[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v, w; };\n\nvector<int> gcd(vector<int> s, vector<int> t) {\n\tint N = s.size(), M = t.size();\n\tif (N < M) return gcd(t, s);\n\tif (!M) return s;\n\trep(j, M) s[j] ^= t[j];\n\tint l = N;\n\trep(i, N) if (s[i]) {\n\t\tl = min(l, i);\n\t\tbreak;\n\t}\n\tvector<int> a(N - l);\n\trep(i, N - l) a[i] = s[l + i];\n\treturn gcd(t, a);\n}\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n >>= 1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint N; cin >> N;\n\tstring s; cin >> s;\n\tvector<string> a(N);\n\trep(i, N) cin >> a[i];\n\tvector<int> d;\n\trep(i, N) {\n\t\tint M = a[i].length();\n\t\tvector<int> b(M);\n\t\trep(j, M) b[j] = a[i][j] - '0';\n\t\td = gcd(d, b);\n\t}\n\tint n = s.length();\n\tvector<int> c(n), _c(n);\n\trep(i, n) c[i] = s[i] - '0';\n\tint m = d.size();\n\tint ans = 1;\n\tfor (int i = 0; i + m <= n; i++) {\n\t\tif (c[i]) ans = (ans + pow_mod(2, n - m - i, MOD)) % MOD;\n\t\tif (c[i] == _c[i]) continue;\n\t\trep(j, m) _c[i + j] ^= d[j];\n\t}\n\tbool ok = true;\n\tif (_c >= c) ok = false;\n\tif (ok) ans = (ans + 1) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\nconst uint mod=998244353;\n//const uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nconst int L=4000;\n//const int L=5;\n//const int L=10;\nusing B=bitset<L>;\n\nB basis[L];\nbool has[L];\nint rem=L;\n\nvc<B> qs;\n\nvoid ad(B b){\n\tper(i,L){\n\t\tif(b[i]){\n\t\t\tif(has[i]){\n\t\t\t\tb^=basis[i];\n\t\t\t}else{\n\t\t\t\trem--;\n\t\t\t\thas[i]=1;\n\t\t\t\tbasis[i]=b;\n\t\t\t\tif(i<L-1)\n\t\t\t\t\tqs.pb(b<<1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tB x;cin>>x;\n\t\n\trep(_,n){\n\t\tB b;cin>>b;\n\t\tqs.pb(b);\n\t}\n\twhile(rem&&qs.size()){\n\t\tB b=qs.back();qs.pop_back();\n\t\tad(b);\n\t}\n\t\n\tper(i,L)if(has[i]){\n\t\tdmp(basis[i]);\n\t}\n\t\n\tmint p=1,q;\n\tB cur;\n\tper(i,L){\n\t\tif(has[i]){\n\t\t\tq*=2;\n\t\t\tif(x[i]){\n\t\t\t\tif(cur[i]){\n\t\t\t\t\tq+=p;\n\t\t\t\t}else{\n\t\t\t\t\tq+=p;\n\t\t\t\t\tcur^=basis[i];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(cur[i]){\n\t\t\t\t\tcur^=basis[i];\n\t\t\t\t}else{\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(x[i]){\n\t\t\t\tif(cur[i]){\n\t\t\t\t}else{\n\t\t\t\t\tq+=p;\n\t\t\t\t\tp=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(cur[i]){\n\t\t\t\t\tp=0;\n\t\t\t\t}else{\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<p+q<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\ninline int deg(const bitset <N> &b) {\n  int t = N - 1;\n  while (t >= 0 && !b[t]) t --;\n  return t + 1;\n}\n\nint n;\nchar buf[N];\n\ninline void read(bitset <N> &b) {\n  scanf(\"%s\", buf);\n  reverse(buf, buf + strlen(buf));\n  for (int i = 0; buf[i]; i ++)\n    b[i] = (bool)(buf[i] - '0');\n}\n\nbitset <N> X, A[10];\n\ninline bitset <N> gcd(bitset <N> p, bitset <N> q) {\n  int a = deg(p);\n  int b = deg(q);\n  while (true) {\n    if (!a) return q;\n    if (!b) return p;\n    if (a < b) {\n      swap(p, q); swap(a, b);\n    }\n    p ^= q << (a - b);\n    while (a >= 0 && p[a] == 0) a --;\n    a ++;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  read(X);\n  for (int i = 1; i <= n; i ++) read(A[i]);\n  for (int i = 2; i <= n; i ++)\n    A[1] = gcd(A[1], A[i]);\n  int ans = 0, j = deg(A[1]);\n  for (int i = deg(X) - 1; i >= j - 1; i --) \n    ans = ((ans << 1) + X[i]) % mod;\n  for (int i = deg(X) - 1; i >= j; i --)\n    if (X[i]) X ^= A[1] << (i - j);\n  for (int i = j - 1; ~ i; i --)\n    if (A[1][i] != X[i]) {\n      if (A[1][i] > X[i]) ans --;\n      break;\n    }\n  ans = (ans + 1) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<bitset>\n#include<string>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\ntypedef bitset<4096>bi;\nbi gcd(bi a, bi b)\n{\n\tbi emp;\n\tif (a == emp)return b;\n\tif (b == emp)return a;\n\tint la = 0, lb = 0;\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tif (a[i])la = i;\n\t\tif (b[i])lb = i;\n\t}\n\tfor (;;)\n\t{\n\t\tif (la < lb)swap(la, lb), swap(a, b);\n\t\ta ^= b << (la - lb);\n\t\tbool f = false;\n\t\tfor (int i = la; i >= 0; i--)\n\t\t{\n\t\t\tif (a[i])\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tla = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!f)return b;\n\t}\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tstring s;\n\tcin >> s;\n\treverse(s.begin(), s.end());\n\tbi mok;\n\tfor (int i = 0; i < s.size(); i++)mok[i] = (s[i] == '1');\n\tbi g;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tbi b;\n\t\tstring z;\n\t\tcin >> z;\n\t\treverse(z.begin(), z.end());\n\t\tfor (int i = 0; i < z.size(); i++)b[i] = (z[i] == '1');\n\t\tg = gcd(g, b);\n\t}\n\tint x = 0;\n\tfor (int i = 0; i < 4096; i++)if (g[i])x = i;\n\tll ans = 0;\n\tfor (int i = 4095; i >= x; i--)\n\t{\n\t\tans *= 2;\n\t\tans += mok[i];\n\t\tans %= mod;\n\t}\n\tbi r;\n\tfor (int i = 4095; i >= x; i--)\n\t{\n\t\tif (r[i] != mok[i])r ^= g << (i - x);\n\t}\n\tfor (int i = x - 1; i >= 0; i--)\n\t{\n\t\tif (r[i] == mok[i])continue;\n\t\tif (r[i] < mok[i])ans = (ans + 1) % mod;\n\t\tbreak;\n\t}\n\tif (r == mok)ans = (ans + 1) % mod;\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mxlen=4000;\ntypedef bitset<mxlen> bs;\nbitset<mxlen> x,a[7];\nbs gcd(bs& a,bs& b)\n{\n    //dbg(a,b);\n    int la=-1,lb=-1;\n    for(int i=0;i<4000;i++) \n    {\n        if(a[i]) la=i;\n        if(b[i]) lb=i;\n    }\n    if(lb>la) swap(a,b);\n    if(lb==-1) return a;\n    a^=(b<<(la-lb));\n    return gcd(a,b);\n}\nconst int maxn=1e5+7;\nconst int mod=998244353;\nll two[maxn];\nint main()\n{\n    int n;\n    cin>>n;\n    string s;\n    cin>>s;\n    int mx=s.length()-1;\n    for(int i=s.length()-1;i>=0;i--)\n        x[s.length()-1-i]=s[i]=='1';\n    //dbg(x);\n    bs g;\n    for(int i=0;i<n;i++)\n    {\n        cin>>s;\n        for(int j=s.length()-1;j>=0;j--)\n            a[i][s.length()-1-j]=s[j]=='1';\n        g=gcd(g,a[i]);\n    }\n    //dbg(g);\n    int lg=-1;\n    for(int i=0;i<mxlen;i++) if(g[i]) lg=i;\n    //dbg(mx,lg);\n    two[0]=1;\n    for(int i=1;i<maxn;i++) two[i]=two[i-1]*2%mod;\n    ll ans=1;\n    bs last;\n    for(int i=mx;i>=lg;i--)\n    {\n        if(x[i]) \n            ans=(ans+two[i-lg])%mod;\n        if(x[i]^last[i]) last^=g<<(i-lg); \n    }\n    for(int i=mx;i>=0;i--)\n    {\n        if(x[i]>last[i])\n            break;\n        if(x[i]<last[i]) \n        {\n            ans--;\n            break;\n        }\n    }\n    print(ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nusing bits = bitset<4000>;\n\nint main() {\n\n  auto bitlen = [](const bits& a) {\n    for(i64 j = 4000; j --> 0;) {\n      if(a[j]) {\n        return j + 1;\n      }\n    }\n    return 0ll;\n  };\n\n  i64 N;\n  cin >> N;\n  bits X;\n  i64 xs;\n  cin >> X;\n  xs = bitlen(X);\n\n  vector<bits> A(N);\n  vector<i64> S(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    S[i] = bitlen(A[i]);\n  }\n  auto bitmod = [](bits a, i64 as, bits b, i64 bs) {\n    for(i64 i = as - bs + 1; i --> 0;) {\n      if(a[i + bs - 1]) {\n        a ^= (b << i);\n      }\n    }\n    return a;\n  };\n\n  auto bitgcd = [&](bits a, i64 as, bits b, i64 bs) {\n    while(b.any()) {\n      auto m = bitmod(a, as, b, bs);\n      a = b;\n      as = bs;\n      b = m;\n      bs = bitlen(b);\n    }\n    return pair<bits, i64>(a, as);\n  };\n\n  auto g = A[0];\n  auto gs = S[0];\n  for(i64 i = 1; i < N; i++) {\n    auto p = bitgcd(g, gs, A[i], S[i]);\n    g = p.first;\n    gs = p.second;\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(xs - gs + 1 >= 0) {\n    vector<i64> Bs(xs - gs + 1, 1);\n    for(i64 i = 1; i < xs - gs + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = xs - gs + 1; i --> 0;) {\n      if(X[i + gs - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + gs - 1] != X[i + gs - 1]) {\n        now ^= (g << i);\n      }\n    }\n    for(i64 i = 4000; i --> 0; ) {\n      if(now[i] != X[i]) {\n        if(X[i]) {\n          ans = (ans + 1);\n        }\n        break;\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nconst int L = 4005;\nconst int N = 4000;\nconst int mo = 998244353;\n\nbitset<L>a[N],Lim;\nint n;\nint key[N];\nLL mi[L];\n\nvoid getbit(bitset<L> &a){\n\tchar s[L];\n\tscanf(\"%s\",s+1);\n\tint len=strlen(s+1);\n\tfo(i,0,len-1)a[i]=s[len-i]-'0';\n}\n\nbitset<L> trs(bitset<L> a,bitset<L> b){\n\tint wa,wb;\n\tfd(i,4000,0)if (a[i]){wa=i;break;}\n\tfd(i,4000,0)if (b[i]){wb=i;break;}\n\tif (wa<wb)swap(a,b),swap(wa,wb);\n\twhile(wb>-1){\n\t\ta=a^(b<<(wa-wb));\n\t\tbool fd=0;\n\t\tfd(i,wa,0)if (a[i]){wa=i;fd=1;break;}\n\t\tif (!fd)wa=-1;\n\t\tswap(a,b),swap(wa,wb);\n\t}\n\treturn a;\n}\n\nint main(){\n\tmi[0]=1;\n\tfo(i,1,4000)mi[i]=mi[i-1]*2%mo;\n\tscanf(\"%d\",&n);\n\tgetbit(Lim);\n\tfo(i,1,n)getbit(a[i]);\n\tint n_=0;\n\tfo(i,1,n){\n\t\tfo(j,1,i-1)\n\t\tif (a[i][key[j]])a[i]=a[i]^a[j];\n\t\tint w=-1;\n\t\tfd(x,4000,0)if (a[i][x]){w=x;break;}\n\t\tkey[i]=w;\n\t\tif (w!=-1){\n\t\t\tkey[++n_]=w;\n\t\t\ta[n_]=a[i];\n\t\t}\n\t}\n\tn=n_;\n\tint pre=0;\n\tfor(bool pd=1;pd;){\n\t\tint pn=n;\n\t\tpd=0;\n\t\tint w=(pre==0)?n:pre;\n\t\tfo(i,1,w)\n\t\t\tfo(j,pre+1,pn)\n\t\t\tif (i!=j){\n\t\t\t\tbitset<L> now=trs(a[i],a[j]);\n\t\t\t\tfo(p,1,n)\n\t\t\t\tif (now[key[p]])now=now^a[p];\n\t\t\t\tif (now.count()>0){\n\t\t\t\t\ta[++n]=now;\n\t\t\t\t\tkey[n]=0;\n\t\t\t\t\tfd(x,4000,0)if (now[x]){key[n]=x;break;}\n\t\t\t\t}\n\t\t\t}\n\t\tpre=pn;\n\t}\n\tint keyw=1;\n\tfo(i,2,n)\n\tif (key[i]<key[keyw])keyw=i;\n\tint w=0;\n\tfd(i,4000,0)\n\tif (Lim[i]){w=i;break;}\n\tLL ans=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i])ans=(ans+mi[i-key[keyw]])%mo;\n\tbitset<L>now;\n\tfo(i,0,4000)now=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i]!=now[i])now=now^(a[keyw]<<(i-key[keyw]));\n\tint prefer=1;\n\tfd(i,key[keyw],0)\n\tif (Lim[i]!=now[i]){\n\t\tif (now[i]>Lim[i])prefer=0;\n\t\tbreak;\n\t}\n\tans=(ans+prefer)%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, i,j, s;\nint main()\n{\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\ts += i *j;\n\t\t}\n\t}\n\tcout << s;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353;\n\nll n;\nvector<bool> x;\nvector<bool> a,b;\n\nvoid mns(){\n    for(ll i=(int)a.size()-1;i>=(int)b.size()-1;i--){\n        if(a[i]==1){\n            for(int t=0;t<b.size();t++){\n                a[i-t]=a[i-t]^b[b.size()-t-1];\n            }\n        }\n    }\n    while(!a.empty() && a.back()==0){a.pop_back();}\n    swap(a,b);\n}\n\n\n\n\n\n\n\n\nint main(){\n    vector<ll> P(100000,1);\n    for(ll i=1;i<P.size();i++){P[i]=P[i-1]*2%MOD;}\n    cin>>n;\n    string X;\n    cin>>X;\n    reverse(X.begin(),X.end());\n    x.resize(X.size());\n    for(int i=0;i<X.size();i++){\n        x[i]=X[i]-'0';\n    }\n    string A;\n    cin>>A;\n    reverse(A.begin(),A.end());\n    a.resize(A.size());\n    for(int i=0;i<A.size();i++){\n        a[i]=A[i]-'0';\n    }\n    for(int i=1;i<n;i++){\n        string B;\n        cin>>B;\n        reverse(B.begin(),B.end());\n        b.resize(B.size());\n        for(int i=0;i<B.size();i++){\n            b[i]=B[i]-'0';\n        }\n        if(a.size()<b.size()){swap(a,b);}\n        while(b.size()){mns();}\n    }\n    ll ans=1;\n    vector<bool> Z(x.size(),false);\n    for(ll i=(int)x.size()-1;i>=(int)a.size()-1;i--){\n        if(x[i]){\n            ans+=P[i-(a.size()-1)];\n            if(Z[i]==0){\n                for(int t=0;t<a.size();t++){\n                    Z[i-t]=Z[i-t]^a[a.size()-1-t];\n                }\n            }\n        }\n        else{\n            if(Z[i]){\n                for(int t=0;t<a.size();t++){\n                    Z[i-t]=Z[i-t]^a[a.size()-1-t];\n                }\n            }\n        }\n    }\n    cout<<ans%MOD<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\n#define N_bit 4000\nusing bin = bitset<N_bit>;\nbin gcd(bin a, bin b){\n    int na = 0, nb = 0;\n    while(true){\n        while(na < N_bit && a[N_bit - 1 - na] == 0) na++;\n        while(nb < N_bit && b[N_bit - 1 - nb] == 0) nb++;\n        if(na > nb){\n            swap(a, b);\n            swap(na, nb);\n        }\n        if(nb == N_bit) return a;\n\n        a ^= b << (nb - na);\n    }\n}\n\nbool compare(bin a, bin b){\n    IREP(i, N_bit){\n        if(a[i] == 0 && b[i] == 1) return true;\n        if(a[i] == 1 && b[i] == 0) return true;\n    }\n    return true;\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    string X; cin >> X;\n    vector<string> A(N); cin >> A;\n\n    bin x(X);\n    vector<bin> a(N);\n    REP(i, N) a[i] = bin(A[i]);\n    bin g = a[0];\n    FOR(i, 1, N){\n        g = gcd(g, a[i]);\n    }\n\n    int nx = 0, ng = 0;\n    while(nx < N_bit && x[N_bit - 1 - nx] == 0) nx++;\n    while(ng < N_bit && g[N_bit - 1 - ng] == 0) ng++;\n\n    nx = N_bit - nx;\n    ng = N_bit - ng;\n    if(nx < ng){\n        Out(1);\n        return 0;\n    }\n\n    mint ans = 0;\n    bin t(0);\n    REP(i, nx - ng + 1){\n        if(x[nx - 1 - i] == 1){\n            if(t[nx - 1 - i] == 0){\n                ans += pow((mint)2, nx - ng - i);\n                t ^= g << (nx - ng - i);\n            }else{\n                ans += pow((mint)2, nx - ng - i);\n            }\n        }else if(x[nx - 1 - i] == 0){\n            if(t[nx - 1 - i] == 1){\n                t ^= g << (nx - ng - i);\n            }\n        }\n    }\n    if(compare(t, x)) ans += 1;\n    Out(ans - 1);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\nvector<bool> input(){\n\tstring s;\n\tcin>>s;\n\tint N = s.size();\n\tvector<bool> x(N);\n\trep(i,N) x[i] = s[i]=='1';\n\treturn x;\n}\nvoid normalize(vector<bool>& a){\n\tvector<bool> b;\n\tint N = a.size();\n\tbool yet = 1;\n\trep(i,N){\n\t\tif(a[i]){\n\t\t\tyet = 0;\n\t\t}\n\t\tif(!yet) b.pb(a[i]);\n\t}\n\ta = b;\n}\nvector<bool> gcd(vector<bool> a,vector<bool> b){\n\tnormalize(a);\n\tnormalize(b);\n\tint N = a.size(), M = b.size();\n\tif(N<M) swap(a,b),swap(N,M);\n\n\tif(M==0) return a;\n\n\trep(i,M) a[i] = a[i] ^ b[i];\n\treturn gcd(a,b);\n}\n\nint N;\nint main(){\n\tcin>>N;\n\tvector<bool> X = input();\n\tvector<bool> g;\n\trep(i,N){\n\t\tvector<bool> f;\n\t\tf = input();\n\t\tg = gcd(g,f);\n\t}\n\tvector<mint> p2(5000);\n\tp2[0] = 1;\n\trep1(i,4999) p2[i] = p2[i-1]*2;\n\n\tmint ans = 1;\n\tvector<bool> oX = X;\n\tint a = X.size();\n\tint b = g.size();\n\trep(i,a-b+1){\n\t\tif(X[i]){\n\t\t\trep(j,b) X[i+j] = X[i+j] ^ g[j];\n\t\t}\n\t\tif(oX[i]){\n\t\t\tans += p2[a-(i+b)];\n\t\t}\n\t}\n\trep(i,a) oX[i] = oX[i] ^ X[i];\n\tif(X>oX) ans += 1;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bitset>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nconst LL MOD = 998244353;\n\nconst int SIZE = 4096;\n//const int SIZE = 16;\nusing Bits = bitset<SIZE>;\nint N;\nBits X, A[6];\nBits B[SIZE];\nchar buf[SIZE];\n\nvoid read(Bits &b) {\n    scanf(\"%s\", buf);\n    b = Bits(buf);\n}\n\nint get_high(const Bits &b) {\n    for (int i=SIZE; i--;) if (b.test(i)) return i;\n    return -1;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    read(X);\n    REP (i, N) read(A[i]);\n\n    REP (i, N) {\n\tBits b = A[i];\n\tint high = get_high(b);\n\n\twhile (0 <= high && high < SIZE) {\n\t    if (B[high].test(high)) {\n\t\tb ^= B[high];\n\t\thigh = get_high(b);\n\t    } else {\n\t\tB[high] = b;\n\t\tb <<= 1;\n\t\thigh++;\n\t    }\n\t}\n    }\n\n    int z = -1;\n    REP (i, SIZE) if (B[i].test(i)) {\n\tz = i;\n\tbreak;\n    }\n\n    LL cnt = 0;\n    Bits ex;\n\n    for (int i=SIZE-1; i>=z; i--) {\n\tcnt *= 2;\n\tif (X.test(i)) {\n\t    cnt += 1;\n\t}\n\tif (cnt >= MOD) cnt -= MOD;\n\n\tif (X.test(i) != ex.test(i)) {\n\t    ex ^= B[z] << (i-z);\n\t}\n    }\n//    REP (i, SIZE) cerr << B[i].to_ullong()<< \" \" << B[i] << endl;\n//    cerr << X << endl;\n//    cerr << ex << endl;\n    bool le = true;\n    for (int i=z; i>=0; i--) {\n\tif (!X.test(i) && ex.test(i)) {\n\t    le = false;\n\t    break;\n\t}\n\tif (X.test(i) && !ex.test(i)) {\n\t    break;\n\t}\n    }\n    if (le) cnt++;\n\n    cnt %= MOD;\n    printf(\"%lld\\n\", cnt);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bitset>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\nbitset <N> x, G, a[10];\nint n;\n\nbitset <N> gcd(bitset <N> A, bitset <N> B)\n{\n    int i = N - 1, j = N - 1;\n    while(1)\n    {\n        for(; ~i && !A[i]; --i);\n        for(; ~j && !B[j]; --j);\n        if (i == -1) return B;\n        if (j == -1) return A;\n        if (i > j) A ^= (B << (i - j));\n            else B ^= (A << (j - i));\n    }\n}\n\nint div(bitset <N> A, bitset <N> B)\n{\n    int i = N - 1, j = N - 1, ans = 0;\n    for(; ~j && ~B[j]; --j);\n    for(; i >= j; --i)\n    {\n        if (A[i])\n        {\n            A ^= B << (j - i);\n            ans = (ans * 2 + 1) % mod;\n        }\n        else ans = ans * 2 % mod;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> x;\n    FOR(i, 1, n) cin >> a[i];\n    G = a[1];\n    FOR(i, 2, n) G = gcd(G, a[i]);\n    printf(\"%d\\n\", (div(x, G) + 1) % mod);\n    return 0;\n}\n;\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<bitset>\n#define BS 4096\nusing namespace std;\nbitset<4096>w[6], X, G, TP;\nint n, GL, Mod = 998244353, po[4096];\nchar p[4096];\nvoid Put(bitset<4096> &TP, char *key) {\n\tint i, L;\n\tfor (i = 0; key[i]; i++);\n\tL = i;\n\tfor (i = 0; i < L; i++) {\n\t\tTP[L - i - 1] = key[i]-'0';\n\t}\n}\nint Len(bitset<4096> &TP) {\n\tint j;\n\tfor (j = BS - 1; j >= 0; j--) {\n\t\tif (G[j])break;\n\t}\n\treturn j+1;\n}\nint main() {\n\tint i, j;\n\tpo[0] = 1;\n\tfor (i = 1; i <= 4000; i++)po[i] = po[i - 1] * 2 % Mod;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tPut(X, p);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%s\", p);\n\t\tPut(w[i], p);\n\t}\n\tG = w[0];\n\twhile (1) {\n\t\tint ck = 0;\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tTP = w[i];\n\t\t\tGL = Len(G);\n\t\t\tfor (j = BS - 1; j >= GL - 1; j--) {\n\t\t\t\tif (TP[j]) {\n\t\t\t\t\tTP ^= G << (j + 1 - GL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = BS - 1; j >= 0; j--)if (TP[j])break;\n\t\t\tif (j != -1) {\n\t\t\t\tck = 1;\n\t\t\t\tG = TP;\n\t\t\t}\n\t\t}\n\t\tif (!ck)break;\n\t}\n\tGL = Len(G);\n\tlong long res = 0;\n\tfor (i = BS - 1; i >= GL - 1; i--) {\n\t\tif (X[i]) {\n\t\t\tres = (res + po[i - (GL - 1)]) % Mod;\n\t\t}\n\t\tif (TP[i] != X[i]) {\n\t\t\tTP ^= G << (i + 1 - GL);\n\t\t}\n\t}\n\tint ck = 0;\n\tfor (i = BS - 1; i >= 0; i--) {\n\t\tif (X[i] != TP[i]) {\n\t\t\tif (TP[i]) ck = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tres = (res + 1 - ck) % Mod;\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nvoid div(string &m, const string &n)\n{\n\tint i = 0;\n\tfor (; i < m.length(); i++) {\n\t\tif (~m[i] & 1) continue;\n\t\tif (i + n.length() > m.length())\n\t\t\tbreak;\n\t\tfor (int j = 1; j < n.length(); j++)\n\t\t\tm[i + j] ^= n[j] & 1;\n\t}\n\tm = m.substr(i);\n}\n\nvoid gcd(string &m, string &n)\n{\n\tfor (; !n.empty(); m.swap(n))\n\t\tdiv(m, n);\n}\n\nint main()\n{\n\tint N, a = 0;\n\tstring X, A, B;\n\tcin >> N >> X;\n\twhile (N--) {\n\t\tcin >> B;\n\t\tgcd(A, B);\n\t}\n\tfor (int i = 0; i + A.length() <= X.length(); i++)\n\t\ta = (a * 2 | X[i] & 1) % 998244353;\n\tstring Y = X;\n\tdiv(Y, A);\n\tcout << (a + (!Y.length() || X.length() >= Y.length() && X[X.length() - Y.length()] & 1)) % 998244353 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\ntypedef bitset<4000> b4000;\n\nconst int MOD = 998244353;\n\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint pow2[4444];\nb4000 cyc[4001];\nint dp[4111];\nint curmin;\nb4000 smallest;\n\nint getmx(b4000 &x)\n{\n\tfor(int i=3999;i>=0;i--)\n\t{\n\t\tif(x[i]) return i;\n\t}\n\treturn -1;\n}\n\nvoid solve(vector<b4000> &vec)\n{\n\tint n=vec.size();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\twhile(vec[i].count()>0&&vec[j].count()>0)\n\t\t\t{\n\t\t\t\t//cerr<<vec[i].count()<<' '<<vec[j].count()<<'\\n';\n\t\t\t\tint i2=i; int j2=j;\n\t\t\t\tint siz1=getmx(vec[i]); int siz2=getmx(vec[j]);\n\t\t\t\tif(siz1<siz2) \n\t\t\t\t{\n\t\t\t\t\tswap(i2,j2); swap(siz1,siz2);\n\t\t\t\t}\n\t\t\t\tvec[i2] = (vec[i2]^(vec[j2]<<(siz1-siz2)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\t//cerr<<i<<' '<<vec[i].count()<<'\\n';\n\t\tif(!vec[i].count()) continue;\n\t\tsmallest=vec[i];\n\t\treturn ;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tpow2[0]=1;\n\tfor(int i=1;i<=4440;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t}\n\tint n; string s; cin>>n>>s;\n\tvector<b4000> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tstring z; cin>>z;\n\t\tb4000 tmp; tmp.reset();\n\t\treverse(z.begin(),z.end());\n\t\tfor(int j=0;j<z.length();j++)\n\t\t{\n\t\t\tif(z[j]=='1') tmp.set(j,1);\n\t\t}\n\t\tvec.pb(tmp);\n\t}\n\tsolve(vec);\n\t//cerr<<smallest<<'\\n';\n\tfor(int i=3999;i>=0;i--)\n\t{\n\t\tif(smallest[i])\n\t\t{\n\t\t\tcyc[i]=smallest;\n\t\t\tfor(int j=i+1;j<4000;j++)\n\t\t\t{\n\t\t\t\tsmallest<<=1;\n\t\t\t\tcyc[j]=smallest;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tb4000 cur; cur.reset();\n\tb4000 tmp;\n\tdp[0]=(cyc[0].count()>0?1:0);\n\tfor(int i=1;i<4000;i++)\n\t{\n\t\tif(cyc[i].count()>0) dp[i]=1;\n\t\tdp[i]+=dp[i-1];\n\t}\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tif(s[i]=='1') tmp.set(int(s.length())-1-i,1);\n\t}\n\tint ans=0;\n\tfor(int i=int(s.length())-1;i>=0;i--)\n\t{\n\t\tif(tmp[i])\n\t\t{\n\t\t\tif(cur[i])\n\t\t\t{\n\t\t\t\tif(cyc[i].count()>0)\n\t\t\t\t{\n\t\t\t\t\tint v=1;\n\t\t\t\t\tif(i-1>=0) v=pow2[dp[i-1]];\n\t\t\t\t\tans=add(ans,v);\n\t\t\t\t}\n\t\t\t\tif(i==0) ans++;\n\t\t\t\t//otherwise proceed as usual\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint v=1;\n\t\t\t\tif(i-1>=0) v=pow2[dp[i-1]];\n\t\t\t\tans=add(ans,v);\n\t\t\t\tif(cyc[i].count()==0) break;\n\t\t\t\tif(i==0) ans++;\n\t\t\t\tcur^=cyc[i];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(cur[i])\n\t\t\t{\n\t\t\t\tif(cyc[i].count()>0)\n\t\t\t\t{\n\t\t\t\t\tif(i==0) ans++;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcur^=cyc[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==0) ans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nusing bits = bitset<5000>;\n\nint main() {\n\n  auto bitlen = [](const bits& a) {\n    for(i64 j = 5000; j --> 0;) {\n      if(a[j]) {\n        return j + 1;\n      }\n    }\n    return 0ll;\n  };\n\n  i64 N;\n  cin >> N;\n  bits X;\n  i64 xs;\n  cin >> X;\n  xs = bitlen(X);\n\n  vector<bits> A(N);\n  vector<i64> S(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    S[i] = bitlen(A[i]);\n  }\n  auto bitmod = [](bits a, i64 as, bits b, i64 bs) {\n    for(i64 i = as - bs + 1; i --> 0;) {\n      if(a[i + bs - 1]) {\n        a ^= (b << i);\n      }\n    }\n    return a;\n  };\n\n  auto bitgcd = [&](bits a, i64 as, bits b, i64 bs) {\n    while(b.any()) {\n      auto m = bitmod(a, as, b, bs);\n      a = b;\n      as = bs;\n      b = m;\n      bs = bitlen(b);\n    }\n    return pair<bits, i64>(a, as);\n  };\n\n  auto g = A[0];\n  auto gs = S[0];\n  for(i64 i = 1; i < N; i++) {\n    auto p = bitgcd(g, gs, A[i], S[i]);\n    g = p.first;\n    gs = p.second;\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(xs - gs + 1 >= 0) {\n    vector<i64> Bs(xs - gs + 1, 1);\n    for(i64 i = 1; i < xs - gs + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = xs - gs + 1; i --> 0;) {\n      if(X[i + gs - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + gs - 1] != X[i + gs - 1]) {\n        now ^= (g << i);\n      }\n    }\n    bool OK = true;\n    for(i64 i = 5000; i --> 0; ) {\n      if(now[i] != X[i]) {\n        if(now[i]) {\n          ans = (ans + 1);\n          OK = false;\n        }\n        break;\n      }\n    }\n    if(OK) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 7,Len = 4000 + 10,mod = 998244353;\n\nchar str[Len];\ntypedef bitset <Len> Bs;\nbool X[Len],A[N][Len],Gcd[Len],cur[Len],Mul[Len];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Getstr(bool S[]) {\n\tscanf(\"%s\",str);\n\tint len = strlen(str);\n\treverse(str,str + len);\n\tFor(i,0,len - 1) S[i] = str[i] - '0';\n}\n\ninline int Length(bool a[]) {\n\tFordown(i,Len - 1,0) if(a[i]) return i;\n\treturn 0;\n}\n\ninline void Plus(bool a[],bool b[],int Delta) {\n\tFor(i,Delta,Len - 1) a[i] = a[i] ^ b[i - Delta];\n}\n\ninline void gcd(bool a[],bool b[],bool c[]) {\n\tint Lena = Length(a),Lenb = Length(b);\n\tif(Lena < Lenb) swap(a,b),swap(Lena,Lenb);\n\tif(Lenb == 0 && b[0] == 0) { For(i,0,Len - 1) c[i] = a[i]; return; }\n\tPlus(a,b,Lena - Lenb);\n\tgcd(b,a,c);\n}\n\nint main() {\n\tint n = read();Getstr(X);\n\tFor(i,1,n) Getstr(A[i]);\n\tFor(i,1,n) {\n\t\tFor(j,0,Length(Gcd)) cur[j] = Gcd[j];\n\t\tgcd(A[i],cur,Gcd);\n\t}\n\tint ans = 0,LenG = Length(Gcd);\n\tFordown(i,Length(X),LenG) ans = ((ans << 1) + X[i]) % mod;\n\tFordown(i,Length(X),LenG) if(Mul[i] ^ X[i]) Plus(Mul,Gcd,i - LenG);\n\n\tFordown(i,LenG - 1,0) {\n\t\tif(Mul[i] < X[i]) break;\n\t\tif(Mul[i] > X[i]) { ans--;break; }\n\t}\n\n\tprintf(\"%d\\n\",ans + 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2018-05-06 20:54:33\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst ll mod=(ll)998244353;\nconst int N=4005;\ntypedef bitset<N> oo;\nbitset<N> an[11],x,gd;\nint clz(oo &a){\n    int l=1,r=a.size(),mid,ans=0;\n    while(l<=r){\n        mid=(l+r)>>1;\n        if((a>>(N-mid)).none()){\n            ans=mid;\n            l=mid+1;\n        } else r=mid-1;\n    }\n    return ans;\n}\noo gcd(oo a,oo b){\n    oo *x=&a,*y=&b;\n    int dx=N-clz(*x),dy=N-clz(*y);\n    if(dx<dy){\n        swap(dx,dy);\n        swap(x,y);\n    }\n    if(y->none())return *y;\n    oo res=gcd((*x)^((*y)<<(dx-dy)),*y);\n    if(res.none())return *y;\n    return res;\n}\nbool operator<=(const oo &a, const oo &b){\n    int l=1,r=a.size(),mid,ans=0;\n    while(l<=r){\n        mid=(l+r)>>1;\n        if((a>>(N-mid))==(b>>(N-mid))){\n            ans=mid;\n            l=mid+1;\n        }else r=mid-1;\n    }\n    if(ans==a.size())return 1;\n    return a[N-ans-1]<=b[N-ans-1];\n}\noo divide(oo a,oo b){\n    int da,db;\n    while(b<=a){\n        da=N-clz(a);\n        db=N-clz(b);\n        a^=b<<(da-db);\n    }\n    return a;\n}\nint main(){\n    int n;cin>>n;\n    string s;cin>>s;\n    x=bitset<N>(s);\n    rep(i,0,n){\n        cin>>s;an[i]=bitset<N>(s);\n    }\n    gd=an[0];\n    rep(i,1,n){\n        gd=gcd(gd,an[i]);\n    }\n    // OUT(gd.to_string());\n    int d=N-clz(gd),m=N-clz(x);\n    string sx=x.to_string();\n    reverse(all(sx));\n    ll ans=0;\n    per(i,m,d-1){ \n        if(sx[i]=='1'){\n            ans+=powmod(2,i-d+1,mod);\n        }\n    }\n    oo yu=divide(x,gd),tmp=x^yu;\n    assert(divide(tmp,gd).none());\n    if(tmp<=x)ans++;\n    ans%=mod;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int N, lb, a, z;\nbitset<4444> A[7], X, Y, Z;\nchar s[4444];\n\ntemplate <size_t N>\nlong long to_modllong(bitset<N> n){\n    long long ret = 0;\n    for(int i = N; --i >= 0;ret += n[i]){\n        ret <<= 1;\n        ret %= 998244353;\n    }\n    return ret;\n}\n\ntemplate <typename T>\nstatic inline T gcd(T u, T v){\n    int sftu = 0, sftv = 0;\n    T t;\n    if(u.none()) return v;\n    if(v.none()) return u;\n    while(!u[0]){\n        ++sftu;\n        u >>= 1;\n    }\n    while(!v[0]){\n        ++sftv;\n        v >>= 1;\n    }\n    sftu = min(sftu, sftv);\n    do{\n        while(!v[0])v >>= 1;\n        swap(u, v);\n        v = v ^ u;\n    }while(v.any());\n    return u << sftu;\n}\n\nint main(){\n    scanf(\"%lld %s\", &N, s);\n    X = bitset<4444>(s);\n    Z = X;\n    for(int i = 0; i < N; ++i){\n        scanf(\" %s\", s);\n        A[i] = bitset<4444>(s);\n    }\n    Y = A[0];\n    for(int i = 1; i < N; ++i)Y = gcd(A[i], Y);\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (lb = i))break;\n    for(int i = 4443 - lb; i >= 0; --i){\n        if(X[i + lb]){\n            X ^= Y << i;\n            A[6] ^= Y << i;\n        }\n    }\n    long long d = 0;\n    Y = A[6] ^ Z;\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (d = i))break;\n    cout << (to_modllong(Z >> lb) + (!d || Z[d])) % 998244353 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ayy\n// ' lamo\n// SUBLIME HAX\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\n// const int P=1e9+7;\n\n\n\n\n\nconst int N=4096;\n// const int N=12;\nint n;\ntypedef bitset<N> BS;\nBS X,A[6],Y,Q;\nvoid read(BS &bs) {\n\tstring s; cin>>s;\n\treverse(s.begin(),s.end());\n\tfor(int i=0;i<sz(s);i++) bs[i]=int(s[i]=='1');\n}\nbool operator<(const BS &L,const BS &R) {\n\tfor(int i=N;--i>=0;) if(L[i]!=R[i]) return L[i]<R[i];\n\treturn 0;\n}\nint len(const BS &bs) {\n\tfor(int i=N;--i>=0;) if(bs[i]) return i+1;\n\treturn 0;\n}\n\nint h[6];\nvoid rref() {\n\tfor(int i=0;i<n;i++) h[i]=len(A[i])-1;\n\tQ=A[min_element(h,h+n)-h];\n\tint w=len(Q)-1;\n\tfor(;;) {\n\t\tfor(int i=0;i<n;i++) {\n\t\t\t// dbg(w,i,h[i]);\n\t\t\tassert(w <= h[i]);\n\t\t\tif(A[i] != Q<<(h[i]-w)) {\n\t\t\t\tA[i] ^= Q<<(h[i]-w);\n\t\t\t\th[i]=len(A[i])-1;\n\t\t\t\tif(h[i]<w) w=h[i], Q=A[i];\n\t\t\t\tgoto win;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\twin:;\n\t}\n}\n\n\n\nconst int P=998244353;\nint powq(int x,int e) {\n\tif(!e) return 1;\n\tif(e&1) return int(1LL*x*powq(x,e-1)%P);\n\tx=powq(x,e>>1);\n\treturn int(1LL*x*x%P);\n}\n\n\nint32_t main() {\n\tcin>>n;\n\tread(X);\n\tfor(int i=0;i<n;i++) read(A[i]);\n\trref();\n\t// dbg(Q);\n\n\tint w=len(Q); assert(w>0);\n\tint m=len(X); assert(m>0);\n\tY.reset();\n\tif(w>m) return cout<<1<<endl,0;\n\tll Z=0;\n\tfor(int i=m-1;i>=w-1;i--) {\n\t\t// dbg(i,X,Y,i-(w-1));\n\t\tif(X[i]) Z+=powq(2,i-(w-1));\n\t\tif(X[i] != Y[i]) Y^=Q<<(i-(w-1));\n\t}\n\t++Z;\n\tcout<<Z%P<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nconst int N=4000;\nbitset<N>x,a[5],g,t,c;\nchar str[N*2];\ninline void read(bitset<N> &bit) {\n\tscanf(\"%s\",str);\n\tint n=strlen(str)-1;\n\tfor (int i=0;i<=n;i++)\n\t\tbit[i]=str[n-i]-'0';\n}\ninline int deg(bitset<N> &bit) {\n\tfor (int i=N;i--;) if (bit[i]) return i;\n\treturn 0;\n}\nint p[N];\nint main()\n{\n\tint n=gi()-1,i,k,low;\n\tconst int mod=998244353;\n\tread(x);read(g);\n\tfor (i=0;i<n;i++) {\n\t\tread(t);\n\t\twhile (1) {\n\t\t\tif (deg(g)<deg(t)) swap(g,t);\n\t\t\tlow=deg(t);\n\t\t\tfor (k=deg(g);k>=low;k--)\n\t\t\t\tif (g[k])\n\t\t\t\t\tg^=t<<(k-low);\n\t\t\tif (g.none()) { g=t; break; }\n\t\t}\n\t}\n\tfor (i=p[0]=1;i<N;i++) p[i]=(p[i-1]<<1)%mod;\n\tk=deg(g);\n\tint ans=0;\n\tfor (i=N-1;i>=k;i--) {\n\t\tif (x[i]) (ans+=p[i-k])%=mod;\n\t\tif (x[i]!=c[i]) c^=g<<(i-k);\n\t}\n\tfor (i=k;~i;i--) {\n\t\tif (x[i]>c[i]) break;\n\t\telse if (x[i]<c[i]) { ans--; break; }\n\t}\n\tans++;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar s[4009],X[4009];\nint n,c;\nbitset<4000> a[4000],B,C,B2;\n\n#define mod 998244353\nint add(int x,int y){\n\treturn (x+=y)<mod?x:x-mod;\n}\nint p2[4009];\nint main(){\n\tp2[0] = 1;\n\tfor(int i=1; i<4009; i++)\n\t\tp2[i] = add(p2[i-1],p2[i-1]);\n\n\tint l;\n\tscanf(\"%d%s\",&n,&X);\n\n\tscanf(\"%s\",s);\n\tl = strlen(s);\n\tfor(int i=0; s[i]; i++)if(s[i] == '1')\n\t\ta[l-1].set(l-1-i);\n\twhile(l <= 3999){\n\t\ta[l] = a[l-1] << 1;\n\t\tl++;\n\t}\n\tint lo = l-1;\n\tfor(int i=1; i<n; i++){\n\t\tscanf(\"%s\",s);\n\t\tl = strlen(s);\n\t\tB.reset();\n\t\tfor(int j=0; s[j]; j++)if(s[j] == '1')\n\t\t\tB.set(l-1-j);\n\t\tfor(int j=l-1; j>=0; j--){\n\t\t\tif(!a[j].test(j)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(B.test(j))\n\t\t\t\tB ^= a[j];\n\t\t}\n\t\tif(B.none())continue;\n\n\t\tC = a[lo];\n\t\tint H = -1;\n\t\tfor(int j=3999; j>=0; j--)if(B.test(j)){\n\t\t\tH = j;\n\t\t\tbreak;\n\t\t}\n\t\tB2 = B << (lo - H);\n\t\twhile(lo >= H){\n\t\t\tif(C.test(lo))\n\t\t\t\tC ^= B2;\n\t\t\tB2 >>= 1;\n\t\t\tlo--;\n\t\t}\n\n\t\tif(!C.none())B = C;\n\n\t\tH = -1;\n\t\tfor(int j=3999; j>=0; j--)if(B.test(j)){\n\t\t\tH = j;\n\t\t\tbreak;\n\t\t}\n\t\ta[H] = B;\n\t\tfor(int j=H+1; j<lo; j++)\n\t\t\ta[j] = a[j-1] << 1;\n\t\tlo = H;\n\t}\n\n\n\tl = strlen(X);\n\tint res = 0;\n\tfor(int i=0;;i++){\n\t\tif(X[i] == '1'){\n\t\t\tif(l-1-i >= lo){\n\t\t\t\tres = add(res, p2[l-1-i-lo]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(X[i] == '0')continue;\n\n\t\tB.reset();\n\t\tfor(int j=0; j<i; j++)if(X[j] == '1')B.set(l-1-j);\n\t\tfor(int j=l-1; j>=lo; j--)if(B.test(j))\n\t\t\tB ^= a[j];\n\t\tbool small = true;\n\t\tfor(int j=i; j<l; j++){\n\t\t\tbool x_bit = (X[j] == '1');\n\t\t\tbool y_bit = B.test(l-1-j);\n\t\t\tif(x_bit != y_bit){\n\t\t\t\tif(!x_bit && y_bit)\n\t\t\t\t\tsmall = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(small)res=add(res,1);\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v, w; };\n\nvector<int> gcd(vector<int> s, vector<int> t) {\n\tint N = s.size(), M = t.size();\n\tif (N < M) return gcd(t, s);\n\tif (!M) return s;\n\trep(j, M) s[j] ^= t[j];\n\tint l = N;\n\trep(i, N) if (s[i]) {\n\t\tl = i;\n\t\tbreak;\n\t}\n\tvector<int> a(N - l);\n\trep(i, N - l) a[i] = s[l + i];\n\treturn gcd(t, a);\n}\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n >>= 1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint N; cin >> N;\n\tstring s; cin >> s;\n\tvector<string> a(N);\n\trep(i, N) cin >> a[i];\n\tvector<int> d;\n\trep(i, N) {\n\t\tint M = a[i].length();\n\t\tvector<int> b(M);\n\t\trep(j, M) b[j] = a[i][j] - '0';\n\t\td = gcd(d, b);\n\t}\n\tint n = s.length();\n\tvector<int> c(n), _c(n);\n\trep(i, n) c[i] = s[i] - '0';\n\tint m = d.size();\n\tint ans = 1;\n\tfor (int i = 0; i + m <= n; i++) {\n\t\tif (c[i]) ans = (ans + pow_mod(2, n - m - i, MOD)) % MOD;\n\t\tif (c[i] == _c[i]) continue;\n\t\trep(j, m) _c[i + j] ^= d[j];\n\t}\n\tbool ok = true;\n\trep(i, n) if (_c[i]) ok = false;\n\tif (ok) ans = (ans + MOD + 1) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n#define MOD 998244353\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\ntypedef bitset<4000> Num;\n\nint N;\nNum X, A[6];\n\nNum in()\n{\n\tchar buf[4040];\n\tscanf(\"%s\", buf);\n\n\tint len = strlen(buf);\n\tNum ret;\n\tfor (int i = 0; i < len; ++i) {\n\t\tif (buf[i] == '1') ret.set(len - 1 - i);\n\t}\n\treturn ret;\n}\n\nint msb(Num a)\n{\n\tfor (int i = 3999; i >= 0; --i) {\n\t\tif (a[i]) return i;\n\t}\n\treturn -1;\n}\n\nNum gcd(Num a, Num b)\n{\n\tfor (;;) {\n\t\tint na = msb(a), nb = msb(b);\n\t\tif (na == -1) return b;\n\t\tif (nb == -1) return a;\n\t\tif (na < nb) {\n\t\t\tb ^= a << (nb - na);\n\t\t} else {\n\t\t\ta ^= b << (na - nb);\n\t\t}\n\t}\n}\n\ni64 toint(Num n)\n{\n\ti64 ret = 0;\n\tfor (int i = 3999; i >= 0; --i) {\n\t\tret = ret * 2 % MOD;\n\t\tret += n[i];\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tX = in();\n\tfor (int i = 0; i < N; ++i) A[i] = in();\n\n\tNum g = A[0];\n\tfor (int i = 1; i < N; ++i) {\n\t\tg = gcd(g, A[i]);\n\t}\n\tint mg = msb(g);\n\ti64 ret = toint(X >> mg);\n\n\tNum waf = X, relka;\n\tfor (int i = 3999; i >= mg; --i) {\n\t\tif (waf[i]) {\n\t\t\twaf ^= g << (i - mg);\n\t\t\trelka ^= g << (i - mg);\n\t\t}\n\t}\n\tbool toolarge = false;\n\tfor (int i = mg - 1; i >= 0; --i) {\n\t\tint xi = X[i];\n\t\tint wi = relka[i];\n\n\t\tif (xi > wi) break;\n\t\tif (xi < wi) {\n\t\t\ttoolarge = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!toolarge) ADD(ret, 1);\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nstring gcd(string s,string t){\n\twhile(s.back()=='0')s.pop_back();\n\twhile(t.back()=='0')t.pop_back();\n\tif(s==t) return s;\n\t\n\tif(s.length()<t.length()){\n\t\treturn gcd(t,s);\n\t}\n\tif(s.length()==t.length()){\n\t\tint l=t.length();\n\t\tfor(int i=0;i<l;i++)if(s[i]=='1'){\n\t\t\tif(t[i]=='1')t[i]='0';\n\t\t\telse t[i]='1';\n\t\t}\n\t\treturn gcd(s,t);\n\t}\n\t{\n\t\tint ls=s.length();\n\t\tint lt=t.length();\n\t\t\n\t\tfor(int i=0;i<lt;i++)if(t[i]=='1'){\n\t\t\tif(s[i+ls-lt]=='1')s[i+ls-lt]--;\n\t\t\telse s[i+ls-lt]++;\n\t\t}\n\t\t\n\t\tbool bo=0;\n\t\tfor(auto c:s)if(c=='1')bo=1;\n\t\tif(!bo) return t;\n\t\treturn gcd(s,t);\n\t\n\t}\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n;\n \tstring x;\n \tcin>>n>>x;\n \treverse(x.begin(),x.end());\n \tstring s;\n \tcin>>s;\n \treverse(s.begin(),s.end());\n \tfor(int i=1;i<n;i++){\n \t\tstring ss;\n \t\tcin>>ss;\n \t\t\n \treverse(ss.begin(),ss.end());\n \t\ts=gcd(s,ss);\n //\t\tcout<<i<<\" \"<<s<<endl;\n \t}\n //\tcout<<s<<endl;\n \tmod=998244353;\n \tint ans=0;\n \t\n \tint l=x.length();\n \t\n \tint r=s.length();\n \t\n \tif(l<r){\n \t\tcout<<1<<endl;\n \t\treturn 0;\n \t}\n \t\n\n \t\n \tstring ima=\"\";\n \tfor(int i=0;i<l-r;i++)ima+=\"0\";\n \tima+=s;\n //\tcout<<ans<<endl;\n \tfor(int i=l-1;i>r-2;i--){\n \t\tif(ima[i]=='0' && x[i]=='0'){\n \t\t\tgoto lll;\n \t\t}\n \t\telse if(ima[i]=='0' &&x[i]=='1'){\n \t\t\tans+=beki(2,i-(r-1),mod);\n \t\t\tans%=mod;\n \t\t}\n \t\telse if(ima[i]=='1' &&x[i]=='0'){\n \t\t\t\n \t\t}\n \t\telse{\n \t\t\tans+=beki(2,i-(r-1),mod);\n \t\t\tans%=mod;\n \t\t\tgoto lll;\n \t\t}\n \t\t\n \t\tfor(int j=0;j<r;j++){\n \t\t\tif(s[j]=='1'){\n \t\t\t\tif(ima[i-r+1+j]=='1')ima[i-r+1+j]--;\n \t\t\t\telse ima[i-r+1+j]++;\n \t\t\t}\n \t\t}\n \t\tlll:;\n \t//\tcout<<ans<<\" \"<<ima<<\" \"<<i-r+1<<endl;\n \t}\n \t\n \tbool b=0;\n \tfor(int i=l-1;i>=0;i--){\n \t\tif(x[i]>ima[i]){\n \t\t\tb=1;\n \t\t\tbreak;\n \t\t}\n \t\telse if(x[i]<ima[i]){\n \t\t\tgoto ll2;\n \t\t}\n \t}\n \t\n \tans++;\n \tll2:;\n \t/*\n \tb=0;\n \t\n \tfor(int i=0;i<r;i++){\n \t\tif(s[i]=='1'){\n \t\t\tif(ima[i]=='0')ima[i]++;\n \t\t\telse ima[i]--;\n \t\t}\n \t}\n \t \tfor(int i=l-1;i>=0;i--){\n \t\tif(x[i]>ima[i]){\n \t\t\tb=1;\n \t\t\tbreak;\n \t\t}\n \t\telse if(x[i]<ima[i]){\n \t\t\tbreak;\n \t\t}\n \t}\n \t\n \tif(b)ans++;\n \t*/\n \tcout<<ans%mod<<endl;\n \t\n \t\n  \treturn 0;\n  }\n  "
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Ankur Dua\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nusing ll = long long;\nll mod=1000000007;\nll *fact, *ifact;\n\nusing cd = complex<long double>;\nconst long double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        long double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\nvector<ll> multiply(vector<ll> const& a, vector<ll> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size())\n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<ll> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int &cid = ptr[v]; cid < (int) adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n\n//Min cost max flow using dijkstra from https://codeforces.com/contest/1107/submission/49033783\ntemplate<typename flow_t, typename cost_t>\nstruct MinCostMaxFlow {\n    static const flow_t FLOW_INF = numeric_limits<flow_t>::max() / 2;\n    const cost_t COST_INF = numeric_limits<cost_t>::max() / 2;\n    struct edge {\n        int node, rev;\n        flow_t capacity;\n        cost_t cost;\n\n        edge(int _node = -1, int _rev = -1, flow_t _capacity = 0, cost_t _cost = 0)\n                : node(_node), rev(_rev), capacity(_capacity), cost(_cost) {}\n    };\n\n    int V = -1;\n    vector<vector<edge>> adj;\n    vector<cost_t> dist;\n    vector<int> prev;\n    vector<edge*> prev_edge;\n\n    MinCostMaxFlow(int vertices = -1) {\n        if (vertices >= 0)\n            init(vertices);\n    }\n\n    void init(int vertices) {\n        V = vertices;\n        adj.assign(V, {});\n        dist.resize(V);\n        prev.resize(V);\n        prev_edge.resize(V);\n    }\n\n    void addEdge(int u, int v, flow_t capacity, cost_t cost) {\n        edge uv_edge(v, adj[v].size() + (u == v ? 1 : 0), capacity, cost);\n        edge vu_edge(u, adj[u].size(), 0, -cost);\n        adj[u].push_back(uv_edge);\n        adj[v].push_back(vu_edge);\n    }\n\n    edge &reverse_edge(const edge &e) {\n        return adj[e.node][e.rev];\n    }\n\n    bool bellman_ford(int source, int sink) {\n        for (int i = 0; i < V; i++) {\n            dist[i] = COST_INF;\n            prev[i] = -1;\n            prev_edge[i] = nullptr;\n        }\n\n        vector<int> last_seen(V, -1);\n        vector<int> nodes(1, source);\n        dist[source] = 0;\n\n        for (int iteration = 0; iteration < V; iteration++) {\n            vector<int> next_nodes;\n\n            for (int node : nodes)\n                for (edge &e : adj[node])\n                    if (e.capacity > 0 && dist[node] + e.cost < dist[e.node]) {\n                        dist[e.node] = dist[node] + e.cost;\n                        prev[e.node] = node;\n                        prev_edge[e.node] = &e;\n\n                        if (last_seen[e.node] != iteration) {\n                            last_seen[e.node] = iteration;\n                            next_nodes.push_back(e.node);\n                        }\n                    }\n\n            swap(nodes, next_nodes);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    struct dijkstra_state {\n        cost_t dist;\n        int node;\n\n        bool operator<(const dijkstra_state &other) const {\n            return dist > other.dist;\n        }\n    };\n\n    void dijkstra_check(int node, cost_t potential_dist, int previous, edge *previous_edge, auto &pq) {\n        if (potential_dist < dist[node]) {\n            dist[node] = potential_dist;\n            prev[node] = previous;\n            prev_edge[node] = previous_edge;\n            pq.push({dist[node], node});\n        }\n    }\n\n    bool dijkstra(int source, int sink) {\n        dist.assign(V, COST_INF);\n        prev.assign(V, -1);\n        prev_edge.assign(V, nullptr);\n\n        priority_queue<dijkstra_state> pq;\n        dijkstra_check(source, 0, -1, nullptr, pq);\n\n        while (!pq.empty()) {\n            dijkstra_state top = pq.top();\n            pq.pop();\n\n            if (top.dist > dist[top.node])\n                continue;\n\n            for (edge &e : adj[top.node])\n                if (e.capacity > 0)\n                    dijkstra_check(e.node, top.dist + e.cost, top.node, &e, pq);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    void reduce_cost() {\n        for (int i = 0; i < V; i++)\n            for (edge &e : adj[i])\n                e.cost += dist[i] - dist[e.node];\n    }\n\n    pair<flow_t, cost_t> minCostFlow(int source, int sink, flow_t flow_goal = FLOW_INF) {\n        assert(V >= 0);\n\n        if (!bellman_ford(source, sink))\n            return make_pair(0, 0);\n\n        flow_t total_flow = 0;\n        cost_t total_cost = 0;\n        cost_t reduce_sum = 0;\n\n        do {\n            reduce_cost();\n            reduce_sum += dist[sink];\n            flow_t path_cap = flow_goal - total_flow;\n\n            for (int node = sink; prev[node] != -1; node = prev[node])\n                path_cap = min(path_cap, prev_edge[node]->capacity);\n\n            for (int node = sink; prev[node] != -1; node = prev[node]) {\n                edge *e = prev_edge[node];\n                assert(e->cost == 0);\n                e->capacity -= path_cap;\n                reverse_edge(*e).capacity += path_cap;\n            }\n\n            total_flow += path_cap;\n            total_cost += reduce_sum * path_cap;\n        } while (total_flow < flow_goal && dijkstra(source, sink));\n\n        return make_pair(total_flow, total_cost);\n    }\n};\n\nll modExp(ll base, ll exp, ll mod=::mod){\n    ll ans=1;\n    while(exp) {\n        if (exp & 1) {\n            (ans *= base) %= mod;\n        }\n        (base *= base) %= mod;\n        exp>>=1;\n    }\n    return ans;\n}\nll modInv(ll x, ll mod=::mod){\n    return modExp(x,mod-2,mod);\n}\nvoid modFact(ll n, ll mod=::mod){\n    ifact=new ll[n+1];\n    fact=new ll[n+1];\n    fact[0]=fact[1]=1;\n    for(int i=2;i<=n;i++){\n        fact[i]=(i*fact[i-1])%mod;\n    }\n    ifact[n]=modInv(fact[n], mod);\n    for(int i=n-1;i>=0;i--){\n        ifact[i]=((i+1)*ifact[i+1])%mod;\n    }\n}\nll ncr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[r];\n    ans%=mod;\n    ans*=ifact[n-r];\n    ans%=mod;\n    return ans;\n}\nll npr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[n-r];\n    return ans%mod;\n}\nclass DSU{\npublic:\n    int*p, *r;\n    DSU(int n){\n        p=new int[n+50];\n        r=new int[n+50];\n        for(int i=0;i<=n+10;i++){\n            p[i]=i;\n            r[i]=0;\n        }\n    }\n    ~DSU(){\n        delete[] p;\n        delete[] r;\n    }\n    int find(int x){\n        if(p[x]==x)\n            return x;\n        return p[x]=find(p[x]);\n    }\n    bool Unite(int a, int b){\n        a=find(a);\n        b=find(b);\n        if(a==b)\n            return false;\n        if(r[a]<r[b])\n            p[a]=b;\n        else\n            p[b]=a;\n        if(r[a]==r[b])\n            r[a]++;\n        return true;\n    }\n};\nusing namespace std;\nconst int mx=4000;\ntypedef bitset<mx> BS;\nll p2[mx];\nBS b;\nclass ARC84D {\npublic:\n    ll dfs(BS &x,vector<int> &cnt, int bp, bool eq, vector<BS> &basis){\n        if(bp==-1)\n            return 1;\n        if(!eq)\n            return p2[cnt[bp]];\n        ll ans=0;\n        if(x[bp] && b[bp]){\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,false,basis);\n                b^=basis[bp];\n                ans%=mod;\n            }\n        }else if(x[bp] && !b[bp]){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n            ans+=dfs(x,cnt,bp-1,false,basis);\n\n            ans%=mod;\n        }else if((!x[bp]) && (b[bp])){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n        }else{\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n        }\n\n        return ans;\n    }\n    BS ggcd(BS a, BS b){\n        while(b.any()){\n            int ha,hb;\n            for(int i=mx-1;i>=0;i--){\n                if(a[i]){\n                    ha=i;\n                    break;\n                }\n\n            }\n\n            for(int i=mx-1;i>=0;i--){\n                if(b[i]){\n                    hb=i;\n                    break;\n                }\n\n            }\n            if(ha<hb){\n                swap(a,b);\n                swap(ha,hb);\n            }\n            BS res;\n            for(int i=ha;i>=0;i--){\n                res<<=1;\n                if(a[i])\n                    res[0]=1;\n                if(res[hb])\n                    res^=b;\n            }\n            a=b;\n            b=res;\n        }\n        return a;\n\n\n    }\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        int n;\n        cin>>n;\n\n        string xx;\n        cin>>xx;\n        BS x(xx);\n        vector<BS> basis(mx);\n        BS gcd;\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            BS cur(s);\n            gcd=ggcd(cur,gcd);\n        }\n        mod=998244353;\n        p2[0]=1;\n        for(int i=1;i<mx;i++){\n            p2[i]=(2*p2[i-1])%mod;\n        }\n        BS least=gcd;\n        for(int i=mx-1;i>=0;i--){\n            if(least[i]){\n                //least=basis[i]<<1;\n                for(int j=i;j<mx;j++,least<<=1){\n                    basis[j]=least;\n                }\n                break;\n            }\n        }\n        vector<int> cnt(mx);\n        for(int i=0;i<mx;i++)\n            if(basis[i][i])\n                cnt[i]=1;\n        for(int i=1;i<mx;i++)\n            cnt[i]+=cnt[i-1];\n        b=BS();\n        cout<<dfs(x,cnt,mx-1,true,basis)<<endl;\n\t}\n};\n\n\nint main() {\n\tARC84D solver;\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(NULL);\n\tstd::cout.tie(NULL);\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\ntemplate <typename T> using posteriority_queue = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> void unique(vector<T> &a) { a.erase(unique(ALL(a)), a.end()); }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint mod = MOD;\nstruct ModInt {\n  unsigned val;\n  ModInt(): val(0) {}\n  ModInt(ll x) : val(x >= 0 ? x % mod : x % mod + mod) {}\n  ModInt pow(ll exponent) {\n    ModInt tmp = *this, res = 1;\n    while (exponent > 0) {\n      if (exponent & 1) res *= tmp;\n      tmp *= tmp;\n      exponent >>= 1;\n    }\n    return res;\n  }\n  ModInt &operator+=(const ModInt &x) { if((val += x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator-=(const ModInt &x) { if((val += mod - x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator*=(const ModInt &x) { val = static_cast<unsigned long long>(val) * x.val % mod; return *this; }\n  ModInt &operator/=(const ModInt &x) {\n    // assert(__gcd(static_cast<int>(x.val), mod) == 1);\n    unsigned a = x.val, b = mod; int u = 1, v = 0;\n    while (b) {\n      unsigned tmp = a / b;\n      swap(a -= tmp * b, b);\n      swap(u -= tmp * v, v);\n    }\n    return *this *= u;\n  }\n  bool operator==(const ModInt &x) const { return val == x.val; }\n  bool operator!=(const ModInt &x) const { return val != x.val; }\n  bool operator<(const ModInt &x) const { return val < x.val; }\n  bool operator<=(const ModInt &x) const { return val <= x.val; }\n  bool operator>(const ModInt &x) const { return val > x.val; }\n  bool operator>=(const ModInt &x) const { return val >= x.val; }\n  ModInt &operator++() { if (++val == mod) val = 0; return *this; }\n  ModInt operator++(int) { ModInt res = *this; ++*this; return res; }\n  ModInt &operator--() { val = (val == 0 ? mod : val) - 1; return *this; }\n  ModInt operator--(int) { ModInt res = *this; --*this; return res; }\n  ModInt operator+() const { return *this; }\n  ModInt operator-() const { return ModInt(val ? mod - val : 0); }\n  ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n  ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n  ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n  ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n  friend ostream &operator<<(ostream &os, const ModInt &x) { return os << x.val; }\n  friend istream &operator>>(istream &is, ModInt &x) { ll val; is >> val; x = ModInt(val); return is; }\n};\nModInt abs(const ModInt &x) { return x; }\nstruct Combinatorics {\n  int val; // \"val!\" and \"mod\" must be disjoint.\n  vector<ModInt> fact, fact_inv, inv;\n  Combinatorics(int val = 10000000) : val(val), fact(val + 1), fact_inv(val + 1), inv(val + 1) {\n    fact[0] = 1;\n    FOR(i, 1, val + 1) fact[i] = fact[i - 1] * i;\n    fact_inv[val] = ModInt(1) / fact[val];\n    for (int i = val; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i;\n    FOR(i, 1, val + 1) inv[i] = fact[i - 1] * fact_inv[i];\n  }\n  ModInt nCk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val && k <= val);\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n  }\n  ModInt nPk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val);\n    return fact[n] * fact_inv[n - k];\n  }\n  ModInt nHk(int n, int k) {\n    if (n < 0 || k < 0) return ModInt(0);\n    return (k == 0 ? ModInt(1) : nCk(n + k - 1, k));\n  }\n};\n\nint main() {\n  const int N = 4000;\n  int n; bitset<N> x; cin >> n >> x;\n  bitset<N> a; cin >> a;\n  int msb = N - 1;\n  for (; msb >= 0; --msb) {\n    if (a.test(msb)) break;\n  }\n  while (--n) {\n    bitset<N> ai; cin >> ai;\n    int ai_msb = N - 1;\n    for (; ai_msb >= 0; --ai_msb) {\n      if (ai.test(ai_msb)) break;\n    }\n    if (ai_msb > msb) {\n      swap(a, ai);\n      swap(msb, ai_msb);\n    }\n    while (ai.any()) {\n      a = a ^ (ai << (msb - ai_msb));\n      for (; msb >= 0; --msb) {\n        if (a.test(msb)) break;\n      }\n      if (msb < ai_msb) {\n        swap(a, ai);\n        swap(msb, ai_msb);\n      }\n    }\n  }\n  ModInt ans = 0;\n  for (int i = N - 1; i >= msb; --i) {\n    ans *= 2;\n    if (x.test(i)) ++ans;\n  }\n  bitset<N> bit = x;\n  REP(i, msb) bit.reset(i);\n  bitset<N> lim = bit;\n  for (int i = N - 1; i >= msb; --i) {\n    if (bit.test(i)) bit ^= a << (i - msb);\n  }\n  lim |= bit;\n  ++ans;\n  for (int i = msb - 1; i >= 0; --i) {\n    if (x.test(i) && !lim.test(i)) break;\n    if (!x.test(i) && lim.test(i)) {\n      --ans;\n      break;\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nbitset<4000> X,P;\nll mo=998244353;\nll p2[202020];\nint ng;\n\nbitset<4000> gcd(bitset<4000> A,bitset<4000> B) {\n\tint i;\n\tfor(i=3999;i>=0;i--) {\n\t\tif(A[i]==1 && B[i]==1) {\n\t\t\tB^=A;\n\t\t\tbreak;\n\t\t}\n\t\tif(A[i]==1) break;\n\t\tif(B[i]==1) {\n\t\t\tswap(A,B);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// A>B\n\twhile(1) {\n\t\tint x;\n\t\tfor(x=i-1;x>=0;x--) if(B[x]) break;\n\t\tif(x<0) break;\n\t\twhile(i>=x) {\n\t\t\tif(A[i]) A^=B<<(i-x);\n\t\t\ti--;\n\t\t}\n\t\ti=x;\n\t\tswap(A,B);\n\t}\n\treturn A;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tp2[0]=1;\n\tFOR(i,101010) p2[i+1]=p2[i]*2%mo;\n\t\n\tcin>>N>>S;\n\tFOR(i,S.size()) if(S[i]=='1') X[S.size()-1-i]=1;\n\tFOR(j,N) {\n\t\tcin>>S;\n\t\tbitset<4000> B;\n\t\tFOR(i,S.size()) if(S[i]=='1') B[S.size()-1-i]=1;\n\t\tif(j==0) P=B;\n\t\telse P=gcd(P,B);\n\t}\n\t\n\tll ret=0;\n\tFOR(i,4000) if(P[i]) x=i;\n\tfor(i=3999;i>=x+1;i--) if(X[i]) ret+=p2[i-x];\n\tfor(i=3999;i>=x+1;i--) if(X[i]) X^=P<<(i-x);\n\t\n\tret++;\n\tfor(i=x;i>=0;i--) {\n\t\tif(X[i]<P[i]) {\n\t\t\tret--;\n\t\t\tbreak;\n\t\t}\n\t\tif(X[i]>P[i]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tret++;\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nconst int mn=8e3,maxn=mn+2,mo=998244353;\nchar c[maxn];\nbitset<maxn>L,a[7],f[maxn],s,now;\nint n,i,j,k,ans,T,ts,len,h[maxn],t[7],id[7];\nint two[maxn];bool bz;\nvoid ins(bitset<maxn> a){\n\tint i;\n\tfd(i,T,0) if (a[i]){\n\t\tif (f[i].any()) a^=f[i];else{\n\t\t\ts=f[i]=a,ts=i;\n\t\t\treturn;\n\t\t}\n\t}ts=-1;\n}\nbool cmp(int x,int y){\n\treturn t[x]<t[y];\n}\nint main(){\n\tscanf(\"%d%s\",&n,c+1);\n\tlen=strlen(c+1);\n\tfo(i,1,len>>1) swap(c[i],c[len-i+1]); \n\tfo(i,1,len) L[i-1]=c[i]-'0';\n\tfo(i,1,n){\n\t\tscanf(\"%s\",c+1);\n\t\tlen=strlen(c+1);\n\t\tfo(j,1,len>>1) swap(c[j],c[len-j+1]); \n\t\tfo(j,1,len) a[i][j-1]=c[j]-'0';\n\t\tt[i]=len-1,id[i]=i;\n\t}\n\tsort(id+1,id+1+n,cmp);\n\tint x=id[1];\n\tfo(j,0,mn-t[x]) f[j+t[x]]=a[x]<<j;\n\tfo(i,2,n){\n\t\tx=id[i],T=t[x];\n\t\tins(a[x]);\n\t\tfor(;ts!=-1;) T=ts+1,s<<=1,ins(s);\n\t}\n\ttwo[0]=1;\n\th[0]=f[0].any();\n\tfo(i,1,mn) h[i]=h[i-1]+(f[i].any()),two[i]=(ll)two[i-1]*2%mo;\n\tfd(i,mn,0) if (L[i]){\n\t\t(ans+=(i)?two[h[i-1]]:1)%=mo;\n\t\tif (!now[i]) {\n\t\t\tif (!f[i].any()) break;\n\t\t\tnow^=f[i];\n\t\t}\n\t}else{\n\t\tif (now[i]){\n\t\t\tif (!f[i].any()) break;\n\t\t\tnow^=f[i];\n\t\t}\n\t}\n\tif (i<0) ans++;\n\tprintf(\"%d\\n\",ans%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    constexpr uint MOD = 998244353;\n    using mint = ModInt<MOD>;\n    constexpr int L = 4000;\n    const int N = read<int>();\n    using B = std::bitset<L>;\n    B X(read<std::string>());\n    auto gcd = [&](auto&& self, B a, B b) {\n        if (a.count() == 0) { return b; }\n        if (a.to_string() > b.to_string()) { return self(self, b, a); }\n        int d = L - 1;\n        for (; d >= 0 and b[d] == 0; d--) {}\n        int dd = L - 1;\n        for (; dd >= 0 and a[dd] == 0; dd--) {}\n        for (; d >= dd; d--) {\n            if (b[d] == 0) { continue; }\n            const int sft = d - dd;\n            b ^= (a << sft);\n        }\n        return self(self, b, a);\n    };\n    B g;\n    for (int i = 0; i < N; i++) { g = gcd(gcd, g, B(read<std::string>())); }\n    int d = L - 1;\n    auto x = X;\n    for (; d >= 0 and g[d] == 0; d--) {}\n    for (int l = L - 1; l >= d; l--) {\n        if (x[l] == 0) { continue; }\n        const int sft = l - d;\n        x ^= (g << sft);\n    }\n    B mask;\n    for (int i = 0; i < d; i++) { mask[i] = 1; }\n    X >>= d;\n    mint ans = (x.to_string() >= (X & mask).to_string()) ? 1 : 0, base = 1;\n    for (int i = 0; i < L; i++) { ans += base * X[i], base *= 2; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nbitset<4000> X,P;\nll mo=998244353;\nll p2[202020];\nint ng;\n\nbitset<4000> gcd(bitset<4000> A,bitset<4000> B) {\n\tint i;\n\tfor(i=3999;i>=0;i--) {\n\t\tif(A[i]==1 && B[i]==1) {\n\t\t\tB^=A;\n\t\t\tbreak;\n\t\t}\n\t\tif(A[i]==1) break;\n\t\tif(B[i]==1) {\n\t\t\tswap(A,B);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// A>B\n\twhile(1) {\n\t\tint x;\n\t\tfor(x=i-1;x>=0;x--) if(B[x]) break;\n\t\tif(x<0) break;\n\t\twhile(i>=x) {\n\t\t\tif(A[i]) A^=B<<(i-x);\n\t\t\ti--;\n\t\t}\n\t\ti=x;\n\t\tswap(A,B);\n\t}\n\treturn A;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tp2[0]=1;\n\tFOR(i,101010) p2[i+1]=p2[i]*2%mo;\n\t\n\tcin>>N>>S;\n\tFOR(i,S.size()) if(S[i]=='1') X[S.size()-1-i]=1;\n\tFOR(j,N) {\n\t\tcin>>S;\n\t\tbitset<4000> B;\n\t\tFOR(i,S.size()) if(S[i]=='1') B[S.size()-1-i]=1;\n\t\tif(j==0) P=B;\n\t\telse P=gcd(P,B);\n\t}\n\t\n\tll ret=0;\n\tFOR(i,4000) if(P[i]) x=i;\n\tfor(i=3999;i>=x;i--) if(X[i]) ret+=p2[i-x];\n\tbitset<4000> Y;\n\tfor(i=3999;i>=x;i--) if(X[i]^Y[i]) Y^=P<<(i-x);\n\t\n\t/*\n\tFOR(i,6) cout<<P[i];\n\tcout<<\" \";\n\tFOR(i,6) cout<<Y[i];\n\tcout<<endl;\n\t*/\n\tret++;\n\tret++;\n\tfor(i=x-1;i>=0;i--) {\n\t\tif(Y[i]<P[i]) {\n\t\t\tret--;\n\t\t\tbreak;\n\t\t}\n\t\tif(Y[i]>P[i]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(i<0) ret--;\n\t\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nconstexpr int MAX = 4000;\n\nusing B = bitset<MAX>;\n\nint n;\nB x, a, b;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> x;\n    rep(i, n) for(cin >> b; b.any(); swap(a, b)) {\n        int p = MAX;\n        while(p--)\n            if(b[p]) break;\n        for(int j = MAX; j-- > p;)\n            if(a[j]) a ^= b << j - p;\n    }\n\n    int p = MAX;\n    while(p--)\n        if(a[p]) break;\n\n    int ans = 0;\n    for(int i = MAX; i-- > p;)\n        ans = (ans << 1 | x[i]) % Mod;\n\n    b = x;\n    for(int i = MAX - 1; i >= p; b ^= a << (i - p)) {\n        while(i >= p && !b[i])\n            i--;\n    }\n    for(int i = p - 1; ~i; i--)\n        if(b[i]) {\n            ans -= !x[i];\n            break;\n        }\n\n    cout << (ans + 1) % Mod << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v, w; };\n\nvector<int> gcd(vector<int> s, vector<int> t) {\n\tint N = s.size(), M = t.size();\n\tif (N < M) return gcd(t, s);\n\tif (!M) return s;\n\trep(j, M) s[j] ^= t[j];\n\tint l = N;\n\trep(i, N) if (s[i]) {\n\t\tl = min(l, i);\n\t\tbreak;\n\t}\n\tvector<int> a(N - l);\n\trep(i, N - l) a[i] = s[l + i];\n\treturn gcd(t, a);\n}\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n >>= 1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint N; cin >> N;\n\tstring s; cin >> s;\n\tvector<string> a(N);\n\trep(i, N) cin >> a[i];\n\tvector<int> d;\n\trep(i, N) {\n\t\tint M = a[i].length();\n\t\tvector<int> b(M);\n\t\trep(j, M) b[j] = a[i][j] - '0';\n\t\td = gcd(d, b);\n\t}\n\tint n = s.length();\n\tvector<int> c(n), _c(n);\n\trep(i, n) c[i] = s[i] - '0';\n\tint m = d.size();\n\tint ans = 1;\n\tfor (int i = 0; i + m <= n; i++) {\n\t\tif (c[i]) ans = (ans + pow_mod(2, n - m - i, MOD)) % MOD;\n\t\tif (c[i] == _c[i]) continue;\n\t\trep(j, m) _c[i + j] ^= d[j];\n\t}\n\tbool ok = true;\n\tif (_c <= c) ok = false;\n\tif (ok) ans = (ans + 1) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 4010\n#define mod 998244353\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nint n,len,pp[5010];\nbitset <N+10> T,M,X,C;\ninline int gt(bitset <N+10> &s)\n{\n\tfor(int i=N;i>=0;i--) if(s[i]) return i;\n\treturn 0;\n}\nint main()\n{\n\tn=read(); cin >> X; cin >> T;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tcin >> M; //cout << M << endl;\n\t\twhile(1)\n\t\t{\n\t\t\tif(gt(T)<gt(M)) swap(M,T);\n\t\t\tint tt=gt(M);\n\t\t\tfor(int j=gt(T);j>=gt(M);j--) \n\t\t\t\tif(T[j]) T^=(M<<(j-tt));\n\t\t\tif(T.none()) {T=M; break;} \n\t\t}\n\t\t//cout << T << endl;\n\t}\n\tpp[0]=1; for(int i=1;i<=N;i++) pp[i]=(pp[i-1]<<1)%mod;\n\tint tt=gt(T),Ans=0;\n\t//cout << T << endl;\n\tfor(int i=N-1;i>=tt;i--)\n\t{\n\t\tif(X[i]) Ans+=pp[i-tt],Ans%=mod;\n\t\tif(X[i]!=C[i]) C^=T<<(i-tt);\n \t}\n \tfor(int i=tt;i>=0;i--)\n \t{\n \t\tif(X[i]>C[i]) break;\n \t\tif(X[i]<C[i]) {Ans--; break;}\n \t}\n \tAns++; cout << (Ans % mod + mod)%mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[4009];\nstruct bin{\n\tbitset<4000> bit;\n\tint L;\n\tvoid inp(){\n\t\tscanf(\"%s\",s);\n\t\tL = strlen(s);\n\t\treverse(s,s+L);\n\t\t--L;\n\t\tfor(int i=0; i<=L; i++)if(s[i] == '1')\n\t\t\tbit.set(i);\n\t}\n\tvoid add1(){\n\t\tfor(int i=0; i<=L+1; i++)if(bit.test(i))bit.reset(i);else{\n\t\t\tbit.set(i);\n\t\t\tbreak;\n\t\t}\n\t\tif(bit.test(L+1))++L;\n\t}\n};\n\nint n;\nbin min_set[64],X;\n\nbool gaussian(bin&A, bin&B, bin&C){\n\tC = B;\n\tif(A.L > B.L){\n\t\treturn true;\n\t}\n\tint dif = B.L - A.L;\n\tbitset<4000> g = A.bit << dif;\n\twhile(dif >= 0){\n\t\tif(C.bit.test(C.L))\n\t\t\tC.bit ^= g;\n\t\tg >>= 1;\n\t\tC.L--;\n\t\tdif--;\n\t}\n\twhile(C.L >=0 && !C.bit.test(C.L))C.L--;\n\treturn C.L >= 0;\n}\n\n#define mod 998244353\nint add(int x,int y){return (x+=y)<mod?x:x-mod;}\nint mul(int x,int y){return (int)((long long int)(x)*y%mod);}\nint p2[4009];\nint main(){\n\tscanf(\"%d\",&n);\n\tX.inp();X.add1();\n\tfor(int i=0; i<n; i++)\n\t\tmin_set[1<<i].inp();\n\tfor(int mask=1; mask<(1<<n); mask++)if((mask&-mask) != mask){\n\t\tmin_set[mask].L = -1;\n\t\tfor(int i=0; i<n; i++)if(mask&(1<<i)){\n\t\t\tbin cur = min_set[mask-(1<<i)];\n\t\t\tif(min_set[mask].L == -1 || cur.L < min_set[mask].L)\n\t\t\t\tmin_set[mask] = cur;\n\t\t\tif(!gaussian(min_set[mask-(1<<i)],min_set[1<<i],cur))continue;\n\t\t\tif(min_set[mask].L == -1 || cur.L < min_set[mask].L)\n\t\t\t\tmin_set[mask] = cur;\n\t\t}\n\t}\n\tp2[0] = 1;\n\tfor(int i=1; i<=X.L; i++)p2[i] = add(p2[i-1],p2[i-1]);\n\tbin cur = min_set[(1<<n)-1];\n\tint res= 0;\n\tfor(int i=X.L; i>=0; i--){\n\t\tif(!X.bit.test(i))continue;\n\t\tif(i >= cur.L){\n\t\t\tres=add(res, p2[i - cur.L]);\n\t\t\tcontinue;\n\t\t}\n\t\tbin B;\n\t\tgaussian(X, cur, B);\n\t\tB.bit ^= X.bit;\n\t\tbool ff = false;\n\t\tfor(int j=i; j>=0; j--)if(B.bit.test(j) ^ X.bit.test(j)){\n\t\t\tif(!B.bit.test(j) && X.bit.test(j))\n\t\t\t\tff = true;\n\t\t\tbreak;\n\t\t}\n\t\tif(ff)res=add(res,1);\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nvector<int> num[7],x,g,t;\nint N;\nchar s[4005];\nvector<int> gcd(vector<int> a,vector<int> b) {\n\tif(a.size() < b.size()) swap(a,b);\n\tif(b.size() == 1 && b[0] == 0) return a;\n\tvector<int> d(a.size());\n\tint t = a.size() - 1;\n\tfor(int i = b.size() - 1 ; i >= 0 ; --i) {\n\t\td[t] = a[t] ^ b[i];\n\t\t--t;\n\t}\n\tfor(int i = t ; i >= 0 ; --i) d[i] = a[i];\n\twhile(d.size() > 1) {\n\t\tif(d.back() == 0) d.pop_back();\n\t\telse break;\n\t}\n\treturn gcd(b,d);\n}\nvoid Init() {\n\tread(N);\n\tscanf(\"%s\",s + 1);\n\tint len = strlen(s + 1);\n\tfor(int i = len ; i >= 1 ; --i) {\n\t\tx.pb(s[i] - '0');\n\t}\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tscanf(\"%s\",s + 1);\n\t\tlen = strlen(s + 1);\n\t\tfor(int j = len ; j >= 1 ; --j) num[i].pb(s[j] - '0');\n\t}\n\tg = num[1];\n\tfor(int i = 2 ; i <= N ; ++i) g = gcd(g,num[i]);\n}\nvoid Solve() {\n\tt = x;\n\tint l = x.size() - g.size() + 1;\n\tint d = x.size() - 1;\n\tint ans = 0;\n\tfor(int i = 0 ; i < l ; ++i) {\n\t\tans = (1LL * ans * 2 + x[d - i]) % MOD;\n\t}\n\tans = (ans + 1) % MOD;\n\tfor(int i = l ; i < x.size() ; ++i) t[d - i] = 0;\n\tfor(int i = 0 ; i < l ; ++i) {\n\t\tif(t[d - i] == 1) {\n\t\t\tint k = g.size() - 1;\n\t\t\tfor(int j = 0 ; j < g.size() ; ++j) {\n\t\t\t\tt[d - i - j] = t[d - i - j] ^ g[k - j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = l ; i < x.size() ; ++i) {\n\t\tif(t[d - i] != x[d - i]) {\n\t\t\tif(t[d - i] > x[d - i]) ans = (ans + MOD - 1) % MOD;\n\t\t\telse break;\n\t\t}\n\t}\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tInit();\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\n\nmint mod_pow(mint a, ll x) {\n  mint res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nbitset<4000> gcd(bitset<4000>& p, bitset<4000>& q) {\n  int dp, dq;\n  dp = dq = -1;\n  rep(i, 4000) {\n    if (p[i]) dp = i;\n    if (q[i]) dq = i;\n  }\n  if (dq > dp) {\n    swap(dp, dq);\n    swap(p, q);\n  }\n  if (dq == -1) {\n    return p;\n  }\n  int d = dp-dq;\n  p ^= (q<<d);\n  return gcd(p, q);\n}\n\nmint calc(bitset<4000>& x, bitset<4000>& r) {\n  bitset<4000> k;\n  int dx, dr;\n  rep(i, 4000) {\n    if (x[i]) dx = i;\n    if (r[i]) dr = i;\n  }\n  mint ret = 0;\n\n  r <<= dx-dr;\n  for(int i=dx; i>=dr; i--) {\n    if (x[i]) {\n      ret += mod_pow(2, i-dr);\n      debug(ret.x);\n    }\n    if (k[i] ^ x[i]) {\n      k ^= r;\n    }\n    r >>= 1;\n  }\n\n  bool flag = true;\n  for(int i=dr-1; i>=0; i--) {\n    if (x[i] && !k[i]) {\n      break;\n    } else if (!x[i] && k[i]) {\n      flag = false;\n      break;\n    }\n  }\n  if (flag) ret += 1;\n  return ret;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  string s; cin >> s;\n  bitset<4000> x;\n  reverse(s.begin(), s.end());\n  rep(i, s.size()) {\n    if (s[i] == '1') {\n      x.set(i);\n    }\n  }\n\n  vector<bitset<4000>> vec(n);\n  rep(i, n) {\n    cin >> s;\n    reverse(s.begin(), s.end());\n    rep(j, s.size()) {\n      if (s[j] == '1') {\n        vec[i].set(j);\n      }\n    }\n  }\n\n  bitset<4000> r;\n  rep(i, n) {\n    r = gcd(r, vec[i]);\n  }\n\n  cout << calc(x, r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 5000\n\nlong long mod=998244353;\nbitset<N> p,q;\n\nint main(){\n    p=gcd(p)\n}\n\nvoid bitsetSubtract(bitset<N> &x, const bitset<N> &y) {\n    bool b = false;\n\n    for (int i = 0; i < N; i++) {\n        if (b) {\n            if (x[i]) {\n                x[i] = y[i];\n                b = y[i];\n            } else {\n                x[i] = !y[i];\n                b = true;\n            }\n        } else {\n            if (x[i]) {\n                x[i] = !y[i];\n                b = false;\n            } else {\n                x[i] = y[i];\n                b = y[i];\n            }\n        }\n    }\n}\n\nbitset<N> gcd(bitset<N> u, bitset<N> v) {\n    bitset<N> one (string(\"1\"));\n    bitset<N> zero (string(\"0\"));\n\n    int shift;\n\n    if (u == 0) return v;\n    if (v == 0) return u;\n\n    for (shift = 0; ((u | v) & one) == zero; ++shift) {\n        u >>= 1;\n        v >>= 1;\n    }\n\n    while ((u & one) == zero) u >>= 1;\n\n    do {\n        while ((v & one) == zero) v >>= 1;\n\n        if (u.to_string() > v.to_string()) {\n            bitset<N> t = v;\n            v = u;\n            u = t;\n        }\n\n        bitsetSubtract(v,u);\n    } while (v != 0);\n\n    return u << shift;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nconst int MN = 4010;\n\nint N;\nstring X, g, tmp;\nstring A[6];\n\nstring gcd(string &a, string &b) {\n    if(a.size() < b.size()) return gcd(b, a);\n    if(b.size() == 0) return a;\n\n    int n = a.size();\n    int m = b.size();\n    for(int i = 0; i <= n - m; i++) {\n        if(a[n - 1 - i] == '1') {\n            for(int j = 0; j < m; j++) {\n                int t = a[n - 1 - i - j] - '0';\n                int d = b[m - 1 - j] - '0';\n                a[n - 1 - i - j] = '0' + (t ^ d);\n            }\n        }\n    }\n    while(a.size() && a.back() == '0') a.pop_back();\n    return gcd(b, a);\n}\n\nint chk[MN], po[MN], la;\n\nint cc[MN];\nint dp(int x) {\n    if(x == (int)X.size() - (int)g.size() + 1) return la;\n    int &ret = cc[x];\n    if(ret != -1) return ret;\n\n    ret = dp(x + 1);\n    if(X[x] == '1') {\n        ret += po[ (int)X.size() - (int)g.size() - x ];\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    po[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        po[i] = 1LL * po[i - 1] * 2 % mod;\n    }\n\n    cin >> N >> X;\n\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n        reverse(A[i].begin(), A[i].end());\n    }\n\n    g = A[0];\n    for(int i = 1; i < N; i++) {\n        g = gcd(g, A[i]);\n    }\n\n    reverse(g.begin(), g.end());\n\n    int n = X.size();\n    int m = g.size();\n    tmp = X;\n    for(int i = 0; i <= n - m; i++) {\n        chk[i] = tmp[i] - '0';\n        if(tmp[i] == '1') {\n            for(int j = 0; j < m; j++) {\n                int t = tmp[i + j] - '0';\n                int d = g[j] - '0';\n                tmp[i + j] = '0' + (t ^ d);\n            }\n        }\n    }\n\n    la = 1;\n    for(int i = n - m + 1; i < n; i++) {\n        if(tmp[i] == '1') {\n            la = X[i] - '0';\n            break;\n        }\n    }\n\n    memset(cc, -1, sizeof(cc));\n    cout << dp(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\nconst int m = 4010;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel rui(m + 10, 1);\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nint max_true(bs &a,int jou) {\n\tint ans = jou;\n\trep(i, jou) {\n\t\tif (a[i]) { ans = i; }\n\t}\n\treturn ans;\n}\nbool can_div(bs &a, bs b, int &sza, int szb) {\n\tfor (int i = sza; i >= szb; i--) {\n\t\tif (a[i]) {\n\t\t\ta ^= b << (i - szb);\n\t\t}\n\t}\n\tsza = max_true(a, szb);\n\tif (sza == szb) { return true; }\n\treturn false;\n}\nbs gcd(bs a, bs b) {\n\tint sza = max_true(a,m);\n\tint szb = max_true(b,m);\n\tif (sza < szb) { swap(sza, szb); swap(a, b); }\n\twhile (true) {\n\t\tif (can_div(a, b, sza, szb)) { return b; }\n\t\tif (can_div(b, a, szb, sza)) { return a; }\n\t}\n}\nvoid solve(bs &x, bs &a) {\n\tint szx = max_true(x,m);\n\tint sza = max_true(a,m);\n\tbs to;\n\trep(i, m) { to[i] = 0; }\n\tint ans = 0;\n\tfor (int i = szx; i >= sza; i--) {\n\t\tif (x[i]) {\n\t\t\tans += rui[i - sza];\n\t\t}\n\t\tif (x[i] != to[i]) {\n\t\t\tto ^= a << (i - sza);\n\t\t}\n\t}\n\tans++;\n\tfor (int i = m - 1; i >= 0;i--) {\n\t\tif (to[i] and !x[i]) { ans--; break; }\n\t\tif (x[i] and !to[i]) { break; }\n\t}\n\tcout << ans % p << endl;\n}\nbs mak(string s) {\n\trev(s);\n\tbs ans;\n\trep(i, m) { ans[i] = 0; }\n\trep(i, s.size()) {\n\t\tans[i] = (s[i] == '1');\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint n; cin >> n;\n\tstring x; cin >> x;\n\tstring s; cin >> s;\n\tbs gcd0 = mak(s);\n\trep(i, n - 1) {\n\t\tstring ne; cin >> ne;\n\t\tbs newb = mak(ne);\n\t\tgcd0 = gcd(newb, gcd0);\n\t}\n\tbs nw = mak(x);\n\trep(i, m + 9) { rui[i + 1] = rui[i] * 2; rui[i + 1] %= p; }\n\tsolve(nw, gcd0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 998244353;\nconst int dd = 4007;\n\nint n;\nbitset<dd> a[8], X;\n\nvoid read(bitset<dd> &cur) {\n\tstring s;\n\tcin >> s;\n\tint n = (int)s.size();\n\tfor (int i = 0; i < n; i++) cur[n - i - 1] = (s[i] == '1');\n}\n\nint get(bitset<dd> &cur) {\n\tfor (int i = dd - 1; i >= 0; i--) if (cur[i]) return i;\n\treturn dd;\n}\n\nint main() {\n\tcin >> n;\n\tread(X);\n\t\n\tfor (int i = 0; i < n; i++) read(a[i]);\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (1) {\n\t\t\tint l = get(a[0]);\n\t\t\tint r = get(a[i]);\n\t\t\tif (l > r) swap(a[0], a[i]), swap(l, r);\n\t\t\tif (r == dd) break;\n\t\t\ta[i] ^= (a[0] << (r - l));\n\t\t}\n\t}\n\tint p = get(a[0]);\n\tint pw = 1, ans = 0;\n\t\n\tfor (int i = p; i < dd; i++) {\n\t\tif (X[i]) ans = (ans + pw) % mod;\n\t\tpw = (pw + pw) % mod;\n\t}\n\t\n\ta[1].reset();\n\tfor (int i = dd - 1; i >= p; i--) {\n\t\tif (a[1][i] != X[i]) {\n\t\t\ta[1] ^= (a[0] << (i - p));\n\t\t}\n\t}\n\t\n\tint ok = 1;\n\tfor (int i = p - 1; i >= 0; i--) {\n\t\tif (a[1][i] < X[i]) break;\n\t\tif (a[1][i] > X[i]) { ok = 0; break; }\n\t}\n\tif (ok) ans = (ans + 1) % mod;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE=4000;\nusing Bit=bitset<SIZE>;\n\nusing ll=long long;\nconst ll MOD=998244353;\n\nll powm(ll x,ll k){\n    ll res=1;\n    while(k){\n        if(k&1) res=res*x%MOD;\n        x=x*x%MOD;\n        k>>=1;\n    }\n    return res;\n}\nint main(){\n    int n;\n    Bit x;\n    cin>>n>>x;\n    vector<int> tp(n);\n    vector<Bit> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n    for(int i=0;i<n;i++){\n        if(a[i]!=0) break;\n        if(i+1==n){\n            cout<<1<<endl;\n            return 0;\n        }\n    }\n    auto baseId=[&](){\n        int id=-1;\n        for(int i=0;i<n;i++){\n            if(a[i]==0) continue;\n            if(id==-1){\n                id=i;\n                continue;\n            }\n            for(int j=SIZE-1;j>=0;j--){\n                if(a[id][j] && !a[i][j]){\n                    id=i;\n                    break;\n                }\n                if(!a[id][j] && a[i][j]) break;\n            }\n        }\n        return id;\n    };\n    auto topBit=[&](int id){\n        for(int i=SIZE-1;i>=0;i--){\n            if(a[id][i]){\n                return i;\n            }\n        }\n        return -1;\n    };\n    for(int i=SIZE-1;i>=0;i--){\n        int bid=baseId();\n        int top=topBit(bid);\n        bool delt=false;\n        for(int j=0;j<n;j++){\n            if(a[j]!=0 && j!=bid && a[j][i]){\n                delt=true;\n                a[j]^=(a[bid]<<(i-top));\n            }\n        }\n    }\n\n    ll res=0;\n    int bid=baseId();\n    int top=topBit(bid);\n    cerr<<top<<endl;\n    Bit base=a[bid];    \n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]) res+=powm(2,i-top);\n    }\n    Bit v;\n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]^v[i]) v^=(a[bid]<<(i-top));\n    }\n    for(int i=SIZE-1;i>=0;i--){\n        if(!x[i] && v[i]){\n            break;\n        }\n        if(x[i] && !v[i]){\n            res++;\n            break;\n        }\n        if(i==0) res++;\n    }\n    res%=MOD;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=4003;\nconst int mod=998244353;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,ans,f[N];\nbitset<N>X,G,C;\ninline void Add(int &x,int y){x=x+y<mod?x+y:x+y-mod;}\ninline int deg(bitset<N>&x)\n{\n\trFor(i,4000,0)if(x[i])return i;\n\treturn -1;\n}\ninline void gcd()\n{\n\twhile(1)\n\t{\n\t\tint x=deg(G),y=deg(C);\n\t\tif(x==-1)swap(C,G),swap(x,y);\n\t\tif(y==-1)break;\n\t\tif(x<y)swap(C,G),swap(x,y);\n\t\trFor(i,x,y)if(G[i])G^=C<<(i-y);\n\t}\n}\nint main()\n{\n\tfile();\n\tread(n);cin>>X;\n\tcin>>G;\n\tFor(i,2,n)cin>>C,gcd();\n\tC.reset();\n\tint D=deg(X),d=deg(G);\n\tf[0]=1;For(i,1,D)Add(f[i]=f[i-1],f[i-1]);\n\trFor(i,D,d)\n\t{\n\t\tif(X[i])Add(ans,f[i-d]);\n\t\tif(X[i]^C[i])C^=G<<(i-d);\n\t}\n\tAdd(ans,1);\n\trFor(i,4000,0)\n\t{\n\t\tif(X[i]>C[i])break;\n\t\tif(X[i]<C[i]){Add(ans,mod-1);break;}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n#define MOD 998244353\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\ntypedef bitset<4000> Num;\n\nint N;\nNum X, A[6];\n\nNum in()\n{\n\tchar buf[4040];\n\tscanf(\"%s\", buf);\n\n\tint len = strlen(buf);\n\tNum ret;\n\tfor (int i = 0; i < len; ++i) {\n\t\tif (buf[i] == '1') ret.set(len - 1 - i);\n\t}\n\treturn ret;\n}\n\nint msb(Num a)\n{\n\tfor (int i = 3999; i >= 0; --i) {\n\t\tif (a[i]) return i;\n\t}\n\treturn -1;\n}\n\nNum gcd(Num a, Num b)\n{\n\tfor (;;) {\n\t\tint na = msb(a), nb = msb(b);\n\t\tif (na == -1) return b;\n\t\tif (nb == -1) return a;\n\t\tif (na < nb) {\n\t\t\tb ^= a << (nb - na);\n\t\t} else {\n\t\t\ta ^= b << (na - nb);\n\t\t}\n\t}\n}\n\ni64 toint(Num n)\n{\n\ti64 ret = 0;\n\tfor (int i = 3999; i >= 0; --i) {\n\t\tret = ret * 2 % MOD;\n\t\tret += n[i];\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tX = in();\n\tfor (int i = 0; i < N; ++i) A[i] = in();\n\n\tNum g = A[0];\n\tfor (int i = 1; i < N; ++i) {\n\t\tg = gcd(g, A[i]);\n\t}\n\tint mg = msb(g);\n\ti64 ret = toint(X >> mg);\n\n\tNum waf;\n\tfor (int i = mg; i < 4000; ++i) {\n\t\tif (X[i]) {\n\t\t\twaf ^= g << (i - mg);\n\t\t}\n\t}\n\tbool toolarge = false;\n\tfor (int i = mg; i >= 0; --i) {\n\t\tint xi = X[i];\n\t\tint wi = waf[i];\n\n\t\tif (xi > wi) break;\n\t\tif (xi < wi) {\n\t\t\ttoolarge = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!toolarge) ADD(ret, 1);\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) {\n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; } else { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); } else { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/*  */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tIntMod Combination(const IntMod& right) const {\n\t\tif (value_m < right.value_m) throw \"okashii\";\n\t\treturn Fact() / ((*this - right).Fact() * right.Fact());\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\ntypedef IntMod<1000000007> MInt;\n\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator*(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret *= right;\n//\treturn ret;\n//}\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator/(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret /= right;\n//\treturn ret;\n//}\n\n#if 0\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator >> (istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Graph.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Range.h\"\n#include \"Tree.h\"\n#include \"Union_Find.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator >> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nconst int M = 4064;\nusing Bits = bitset<M>;\nusing Mit = IntMod<998244353>;\n\nint Digit(const Bits& a) {\n\tREM(i, 0, M) {\n\t\tif (a[i]) {\n\t\t\treturn i + 1;\n\t\t}\n\t}\n}\n\nBits GCD(Bits a, Bits b) {\n\tBits* p = &a;\n\tBits* q = &b;\n\tint as = Digit(a) - 1;\n\tint bs = Digit(b) - 1;\n\n\twhile (bs >= 0) {\n\t\twhile (as >= bs) {\n\t\t\t*p ^= *q << (as - bs);\n\t\t\twhile (as >= 0 && (*p)[as] == 0) {\n\t\t\t\t--as;\n\t\t\t}\n\t\t}\n\t\tswap(p, q);\n\t\tswap(as, bs);\n\t}\n\treturn *p;\n}\n\nbool Less(const Bits& a, const Bits& b) {\n\tREM(i, 0, M) {\n\t\tif (a[i] < b[i]) return true;\n\t\tif (a[i] > b[i]) return false;\n\t}\n\treturn false;\n}\n\nBits Inc(const Bits& a) {\n\tBits ret(a);\n\n\tREP(i, 0, M) {\n\t\tif (ret[i]) {\n\t\t\tret[i] = 0;\n\t\t} else {\n\t\t\tret[i] = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nint N;\nBits X;\nBits A[6];\nint main() {\n\tcin >> N >> X;\n\tREP(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\tX = Inc(X);\n\n\tBits gcd = 0;\n\tREP(i, 0, N) {\n\t\tgcd = GCD(gcd, A[i]);\n\t}\n\t\n\tint xs = Digit(X);\n\tint gs = Digit(gcd);\n\n\tMit sum = 0;\n\tREM(i, gs - 1, xs) {\n\t\tif (X[i]) {\n\t\t\tsum += Mit(2).Pow(i - gs + 1);\n\t\t}\n\t}\n\n\tBits Y = 0;\n\tREM(i, gs - 1, xs) {\n\t\tif (Y[i] != X[i]) {\n\t\t\tY ^= gcd << (i - gs + 1);\n\t\t}\n\t}\n\n\tcout << sum + Less(Y, X) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=998244353;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing BS = bitset<4000>;\n\nint N;\nstring X;\nLL pw2[4010];\nBS A[6];\nBS bases[4010];\n\nvoid Add(LL &t, LL v) {\n  t += v;\n  while (t >= MOD) t -= MOD;\n}\n\nBS MakeBitset(string &s) {\n  BS ret;\n  int idx = 3999;\n  rrep(i, s.size()) {\n    if (s[i] == '1') ret[idx] = 1;\n    else if (s[i] == '0') ret[idx] = 0;\n    else assert(0);\n    idx--;\n  }\n  return ret;\n}\n\nint RegBase(BS &v) {\n  while (1) {\n    int idx = v._Find_first();\n    if (idx == v.size()) {\n      assert(v.count() == 0);\n      return -1;\n    }\n\n    if (bases[idx].count() == 0) {\n      bases[idx] = v;\n      return idx;\n    }\n\n    v ^= bases[idx];\n    assert(v._Find_first() > idx);\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  cin >> N >> X;\n  rep(i, N) {\n    string s;\n    cin >> s;\n    A[i] = MakeBitset(s);\n  }\n  sort(A, A+N, [](const BS &a, const BS &b) {\n    if (!a.count()) return false;\n    if (!b.count()) return true;\n    return a._Find_first() > b._Find_first();\n  });\n\n  int idx = A[0]._Find_first();\n  BS v = A[0];\n  while (1) {\n    int res = RegBase(v);\n    assert(res == idx);\n    if (res == -1) break;\n    v = bases[res] >> 1;\n    if (idx == 0) break;\n    idx--;\n  }\n\n  reps(i, 1, N) {\n    v = A[i];\n    idx = A[i]._Find_first();\n    while (1) {\n      int res = RegBase(v);\n      if (res == -1) break;\n      v = bases[res] >> 1;\n    }\n  }\n\n  int m = 0;\n  pw2[0] = 1;\n  rep(i, 4000) {\n    if (bases[i].count()) m++;\n    if (i > 0) {\n      Add(pw2[i], pw2[i-1]);\n      Add(pw2[i], pw2[i-1]);\n    }\n  }\n\n  X = string(4000-X.size(), '0') + X;\n  assert(X.size() == 4000);\n\n  BS cur;\n  LL ans = 1;\n  rep(i, 4000) {\n    if (!bases[i].count()) {\n      if (cur[i] > X[i]-'0') {\n        Add(ans, MOD-1);\n        break;\n      } else if (cur[i] < X[i] - '0') {\n        Add(ans, pw2[m]);\n        Add(ans, MOD-1);\n        break;\n      }\n    }\n\n    if (X[i] == '1') {\n      assert(m > 0);\n      Add(ans, pw2[m-1]);\n      if (!cur[i]) cur ^= bases[i];\n    } else if (X[i] == '0') {\n      if (cur[i]) cur ^= bases[i];\n    }\n\n    --m;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nstring func(string a, string b){\n\tif(a.size() < b.size()) return func(b, a);\n\trep(i, b.size()) a[i] = (a[i] - '0' ^ b[i] - '0') + '0';\n\tint z = 0;\n\trep(i, a.size()) if(a[i] != '0') break; else z++;\n\tif(z == a.size()) return b;\n\treturn func(b, a.substr(z));\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n;\n\tstring x; cin >> n >> x;\n\tvector<string> a(n);\n\trep(i, n) cin >> a[i];\n\t\n\tstring s = a[0];\n\tfor(int i = 1; i < n; i++) s = func(s, a[i]);\n\tdbg(s);\n\t\n\tconst int mod = 998244353;\n\tll ans = 0, pw[5000];\n\tpw[0] = 1; rep(i, 4999) pw[i + 1] = pw[i] * 2 % mod;\n\t\n\tstring y(x.size(), '0');\n\trep(i, (int)x.size() - (int)s.size() + 1){\n\t\tif(x[i] == '1') ans += pw[(int)x.size() - (int)s.size() - i];\n\t\tif(x[i] != y[i]){\n\t\t\trep(j, s.size()) y[i + j] = (y[i + j] - '0' ^ s[j] - '0') + '0';\n\t\t}\n\t}\n\t//dbg(y);\n\t\n\tif(x >= y) ans++;\n\tcout << ans % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int mod = 998244353;\nconst int maxn = 4040;\ntypedef std::bitset<maxn> set;\ninline set gcd(set x,set y) {\n\tfor(int i = 4000;i >= 0;--i) {\n\t\tif(y.none()) return x;\n\t\tif(x.none()) return y;\n\t\tif(x.test(i) || y.test(i)) {\n\t\t\tif(x.test(i) && y.test(i)) y ^= x;\n\t\t\tif(y.none()) return x;\n\t\t\tif(!x.test(i)) std::swap(x, y);\n\t\t\tint h = i; for(;!y.test(h);--h);\n\t\t\tx ^= y << i - h;\n\t\t}\n\t}\n\treturn x.none() ? y : x;\n}\ninline set reduce(set x, set y) {\n\tint h = maxn - 1; for(;!y.test(h);) -- h;\n\tfor(int i = maxn - 1;i >= h;--i) if(x.test(i)) x ^= y << i - h;\n\treturn x;\n}\ninline bool less(set x, set y) {\n\tfor(int i = maxn - 1;i >= 0;--i) if(x.test(i) != y.test(i))\n\t\treturn x.test(i) < y.test(i);\n\treturn 1;\n}\nint n;\nset x, g, now;\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> x;\n\tfor(int i = 0;i < n;++i) {\n\t\tcin >> now, g = gcd(g, now);\n\t}\n\tset p = reduce(x, g);\n\tint ans = less(x ^ p, x);\n\tfor(;(g >>= 1).any();x >>= 1);\n\tfor(int now = 1, i = 0;i < maxn;++i, now = (now + now) % mod) if(x.test(i)) ans = (ans + now) % mod;\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\ntypedef unsigned long long wolf;\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nchar in[2100];\nchar str[2100];\nint main(){\n\tint a;\n\tscanf(\"%d%s\",&a,in);\n\tint n=strlen(in);\n\tbitset<2000> x(in);\n\tbitset<2000> y;\n\tint by,bz;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",str);\n\t\tbitset<2000> z(str);\n\t\tif(i==0){\n\t\t\ty=z;\n\t\t\tby=strlen(str);\n\t\t}else{\n\t\t\tbz=strlen(str);\n\t\t\twhile(bz){\n\t\t\t\tif(by>=bz){\n\t\t\t\t\ty^=(z<<(by-bz));\n\t\t\t\t\twhile(by>0&&y[by-1]==false){\n\t\t\t\t\t\tby--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(by<bz){\n\t\t\t\t\tswap(y,z);\n\t\t\t\t\tswap(by,bz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%s\\n\",y.to_string().c_str());\n\tlong long ret=0;\n\tfor(int i=0;i<=n-by;i++){\n\t\tret=ret*2%mod;\n\t\tif(in[i]=='1')ret=(ret+1)%mod;\n\t}\n\tbitset<2000> tmp;\n\tfor(int i=n-1;i>=by-1;i--){\n\t\tif(tmp[i]!=x[i])tmp^=(y<<(i-by+1));\n\t}\n\t//printf(\"%s\\n\",tmp.to_string().c_str());\n\tbool ok=true;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(tmp[i]!=x[i]){\n\t\t\tif(tmp[i]){ok=false;break;}\n\t\t\telse {break;}\n\t\t}\n\t}\n\tif(ok)ret=(ret+1)%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX=4005;\nconst ll MOD=998244353;\nbitset<MAX> a[6],x,fin;\nint n;\nll fin2,p2[MAX];\nbitset<MAX> xgcd(bitset<MAX> &p,bitset<MAX> &q){\n    bitset<MAX> val=p;\n    int pos1=-1,pos2=-1;\n    for(int i=MAX-1;i>=0;i--) {\n        if(p[i]) pos1=max(pos1,i);\n        if(q[i]) pos2=max(pos2,i);\n    }\n    if(pos2==-1) return val;\n    for(int i=pos1;i>=pos2;i--){\n        if(val[i]) val^=q<<(i-pos2);\n    }\n    return xgcd(q,val);\n}\nvoid cnt(bitset<MAX> &p,bitset<MAX> &q){\n    bitset<MAX> val(0);\n    int pos1=-1,pos2=-1;\n    for(int i=MAX-1;i>=0;i--) {\n        if(p[i]) pos1=max(pos1,i);\n        if(q[i]) pos2=max(pos2,i);\n    }\n    for(int i=pos1;i>=pos2;i--){\n        if(p[i]) fin2+=p2[i-pos2],fin2%=MOD;\n        if(p[i]!=val[i]) val^=q<<(i-pos2);\n    }\n    for(int i=MAX-1;i>=0;i--){\n        if(p[i]<val[i]){\n            return;\n        }\n        else if(p[i]>val[i]){\n            fin2++;return;\n        }\n    }\n    fin2++;\n    return;\n}\nint main(){\n    string t;\n    cin>>n>>t;\n    bitset<MAX> tmp(t);\n    x=tmp;\n    for(int i=0;i<n;i++) {\n        cin>>t;\n        bitset<MAX> tmp(t);\n        a[i]=tmp;\n    }\n    fin=a[0];\n    for(int i=1;i<n;i++) fin=xgcd(fin,a[i]);\n    p2[0]=1;\n    for(int i=1;i<MAX;i++) p2[i]=p2[i-1]*2%MOD;\n    cnt(x,fin);\n    cout<<fin2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint N;\nstring X, G;\nvector<string> A;\n\nstring gcd(string a, string b) {\n    if(a.size() < b.size()) return gcd(b, a);\n    if(b.size() == 0) return a;\n\n    string ret;\n    bool t = false;\n    for(int i = 0; i < b.size(); i++) {\n        char c = a[i] == b[i]? '0' : '1';\n        if(c == '1') t = true;\n        if(t) ret.push_back(c);\n    }\n    for(int i = b.size(); i < a.size(); i++) {\n        if(a[i] == '1') t = true;\n        if(t) ret.push_back(a[i]);\n    }\n    return gcd(ret, b);\n}\n\nbool cmp(string a, string b) {\n    if(a.size() != b.size()) return a.size() < b.size();\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] != b[i]) return a[i] < b[i];\n    }\n    return true;\n}\n\nint str_to_int(string s) {\n    if(s.size() == 0) return 0;\n    int ret = 0;\n    for(int i = 0; i < s.size(); i++) {\n        ret = ret * 2 % mod;\n        if(s[i] == '1') ret = (ret + 1) % mod;\n    }\n    return ret;\n}\n\nstring C;\n\nint dfs(int idx) {\n    if(idx == G.size() + 1) return cmp(C, X);\n    if(C[idx] != X[idx]) {\n        for(int i = idx; i < idx + G.size(); i++) {\n            C[i] = C[i] == G[i - idx]? '0' : '1';\n        }\n    }\n    return dfs(idx + 1);\n}\n\nint ans;\n\nint main() {\n    cin >> N >> X;\n\n    A.resize(N);\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n\n    G = \"\";\n    for(int i = 0; i < N; i++) {\n        G = gcd(A[i], G);\n    }\n\n    if(cmp(X, G)) {\n        cout << 1;\n        return 0;\n    }\n\n    ans = str_to_int(X.substr(0, X.size() - G.size() + 1));\n\n    for(int i = 0; i < X.size(); i++) C.push_back('0');\n    ans += dfs(0);\n    ans %= mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 4096;\nconst int mod = 998244353;\nusing bs = bitset<MAXN>;\n\nint len(bs &x){\n\tfor(int i=MAXN-1; i>=0; i--){\n\t\tif(x[i]) return i + 1;\n\t}\n\treturn 0;\n}\n\nbs MOD(bs a, bs b){\n\tint d = len(a) - len(b);\n\tif(d < 0) return a;\n\treturn a ^ (b << d);\n}\n\nbs gcd(bs a, bs b){\n\tif(len(b) == 0) return a;\n\treturn gcd(b, MOD(a, b));\n}\n\nbs input(){\n\tstring s;\n\tcin >> s;\n\tbs ret = 0;\n\treverse(s.begin(), s.end());\n\tfor(int i=0; i<s.size(); i++){\n\t\tif(s[i] == '1') ret.set(i);\n\t}\n\treturn ret;\n}\n\nint pwr(int x){\n\tint ret = 1;\n\tfor(int i=0; i<x; i++) ret = ret * 2 % mod;\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tbs x = input();\n\tbs g = 0;\n\tfor(int i=0; i<n; i++){\n\t\tg = gcd(g, input());\n\t}\n\tn = len(x);\n\tint m = len(g);\n\tint ret = 1;\n\tbs cur = 0;\n\tfor(int i=n-1; i>=m-1; i--){\n\t\tif(x[i] == 0){\n\t\t\tif(cur[i] == 1){\n\t\t\t\tcur ^= (g << (i - m + 1));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(cur[i] == 0){\n\t\t\t\tret += pwr(i - m + 1);\n\t\t\t\tret %= mod;\n\t\t\t\tcur ^= (g << (i - m + 1));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret += pwr(i - m + 1);\n\t\t\t\tret %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=m-2; i>=0; i--){\n\t\tif(cur[i] < x[i]) break;\n\t\tif(cur[i] > x[i]){\n\t\t\tret += mod - 1;\n\t\t\tret %= mod;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VL vector<long long>\n#define VPII vector<pair<int,int>>\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long>>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 998244353;\nconst int SIZE = 1e6+10;\nbitset<4000>X,d[4000];\nbitset<4000>A[6];\nint len[6],Xn;\nchar s[SIZE];\nint N;\nvoid read(bitset<4000>&input,int& l){\n    RS(s);\n    l=LEN(s);\n    input=bitset<4000>(s);\n}\nint mi_len=0,mi_id=0;\nvoid add(bitset<4000>a,int l){\n    for(int j=l;j>=mi_len;j--){\n        if(a[j])a^=d[j];\n    }\n    if(a.none())return;\n    for(int j=mi_len-1;j>=0;j--){\n        if(a[j]){\n            for(int i=mi_len-1;i>=j;i--){\n                d[i]=a<<(i-j);\n            }\n            int original_len=mi_len;\n            mi_len=j;\n            add(a<<(original_len-j),original_len);\n            return;\n        }\n    }\n}\nint main(){\n    RI(N);\n    read(X,Xn);\n    REP(i,N)read(A[i],len[i]);\n    mi_len=4000;\n    REP(i,N){\n        if(mi_len>len[i]){\n            mi_len=len[i];\n            mi_id=i;\n        }\n    }\n    mi_len--;\n    for(int i=3999;i>=mi_len;i--){\n        d[i]=A[mi_id]<<(i-mi_len);\n    }\n    REP(i,N){\n        if(i==mi_len)continue;\n        add(A[i],len[i]-1);\n    }\n    bitset<4000>fin=X;\n    LL an=0;\n    for(int i=Xn-1;i>=mi_len;i--){\n        //for(int j=i;j>=0;j--)printf(\"%d\",(int)d[i][j]);\n        //puts(\"\");\n        an*=2;\n        if(X[i])an++;\n        an%=MOD;\n        if(fin[i])fin^=d[i];\n    }\n    bool suc=1;\n    for(int i=mi_len-1;i>=0;i--){\n        if(fin[i]){\n            if(!X[i]){\n                suc=0;\n            }\n            break;\n        }\n    }\n    if(suc)an++;\n    printf(\"%lld\\n\",an%MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MOD = 998244353;\nconst Int MAX = 5050;\nusing BS = bitset<MAX>;\n\nInt msb(BS a){\n  for(Int i=MAX-1;i>=0;i--)\n    if(a[i]) return i;\n  return -1;\n}\n\nBS gcd(BS a,BS b){\n  Int x=msb(a),y=msb(b);\n  if(x<y) swap(a,b),swap(x,y);\n  if(y<0) assert(x>=0);\n  if(y<0) return a;\n  Int d=x-y;\n  return gcd(a^(b<<d),b);\n}\n\nsigned main(){\n  Int n;\n  string x;\n  cin>>n>>x;\n  vector<string> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n\n  BS g(a[0]);\n  for(Int i=1;i<n;i++) g=gcd(g,BS(a[i]));\n  \n  BS z(x);  \n  Int ans=0,m=msb(g);\n  for(Int i=MAX-1;i>=m;i--){\n    ans=ans*2+z[i];\n    ans%=MOD;\n  }\n  \n  BS t(0);\n  for(Int i=MAX-1;i>=m;i--)\n    if(t[i]^z[i]) t^=g<<(i-m);\n\n  for(Int i=m;i>=0;i--){\n    if(t[i]<z[i]) ans++;\n    if(t[i]!=z[i]) break;\n    if(i==0) ans++;\n  }\n  \n  ans%=MOD;  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4005,mod=998244353;\ntypedef bitset<N>Bit;\nint n,p[N];\nBit x,y,a[6];\nint last(Bit x)\n{\n    for(int i=N-1;i>=0;i--)\n        if(x[i]) return i;\n    return -1;\n}\nBit gcd(Bit x,Bit y)\n{\n    if(x.none()) return y;\n    if(y.none()) return x;\n    int s=last(x),t=last(y);\n    if(s<t) return gcd(x,y^(x<<t-s));\n    return gcd(y,x^(y<<s-t));\n}\nint main()\n{\n    p[0]=1;\n    for(int i=1;i<N;i++) p[i]=p[i-1]*2%mod;\n    cin>>n>>x;\n    for(int i=0;i<n;i++) cin>>a[i];\n    for(int i=1;i<n;i++) a[0]=gcd(a[0],a[i]);\n    int s=last(x),t=last(a[0]);\n    int ans=0;\n    for(int i=s;i>=t;i--)\n    {\n        if(x[i]) ans=(ans+p[i-t])%mod;\n        if(x[i]!=y[i]) y^=a[0]<<(i-t);\n    }\n    for(int i=s;i>=0;i--)\n        if(x[i]!=y[i])\n    {\n        ans+=x[i];break;\n    }\n    else if(i==0) ans++;\n    printf(\"%lld\\n\",ans%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=998244353;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing BS = bitset<4000>;\n\nint N;\nstring X;\nLL pw2[4010];\nBS A[6];\nBS bases[4010];\n\nvoid Add(LL &t, LL v) {\n  t += v;\n  while (t >= MOD) t -= MOD;\n}\n\nBS MakeBitset(string &s) {\n  BS ret;\n  int idx = 3999;\n  rrep(i, s.size()) {\n    if (s[i] == '1') ret[idx] = 1;\n    else if (s[i] == '0') ret[idx] = 0;\n    else assert(0);\n    idx--;\n  }\n  return ret;\n}\n\nint RegBase(BS &v) {\n  while (1) {\n    int idx = v._Find_first();\n    if (idx == v.size()) {\n      assert(v.count() == 0);\n      return -1;\n    }\n\n    if (bases[idx].count() == 0) {\n      bases[idx] = v;\n      return idx;\n    }\n\n    v ^= bases[idx];\n    assert(v._Find_first() > idx);\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  cin >> N >> X;\n  rep(i, N) {\n    string s;\n    cin >> s;\n    A[i] = MakeBitset(s);\n  }\n  sort(A, A+N, [](const BS &a, const BS &b) {return a._Find_first() > b._Find_first();});\n\n  int idx = A[0]._Find_first();\n  BS v = A[0];\n  while (1) {\n    int res = RegBase(v);\n    assert(res == idx);\n    if (res == -1) break;\n    v = bases[res] >> 1;\n    if (idx == 0) break;\n    idx--;\n  }\n\n  reps(i, 1, N) {\n    v = A[i];\n    idx = A[i]._Find_first();\n    while (1) {\n      int res = RegBase(v);\n      if (res == -1) break;\n      v = bases[res] >> 1;\n    }\n  }\n\n  int m = 0;\n  pw2[0] = 1;\n  rep(i, 4000) {\n    if (bases[i].count()) m++;\n    if (i > 0) {\n      Add(pw2[i], pw2[i-1]);\n      Add(pw2[i], pw2[i-1]);\n    }\n  }\n\n  X = string(4000-X.size(), '0') + X;\n  assert(X.size() == 4000);\n\n  BS cur;\n  LL ans = 1;\n  rep(i, 4000) {\n    if (!bases[i].count()) {\n      if (cur[i] > X[i]-'0') {\n        Add(ans, MOD-1);\n        break;\n      } else if (cur[i] < X[i] - '0') {\n        Add(ans, pw2[m]);\n        Add(ans, MOD-1);\n        break;\n      }\n    }\n\n    if (X[i] == '1') {\n      assert(m > 0);\n      Add(ans, pw2[m-1]);\n      if (!cur[i]) cur ^= bases[i];\n    } else if (X[i] == '0') {\n      if (cur[i]) cur ^= bases[i];\n    }\n\n    --m;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 998244353;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\nconst ll len = 4010;\ntypedef bitset<len> bs;\nnamespace SOLVE {\n    bs gcd(bs a, bs b){\n        while (a.count() and b.count()) {\n            int h[2] = {0,0};\n            REP(i,0,len){\n                if(a[i])h[0] = i;\n                if(b[i])h[1] = i;\n            }\n            if(h[0]<=h[1]){\n                b^=a<<(h[1]-h[0]);\n            }else{\n                a^=b<<(h[0]-h[1]);\n            }\n        }\n        if(a.count())return a;\n        return b;\n    }\n    bs g,x;\n    int get_deg(bs x){\n        RREP(i,len-1,0)if(x[i])return i;\n        return -1;\n    }\n    bool operator<(const bs&a,const bs&b){\n        RREP(i,len-1,0)if(a[i]!=b[i])return a[i]<b[i];\n        return false;\n    }\n    ll ans = 0;\n    void main(){\n        int n;\n        cin>>n>>x;\n        \n        REP(i,0,n){\n            bs b;\n            cin>>b;\n            g = gcd(b, g);\n        }\n        int deg = get_deg(g);\n        RREP(i,len-1,deg){\n            if(x[i]){\n                ans += fast(2, i-deg, mod);\n                \n            }\n        }\n        if(x<g){\n            cout<<1<<endl;\n            return;\n        }\n        ans+=gcd(x, g)==g;\n        cout<< MOD(ans,mod)<<endl;\n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << endl\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/2;\nconst ll MOD = 998244353;\n\ninline ll add(ll a, ll b, ll M) { // a + b (mod M)\n    return (a += b) >= M ? a - M : a;\n}\ninline ll sub(ll a, ll b, ll M) { // a - b (mod M)\n    return (a -= b) < 0 ? a + M : a;\n}\ninline ll mul(ll a, ll b, ll M) { // a * b (mod M)\n    ll r = a*b - (ll)((long double)(a)*b/M+.5)*M;\n    return r < 0 ? r + M: r;\n}\ninline ll div(ll a, ll b, ll M) { // solve b x == a (mod M)\n    ll u = 1, x = 0, s = b, t = M;\n    while (s) { // extgcd for b x + M s = t\n        ll q = t / s;\n        swap(x -= u * q, u);\n        swap(t -= s * q, s);\n    }\n    if (a % t) return -1; // infeasible\n    return mul(x < 0 ? x + M : x, a / t, M); // b (xa/t) == a (mod M)\n}\ninline ll pow(ll a, ll b, ll M) {\n    ll x = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) x = (a * x) % M;\n        a = (a * a) % M;\n    }\n    return x;\n}\n\n// p(x) = p[0] + p[1] x + ... + p[n-1] x^n-1\n// assertion: p.back() != 0\ntypedef vector<ll> poly;\nostream& operator<<(ostream &os, const poly &p) {\n    bool head = true;\n    for (size_t i = 0; i < p.size(); ++i) {\n        if (p[i] == 0) continue;\n        if (!head) os << \" + \";\n        os << p[i];\n        head = false;\n        if (i >= 1) os << \" x\";\n        if (i >= 2) os << \"^\" << i;\n    }\n    return os;\n}\ninline poly add(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = add(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\ninline poly sub(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = sub(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\n\n\n/*\n// FFT-based multiplication: this works correctly for M in [int]\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root, int sign>\ninline void fmt(vector<ll>& x) {\n    const int n = x.size();\n    int h = pow(primitive_root, (mod-1)/n, mod);\n    if (sign < 0) h = div(1, h, mod);\n    for (int i = 0, j = 1; j < n-1; ++j) {\n        for (int k = n >> 1; k > (i ^= k); k >>= 1);\n        if (j < i) swap(x[i], x[j]);\n    }\n    for (int m = 1; m < n; m *= 2) {\n        ll w = 1, wk = pow(h, n / (2*m), mod);\n        for (int i = 0; i < m; ++i) {\n            for (int s = i; s < n; s += 2*m) {\n                ll u = x[s], d = x[s + m] * w % mod;\n                if ((x[s] = u + d) >= mod) x[s] -= mod;\n                if ((x[s + m] = u - d) < 0) x[s + m] += mod;\n            }\n            w = w * wk % mod;\n        }\n    }\n    if (sign < 0) {\n        ll inv = div(1, n, mod);\n        for (auto &a: x)\n            a = a * inv % mod;\n    }\n}\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root>\ninline vector<ll> conv(vector<ll> a, vector<ll> b){\n    fmt<mod,primitive_root,+1>(a); fmt<mod,primitive_root,+1>(b);\n    for (size_t i = 0; i < a.size(); ++i)\n        a[i] = a[i] * b[i] % mod;\n    fmt<mod,primitive_root,-1>(a);\n    return a;\n}\n// general convolution where mod < 2^31.\ninline vector<ll> conv(vector<ll> a, vector<ll> b, ll mod){\n    int n = a.size() + b.size() - 1;\n    for (int k: {1,2,4,8,16}) n |= (n >> k);\n    ++n;\n    a.resize(n); b.resize(n);\n    const int A = 167772161, B = 469762049, C = 1224736769, D = (ll)(A) * B % mod;\n    if(mod==A)return conv<A,3>(a,b);\n    if(mod==B)return conv<B,3>(a,b);\n    if(mod==C)return conv<C,3>(a,b);\n    if(mod==924844033)return conv<924844033,5>(a,b);\n    vector<ll> x = conv<A,3>(a,b), y = conv<B,3>(a,b), z = conv<C,3>(a,b);\n    for (size_t i = 0; i < x.size(); ++i) {\n        ll X = (y[i] - x[i]) * 104391568;\n        if ((X %= B) < 0) X += B;\n        ll Y = (z[i] - (x[i] + A * X) % C) * 721017874;\n        if ((Y %= C) < 0) Y += C;\n        x[i] += A * X + D * Y;\n        if ((x[i] %= mod) < 0) x[i] += mod;\n    }\n    x.resize(n);\n    return x;\n}\n\ninline poly mul(poly p, poly q, ll M) {\n    poly pq = conv(p, q, M);\n    pq.resize(p.size() + q.size() - 1);\n    while (!pq.empty() && !pq.back()) pq.pop_back();\n    return pq;\n}\n*/\nnamespace FFT {\n    const int max_base = 19, maxN = 1 << max_base; // N <= 2e5\n    const double PI = acos(-1);\n    struct num {\n        double x{}, y{};\n        num() = default;\n        num(double x,double y): x(x), y(y) {}\n        explicit num(double r): x(cos(r)), y(sin(r)) {}\n    };\n    inline num operator+(num a, num b) { return {a.x + b.x, a.y + b.y}; }\n    inline num operator-(num a, num b) { return {a.x - b.x, a.y - b.y}; }\n    inline num operator*(num a, num b) { return {a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x}; }\n    inline num conj(num a) {return {a.x, -a.y}; }\n    num root[maxN];\n    int rev[maxN];\n    bool is_root_prepared = false;\n\n    inline void prepare_root(){\n        if(is_root_prepared) return;\n        is_root_prepared = true;\n        root[1] = num(1, 0);\n        for (int i = 1; i < max_base; ++i) {\n            num x(2*PI / (1LL << (i+1)));\n            for (ll j = (1LL << (i-1)); j < (1LL << (i)); ++j) {\n                root[2*j] = root[j];\n                root[2*j+1] = root[j]*x;\n            }\n        }\n    }\n\n    int base=1, N=2;\n    int lastN = -1;\n\n    inline void prepare_rev(){\n        if(lastN == N) return;\n        lastN = N;\n        for (int i = 0; i < N; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (base - 1));\n    }\n\n    inline void fft(num *a, num *f){\n        for (int i = 0; i < N; ++i) f[i] = a[rev[i]];\n        for (int k = 1; k < N; k <<= 1) {\n            for (int i = 0; i < N; i += 2*k) {\n                for (int j = 0; j < k; ++j) {\n                    num z = f[i+j+k]* root[j+k];\n                    f[i+j+k] = f[i+j] - z;\n                    f[i+j] = f[i+j] + z;\n                }\n            }\n        }\n    }\n    num a[maxN], b[maxN], f[maxN], g[maxN];\n    ll A[maxN], B[maxN], C[maxN];\n\n    inline void multi_mod(int m){\n        for (int i = 0; i < N; ++i) {\n            ll x = A[i] % m;\n            a[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        for (int i = 0; i < N; ++i) {\n            ll x = B[i] % m;\n            b[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            int j = (N-i) &(N-1);\n            num a1 = (f[i] + conj(f[j])) * num(0.5, 0);\n            num a2 = (f[i] - conj(f[j])) * num(0, -0.5);\n            num b1 = (g[i] + conj(g[j])) * num(0.5/N, 0);\n            num b2 = (g[i] - conj(g[j])) * num(0, -0.5/N);\n            a[j] = a1*b1 + a2*b2 * num(0, 1);\n            b[j] = a1*b2 + a2*b1;\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            ll aa = f[i].x + 0.5;\n            ll bb = g[i].x + 0.5;\n            ll cc = f[i].y + 0.5;\n            C[i] = (aa + bb % m * (1LL << 15) + cc% m *(1LL << 30)) % m;\n        }\n    }\n\n    inline void prepare_AB(int n1, int n2){\n        if(N > n1+n2){\n            base = 1;\n            N = 2;\n        }\n        while(N < n1+n2) base++, N <<= 1;\n        for (int i = n1; i < N; ++i) A[i] = 0;\n        for (int i = n2; i < N; ++i) B[i] = 0;\n        prepare_root();\n        prepare_rev();\n    }\n\n    inline void multi_mod(int n1, int n2, int m){\n        prepare_AB(n1, n2);\n        multi_mod(m);\n    }\n}\ninline poly mul(poly A, poly B,int M){\n    while(!A.empty()&&!A.back())A.pop_back();\n    while(!B.empty()&&!B.back())B.pop_back();\n    poly C(A.size() + B.size()-1);\n    for (size_t i = 0; i < A.size(); ++i) FFT::A[i] = A[i];\n    for (size_t i = 0; i < B.size(); ++i) FFT::B[i] = B[i];\n    FFT::multi_mod(A.size(), B.size(), M);\n    for (size_t i = 0; i < C.size(); ++i) C[i] = FFT::C[i];\n    while(!C.empty()&&!C.back())C.pop_back();\n    return C;\n}\n\n\ninline pair<poly,poly> divmod(poly p, poly q, ll M) {\n    if (p.size() < q.size()) return { {}, p };\n    reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    poly t = {div(1, q[0], M)};\n    if (t[0] < 0) return { {}, {} }; // infeasible\n    for (size_t k = 1; k <= 2*(p.size()-q.size()+1); k *= 2) {\n        poly qq=q;\n        if(k+1<q.size())qq.resize(k+1);\n        while (!qq.empty() && !qq.back()) qq.pop_back();\n        poly s = mul(mul(t, t, M), qq, M);\n        t.resize(k);\n        for (size_t i = 0; i < k; ++i)\n            t[i] = sub(2*t[i], s[i], M);\n    }\n    t.resize(p.size() - q.size() + 1);\n    poly pp=p;\n    pp.resize(p.size() - q.size() + 1);\n    while (!pp.empty() && !pp.back()) pp.pop_back();\n    t = mul(t, pp, M);\n    t.resize(p.size() - q.size() + 1);\n    reverse(t.begin(),t.end()); reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    while (!t.empty() && !t.back()) t.pop_back();\n    return {t, sub(p, mul(q, t, M), M) };\n}\npoly gcd(poly p, poly q, ll M) {\n    for (; !p.empty(); swap(p, q = divmod(q, p, M).second)){\n      while(!p.empty()&&!p.back())p.pop_back();\n      while(!q.empty()&&!q.back())q.pop_back();\n    }\n    while(!q.empty()&&!q.back())q.pop_back();\n    return q;\n}\n\n#include <ctime>\ndouble tick() {\n  static clock_t oldtick;\n  clock_t newtick = clock();\n  double diff = 1.0*(newtick - oldtick) / CLOCKS_PER_SEC;\n  oldtick = newtick;\n  return diff;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  //tick();\n  ll N;cin>>N;\n  string X;cin>>X;reverse(X.begin(),X.end());\n  string A;cin>>A;reverse(A.begin(),A.end());\n  poly g(A.length());\n  for(size_t i=0;i<A.length();i++){\n    g[i]=A[i]-'0';\n  }\n  //debug(g);\n  for(ll i=1;i<N;i++){\n    cin >> A;\n    reverse(A.begin(),A.end());\n    poly p(A.length());\n    for(size_t i=0;i<A.length();i++){\n      p[i]=A[i]-'0';\n    }\n    g=gcd(p,g,2);\n  }\n  //debug(g);\n  ll ans=0;\n  size_t d=g.size();\n  //debug(d);\n  poly q(X.length(),0);\n  ll pw=1;\n  for(size_t i=d-1;i<X.length();i++){\n    q[i]=X[i]-'0';\n    if(X[i]>'0')ans = (ans+pw)%MOD;\n    pw = pw*2%MOD;\n  }\n  //debug(q);\n  poly r=divmod(q,g,2).second;\n  r.resize(d-1);\n  bool isok=true;\n  for(size_t i=d-2;i>=0;i--){\n    if(r[i]==X[i]-'0')continue;\n    isok = r[i]<X[i]-'0';\n    break;\n  }\n  ans = (ans+isok)%MOD;\n  cout<<ans<<endl;\n  //debug(tick());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 4040\n\nlong long mod=998244353;\nlong long n;\nbitset<N> p,q,r;\n\nvoid bitsetSubtract(bitset<N> &x, const bitset<N> &y) {\n    bool b = false;\n\n    for (int i = 0; i < N; i++) {\n        if (b) {\n            if (x[i]) {\n                x[i] = y[i];\n                b = y[i];\n            } else {\n                x[i] = !y[i];\n                b = true;\n            }\n        } else {\n            if (x[i]) {\n                x[i] = !y[i];\n                b = false;\n            } else {\n                x[i] = y[i];\n                b = y[i];\n            }\n        }\n    }\n}\n\nbitset<N> gcd(bitset<N> u, bitset<N> v) {\n    bitset<N> one (string(\"1\"));\n    bitset<N> zero (string(\"0\"));\n\n    int shift;\n\n    if (u == 0) return v;\n    if (v == 0) return u;\n\n    for (shift = 0; ((u | v) & one) == zero; ++shift) {\n        u >>= 1;\n        v >>= 1;\n    }\n\n    while ((u & one) == zero) u >>= 1;\n\n    do {\n        while ((v & one) == zero) v >>= 1;\n\n        if (u.to_string() > v.to_string()) {\n            bitset<N> t = v;\n            v = u;\n            u = t;\n        }\n\n        bitsetSubtract(v,u);\n    } while (v != 0);\n\n    return u << shift;\n}\nlong long ans,dp1[N+1],dp2[N+1],dp3[N+1],cnt1,cnt2;\nint main(){\n  dp2[1]=1;\n  dp3[0]=0;\n    cin>>n>>p>>q;\n    for(int i=1;i<n;i++){\n      cin>>r;\n      q=gcd(q,r);\n    }\n    cout<<q<<endl;\n    for(int i=1;i<=N;i++){\n      dp2[i+1]=(dp2[i]*2)%mod;\n      if(p[i-1]){\n        dp3[i]=(dp3[i-1]+dp2[i])%mod;\n        cnt2=i;\n      }\n      else dp3[i]=dp3[i-1];\n      if(q[i-1]){\n        cnt1=i+1;\n    }\n  }\n    cout<<dp3[cnt2]/dp2[cnt1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst ll MOD = 998244353;\nconst int MX = 4010;\nconst int INF = 1e5;\nbitset<MX> a[8];\nbitset<MX> X;\nint n;\nchar buf[10000];\n\nvoid read(bitset<MX> &b) {\n\tscanf(\" %s\", buf);\n\tint n = strlen(buf);\n\tfor (int i = 0; i < n; ++i) {\n\t\tb[n - 1 - i] = (buf[i] == '1' ? 1 : 0);\n\t}\n}\n\nint getl(const bitset<MX> &b) {\n\tfor (int i = MX - 1; i >= 0; --i) {\n\t\tif (b[i])\n\t\t\treturn i;\n\t}\n\treturn INF;\n}\n\nint main() {\n\tcin >> n;\n\tread(X);\n\tfor (int i = 0; i < n; ++i)\n\t\tread(a[i]);\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (true) {\n\t\t\tint l = getl(a[0]);\n\t\t\tint r = getl(a[i]);\n\t\t\tif (l > r)\n\t\t\t\tswap(a[0], a[i]), swap(l, r);\n\t\t\tif (r == INF)\n\t\t\t\tbreak;\n\t\t\ta[i] ^= (a[0] << (r - l));\n\t\t}\n\t}\n\tint p = getl(a[0]);\n\tll pw = 1;\n\tll ans = 0;\n\tfor (int i = p; i < MX; ++i, pw = (pw * 2) % MOD) {\n\t\tif (X[i]) {\n\t\t\tans = (ans + pw) % MOD;\n\t\t}\n\t}\n\ta[1].reset();\n\tfor (int i = MX - 1; i >= p; --i) {\n\t\tif (a[1][i] != X[i])\n\t\t\ta[1] ^= (a[0] << (i - p));\n\t}\n\tint fl = 0;\n\tfor (int i = p - 1; i >= 0; --i) {\n\t\tif (a[1][i] > X[i]) {\n\t\t\tfl = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (a[1][i] < X[i])\n\t\t\tbreak;\n\t}\n\tif (!fl) {\n\t\tans = (ans + 1) % MOD;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 998244353;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<u32 M = 1000000007>\nstruct modint{\n    u32 val;\n    modint(): val(0){}\n    template<typename T>\n    modint(T t){t %= (T)M; if(t < 0) t += (T)M; val = t;}\n\n    modint pow(ll k) const {\n        modint res(1), x(val);\n        while(k){\n            if(k&1) res *= x;\n            x *= x;\n            k >>= 1;\n        }\n        return res;\n    }\n    template<typename T>\n    modint& operator=(T t){t %= (T)M; if(t < 0) t += (T)M; val = t; return *this;}\n    modint inv() const {return pow(M-2);}\n    modint& operator+=(modint a){val += a.val; if(val >= M) val -= M; return *this;}\n    modint& operator-=(modint a){if(val < a.val) val += M-a.val; else val -= a.val; return *this;}\n    modint& operator*=(modint a){val = (u64)val*a.val%M; return *this;}\n    modint& operator/=(modint a){return (*this) *= a.inv();}\n    modint operator+(modint a) const {return modint(val) +=a;}\n    modint operator-(modint a) const {return modint(val) -=a;}\n    modint operator*(modint a) const {return modint(val) *=a;}\n    modint operator/(modint a) const {return modint(val) /=a;}\n    modint operator-(){return modint(M-val);}\n    bool operator==(const modint a) const {return val == a.val;}\n    bool operator!=(const modint a) const {return val != a.val;}\n    bool operator<(const modint a) const {return val < a.val;}\n};\nusing mint = modint<MOD>;\n\nint main() {\n    using B = bitset<4000>;\n    auto f = [&](string &s) -> B {\n        B res;\n        for (int i = 0; i < s.size(); ++i) {\n            if(s[i] == '1') res.set(4000+i-(int)s.size());\n        }\n        return res;\n    };\n    int n; B X;\n    cin >> n;\n    vector<B> v(n);\n    {\n        string x;\n        cin >> x;\n        X = f(x);\n        for (int i = 0; i < n; ++i) cin >> x, v[i] = f(x);\n    }\n    for (int i = 1; i < n; ++i) {\n        int a = v[0]._Find_first(), b = v[i]._Find_first();\n\n        while(true){\n            if(a == 4000 || b == 4000) {\n                if(a == 4000) swap(v[0], v[i]);\n                break;\n            }\n            if(a > b){\n                v[i] ^= (v[0] >> (a-b));\n                b = v[i]._Find_first();\n            }else {\n                v[0] ^= (v[i] >> (b-a));\n                a = v[0]._Find_first();\n            }\n        }\n    }\n\n    int a = v[0]._Find_first(), b = X._Find_first();\n    B Y;\n    mint ans = 0;\n    for (int i = b; i <= a; ++i) {\n        if(X[i]) {\n            ans += mint(2).pow(a-i);\n        }\n        if(X[i] != Y[i]){\n            Y ^= (v[0] >> (a-i));\n        }\n    }\n    int ok = 1;\n    for (int i = 3999; i >= 0; --i) {\n        if(X[i] && !Y[i]) {\n            ok = 0;\n            break;\n        }\n        else if(!X[i] && Y[i]) break;\n    }\n    if(ok) ans += mint(1);\n    cout << ans.val << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt operator+(const modInt &n){return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n){return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n){return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n){return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n){return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n){return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n){return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n){return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\n\n\nint solve(bitset<4000> x,int n,\n\t\t\t\t\t bitset<4000> a,int m){\n\trrep(i,4000){\n\t\tif(a[i] && !x[i]) return 1;\n\t\tif(!a[i] && x[i]) break;\n\t}\n\tif(n<m) return 1;\n\t//rrep(j,20)cout<<x[j];cout<<endl;\n\tll re=0;\n\tbitset<4000> sum; sum.reset();\n\trreps(i,m,n){\n\t\t(re*=2)%=MOD;\n\t\tif(x[i]) (re+=1)%=MOD;\n\t\tif(x[i]!=sum[i]) sum^=a<<(i-m+1);\n\t}\n\t(re*=2)%=MOD;\n\trep(_,2){\n\t\tint ok=1;\n\t\t// rrep(j,20)cout<<sum[j];cout<<endl;\n\t\t// rrep(j,20)cout<<x[j];cout<<endl;\n\t\trrep(i,4000){\n\t\t\tif(i>=m) assert(x[i]==sum[i]);\n\t\t\tif(sum[i] && !x[i]){ ok=0; break;}\n\t\t\tif(!sum[i] && x[i]){ break;}\n\t\t}\n\t\t// out(ok,1);\n\t\tif(ok) (re+=1)%=MOD;\n\t\tsum^=a;\n\t}\n\t//out(re,ret,1);\n\treturn re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n\tstring x;\n\tcin>>n>>x;\n\tvector<pair<bitset<4000>,int>> as(n);\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tas[i].Y=s.size();\n\t\tas[i].X.reset();\n\t\trep(j,s.size()) as[i].X[j]=(s[s.size()-1-j]-'0');\n\t}\n\t// rep(i,as.size()){rrep(j,20)cout<<as[i].X[j];cout<<endl;}cout<<endl;\n\twhile(as.size()>1){\n\t\tsort(rall(as),[&](auto &l,auto &r){\n\t\t\t\treturn l.Y<r.Y;\n\t\t\t});\n\t\twhile(1){\n\t\t\tint upd=0;\n\t\t\trep(i,as.size())rep(j,i)if(as[i]==as[j]){\n\t\t\t\tas.erase(as.begin()+j);\n\t\t\t\tupd=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,as.size())if(as[i].Y==0){\n\t\t\t\tas.erase(as.begin()+i);\n\t\t\t\tupd=1;\n\t\t\t}\n\t\t\tif(!upd) break;\n\t\t}\n\t\twhile(as.size() && as.back().Y==0) as.pop_back();\n\t\tif(as.size()<=1) break;\n\t\tas[0].X^=as[1].X<<(as[0].Y-as[1].Y);\n\t\tas[0].Y=0;\n\t\trep(i,4000){\n\t\t\tif(as[0].X[i]) as[0].Y=i+1;\n\t\t}\n\t}\n\t// rep(i,as.size()){rrep(j,20)cout<<as[i].X[j];cout<<\",\"<<as[i].Y<<endl;}cout<<endl;\n\tassert(as.size()==1);\n\t\n\tbitset<4000> st; st.reset();\n\trep(j,x.size()) st[j]=(x[x.size()-1-j]-'0');\n\tcout<<solve(st,x.size(),as[0].X,as[0].Y)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=16,M=100005,mod=998244353;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\n#define big bitset<N>\n\nint n,pw[N];\nbig x,d,a;\n\ninline bool operator <= (big a,big b){\n\tfor(int i=4000;~i;i--)\n\t\tif(a[i]&&!b[i]) return 0; else if(!a[i]&&b[i]) return 1;\n\treturn 1;\n}\n\ninline void in(big &a){\n\ta=0;\n\tstatic char s[N];\n\tstatic int n;\n\treads(s);n=strlen(s);\n\treverse(s,s+n);\n\tfor(int i=0;i<n;i++)\n\t\ta[i]=(s[i]=='1');\n}\ninline int getlen(big a){\n\tfor(int i=4000;~i;i--)\n\t\tif(a[i]) return i;\n\treturn -1;\n}\ninline big gcd(big a,big b){\n\tint la=getlen(a),lb=getlen(b);\n\twhile(~la&&~lb){\n\t\tif(la>=lb){\n\t\t\tfor(int i=la;i>=lb;i--)\n\t\t\t\tif(a[i]) a^=(b<<i-lb);\n\t\t\twhile(~la&&!a[la]) la--;\n\t\t}\n\t\telse{\n\t\t\tfor(int i=lb;i>=la;i--)\n\t\t\t\tif(b[i]) b^=(a<<i-la);\n\t\t\twhile(~lb&&!b[lb]) lb--;\n\t\t}\n\t}\n\treturn a|b;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tpw[0]=1;\n\tfor(int i=1;i<N;i++) pw[i]=pw[i-1]*2%mod;\n\tread(n);in(x);\n\td.reset();\n\tfor(int i=1;i<=n;i++){\n\t\tin(a);\n\t\td=gcd(d,a);\n\t}\n\tint m=getlen(x),n=getlen(d);\n\tbig tmp=0;int ans=0;\n\tfor(int i=m;i>=n;i--){\n\t\tif(x[i]) ch(ans,pw[i-n]);\n\t\tif(x[i]^tmp[i]) tmp^=d<<i-n;\n\t}\n\tif(tmp<=x) ch(ans,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\ninline int deg(const bitset <N> &b) {\n  int t = N - 1;\n  while (t >= 0 && !b[t]) t --;\n  return t + 1;\n}\n\nint n;\nchar buf[N];\n\ninline void read(bitset <N> &b) {\n  scanf(\"%s\", buf);\n  reverse(buf, buf + strlen(buf));\n  for (int i = 0; buf[i]; i ++)\n    b[i] = (bool)(buf[i] - '0');\n}\n\nbitset <N> X, A[N];\n\ninline bitset <N> gcd(bitset <N> p, bitset <N> q) {\n  int a = deg(p);\n  int b = deg(q);\n  while (true) {\n    if (!a) return q;\n    if (!b) return p;\n    if (a < b) {\n      swap(p, q); swap(a, b);\n    }\n    p ^= q << (a - b);\n    while (a >= 0 && p[a] == 0) a --;\n    a ++;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  read(X);\n  for (int i = 1; i <= n; i ++) read(A[i]);\n  for (int i = 2; i <= n; i ++)\n    A[1] = gcd(A[1], A[i]);\n  int ans = 0, j = deg(A[1]);\n  for (int i = deg(X) - 1; i >= j - 1; i --) \n    ans = ((ans << 1) + X[i]) % mod;\n  for (int i = deg(X) - 1; i >= j; i --)\n    if (X[i]) X ^= A[1] << (i - j);\n  for (int i = j - 1; ~ i; i --)\n    if (A[i][1] != X[i]) {\n      if (A[i][1] > X[1]) ans --;\n      break;\n    }\n  ans = (ans + 1) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\nvector<bool> input(){\n\tstring s;\n\tcin>>s;\n\tint N = s.size();\n\tvector<bool> x(N);\n\trep(i,N) x[i] = s[i]=='1';\n\treturn x;\n}\nvoid normalize(vector<bool>& a){\n\tvector<bool> b;\n\tint N = a.size();\n\tbool yet = 1;\n\trep(i,N){\n\t\tif(a[i]){\n\t\t\tyet = 0;\n\t\t}\n\t\tif(!yet) b.pb(a[i]);\n\t}\n\ta = b;\n}\nvector<bool> gcd(vector<bool> a,vector<bool> b){\n\tnormalize(a);\n\tnormalize(b);\n\tint N = a.size(), M = b.size();\n\tif(N<M) swap(a,b),swap(N,M);\n\n\tif(M==0) return a;\n\n\trep(i,M) a[i] = a[i] ^ b[i];\n\treturn gcd(a,b);\n}\n\nint N;\nint main(){\n\tcin>>N;\n\tvector<bool> X = input();\n\tvector<bool> g;\n\trep(i,N){\n\t\tvector<bool> f;\n\t\tf = input();\n\t\tg = gcd(g,f);\n\t}\n\tvector<mint> p2(5000);\n\tp2[0] = 1;\n\trep1(i,4999) p2[i] = p2[i-1]*2;\n\n\tmint ans = 0;\n\tvector<bool> oX = X;\n\tint a = X.size();\n\tint b = g.size();\n\trep(i,a-b+1){\n\t\tif(X[i]){\n\t\t\trep(j,b) X[i+j] = X[i+j] ^ g[j];\n\t\t}\n\t\tif(oX[i]){\n\t\t\tans += p2[a-(i+b)];\n\t\t}\n\t}\n\tcout<<ans+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bitset>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\nbitset <N> x, y, G, a[10];\nint n;\n\nbitset <N> gcd(bitset <N> A, bitset <N> B)\n{\n    int i = N - 1, j = N - 1;\n    while(1)\n    {\n        for(; ~i && !A[i]; --i);\n        for(; ~j && !B[j]; --j);\n        if (i == -1) return B;\n        if (j == -1) return A;\n        if (i > j) A ^= (B << (i - j));\n            else B ^= (A << (j - i));\n    }\n}\n\nint div(bitset <N> A, bitset <N> B)\n{\n    int i = N - 1, j = N - 1, ans = 0;\n    for(; ~j && ~B[j]; --j);\n    for(; i >= j; --i)\n    {\n        if (A[i])\n        {\n            y ^= B << (j - i);\n            ans = (ans * 2 + 1) % mod;\n        }\n        else ans = ans * 2 % mod;\n    }\n    for(int i = N - 1; ~i; --i) if (A[i] < y[i])\n    {\n        ans = (ans - 1 + mod) % mod;\n        break;\n    }\n    else if (A[i] > y[i]) break;\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> x;\n    FOR(i, 1, n) cin >> a[i];\n    G = a[1];\n    FOR(i, 2, n) G = gcd(G, a[i]);\n    printf(\"%d\\n\", (div(x, G) + 1) % mod);\n    return 0;\n}\n;\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define maxn 5005\n#define plus qaq\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\nint n;\nchar s[maxn];\nint t[maxn],a[10][maxn],g[maxn],temp[maxn];\nvoid trans(char *x,int *y)\n{\n\tint len=strlen(x);\n\tfor(int i=0;i<=len-1;i++)\n\t\ty[i]=x[len-1-i]-'0';\n}\nint deg(int *a)\n{\n\tfor(int i=4000;i>=0;i--)\n\t\tif(a[i])\n\t\t\treturn i;\n\treturn 0;\n}\nvoid plus(int *a,int *b,int m)\n{\n\tfor(int i=m;i<=4000;i++)\n\t\ta[i]=(a[i]^b[i-m]);\n}\nvoid getgcd(int *a,int *b,int *g)\n{\n//\tfor(int i=0;i<=5;i++)\n//\t\tcerr<<a[i];\n//\tcerr<<endl;\n//\tfor(int i=0;i<=5;i++)\n//\t\tcerr<<b[i];\n//\tcerr<<endl;\n\tint da=deg(a),db=deg(b);\n\tif(da<db) swap(a,b),swap(da,db);\n\tif(db==0 && b[0]==0)\n\t{\n\t\tmemcpy(g,a,sizeof(a));\n\t\treturn;\n\t}\n\tplus(a,b,da-db);\n\tgetgcd(b,a,g);\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,s); trans(s,t);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",s); trans(s,a[i]);\n\t\tgetgcd(a[i],g,temp);\n\t\tmemcpy(g,temp,sizeof(g));\n\t}\n\n\tint d=deg(g);\n\n//\tfor(int i=0;i<=5;i++)\n//\t\tcerr<<g[i];\n//\tcerr<<endl;\n\n\tmemset(temp,0,sizeof(temp));\n\n\tfor(int i=4000;i>=d;i--)\n\tif(temp[i]^t[i])\n\t{\n\t\tplus(temp,g,i-d);\n\t}\n\n\tll ans=0;\n\tint dd=deg(t);\n\tfor(int i=dd;i>=d;i--)\n\t\tans=((ans<<1)+t[i])%mod;\n\tfor(int i=dd-1;i>=0;i--)\n\t{\n\t\tif(temp[i]<t[i])\n\t\t\tbreak;\n\t\telse if(temp[i]>t[i])\n\t\t{\n\t\t\tans--;\n\t\t\tans=(ans%mod+mod)%mod;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ans+1)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nusing bits = bitset<4000>;\n\nint main() {\n\n  auto bitlen = [](const bits& a) {\n    for(i64 j = 4000; j --> 0;) {\n      if(a[j]) {\n        return j + 1;\n      }\n    }\n    return 0ll;\n  };\n\n  i64 N;\n  cin >> N;\n  bits X;\n  i64 xs;\n  cin >> X;\n  xs = bitlen(X);\n\n  vector<bits> A(N);\n  vector<i64> S(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    S[i] = bitlen(A[i]);\n  }\n  auto bitmod = [](bits a, i64 as, bits b, i64 bs) {\n    for(i64 i = as - bs + 1; i --> 0;) {\n      if(a[i + bs - 1]) {\n        a ^= (b << i);\n      }\n    }\n    return a;\n  };\n\n  auto bitgcd = [&](bits a, i64 as, bits b, i64 bs) {\n    while(b.any()) {\n      auto m = bitmod(a, as, b, bs);\n      a = b;\n      as = bs;\n      b = m;\n      bs = bitlen(b);\n    }\n    return pair<bits, i64>(a, as);\n  };\n\n  auto g = A[0];\n  auto gs = S[0];\n  for(i64 i = 1; i < N; i++) {\n    auto p = bitgcd(g, gs, A[i], S[i]);\n    g = p.first;\n    gs = p.second;\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(xs - gs + 1 >= 0) {\n    vector<i64> Bs(xs - gs + 1, 1);\n    for(i64 i = 1; i < xs - gs + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = xs - gs + 1; i --> 0;) {\n      if(X[i + gs - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + gs - 1] != X[i + gs - 1]) {\n        now ^= (g << i);\n      }\n    }\n    if(bitlen(now) > 0 && bitmod(X, xs, now, bitlen(now)) != X) { ans = (ans + 1) % MOD; }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bitset>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\nbitset <N> x, y, G, a[10];\nint n;\n\nbitset <N> gcd(bitset <N> A, bitset <N> B)\n{\n    int i = N - 1, j = N - 1;\n    while(1)\n    {\n        for(; ~i && !A[i]; --i);\n        for(; ~j && !B[j]; --j);\n        if (i == -1) return B;\n        if (j == -1) return A;\n        if (i > j) A ^= (B << (i - j));\n            else B ^= (A << (j - i));\n    }\n}\n\nint div(bitset <N> A, bitset <N> B)\n{\n    int i = N - 1, j = N - 1, ans = 0;\n    for(; ~j && ~B[j]; --j);\n    for(; i >= j; --i)\n    {\n        ans = (ans * 2 + (A[i] ? 1 : 0)) % mod;\n        if (A[i] != y[i]) y ^= B << (i - j);\n    }\n    for(int i = N - 1; ~i; --i) if (A[i] < y[i])\n    {\n        ans = (ans - 1 + mod) % mod;\n        break;\n    }\n    else if (A[i] > y[i]) break;\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> x;\n    FOR(i, 1, n) cin >> a[i];\n    G = a[1];\n    FOR(i, 2, n) G = gcd(G, a[i]);\n    printf(\"%d\\n\", (div(x, G) + 1) % mod);\n    return 0;\n}\n;\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=4010,mod=998244353;\nchar s[N];\nistream& operator >> (istream&in,bitset<N>&a){\n\tin>>s;int n=strlen(s);a.reset();\n\tfor(int i=0;i<n;++i)a[n-i-1]=s[i]&1;\n\treturn in;\n}\nint ans,n;\nbitset<N>X,Y,A,B;\nint len(const bitset<N>&a){for(int i=N-1;i>=0;--i)if(a[i])return i;return -1;}\nvoid rem(bitset<N>&a,const bitset<N>&b){\n\tint j=len(b);\n\tfor(int i=N-1;i>=j;--i)if(a[i])a^=b<<(i-j);\n}\n\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>X;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>A;\n\t\tfor(;B.any();swap(A,B))rem(A,B);\n\t\tswap(A,B);\n\t}\n\tint L=len(B);\n\tfor(int i=N-1;i>=L;--i)\n\t\tans=(ans*2+X[i])%mod;\n\trem(Y=X,B);\n\tfor(int i=L-1;i>=0;--i)\n\t\tif(Y[i]){\n\t\t\tif(!X[i])--ans;\n\t\t\tbreak;\n\t\t}\n\tcout<<(ans+1)%mod<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nusing bits = bitset<5000>;\n\nint main() {\n\n  auto bitlen = [](const bits& a) {\n    for(i64 j = 5000; j --> 0;) {\n      if(a[j]) {\n        return j + 1;\n      }\n    }\n    return 0ll;\n  };\n\n  i64 N;\n  cin >> N;\n  bits X;\n  i64 xs;\n  cin >> X;\n  xs = bitlen(X);\n\n  vector<bits> A(N);\n  vector<i64> S(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    S[i] = bitlen(A[i]);\n  }\n  auto bitmod = [](bits a, i64 as, bits b, i64 bs) {\n    for(i64 i = as - bs + 1; i --> 0;) {\n      if(a[i + bs - 1]) {\n        a ^= (b << i);\n      }\n    }\n    return a;\n  };\n\n  auto bitgcd = [&](bits a, i64 as, bits b, i64 bs) {\n    while(b.any()) {\n      auto m = bitmod(a, as, b, bs);\n      a = b;\n      as = bs;\n      b = m;\n      bs = bitlen(b);\n    }\n    return pair<bits, i64>(a, as);\n  };\n\n  auto g = A[0];\n  auto gs = S[0];\n  for(i64 i = 1; i < N; i++) {\n    auto p = bitgcd(g, gs, A[i], S[i]);\n    g = p.first;\n    gs = p.second;\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(xs - gs + 1 >= 0) {\n    vector<i64> Bs(xs - gs + 1, 1);\n    for(i64 i = 1; i < xs - gs + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = xs - gs + 1; i --> 0;) {\n      if(X[i + gs - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + gs - 1] != X[i + gs - 1]) {\n        now ^= (g << i);\n      }\n    }\n    bool OK = true;\n    for(i64 i = 5000; i --> 0; ) {\n      if(now[i] != X[i]) {\n        if(now[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    if(OK) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=998244353;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing BS = bitset<4000>;\n\nint N;\nstring X;\nLL pw2[4010];\nvector<BS> A;\nBS bases[4010];\n\nvoid Add(LL &t, LL v) {\n  t += v;\n  while (t >= MOD) t -= MOD;\n}\n\nBS MakeBitset(string &s) {\n  BS ret;\n  int idx = 3999;\n  rrep(i, s.size()) {\n    if (s[i] == '1') ret[idx] = 1;\n    else if (s[i] == '0') ret[idx] = 0;\n    else assert(0);\n    idx--;\n  }\n  return ret;\n}\n\nint RegBase(BS &v) {\n  while (1) {\n    int idx = v._Find_first();\n    if (idx == v.size()) {\n      assert(v.count() == 0);\n      return -1;\n    }\n\n    if (bases[idx].count() == 0) {\n      bases[idx] = v;\n      return idx;\n    }\n\n    v ^= bases[idx];\n    assert(v._Find_first() > idx);\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  cin >> N >> X;\n  rep(i, N) {\n    string s;\n    cin >> s;\n    A.eb(MakeBitset(s));\n  }\n  sort(all(A), [](const BS &a, const BS &b) {\n    return a._Find_first() < b._Find_first();\n  });\n  while (!A.empty() && !A.back().count()) A.pop_back();\n  reverse(all(A));\n\n  if (A.empty()) {\n    cout << \"1\\n\";\n    return 0;\n  }\n\n  int idx = A[0]._Find_first();\n  BS v = A[0];\n  while (1) {\n    int res = RegBase(v);\n    //assert(res == idx);\n    if (res == -1) break;\n    v = bases[res] >> 1;\n    if (idx == 0) break;\n    idx--;\n  }\n\n  reps(i, 1, N) {\n    v = A[i];\n    idx = A[i]._Find_first();\n    while (1) {\n      int res = RegBase(v);\n      if (res == -1) break;\n      v = bases[res] >> 1;\n    }\n  }\n\n  int m = 0;\n  pw2[0] = 1;\n  rep(i, 4000) {\n    if (bases[i].count()) m++;\n    if (i > 0) {\n      Add(pw2[i], pw2[i-1]);\n      Add(pw2[i], pw2[i-1]);\n    }\n  }\n\n  X = string(4000-X.size(), '0') + X;\n  assert(X.size() == 4000);\n\n  BS cur;\n  LL ans = 1;\n  rep(i, 4000) {\n    if (!bases[i].count()) {\n      if (cur[i] > X[i]-'0') {\n        Add(ans, MOD-1);\n        break;\n      } else if (cur[i] < X[i] - '0') {\n        Add(ans, pw2[m]);\n        Add(ans, MOD-1);\n        break;\n      }\n    }\n\n    if (X[i] == '1') {\n      assert(m > 0);\n      Add(ans, pw2[m-1]);\n      if (!cur[i]) cur ^= bases[i];\n    } else if (X[i] == '0') {\n      if (cur[i]) cur ^= bases[i];\n    }\n\n    --m;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 5000\n\nlong long mod=998244353;\nbitset<N> p,q;\n\nint main(){\n    p=gcd(p)\n}\n\nvoid bitsetSubtract(bitset<N> &x, const bitset<N> &y) {\n    bool bo = false;\n\n    for (int i = 0; i < N; i++) {\n        if (b) {\n            if (x[i]) {\n                x[i] = y[i];\n                b = y[i];\n            } else {\n                x[i] = !y[i];\n                b = true;\n            }\n        } else {\n            if (x[i]) {\n                x[i] = !y[i];\n                b = false;\n            } else {\n                x[i] = y[i];\n                b = y[i];\n            }\n        }\n    }\n}\n\nbitset<N> gcd(bitset<N> u, bitset<N> v) {\n    bitset<N> one (string(\"1\"));\n    bitset<N> zero (string(\"0\"));\n\n    int shift;\n\n    if (u == 0) return v;\n    if (v == 0) return u;\n\n    for (shift = 0; ((u | v) & one) == zero; ++shift) {\n        u >>= 1;\n        v >>= 1;\n    }\n\n    while ((u & one) == zero) u >>= 1;\n\n    do {\n        while ((v & one) == zero) v >>= 1;\n\n        if (u.to_string() > v.to_string()) {\n            bitset<N> t = v;\n            v = u;\n            u = t;\n        }\n\n        bitsetSubtract(v,u);\n    } while (v != 0);\n\n    return u << shift;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE=4000;\nusing Bit=bitset<SIZE>;\n\nusing ll=long long;\nconst ll MOD=998244353;\n\nll powm(ll x,ll k){\n    ll res=1;\n    while(k){\n        if(k&1) res=res*x%MOD;\n        x=x*x%MOD;\n        k>>=1;\n    }\n    return res;\n}\nint main(){\n    int n;\n    Bit x;\n    cin>>n>>x;\n    vector<int> tp(n);\n    vector<Bit> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n    for(int i=0;i<n;i++){\n        if(a[i]!=0) break;\n        if(i+1==n){\n            cout<<1<<endl;\n            return 0;\n        }\n    }\n    auto baseId=[&](){\n        int id=-1;\n        for(int i=0;i<n;i++){\n            if(a[i]==0) continue;\n            if(id==-1){\n                id=i;\n                continue;\n            }\n            for(int j=SIZE-1;j>=0;j--){\n                if(a[id][j] && !a[i][j]){\n                    id=i;\n                    break;\n                }\n                if(!a[id][j] && a[i][j]) break;\n            }\n        }\n        return id;\n    };\n    auto topBit=[&](int id){\n        for(int i=SIZE-1;i>=0;i--){\n            if(a[id][i]){\n                return i;\n            }\n        }\n        return -1;\n    };\n    for(int i=SIZE-1;i>=0;i--){\n        int bid=baseId();\n        int top=topBit(bid);\n        if(i<top) break;\n        bool delt=false;\n        for(int j=0;j<n;j++){\n            if(a[j]!=0 && j!=bid && a[j][i]){\n                delt=true;\n                a[j]^=(a[bid]<<(i-top));\n            }\n        }\n    }\n\n    ll res=0;\n    int bid=baseId();\n    int top=topBit(bid);\n    Bit base=a[bid];    \n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]) res=(res+powm(2,i-top))%MOD;\n    }\n    Bit v;\n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]^v[i]) v^=(a[bid]<<(i-top));\n    }\n    for(int i=SIZE-1;i>=0;i--){\n        if(!x[i] && v[i]){\n            break;\n        }\n        if(x[i] && !v[i]){\n            res++;\n            break;\n        }\n        if(i==0) res++;\n    }\n    res%=MOD;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\n\nconst ll MOD = 998244353;\n\nbool cmp(vi& a, vi& b) {\n\tif (a.size() > b.size()) return 0;\n\tif (a.size() < b.size()) return 1;\n\tint n = a.size();\n\trep(i, n) {\n\t\tif (a[n-1-i]==b[n-1-i]) continue;\n\t\tif (a[n-1-i] > b[n-1-i]) return 0;\n\t\telse return 1;\n\t}\n\treturn 0;\n}\n\nvi gcd(vi a, vi b) {\n\tif (cmp(a, b)) {\n\t\tswap(a, b);\n\t}\n\n\tbool zero = true;\n\tfor (auto x : b) {\n\t\tif (x != 0) zero = false;\n\t}\n\tif (zero) return a;\n\n\tint d = a.size() - b.size();\n\tvi res = a;\n\trep(i, b.size()) {\n\t\tres[i + d] ^= b[i];\n\t}\n\n\twhile (res.size() && res.back() == 0) {\n\t\tres.pop_back();\n\t}\n\treturn gcd(res, b);\n}\n\nvi get(string s) {\n\treverse(ALL(s));\n\tvi res;\n\tfor (char c : s) {\n\t\tres.pb(c - '0');\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N; cin >> N;\n\tstring sx; cin >> sx;\n\tvi x = get(sx);\n\tvi g;\n\n\trep(i, N) {\n\t\tstring s; cin >> s;\n\t\tvi vec = get(s);\n\t\tg = gcd(g, vec);\n\t}\n\n\tint dg = g.size(), dx = x.size();\n\n\tif (dg > dx) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tll ans = 0;\n\tfor (int i = dx-1; i >= dg-1; --i) {\n\t\tans = ans * 2 + x[i];\n\t\tans %= MOD;\n\t}\n\n\tvi xx(dx);\n\n\tfor (int i = dx-1; i >= dg-1; --i) {\n\t\tif (xx[i] != x[i]) {\n\t\t\tfor (int j = 0; j < dg; ++j) {\n\t\t\t\txx[i-j] ^= g[dg-1-j];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok = true;\n\n\tfor (int j = dg-1; j >= 0; --j) {\n\t\tif (x[j] == xx[j]) {\n\t\t\tcontinue;\n\t\t} else if (x[j] > xx[j]) {\n\t\t\tok = true;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ok) { ans = (ans + 1) % MOD; }\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353LL;\nvector<int> gcd(vector<int> A, vector<int> B) {\n\tif (B[0] == 0) {\n\t\treturn A;\n\t}\n\tint N = A.size(), M = B.size();\n\tfor (int i = 0; i <= N - M; i++) {\n\t\tif (A[i] == 1) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tA[i + j] ^= B[j];\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> R;\n\tbool zero = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i]) zero = 0;\n\t\tif (!zero) R.push_back(A[i]);\n\t}\n\tif (zero) R.push_back(0);\n\treturn gcd(B, R);\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tstring X;\n\tcin >> X;\n\tvector<int> x;\n\tfor (int i = 0; i < X.size(); i++) x.push_back(X[i] - '0');\n\tvector<int> g(1, 0);\n\tfor (int i = 0; i < N; i++) {\n\t\tstring A;\n\t\tcin >> A;\n\t\tvector<int> a;\n\t\tfor (int i = 0; i < A.size(); i++) a.push_back(A[i] - '0');\n\t\tg = gcd(g, a);\n\t}\n\tif (g.size() > x.size()) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= x.size() - g.size(); i++) {\n\t\t(ans *= 2) %= MOD;\n\t\t(ans += x[i]) %= MOD;\n\t}\n\tvector<int> y(x.size(), 0);\n\tfor (int i = 0; i <= x.size() - g.size(); i++) {\n\t\tif (y[i] != x[i]) {\n\t\t\tfor (int j = 0; j < g.size(); j++) y[i + j] ^= g[j];\n\t\t}\n\t}\n\tbool ok = 1;\n\tfor (int i = x.size() - g.size() + 1; i < x.size(); i++) {\n\t\tif (y[i] < x[i]) break;\n\t\tif (y[i] > x[i]) {\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ok) (ans += 1) %= MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[4009];\nstruct bin{\n\tbitset<4009> bit;\n\tint L;\n\tvoid inp(){\n\t\tscanf(\"%s\",s);\n\t\tL = strlen(s);\n\t\treverse(s,s+L);\n\t\t--L;\n\t\tfor(int i=0; i<=L; i++)if(s[i] == '1')\n\t\t\tbit.set(i);\n\t}\n\tvoid add1(){\n\t\tfor(int i=0; i<=L+1; i++)if(bit.test(i))bit.reset(i);else{\n\t\t\tbit.set(i);\n\t\t\tbreak;\n\t\t}\n\t\tif(bit.test(L+1))++L;\n\t}\n\tvoid out(){\n\t\tif(L==-1)printf(\"0\\n\");else{\n\t\t\tfor(int i=L; i>=0; i--)printf(\"%d\",bit.test(i));\n\t\t\tputs(\"\");\n\t\t}\n\t}\n};\n\nint n;\nbin Y,X,Z;\n\nbool gaussian(bin&A, bin&B, bin&C){\n\tC = B;\n\tif(A.L > B.L){\n\t\treturn true;\n\t}\n\tint dif = B.L - A.L;\n\tbitset<4009> g = A.bit << dif;\n\twhile(dif >= 0){\n\t\tif(C.bit.test(C.L))\n\t\t\tC.bit ^= g;\n\t\tg >>= 1;\n\t\tC.L--;\n\t\tdif--;\n\t}\n\twhile(C.L >=0 && !C.bit.test(C.L))C.L--;\n\treturn C.L >= 0;\n}\n\nbin gcd(bin A, bin B){\n\tbin C;\n\tif(!gaussian(A, B, C))return A;\n\treturn gcd(C,A);\n}\n\n#define mod 998244353\nint add(int x,int y){return (x+=y)<mod?x:x-mod;}\nint mul(int x,int y){return (int)((long long int)(x)*y%mod);}\nint p2[4009];\nint main(){\n\tscanf(\"%d\",&n);\n\tX.inp();X.add1();\n\tY.inp();\n\tfor(int i=1; i<n; i++){\n\t\tZ.inp();\n\t\tY = gcd(Y, Z);\n\t}\n\tp2[0] = 1;\n\tfor(int i=1; i<=X.L; i++)p2[i] = add(p2[i-1],p2[i-1]);\n\tbin cur = Y;\n\tint res= 0;\n\tfor(int i=X.L; i>=0; i--){\n\t\tif(!X.bit.test(i))continue;\n\t\tif(i >= cur.L){\n\t\t\tres=add(res, p2[i - cur.L]);\n\t\t\tcontinue;\n\t\t}\n\t\tbin B;\n\t\tgaussian(cur, X, B);\n\t\tB.bit ^= X.bit;\n\t\tbool ff = false;\n\t\tfor(int j=cur.L-1; j>=0; j--)if(B.bit.test(j) ^ X.bit.test(j)){\n\t\t\tif(!B.bit.test(j) && X.bit.test(j))\n\t\t\t\tff = true;\n\t\t\tbreak;\n\t\t}\n\t\tif(ff)res=add(res,1);\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nconst int SZ = 4000;\nusing B = bitset< SZ >;\n\nint msb(const B &x) {\n  for(int i = SZ - 1; i > 0; i--) if(x[i]) return i;\n  return 0;\n}\n\nB gcd(B a, B b) {\n  int aa = msb(a), bb = msb(b);\n  if(aa < bb) swap(a, b), swap(aa, bb);\n  if(b.none()) return a;\n  return gcd(b, a ^ (b << (aa - bb)));\n}\n\nB in() {\n  string s;\n  cin >> s;\n  return B(s);\n}\n\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt &operator^=(int64_t n) {\n    int y = x;\n    x = 1;\n    while(n > 0) {\n      if(n & 1) x = 1LL * x * y % mod;\n      y = 1LL * y * y % mod;\n      n >>= 1;\n    }\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  ModInt operator^(const int64_t n) const { return ModInt(*this) ^= n; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\nint main() {\n  int N;\n\n  cin >> N;\n  B X = in();\n\n  B T(in());\n  for(int i = 1; i < N; i++) T = gcd(T, in());\n\n  vector< modint > mul(SZ);\n  mul[0] = 1;\n  for(int i = 1; i < SZ; i++) mul[i] = mul[i - 1] * 2;\n  modint ret = 1;\n  int m = msb(T);\n  B Y;\n  for(int i = SZ - 1; i >= m; i--) {\n    if(X[i]) ret += mul[i - m];\n    if(X[i] ^ Y[i]) Y ^= (T << (i - m));\n  }\n  for(int i = m - 1; i >= 0; i--) {\n    if(X[i] > Y[i]) break;\n    if(X[i] < Y[i]) {\n      ret -= 1;\n      break;\n    }\n  }\n  cout << ret << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 998244353;\n\nconst int MAXN = 4e3 + 5;\n\ndeque<int> mn, cur;\ndeque<int> x;\n\ndeque<int> ss;\n\nchar c[MAXN];\n\ndeque<int> read() {\n\tscanf(\"%s\", &c[0]);\n\tdeque<int> ans;\n\tfor(int i = 0; c[i]; i++) {\n\t\tans.push_front(c[i] - '0');\n\t}\n\treturn ans;\n}\n\nvoid set_min(deque<int> &a, deque<int> &b) {\n\twhile(1) {\n\t\tif (SZ(a) > SZ(b)) {\n\t\t\tswap(a, b);\n\t\t}\n\t\tREP(i, 0, SZ(a)) {\n\t\t\tb[SZ(b) - SZ(a) + i] ^= a[i];\n\t\t}\n\t\twhile(SZ(b) > 0 && b[SZ(b) - 1] == 0) {\n\t\t\tb.pop_back();\n\t\t}\n\t\tif (SZ(b) == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\t\n}\n\nvoid solve(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tx = read();\n\tmn = read();\n\tREP(i, 0, n - 1) {\n\t\tcur = read();\n\t\tset_min(mn, cur);\n\t}\n\t\n\tif (SZ(mn) > SZ(x)) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\t\n\tll ans = 0ll;\n\tfor(int i = SZ(x) - 1; i >= SZ(mn) - 1; i--) {\n\t\tans = (ans * 2) % MOD;\n\t\tif (x[i] == 1) {\n\t\t\tans = (ans + 1) % MOD;\n\t\t}\n\t}\n\t\n\tss = mn;\n\twhile(SZ(ss) < SZ(x)) {\n\t\tss.push_front(0);\n\t}\n\tfor(int i = SZ(ss) - 1; i >= SZ(mn) - 1; i--) {\n\t\tif (ss[i] != x[i]) {\n\t\t\tREP(j, 0, SZ(mn)) {\n\t\t\t\tss[i - SZ(mn) + 1 + j] ^= mn[j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint fl = 1;\n\tfor(int i = SZ(mn) - 2; i >= 0; i--) {\n\t\tif (ss[i] != x[i]) {\n\t\t\tif (ss[i] > x[i]) {\n\t\t\t\tfl = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/*for(int i = SZ(mn) - 1; i >= 0; i--) {\n\t\tprintf(\"%d\", mn[i]);\n\t}\n\tprintf(\" %d\\n\", fl);*/\n\t\n\tans = (ans + fl) % MOD;\n\tcout << ans << endl;\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nconst int MN = 4010;\n\nint N;\nstring X, g, tmp;\nstring A[6];\n\nstring gcd(string &a, string &b) {\n    if(a.size() < b.size()) return gcd(b, a);\n    if(b.size() == 0) return a;\n\n    int n = a.size();\n    int m = b.size();\n    for(int i = 0; i <= n - m; i++) {\n        if(a[n - 1 - i] == '1') {\n            for(int j = 0; j < m; j++) {\n                int t = a[n - 1 - i - j] - '0';\n                int d = b[m - 1 - j] - '0';\n                a[n - 1 - i - j] = '0' + (t ^ d);\n            }\n        }\n    }\n    while(a.size() && a.back() == '0') a.pop_back();\n    return gcd(b, a);\n}\n\nint chk[MN], po[MN], la;\n\nint cc[MN];\nint dp(int x) {\n    if(x == (int)X.size() - (int)g.size() + 1) return la;\n    int &ret = cc[x];\n    if(ret != -1) return ret;\n\n    ret = dp(x + 1);\n    if(X[x] == '1') {\n        ret += po[ (int)X.size() - (int)g.size() - x ];\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    po[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        po[i] = 1LL * po[i - 1] * 2 % mod;\n    }\n\n    cin >> N >> X;\n\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n        reverse(A[i].begin(), A[i].end());\n    }\n\n    g = A[0];\n    for(int i = 1; i < N; i++) {\n        g = gcd(g, A[i]);\n    }\n\n    reverse(g.begin(), g.end());\n\n    int n = X.size();\n    int m = g.size();\n    tmp = X;\n    for(int i = 0; i <= n - m; i++) {\n        chk[i] = tmp[i] - '0';\n        if(tmp[i] == '1') {\n            for(int j = 0; j < m; j++) {\n                int t = tmp[i + j] - '0';\n                int d = g[j];\n                tmp[i + j] = '0' + (t ^ d);\n            }\n        }\n    }\n\n    la = 1;\n    for(int i = n - m + 1; i < n; i++) {\n        if(tmp[i] == '1') {\n            la = X[i] - '0';\n            break;\n        }\n    }\n\n    memset(cc, -1, sizeof(cc));\n    cout << dp(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=998244353;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing BS = bitset<4000>;\n\nint N;\nstring X;\nLL pw2[4010];\nBS bases[4010];\nvector<BS> A;\n\nvoid Add(LL &t, LL v) {\n  t += v;\n  while (t >= MOD) t -= MOD;\n}\n\nBS MakeBitset(string &s) {\n  BS ret;\n  int idx = 3999;\n  rrep(i, s.size()) {\n    if (s[i] == '1') ret[idx] = 1;\n    else if (s[i] == '0') ret[idx] = 0;\n    else assert(0);\n    idx--;\n  }\n  return ret;\n}\n\nint RegBase(BS &v) {\n  while (1) {\n    int idx = v._Find_first();\n    if (idx == v.size()) {\n      assert(v.count() == 0);\n      return -1;\n    }\n\n    if (bases[idx].count() == 0) {\n      bases[idx] = v;\n      return idx;\n    }\n\n    v ^= bases[idx];\n    assert(v._Find_first() > idx);\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  cin >> N >> X;\n  rep(i, N) {\n    string s;\n    cin >> s;\n    A.eb(MakeBitset(s));\n  }\n  //sort(all(A), [](const BS &a, const BS &b) {\n  //  return a._Find_first() < b._Find_first();\n  //});\n  //while (!A.empty() && !A.back().count()) A.pop_back();\n  //reverse(all(A));\n\n  //if (A.empty()) {\n  //  cout << \"1\\n\";\n  //  return 0;\n  //}\n\n  int idx = A[0]._Find_first();\n  BS v = A[0];\n  while (1) {\n    int res = RegBase(v);\n    assert(res == idx);\n    if (res == -1) break;\n    v = bases[res] >> 1;\n    if (idx == 0) break;\n    idx--;\n  }\n\n  reps(i, 1, N) {\n    v = A[i];\n    idx = A[i]._Find_first();\n    while (1) {\n      int res = RegBase(v);\n      if (res == -1) break;\n      v = bases[res] >> 1;\n    }\n  }\n\n  int m = 0;\n  pw2[0] = 1;\n  rep(i, 4000) {\n    if (bases[i].count()) m++;\n    if (i > 0) {\n      Add(pw2[i], pw2[i-1]);\n      Add(pw2[i], pw2[i-1]);\n    }\n  }\n\n  X = string(4000-X.size(), '0') + X;\n  assert(X.size() == 4000);\n\n  BS cur;\n  LL ans = 1;\n  rep(i, 4000) {\n    if (!bases[i].count()) {\n      if (cur[i] > X[i]-'0') {\n        Add(ans, MOD-1);\n        break;\n      } else if (cur[i] < X[i] - '0') {\n        Add(ans, pw2[m]);\n        Add(ans, MOD-1);\n        break;\n      }\n      continue;\n    }\n\n    if (X[i] == '1') {\n      assert(m > 0);\n      Add(ans, pw2[m-1]);\n      if (!cur[i]) cur ^= bases[i];\n    } else if (X[i] == '0') {\n      if (cur[i]) cur ^= bases[i];\n    }\n\n    --m;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=4005,mu=998244353;\nint a[N],c[N],tmp[N],ans[N],x[N],lx,mx,n;\nchar s[N],sx[N];\nint deg(int *a){\n\tfor (int i=mx;i>=0;i--) \n\t\tif (a[i]) return i;\n}\nvoid del(int *a,int *b,int t){\n\tfor (int i=mx;i>=t;i--)\n\t\ta[i]^=b[i-t];\n}\nvoid gcd(int *a,int *b,int *c){\n\tint l1=deg(a),l2=deg(b);\n\tif (l1<l2) std::swap(a,b),std::swap(l1,l2);\n\tif (l2==0 && b[0]==0){\n\t\tfor (int i=0;i<mx;i++) c[i]=a[i];\n\t\treturn;\n\t}\n\tfor(int i=l1;i>=l2;i--)\n\t\tif (a[i]) del(a,b,i-l2);\n\tgcd(b,a,c);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",sx);\n\tint lx=strlen(sx);\n\tfor (int i=lx-1,j=0;i>=0;i--,j++) x[i]=sx[j]-'0';\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%s\",s);\n\t\tint t=strlen(s);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor (int i=t-1,j=0;i>=0;i--,j++) a[i]=s[j]-'0';\n\t\tmx=std::max(mx,t);\n\t\tfor (int i=0;i<mx;i++) tmp[i]=ans[i];\n\t\tgcd(a,tmp,ans);\n\t}\n\tint len=deg(ans);\n\tmemset(a,0,sizeof(a));\n\tfor(int i=lx-1;i>=len;i--)\n\t\tif (a[i]!=x[i]) del(a,c,i-len);\n\tint Ans=0;\n\tfor (int i=lx-1;i>=len;i--)\n\t\tAns=(Ans*2ll+x[i])%mu;\n\tfor (int i=len-1;i>=0;i--){\n\t\tif (a[i]<x[i]) break;\n\t\tif (a[i]>x[i]){\n\t\t\tAns--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef bitset<4010> B;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nll POW[4002];\nvoid init(){\n\tPOW[0] = 1;\n\tfor(int i = 0 ; i < 4001 ; i ++){\n\t\tPOW[i+1] = POW[i]*2;\n\t\tif(POW[i] >= MOD)POW[i] -= MOD;\n\t}\n}\n\nint find_last(B x){\n\tfor(int i = 4009 ; i >= 0 ; i --){\n\t\tif(x[i])return i;\n\t}\n\treturn -1;\n}\n\nB gcd(B x,B y){\n\tif(x.none())return y;\n\tint s = find_last(x);\n\tint t = find_last(y);\n\tif(s < t){\n\t\tswap(x,y);\n\t\tswap(s,t);\n\t}\n\twhile(y.any()){\n\t\tx ^= y<<(s-t);\n\t\ts = find_last(x);\n\t\tif(s < t){\n\t\t\tswap(x,y);\n\t\t\tswap(s,t);\n\t\t}\n\t}\n\treturn x;\n}\n\nint main(){\n\tinit();\n\tint n;\n\tB x,a[7];\n\tcin >> n;\n\tx.none();\n\tcin >> x;\n\tfor(int i = 0 ; i < n ; i ++){\n\t\ta[i].none();\n\t\tcin >> a[i];\n\t}\n\t\n\tfor(int i = 1 ; i < n ; i ++){\n\t\ta[0] = gcd(a[0],a[i]);\n\t}\n\t\n\t//cout << a[0].to_string().substr(4000,10) << endl;\n\t\n\tll ret = 0;\n\tint s = find_last(x);\n\tint t = find_last(a[0]);\n\tB y; y.reset();\n\tfor(int i = s ; i >= t ; i --){\n\t\tif(x[i])ret += POW[i-t];\n\t\tif(x[i] != y[i])y ^= a[0] << (i-t);\n\t}\n\t//cout << ret << endl;\n\t//cout << x.to_string().substr(4000,10) << endl;\n\t//cout << y.to_string().substr(4000,10) << endl;\n\tfor(int i = s ; i >= 0 ; i --){\n\t\tif(x[i] == y[i]){\n\t\t\tif(i == 0)ret ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(x[i])ret ++;\n\t\tbreak;\n\t}\n\tcout << ret%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nstring gcd(string a, string b){\n  if(a.size()<b.size()) swap(a, b);\n  if(b.empty()) return a;\n  int n=a.size(), m=b.size();\n  for(int i=n-m; i<n; i++){\n    if(b[i-n+m]=='1'){\n      if(a[i]=='0') a[i]='1';\n      else a[i]='0';\n    }\n  }\n  while(!a.empty()){\n    if(a.back()=='0') a.pop_back();\n    else break;\n  }\n  return gcd(b, a);\n}\nll p2[4001];\nll solve(string g, string x, string y, int i){\n  int n=x.size(), m=g.size();\n  if(n<m) return 1;\n  if(n-m+1==i){\n    if(x>=y) return 1;\n    else return 0;\n  }\n  if(x[i]=='1'){\n    if(y[i]=='1') return (p2[n-m-i]+solve(g, x, y, i+1))%MOD;\n    for(int j=0; j<m; j++){\n      if(g[j]=='1'){\n        if(y[i+j]=='0') y[i+j]='1';\n        else y[i+j]='0';\n      }\n    }\n    return (p2[n-m-i]+solve(g, x, y, i+1))%MOD;\n  }else{\n    if(y[i]=='0') return solve(g, x, y, i+1);\n    for(int j=0; j<m; j++){\n      if(g[j]=='1'){\n        if(y[i+j]=='0') y[i+j]='1';\n        else y[i+j]='0';\n      }\n    }\n    return solve(g, x, y, i+1);\n  }\n}\nint main()\n{\n\tint n; cin>>n;\n  string x; cin>>x;\n  string a[6];\n  for(int i=0; i<n; i++){\n    cin>>a[i];\n    reverse(a[i].begin(), a[i].end());\n  }\n  string g=a[0];\n  for(int i=1; i<n; i++){\n    g=gcd(g, a[i]);\n  }\n  p2[0]=1;\n  for(int i=1; i<=4000; i++){\n    p2[i]=p2[i-1]*2%MOD;\n  }\n  reverse(g.begin(), g.end());\n  string y;\n  for(int i=0; i<x.size(); i++){\n    y+='0';\n  }\n  cout<<solve(g, x, y, 0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int N, lb, a, z;\nbitset<4444> A[7], X, Y, Z;\nchar s[4444];\n\ntemplate <size_t N>\nlong long to_modllong(bitset<N> n){\n    long long ret = 0;\n    for(int i = N; --i >= 0;ret += n[i]){\n        ret <<= 1;\n        ret %= 998244353;\n    }\n    return ret;\n}\n\ntemplate <typename T>\nstatic inline T gcd(T u, T v){\n    int sftu = 0, sftv = 0;\n    T t;\n    if(u.none()) return v;\n    if(v.none()) return u;\n    while(!u[0]){\n        ++sftu;\n        u >>= 1;\n    }\n    while(!v[0]){\n        ++sftv;\n        v >>= 1;\n    }\n    sftu = min(sftu, sftv);\n    do{\n        while(!v[0])v >>= 1;\n        swap(u, v);\n        v = v ^ u;\n    }while(v.any());\n    return u << sftu;\n}\n\nint main(){\n    scanf(\"%lld %s\", &N, s);\n    X = bitset<4444>(s);\n    Z = X;\n    for(int i = 0; i < N; ++i){\n        scanf(\" %s\", s);\n        A[i] = bitset<4444>(s);\n    }\n    Y = A[0];\n    for(int i = 1; i < N; ++i)Y = gcd(A[i], Y);\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (lb = i))break;\n    for(int i = 4443 - lb; i >= 0; --i){\n        if(X[i + lb]){\n            X ^= Y << i;\n            A[6] ^= Y << i;\n        }\n    }\n    long long d = 0;\n    Y = A[6] ^ Z;\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (d = i))break;\n    //cout << bitset<200>(Y.to_ullong()) << \"\\n\" << d << endl;\n    cout << (to_modllong(Z >> lb) + (!d || Z[d])) % 998244353 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\nconst int m = 4010;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel rui(m + 10, 1);\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nint max_true(bs &a,int jou) {\n\tint ans = jou;\n\trep(i, jou) {\n\t\tif (a[i]) { ans = i; }\n\t}\n\treturn ans;\n}\nbool can_div(bs &a, bs b, int &sza, int szb) {\n\tfor (int i = sza; i >= szb; i--) {\n\t\tif (a[i]) {\n\t\t\ta ^= b << (i - szb);\n\t\t}\n\t}\n\tsza = max_true(a, szb);\n\tif (sza == szb) { return true; }\n\treturn false;\n}\nbs gcd(bs a, bs b) {\n\tint sza = max_true(a,m);\n\tint szb = max_true(b,m);\n\tif (sza < szb) { swap(sza, szb); swap(a, b); }\n\twhile (true) {\n\t\tif (can_div(a, b,sza,szb)) { swap(a, b); break; }\n\t\tif (can_div(b, a,szb,sza)) { break; }\n\t}\n\treturn a;\n}\nvoid solve(bs &x, bs &a) {\n\tint szx = max_true(x,m);\n\tint sza = max_true(a,m);\n\tbs to;\n\tint ans = 0;\n\tvel rui(m + 1, 1);\n\trep(i, m) { rui[i + 1] = rui[i] * 2; rui[i + 1] %= p; }\n\tfor (int i = szx; i >= sza; i--) {\n\t\tif (x[i]) {\n\t\t\tans += rui[i - sza];\n\t\t}\n\t\tif (x[i] != to[i]) {\n\t\t\tto ^= a << (i - sza);\n\t\t}\n\t}\n\tcout << (ans + 1)%p << endl;\n}\nbs mak(string s) {\n\trev(s);\n\tbs  ans;\n\trep(i, s.size()) {\n\t\tans[i] = (s[i] == '1');\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint n; cin >> n;\n\tstring x; cin >> x;\n\tstring s; cin >> s;\n\tbs gcd0 = mak(s);\n\trep(i, n - 1) {\n\t\tstring ne; cin >> ne;\n\t\tbs newb = mak(ne);\n\t\tgcd0 = gcd(newb, gcd0);\n\t}\n\tbs nw = mak(x);\n\trep(i, m + 9) { rui[i + 1] = rui[i] * 2; rui[i + 1] %= p; }\n\tsolve(nw, gcd0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\ntypedef unsigned long long wolf;\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nchar in[4100];\nchar str[4100];\nint main(){\n\tint a;\n\tscanf(\"%d%s\",&a,in);\n\tint n=strlen(in);\n\treverse(in,in+n);\n \n\tbitset<4020> x;\n\tfor(int i=0;i<n;i++)if(in[i]=='1')x[i]=true;\n\tbitset<4020> y;\n\tint by,bz;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",str);\n\t\tint m=strlen(str);\n\t\tbitset<4020> z;\n\t\treverse(str,str+m);\n\t\tfor(int j=0;j<m;j++)if(str[j]=='1')z[j]=true;\n\t\t//printf(\"%s %s\\n\",str+1990,z.to_string().c_str()+1990);\n\t\tif(i==0){\n\t\t\ty=z;\n\t\t\tby=strlen(str);\n\t\t}else{\n\t\t\tbz=strlen(str);\n\t\t\twhile(bz){\n\t\t\t\tif(by>=bz){\n\t\t\t\t\ty^=(z<<(by-bz));\n\t\t\t\t\twhile(by>0&&y[by-1]==false){\n\t\t\t\t\t\tby--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(by<bz){\n\t\t\t\t\tswap(y,z);\n\t\t\t\t\tswap(by,bz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%s\\n\",y.to_string().c_str());\n\tlong long ret=0;\n\tfor(int i=0;i<=n-by;i++){\n\t\tret=ret*2%mod;\n\t\tif(in[n-1-i]=='1')ret=(ret+1)%mod;\n\t}\n\tbitset<4020> tmp;\n\tfor(int i=n-1;i>=by-1;i--){\n\t\tif(tmp[i]!=x[i])tmp^=(y<<(i-by+1));\n\t}\n\t//printf(\"%s\\n\",tmp.to_string().c_str());\n\tbool ok=true;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(tmp[i]!=x[i]){\n\t\t\tif(tmp[i]){ok=false;break;}\n\t\t\telse {break;}\n\t\t}\n\t}\n\tif(ok)ret=(ret+1)%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << endl\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/2;\nconst ll MOD = 998244353;\n\ninline ll add(ll a, ll b, ll M) { // a + b (mod M)\n    return (a += b) >= M ? a - M : a;\n}\ninline ll sub(ll a, ll b, ll M) { // a - b (mod M)\n    return (a -= b) < 0 ? a + M : a;\n}\ninline ll mul(ll a, ll b, ll M) { // a * b (mod M)\n    ll r = a*b - (ll)((long double)(a)*b/M+.5)*M;\n    return r < 0 ? r + M: r;\n}\ninline ll div(ll a, ll b, ll M) { // solve b x == a (mod M)\n    ll u = 1, x = 0, s = b, t = M;\n    while (s) { // extgcd for b x + M s = t\n        ll q = t / s;\n        swap(x -= u * q, u);\n        swap(t -= s * q, s);\n    }\n    if (a % t) return -1; // infeasible\n    return mul(x < 0 ? x + M : x, a / t, M); // b (xa/t) == a (mod M)\n}\ninline ll pow(ll a, ll b, ll M) {\n    ll x = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) x = (a * x) % M;\n        a = (a * a) % M;\n    }\n    return x;\n}\n\n// p(x) = p[0] + p[1] x + ... + p[n-1] x^n-1\n// assertion: p.back() != 0\ntypedef vector<ll> poly;\nostream& operator<<(ostream &os, const poly &p) {\n    bool head = true;\n    for (size_t i = 0; i < p.size(); ++i) {\n        if (p[i] == 0) continue;\n        if (!head) os << \" + \";\n        os << p[i];\n        head = false;\n        if (i >= 1) os << \" x\";\n        if (i >= 2) os << \"^\" << i;\n    }\n    return os;\n}\ninline poly add(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = add(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\ninline poly sub(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = sub(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\n\n\n/*\n// FFT-based multiplication: this works correctly for M in [int]\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root, int sign>\ninline void fmt(vector<ll>& x) {\n    const int n = x.size();\n    int h = pow(primitive_root, (mod-1)/n, mod);\n    if (sign < 0) h = div(1, h, mod);\n    for (int i = 0, j = 1; j < n-1; ++j) {\n        for (int k = n >> 1; k > (i ^= k); k >>= 1);\n        if (j < i) swap(x[i], x[j]);\n    }\n    for (int m = 1; m < n; m *= 2) {\n        ll w = 1, wk = pow(h, n / (2*m), mod);\n        for (int i = 0; i < m; ++i) {\n            for (int s = i; s < n; s += 2*m) {\n                ll u = x[s], d = x[s + m] * w % mod;\n                if ((x[s] = u + d) >= mod) x[s] -= mod;\n                if ((x[s + m] = u - d) < 0) x[s + m] += mod;\n            }\n            w = w * wk % mod;\n        }\n    }\n    if (sign < 0) {\n        ll inv = div(1, n, mod);\n        for (auto &a: x)\n            a = a * inv % mod;\n    }\n}\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root>\ninline vector<ll> conv(vector<ll> a, vector<ll> b){\n    fmt<mod,primitive_root,+1>(a); fmt<mod,primitive_root,+1>(b);\n    for (size_t i = 0; i < a.size(); ++i)\n        a[i] = a[i] * b[i] % mod;\n    fmt<mod,primitive_root,-1>(a);\n    return a;\n}\n// general convolution where mod < 2^31.\ninline vector<ll> conv(vector<ll> a, vector<ll> b, ll mod){\n    int n = a.size() + b.size() - 1;\n    for (int k: {1,2,4,8,16}) n |= (n >> k);\n    ++n;\n    a.resize(n); b.resize(n);\n    const int A = 167772161, B = 469762049, C = 1224736769, D = (ll)(A) * B % mod;\n    if(mod==A)return conv<A,3>(a,b);\n    if(mod==B)return conv<B,3>(a,b);\n    if(mod==C)return conv<C,3>(a,b);\n    if(mod==924844033)return conv<924844033,5>(a,b);\n    vector<ll> x = conv<A,3>(a,b), y = conv<B,3>(a,b), z = conv<C,3>(a,b);\n    for (size_t i = 0; i < x.size(); ++i) {\n        ll X = (y[i] - x[i]) * 104391568;\n        if ((X %= B) < 0) X += B;\n        ll Y = (z[i] - (x[i] + A * X) % C) * 721017874;\n        if ((Y %= C) < 0) Y += C;\n        x[i] += A * X + D * Y;\n        if ((x[i] %= mod) < 0) x[i] += mod;\n    }\n    x.resize(n);\n    return x;\n}\n\ninline poly mul(poly p, poly q, ll M) {\n    poly pq = conv(p, q, M);\n    pq.resize(p.size() + q.size() - 1);\n    while (!pq.empty() && !pq.back()) pq.pop_back();\n    return pq;\n}\n*/\nnamespace FFT {\n    const int max_base = 19, maxN = 1 << max_base; // N <= 2e5\n    const double PI = acos(-1);\n    struct num {\n        double x{}, y{};\n        num() = default;\n        num(double x,double y): x(x), y(y) {}\n        explicit num(double r): x(cos(r)), y(sin(r)) {}\n    };\n    inline num operator+(num a, num b) { return {a.x + b.x, a.y + b.y}; }\n    inline num operator-(num a, num b) { return {a.x - b.x, a.y - b.y}; }\n    inline num operator*(num a, num b) { return {a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x}; }\n    inline num conj(num a) {return {a.x, -a.y}; }\n    num root[maxN];\n    int rev[maxN];\n    bool is_root_prepared = false;\n\n    inline void prepare_root(){\n        if(is_root_prepared) return;\n        is_root_prepared = true;\n        root[1] = num(1, 0);\n        for (int i = 1; i < max_base; ++i) {\n            num x(2*PI / (1LL << (i+1)));\n            for (ll j = (1LL << (i-1)); j < (1LL << (i)); ++j) {\n                root[2*j] = root[j];\n                root[2*j+1] = root[j]*x;\n            }\n        }\n    }\n\n    int base=1, N=2;\n    int lastN = -1;\n\n    inline void prepare_rev(){\n        if(lastN == N) return;\n        lastN = N;\n        for (int i = 0; i < N; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (base - 1));\n    }\n\n    inline void fft(num *a, num *f){\n        for (int i = 0; i < N; ++i) f[i] = a[rev[i]];\n        for (int k = 1; k < N; k <<= 1) {\n            for (int i = 0; i < N; i += 2*k) {\n                for (int j = 0; j < k; ++j) {\n                    num z = f[i+j+k]* root[j+k];\n                    f[i+j+k] = f[i+j] - z;\n                    f[i+j] = f[i+j] + z;\n                }\n            }\n        }\n    }\n    num a[maxN], b[maxN], f[maxN], g[maxN];\n    ll A[maxN], B[maxN], C[maxN];\n\n    inline void multi_mod(int m){\n        for (int i = 0; i < N; ++i) {\n            ll x = A[i] % m;\n            a[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        for (int i = 0; i < N; ++i) {\n            ll x = B[i] % m;\n            b[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            int j = (N-i) &(N-1);\n            num a1 = (f[i] + conj(f[j])) * num(0.5, 0);\n            num a2 = (f[i] - conj(f[j])) * num(0, -0.5);\n            num b1 = (g[i] + conj(g[j])) * num(0.5/N, 0);\n            num b2 = (g[i] - conj(g[j])) * num(0, -0.5/N);\n            a[j] = a1*b1 + a2*b2 * num(0, 1);\n            b[j] = a1*b2 + a2*b1;\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            ll aa = f[i].x + 0.5;\n            ll bb = g[i].x + 0.5;\n            ll cc = f[i].y + 0.5;\n            C[i] = (aa + bb % m * (1LL << 15) + cc% m *(1LL << 30)) % m;\n        }\n    }\n\n    inline void prepare_AB(int n1, int n2){\n        if(N > n1+n2){\n            base = 1;\n            N = 2;\n        }\n        while(N < n1+n2) base++, N <<= 1;\n        for (int i = n1; i < N; ++i) A[i] = 0;\n        for (int i = n2; i < N; ++i) B[i] = 0;\n        prepare_root();\n        prepare_rev();\n    }\n\n    inline void multi_mod(int n1, int n2, int m){\n        prepare_AB(n1, n2);\n        multi_mod(m);\n    }\n}\ninline poly mul(poly A, poly B,int M){\n    while(!A.empty()&&!A.back())A.pop_back();\n    while(!B.empty()&&!B.back())B.pop_back();\n    poly C(A.size() + B.size()-1);\n    for (size_t i = 0; i < A.size(); ++i) FFT::A[i] = A[i];\n    for (size_t i = 0; i < B.size(); ++i) FFT::B[i] = B[i];\n    FFT::multi_mod(A.size(), B.size(), M);\n    for (size_t i = 0; i < C.size(); ++i) C[i] = FFT::C[i];\n    while(!C.empty()&&!C.back())C.pop_back();\n    return C;\n}\n\n\ninline pair<poly,poly> divmod(poly p, poly q, ll M) {\n    if (p.size() < q.size()) return { {}, p };\n    if (q.size()==1){\n      for(ll x:p)x=div(x,q[0],M);\n      return {p,{}};\n    }\n    reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    poly t = {div(1, q[0], M)};\n    if (t[0] < 0) return { {}, {} }; // infeasible\n    for (size_t k = 1; k <= 2*(p.size()-q.size()+1); k *= 2) {\n        poly qq=q;\n        if(k+1<q.size())qq.resize(k+1);\n        while (!qq.empty() && !qq.back()) qq.pop_back();\n        poly s = mul(mul(t, t, M), qq, M);\n        t.resize(k);\n        for (size_t i = 0; i < k; ++i)\n            t[i] = sub(2*t[i], s[i], M);\n    }\n    t.resize(p.size() - q.size() + 1);\n    poly pp=p;\n    pp.resize(p.size() - q.size() + 1);\n    while (!pp.empty() && !pp.back()) pp.pop_back();\n    t = mul(t, pp, M);\n    t.resize(p.size() - q.size() + 1);\n    reverse(t.begin(),t.end()); reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    while (!t.empty() && !t.back()) t.pop_back();\n    return {t, sub(p, mul(q, t, M), M) };\n}\npoly gcd(poly p, poly q, ll M) {\n    for (; !p.empty(); swap(p, q = divmod(q, p, M).second)){\n      while(!p.empty()&&!p.back())p.pop_back();\n      while(!q.empty()&&!q.back())q.pop_back();\n    }\n    while(!q.empty()&&!q.back())q.pop_back();\n    return q;\n}\n\n#include <ctime>\ndouble tick() {\n  static clock_t oldtick;\n  clock_t newtick = clock();\n  double diff = 1.0*(newtick - oldtick) / CLOCKS_PER_SEC;\n  oldtick = newtick;\n  return diff;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  //tick();\n  ll N;cin>>N;\n  string X;cin>>X;reverse(X.begin(),X.end());\n  string A;cin>>A;reverse(A.begin(),A.end());\n  poly g(A.length());\n  for(size_t i=0;i<A.length();i++){\n    g[i]=A[i]-'0';\n  }\n  //debug(g);\n  for(ll i=1;i<N;i++){\n    cin >> A;\n    reverse(A.begin(),A.end());\n    poly p(A.length());\n    for(size_t i=0;i<A.length();i++){\n      p[i]=A[i]-'0';\n    }\n    g=gcd(p,g,2);\n  }\n  //debug(g);\n  ll ans=0;\n  size_t d=g.size();\n  //debug(d);\n  poly q(X.length(),0);\n  ll pw=1;\n  for(size_t i=d-1;i<X.length();i++){\n    q[i]=X[i]-'0';\n    if(X[i]>'0')ans = (ans+pw)%MOD;\n    pw = pw*2%MOD;\n  }\n  //debug(q);\n  poly r=divmod(q,g,2).second;\n  //debug(r);\n  r.resize(d-1);\n  bool isok=true;\n  for(int i=d-2;i>=0;i--){\n    if(r[i]==X[i]-'0')continue;\n    isok = r[i]<X[i]-'0';\n    break;\n  }\n  ans = (ans+isok)%MOD;\n  cout<<ans<<endl;\n  //debug(tick());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Ankur Dua\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nusing ll = long long;\nll mod=1000000007;\nll *fact, *ifact;\n\nusing cd = complex<long double>;\nconst long double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        long double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\nvector<ll> multiply(vector<ll> const& a, vector<ll> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size())\n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<ll> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int &cid = ptr[v]; cid < (int) adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n\n//Min cost max flow using dijkstra from https://codeforces.com/contest/1107/submission/49033783\ntemplate<typename flow_t, typename cost_t>\nstruct MinCostMaxFlow {\n    static const flow_t FLOW_INF = numeric_limits<flow_t>::max() / 2;\n    const cost_t COST_INF = numeric_limits<cost_t>::max() / 2;\n    struct edge {\n        int node, rev;\n        flow_t capacity;\n        cost_t cost;\n\n        edge(int _node = -1, int _rev = -1, flow_t _capacity = 0, cost_t _cost = 0)\n                : node(_node), rev(_rev), capacity(_capacity), cost(_cost) {}\n    };\n\n    int V = -1;\n    vector<vector<edge>> adj;\n    vector<cost_t> dist;\n    vector<int> prev;\n    vector<edge*> prev_edge;\n\n    MinCostMaxFlow(int vertices = -1) {\n        if (vertices >= 0)\n            init(vertices);\n    }\n\n    void init(int vertices) {\n        V = vertices;\n        adj.assign(V, {});\n        dist.resize(V);\n        prev.resize(V);\n        prev_edge.resize(V);\n    }\n\n    void addEdge(int u, int v, flow_t capacity, cost_t cost) {\n        edge uv_edge(v, adj[v].size() + (u == v ? 1 : 0), capacity, cost);\n        edge vu_edge(u, adj[u].size(), 0, -cost);\n        adj[u].push_back(uv_edge);\n        adj[v].push_back(vu_edge);\n    }\n\n    edge &reverse_edge(const edge &e) {\n        return adj[e.node][e.rev];\n    }\n\n    bool bellman_ford(int source, int sink) {\n        for (int i = 0; i < V; i++) {\n            dist[i] = COST_INF;\n            prev[i] = -1;\n            prev_edge[i] = nullptr;\n        }\n\n        vector<int> last_seen(V, -1);\n        vector<int> nodes(1, source);\n        dist[source] = 0;\n\n        for (int iteration = 0; iteration < V; iteration++) {\n            vector<int> next_nodes;\n\n            for (int node : nodes)\n                for (edge &e : adj[node])\n                    if (e.capacity > 0 && dist[node] + e.cost < dist[e.node]) {\n                        dist[e.node] = dist[node] + e.cost;\n                        prev[e.node] = node;\n                        prev_edge[e.node] = &e;\n\n                        if (last_seen[e.node] != iteration) {\n                            last_seen[e.node] = iteration;\n                            next_nodes.push_back(e.node);\n                        }\n                    }\n\n            swap(nodes, next_nodes);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    struct dijkstra_state {\n        cost_t dist;\n        int node;\n\n        bool operator<(const dijkstra_state &other) const {\n            return dist > other.dist;\n        }\n    };\n\n    void dijkstra_check(int node, cost_t potential_dist, int previous, edge *previous_edge, auto &pq) {\n        if (potential_dist < dist[node]) {\n            dist[node] = potential_dist;\n            prev[node] = previous;\n            prev_edge[node] = previous_edge;\n            pq.push({dist[node], node});\n        }\n    }\n\n    bool dijkstra(int source, int sink) {\n        dist.assign(V, COST_INF);\n        prev.assign(V, -1);\n        prev_edge.assign(V, nullptr);\n\n        priority_queue<dijkstra_state> pq;\n        dijkstra_check(source, 0, -1, nullptr, pq);\n\n        while (!pq.empty()) {\n            dijkstra_state top = pq.top();\n            pq.pop();\n\n            if (top.dist > dist[top.node])\n                continue;\n\n            for (edge &e : adj[top.node])\n                if (e.capacity > 0)\n                    dijkstra_check(e.node, top.dist + e.cost, top.node, &e, pq);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    void reduce_cost() {\n        for (int i = 0; i < V; i++)\n            for (edge &e : adj[i])\n                e.cost += dist[i] - dist[e.node];\n    }\n\n    pair<flow_t, cost_t> minCostFlow(int source, int sink, flow_t flow_goal = FLOW_INF) {\n        assert(V >= 0);\n\n        if (!bellman_ford(source, sink))\n            return make_pair(0, 0);\n\n        flow_t total_flow = 0;\n        cost_t total_cost = 0;\n        cost_t reduce_sum = 0;\n\n        do {\n            reduce_cost();\n            reduce_sum += dist[sink];\n            flow_t path_cap = flow_goal - total_flow;\n\n            for (int node = sink; prev[node] != -1; node = prev[node])\n                path_cap = min(path_cap, prev_edge[node]->capacity);\n\n            for (int node = sink; prev[node] != -1; node = prev[node]) {\n                edge *e = prev_edge[node];\n                assert(e->cost == 0);\n                e->capacity -= path_cap;\n                reverse_edge(*e).capacity += path_cap;\n            }\n\n            total_flow += path_cap;\n            total_cost += reduce_sum * path_cap;\n        } while (total_flow < flow_goal && dijkstra(source, sink));\n\n        return make_pair(total_flow, total_cost);\n    }\n};\n\nll modExp(ll base, ll exp, ll mod=::mod){\n    ll ans=1;\n    while(exp) {\n        if (exp & 1) {\n            (ans *= base) %= mod;\n        }\n        (base *= base) %= mod;\n        exp>>=1;\n    }\n    return ans;\n}\nll modInv(ll x, ll mod=::mod){\n    return modExp(x,mod-2,mod);\n}\nvoid modFact(ll n, ll mod=::mod){\n    ifact=new ll[n+1];\n    fact=new ll[n+1];\n    fact[0]=fact[1]=1;\n    for(int i=2;i<=n;i++){\n        fact[i]=(i*fact[i-1])%mod;\n    }\n    ifact[n]=modInv(fact[n], mod);\n    for(int i=n-1;i>=0;i--){\n        ifact[i]=((i+1)*ifact[i+1])%mod;\n    }\n}\nll ncr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[r];\n    ans%=mod;\n    ans*=ifact[n-r];\n    ans%=mod;\n    return ans;\n}\nll npr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[n-r];\n    return ans%mod;\n}\nclass DSU{\npublic:\n    int*p, *r;\n    DSU(int n){\n        p=new int[n+50];\n        r=new int[n+50];\n        for(int i=0;i<=n+10;i++){\n            p[i]=i;\n            r[i]=0;\n        }\n    }\n    ~DSU(){\n        delete[] p;\n        delete[] r;\n    }\n    int find(int x){\n        if(p[x]==x)\n            return x;\n        return p[x]=find(p[x]);\n    }\n    bool Unite(int a, int b){\n        a=find(a);\n        b=find(b);\n        if(a==b)\n            return false;\n        if(r[a]<r[b])\n            p[a]=b;\n        else\n            p[b]=a;\n        if(r[a]==r[b])\n            r[a]++;\n        return true;\n    }\n};\nusing namespace std;\nconst int mx=4000;\ntypedef bitset<mx> BS;\nll p2[mx];\nBS b;\nclass ARC84D {\npublic:\n    ll dfs(BS &x,vector<int> &cnt, int bp, bool eq, vector<BS> &basis){\n        if(bp==-1)\n            return 1;\n        if(!eq)\n            return p2[cnt[bp]];\n        ll ans=0;\n        if(x[bp] && b[bp]){\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,false,basis);\n                b^=basis[bp];\n                ans%=mod;\n            }\n        }else if(x[bp] && !b[bp]){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n            ans+=dfs(x,cnt,bp-1,false,basis);\n\n            ans%=mod;\n        }else if((!x[bp]) && (b[bp])){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n        }else{\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n        }\n\n        return ans;\n    }\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        int n;\n        cin>>n;\n\n        string xx;\n        cin>>xx;\n        BS x(xx);\n        vector<BS> basis(mx);\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            BS cur(s);\n\n            do{\n                BS v=cur;\n                for(int j=mx-1;j>=0;j--){\n                    if(v[j] && basis[j][j])\n                        v^=basis[j];\n                    else if(v[j]){\n                        basis[j]=v;\n                        break;\n                    }\n                }\n                if(!cur[mx-1])\n                    cur<<=1;\n                else break;\n            }while(true);\n        }\n        mod=998244353;\n        p2[0]=1;\n        for(int i=1;i<mx;i++){\n            p2[i]=(2*p2[i-1])%mod;\n        }\n        vector<int> cnt(mx);\n        for(int i=0;i<mx;i++)\n            if(basis[i][i])\n                cnt[i]=1;\n        for(int i=1;i<mx;i++)\n            cnt[i]+=cnt[i-1];\n        b=BS();\n        cout<<dfs(x,cnt,mx-1,true,basis)<<endl;\n\t}\n};\n\n\nint main() {\n\tARC84D solver;\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(NULL);\n\tstd::cout.tie(NULL);\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdint>\n#include <cassert>\n\n\n#include <iostream>\n#include <bitset>\n\ntemplate<const std::size_t N>\nstruct binfps {\n  using size_type = std::size_t;\n  using bit_type = std::uint_fast64_t;\n\n  const static size_type lg = 6;\n  const static size_type lgmask = (size_type(1) << lg) - 1;\n  const static size_type _w_len = (N + (size_type(1) << lg) - 1) >> lg;\n  std::array<bit_type, _w_len> w;\n  size_type len;\n\n  binfps(): len(0) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n  }\n\n  binfps(const std::bitset<N>& b) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n    for(size_type i = 0; i < N; i++) {\n      if(b[i]) set(i);\n    }\n    recalc();\n  }\n\n  size_type size() const { return this->len; }\n  void recalc() {\n    len = 0;\n    for(size_type i = w.size(); i --> 0; ) {\n      if(w[i]) {\n        for(size_type j = (1 << lg); j --> 0;) {\n          if(w[i] >> j) {\n            len = j + 1 + (i << lg);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  void set(size_type i) { w[i >> lg] |= (size_type(1) << (i & lgmask)); }\n  void unset(size_type i) { w[i >> lg] &= ~(size_type(1) << (i & lgmask)); }\n\n  bool any() const {\n    for(size_type i = 0; i < _w_len; i++) {\n      if(w[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool operator[](size_type i) const {\n    return (w[i >> lg] >> (i & lgmask)) & 1;\n  }\n\n  binfps& operator^=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] ^= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator&=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator|=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n\n\n  binfps& operator<<=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    size_type off = x >> lg;\n    size_type m = x & lgmask;\n    size_type dwmask = ((size_type)(1) << (64 - m)) - 1;\n    if(m == 0) {\n      dwmask = ~(size_type)(0);\n    }\n    size_type upmask = ~dwmask;\n    // up\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i + off + 1] |= (w[i] & upmask) >> m;\n    }\n    // down\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i + off] |= (w[i] & dwmask) << m;\n    }\n\n    w = std::move(next);\n    len = std::min(N, len + x);\n    return (*this);\n  }\n\n  binfps& operator>>=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    size_type off = x >> lg;\n    size_type m = x & lgmask;\n    size_type dwmask = (size_type(1) << m) - 1;\n    if(m == 0) {\n      dwmask = 0;\n    }\n    size_type upmask = ~dwmask;\n    // down\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i] |= (w[i + off + 1] & dwmask) << (64 - m);\n    }\n    // up\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i] |= (w[i + off] & upmask) >> m;\n    }\n    w = std::move(next);\n    if(len < x) {\n      len = 0;\n    }\n    else {\n      len = len - x;\n    }\n    return (*this);\n  }\n\n  binfps operator^(const binfps& b) const { return binfps(*this) ^= b; }\n  binfps operator&(const binfps& b) const { return binfps(*this) &= b; }\n  binfps operator|(const binfps& b) const { return binfps(*this) |= b; }\n  binfps operator<<(const size_type x) const { return binfps(*this) <<= x; }\n  binfps operator>>(const size_type x) const { return binfps(*this) >>= x; }\n  binfps operator~() {\n    binfps a = *this;\n    for(size_type i = w.size(); i --> 0;) {\n      a.w[i] = ~w[i];\n    }\n    return a;\n  }\n\n  bool operator<(const binfps& b) const {\n    bool OK = false;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] < b.w[i]) {\n          OK = true;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n  bool operator<=(const binfps& b) const {\n    bool OK = true;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] > b.w[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n\n  static binfps mod(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    for(int i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static binfps div(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    binfps d;\n    for(int i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        binfps e;\n        e.set(i);\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static binfps gcd(binfps a, binfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = std::move(b);\n      b = std::move(m);\n    }\n    return a;\n  }\n\n  void dump() const {\n    for(size_type i = _w_len; i --> 0; ) {\n      std::cerr << std::bitset<64>(w[i]) << \"|\" << std::endl;\n    }\n    std::cerr << std::endl;\n  }\n};\n\n\nconst int BN = 5000;\nusing bits = binfps<BN>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n \nint main() {\n  i64 N;\n  cin >> N;\n  std::bitset<BN> binp;\n  cin >> binp;\n  bits X(binp);\n  X.recalc();\n \n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> binp;\n    A[i] = bits(binp);\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    if(now <= X) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 4010;\nll pow2[4020];\n\nvi bxor(const vi& a, const vi& b) {\n\tvi res(N, 0);\n\trep(i, 0, N) res[i] = (a[i] ^ b[i]);\n\treturn res;\n}\n\nint fbit(const vi& a) { //fbit(0101) = 3\n\trer(i, N, 0) {\n\t\tif(a[i] == 1) return i + 1;\n\t}\n\treturn 0;\n}\n\nvi shift(const vi& a, int k) {\n\tvi res(N, 0);\n\tint fa = fbit(a);\n\tassert(fa + k <= N);\n\trep(i, 0, fa) {\n\t\tres[i + k] = a[i];\n\t}\n\treturn res;\n}\n\nbool is_zero(const vi& a) {\n\trep(i, 0, N) {\n\t\tif(a[i]) return false;\n\t}\n\treturn true;\n}\n\nvi gcd(const vi& a, const vi& b) {\n\tif(is_zero(b)) return a;\n\tvi c = a;\n\twhile(true) {\n\t\tint fc = fbit(c), fb = fbit(b);\n\t\tif(fc < fb) break;\n\t\tint diff = fc - fb;\n\t\tc = bxor(c, shift(b, diff));\n\t}\n\treturn gcd(b, c);\n}\n\nvi stobit(const string& str) {\n\tvector<int> res(N, 0);\n\tint n = sz(str);\n\trep(i, 0, n) {\n\t\tres[n - i - 1] = str[i] - '0';\n\t}\n\treturn res;\n}\n\nll loop(const vi& a, const vi& b) {\n\tint fa = fbit(a), fb = fbit(b);\n\tif(fa < fb) return 0;\n\tvi c = bxor(a, shift(b, fa - fb));\n\treturn (loop(c, b) + pow2[fa - fb]) % mod;\n}\n\nint M;\nvi X;\nvi B[10];\n\nvoid solve() {\n\tstring str;\n\tcin >> M >> str;\n\tpow2[0] = 1;\n\trep(i, 1, 4010) pow2[i] = pow2[i - 1] * 2 % mod;\n\tX = stobit(str);\n\trep(i, 0, M) {\n\t\tcin >> str;\n\t\tB[i] = stobit(str);\n\t}\n\tvi g = B[0];\n\trep(i, 0, M - 1) g = gcd(g, B[i + 1]);\n\tint a = fbit(X), b = fbit(g);\n\tvi c(N, 0);\n\tll res = 0;\n\trep(i, 0, (a - b + 1)) {\n\t\tif(X[a - i - 1] == 1) {\n\t\t\tc = bxor(c, shift(g, (a - b - i)));\n\t\t\tADD(res, pow2[a - b - i]);\n\t\t}\n\t\tif(X[a - i - 1] == 0 && c[a - i - 1] == 1) {\n\t\t\tc = bxor(c, shift(g, (a - b - i)));\n\t\t}\n\t}\n\tcout << (res + 1) % mod << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nint n;\n\nchar xs[4010];\n\nusing V=bitset<4000>;\n\nconst ll mod = 998244353;\n\nll Pow(ll b, ll e){\n\tll ret=1;\n\twhile(e){\n\t\tif(e&1) (ret*=b)%=mod;\n\t\te>>=1; (b*=b)%=mod;\n\t}\n\treturn ret;\n}\n\nbool exi[4010];\nV key[4010];\nvoid Input(){\n\tstatic char buf[4010];\n\tscanf(\"%s\", buf);\n\tint l = strlen(buf);\n\tV v; for(int i=l-1; 0<=i; --i) v[l-1-i]=(buf[i]=='1');\n\tint top = l-1;\n\tfor(;;){\n\t\tbool zr = 0;\n\t\twhile(exi[top]){\n\t\t\tv ^= key[top];\n\t\t\twhile(!v[top]){\n\t\t\t\tif(top == 0){\n\t\t\t\t\tzr = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t--top;\n\t\t\t}\n\t\t\tif(zr) break;\n\t\t}\n\t\tif(zr) break;\n\t\tfor(;!exi[top];){\n\t\t\texi[top]=1; key[top]=v;\n\t\t\tif(top == 3999) break;\n\t\t\t++top; v<<=1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%s\", &n, xs);\n\tfor(int i=0; i<n; ++i) Input();\n\t\n\tvector<int> tops;\n\tint xt = strlen(xs);\n\tfor(int i=xt-1; 0<=i; --i) if(exi[i]){\n\t\ttops.pb(i);\n\t}\n\tll txc=0;\n\t\n\treverse(xs, xs+xt);\n\tint p=0, tn=tops.size();\n\twhile(tops[p] != xt-1) ++p;\n\tV cv;\n\tbool alive = 1;\n\tfor(int i=xt-1; 0<=i; --i){\n\t\tif(xs[i]=='1'){\n\t\t\tif(cv[i]){\n\t\t\t\tif(p<tn && tops[p]==i){\n\t\t\t\t\t(txc += Pow(2, tn-p-1)) %= mod;\n\t\t\t\t}\n\t\t\t} else if(p<tn && tops[p]==i){\n\t\t\t\t(txc += Pow(2, tn-p-1)) %= mod;\n\t\t\t\tcv ^= key[i];\n\t\t\t} else {\n\t\t\t\t(txc += Pow(2, tn-p)) %= mod;\n\t\t\t\talive = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif(cv[i]){\n\t\t\t\tif(p<tn && tops[p]==i){\n\t\t\t\t\tcv ^= key[i];\n\t\t\t\t} else {\n\t\t\t\t\talive = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(p<tn && tops[p]==i) ++p;\n\t}\n\tif(alive) ++txc;\n\tprintf(\"%lld\\n\", txc%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 4001, mod = 998244353;\n\nint n;\nvector<bitset<N> > a;\nbitset<N> k;\n\nstring in;\n\nint sz (bitset<N> &T) {\n\tfor(int i=N;i--;) {\n\t\tif(T[i] == 1) return i+1;\n\t}\n\treturn 0;\n}\n\nint val (bitset<N> &T) {\n\tint R = 0;\n\tfor(int i=N;i--;) {\n\t\tR = (2*R + T[i]) % mod;\n\t}\n\treturn (R + 1) % mod;\n}\n\nbool cmp (bitset<N> &A, bitset<N> &B) {\n\tfor(int i=N;i--;) {\n\t\tif(A[i] < B[i]) return true;\n\t\tif(A[i] > B[i]) return false;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tcin >> n >> in;\n\tk = bitset<N>(in);\n\tfor(int i=1;i<=n;i++) {\n\t\tcin >> in;\n\t\ta.push_back(bitset<N>(in));\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tif(sz(a[0]) > sz(a[i])) {\n\t\t\tswap(a[0], a[i]);\n\t\t}\n\t}\n\twhile(a.size() > 1) {\n\t\tauto &A = a[0], &B = a.back(), T = B;\n\t\tint S = sz(A)-1;\n\t\tfor(int i=N-1;i>=S;i--) {\n\t\t\tif(B[i] == 1) B ^= (A << (i-S));\n\t\t}\n\t\tswap(A, B);\n\t\tif(sz(A) == 0) {\n\t\t\tA = T;\n\t\t\tswap(A, B);\n\t\t\ta.pop_back();\n\t\t}\n\t\telse {\n\t\t\ta.push_back(T);\n\t\t}\n\t}\n\tauto T = k;\n\tint S = sz(a[0])-1;\n\tfor(int i=N-1;i>=S;i--) {\n\t\tif(T[i] == 1) T ^= (a[0] << (i-S));\n\t}\n\tauto X = k >> S, Y = k^T;\n\tcout << (val(X) + mod - cmp(k, Y)) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e3+10;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,p,bin[N],fl=1,ans=0;\nbitset<N> a,b,c;\n\nint main() {\n\tcin>>n>>a>>b;\n\tfor(int i=2;i<=n;i++) {\n\t\tcin>>c;\n\t\twhile(c.any()) {\n\t\t\tfor(int i=4000;;i--) if(c[i]) { p=i;break; }\n\t\t\tfor(int i=4000;i>=p;i--) if(b[i]) b^=c<<(i-p);\n\t\t\tswap(b,c);\n\t\t}\n\t}\n\tbin[0]=1;\n\tfor(int i=1;i<N;i++) bin[i]=2ll*bin[i-1]%mod;\n\tfor(int i=4000;;i--) if(b[i]) { p=i;break; }\n\tc.reset();\n\tfor(int i=4000;i>=p;i--) {\n\t\tif(a[i]) ans=(ans+bin[i-p])%mod;\n\t\tif(c[i]!=a[i]) c^=a<<(i-p);\n\t}\n\tfor(int i=p-1;~i;i--)\n\t\tif(c[i]<a[i]) break;\n\t\telse if(c[i]>a[i]) { fl=0;break; }\n\tcout<<(ans+fl)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nconst int L = 4005;\nconst int N = 4005;\nconst int mo = 998244353;\n\nbitset<L>a[N],Lim;\nint n;\nint key[N];\nLL mi[L];\n\nvoid getbit(bitset<L> &a){\n\tchar s[L];\n\tscanf(\"%s\",s+1);\n\tint len=strlen(s+1);\n\tfo(i,0,len-1)a[i]=s[len-i]-'0';\n}\n\nbitset<L> trs(bitset<L> a,bitset<L> b){\n\tint wa,wb;\n\tfd(i,4000,0)if (a[i]){wa=i;break;}\n\tfd(i,4000,0)if (b[i]){wb=i;break;}\n\tif (wa<wb)swap(a,b),swap(wa,wb);\n\twhile(wb>-1){\n\t\ta=a^(b<<(wa-wb));\n\t\tbool fd=0;\n\t\tfd(i,wa,0)if (a[i]){wa=i;fd=1;break;}\n\t\tif (!fd)wa=-1;\n\t\tif (wa<wb)swap(a,b),swap(wa,wb);\n\t}\n\treturn a;\n}\n\nint main(){\n\tmi[0]=1;\n\tfo(i,1,4000)mi[i]=mi[i-1]*2%mo;\n\tscanf(\"%d\",&n);\n\tgetbit(Lim);\n\tfo(i,1,n)getbit(a[i]);\n\tint n_=0;\n\tfo(i,1,n){\n\t\tfo(j,1,i-1)\n\t\tif (a[i][key[j]])a[i]=a[i]^a[j];\n\t\tint w=-1;\n\t\tfd(x,4000,0)if (a[i][x]){w=x;break;}\n\t\tkey[i]=w;\n\t\tif (w!=-1){\n\t\t\tkey[++n_]=w;\n\t\t\ta[n_]=a[i];\n\t\t}\n\t}\n\tn=n_;\n\tint pre=0;\n\tfor(bool pd=1;pd;){\n\t\tint pn=n;\n\t\tpd=0;\n\t\tint w=(pre==0)?n:pre;\n\t\tfo(i,1,w)\n\t\t\tfo(j,pre+1,pn)\n\t\t\tif (i!=j){\n\t\t\t\tbitset<L> now=trs(a[i],a[j]);\n\t\t\t\tfo(p,1,n)\n\t\t\t\tif (now[key[p]])now=now^a[p];\n\t\t\t\tif (now.count()>0){\n\t\t\t\t\ta[++n]=now;\n\t\t\t\t\tkey[n]=0;\n\t\t\t\t\tfd(x,4000,0)if (now[x]){key[n]=x;break;}\n\t\t\t\t}\n\t\t\t}\n\t\tpre=pn;\n\t}\n\tint keyw=1;\n\tfo(i,2,n)\n\tif (key[i]<key[keyw])keyw=i;\n\tint w=0;\n\tfd(i,4000,0)\n\tif (Lim[i]){w=i;break;}\n\tLL ans=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i])ans=(ans+mi[i-key[keyw]])%mo;\n\tbitset<L>now;\n\tfo(i,0,4000)now=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i]!=now[i])now=now^(a[keyw]<<(i-key[keyw]));\n\tint prefer=1;\n\tfd(i,key[keyw],0)\n\tif (Lim[i]!=now[i]){\n\t\tif (now[i]>Lim[i])prefer=0;\n\t\tbreak;\n\t}\n\tans=(ans+prefer)%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define mod 998244353\n\nlong long a,b;\nbitset<4000> p;\nlong long dp1[4000],dp2[4000];\n\nint main(){\n  dp1[0]=1;\n  dp2[0]=1;\n  cin>>a>>p;\n  for(int i=1;i<=4000;i++){\n    dp2[i]*=(dp2[i-1]*2)%mod;\n    if(p[i]){\n      b=i;\n      dp1[i]*=(dp1[i-1]*2)%mod;\n    }\n  }\n  cout<<(dp1[b]/dp2[b-1])%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int BIT = 4000;\nconst int MOD = 998244353;\n\nbitset<BIT> gcd(bitset<BIT> a, bitset<BIT> b)\n{\n    int i = BIT - 1;\n    int j = BIT - 1;\n\n    for(;;){\n        while(i >= 0 && !a[i])\n            -- i;\n        if(i == -1)\n            return b;\n\n        while(j >= 0 && !b[j])\n            -- j;\n        if(j == -1)\n            return a;\n\n        if(i < j)\n            b ^= a << (j - i);\n        else\n            a ^= b << (i - j);\n    }\n}\n\nlong long div(const bitset<BIT>& x, const bitset<BIT>& a)\n{\n    int i = BIT - 1;\n    while(!a[i])\n        -- i;\n\n    long long ans = 0;\n    bitset<BIT> y;\n    for(int j=BIT-1; j>=i; --j){\n        ans *= 2;\n        ans %= MOD;\n        if(x[j]){\n            ++ ans;\n            ans %= MOD;\n        }\n        if(x[j] != y[j])\n            y ^= a << (j - i);\n    }\n    ++ ans;\n    ans %= MOD;\n\n    return ans;\n}\n\nint main()\n{\n    int n;\n    bitset<BIT> x;\n    cin >> n >> x;\n\n    vector<bitset<BIT> > a(n);\n    for(int i=0; i<n; ++i)\n        cin >> a[i];\n\n    bitset<BIT> b = a[0];\n    for(int i=1; i<n; ++i)\n        b = gcd(a[i], b);\n\n    cout << div(x, b) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdint>\n#include <cassert>\n\n\n#include <iostream>\n#include <bitset>\n\ntemplate<const std::size_t N>\nstruct binfps {\n  using size_type = std::size_t;\n  using bit_type = std::uint_fast64_t;\n\n  const static size_type lg = 6;\n  const static size_type lgmask = (bit_type(1) << lg) - 1;\n  const static size_type _w_len = (N + (bit_type(1) << lg) - 1) >> lg;\n  std::array<bit_type, _w_len> w;\n  size_type len;\n\n  binfps(): len(0) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n  }\n\n  binfps(const std::bitset<N>& b) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n    for(size_type i = 0; i < N; i++) {\n      if(b[i]) set(i);\n    }\n    recalc();\n  }\n\n  size_type size() const { return this->len; }\n  void recalc() {\n    len = 0;\n    for(size_type i = w.size(); i --> 0; ) {\n      if(w[i]) {\n        for(size_type j = (1 << lg); j --> 0;) {\n          if(w[i] >> j) {\n            len = j + 1 + (i << lg);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  void set(size_type i) { w[i >> lg] |= (bit_type(1) << (i & lgmask)); }\n  void unset(size_type i) { w[i >> lg] &= ~(bit_type(1) << (i & lgmask)); }\n\n  bool any() const {\n    for(size_type i = 0; i < _w_len; i++) {\n      if(w[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool operator[](size_type i) const {\n    return (w[i >> lg] >> (i & lgmask)) & 1;\n  }\n\n  binfps& operator^=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] ^= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator&=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator|=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n\n\n  binfps& operator<<=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    bit_type off = x >> lg;\n    bit_type m = x & lgmask;\n    bit_type dwmask = ((bit_type)(1) << (64 - m)) - 1;\n    if(m == 0) {\n      dwmask = ~(bit_type)(0);\n    }\n    bit_type upmask = ~dwmask;\n    // up\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i + off + 1] |= (w[i] & upmask) >> m;\n    }\n    // down\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i + off] |= (w[i] & dwmask) << m;\n    }\n\n    w = std::move(next);\n    len = std::min(N, len + x);\n    return (*this);\n  }\n\n  binfps& operator>>=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    bit_type off = x >> lg;\n    bit_type m = x & lgmask;\n    bit_type dwmask = (bit_type(1) << m) - 1;\n    if(m == 0) {\n      dwmask = 0;\n    }\n    bit_type upmask = ~dwmask;\n    // down\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i] |= (w[i + off + 1] & dwmask) << (64 - m);\n    }\n    // up\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i] |= (w[i + off] & upmask) >> m;\n    }\n    w = std::move(next);\n    if(len < x) {\n      len = 0;\n    }\n    else {\n      len = len - x;\n    }\n    return (*this);\n  }\n\n  binfps operator^(const binfps& b) const { return binfps(*this) ^= b; }\n  binfps operator&(const binfps& b) const { return binfps(*this) &= b; }\n  binfps operator|(const binfps& b) const { return binfps(*this) |= b; }\n  binfps operator<<(const size_type x) const { return binfps(*this) <<= x; }\n  binfps operator>>(const size_type x) const { return binfps(*this) >>= x; }\n  binfps operator~() {\n    binfps a = *this;\n    for(size_type i = w.size(); i --> 0;) {\n      a.w[i] = ~w[i];\n    }\n    return a;\n  }\n\n  bool operator<(const binfps& b) const {\n    bool OK = false;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] < b.w[i]) {\n          OK = true;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n  bool operator<=(const binfps& b) const {\n    bool OK = true;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] > b.w[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n\n  static binfps mod(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    for(int i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static binfps div(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    binfps d;\n    for(int i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        binfps e;\n        e.set(i);\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static binfps gcd(binfps a, binfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = std::move(b);\n      b = std::move(m);\n    }\n    return a;\n  }\n\n  void dump() const {\n    for(size_type i = _w_len; i --> 0; ) {\n      std::cerr << std::bitset<64>(w[i]) << \"|\" << std::endl;\n    }\n    std::cerr << std::endl;\n  }\n};\n\n\nconst int BN = 5000;\nusing bits = binfps<BN>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n \nint main() {\n  i64 N;\n  cin >> N;\n  std::bitset<BN> binp;\n  cin >> binp;\n  bits X(binp);\n  X.recalc();\n \n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> binp;\n    A[i] = bits(binp);\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    if(now <= X) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int LG = 21;\nconst int N = 4005;\nconst long long MOD = 998244353;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define pb push_back\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring YES[2] = {\"NO\", \"YES\"};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint Root(int x, vector<int> &root)\n{\n    if (x == root[x]) return x;\n    return root[x] = Root(root[x], root);\n}\n\nvoid Merge(int v, int u, vector<int> &root, vector<int> &sz)\n{\n    v = Root(v, root), u = Root(u, root);\n    if (v == u) return;\n    if (sz[v] < sz[u])\n    {\n        sz[u] += sz[v];\n        root[v] = u;\n    }\n    else\n    {\n        sz[v] += sz[u];\n        root[u] = v;\n    }\n}\n\nint ok(int x, int n)\n{\n    return 0 <= x && x < n;\n}\n\nvoid bfs(int v, vi &dist, vector<vi> &graph)\n{\n    fill(all(dist), -1);\n    dist[v] = 0;\n    vi q = {v};\n    for (int i = 0; i < q.size(); i++)\n    {\n        for (auto u : graph[q[i]])\n        {\n            if (dist[u] == -1)\n            {\n                dist[u] = dist[q[i]] + 1;\n                q.push_back(u);\n            }\n        }\n    }\n}\n\nvector<int> z_func(string &s)\n{\n    vector<int> z(s.size());\n    z[0] = s.size();\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    return z;\n}\n\nvector<int> p_func(string &s)\n{\n    vector<int> p(s.size());\n    for (int i = 1; i < s.size(); i++)\n    {\n        int j = p[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = p[j - 1];\n        if (s[i] == s[j])\n            j++;\n        p[i] = j;\n    }\n    return p;\n}\n\nvector<int> d1_func(string &s)\n{\n    vector<int> d1(s.size());\n    int L = 0, R = -1;\n    for (int i = 0; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d1[R - i + L]);\n        while (i + k < s.size() && i - k >= 0 && s[i - k] == s[i + k])\n            k++;\n        d1[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k;\n            R = i + k;\n        }\n    }\n    return d1;\n}\n\nvector<int> d2_func(string &s)\n{\n    vector<int> d2(s.size());\n    int L = 0, R = -1;\n    for (int i = 1; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d2[R - i + L + 1]);\n        while (i + k < s.size() && i - k - 1 >= 0 && s[i - k - 1] == s[i + k])\n            k++;\n        d2[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k - 1;\n            R = i + k;\n        }\n    }\n    return d2;\n}\n\nll log10(ll x)\n{\n    if (x < 10) re 1;\n    re 1 + log10(x / 10);\n}\n\nll ds(ll x)\n{\n    if (x < 10) return x;\n    re x % 10 + ds(x / 10);\n}\n\ndouble sqr(double x)\n{\n    return x * x;\n}\n\nbool in(int bit, int mask)\n{\n    return (mask & (1 << bit)) > 0;\n}\n\nvoid Del(vector<int> &v, int pos)\n{\n    swap(v[pos], v[v.size() - 1]);\n    v.pop_back();\n}\n\nlong long g(vector<long long> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nint g(vector<int> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nbool comp(pii a, pii b)\n{\n    if (abs(a.first - a.second) == abs(b.first - b.second))\n        return a > b;\n    return abs(a.first - a.second) > abs(b.first - b.second);\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    string s;\n    cin >> n >> s;\n    bitset<N> x;\n    for (int i = s.size() - 1; i >= 0; i--)\n        x[s.size() - 1 - i] = s[i] - '0';\n    bitset<N> g;\n    forn(i, n)\n    {\n        cin >> s;\n        bitset<N> a;\n        for (int i = s.size() - 1; i >= 0; i--)\n            a[s.size() - 1 - i] = s[i] - '0';\n        if (!i) g = a;\n        while (g != a)\n        {\n            int x = -1, y = -1;\n            for (int i = 0; i < N; i++)\n            {\n                if (a[i]) x = i;\n                if (g[i]) y = i;\n            }\n            if (x >= y)\n            {\n                if (a == (g << (x - y))) break;\n                a = a ^ (g << (x - y));\n            }\n            else\n            {\n                if (g == (a << (y - x)))\n                {\n                    g = a;\n                    break;\n                }\n                g = g ^ (a << (y - x));\n            }\n        }\n    }\n    int d = 0, D = 0;\n    for (int i = 0; i < N; i++)\n    {\n        if (g[i]) d = i;\n        if (x[i]) D = i;\n    }\n    if (d > D) cout << 1, exit(0);\n    ll ans = 0;\n    for (int i = D; i >= d; i--)\n    {\n        ans = (2 * ans + x[i]) % MOD;\n    }\n    cout << (ans + 1) % MOD;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nstatic const int MOD = 998244353;\n\n#define N 4040\n\nint Len(const bitset<N> &a) {\n        for (int res = N - 1; res >= 0; res --) {\n                if (a[res]) return res + 1;\n        }\n        return 0;\n}\n\nbitset<N> gcd(bitset<N> s, bitset<N> t) {\n        int n = Len(s), m = Len(t);\n        if (n < m) return gcd(t, s);\n        if (t.none()) return s;\n        int d = n - m;\n        bitset<N> u = t;\n        u <<= d;\n        s ^= u;\n        return gcd(t, s);\n}\n\nlong long ModPow(long long x, long long n, long long m) {\n        long long res = 1;\n        while (n > 0) {\n                if (n & 1) res = res * x % m;\n                x = x * x % m;\n                n >>= 1;\n        }\n        return res;\n}\n\nint main() {\n        int q;\n        scanf(\"%d\", &q);\n        bitset<N> x;\n        cin >> x;\n        bitset<N> g;\n        for (int i = 0; i < q; i ++) {\n                bitset<N> s;\n                cin >> s;\n                g = gcd(g, s);\n        }\n        int n = Len(x);\n        bitset<N> d(0);\n        int m = Len(g);\n        int ans = 0;\n        for (int i = n - 1; i >= m - 1; i --) {\n                if (x[i]) ans = (ans + ModPow(2, i - m + 1, MOD)) % MOD;\n                if (x[i] == d[i]) continue;\n                d ^= (g << i - m + 1);\n        }\n        bool ok = true;\n        for (int i = n - 1; i >= 0; i --) {\n                if (d[i] < x[i]) break;\n                if (d[i] > x[i]) ok = false;\n        }\n        printf(\"%d\\n\", ans + ok);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 998244353;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<u32 M = 1000000007>\nstruct modint{\n    u32 val;\n    modint(): val(0){}\n    template<typename T>\n    modint(T t){t %= (T)M; if(t < 0) t += (T)M; val = t;}\n\n    modint pow(ll k) const {\n        modint res(1), x(val);\n        while(k){\n            if(k&1) res *= x;\n            x *= x;\n            k >>= 1;\n        }\n        return res;\n    }\n    template<typename T>\n    modint& operator=(T t){t %= (T)M; if(t < 0) t += (T)M; val = t; return *this;}\n    modint inv() const {return pow(M-2);}\n    modint& operator+=(modint a){val += a.val; if(val >= M) val -= M; return *this;}\n    modint& operator-=(modint a){if(val < a.val) val += M-a.val; else val -= a.val; return *this;}\n    modint& operator*=(modint a){val = (u64)val*a.val%M; return *this;}\n    modint& operator/=(modint a){return (*this) *= a.inv();}\n    modint operator+(modint a) const {return modint(val) +=a;}\n    modint operator-(modint a) const {return modint(val) -=a;}\n    modint operator*(modint a) const {return modint(val) *=a;}\n    modint operator/(modint a) const {return modint(val) /=a;}\n    modint operator-(){return modint(M-val);}\n    bool operator==(const modint a) const {return val == a.val;}\n    bool operator!=(const modint a) const {return val != a.val;}\n    bool operator<(const modint a) const {return val < a.val;}\n};\nusing mint = modint<MOD>;\n\nint main() {\n    using B = bitset<4000>;\n    auto f = [&](string &s) -> B {\n        B res;\n        for (int i = 0; i < s.size(); ++i) {\n            if(s[i] == '1') res.set(4000+i-(int)s.size());\n        }\n        return res;\n    };\n    int n; B X;\n    cin >> n;\n    vector<B> v(n);\n    {\n        string x;\n        cin >> x;\n        X = f(x);\n        for (int i = 0; i < n; ++i) cin >> x, v[i] = f(x);\n    }\n    for (int i = 1; i < n; ++i) {\n        int a = v[0]._Find_first(), b = v[i]._Find_first();\n\n        while(true){\n            if(a == 4000 || b == 4000) {\n                if(a == 4000) swap(v[0], v[i]);\n                break;\n            }\n            if(a > b){\n                v[i] ^= (v[0] >> (a-b));\n                b = v[i]._Find_first();\n            }else {\n                v[0] ^= (v[i] >> (b-a));\n                a = v[0]._Find_first();\n            }\n        }\n    }\n\n    int a = v[0]._Find_first(), b = X._Find_first();\n    B Y;\n    mint ans = 0;\n    for (int i = b; i <= a; ++i) {\n        if(X[i]) {\n            ans += mint(2).pow(a-i);\n        }\n        if(X[i] != Y[i]){\n            Y ^= (v[0] >> (a-i));\n        }\n    }\n    int ok = 1;\n    for (int i = 0; i < 4000; ++i) {\n        if(X[0] && !Y[0]) {\n            ok = 0;\n            break;\n        }\n        else if(!X[0] && Y[0]) break;\n    }\n    if(ok) ans += mint(1);\n    cout << ans.val << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<bitset>\n#include<string>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MA = 4040;\nconst long long mod = 998244353;\n\nbitset<MA> X;\nbitset<MA> a[6];\nint N;\n\nchar ch[MA + 1];\n\nint cnt = 0;\n\nvoid output(bitset<MA> b, char ch){\n\tfor(int i = 5; i >= 0; --i){\n\t\tprintf(\"%d\", (int)b[i]);\n\t}\n\tprintf(\"%c\", ch);\n\tcnt++;\n\tif(cnt > 100) exit(0);\n}\n\nvoid input(){\n\tscanf(\"%d\", &N);\n\tscanf(\"%s\", ch);\n\tstring str = ch;\n\tX = bitset<MA>(str);\n\tfor(int i = 0; i < N; ++i){\n\t\tchar ch[MA + 1];\n\t\tscanf(\"%s\", ch);\n\t\tstring str = ch;\n\t\ta[i] = bitset<MA>(str);\n\t}\n}\n\nlong long ex[MA];\n\nint getD(bitset<MA> &a){\n\tint res = -1;\n\tfor(int i = 0; i < MA; ++i){\n\t\tif(a[i] == 1){\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid step(bitset<MA> &a, bitset<MA> &b){\n\tint ta = -1, tb = -1;\n//\toutput(a, ' ');\n//\toutput(b, ' ');\n\tfor(int i = 0; i < MA; ++i){\n\t\tif(a[i] == 1){\n\t\t\tta = i;\n\t\t}\n\t\tif(b[i] == 1){\n\t\t\ttb = i;\n\t\t}\n\t}\n\tif(ta < tb) swap(a, b);\n\tint x = ta - tb;\n\ta ^= (b << x);\n//\toutput(a, ' ');\n//\toutput(b, '\\n');\n}\n\nvoid calc(){\n\tfor(int i = 1; i < N; ++i){\n\t\twhile(a[0] != a[i]){\n\t\t\tif(a[0] == bitset<MA>()){\n\t\t\t\ta[0] = a[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(a[i] == bitset<MA>()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstep(a[0], a[i]);\n\t\t}\n\t}\n}\n\nbool cmp(bitset<MA> &a, bitset<MA> &b){\n\tfor(int i = MA - 1; i >= 0; --i){\n\t\tif(a[i] > b[i]) return false;\n\t\telse if(a[i] < b[i]) return true;\n\t}\n\treturn true;\n}\n\nlong long solve(){\n\tcalc();\n\tex[0] = 1;\n\tfor(int i = 1; i < MA; ++i){\n\t\tex[i] = ex[i - 1] * 2;\n\t\tif(ex[i] > mod) ex[i] -= mod;\n\t}\n\tcalc();\n\t//output(a[0], '-');\n\tint D = getD(a[0]);\n\tint M = getD(X);\n\tif(M < D) return 1;\n\tbitset<MA> tmp;\n\tlong long ans = 0;\n\tfor(int i = M - D; i >= 0; --i){\n\t//\toutput(tmp, '\\n');\n\t\tif(X[i + D] == 1){\n\t\t\tans += ex[i];\n\t\t\tans %= mod;\n\t\t}\n\t\tif(X[i + D] != tmp[i + D]){\n\t\t\ttmp ^= (a[0] << i);\n\t\t}\n\t}\n\tif(cmp(tmp, X)) ans++;\n\tans %= mod;\n\tans += mod;\n\tans %= mod;\n\treturn ans;\n}\n\nint main(){\n\tinput();\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<bitset>\n#include<cstdio>\n#define MN 4000\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,ans,pw[MN+5];\nchar s[MN+5],t[8][MN+5];\nbitset<MN+5> b[8],g,a;\nbitset<MN+5> gcd(const bitset<MN+5>&a,const bitset<MN+5>&b,int d,int D)\n{\n\twhile(d&&!a[d-1]) --d;while(D&&!b[D-1]) --D;\n\tif(!d) return b;if(!D) return a;\t\n\tif(d<=D) return gcd(a,(a<<D-d)^b,d,D);\n\telse return gcd(b,(b<<d-D)^a,D,d);\n}\nint main()\n{\n\tn=read();scanf(\"%s\",s+1); \n\tfor(int i=1;i<=n;++i) scanf(\"%s\",t[i]+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint d=strlen(t[i]+1);\n\t\tfor(int j=0;j<d;++j) b[i][j]=t[i][d-j]-'0';\t\n\t}\n\tg=b[1];for(int i=2;i<=n;++i) g=gcd(g,b[i],MN,MN);\n\tint deg=MN,len=strlen(s+1);while(!g[deg-1]) --deg;pw[0]=1;\n\tfor(int i=1;i<=len;++i) pw[i]=2*pw[i-1]%mod;\n\tfor(int i=1;i<=len;++i)\n\t{\n\t\tbitset<MN+5> nx;int flag=0; \n\t\tif(!(s[i]=='0'&&a[len-i]))\n\t\t{\n\t\t\tif(a[len-i]<s[i]-'0') (ans+=pw[max(0,len-deg+1-i)])%=mod;\n\t\t\telse nx=a,flag=1;\n\t\t}\n\t\tif(i+deg-1<=len&&!(s[i]=='0'&&!a[len-i]))\n\t\t{\n\t\t\tif((a[len-i]^1)<s[i]-'0') (ans+=pw[max(0,len-deg+1-i)])%=mod;\n\t\t\telse nx=(a^(g<<(len-deg+1-i))),flag=1;\n\t\t}\n\t\tif(!flag) {--ans;break;} else a=nx;\n\t}\n\tcout<<(ans+1)%mod;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int BIT = 4000;\nconst int MOD = 998244353;\n\nbitset<BIT> gcd(bitset<BIT> a, bitset<BIT> b)\n{\n    int i = BIT - 1;\n    int j = BIT - 1;\n\n    for(;;){\n        while(i >= 0 && !a[i])\n            -- i;\n        while(j >= 0 && !b[j])\n            -- j;\n\n        if(i == -1)\n            return b;\n        if(j == -1)\n            return a;\n\n        if(i < j)\n            b ^= a << (j - i);\n        else\n            a ^= b << (i - j);\n    }\n}\n\nlong long div(bitset<BIT> x, bitset<BIT> a)\n{\n    int i = BIT - 1;\n    while(!a[i])\n        -- i;\n\n    long long ans = 0;\n    bitset<BIT> y;\n    for(int j=BIT-1; j>=i; --j){\n        ans *= 2;\n        ans %= MOD;\n        if(x[j]){\n            ++ ans;\n            ans %= MOD;\n        }\n        if(!y[j])\n            y ^= a << (j - i);\n    }\n    ++ ans;\n    ans %= MOD;\n\n    return ans;\n}\n\nint main()\n{\n    int n;\n    bitset<BIT> x;\n    cin >> n >> x;\n\n    vector<bitset<BIT> > a(n);\n    for(int i=0; i<n; ++i)\n        cin >> a[i];\n\n    bitset<BIT> b = a[0];\n    for(int i=1; i<n; ++i)\n        b = gcd(a[i], b);\n\n    cout << div(x, b) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <bitset>\n#include <vector>\n\nconst int L = 4001;\nconst int MOD = 998244353;\n\nusing Bitset = std::bitset<L>;\n\nint n, m, len[6], pow[L + 1];\nchar buf[L + 1];\nBitset x, a[6];\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"F.in\", \"r\", stdin);\n#endif\n    scanf(\"%d\", &n);\n    scanf(\"%s\", buf);\n    m = strlen(buf);\n    for (int j = 0; j < m; ++ j) {\n        if (buf[j] == '1') {\n            x.set(m - 1 - j);\n        }\n    }\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%s\", buf);\n        len[i] = strlen(buf);\n        for (int j = 0; j < len[i]; ++ j) {\n            if (buf[j] == '1') {\n                a[i].set(len[i] - 1 - j);\n            }\n        }\n    }\n    int i0 = 0;\n    for (int i = 0; i < n; ++ i) {\n        if (len[i] < len[i0]) {\n            i0 = i;\n        }\n    }\n    while (true) {\n        int new_i0 = i0;\n        for (int i = 0; i < n; ++ i) {\n            while (i != i0 && len[i] >= len[i0]) {\n                a[i] ^= a[i0] << (len[i] - len[i0]);\n                while (len[i] > 0 && !a[i].test(len[i] - 1)) {\n                    len[i] --;\n                }\n            }\n            if (len[i] > 0 && len[i] < len[new_i0]) {\n                new_i0 = i;\n            }\n        }\n        if (i0 == new_i0) {\n            break;\n        }\n        i0 = new_i0;\n    }\n    pow[0] = 1;\n    for (int i = 1; i <= L; ++ i) {\n        pow[i] = (pow[i - 1] << 1) % MOD;\n    }\n    auto b = a[i0];\n    Bitset s;\n    int result = 0;\n    for (int i = len[i0] - 1; i < L; ++ i) {\n        if (x.test(i)) {\n            s ^= b;\n            result += pow[i - (len[i0] - 1)];\n            if (result >= MOD) {\n                result -= MOD;\n            }\n        }\n        b <<= 1;\n        if (b.test(len[i0] - 1)) {\n            b ^= a[i0];\n        }\n    }\n    bool ok = true;\n    for (int i = len[i0] - 2; i >= 0; -- i) {\n        if (x.test(i) < s.test(i)) {\n            ok = false;\n        }\n        if (x.test(i) > s.test(i)) {\n            break;\n        }\n    }\n    result += ok;\n    if (result >= MOD) {\n        result -= MOD;\n    }\n    printf(\"%d\\n\", result);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 998244353;\n\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  string X;\n  cin >> N >> X;\n  vector<string> A(N);\n  for(int i = 0; i < N; ++i) cin >> A[i];\n\n  string g = \"0\";\n  for(int i = 0; i < N; ++i) {\n\n    string a = g, b = A[i];\n    while(true) {\n      if(a.size() < b.size()) swap(a, b);\n      if(a == \"0\" || b == \"0\") {\n        if(a == \"0\") g = b;\n        else g = a;\n        break;\n      }\n      for(int j = 0; j < (int)b.size(); ++j) {\n        a[j] = \"01\"[(a[j] - '0') ^ (b[j] - '0')];\n      }\n      \n      string c;\n      int j = 0;\n      while(a[j] == '0') ++j;\n      for(; j < (int)a.size(); ++j) c.push_back(a[j]);\n      if(c.size() == 0) c.push_back('0');\n      a = b, b = c;\n    }\n  }\n\n  // matome\n  ll ans = 0;\n  vector<bool> res((int)X.size());\n  string Y(X.size(), '0');\n  for(int i = 0; i < (int)X.size() - (int)g.size() + 1; ++i) {\n    if(X[i] != Y[i]) {\n      for(int j = 0; j < (int)g.size(); ++j)\n        Y[i + j] = \"01\"[(g[j] - '0') ^ (Y[i + j] - '0')];\n    }\n  }\n  if(X >= Y) ++ans;\n\n  for(int i = 0; i < (int)X.size() - (int)g.size() + 1; ++i) {\n    if(X[i] == '1') {\n      ans = (ans + (1LL<<((int)X.size() - ((int)g.size()) - i))) % MOD;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 4040\n\nlong long mod=998244353;\nlong long n;\nbitset<N> p,q,r;\n\nvoid bitsetSubtract(bitset<N> &x, const bitset<N> &y) {\n    bool b = false;\n\n    for (int i = 0; i < N; i++) {\n        if (b) {\n            if (x[i]) {\n                x[i] = y[i];\n                b = y[i];\n            } else {\n                x[i] = !y[i];\n                b = true;\n            }\n        } else {\n            if (x[i]) {\n                x[i] = !y[i];\n                b = false;\n            } else {\n                x[i] = y[i];\n                b = y[i];\n            }\n        }\n    }\n}\n\nbitset<N> gcd(bitset<N> u, bitset<N> v) {\n    bitset<N> one (string(\"1\"));\n    bitset<N> zero (string(\"0\"));\n\n    int shift;\n\n    if (u == 0) return v;\n    if (v == 0) return u;\n\n    for (shift = 0; ((u | v) & one) == zero; ++shift) {\n        u >>= 1;\n        v >>= 1;\n    }\n\n    while ((u & one) == zero) u >>= 1;\n\n    do {\n        while ((v & one) == zero) v >>= 1;\n\n        if (u.to_string() > v.to_string()) {\n            bitset<N> t = v;\n            v = u;\n            u = t;\n        }\n\n        bitsetSubtract(v,u);\n    } while (v != 0);\n\n    return u << shift;\n}\nlong long ans,dp1[N+1],dp2[N+1],dp3[N+1],cnt1,cnt2;\nint main(){\n  dp1[0]=1;\n  dp2[0]=1;\n    cin>>n>>p>>q;\n    for(int i=1;i<n;i++){\n      cin>>r;\n      q=gcd(q,r);\n    }\n    for(int i=1;i<=N;i++){\n      dp2[i]=(dp2[i-1]*2)%mod;\n      if(p[i]){\n        dp3[i]=(dp3[i-1]+dp2[i])%mod;\n        cnt2=i;\n      }\n      else dp3[i]=dp3[i-1];\n      if(q[i]){\n        cnt1=i;\n    }\n  }\n    cout<<dp3[cnt2]/dp2[cnt1-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <queue>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 998244353;\nconst int Maxn = 4005;\n\nstruct pos {\n\tstring s;\n\tbool operator <(const pos &p) const {\n\t\tif (s.length() != p.s.length()) return s.length() > p.s.length();\n\t\treturn s > p.s;\n\t}\n};\n\npos getNew(const pos &a, const pos &b)\n{\n\tstring A = a.s, B = b.s;\n\tint len = max(int(A.length()), int(B.length()));\n\tif (A.length() < len) A = A + string(len - int(A.length()), '0');\n\tif (B.length() < len) B = B + string(len - int(B.length()), '0');\n\tstring C(len, '0');\n\tfor (int i = 0; i < len; i++)\n\t\tC[i] = ((A[i] == '1') ^ (B[i] == '1'))? '1': '0';\n\tint pnt = 0;\n\twhile (pnt + 1 < C.length() && C[pnt] == '0') pnt++;\n\tpos p; p.s = C.substr(pnt);\n\treturn p;\n}\n\nint pw[Maxn];\nint n;\nstring X;\nset <pos> S;\nstring mask;\nint res;\n\nint Get(int allowed)\n{\n\tint mx = int(X.length()) - int(mask.length());\n\tif (allowed <= mx) return pw[mx - allowed + 1];\n\treturn 1;\n}\n\nint main()\n{\n\tpw[0] = 1;\n\tfor (int i = 1; i < Maxn; i++)\n\t\tpw[i] = 2 * pw[i - 1] % mod;\n\tcin >> n >> X;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring str; cin >> str;\n\t\tpos p; p.s = str;\n\t\tS.insert(p);\n\t}\n\tfor (set <pos>::iterator it = S.begin(); it != S.end(); it++)\n\t\tfor (set <pos>::iterator it2 = S.begin(); it2 != S.end(); it2++)\n\t\t\tS.insert(getNew(*it, *it2));\n\tset <pos>::iterator it = S.end(); it--; it--;\n\tmask = it->s;\n\tstring cur = string(int(X.length()), '0');\n\tbool inv = false;\n\tfor (int i = 0; i < X.length(); i++)\n\t\tif (X[i] == '0') {\n\t\t\tif (cur[i] == '1')\n\t\t\t\tif (i + int(mask.length()) <= X.length())\n\t\t\t\t\tfor (int j = 0; j < mask.length(); j++)\n\t\t\t\t\t\tcur[i + j] = ((cur[i + j] == '1') ^ (mask[j] == '1'))? '1': '0';\n\t\t\t\telse { inv = true; break; }\n\t\t} else {\n\t\t\tif (cur[i] == '1' && i + int(mask.length()) <= X.length() || cur[i] == '0')\n\t\t\t\tres = (res + Get(i + 1)) % mod;\n\t\t\tif (cur[i] == '0')\n\t\t\t\tif (i + int(mask.length()) <= X.length())\n\t\t\t\t\tfor (int j = 0; j < mask.length(); j++)\n\t\t\t\t\t\tcur[i + j] = ((cur[i + j] == '1') ^ (mask[j] == '1'))? '1': '0';\n\t\t\t\telse { inv = true; break; }\n\t\t}\n\tif (!inv) res = (res + 1) % mod;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <limits.h>\n#include <assert.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <bitset>\n#include <vector>\nusing namespace std;\n\n#define LL long long\n\n#define fi first\n#define se second\n#define lson l,mid,id<<1\n#define rson mid+1,r,id<<1|1\n#define ls id<<1\n#define rs id<<1|1\n#define MID(a,b) (((a)+(b))>>1)\n#define maxx(a,b) ((a)<(b)?(b):(a))\n#define minx(a,b) ((a)<(b)?(a):(b))\n#define absx(a) ((a)<0?-(a):(a))\n#define mk(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define itr iterator\n#define lowbit(x) ((x)&-(x))\n\ntypedef unsigned LL ULL;\ntypedef unsigned uint;\ntypedef map<int,int> mii;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef pair<LL,LL> pLL;\n\ntemplate< typename T > inline void read(T &x) {\n    bool f; char ch; f=0; x=0; ch=getchar();\n    while(ch<'0' || ch>'9') {if(ch=='-') f=1; ch=getchar();}\n    while(ch>='0' && ch<='9') {x=x*10+ch-'0'; ch=getchar();}\n    if(f) x=-x;\n}\n\ntemplate< typename T > inline void Max(T &a, T b) {if(a<b) a=b;}\ntemplate< typename T > inline void Min(T &a, T b) {if(b<a) a=b;}\ntemplate< typename T > inline T Abs(T a) {if(a<0) return -a; else return a;}\n\nconst double pi=(double) acos(-1.0);\nconst int MOD=(int) 1e9+7;\nconst int INF=(int) 0x3f3f3f3f;\nconst LL  LINF=(LL) INF<<32|INF;\nconst int SINF=(uint) ~0>>1;\nconst LL  SLINF=(ULL) (-1)>>1;\nconst double DINF=(double) 1e50;\nconst double eps=(double) 1e-8;\nconst int maxn=(int) 4e3+20;\nconst int maxm=(int) 1e5+20;\nconst int maxk=(int) 5e2+20;\n\ninline int sig(double x) {return x<-eps?-1:x>eps;}\n\n//--------------start------------------\n\nint n;\nbitset<maxn> tar,a[10];\nint len[10],lt;\n\nstring str;\n\nconst int mod=998244353;\n\nvoid work()\n{\n    read(n);\n    cin >> str ;\n    lt = str.size() ; tar = bitset<maxn> (str) ;\n\n    while( lt && !tar[lt-1] ) lt--;\n\n    for(int i=0;i<n;i++)\n    {\n        cin >> str ;\n        len[i] = str.size() ; a[i] = bitset<maxn> (str) ;\n\n        while( len[i] && !a[i][len[i]-1] ) len[i]--;\n    }\n\n    int tmp;\n    while(1)\n    {\n        tmp=-1;\n        for(int i=0;i<n;i++)\n        {\n            if(len[i] && (tmp==-1 || len[i]<len[tmp])) tmp=i;\n        }\n\n        int flag=1;\n\n        for(int i=0;i<n;i++)\n        {\n            if(i==tmp || len[i]==0) continue;\n\n            a[i] = a[i] ^ ( a[tmp] << ( len[i] - len[tmp] ) ) ;\n\n//            cout <<\" i : \" <<i <<endl;\n//            for(int j=0;j<len[i];j++) cout <<a[i][j]; cout <<endl;\n\n            while( len[i] && !a[i][len[i]-1] ) len[i]--, flag=0;\n        }\n\n//        cout <<\"t : \" <<endl;\n//        for(int k=0;k<n;k++)\n//        {\n//            for(int i=len[k]-1;~i;i--) cout <<a[k][i]; cout <<endl;\n//        }\n//        cout <<endl;\n\n        if(flag) break;\n    }\n\n//    for(int i=len[tmp]-1;~i;i--) cout <<a[tmp][i]; cout <<endl;\n//    cout <<len[tmp] <<endl;\n\n    if(len[tmp]>lt)\n    {\n        puts(\"0\");\n    }\n    else\n    {\n        int ans=0, po=1;\n        bitset<maxn> acc, pp=a[tmp];\n        for(int i=len[tmp];i<=lt;i++)\n        {\n            if(tar[i-1])\n            {\n                ans+=po; if(ans>=mod) ans-=mod;\n                acc=acc^pp;\n            }\n            po<<=1; if(po>=mod) po-=mod;\n            pp=pp<<1; if(pp[len[tmp]-1]) pp=pp^a[tmp];\n        }\n\n        bool flag=1;\n        for(int i=lt-1;~i;i--)\n        {\n            if(tar[i]>acc[i]) break;\n            if(tar[i]<acc[i])\n            {\n                flag=0;\n                break;\n            }\n        }\n\n//        for(int i=lt-1;~i;i--) cout <<tar[i]; cout <<endl;\n//        for(int i=lt-1;~i;i--) cout <<acc[i]; cout <<endl;\n\n//        cout <<flag <<endl;\n\n        ans+=flag;\n        if(ans>=mod) ans-=mod;\n\n        printf(\"%d\\n\",ans);\n    }\n}\n\n//--------------end--------------------\n\nint main()\n{\n#ifdef yukihana0416\nfreopen(\"in.txt\",\"r\",stdin);\n//freopen(\"out.txt\",\"w\",stdout);\n#endif // yukihana0416\n    work();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 998244353;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 2010\nll p2[N];\n\nvoid xo(string &a, string &b){\n\tint n = min(a.size(), b.size());\n\trep(i, n) a[i] = '0'+(a[i]^b[i]);\n}\n\nvoid ker(vector<string> &s){\n\tint n = s.size();\n\trep(i, n-1){\n\t\twhile(s[i].size()>0){\n\t\t\tif(s[i].size()<s[i+1].size()) s[i].swap(s[i+1]);\n\t\t\txo(s[i], s[i+1]);\n\t\t\tint j = 0;\n\t\t\twhile(j<s[i].size() &&s[i][j]=='0') j++;\n\t\t\ts[i].erase(0, j);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tstring x;\n\tcin>>n>>x;\n\tint m = x.size();\n\tvector<string> s(n);\n\trep(i, n) cin>>s[i];\n\tker(s);\n\tstring a(s[n-1]), b(m, '0');\n\tp2[0] = 1;\n\trep(i, N-1) p2[i+1] = p2[i]*2%mod;\n\tll res = 1;\n\tint m2 = a.size(), l = m-m2+1;\n\trep(i, l){\n\t\tb.erase(0, 1); b += '0';\n\t\tif(x[i]=='1'){\n\t\t\tres += p2[l-i-1];\n\t\t\tif(b[0]=='0') xo(b, a);\n\t\t\t// todo\n\t\t} else {\n\t\t\tif(b[0]=='1') xo(b, a);\n\t\t}\n\t\tres %= mod;\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[4009];\nstruct bin{\n\tbitset<4009> bit;\n\tint L;\n\tvoid inp(){\n\t\tscanf(\"%s\",s);\n\t\tL = strlen(s);\n\t\treverse(s,s+L);\n\t\t--L;\n\t\tfor(int i=0; i<=L; i++)if(s[i] == '1')\n\t\t\tbit.set(i);\n\t}\n\tvoid add1(){\n\t\tfor(int i=0; i<=L+1; i++)if(bit.test(i))bit.reset(i);else{\n\t\t\tbit.set(i);\n\t\t\tbreak;\n\t\t}\n\t\tif(bit.test(L+1))++L;\n\t}\n};\n\nint n;\nbin min_set[64],X;\n\nbool gaussian(bin&A, bin&B, bin&C){\n\tC = B;\n\tif(A.L > B.L){\n\t\treturn true;\n\t}\n\tint dif = B.L - A.L;\n\tbitset<4009> g = A.bit << dif;\n\twhile(dif >= 0){\n\t\tif(C.bit.test(C.L))\n\t\t\tC.bit ^= g;\n\t\tg >>= 1;\n\t\tC.L--;\n\t\tdif--;\n\t}\n\twhile(C.L >=0 && !C.bit.test(C.L))C.L--;\n\treturn C.L >= 0;\n}\n\n#define mod 998244353\nint add(int x,int y){return (x+=y)<mod?x:x-mod;}\nint mul(int x,int y){return (int)((long long int)(x)*y%mod);}\nint p2[4009];\nint main(){\n\tscanf(\"%d\",&n);\n\tX.inp();X.add1();\n\tfor(int i=0; i<n; i++)\n\t\tmin_set[1<<i].inp();\n\tfor(int mask=1; mask<(1<<n); mask++)if((mask&-mask) != mask){\n\t\tmin_set[mask].L = -1;\n\t\tfor(int i=0; i<n; i++)if(mask&(1<<i)){\n\t\t\tbin cur = min_set[mask-(1<<i)];\n\t\t\tif(min_set[mask].L == -1 || cur.L < min_set[mask].L)\n\t\t\t\tmin_set[mask] = cur;\n\t\t\tif(!gaussian(min_set[mask-(1<<i)],min_set[1<<i],cur))continue;\n\t\t\tif(min_set[mask].L == -1 || cur.L < min_set[mask].L)\n\t\t\t\tmin_set[mask] = cur;\n\t\t}\n\t}\n\tp2[0] = 1;\n\tfor(int i=1; i<=X.L; i++)p2[i] = add(p2[i-1],p2[i-1]);\n\tbin cur = min_set[(1<<n)-1];\n\tint res= 0;\n\tfor(int i=X.L; i>=0; i--){\n\t\tif(!X.bit.test(i))continue;\n\t\tif(i >= cur.L){\n\t\t\tres=add(res, p2[i - cur.L]);\n\t\t\tcontinue;\n\t\t}\n\t\tbin B;\n\t\tgaussian(cur, X, B);\n\t\tB.bit ^= X.bit;\n\t\tbool ff = false;\n\t\tfor(int j=cur.L-1; j>=0; j--)if(B.bit.test(j) ^ X.bit.test(j)){\n\t\t\tif(!B.bit.test(j) && X.bit.test(j))\n\t\t\t\tff = true;\n\t\t\tbreak;\n\t\t}\n\t\tif(ff)res=add(res,1);\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n\nconst int MOD = 998244353;\nusing mn = modnum<MOD>;\n\nconst int SZ = 4000;\nusing num = bitset<SZ>;\n\nint clz(num a) {\n    int i = 0;\n    while (i < sz(a) && !a[sz(a) - 1 - i]) i++;\n    return i;\n}\n\nnum gcd(num a, num b) {\n    int az = clz(a), bz = clz(b);\n    if (az > bz) {\n        swap(a, b);\n        swap(az, bz);\n    }\n    if (bz == sz(b)) return a;\n    return gcd(a ^ (b << (bz - az)), b);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N; num X;\n    cin >> N >> X;\n\n    vector<num> a(N);\n    for (auto& v : a) cin >> v;\n\n    num g = a[0];\n    for (int i = 1; i < N; i++)\n        g = gcd(g, a[i]);\n\n    int gl = SZ - 1 - clz(g), xl = SZ - 1 - clz(X);\n    if (gl > xl) { cout << \"0\\n\"; return 0; }\n\n    mn ans = 0;\n    num last = X;\n    for (int d = xl; d >= gl; d--) {\n        if (X[d]) {\n            ans += mn(2).pow(d - gl);\n        }\n        if (last[d] != X[d]) {\n            last ^= g << (d - gl);\n        }\n    }\n\n    ans += 1;\n    for (int d = gl - 1; d >= 0; d--) {\n        if (last[d] != X[d]) {\n            if (last[d] > X[d]) ans -= 1;\n            break;\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\n#define N_bit 4000\nusing bin = bitset<N_bit>;\nbin gcd(bin a, bin b){\n    int na = 0, nb = 0;\n    while(true){\n        while(na < N_bit && a[N_bit - 1 - na] == 0) na++;\n        while(nb < N_bit && b[N_bit - 1 - nb] == 0) nb++;\n        if(na > nb){\n            swap(a, b);\n            swap(na, nb);\n        }\n        if(nb == N_bit) return a;\n\n        a ^= b << (nb - na);\n    }\n}\n/*\n//return true if a <= b\nbool compare(bin a, bin b){\n    IREP(i, N_bit){\n        if(a[i] == 1 && b[i] == 0) return false;\n        if(a[i] == 0 && b[i] == 1) return true;\n    }\n    return true;\n}*/\n\nsigned main(){\n\n    int N; cin >> N;\n    string X; cin >> X;\n    vector<string> A(N); cin >> A;\n\n    bin x(X);\n    vector<bin> a(N);\n    REP(i, N) a[i] = bin(A[i]);\n    bin g = a[0];\n    FOR(i, 1, N){\n        g = gcd(g, a[i]);\n    }\n    //debug(g);\n\n    int nx = 0, ng = 0;\n    while(nx < N_bit && x[N_bit - 1 - nx] == 0) nx++;\n    while(ng < N_bit && g[N_bit - 1 - ng] == 0) ng++;\n\n    nx = N_bit - nx;\n    ng = N_bit - ng;\n    \n    if(nx < ng){\n        Out(1);\n        return 0;\n    }\n    mint ans = 1;\n    bin t(0);\n    REP(i, nx - ng + 1){\n        if(x[nx - 1 - i] == 1){\n            if(t[nx - 1 - i] == 0){\n                ans += pow((mint)2, nx - ng - i);\n                t ^= g << (nx - ng - i);\n            }else{\n                ans += pow((mint)2, nx - ng - i);\n            }\n        }else if(x[nx - 1 - i] == 0){\n            if(t[nx - 1 - i] == 1){\n                t ^= g << (nx - ng - i);\n            }\n        }\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=998244353;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=1e6+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=4e3+10;\n\t//------------------FIXED------------------\n\ttypedef bitset<N> bs;\n\tbool operator <= (bs a,bs b)\n\t{\n\t\tfd(i,N-1,0) if(a[i]!=b[i]) return a[i]<b[i];\n\t\treturn 1;\n\t}\n\tchar str[N];int ln;\n\tvoid read(bs &ret){ scanf(\"%s\",str+1);ln=strlen(str+1);fo(i,1,ln) ret[ln-i]=(str[i]-'0'); }\n\tvoid main()\n\t{\n\t\tint n=qread();bs MX;read(MX);int L=ln;\n\t\tbs gcd;read(gcd);int ln1=ln;\n\t\tfo(i,2,n)\n\t\t{\n\t\t\tbs now;read(now);int ln2=ln;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(ln1>ln2) swap(ln1,ln2),swap(gcd,now);\n\t\t\t\tnow^=gcd<<(ln2-ln1);while(ln2 and now[ln2-1]==0) ln2--;if(ln2==0) break;\n\t\t\t}\n\t\t}\n\t\tif(ln1>L){write(1);return;}//0\n\t\tll ans=0;int z=L-ln1+1;\n\t\tbs now;fd(i,L-1,L-z) {ans=(ans*2+MX[i])%MOD;if(MX[i]^now[i]) now^=gcd<<(i-ln1+1);}\n\t\tif(now<=MX) add(ans,1);write(ans);\n\t}\n};//\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();\n\tmine::main();\n\tdebug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) {\n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; } else { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); } else { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/*  */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tIntMod Combination(const IntMod& right) const {\n\t\tif (value_m < right.value_m) throw \"okashii\";\n\t\treturn Fact() / ((*this - right).Fact() * right.Fact());\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\ntypedef IntMod<1000000007> MInt;\n\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator*(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret *= right;\n//\treturn ret;\n//}\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator/(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret /= right;\n//\treturn ret;\n//}\n\n#if 0\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator >> (istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Graph.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Range.h\"\n#include \"Tree.h\"\n#include \"Union_Find.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator >> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nconst int M = 4064;\nusing Bits = bitset<M>;\nusing Mit = IntMod<998244353>;\n\nint Digit(const Bits& a) {\n\tREM(i, 0, M) {\n\t\tif (a[i]) {\n\t\t\treturn i + 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nBits GCD(Bits a, Bits b) {\n\tBits* p = &a;\n\tBits* q = &b;\n\tint as = Digit(a) - 1;\n\tint bs = Digit(b) - 1;\n\n\twhile (bs >= 0) {\n\t\twhile (as >= bs) {\n\t\t\t*p ^= *q << (as - bs);\n\t\t\twhile (as >= 0 && (*p)[as] == 0) {\n\t\t\t\t--as;\n\t\t\t}\n\t\t}\n\t\tswap(p, q);\n\t\tswap(as, bs);\n\t}\n\treturn *p;\n}\n\nbool Less(const Bits& a, const Bits& b) {\n\tREM(i, 0, M) {\n\t\tif (a[i] < b[i]) return true;\n\t\tif (a[i] > b[i]) return false;\n\t}\n\treturn false;\n}\n\nBits Inc(const Bits& a) {\n\tBits ret(a);\n\n\tREP(i, 0, M) {\n\t\tif (ret[i]) {\n\t\t\tret[i] = 0;\n\t\t} else {\n\t\t\tret[i] = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nint N;\nBits X;\nBits A[6];\nMit P[M];\nint main() {\n\tcin >> N >> X;\n\tREP(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\tX = Inc(X);\n\t\n\tP[0] = 1;\n\tREP(i, 1, M) {\n\t\tP[i] = P[i - 1] * 2;\n\t}\n\t\n\tBits gcd = 0;\n\tREP(i, 0, N) {\n\t\tgcd = GCD(gcd, A[i]);\n\t}\n\t\n\tint xs = Digit(X);\n\tint gs = Digit(gcd);\n\n\tMit sum = 0;\n\tREM(i, gs - 1, xs) {\n\t\tif (X[i]) {\n\t\t\tsum += P[i - gs + 1];\n\t\t}\n\t}\n\n\tBits Y = 0;\n\tREM(i, gs - 1, xs) {\n\t\tif (Y[i] != X[i]) {\n\t\t\tY ^= gcd << (i - gs + 1);\n\t\t}\n\t}\n\n\tcout << sum + Less(Y, X) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbitset <4050> a,b,c; int n,m,ans,h[4050],p,fl,mo=998244353;\nint main(){\n\tcin>>n; cin>>a;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (cin>>c;c.any();swap(b,c)){\n\t\t\tfor (p=4000;;--p) if (c[p]) break;\n\t\t\tfor (int j=4000;j>=p;--j) if (b[j]) b^=c<<j-p;\n\t\t}\n\tfor (p=4000;;--p) if (b[p]) break;\n\tc=a; h[0]=fl=1;\n\tfor (int i=1;i<=4000;++i) h[i]=h[i-1]*2%mo;\n\tfor (int i=p;i<4001;++i)\n\tif (a[i]) (ans+=h[i-p])%=mo;\n\tfor (int i=4000;i>=p;--i) if (a[i]) a^=b<<i-p;\n\tfor (int i=p;~i;--i)\n\tif (a[i]) {fl=c[i]; break;}\n\tprintf(\"%d\\n\",(ans+fl)%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint n;\n\n#define MAX 4002\n\nchar buf[MAX];\n\n\nbitset<MAX> x;\n\nvoid read(bitset<MAX> &b) {\n\tb.reset();\n\tscanf(\"%s\", buf);\n\tint sz = strlen(buf);\n\tfor (int i = 0; i < sz; i++) {\n\t\tb.set(sz - i - 1, buf[i] - '0');\n\t}\n}\n\nbitset<MAX> gc;\nbitset<MAX> tmp;\n\nint idx(bitset<MAX> &a) {\n\tfor (int i = MAX - 1; i >= 0; i--) {\n\t\tif (a.test(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\nbitset<MAX> gcd(bitset<MAX> a, bitset<MAX> b) {\n\twhile (1) {\n\t\tint A = idx(a);\n\t\tint B = idx(b);\n\t\tif (A == -1) {\n\t\t\treturn b;\n\t\t}\n\t\tif (B == -1) {\n\t\t\treturn a;\n\t\t}\n\t\tif (A >= B) {\n\t\t\ta ^= b << (A - B);\n\t\t}\n\t\telse {\n\t\t\tb ^= a << (B - A);\n\t\t}\n\t}\n\treturn a;\n}\n#define MOD  998244353\nbitset<MAX> xx;\nlong long int p2[MAX];\nint main() {\n\tp2[0] = 1;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2[i] = p2[i - 1];\n\t\tp2[i] *= 2LL;\n\t\tp2[i] %= MOD;\n\t}\n\tcin >> n;\n\tread(x);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0) {\n\t\t\tread(gc);\n\t\t\tcontinue;\n\t\t}\n\t\tread(tmp);\n\t\tgc = gcd(gc, tmp);\n\t}\n\tint d = idx(gc);\n\tlong long int ans = 0;\n\tlong long int way = 0;\n\tfor (int i = MAX - 1; i >= d; i--) {\n\t\tif (x.test(i)) {\n\t\t\tway += p2[i - (d)];\n\t\t\tway %= MOD;\n\t\t}\n\t}\n\txx = x;\n\twhile (1) {\n\t\tint id1 = idx(xx);\n\t\tint id2 = idx(gc);\n\t\tif (id1 >= id2) {\n\t\t\txx ^= gc << (id1 - id2);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\txx ^= x;\n\tway++;\n\tfor (int i = MAX - 1; i >= 0; i--) {\n\t\tint A = x.test(i);\n\t\tint B = xx.test(i);\n\t\tif (A == B)continue;\n\t\tif (A < B) {\n\t\t\tway += MOD-1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tway %= MOD;\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include <cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nconst int DEBUG = 1;\n\n\nconst int N=4000;\ntypedef bitset<N> bs;\nconst lint MOD=998244353;\n\nbs read(){\n  string s;\n  cin>>s;\n  int l=s.length();\n  bs ret;\n  rep(i,l)ret[i]=s[l-i-1]=='1';\n  return ret;\n}\n\nbs div(bs a, bs b){\n  int hi=-1;\n  rep(i,N){\n    if(b[i]){\n      hi=i;\n    }\n  }\n  assert(hi>=0);\n  for(int i=N-hi-1;i>=0;--i){\n    if(a[i+hi]){\n      a^=b<<i;\n    }\n  }\n  return a;\n}\n\nbs gcd(bs a,bs b){\n  while(b.count()!=0){\n    a=div(a,b);\n    swap(a,b);\n  }\n  return a;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  bs x=read();\n  vector<bs> s(n);\n  rep(i,n)s[i]=read();\n  bs t=s[n-1];\n  rep(i,n-1)\n    t=gcd(s[i],t);\n  lint ans=0;\n  lint cur=1;\n  int hi=-1;\n  rep(i,N){\n    if(t[i]){\n      hi=i;\n    }\n  }\n  bs y;\n  for(int i=N-hi-1;i>=0;--i){\n    if(x[i+hi]!=y[i+hi]){\n      y^=y<<i;\n    }\n  }\n  rep(i,N-hi){\n    if(x[i+hi])ans=(ans+cur)%MOD;\n    cur=cur*2%MOD;\n  }\n  bool lt=false;\n  for(int i=N-1;i>=0;--i){\n    if(x[i]!=y[i]){\n      lt=x[i]<y[i];\n      break;\n    }\n  }\n  if(lt)cur=(cur+MOD-1)%MOD;\n  cout<<(ans+1)%MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\ntypedef pair<P,P> P2;\ntypedef pair<double,int>Q;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n//#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\nint n; bitset<4005>str[10],s,base;\nvector<bitset<4005> >vec;\nint mn = INF;\nint main(){\n\tcin>>n;\n\tstring x; cin>>x;\n\tfor(int i=0;i<x.size();i++) s[i] = x[i]-'0';\n\trep(i,n){\n\t\tcin>>x;\n\t\tfor(int ii=0;ii<x.size();ii++) str[i][ii] = x[ii]-'0';\n\t\tvec.pb(str[i]);\n\t\tif(mn>x.size()){\n\t\t\tmn=x.size();\n\t\t\tbase = str[i];\n\t\t}\n\t}\n\twhile(!vec.empty()){\n\t\tint pre = mn; int cur = vec.size();\n\t\tfor(int i=0;i<cur;i++){\n\t\t\tfor(int j=i+1;j<cur;j++){\n\t\t\t\tbitset<4005>B = vec[i] ^ vec[j];\n\t\t\t\tint beg=INF,en=-INF;\n\t\t\t\tfor(int k=0;k<4005;k++){\n\t\t\t\t\tif(B[k]){\n\t\t\t\t\t\tbeg = min(beg,k);\n\t\t\t\t\t\ten = max(en,k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(beg==INF) continue;\n\t\t\t\tB>>=beg;//assert(B[0]==1);\n\t\t\t\tif(mn>en-beg+1){\n\t\t\t\t    //cout<<beg<<\" \"<<en<<endl;\n\t\t\t\t\tmn=en-beg+1;\n\t\t\t\t\tbase = B;\n\t\t\t\t\t//cout<<base[0]<<base[1]<<base[2]<<endl;\n\t\t\t\t}\n\t\t\t\tvec.pb(B);\n\t\t\t\tif(mn==3){\n\t\t\t\t    //cout<<B[0]<<\" \"<<B[1]<<\" \"<<B[2]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pre == mn){\n\t\t\tbreak;\n\t\t}\n\t}\n\tll mod = 998244353;\n\tll cnt[4005]={};\n\tcnt[0] = 1; cnt[mn] = 1;\n\tfor(int i=mn+1;i<4005;i++) cnt[i] = cnt[i-1]*2LL%mod;\n\tll ret = 1;\n\tfor(int i=0;i<x.size();i++){\n\t\tif(i!=x.size()-1) ret += cnt[i+1];\n\t\telse{\n\t\t/*\tfor(int j=1;j<x.size();j++){\n\t\t\t\t//1,x[1],,0,*******\n\t\t\t\tif(x[j] == 1) contninue;\n\t\t\t}*/\n\t\t}\n\t}\n\tcout<<ret<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nconst int SZ = 4000;\nusing B = bitset< SZ >;\n\nint msb(const B &x) {\n  for(int i = SZ - 1; i > 0; i--) if(x[i]) return i;\n  return 0;\n}\n\nB gcd(B a, B b) {\n  int aa = msb(a), bb = msb(b);\n  if(aa < bb) swap(a, b), swap(aa, bb);\n  if(b.none()) return a;\n  return gcd(b, a ^ (b << (aa - bb)));\n}\n\nB in() {\n  string s;\n  cin >> s;\n  return B(s);\n}\n\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt &operator^=(int64_t n) {\n    int y = x;\n    x = 1;\n    while(n > 0) {\n      if(n & 1) x = 1LL * x * y % mod;\n      y = 1LL * y * y % mod;\n      n >>= 1;\n    }\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  ModInt operator^(const int64_t n) const { return ModInt(*this) ^= n; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\nint main() {\n  int N;\n\n  cin >> N;\n  B X = in();\n\n  B T(in());\n  for(int i = 1; i < N; i++) T = gcd(T, in());\n\n  vector< modint > mul(SZ);\n  mul[0] = 1;\n  for(int i = 1; i < SZ; i++) mul[i] = mul[i - 1] * 2;\n  modint ret = 1;\n  int m = msb(T);\n  B Y;\n  for(int i = SZ - 1; i >= m; i--) {\n    if(X[i]) ret += mul[i - m];\n    if(X[i] ^ Y[i]) Y ^= (T << (i - m));\n  }\n  for(int i = m - 1; i >= 0; i--) {\n    if(X[i] > Y[i]) break;\n    if(Y[i] < Y[i]) {\n      ret -= 1;\n      break;\n    }\n  }\n  cout << ret << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<bitset>\n#define BS 4096\nusing namespace std;\nbitset<4096>w[6], X, G, TP;\nint n, GL, Mod = 998244353, po[4096];\nchar p[4096];\nvoid Put(bitset<4096> &TP, char *key) {\n\tint i, L;\n\tfor (i = 0; key[i]; i++);\n\tL = i;\n\tfor (i = 0; i < L; i++) {\n\t\tTP[L - i - 1] = key[i]-'0';\n\t}\n}\nint Len(bitset<4096> &TP) {\n\tint j;\n\tfor (j = BS - 1; j >= 0; j--) {\n\t\tif (G[j])break;\n\t}\n\treturn j+1;\n}\nint main() {\n\tint i, j;\n\tpo[0] = 1;\n\tfor (i = 1; i <= 4000; i++)po[i] = po[i - 1] * 2 % Mod;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tPut(X, p);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%s\", p);\n\t\tPut(w[i], p);\n\t}\n\tG = w[0];\n\twhile (1) {\n\t\tint ck = 0;\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tTP = w[i];\n\t\t\tGL = Len(G);\n\t\t\tfor (j = BS - 1; j >= GL - 1; j--) {\n\t\t\t\tif (TP[j]) {\n\t\t\t\t\tTP ^= G << (j + 1 - GL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = BS - 1; j >= 0; j--)if (TP[j])break;\n\t\t\tif (j != -1) {\n\t\t\t\tck = 1;\n\t\t\t\tG = TP;\n\t\t\t}\n\t\t}\n\t\tif (!ck)break;\n\t}\n\tGL = Len(G);\n\tlong long res = 0;\n\tTP.reset();\n\tfor (i = BS - 1; i >= GL - 1; i--) {\n\t\tif (X[i]) {\n\t\t\tres = (res + po[i - (GL - 1)]) % Mod;\n\t\t}\n\t\tif (TP[i] != X[i]) {\n\t\t\tTP ^= G << (i + 1 - GL);\n\t\t}\n\t}\n\tint ck = 0;\n\tfor (i = BS - 1; i >= 0; i--) {\n\t\tif (X[i] != TP[i]) {\n\t\t\tif (TP[i]) ck = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tres = (res + 1 - ck) % Mod;\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nconst int MN = 4010;\n\nint N;\nstring X, g;\nstring A[6];\n\nstring gcd(string &a, string &b) {\n    if(a.size() < b.size()) return gcd(b, a);\n    if(b.size() == 0) return a;\n\n    int n = a.size();\n    int m = b.size();\n    for(int i = 0; i <= n - m; i++) {\n        if(a[n - 1 - i] == '1') {\n            for(int j = 0; j < m; j++) {\n                int t = a[n - 1 - i - j] - '0';\n                int d = b[m - 1 - j] - '0';\n                a[n - 1 - i - j] = '0' + (t ^ d);\n            }\n        }\n    }\n    while(a.size() && a.back() == '0') a.pop_back();\n    return gcd(b, a);\n}\n\nint chk[MN], po[MN];\n\nint cc[MN];\nint dp(int x) {\n    if(x == (int)X.size() - (int)g.size() + 1) return 1;\n    int &ret = cc[x];\n    if(ret != -1) return ret;\n\n    ret = dp(x + 1);\n    if(X[x] == '1') {\n        ret += po[ (int)X.size() - (int)g.size() - x ];\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    po[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        po[i] = 1LL * po[i - 1] * 2 % mod;\n    }\n\n    cin >> N >> X;\n\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n        reverse(A[i].begin(), A[i].end());\n    }\n\n    g = A[0];\n    for(int i = 1; i < N; i++) {\n        g = gcd(g, A[i]);\n    }\n\n    reverse(g.begin(), g.end());\n\n    int n = X.size();\n    int m = g.size();\n    string tmp = X;\n    for(int i = 0; i <= n - m; i++) {\n        chk[i] = tmp[i] - '0';\n        if(tmp[i] == '1') {\n            for(int j = 0; j < m; j++) {\n                int t = tmp[i + j] - '0';\n                int d = g[j];\n                tmp[i + j] = '0' + (t ^ d);\n            }\n        }\n    }\n    memset(cc, -1, sizeof(cc));\n    cout << dp(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt operator+(const modInt &n){return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n){return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n){return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n){return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n){return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n){return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n){return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n){return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\n\nmint solve(bitset<4000> x,int n,\n\t\t\t\t\t bitset<4000> a,int m){\n\t//rrep(j,20)cout<<x[j];cout<<endl;\n\tmint re,ret;\n\tbitset<4000> sum; sum.reset();\n\trreps(i,m,n){\n\t\tre*=2;\n\t\tif(x[i]) re+=1;\n\t\tif(x[i]!=sum[i]) sum^=a<<(i-m+1);\n\t}\n\tre*=2;\n\trep(_,2){\n\t\tint ok=1;\n\t\t// rrep(j,20)cout<<sum[j];cout<<endl;\n\t\t// rrep(j,20)cout<<x[j];cout<<endl;\n\t\trrep(i,4000){\n\t\t\tif(sum[i] && !x[i]){ ok=0; break;}\n\t\t\tif(!sum[i] && x[i]){ break;}\n\t\t}\n\t\t// out(ok,1);\n\t\tif(ok) ret+=1;\n\t\tsum^=a;\n\t}\n\treturn re+ret;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n\tstring x;\n\tcin>>n>>x;\n\tvector<pair<bitset<4000>,int>> as(n);\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tas[i].Y=s.size();\n\t\tas[i].X.reset();\n\t\trep(j,s.size()) as[i].X[j]=(s[s.size()-1-j]-'0');\n\t}\n\t// rep(i,as.size()){rrep(j,20)cout<<as[i].X[j];cout<<endl;}cout<<endl;\n\twhile(as.size()>1){\n\t\tsort(rall(as),[&](auto &l,auto &r){\n\t\t\t\treturn l.Y<r.Y;\n\t\t\t});\n\t\twhile(1){\n\t\t\tint upd=0;\n\t\t\trep(i,as.size())rep(j,i)if(as[i]==as[j]){\n\t\t\t\tas.erase(as.begin()+j);\n\t\t\t\tupd=1;\n\t\t\t}\n\t\t\trep(i,as.size())if(as[i].Y==0){\n\t\t\t\tas.erase(as.begin()+i);\n\t\t\t\tupd=1;\n\t\t\t}\n\t\t\tif(!upd) break;\n\t\t}\n\t\twhile(as.size() && as.back().Y==0) as.pop_back();\n\t\tif(as.size()<=1) break;\n\t\tas[0].X^=as[1].X<<(as[0].Y-as[1].Y);\n\t\tas[0].Y=0;\n\t\trep(i,4000){\n\t\t\tif(as[0].X[i]) as[0].Y=i+1;\n\t\t}\n\t}\n\t// rep(i,as.size()){rrep(j,20)cout<<as[i].X[j];cout<<\",\"<<as[i].Y<<endl;}cout<<endl;\n\n\tbitset<4000> st; st.reset();\n\trep(j,x.size()) st[j]=(x[x.size()-1-j]-'0');\n\tcout<<solve(st,x.size(),as[0].X,as[0].Y)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\nconst int limit = 4010;\nusing T = bitset<limit>;\n\nT gcd(T a, T b) {\n\t//cerr << a << \" \" << \" \" << b << endl;\n\tif (b.none()) return a;\n\tint ta = 0, tb = 0;\n\trep(i, limit) if (a[i]) ta = i;\n\trep(i, limit) if (b[i]) tb = i;\n\n\tif (ta < tb) {\n\t\treturn gcd(b, a);\n\t} else {\n\t\tT ab = a;\n\t\tfor (int i = ta; i >= tb; --i) {\n\t\t\tif (ab[i]) {\n\t\t\t\tab ^= b << (i - tb);\n\t\t\t}\n\t\t}\n\t\treturn gcd(b, ab);\n\t}\n\treturn b;\n}\n\nT read() {\n\tstring s;\n\tcin >> s;\n\tconst int n = s.size();\n\tT ret;\n\trep(i, n) if (s[i] == '1') ret.set(n - 1 - i);\n\treturn ret;\n}\n\nconst ll mod = 998244353LL;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\tT x, a[6];\n\n\tx = read();\n\trep(i, n) a[i] = read();\n\n\tT g = a[0];\n\trep(i, 1, n) g = gcd(g, a[i]);\n\n\tint tg = 0, tx = 0;\n\trep(i, limit) if (g[i]) tg = i;\n\trep(i, limit) if (x[i]) tx = i;\n\n\tll ans = 0LL;\n\tfor(int i = tx; i >= tg; --i) ans = (2LL * ans + x[i]) % mod;\n\tans = (ans + 1) % mod;\n\n\tT y;\n\tfor(int i = tx; i >= tg; --i){\n\t\tif(x[i] != y[i]){\n\t\t\ty^= g << (i -tg);\n\t\t}  \n\t}\n\n\tbool big = false;\n\trrep(i,tg){\n\t\tif(x[i]!=y[i]){\n\t\t\tif(x[i] > y[i]) big = false;\n\t\t\tbreak;\n\t\t} \n\t}\n\n\t/*\n\tcerr << x << endl;\n\tcerr << y << endl;\n\t*/\n\n\tif(big) ans = (ans + mod -1) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntypedef bitset<4000>bs;\n\nbs in(){\n    string s;cin>>s;\n    reverse(all(s));\n    bs ret;\n    rep(i,s.size())ret[i]=s[i]-'0';\n    return ret;\n}\n\nbs mo(bs &a,bs &b){\n    bs c=a;\n\n\n    int k=0;\n    rep(i,4000)if(b[i])k=i;\n    for(int i=4000-1;i>=k;i--){\n        if(c[i]){\n            c^=(b<<(i-k));\n        }\n    }\n    return c;\n}\n\nbs gcd(bs a,bs b){\n    if(b.count()==0)return a;\n    bs c=mo(a,b);\n    return gcd(b,c);\n}\n\nconst int mod=998244353;\n\nint N;\nint po[4444];\nsigned main(){\n    po[0]=1;\n    for(int i=1;i<4444;i++)po[i]=po[i-1]*2%mod;\n    cin>>N;\n    bs X=in();\n\n    bs g;\n    rep(i,N){\n        bs A=in();\n        g=gcd(A,g);\n    }\n\n    bs x;\n    int k=0;\n    rep(i,4000)if(g[i])k=i;\n\n    int ans=0;\n    for(int i=4000-1;i>=k;i--){\n        if(X[i]){\n            ans=(ans+po[i-k])%mod;\n            if(x[i]==0){\n                x^=g<<(i-k);\n            }\n        }\n        else{\n            if(x[i]==1){\n                x^=g<<(i-k);\n            }\n        }\n    }\n    ans++;\n    for(int i=4000-1;i>=0;i--){\n        if(X[i]==x[i])continue;\n        if(X[i]<x[i])ans--;\n        break;\n    }\n    ans%=mod;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\n\n\ntemplate<const std::size_t N>\nstruct bfps: public std::bitset<N> {\n  using size_type = std::size_t;\n  size_type len;\n\n  void recalc() {\n    this->len = 0;\n    for(i64 j = 5000; j --> 0;) {\n      if((*this)[j]) {\n        this->len = j + 1;\n        return;\n      }\n    }\n  }\n\n  bfps() : std::bitset<N>() { this->len = 0; }\n  //bfps(const std::uint_fast64_t x) : std::bitset<N>(x) { recalc(); }\n  bfps(const std::bitset<N>& b) : std::bitset<N>(b) { recalc(); }\n  size_type size() const { return this->len; }\n\n\n  static bfps mod(bfps a, const bfps& b) {\n    assert(b.size() > 0);\n    for(i64 i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static bfps div(bfps a, const bfps& b) {\n    assert(b.size() > 0);\n    bfps d;\n    for(i64 i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        bfps e;\n        e[i] = 1;\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static bfps gcd(bfps a, bfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = b;\n      b = m;\n    }\n    return a;\n  }\n};\n\nusing bits = bfps<4000>;\n\nint main() {\n  i64 N;\n  cin >> N;\n  bits X;\n  cin >> X;\n  X.recalc();\n\n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    bool OK = true;\n    for(i64 i = 5000; i --> 0; ) {\n      if(now[i] != X[i]) {\n        if(now[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    if(OK) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Ankur Dua\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nusing ll = long long;\nll mod=1000000007;\nll *fact, *ifact;\n\nusing cd = complex<long double>;\nconst long double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        long double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\nvector<ll> multiply(vector<ll> const& a, vector<ll> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size())\n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<ll> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int &cid = ptr[v]; cid < (int) adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n\n//Min cost max flow using dijkstra from https://codeforces.com/contest/1107/submission/49033783\ntemplate<typename flow_t, typename cost_t>\nstruct MinCostMaxFlow {\n    static const flow_t FLOW_INF = numeric_limits<flow_t>::max() / 2;\n    const cost_t COST_INF = numeric_limits<cost_t>::max() / 2;\n    struct edge {\n        int node, rev;\n        flow_t capacity;\n        cost_t cost;\n\n        edge(int _node = -1, int _rev = -1, flow_t _capacity = 0, cost_t _cost = 0)\n                : node(_node), rev(_rev), capacity(_capacity), cost(_cost) {}\n    };\n\n    int V = -1;\n    vector<vector<edge>> adj;\n    vector<cost_t> dist;\n    vector<int> prev;\n    vector<edge*> prev_edge;\n\n    MinCostMaxFlow(int vertices = -1) {\n        if (vertices >= 0)\n            init(vertices);\n    }\n\n    void init(int vertices) {\n        V = vertices;\n        adj.assign(V, {});\n        dist.resize(V);\n        prev.resize(V);\n        prev_edge.resize(V);\n    }\n\n    void addEdge(int u, int v, flow_t capacity, cost_t cost) {\n        edge uv_edge(v, adj[v].size() + (u == v ? 1 : 0), capacity, cost);\n        edge vu_edge(u, adj[u].size(), 0, -cost);\n        adj[u].push_back(uv_edge);\n        adj[v].push_back(vu_edge);\n    }\n\n    edge &reverse_edge(const edge &e) {\n        return adj[e.node][e.rev];\n    }\n\n    bool bellman_ford(int source, int sink) {\n        for (int i = 0; i < V; i++) {\n            dist[i] = COST_INF;\n            prev[i] = -1;\n            prev_edge[i] = nullptr;\n        }\n\n        vector<int> last_seen(V, -1);\n        vector<int> nodes(1, source);\n        dist[source] = 0;\n\n        for (int iteration = 0; iteration < V; iteration++) {\n            vector<int> next_nodes;\n\n            for (int node : nodes)\n                for (edge &e : adj[node])\n                    if (e.capacity > 0 && dist[node] + e.cost < dist[e.node]) {\n                        dist[e.node] = dist[node] + e.cost;\n                        prev[e.node] = node;\n                        prev_edge[e.node] = &e;\n\n                        if (last_seen[e.node] != iteration) {\n                            last_seen[e.node] = iteration;\n                            next_nodes.push_back(e.node);\n                        }\n                    }\n\n            swap(nodes, next_nodes);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    struct dijkstra_state {\n        cost_t dist;\n        int node;\n\n        bool operator<(const dijkstra_state &other) const {\n            return dist > other.dist;\n        }\n    };\n\n    void dijkstra_check(int node, cost_t potential_dist, int previous, edge *previous_edge, auto &pq) {\n        if (potential_dist < dist[node]) {\n            dist[node] = potential_dist;\n            prev[node] = previous;\n            prev_edge[node] = previous_edge;\n            pq.push({dist[node], node});\n        }\n    }\n\n    bool dijkstra(int source, int sink) {\n        dist.assign(V, COST_INF);\n        prev.assign(V, -1);\n        prev_edge.assign(V, nullptr);\n\n        priority_queue<dijkstra_state> pq;\n        dijkstra_check(source, 0, -1, nullptr, pq);\n\n        while (!pq.empty()) {\n            dijkstra_state top = pq.top();\n            pq.pop();\n\n            if (top.dist > dist[top.node])\n                continue;\n\n            for (edge &e : adj[top.node])\n                if (e.capacity > 0)\n                    dijkstra_check(e.node, top.dist + e.cost, top.node, &e, pq);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    void reduce_cost() {\n        for (int i = 0; i < V; i++)\n            for (edge &e : adj[i])\n                e.cost += dist[i] - dist[e.node];\n    }\n\n    pair<flow_t, cost_t> minCostFlow(int source, int sink, flow_t flow_goal = FLOW_INF) {\n        assert(V >= 0);\n\n        if (!bellman_ford(source, sink))\n            return make_pair(0, 0);\n\n        flow_t total_flow = 0;\n        cost_t total_cost = 0;\n        cost_t reduce_sum = 0;\n\n        do {\n            reduce_cost();\n            reduce_sum += dist[sink];\n            flow_t path_cap = flow_goal - total_flow;\n\n            for (int node = sink; prev[node] != -1; node = prev[node])\n                path_cap = min(path_cap, prev_edge[node]->capacity);\n\n            for (int node = sink; prev[node] != -1; node = prev[node]) {\n                edge *e = prev_edge[node];\n                assert(e->cost == 0);\n                e->capacity -= path_cap;\n                reverse_edge(*e).capacity += path_cap;\n            }\n\n            total_flow += path_cap;\n            total_cost += reduce_sum * path_cap;\n        } while (total_flow < flow_goal && dijkstra(source, sink));\n\n        return make_pair(total_flow, total_cost);\n    }\n};\n\nll modExp(ll base, ll exp, ll mod=::mod){\n    ll ans=1;\n    while(exp) {\n        if (exp & 1) {\n            (ans *= base) %= mod;\n        }\n        (base *= base) %= mod;\n        exp>>=1;\n    }\n    return ans;\n}\nll modInv(ll x, ll mod=::mod){\n    return modExp(x,mod-2,mod);\n}\nvoid modFact(ll n, ll mod=::mod){\n    ifact=new ll[n+1];\n    fact=new ll[n+1];\n    fact[0]=fact[1]=1;\n    for(int i=2;i<=n;i++){\n        fact[i]=(i*fact[i-1])%mod;\n    }\n    ifact[n]=modInv(fact[n], mod);\n    for(int i=n-1;i>=0;i--){\n        ifact[i]=((i+1)*ifact[i+1])%mod;\n    }\n}\nll ncr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[r];\n    ans%=mod;\n    ans*=ifact[n-r];\n    ans%=mod;\n    return ans;\n}\nll npr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[n-r];\n    return ans%mod;\n}\nclass DSU{\npublic:\n    int*p, *r;\n    DSU(int n){\n        p=new int[n+50];\n        r=new int[n+50];\n        for(int i=0;i<=n+10;i++){\n            p[i]=i;\n            r[i]=0;\n        }\n    }\n    ~DSU(){\n        delete[] p;\n        delete[] r;\n    }\n    int find(int x){\n        if(p[x]==x)\n            return x;\n        return p[x]=find(p[x]);\n    }\n    bool Unite(int a, int b){\n        a=find(a);\n        b=find(b);\n        if(a==b)\n            return false;\n        if(r[a]<r[b])\n            p[a]=b;\n        else\n            p[b]=a;\n        if(r[a]==r[b])\n            r[a]++;\n        return true;\n    }\n};\nusing namespace std;\nconst int mx=4000;\ntypedef bitset<mx> BS;\nll p2[mx];\nBS b;\nclass ARC84D {\npublic:\n    ll dfs(BS &x,vector<int> &cnt, int bp, bool eq, vector<BS> &basis){\n        if(bp==-1)\n            return 1;\n        if(!eq)\n            return p2[cnt[bp]];\n        ll ans=0;\n        if(x[bp] && b[bp]){\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,false,basis);\n                b^=basis[bp];\n                ans%=mod;\n            }\n        }else if(x[bp] && !b[bp]){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n            ans+=dfs(x,cnt,bp-1,false,basis);\n\n            ans%=mod;\n        }else if((!x[bp]) && (b[bp])){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n        }else{\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n        }\n\n        return ans;\n    }\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        int n;\n        cin>>n;\n\n        string xx;\n        cin>>xx;\n        BS x(xx);\n        vector<BS> basis(mx);\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            BS cur(s);\n\n            do{\n                BS v=cur;\n                for(int j=mx-1;j>=0;j--){\n                    if(v[j] && basis[j][j])\n                        v^=basis[j];\n                    else if(v[j]){\n                        basis[j]=v;\n                        break;\n                    }\n                }\n                if(!cur[mx-1])\n                    cur<<=1;\n                else break;\n            }while(true);\n        }\n        mod=998244353;\n        p2[0]=1;\n        for(int i=1;i<mx;i++){\n            p2[i]=(2*p2[i-1])%mod;\n        }\n        BS least;\n        for(int i=0;i<mx-1;i++){\n            if(basis[i][i]){\n                least=basis[i]<<1;\n                for(int j=i+1;j<mx;j++,least<<=1){\n                    if(!basis[j][j]){\n                        basis[j]=least;\n                    }\n                }\n            }\n        }\n        vector<int> cnt(mx);\n        for(int i=0;i<mx;i++)\n            if(basis[i][i])\n                cnt[i]=1;\n        for(int i=1;i<mx;i++)\n            cnt[i]+=cnt[i-1];\n        b=BS();\n        cout<<dfs(x,cnt,mx-1,true,basis)<<endl;\n\t}\n};\n\n\nint main() {\n\tARC84D solver;\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(NULL);\n\tstd::cout.tie(NULL);\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nstatic const int MOD = 998244353;\n\n#define N 4040\n\nint Len(const bitset<N> &a) {\n        for (int res = N - 1; res >= 0; res --) {\n                if (a[res]) return res + 1;\n        }\n        return 0;\n}\n\nbitset<N> gcd(bitset<N> s, bitset<N> t) {\n        int n = Len(s), m = Len(t);\n        if (n < m) return gcd(t, s);\n        if (t.none()) return s;\n        int d = n - m;\n        bitset<N> u = t;\n        u <<= d;\n        s ^= u;\n        return gcd(t, s);\n}\n\nlong long ModPow(long long x, long long n, long long m) {\n        long long res = 1;\n        while (n > 0) {\n                if (n & 1) res = res * x % m;\n                x = x * x % m;\n                n >>= 1;\n        }\n        return res;\n}\n\nint main() {\n        int q;\n        scanf(\"%d\", &q);\n        bitset<N> x;\n        cin >> x;\n        bitset<N> g;\n        for (int i = 0; i < q; i ++) {\n                bitset<N> s;\n                cin >> s;\n                g = gcd(g, s);\n        }\n        int n = Len(x);\n        bitset<N> d(0);\n        int m = Len(g);\n        int ans = 0;\n        for (int i = n - 1; i >= m - 1; i --) {\n                if (x[i]) ans = (ans + ModPow(2, i - m + 1, MOD)) % MOD;\n                if (x[i] == d[i]) continue;\n                d ^= (g << i - m + 1);\n        }\n        for (int i = n - 1; i >= 0; i ++) {\n                if (d[i] == 1 && x[i] == 0) {\n                        ans = (ans + 1) % MOD;\n                        break;\n                }\n        }\n        printf(\"%d\\n\", ans);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int P = 998244353;\nconst int L = 4001;\nint n;\nusing Bit = bitset<L>;\ntypedef pair<Bit,int> num;\nnum X , A[6];\nchar s[10000];\nvoid output(num x){\n    per(i,0,10) putchar(x.fi[i]+'0');puts(\"\");\n}\nvoid read(num&b){\n    scanf(\"%s\",s);\n    b.fi.reset();\n    int len = strlen(s);\n    rep(i,0,len) b.fi[i]=s[len-1-i]-'0';\n    b.se=len-1;\n}\nnum gcd(num x,num y){\n    if(x.se<y.se) swap(x,y);\n    if(y.se==-1) return x;\n    num z(x.fi^(y.fi<<(x.se-y.se)),x.se);\n    while(z.se>=0&&z.fi[z.se]==0) z.se--;\n    return gcd(z,y);\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    read(X);\n    rep(i,0,n) read(A[i]);\n    rep(i,1,n) A[0]=gcd(A[0],A[i]);\n    int ans = 0;\n    for(int i=X.se;i>=A[0].se;--i){\n        ans = (ans + ans) % P;\n        if(X.fi[i] == 1) ans = (ans + 1) % P;\n    }\n    num Y = X;\n    rep(i,0,A[0].se) Y.fi[i]=0;\n    for(int i=Y.se;i>=A[0].se;--i)if(Y.fi[i]){\n        Y.fi ^= A[0].fi << (i - A[0].se);\n    }\n    bool ok = true;\n    for(int i=A[0].se-1;i>=0;--i) if(X.fi[i]!=Y.fi[i]){\n        if(X.fi[i]<Y.fi[i]) ok=false;\n        break;\n    }\n    ans = (ans + ok) % P;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<bitset>\n#define BS 4096\nusing namespace std;\nbitset<4096>w[6], X, G, TP;\nint n, GL, Mod = 998244353, po[4096];\nchar p[4096];\nvoid Put(bitset<4096> &TP, char *key) {\n\tint i, L;\n\tfor (i = 0; key[i]; i++);\n\tL = i;\n\tfor (i = 0; i < L; i++) {\n\t\tTP[L - i - 1] = key[i]-'0';\n\t}\n}\nint Len(bitset<4096> &TP) {\n\tint j;\n\tfor (j = BS - 1; j >= 0; j--) {\n\t\tif (G[j])break;\n\t}\n\treturn j+1;\n}\nint main() {\n\tint i, j;\n\tpo[0] = 1;\n\tfor (i = 1; i <= 4000; i++)po[i] = po[i - 1] * 2 % Mod;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tPut(X, p);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%s\", p);\n\t\tPut(w[i], p);\n\t}\n\tG = w[0];\n\twhile (1) {\n\t\tint ck = 0;\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tTP = w[i];\n\t\t\tGL = Len(G);\n\t\t\tfor (j = BS - 1; j >= GL - 1; j--) {\n\t\t\t\tif (TP[j]) {\n\t\t\t\t\tTP ^= G << (j + 1 - GL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = BS - 1; j >= 0; j--)if (TP[j])break;\n\t\t\tif (j != -1) {\n\t\t\t\tck = 1;\n\t\t\t\tG = TP;\n\t\t\t}\n\t\t}\n\t\tif (!ck)break;\n\t}\n\tGL = Len(G);\n\tlong long res = 0;\n\tfor (i = BS - 1; i >= GL - 1; i--) {\n\t\tif (X[i]) {\n\t\t\tres = (res + po[i - (GL - 1)]) % Mod;\n\t\t}\n\t\tif (TP[i] != X[i]) {\n\t\t\tTP ^= G << (i + 1 - GL);\n\t\t}\n\t}\n\tTP ^= X;\n\tint ck = 0;\n\tfor (i = BS - 1; i >= 0; i--) {\n\t\tif (X[i] != TP[i]) {\n\t\t\tif (TP[i]) ck = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tres = (res + 1 - ck) % Mod;\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define md 998244353\n\nvoid show(vi x){\n  rep(i,x.size())cout<<x[i];\n  cout<<endl;\n  cout<<endl;\n}\n\nvi mod(const vi& a,const vi& b){\n  vi crt=a;\n  while(crt.size()>=b.size()){\n    vi nxt;\n    bool mada=true;\n    rep(j,b.size()){\n      if(!mada){\n        nxt.push_back(crt[j]^b[j]);\n      }else{\n        if(crt[j]^b[j]){\n          nxt.push_back(1); mada=false;\n        }\n      }\n    }\n    repl(j,b.size(),crt.size()){\n      if(!mada){\n        nxt.push_back(crt[j]);\n      }else{\n        if(crt[j]){\n          nxt.push_back(1); mada=false;\n        }\n      }\n    }\n    crt=nxt;\n  }\n  return crt;\n}\n\nvi mgcd(vi a,vi b){\n  if(b.size()==0) return a;\n  else return mgcd(b,mod(a,b));\n}\n\nll N;\nvi X;\nvi A[6];\nll dp[4001][2];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N;\n  {\n    string s;\n    cin>>s;\n    rep(j,s.size())X.push_back(s[j]-'0');\n  }\n  rep(i,N){\n    string s;\n    cin>>s;\n    rep(j,s.size())A[i].push_back(s[j]-'0');\n  }\n\n  vi g=A[0];\n  repl(i,1,N){\n    g=mgcd(g,A[i]);\n  }\n\n  ll d=g.size();\n  ll m=X.size()-d+1;\n  dp[0][0]=1;\n  rep(i,m)rep(j,2){\n    rep(nxt,(j==0?X[i]+1:2)){\n      (dp[i+1][!(j==0&&nxt==X[i])]+=dp[i][j])%=md;\n    }\n  }\n  ll res=dp[m][1];\n  cout<<(res+1)%md<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v, w; };\n\nvector<int> gcd(vector<int> s, vector<int> t) {\n\tint N = s.size(), M = t.size();\n\tif (N < M) return gcd(t, s);\n\tif (!M) return s;\n\trep(j, M) s[j] ^= t[j];\n\tint l = N;\n\trep(i, N) if (s[i]) {\n\t\tl = min(l, i);\n\t\tbreak;\n\t}\n\tvector<int> a(N - l);\n\trep(i, N - l) a[i] = s[l + i];\n\treturn gcd(t, a);\n}\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n >>= 1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint N; cin >> N;\n\tstring s; cin >> s;\n\tvector<string> a(N);\n\trep(i, N) cin >> a[i];\n\tvector<int> d;\n\trep(i, N) {\n\t\tint M = a[i].length();\n\t\tvector<int> b(M);\n\t\trep(j, M) b[j] = a[i][j] - '0';\n\t\td = gcd(d, b);\n\t}\n\tint n = s.length();\n\tvector<int> c(n), _c(n);\n\trep(i, n) c[i] = s[i] - '0';\n\tint m = d.size();\n\tint ans = 0;\n\tfor (int i = 0; i + m <= n; i++) {\n\t\tif (c[i]) ans = (ans + pow_mod(2, n - m - i, MOD)) % MOD;\n\t\tif (c[i] == _c[i]) continue;\n\t\trep(j, m) _c[i + j] ^= d[j];\n\t}\n\tbool ok = true;\n\tif (_c > c) ok = false;\n\tif (ok) ans = (ans + 1) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 4000, mod = 998244353;\ntypedef std::bitset<N> bitset;\n\nbitset X, G, A, now;\nint g, n, x, ans, p[N];\n\nvoid up(int &x, int y) {x += y - mod, x += x >> 31 & mod;}\nint length(const bitset &a) {\n\tfor (int i = N - 1; ~i; --i) if (a.test(i)) return i;\n\treturn -1;\n}\nvoid poly_mod(bitset &a, const bitset &g, int &lena, int leng) {\n\tfor (int i = lena; i >= leng; --i) if (a.test(i))\n\t\ta ^= g << i - leng;\n\twhile (lena >= 0 && !a.test(lena)) --lena;\n}\nvoid poly_gcd(bitset &g, bitset &a, int &leng, int &lena) {\n\tif (g.none()) {g = a, leng = lena; return;}\n\tpoly_mod(a, g, lena, leng), poly_gcd(a, g, lena, leng);\n}\nvoid read(bitset &b) {\n\tb.reset(); std::string s; std::cin >> s, std::reverse(s.begin(), s.end());\n\tfor (int i = 0; i < s.size(); ++i) b.set(i, s[i] & 1);\n}\nbool leq(const bitset &a, const bitset &b) {\n\tfor (int i = N - 1; ~i; --i)\n\t\tif (a.test(i) != b.test(i))\n\t\t\treturn a.test(i) < b.test(i);\n\treturn 1;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n, read(X), x = length(X);\n\tfor (int i = 0, a; i < n; ++i)\n\t\tread(A), poly_gcd(G, A, g, a = length(A));\n\tp[0] = 1; for (int i = 1; i <= x; ++i) up(p[i] = p[i - 1], p[i - 1]);\n\tfor (int i = x; i >= g; --i) {\n\t\tif (X.test(i)) up(ans, p[i - g]);\n\t\tif (now.test(i) != X.test(i)) now ^= G << i - g;\n\t}\n\tup(ans, leq(now, X)), std::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 4096;\nconst int mod = 998244353;\nusing bs = bitset<MAXN>;\n\nint len(bs &x){\n\tfor(int i=MAXN-1; i>=0; i--){\n\t\tif(x[i]) return i + 1;\n\t}\n\treturn 0;\n}\n\nbs MOD(bs a, bs b){\n\tint d = len(a) - len(b);\n\tif(d < 0) return a;\n\treturn a ^ (b << d);\n}\n\nbs gcd(bs a, bs b){\n\tif(len(b) == 0) return a;\n\treturn gcd(b, MOD(a, b));\n}\n\nbs input(){\n\tstring s;\n\tcin >> s;\n\tbs ret = 0;\n\treverse(s.begin(), s.end());\n\tfor(int i=0; i<s.size(); i++){\n\t\tif(s[i] == '1') ret.set(i);\n\t}\n\treturn ret;\n}\n\nint pwr(int x){\n\tint ret = 1;\n\tfor(int i=0; i<x; i++) ret = ret * 2 % mod;\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tbs x = input();\n\tbs g = 0;\n\tfor(int i=0; i<n; i++){\n\t\tg = gcd(g, input());\n\t}\n\tn = len(x);\n\tint m = len(g);\n\tint ret = 1;\n\tbs cur = 0;\n\tfor(int i=n-1; i>=m-1; i--){\n\t\tif(x[i] == 0){\n\t\t\tif(cur[i] == 1){\n\t\t\t\tcur ^= (g << (i - m + 1));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(cur[i] == 0){\n\t\t\t\tret += pwr(i - m + 1);\n\t\t\t\tret %= mod;\n\t\t\t\tcur ^= (g << (i - m + 1));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret += pwr(i - m + 1);\n\t\t\t\tret %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=m-2; i>=0; i--){\n\t\tif(cur[i] < x[i]) break;\n\t\tif(cur[i] > x[i]){\n\t\t\tret += mod - 1;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\nvector<bool> input(){\n\tstring s;\n\tcin>>s;\n\tint N = s.size();\n\tvector<bool> x(N);\n\trep(i,N) x[i] = s[i]=='1';\n\treturn x;\n}\nvoid normalize(vector<bool>& a){\n\tvector<bool> b;\n\tint N = a.size();\n\tbool yet = 1;\n\trep(i,N){\n\t\tif(a[i]){\n\t\t\tyet = 0;\n\t\t}\n\t\tif(!yet) b.pb(a[i]);\n\t}\n\ta = b;\n}\nvector<bool> gcd(vector<bool> a,vector<bool> b){\n\tnormalize(a);\n\tnormalize(b);\n\tint N = a.size(), M = b.size();\n\tif(N<M) swap(a,b),swap(N,M);\n\n\tif(M==0) return a;\n\n\trep(i,M) a[i] = a[i] ^ b[i];\n\treturn gcd(a,b);\n}\n\nint N;\nint main(){\n\tcin>>N;\n\tvector<bool> X = input();\n\tvector<bool> g;\n\trep(i,N){\n\t\tvector<bool> f;\n\t\tf = input();\n\t\tg = gcd(g,f);\n\t}\n\tvector<mint> p2(5000);\n\tp2[0] = 1;\n\trep1(i,4999) p2[i] = p2[i-1]*2;\n\n\tmint ans = 0;\n\tvector<bool> oX = X;\n\tint a = X.size();\n\tint b = g.size();\n\trep(i,a-b+1){\n\t\tif(X[i]){\n\t\t\trep(j,b) X[i+j] = X[i+j] ^ g[j];\n\t\t}\n\t\tif(oX[i]){\n\t\t\tans += p2[a-(i+b)];\n\t\t}\n\t}\n\tvector<bool> f(a);\n\trep(i,a) f[i] = oX[i] ^ X[i];\n\tif(f <= oX) ans += 1;\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\nusing namespace std;\n \n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n \nconst int MOD = 998244353;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y) {\n\treturn ((ll)x * y) % MOD;\n}\n \nconst int N = 4010;\nint n;\nint a[N];\nint b[N];\nint c[N];\nint m, L1, L2;\nchar s[N];\nint p2[N];\n \nvoid reduce() {\n\t//cerr << \"REDUCE\" << endl;\n\twhile(true) {\n\t\t//cerr << L1 << \" \" << L2 << endl;\n\t\tif (L1 > L2) {\n\t\t\tswap(a, b);\n\t\t\tswap(L1, L2);\n\t\t}\n\t\tfor (int i = 0; i < L1; i++)\n\t\t\tb[L2 - L1 + i] ^= a[i];\n\t\twhile(L2 > 0 && b[L2 - 1] == 0) L2--;\n\t\tif (L2 == 0) break;\n\t}\n}\n \nint solve() {\n\tif (L1 > m) return 0;\n\tfor (int i = 0; i < m; i++)\n\t\tb[i] = 0;\n\tint ans = 0;\n\tfor (int i = m - 1; i >= L1 - 1; i--) {\n\t\tif (c[i] == 1) ans = add(ans, p2[1 + i - L1]);\n\t\tif (b[i] != c[i]) {\n\t\t\tfor (int j = 0; j < L1; j++)\n\t\t\t\tb[i - L1 + 1 + j] ^= a[j];\n\t\t}\n\t}\n\tint p = L1 - 1;\n\twhile(p >= 0 && b[p] == c[p]) p--;\n\tif (p < 0 || b[p] < c[p]) ans = add(ans, 1);\n\treturn ans;\n}\n \nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n \n\tp2[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tp2[i] = add(p2[i - 1], p2[i - 1]);\n \n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s);\n\tm = strlen(s);\n\tfor (int i = 0; i < m; i++)\n\t\tc[i] = s[m - 1 - i] - '0';\n\tscanf(\"%s\", s);\n\tL1 = strlen(s);\n\tfor (int i = 0; i < L1; i++)\n\t\ta[i] = s[L1 - 1 - i] - '0';\n\tn--;\n\twhile(n--) {\n\t\tscanf(\"%s\", s);\n\t\tL2 = strlen(s);\n\t\tfor (int i = 0; i < L2; i++)\n\t\t\tb[i] = s[L2 - 1 - i] - '0';\n\t\treduce();\n\t}\n\t/*\n\tprintf(\"%d \", L1);\n\tfor (int i = 0; i < L1; i++)\n\t\tprintf(\"%d\", a[i]);\n\tprintf(\"\\n\");\n\t*/\n\tprintf(\"%d\\n\", solve());\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar s[4009],X[4009];\nint n,c;\nbitset<4000> a[4000],B,C,B2;\n\n#define mod 998244353\nint add(int x,int y){\n\treturn (x+=y)<mod?x:x-mod;\n}\nint p2[4009];\nint main(){\n\tp2[0] = 1;\n\tfor(int i=1; i<4009; i++)\n\t\tp2[i] = add(p2[i-1],p2[i-1]);\n\n\tint l;\n\tscanf(\"%d%s\",&n,&X);\n\n\tscanf(\"%s\",s);\n\tl = strlen(s);\n\tfor(int i=0; s[i]; i++)if(s[i] == '1')\n\t\ta[l-1].set(l-1-i);\n\tint lo = l-1;\n\twhile(l <= 3999){\n\t\ta[l] = a[l-1] << 1;\n\t\tl++;\n\t}\n\tfor(int i=1; i<n; i++){\n\t\tscanf(\"%s\",s);\n\t\tl = strlen(s);\n\t\tB.reset();\n\t\tfor(int j=0; s[j]; j++)if(s[j] == '1')\n\t\t\tB.set(l-1-j);\n\t\tfor(int j=l-1; j>=0; j--){\n\t\t\tif(!a[j].test(j)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(B.test(j))\n\t\t\t\tB ^= a[j];\n\t\t}\n\t\tif(B.none())continue;\n\n\t\tC = a[lo];\n\t\tint H = -1;\n\t\tfor(int j=3999; j>=0; j--)if(B.test(j)){\n\t\t\tH = j;\n\t\t\tbreak;\n\t\t}\n\t\tB2 = B << (lo - H);\n\t\twhile(lo >= H){\n\t\t\tif(C.test(lo))\n\t\t\t\tC ^= B2;\n\t\t\tB2 >>= 1;\n\t\t\tlo--;\n\t\t}\n\n\t\tif(!C.none())B = C;\n\n\t\tH = -1;\n\t\tfor(int j=3999; j>=0; j--)if(B.test(j)){\n\t\t\tH = j;\n\t\t\tbreak;\n\t\t}\n\t\ta[H] = B;\n\t\tfor(int j=H+1; j<lo; j++)\n\t\t\ta[j] = a[j-1] << 1;\n\t\tlo = H;\n\t}\n\n\n\tl = strlen(X);\n\tint res = 0;\n\tfor(int i=0;;i++){\n\t\tif(X[i] == '1'){\n\t\t\tif(l-1-i >= lo){\n\t\t\t\tres = add(res, p2[l-1-i-lo]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(X[i] == '0')continue;\n\n\t\tB.reset();\n\t\tfor(int j=0; j<i; j++)if(X[j] == '1')B.set(l-1-j);\n\t\tfor(int j=l-1; j>=lo; j--)if(B.test(j))\n\t\t\tB ^= a[j];\n\t\tbool small = true;\n\t\tfor(int j=i; j<l; j++){\n\t\t\tbool x_bit = (X[j] == '1');\n\t\t\tbool y_bit = B.test(l-1-j);\n\t\t\tif(x_bit != y_bit){\n\t\t\t\tif(!x_bit && y_bit)\n\t\t\t\t\tsmall = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(small)res=add(res,1);\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Ankur Dua\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nusing ll = long long;\nll mod=1000000007;\nll *fact, *ifact;\n\nusing cd = complex<long double>;\nconst long double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        long double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\nvector<ll> multiply(vector<ll> const& a, vector<ll> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size())\n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<ll> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int &cid = ptr[v]; cid < (int) adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n\n//Min cost max flow using dijkstra from https://codeforces.com/contest/1107/submission/49033783\ntemplate<typename flow_t, typename cost_t>\nstruct MinCostMaxFlow {\n    static const flow_t FLOW_INF = numeric_limits<flow_t>::max() / 2;\n    const cost_t COST_INF = numeric_limits<cost_t>::max() / 2;\n    struct edge {\n        int node, rev;\n        flow_t capacity;\n        cost_t cost;\n\n        edge(int _node = -1, int _rev = -1, flow_t _capacity = 0, cost_t _cost = 0)\n                : node(_node), rev(_rev), capacity(_capacity), cost(_cost) {}\n    };\n\n    int V = -1;\n    vector<vector<edge>> adj;\n    vector<cost_t> dist;\n    vector<int> prev;\n    vector<edge*> prev_edge;\n\n    MinCostMaxFlow(int vertices = -1) {\n        if (vertices >= 0)\n            init(vertices);\n    }\n\n    void init(int vertices) {\n        V = vertices;\n        adj.assign(V, {});\n        dist.resize(V);\n        prev.resize(V);\n        prev_edge.resize(V);\n    }\n\n    void addEdge(int u, int v, flow_t capacity, cost_t cost) {\n        edge uv_edge(v, adj[v].size() + (u == v ? 1 : 0), capacity, cost);\n        edge vu_edge(u, adj[u].size(), 0, -cost);\n        adj[u].push_back(uv_edge);\n        adj[v].push_back(vu_edge);\n    }\n\n    edge &reverse_edge(const edge &e) {\n        return adj[e.node][e.rev];\n    }\n\n    bool bellman_ford(int source, int sink) {\n        for (int i = 0; i < V; i++) {\n            dist[i] = COST_INF;\n            prev[i] = -1;\n            prev_edge[i] = nullptr;\n        }\n\n        vector<int> last_seen(V, -1);\n        vector<int> nodes(1, source);\n        dist[source] = 0;\n\n        for (int iteration = 0; iteration < V; iteration++) {\n            vector<int> next_nodes;\n\n            for (int node : nodes)\n                for (edge &e : adj[node])\n                    if (e.capacity > 0 && dist[node] + e.cost < dist[e.node]) {\n                        dist[e.node] = dist[node] + e.cost;\n                        prev[e.node] = node;\n                        prev_edge[e.node] = &e;\n\n                        if (last_seen[e.node] != iteration) {\n                            last_seen[e.node] = iteration;\n                            next_nodes.push_back(e.node);\n                        }\n                    }\n\n            swap(nodes, next_nodes);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    struct dijkstra_state {\n        cost_t dist;\n        int node;\n\n        bool operator<(const dijkstra_state &other) const {\n            return dist > other.dist;\n        }\n    };\n\n    void dijkstra_check(int node, cost_t potential_dist, int previous, edge *previous_edge, auto &pq) {\n        if (potential_dist < dist[node]) {\n            dist[node] = potential_dist;\n            prev[node] = previous;\n            prev_edge[node] = previous_edge;\n            pq.push({dist[node], node});\n        }\n    }\n\n    bool dijkstra(int source, int sink) {\n        dist.assign(V, COST_INF);\n        prev.assign(V, -1);\n        prev_edge.assign(V, nullptr);\n\n        priority_queue<dijkstra_state> pq;\n        dijkstra_check(source, 0, -1, nullptr, pq);\n\n        while (!pq.empty()) {\n            dijkstra_state top = pq.top();\n            pq.pop();\n\n            if (top.dist > dist[top.node])\n                continue;\n\n            for (edge &e : adj[top.node])\n                if (e.capacity > 0)\n                    dijkstra_check(e.node, top.dist + e.cost, top.node, &e, pq);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    void reduce_cost() {\n        for (int i = 0; i < V; i++)\n            for (edge &e : adj[i])\n                e.cost += dist[i] - dist[e.node];\n    }\n\n    pair<flow_t, cost_t> minCostFlow(int source, int sink, flow_t flow_goal = FLOW_INF) {\n        assert(V >= 0);\n\n        if (!bellman_ford(source, sink))\n            return make_pair(0, 0);\n\n        flow_t total_flow = 0;\n        cost_t total_cost = 0;\n        cost_t reduce_sum = 0;\n\n        do {\n            reduce_cost();\n            reduce_sum += dist[sink];\n            flow_t path_cap = flow_goal - total_flow;\n\n            for (int node = sink; prev[node] != -1; node = prev[node])\n                path_cap = min(path_cap, prev_edge[node]->capacity);\n\n            for (int node = sink; prev[node] != -1; node = prev[node]) {\n                edge *e = prev_edge[node];\n                assert(e->cost == 0);\n                e->capacity -= path_cap;\n                reverse_edge(*e).capacity += path_cap;\n            }\n\n            total_flow += path_cap;\n            total_cost += reduce_sum * path_cap;\n        } while (total_flow < flow_goal && dijkstra(source, sink));\n\n        return make_pair(total_flow, total_cost);\n    }\n};\n\nll modExp(ll base, ll exp, ll mod=::mod){\n    ll ans=1;\n    while(exp) {\n        if (exp & 1) {\n            (ans *= base) %= mod;\n        }\n        (base *= base) %= mod;\n        exp>>=1;\n    }\n    return ans;\n}\nll modInv(ll x, ll mod=::mod){\n    return modExp(x,mod-2,mod);\n}\nvoid modFact(ll n, ll mod=::mod){\n    ifact=new ll[n+1];\n    fact=new ll[n+1];\n    fact[0]=fact[1]=1;\n    for(int i=2;i<=n;i++){\n        fact[i]=(i*fact[i-1])%mod;\n    }\n    ifact[n]=modInv(fact[n], mod);\n    for(int i=n-1;i>=0;i--){\n        ifact[i]=((i+1)*ifact[i+1])%mod;\n    }\n}\nll ncr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[r];\n    ans%=mod;\n    ans*=ifact[n-r];\n    ans%=mod;\n    return ans;\n}\nll npr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[n-r];\n    return ans%mod;\n}\nclass DSU{\npublic:\n    int*p, *r;\n    DSU(int n){\n        p=new int[n+50];\n        r=new int[n+50];\n        for(int i=0;i<=n+10;i++){\n            p[i]=i;\n            r[i]=0;\n        }\n    }\n    ~DSU(){\n        delete[] p;\n        delete[] r;\n    }\n    int find(int x){\n        if(p[x]==x)\n            return x;\n        return p[x]=find(p[x]);\n    }\n    bool Unite(int a, int b){\n        a=find(a);\n        b=find(b);\n        if(a==b)\n            return false;\n        if(r[a]<r[b])\n            p[a]=b;\n        else\n            p[b]=a;\n        if(r[a]==r[b])\n            r[a]++;\n        return true;\n    }\n};\nusing namespace std;\nconst int mx=5000;\ntypedef bitset<mx> BS;\nll p2[mx];\nBS b;\nclass ARC84D {\npublic:\n    ll dfs(BS &x,vector<int> &cnt, int bp, bool eq, vector<BS> &basis){\n        if(bp==-1)\n            return 1;\n        if(!eq)\n            return p2[cnt[bp]];\n        ll ans=0;\n        if(x[bp] && b[bp]){\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,false,basis);\n                b^=basis[bp];\n                ans%=mod;\n            }\n        }else if(x[bp] && !b[bp]){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n            ans+=dfs(x,cnt,bp-1,false,basis);\n\n            ans%=mod;\n        }else if((!x[bp]) && (b[bp])){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n        }else{\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n        }\n\n        return ans;\n    }\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        int n;\n        cin>>n;\n\n        string xx;\n        cin>>xx;\n        BS x(xx);\n        vector<BS> basis(mx);\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            BS cur(s);\n\n            do{\n                BS v=cur;\n                for(int j=mx-1;j>=0;j--){\n                    if(v[j] && basis[j][j])\n                        v^=basis[j];\n                    else if(v[j]){\n                        basis[j]=v;\n                        break;\n                    }\n                }\n                if(!cur[mx-1])\n                    cur<<=1;\n                else break;\n            }while(true);\n        }\n        mod=998244353;\n        p2[0]=1;\n        for(int i=1;i<mx;i++){\n            p2[i]=(2*p2[i-1])%mod;\n        }\n        BS least;\n        for(int i=0;i<mx-1;i++){\n            if(basis[i][i]){\n                least=basis[i]<<1;\n                for(int j=i+1;j<mx;j++,least<<=1){\n                    if(!basis[j][j]){\n                        basis[j]=least;\n                    }\n                }\n                break;\n            }\n        }\n        vector<int> cnt(mx);\n        for(int i=0;i<mx;i++)\n            if(basis[i][i])\n                cnt[i]=1;\n        for(int i=1;i<mx;i++)\n            cnt[i]+=cnt[i-1];\n        b=BS();\n        cout<<dfs(x,cnt,mx-1,true,basis)<<endl;\n\t}\n};\n\n\nint main() {\n\tARC84D solver;\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(NULL);\n\tstd::cout.tie(NULL);\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 4040\n\nlong long mod=998244353;\nlong long n,powlist[N+1],pfig,xfig,ans;\nbitset<N> p,q,x;\n\nint countFigure(bitset<N> masu){\n    int cnt=0;\n    for(int i=0;masu[N-i]==0;i++)cnt++;\n    return N-cnt+1;\n}\n\nvoid bitsetSubtract(bitset<N> &x, const bitset<N> &y) {\n    bool b = false;\n\n    for (int i = 0; i < N; i++) {\n        if (b) {\n            if (x[i]) {\n                x[i] = y[i];\n                b = y[i];\n            } else {\n                x[i] = !y[i];\n                b = true;\n            }\n        } else {\n            if (x[i]) {\n                x[i] = !y[i];\n                b = false;\n            } else {\n                x[i] = y[i];\n                b = y[i];\n            }\n        }\n    }\n}\n\nbitset<N> gcd(bitset<N> u, bitset<N> v) {\n    bitset<N> one (string(\"1\"));\n    bitset<N> zero (string(\"0\"));\n\n    int shift;\n\n    if (u == 0) return v;\n    if (v == 0) return u;\n\n    for (shift = 0; ((u | v) & one) == zero; ++shift) {\n        u >>= 1;\n        v >>= 1;\n    }\n\n    while ((u & one) == zero) u >>= 1;\n\n    do {\n        while ((v & one) == zero) v >>= 1;\n\n        if (u.to_string() > v.to_string()) {\n            bitset<N> t = v;\n            v = u;\n            u = t;\n        }\n\n        bitsetSubtract(v,u);\n    } while (v != 0);\n\n    return u << shift;\n}\n\nint bitPowerlist(){\n    powlist[1]=1;\n    for(int i=2;i<=N;i++){\n        powlist[i]=powlist[i-1]*2%mod;\n    }\n}\n\nint bitPower(bitset<N> ma,int res){\n    int ret=0;int j=1;\n    for(int i=res;i<=N;i++){\n        if(ma[i])ret+=powlist[j];\n        j++;\n    }\n    return ret;\n}\n\nint main(){\n    bitPowerlist();\n    cin>>n>>x>>p;\n    int pfig,xfig;\n    for(int i=1;i<n;i++){\n        cin>>q;\n        p=gcd(p,q);\n    }\n    pfig=countFigure(p);\n    xfig=countFigure(x);\n    ans=bitPower(x,pfig);\n    cout<<p<<endl;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nvector<int> num[7],x,g,t;\nint N;\nchar s[4005];\nvector<int> gcd(vector<int> a,vector<int> b) {\n\tif(a.size() < b.size()) swap(a,b);\n\tif(b.size() == 1 && b[0] == 0) return a;\n\tvector<int> d(a.size());\n\tint t = a.size() - 1;\n\tfor(int i = b.size() - 1 ; i >= 0 ; --i) {\n\t\td[t] = a[t] ^ b[i];\n\t\t--t;\n\t}\n\tfor(int i = t ; i >= 0 ; --i) d[i] = a[i];\n\twhile(d.size() > 1) {\n\t\tif(d.back() == 0) d.pop_back();\n\t\telse break;\n\t}\n\treturn gcd(b,d);\n}\nvoid Init() {\n\tread(N);\n\tscanf(\"%s\",s + 1);\n\tint len = strlen(s + 1);\n\tfor(int i = len ; i >= 1 ; --i) {\n\t\tx.pb(s[i] - '0');\n\t}\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tscanf(\"%s\",s + 1);\n\t\tlen = strlen(s + 1);\n\t\tfor(int j = len ; j >= 1 ; --j) num[i].pb(s[j] - '0');\n\t}\n\tg = num[1];\n\tfor(int i = 2 ; i <= N ; ++i) g = gcd(g,num[i]);\n}\nvoid Solve() {\n\tt = x;\n\tif(g.size() > x.size()) {out(1);enter;return;}\n\tint l = x.size() - g.size() + 1;\n\tint d = x.size() - 1;\n\tint ans = 0;\n\tfor(int i = 0 ; i < l ; ++i) {\n\t\tans = (1LL * ans * 2 + x[d - i]) % MOD;\n\t}\n\tans = (ans + 1) % MOD;\n\tfor(int i = l ; i < x.size() ; ++i) t[d - i] = 0;\n\tfor(int i = 0 ; i < l ; ++i) {\n\t\tif(t[d - i] == 1) {\n\t\t\tint k = g.size() - 1;\n\t\t\tfor(int j = 0 ; j < g.size() ; ++j) {\n\t\t\t\tt[d - i - j] = t[d - i - j] ^ g[k - j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = l ; i < x.size() ; ++i) {\n\t\tif(t[d - i] != x[d - i]) {\n\t\t\tif(t[d - i] > x[d - i]) ans = (ans + MOD - 1) % MOD;\n\t\t\tbreak;\n\t\t}\n\t}\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tInit();\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\n\n\ntemplate<const std::size_t N>\nstruct bfps: public std::bitset<N> {\n  using size_type = std::size_t;\n  size_type len;\n\n  void recalc() {\n    this->len = 0;\n    for(i64 j = 5000; j --> 0;) {\n      if((*this)[j]) {\n        this->len = j + 1;\n        return;\n      }\n    }\n  }\n\n  bfps() : std::bitset<N>() { this->len = 0; }\n  //bfps(const std::uint_fast64_t x) : std::bitset<N>(x) { recalc(); }\n  bfps(const std::bitset<N>& b) : std::bitset<N>(b) { recalc(); }\n  size_type size() const { return this->len; }\n\n  static std::pair<bfps, bfps> divmod(bfps a, const bfps& b) {\n    assert(b.size() > 0);\n    bfps d;\n    for(i64 i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n        d ^= (bfps(1) << i);\n      }\n    }\n    a.recalc();\n    d.recalc();\n    return std::pair<bfps, bfps>(d, a);\n  }\n\n  static bfps gcd(bfps a, bfps b) {\n    while(b.any()) {\n      auto dm = divmod(a, b);\n      a = b;\n      b = dm.second;\n    }\n    return a;\n  }\n};\n\nusing bits = bfps<5000>;\n\nint main() {\n  i64 N;\n  cin >> N;\n  bits X;\n  cin >> X;\n  X.recalc();\n\n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    bool OK = true;\n    for(i64 i = 5000; i --> 0; ) {\n      if(now[i] != X[i]) {\n        if(now[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    if(OK) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE=4010;\nusing Bit=bitset<SIZE>;\n\nusing ll=long long;\nconst ll MOD=998244353;\n\nll powm(ll x,ll k){\n    ll res=1;\n    while(k){\n        if(k&1) res=res*x%MOD;\n        x=x*x%MOD;\n        k>>=1;\n    }\n    return res;\n}\nint main(){\n    int n;\n    Bit x;\n    cin>>n>>x;\n    vector<Bit> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n    auto baseId=[&](){\n        int id=-1;\n        for(int i=0;i<n;i++){\n            if(a[i]==0) continue;\n            if(id==-1){\n                id=i;\n                continue;\n            }\n            for(int j=SIZE-1;j>=0;j--){\n                if(a[id][j] && !a[i][j]){\n                    id=i;\n                    break;\n                }\n                if(!a[id][j] && a[i][j]) break;\n            }\n        }\n        return id;\n    };\n    auto topBit=[&](int id){\n        for(int i=SIZE-1;i>=0;i--){\n            if(a[id][i]){\n                return i;\n            }\n        }\n        return -1;\n    };\n    for(int i=SIZE-1;i>=0;i--){\n        int bid=baseId();\n        int top=topBit(bid);\n        if(i<top) break;\n        bool delt=false;\n        for(int j=0;j<n;j++){\n            if(j!=bid && a[j][i]){\n                delt=true;\n                a[j]^=(a[bid]<<(i-top));\n            }\n        }\n        if(delt) i++;\n    }\n\n    ll res=0;\n    int bid=baseId();\n    int top=topBit(bid);\n    Bit base=a[bid];    \n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]) res=(res+powm(2,i-top))%MOD;\n    }\n    Bit v;\n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]^v[i]) v^=(base<<(i-top));\n    }\n    for(int i=SIZE-1;i>=0;i--){\n        if(!x[i] && v[i]){\n            break;\n        }\n        if(x[i] && !v[i]){\n            res++;\n            break;\n        }\n        if(i==0) res++;\n    }\n    res%=MOD;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD = 998244353;\n\nint N;\nbitset<4000> X, res, cur;\nvector<bitset<4000>> A;\nll ans = 0, po2[4001];\nint t;\n\nbitset<4000> con() {\n    string z; cin >> z;\n    bitset<4000> b;\n    F0R(i,z.length()) b[z.length()-1-i] = int(z[i]-'0');\n    return b;\n}\n\nint ms(bitset<4000>& b) {\n    F0Rd(i,4000) if (b[i] == 1) return i;\n    return -1;\n}\n\nvoid solve() {\n\twhile (1) {\n\t    int x = ms(X), y = ms(res);\n\t    auto a = res<<(x-y);\n\t}\n}\n\nvoid init() {\n    ios_base::sync_with_stdio(0);cin.tie(0);\n\tF0R(i,A.size()) if (ms(A[i]) >= 0) res = A[i];\n\tpo2[0] = 1;\n\tFOR(i,1,4001) po2[i] = 2*po2[i-1] % MOD;\n\tcin >> N; A.resize(N);\n\tX = con();\n\tF0R(i,N) A[i] = con();\n\t\n\tF0R(i,A.size()) F0R(j,i) {\n\t    while (1) {\n\t        int x = ms(A[j]), y = ms(A[i]);\n\t        if (x < 0 || y < 0) break;\n\t        if (x > y) A[j] ^= (A[i]<<(x-y));\n\t        else A[i] ^= (A[j]<<(y-x));\n\t    }\n\t}\n\t\n\tF0R(i,A.size()) if (ms(A[i]) >= 0) res = A[i];\n}\n\nvoid solve(int ind) {\n    if (ind < 0) {\n        F0Rd(i,4000) if (cur[i] != X[i]) {\n            if (cur[i] < X[i]) ans = (ans+1) % MOD;\n            return;\n        }\n        ans = (ans+1) % MOD;\n        return;\n    }\n    if (cur[ind+t] == 0) { \n        if (X[ind+t] == 0) {\n            solve(ind-1);\n        } else {\n            ans = (ans+po2[ind]) % MOD;\n            cur ^= (res<<ind);\n            solve(ind-1);\n        }\n    } else { \n        if (X[ind+t] == 0) { // 1, 0\n            cur ^= (res<<ind);\n            solve(ind-1);\n        } else { // 1, 1\n            ans = (ans+po2[ind]) % MOD;\n            solve(ind-1);\n        }\n    }\n}\n\nint main() {\n\tinit();\n\tt = ms(res);\n\tsolve(ms(X)-t);\n\tcout << ans;\n}\n\n// read!\n// ll vs. int!"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\n#define N_bit 4000\nusing bin = bitset<N_bit>;\nbin gcd(bin a, bin b){\n    int na = 0, nb = 0;\n    while(true){\n        while(na < N_bit && a[N_bit - 1 - na] == 0) na++;\n        while(nb < N_bit && b[N_bit - 1 - nb] == 0) nb++;\n        if(na > nb){\n            swap(a, b);\n            swap(na, nb);\n        }\n        if(nb == N_bit) return a;\n\n        a ^= b << (nb - na);\n    }\n}\n\nbool compare(bin a, bin b){\n    IREP(i, N_bit){\n        if(a[i] == 0 && b[i] == 1) return true;\n        if(a[i] == 1 && b[i] == 0) return false;\n    }\n    return true;\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    string X; cin >> X;\n    vector<string> A(N); cin >> A;\n\n    bin x(X);\n    vector<bin> a(N);\n    REP(i, N) a[i] = bin(A[i]);\n    bin g = a[0];\n    FOR(i, 1, N){\n        g = gcd(g, a[i]);\n    }\n\n    int nx = 0, ng = 0;\n    while(nx < N_bit && x[N_bit - 1 - nx] == 0) nx++;\n    while(ng < N_bit && g[N_bit - 1 - ng] == 0) ng++;\n\n    nx = N_bit - nx;\n    ng = N_bit - ng;\n    if(nx < ng){\n        Out(1);\n        return 0;\n    }\n\n    mint ans = 0;\n    bin t(0);\n    REP(i, nx - ng + 1){\n        if(x[nx - 1 - i] == 1){\n            if(t[nx - 1 - i] == 0){\n                ans += pow((mint)2, nx - ng - i);\n                t ^= g << (nx - ng - i);\n            }else{\n                ans += pow((mint)2, nx - ng - i);\n            }\n        }else if(x[nx - 1 - i] == 0){\n            if(t[nx - 1 - i] == 1){\n                t ^= g << (nx - ng - i);\n            }\n        }\n    }\n    if(compare(t, x)) ans += 1;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 205;\nconst int   mod = 998244353;\n\nvoid add(int&a,int b)   {   a += b; if (a >= mod)   a -= mod;   }\nvoid sub(int&a,int b)   {   a -= b; if (a <  0)     a += mod;   }\n\nint mul(int a,int b)    {   return  1ll * a * b % mod;  }\nint inv(int a,int p)    {   return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;    }\nint Pow(int a,int b)    {\n    int ans = 1;\n    while  (b)  {\n        if (b & 1)  ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\n\nstring calc(string A,string B)  {\n    while (A.size() && B.size())    {\n        if (A.size() > B.size())\n            A.swap(B);\n        \n        for(int i = 0 ; i < sz(A) ; ++i)    {\n            B[i] ^= A[i];\n            B[i] += '0';\n        }\n        reverse(all(B));    while (sz(B) && B.back() == '0')    B.pop_back();\n        reverse(all(B));\n    }\n    if (A.empty())  return  B;\n    if (B.empty())  return  A;\n\n    assert(0);\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    string lim; cin >> lim;\n    string gcd;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        string S;   cin >> S;\n        if (i == 0) gcd = S;\n        else        gcd = calc(gcd,S);\n    }\n    if (sz(lim) < sz(gcd))  {\n        cout << \"1\\n\";\n        return  0;\n    }\n    string tmp = string(sz(lim),'0');\n    int ans = 0;\n\n    for(int i = 0 ; i <= sz(lim) - sz(gcd) ; ++i)   {\n        if (lim[i] != tmp[i])\n            for(int j = 0 ; j < sz(gcd) ; ++j)  {\n                tmp[i + j] ^= gcd[j];\n                tmp[i + j] += '0';\n            }\n        if (lim[i] == '1')\n            add(ans,Pow(2,sz(lim) - sz(gcd) - i));\n    }    \n    if (tmp <= lim)\n        ans++;\n    \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nint main() {\n    i64 n;\n    const i64 mod = 998244353;\n    std::string str;\n    std::cin >> n >> str;\n    std::bitset<4010> x(str);\n    std::vector<std::bitset<4010>> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> str;\n        a[i] = std::bitset<4010>(str);\n    }\n\n    std::vector<i64> pow2(4010);\n    pow2[0] = 1;\n    for (int i = 1; i < 4010; i++) pow2[i] = pow2[i - 1] * 2 % mod;\n\n    auto gcd(a[0]);\n    for (int i = 1; i < n; i++) {\n        auto curr = a[i];\n        while (1) {\n            int d1 = 4000, d2 = 4000;\n            while (!gcd[d1] && d1 > 0) d1--;\n            while (!curr[d2] && d2 > 0) d2--;\n            if (d2 > d1) {\n                std::swap(d1, d2);\n                std::swap(gcd, curr);\n            }\n            if (!d2 && !curr[d2]) break;\n            if (gcd == curr) break;\n\n            gcd = gcd ^ (curr << (d1 - d2));\n        }\n    }\n\n    i64 d = 4000, ret = 0, dx = 4000;\n    while (!gcd[d]) d--;\n    while (!x[dx]) dx--;\n    auto y = x >> d;\n    for (int i = 0; i < 4000; i++) if (y[i]) ret = (ret + pow2[i]) % mod;\n    auto q = y << d;\n    for (int i = 0; i <= dx - d; i++) {\n        if (q[dx - i]) q ^= gcd << (dx - i - d);\n    }\n    q |= y << d;\n    if (x.to_string() >= q.to_string()) ret++;\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <bitset>\n#include <iostream>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\nconst int N=4000;\nint n,m,len,a[9][N+1],f[N+1][N+1],s[N+1][N+1],ans[N+1];\nbool ex[N+1];\nvoid inc(int d){\n\tref(j,1,s[d][0])ans[j]+=s[d][j];\n\tans[0]=max(ans[0],s[d][0])+1;\n\tref(j,1,ans[0])if(ans[j]>9)ans[j]-=10,ans[j+1]++;\n\tif(!ans[ans[0]])ans[0]--;\n}\nint main(){\n\ts[0][0]=1;s[0][1]=1;\n\tref(i,1,N){\n\t\tref(j,1,s[i-1][0])s[i][j]=s[i-1][j]*2;\n\t\ts[i][0]=s[i-1][0]+1;\n\t\tref(j,1,s[i][0])if(s[i][j]>9)s[i][j]-=10,s[i][j+1]++;\n\t\tif(!s[i][s[i][0]])s[i][0]--;\n\t}\n\tscanf(\"%d\",&n);\n\tref(i,0,n){\n\t\tchar c=getchar();while(c<'0'||c>'1')c=getchar();\n\t\tm=-1;\n\t\twhile(c>='0'&&c<='1')a[i][++m]=c-48,c=getchar();\n\t\tref(j,0,m/2)swap(a[i][j],a[i][m-j]);\n\t\twhile(m>=0&&!a[i][m])m--;\n\t\tif(!i){len=m;continue;}\n\t\twhile(m>=0&&m<=N){\n\t\t\twhile(m>=0&&ex[m]){\n\t\t\t\tref(j,0,m)a[i][j]^=f[m][j];\n\t\t\t\twhile(m>=0&&!a[i][m])m--;\n\t\t\t}\n\t\t\tif(m<0)break;\n\t\t\tref(j,0,m)f[m][j]=a[i][j];ex[m]=1;\n\t\t\tdef(j,m,0)a[i][j+1]=a[i][j];a[i][0]=0;m++;\n\t\t}\n\t}\n\tm=N+1;\n\twhile(m>0&&ex[m-1])m--;\n\tif(m>N){printf(\"0\\n\");return 0;}\n\tdef(i,len,m){\n\t\tif(a[0][i]==1)inc(i-m);\n\t\tif(a[8][i]!=a[0][i])ref(j,0,i)a[8][j]^=f[i][j];\n\t}\n\tbool flag=1;\n\tdef(i,m-1,0)if(a[8][i]>a[0][i]){flag=0;break;}\n\t\telse if(a[8][i]<a[0][i])break;\n\tif(flag)inc(0);ans[0]=max(ans[0],1);\n\tdef(i,ans[0],1)printf(\"%d\",ans[i]);printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef bitset<4010> B;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nll POW[4002];\nvoid init(){\n\tPOW[0] = 1;\n\tfor(int i = 0 ; i < 4001 ; i ++){\n\t\tPOW[i+1] = POW[i]*2;\n\t\tif(POW[i] >= MOD)POW[i] -= MOD;\n\t}\n}\n\nint find_last(B x){\n\tfor(int i = 4009 ; i >= 0 ; i --){\n\t\tif(x[i])return i;\n\t}\n\treturn -1;\n}\n\nB gcd(B x,B y){\n\tif(x.none())return y;\n\tint s = find_last(x);\n\tint t = find_last(y);\n\twhile(y.any()){\n\t\tx ^= y<<(s-t);\n\t\ts = find_last(x);\n\t\tif(s < t){\n\t\t\tswap(x,y);\n\t\t\tswap(s,t);\n\t\t}\n\t}\n\treturn x;\n}\n\nint main(){\n\tinit();\n\tint n;\n\tB x,a[7];\n\tcin >> n;\n\tcin >> x;\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tcin >> a[i];\n\t}\n\t\n\tfor(int i = 1 ; i < n ; i ++){\n\t\ta[0] = gcd(a[0],a[i]);\n\t}\n\t\n\t//cout << a[0].to_string().substr(4000,10) << endl;\n\t\n\tll ret = 0;\n\tint s = find_last(x);\n\tint t = find_last(a[0]);\n\tB y; y.reset();\n\tfor(int i = s ; i >= t ; i --){\n\t\tif(x[i])ret += POW[i-t];\n\t\tif(x[i] != y[i])y ^= a[0] << (i-t);\n\t}\n\t//cout << ret << endl;\n\t//cout << x.to_string().substr(4000,10) << endl;\n\t//cout << y.to_string().substr(4000,10) << endl;\n\tfor(int i = s ; i >= 0 ; i --){\n\t\tif(x[i] == y[i]){\n\t\t\tif(i == 0)ret ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(x[i]){\n\t\t\tret ++;\n\t\t\tbreak;\n\t\t}\n\t\tif(y[i])break;\n\t}\n\tcout << ret%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=4005,mu=998244353;\nint a[N],c[N],tmp[N],ans[N],x[N],lx,mx,n;\nchar s[N],sx[N];\nint deg(int *a){\n\tfor (int i=mx;i>=0;i--) \n\t\tif (a[i]) return i;\n\treturn 0; \n}\nvoid del(int *a,int *b,int t){\n\tfor (int i=mx;i>=t;i--)\n\t\ta[i]^=b[i-t];\n}\nvoid gcd(int *a,int *b,int *c){\n\tint l1=deg(a),l2=deg(b);\n\tif (l1<l2) std::swap(a,b),std::swap(l1,l2);\n\tif (l2==0 && b[0]==0){\n\t\tfor (int i=0;i<mx;i++) c[i]=a[i];\n\t\treturn;\n\t}\n\tfor(int i=l1;i>=l2;i--)\n\t\tif (a[i]) del(a,b,i-l2);\n\tgcd(b,a,c);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",sx);\n\tint lx=strlen(sx);\n\tfor (int i=lx-1,j=0;i>=0;i--,j++) x[i]=sx[j]-'0';\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%s\",s);\n\t\tint t=strlen(s);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor (int i=t-1,j=0;i>=0;i--,j++) a[i]=s[j]-'0';\n\t\tmx=std::max(mx,t);\n\t\tfor (int i=0;i<mx;i++) tmp[i]=ans[i];\n\t\tgcd(a,tmp,ans);\n\t}\n\tint len=deg(ans);\n\tmemset(a,0,sizeof(a));\n\tfor(int i=lx-1;i>=len;i--)\n\t\tif (a[i]!=x[i]) del(a,c,i-len);\n\tint Ans=0;\n\tfor (int i=lx-1;i>=len;i--)\n\t\tAns=(Ans*2ll+x[i])%mu;\n\tfor (int i=len-1;i>=0;i--){\n\t\tif (a[i]<x[i]) break;\n\t\tif (a[i]>x[i]){\n\t\t\tAns--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nusing bits = bitset<4000>;\n\nint main() {\n\n  auto bitlen = [](const bits& a) {\n    for(i64 j = 4000; j --> 0;) {\n      if(a[j]) {\n        return j + 1;\n      }\n    }\n    return 0ll;\n  };\n\n  i64 N;\n  cin >> N;\n  bits X;\n  i64 xs;\n  cin >> X;\n  xs = bitlen(X);\n\n  vector<bits> A(N);\n  vector<i64> S(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    S[i] = bitlen(A[i]);\n  }\n  auto bitmod = [](bits a, i64 as, bits b, i64 bs) {\n    for(i64 i = as - bs + 1; i --> 0;) {\n      if(a[i + bs - 1]) {\n        a ^= (b << i);\n      }\n    }\n    return a;\n  };\n\n  auto bitgcd = [&](bits a, i64 as, bits b, i64 bs) {\n    while(b.any()) {\n      auto m = bitmod(a, as, b, bs);\n      a = b;\n      as = bs;\n      b = m;\n      bs = bitlen(b);\n    }\n    return pair<bits, i64>(a, as);\n  };\n\n  auto g = A[0];\n  auto gs = S[0];\n  for(i64 i = 1; i < N; i++) {\n    auto p = bitgcd(g, gs, A[i], S[i]);\n    g = p.first;\n    gs = p.second;\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(xs - gs + 1 >= 0) {\n    vector<i64> Bs(xs - gs + 1, 1);\n    for(i64 i = 1; i < xs - gs + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = xs - gs + 1; i --> 0;) {\n      if(X[i + gs - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + gs - 1] != X[i + gs - 1]) {\n        now ^= (g << i);\n      }\n    }\n    bool OK = true;\n    for(i64 i = 4000; i --> 0; ) {\n      if(now[i] != X[i]) {\n        if(now[i]) {\n          ans = (ans + 1);\n          OK = false;\n        }\n        break;\n      }\n    }\n    if(OK) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n \ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\n\n\n\ninline long long mod(long long a, long long m) {\n\treturn (a % m + m) % m;\n}\n\nlong long pow(long long a, long long n, long long m) {\n\tif (n == 0) return 1 % m;\n\tlong long t = pow(a, n / 2, m);\n\tt = mod(t * t, m);\n\tif (n & 1) t = mod(t * a, m);\n\treturn t;\n}\n\nlong long inv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn mod(u, m);\n}\n\nstruct ModPolynomial : vector<long long> {\n\tlong long MOD = 2;\n\tModPolynomial() : vector<long long>(1, 0) { }\n\tModPolynomial(long long num) : vector<long long>(1, num) { }\n\tModPolynomial(int size, long long num) : vector<long long>(size, num) { }\n\tModPolynomial(vector<long long> vec) { (*this) = vec; }\n\n\tModPolynomial& normalize() {\n\t\tfor (int i = 0; i < (*this).size(); ++i) (*this)[i] = mod((*this)[i], MOD);\n\t\twhile ((*this).size() > 1 && (*this).back() == 0) (*this).pop_back();\n\t\treturn (*this);\n\t}\n\n\tinline ModPolynomial operator - () {\n\t\tfor (int i = 0; i < (*this).size(); ++i) (*this)[i] = (*this)[i] * (-1);\n\t\treturn (*this).normalize();\n\t}\n\tinline const ModPolynomial& operator += (const ModPolynomial &x);\n\tinline const ModPolynomial& operator -= (const ModPolynomial &x);\n\tinline const ModPolynomial& operator *= (long long x);\n\tinline const ModPolynomial& operator *= (const ModPolynomial &x);\n\tinline const ModPolynomial& operator /= (long long x);\n\tinline const ModPolynomial& operator /= (const ModPolynomial &x);\n\tinline const ModPolynomial& operator %= (long long x);\n\tinline const ModPolynomial& operator %= (const ModPolynomial &x);\n};\n\ninline bool operator > (ModPolynomial x, ModPolynomial y) { return x.size() > y.size(); }\ninline bool operator < (ModPolynomial x, ModPolynomial y) { return y > x; }\ninline bool operator <= (ModPolynomial x, ModPolynomial y) { return !(y < x); }\ninline bool operator >= (ModPolynomial x, ModPolynomial y) { return !(x < y); }\ninline bool operator != (ModPolynomial x, ModPolynomial y) { return x < y || y < x; }\ninline bool operator == (ModPolynomial x, ModPolynomial y) { return !(x < y) && !(y < x); }\n\nostream &operator << (ostream &os, ModPolynomial x) {\n\tfor (int i = (int)x.size() - 1; i >= 0; --i) {\n\t\tif (i != (int)x.size() - 1) os << abs(x[i]); else os << x[i];\n\t\tif (i != 0) {\n\t\t\tos << \"x\"; if (i != 1) os << \"^\" << i; os << \" \";\n\t\t\tif (x[i - 1] < 0) os << \"- \"; else os << \"+ \";\n\t\t}\n\t}\n\treturn os;\n}\n\ninline ModPolynomial operator + (ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\twhile (x.size() > y.size()) y.push_back(0);\n\twhile (y.size() > x.size()) x.push_back(0);\n\tModPolynomial z((int)x.size(), 0);\n\tfor (int i = 0; i < (int)x.size(); ++i) z[i] = x[i] + y[i];\n\treturn z.normalize();\n}\ninline ModPolynomial operator - (ModPolynomial x, ModPolynomial y) {\n\ty = -y;\n\treturn x + y;\n}\ninline ModPolynomial operator * (ModPolynomial x, long long a) {\n\tx.normalize();\n\tModPolynomial z((int)x.size(), 0);\n\tfor (int i = 0; i < (int)x.size(); ++i) z[i] = mod(x[i] * a, x.MOD);\n\treturn z.normalize();\n}\ninline ModPolynomial operator * (ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\tModPolynomial z((int)x.size() + (int)y.size() - 1, 0);\n\tfor (int i = 0; i < (int)x.size(); ++i) for (int j = 0; j < (int)y.size(); ++j) z[i + j] = mod(z[i + j] + x[i] * y[j], z.MOD);\n\treturn z.normalize();\n}\npair<ModPolynomial, long long> divmod(ModPolynomial x, long long a) {\n\tx.normalize();\n\tfor (int i = (int)x.size() - 1; i >= 0; --i) x[i] = mod(x[i] * inv(a, x.MOD), x.MOD);\n\treturn pair<ModPolynomial, long long>(x, 0);\n}\nModPolynomial operator / (ModPolynomial x, long long a) {\n\tx.normalize();\n\treturn divmod(x, a).first;\n}\nlong long operator % (ModPolynomial x, long long a) {\n\tx.normalize();\n\treturn divmod(x, a).second;\n}\npair<ModPolynomial, ModPolynomial> divmod(ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\tif (x.size() < y.size()) return make_pair(0, x);\n\tif (y.size() == 1) return divmod(x, y.back());\n\tModPolynomial q((int)x.size() - (int)y.size() + 1, 0);\n\tfor (int i = (int)x.size() - 1; i >= (int)y.size() - 1; --i) {\n\t\tlong long div = mod(x[i] * inv(y.back(), x.MOD), x.MOD);\n\t\tq[i - (int)y.size() + 1] = div;\n\t\tfor (int j = 0; j < (int)y.size(); ++j) x[i + j - (int)y.size() + 1] = mod(x[i + j - (int)y.size() + 1] - y[j] * div, x.MOD);\n\t}\n\treturn make_pair(q, x.normalize());\n}\nModPolynomial operator / (ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\treturn divmod(x, y).first;\n}\nModPolynomial operator % (ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\treturn divmod(x, y).second;\n}\nModPolynomial pow(ModPolynomial a, long long n) {\n\ta.normalize();\n\tModPolynomial res(1, 1);\n\twhile (n > 0) { if (n & 1) { res = res * a; } a = a * a; n >>= 1; }\n\treturn res;\n}\nModPolynomial pow(ModPolynomial a, long long n, ModPolynomial PMOD) {\n\ta.normalize(); PMOD.normalize();\n\tModPolynomial res(1, 1);\n\twhile (n > 0) { if (n & 1) { res = (res * a) % PMOD; } a = (a * a) % PMOD; n >>= 1; }\n\treturn res;\n}\nModPolynomial gcd(ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\tif (y.size() == 1 && y.back() == 0) return x;\n\telse return gcd(y, x%y);\n}\ninline const ModPolynomial& ModPolynomial::operator += (const ModPolynomial &x) { *this = *this + x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator -= (const ModPolynomial &x) { *this = *this - x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator *= (long long x) { *this = *this * x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator *= (const ModPolynomial &x) { *this = *this * x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator /= (long long x) { *this = *this / x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator /= (const ModPolynomial &x) { *this = *this / x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator %= (long long x) { *this = *this % x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator %= (const ModPolynomial &x) { *this = *this % x; return *this; }\nModPolynomial generateX() { ModPolynomial X(2, 0); X[1] = 1; return X; }\nModPolynomial EX = generateX();\n\n\n\nstruct Fp {\n\tint MOD = 998244353;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator > (Fp x, Fp y) { return x.val > y.val; }\ninline bool operator < (Fp x, Fp y) { return y > x; }\ninline bool operator <= (Fp x, Fp y) { return !(y < x); }\ninline bool operator >= (Fp x, Fp y) { return !(x < y); }\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n\n\n\n\n\nint N;\nModPolynomial X;\nModPolynomial A[10];\n\n\nint main() {\n\twhile (cin >> N) {\n\t\tstring str;\n\t\tcin >> str;\n\t\treverse(str.begin(), str.end());\n\t\tX.resize(str.size(), 0);\n\t\tfor (int i = 0; i < str.size(); ++i) X[i] = (long long)(str[i] - '0');\n\t\t//COUT(X);\n\n\t\tModPolynomial g;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> str;\n\t\t\treverse(str.begin(), str.end());\n\t\t\tA[i].resize(str.size(), 0);\n\t\t\tfor (int j = 0; j < str.size(); ++j) A[i][j] = (long long)(str[j] - '0');\n\t\t\t//COUT(A[i]);\n\t\t}\n\n\t\tg = A[0];\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tg = gcd(g, A[i]);\n\t\t}\n\n\n\t\tFp res = 0;\n\t\tint d = (int)g.size() - 1;\n\n\t\tModPolynomial EEX = pow(EX, d);\n\t\tModPolynomial q = X / EEX;\n\t\tModPolynomial r = X % EEX;\n\n\t\tfor (int i = (int)q.size() - 1; i >= 0; --i) {\n\t\t\tres *= 2;\n\t\t\tif (q[i] == 1) res += 1;\n\t\t}\n\n\t\tModPolynomial DX = (X - X%g);\n\t\t\n\n\t\tbool ok = true;\n\t\tfor (int i = (int)X.size() - 1; i >= 0; --i) {\n\t\t\tif (DX[i] > X[i]) ok = false;\n\t\t}\n\t\tif (ok) res += 1;\n\n\n\t\t/*\n\t\tCOUT(g);\n\t\tCOUT(d);\n\t\tCOUT(X);\n\t\tCOUT(EEX);\n\t\tCOUT(q);\n\t\tCOUT(r);\n\t\tCOUT(DX);\n\t\tCOUT(ok);\n\t\t*/\n\n\t\tcout << res << endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int N, lb, a, z;\nbitset<4444> A[7], X, Y, Z;\nchar s[4444];\n\ntemplate <size_t N>\nlong long to_modllong(bitset<N> n){\n    long long ret = 0;\n    for(int i = N; --i >= 0;ret += n[i]){\n        ret <<= 1;\n        ret %= 998244353;\n    }\n    return ret;\n}\n\ntemplate <typename T>\nstatic inline T gcd(T u, T v){\n    int sftu = 0, sftv = 0;\n    T t;\n    if(u.none()) return v;\n    if(v.none()) return u;\n    while(!u[0]){\n        ++sftu;\n        u >>= 1;\n    }\n    while(!v[0]){\n        ++sftv;\n        v >>= 1;\n    }\n    sftu = min(sftu, sftv);\n    do{\n        while(!v[0])v >>= 1;\n        swap(u, v);\n        v = v ^ u;\n    }while(v.any());\n    return u << sftu;\n}\n\nint main(){\n    scanf(\"%lld %s\", &N, s);\n    X = bitset<4444>(s);\n    Z = X;\n    for(int i = 0; i < N; ++i){\n        scanf(\" %s\", s);\n        A[i] = bitset<4444>(s);\n    }\n    Y = A[0];\n    for(int i = 1; i < N; ++i)Y = gcd(A[i], Y);\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (lb = i))break;\n    for(int i = 4443 - lb; i >= 0; --i){\n        if(X[i + lb]){\n            X ^= Y << i;\n            A[6] ^= Y << i;\n        }\n    }\n    //if(lb < 64){\n    //    a = (A[6] & ~(Z & A[6])).to_ullong();\n    //    z = (Z & ~(Z & A[6])).to_ullong();\n    //    cout << (to_modllong(Z >> lb) + (a <= z)) % 998244353 << endl;\n    //}else{\n        long long d;\n        Y = A[6] ^ Z;\n        //cout << A[6] << endl << Z << endl;\n        for(int i = 4443; i >= 0; --i)if(Y[i] && (d = i))break;\n        cout << (to_modllong(Z >> lb) + (!d || Z[d])) % 998244353 << endl;\n\n    //}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=4005,mu=998244353;\nint a[N],c[N],tmp[N],ans[N],x[N],lx,mx,n;\nchar s[N],sx[N];\nint deg(int *a){\n\tfor (int i=mx;i>=0;i--) \n\t\tif (a[i]) return i;\n\treturn 0; \n}\nvoid del(int *a,int *b,int t){\n\tfor (int i=mx;i>=t;i--)\n\t\ta[i]^=b[i-t];\n}\nvoid gcd(int *a,int *b,int *c){\n\tint l1=deg(a),l2=deg(b);\n\tif (l1<l2) std::swap(a,b),std::swap(l1,l2);\n\tif (l2==0 && b[0]==0){\n\t\tfor (int i=0;i<mx;i++) c[i]=a[i];\n\t\treturn;\n\t}\n\tfor(int i=l1;i>=l2;i--)\n\t\tif (a[i]) del(a,b,i-l2);\n\tgcd(b,a,c);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",sx);\n\tint lx=strlen(sx);\n\tfor (int i=lx-1,j=0;i>=0;i--,j++) x[i]=sx[j]-'0';\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%s\",s);\n\t\tint t=strlen(s);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor (int i=t-1,j=0;i>=0;i--,j++) a[i]=s[j]-'0';\n\t\tmx=std::max(mx,t);\n\t\tfor (int i=0;i<mx;i++) tmp[i]=ans[i];\n\t\tgcd(a,tmp,ans);\n\t}\n\tint len=deg(ans);\n\tmemset(a,0,sizeof(a));\n\tmx=std::max(mx,lx); \n\tfor(int i=lx-1;i>=len;i--)\n\t\tif (a[i]!=x[i]) del(a,ans,i-len);\n\tint Ans=0;\n\tfor (int i=lx-1;i>=len;i--)\n\t\tAns=(Ans*2ll+x[i])%mu;\n\tfor (int i=len-1;i>=0;i--){\n\t\tif (a[i]<x[i]) break;\n\t\tif (a[i]>x[i]){\n\t\t\tAns--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(Ans+1)%mu);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt operator+(const modInt &n){return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n){return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n){return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n){return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n){return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n){return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n){return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n){return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\n\n\nint solve(bitset<4000> x,int n,\n\t\t\t\t\t bitset<4000> a,int m){\n\trrep(i,4000){\n\t\tif(a[i] && !x[i]) return 1;\n\t\tif(!a[i] && x[i]) break;\n\t}\n\tif(n<m) return 1;\n\t//rrep(j,20)cout<<x[j];cout<<endl;\n\tll re=0;\n\tbitset<4000> sum; sum.reset();\n\trreps(i,m,n){\n\t\t(re*=2)%=MOD;\n\t\tif(x[i]) (re+=1)%=MOD;\n\t\tif(x[i]!=sum[i]) sum^=a<<(i-m+1);\n\t}\n\t(re*=2)%=MOD;\n\trep(_,2){\n\t\tint ok=1;\n\t\t// rrep(j,20)cout<<sum[j];cout<<endl;\n\t\t// rrep(j,20)cout<<x[j];cout<<endl;\n\t\trrep(i,4000){\n\t\t\tif(i>=m) assert(x[i]==sum[i]);\n\t\t\tif(sum[i] && !x[i]){ ok=0; break;}\n\t\t\tif(!sum[i] && x[i]){ break;}\n\t\t}\n\t\t// out(ok,1);\n\t\tif(ok) (re+=1)%=MOD;\n\t\tsum^=a;\n\t}\n\t//out(re,ret,1);\n\treturn re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n\tstring x;\n\tcin>>n>>x;\n\tvector<pair<bitset<4000>,int>> as(n);\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tas[i].Y=s.size();\n\t\tas[i].X.reset();\n\t\trep(j,s.size()) as[i].X[j]=(s[s.size()-1-j]-'0');\n\t}\n\t// rep(i,as.size()){rrep(j,20)cout<<as[i].X[j];cout<<endl;}cout<<endl;\n\twhile(as.size()>1){\n\t\tsort(rall(as),[&](auto &l,auto &r){\n\t\t\t\treturn l.Y<r.Y;\n\t\t\t});\n\t\twhile(1){\n\t\t\tint upd=0;\n\t\t\trep(i,as.size())rep(j,i)if(as[i]==as[j]){\n\t\t\t\tas.erase(as.begin()+j);\n\t\t\t\tupd=1;\n\t\t\t}\n\t\t\trep(i,as.size())if(as[i].Y==0){\n\t\t\t\tas.erase(as.begin()+i);\n\t\t\t\tupd=1;\n\t\t\t}\n\t\t\tif(!upd) break;\n\t\t}\n\t\twhile(as.size() && as.back().Y==0) as.pop_back();\n\t\tif(as.size()<=1) break;\n\t\tas[0].X^=as[1].X<<(as[0].Y-as[1].Y);\n\t\tas[0].Y=0;\n\t\trep(i,4000){\n\t\t\tif(as[0].X[i]) as[0].Y=i+1;\n\t\t}\n\t}\n\t// rep(i,as.size()){rrep(j,20)cout<<as[i].X[j];cout<<\",\"<<as[i].Y<<endl;}cout<<endl;\n\n\tbitset<4000> st; st.reset();\n\trep(j,x.size()) st[j]=(x[x.size()-1-j]-'0');\n\tcout<<solve(st,x.size(),as[0].X,as[0].Y)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nconstexpr int L = 4000;\nusing B = std::bitset<L>;\nbool operator>(const B& b1, const B& b2)\n{\n    for (int i = L - 1; i >= 0; i--) {\n        if (b1[i] != b2[i]) { return b1[i] > b2[i]; }\n    }\n    return false;\n}\nbool operator<=(const B& b1, const B& b2) { return not(b1 > b2); }\nint main()\n{\n    constexpr uint MOD = 998244353;\n    using mint = ModInt<MOD>;\n    const int N = read<int>();\n    B X(read<std::string>());\n    auto gcd = [&](auto&& self, const B& a, B b) -> B {\n        if (a.count() == 0) { return b; }\n        if (a > b) { return self(self, b, a); }\n        int d = L - 1;\n        for (; d >= 0 and a[d] == 0; d--) {}\n        for (int i = L - 1; i >= d; i--) {\n            if (b[i] == 0) { continue; }\n            const int sft = i - d;\n            b ^= (a << sft);\n        }\n        return self(self, b, a);\n    };\n    B g;\n    for (int i = 0; i < N; i++) { g = gcd(gcd, g, B(read<std::string>())); }\n    int d = L - 1;\n    for (; d >= 0 and g[d] == 0; d--) {}\n    B x = X, y;\n    for (int l = L - 1; l >= d; l--) {\n        if (x[l] == 0) { continue; }\n        const int sft = l - d;\n        x ^= (g << sft), y ^= (g << sft);\n    }\n    mint ans = (y <= X) ? 1 : 0, base = 1;\n    for (int i = d; i < L; i++) { ans += base * X[i], base *= 2; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nbitset<4000> X,P;\nll mo=998244353;\nll p2[202020];\nint ng;\n\nbitset<4000> gcd(bitset<4000> A,bitset<4000> B) {\n\tint i;\n\tfor(i=3999;i>=0;i--) {\n\t\tif(A[i]==1 && B[i]==1) {\n\t\t\tB^=A;\n\t\t\tbreak;\n\t\t}\n\t\tif(A[i]==1) break;\n\t\tif(B[i]==1) {\n\t\t\tswap(A,B);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// A>B\n\twhile(1) {\n\t\tint x;\n\t\tfor(x=i-1;x>=0;x--) if(B[x]) break;\n\t\tif(x<0) break;\n\t\twhile(i>=x) {\n\t\t\tif(A[i]) A^=B<<(i-x);\n\t\t\ti--;\n\t\t}\n\t\ti=x;\n\t\tswap(A,B);\n\t}\n\treturn A;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tp2[0]=1;\n\tFOR(i,101010) p2[i+1]=p2[i]*2%mo;\n\t\n\tcin>>N>>S;\n\tFOR(i,S.size()) if(S[i]=='1') X[S.size()-1-i]=1;\n\tFOR(j,N) {\n\t\tcin>>S;\n\t\tbitset<4000> B;\n\t\tFOR(i,S.size()) if(S[i]=='1') B[S.size()-1-i]=1;\n\t\tif(j==0) P=B;\n\t\telse P=gcd(P,B);\n\t}\n\t\n\tll ret=0;\n\tFOR(i,4000) if(P[i]) x=i;\n\tbitset<4000> Y;\n\tfor(i=3999;i>=x;i--) {\n\t\tif(X[i]) ret+=p2[i-x];\n\t\tif(X[i]^Y[i]) Y^=P<<(i-x);\n\t}\n\t\n\t/*\n\tFOR(i,6) cout<<X[i];\n\tcout<<\" \";\n\tFOR(i,6) cout<<Y[i];\n\tcout<<endl;\n\t*/\n\tret++;\n\tfor(i=x-1;i>=0;i--) {\n\t\tif(Y[i]<X[i]) {\n\t\t\tbreak;\n\t\t}\n\t\tif(Y[i]>X[i]) {\n\t\t\tret--;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef bitset<4010> B;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nll POW[4002];\nvoid init(){\n\tPOW[0] = 1;\n\tfor(int i = 0 ; i < 4001 ; i ++){\n\t\tPOW[i+1] = POW[i]*2;\n\t\tif(POW[i] >= MOD)POW[i] -= MOD;\n\t}\n}\n\nint find_last(B x){\n\tfor(int i = 4009 ; i >= 0 ; i --){\n\t\tif(x[i])return i;\n\t}\n\treturn -1;\n}\n\nB gcd(B x,B y){\n\tif(x.none())return y;\n\tint s = find_last(x);\n\tint t = find_last(y);\n\tif(s < t){\n\t\tswap(x,y);\n\t\tswap(s,t);\n\t}\n\twhile(y.any()){\n\t\tx ^= y<<(s-t);\n\t\ts = find_last(x);\n\t\tif(s < t){\n\t\t\tswap(x,y);\n\t\t\tswap(s,t);\n\t\t}\n\t}\n\treturn x;\n}\n\nint main(){\n\tinit();\n\tint n;\n\tB x,a[7];\n\tcin >> n;\n\tcin >> x;\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tcin >> a[i];\n\t}\n\t\n\tfor(int i = 1 ; i < n ; i ++){\n\t\ta[0] = gcd(a[0],a[i]);\n\t}\n\t\n\t//cout << a[0].to_string().substr(4000,10) << endl;\n\t\n\tll ret = 0;\n\tint s = find_last(x);\n\tint t = find_last(a[0]);\n\tB y; y.reset();\n\tfor(int i = s ; i >= t ; i --){\n\t\tif(x[i])ret += POW[i-t];\n\t\tif(x[i] != y[i])y ^= a[0] << (i-t);\n\t}\n\t//cout << ret << endl;\n\t//cout << x.to_string().substr(4000,10) << endl;\n\t//cout << y.to_string().substr(4000,10) << endl;\n\tfor(int i = s ; i >= 0 ; i --){\n\t\tif(x[i] == y[i]){\n\t\t\tif(i == 0)ret ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(x[i]){\n\t\t\tret ++;\n\t\t\tbreak;\n\t\t}\n\t\tif(y[i])break;\n\t}\n\tcout << ret%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    constexpr uint MOD = 998244353;\n    using mint = ModInt<MOD>;\n    constexpr int L = 4000;\n    const int N = read<int>();\n    using B = std::bitset<L>;\n    B X(read<std::string>());\n    auto gcd = [&](auto&& self, B a, B b) {\n        if (a.count() == 0) { return b; }\n        if (a.to_string() > b.to_string()) { return self(self, b, a); }\n        int d = L - 1;\n        for (; d >= 0 and b[d] == 0; d--) {}\n        int dd = L - 1;\n        for (; dd >= 0 and a[dd] == 0; dd--) {}\n        for (; d >= dd; d--) {\n            if (b[d] == 0) { continue; }\n            const int sft = d - dd;\n            b ^= (a << sft);\n        }\n        return self(self, b, a);\n    };\n    B g;\n    for (int i = 0; i < N; i++) { g = gcd(gcd, g, B(read<std::string>())); }\n    int d = L - 1;\n    auto x = X;\n    for (; d >= 0 and g[d] == 0; d--) {}\n    for (int l = L - 1; l >= d; l--) {\n        if (x[l] == 0) { continue; }\n        const int sft = l - d;\n        x ^= (g << sft);\n    }\n    B mask;\n    for (int i = 0; i < d; i++) { mask[i] = 1; }\n    mint ans = (x.to_string() >= (X & mask).to_string()) ? 1 : 0, base = 1;\n    X >>= d;\n    for (int i = 0; i < L; i++) { ans += base * X[i], base *= 2; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <tuple>\n#include <list>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define FOR(x,xs) for(auto &x: xs)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef pair<ll,ll> PL;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\nusing VB = vector<bool>;\n\nconst ll mod = 998244353L;\n\nvoid write(const VB &x) {\n  for(bool b: x) {\n    cout << b;\n  }\n  cout << endl;\n}\n\nvoid addAssign(VB &x, const VB &y, int offset) {\n  int n = x.size();\n  REP(i,offset,n) {\n    x[i] = x[i] != y[i - offset];\n  }\n  while(!x.empty()) {\n    if(x.back()) break;\n    x.pop_back();\n  }\n}\n\nvoid gcd(VB &x, VB &y) {\n  if(x.size() < y.size()) {\n    x.swap(y);\n  }\n  while(y.size() > 0) {\n    addAssign(x, y, x.size() - y.size());\n    if(x.size() < y.size()) {\n      x.swap(y);\n    }\n  }\n}\n\nll solve(const VB &x, const VB &g) {\n  int xl = x.size();\n  int gl = g.size();\n  if(xl < gl) {\n    return 1;\n  }\n  ll ans = 0;\n  for(int i=xl-1; i>=gl-1; i--) {\n    ans = (ans * 2) % mod;\n    if(x[i]) {\n      ans = (ans + 1) % mod;\n    }\n  }\n  VB y(xl);\n  copy(g.begin(), g.end(), y.begin() + (xl - gl));\n  for(int i=xl-1; i>=gl-1; i--) {\n    if(x[i] != y[i]) {\n      addAssign(y, g, i - gl + 1);\n    }\n  }\n  ans++;\n  for(int i=gl-1; i>=0; i--) {\n    if(x[i] < y[i]) {\n      ans--;\n      break;\n    }\n    if(x[i] > y[i]) {\n      break;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N;\n  cin >> N;\n  string str;\n  cin >> str;\n  VB x;\n  transform(str.rbegin(), str.rend(), back_inserter(x), [](char c){return c == '1';});\n  vector<VB> as(N);\n  FOR(a,as) {\n    cin >> str;\n    transform(str.rbegin(), str.rend(), back_inserter(a), [](char c){return c == '1';});\n  }\n  VB g;\n  FOR(a,as) {\n    gcd(g, a);\n  }\n  cout << solve(x, g) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint N;\nstring X, G;\nvector<string> A;\n\nstring gcd(string a, string b) {\n    if(a.size() < b.size()) return gcd(b, a);\n    if(b.size() == 0) return a;\n\n    string ret;\n    bool t = false;\n    for(int i = 0; i < b.size(); i++) {\n        char c = a[i] == b[i]? '0' : '1';\n        if(c == '1') t = true;\n        if(t) ret.push_back(c);\n    }\n    for(int i = b.size(); i < a.size(); i++) {\n        if(a[i] == '1') t = true;\n        if(t) ret.push_back(a[i]);\n    }\n    return gcd(ret, b);\n}\n\nbool cmp(string a, string b) {\n    if(a.size() != b.size()) return a.size() < b.size();\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] != b[i]) return a[i] < b[i];\n    }\n    return false;\n}\n\nint str_to_int(string s) {\n    if(s.size() == 0) return 0;\n    int ret = 0;\n    for(int i = 0; i < s.size(); i++) {\n        ret = ret * 2 % mod;\n        if(s[i] == '1') ret = (ret + 1) % mod;\n    }\n    return ret;\n}\n\nstring C;\n\nint dfs(int idx) {\n    if(idx == G.size() + 1) return cmp(C, X) || C == X;\n    if(C[idx] != X[idx]) {\n        for(int i = idx; i < idx + G.size(); i++) {\n            C[i] = C[i] == G[i - idx]? '0' : '1';\n        }\n    }\n    return dfs(idx + 1);\n}\n\nint ans;\n\nint main() {\n    cin >> N >> X;\n\n    A.resize(N);\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n\n    G = \"\";\n    for(int i = 0; i < N; i++) {\n        G = gcd(A[i], G);\n    }\n\n    if(cmp(X, G)) {\n        cout << 1;\n        return 0;\n    }\n\n    ans = str_to_int(X.substr(0, X.size() - G.size() + 1));\n\n    for(int i = 0; i < X.size(); i++) C.push_back('0');\n    ans += dfs(0);\n    ans %= mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ayy\n// ' lamo\n// SUBLIME HAX\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\n// const int P=1e9+7;\n\n\n\n\nconst int N=8192;\n// const int N=12;\nint n;\ntypedef bitset<N> BS;\nBS X,A[6],Y,Q;\nvoid read(BS &bs) {\n\tstring s; cin>>s;\n\treverse(s.begin(),s.end());\n\tfor(int i=0;i<sz(s);i++) bs[i]=int(s[i]=='1');\n}\nbool operator<(const BS &L,const BS &R) {\n\tfor(int i=N;--i>=0;) if(L[i]!=R[i]) return L[i]<R[i];\n\treturn 0;\n}\nint len(const BS &bs) {\n\tfor(int i=N;--i>=0;) if(bs[i]) return i+1;\n\treturn 0;\n}\n\nint h[6];\nvoid rref() {\n\tfor(int i=0;i<n;i++) h[i]=len(A[i])-1;\n\tQ=A[min_element(h,h+n)-h];\n\tint w=len(Q)-1;\n\tfor(;;) {\n\t\tfor(int i=0;i<n;i++) {\n\t\t\t// dbg(w,i,h[i]);\n\t\t\tassert(w <= h[i]);\n\t\t\tif(A[i] != Q<<(h[i]-w)) {\n\t\t\t\tA[i] ^= Q<<(h[i]-w);\n\t\t\t\th[i]=len(A[i])-1;\n\t\t\t\tif(h[i]<w) w=h[i], Q=A[i];\n\t\t\t\tgoto win;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\twin:;\n\t}\n}\n\n\n\nconst int P=998244353;\nint powq(int x,int e) {\n\tif(!e) return 1;\n\tif(e&1) return int(1LL*x*powq(x,e-1)%P);\n\tx=powq(x,e>>1);\n\treturn int(1LL*x*x%P);\n}\n\n\nint32_t main() {\n\tcin>>n;\n\tread(X);\n\tfor(int i=0;i<n;i++) read(A[i]);\n\trref();\n\t// dbg(Q);\n\n\tint w=len(Q); assert(w>0);\n\tint m=len(X); assert(m>0);\n\tY.reset();\n\tif(w>m) return cout<<1<<endl,0;\n\tll Z=0;\n\tfor(int i=m-1;i>=w-1;i--) {\n\t\t// dbg(i,X,Y,i-(w-1));\n\t\tif(X[i]) Z+=powq(2,i-(w-1));\n\t\tif(X[i] != Y[i]) Y^=Q<<(i-(w-1));\n\t}\n\t++Z;\n\tcout<<Z%P<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nstring gcd(string s,string t){\n\twhile(s.back()=='0')s.pop_back();\n\twhile(t.back()=='0')t.pop_back();\n\tif(s==t) return s;\n\t\n\tif(s.length()<t.length()){\n\t\treturn gcd(t,s);\n\t}\n\tif(s.length()==t.length()){\n\t\tint l=t.length();\n\t\tfor(int i=0;i<l;i++)if(s[i]=='1'){\n\t\t\tif(t[i]=='1')t[i]='0';\n\t\t\telse t[i]='1';\n\t\t}\n\t\treturn gcd(s,t);\n\t}\n\t{\n\t\tint ls=s.length();\n\t\tint lt=t.length();\n\t\t\n\t\tfor(int i=0;i<lt;i++)if(t[i]=='1'){\n\t\t\tif(s[i+ls-lt]=='1')s[i+ls-lt]--;\n\t\t\telse s[i+ls-lt]++;\n\t\t}\n\t\t\n\t\tbool bo=0;\n\t\tfor(auto c:s)if(c=='1')bo=1;\n\t\tif(!bo) return t;\n\t\treturn gcd(s,t);\n\t\n\t}\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n;\n \tstring x;\n \tcin>>n>>x;\n \treverse(x.begin(),x.end());\n \tstring s;\n \tcin>>s;\n \treverse(s.begin(),s.end());\n \tfor(int i=1;i<n;i++){\n \t\tstring ss;\n \t\tcin>>ss;\n \t\t\n \treverse(ss.begin(),ss.end());\n \t\ts=gcd(s,ss);\n \t\tcout<<i<<\" \"<<s<<endl;\n \t}\n //\tcout<<s<<endl;\n \tmod=998244353;\n \tint ans=0;\n \t\n \tint l=x.length();\n \t\n \tint r=s.length();\n \t\n \tif(l<r){\n \t\tcout<<1<<endl;\n \t\treturn 0;\n \t}\n \t\n\n \t\n \tstring ima=\"\";\n \tfor(int i=0;i<l-r;i++)ima+=\"0\";\n \tima+=s;\n //\tcout<<ans<<endl;\n \tfor(int i=l-1;i>r-2;i--){\n \t\tif(ima[i]=='0' && x[i]=='0'){\n \t\t\tgoto lll;\n \t\t}\n \t\telse if(ima[i]=='0' &&x[i]=='1'){\n \t\t\tans+=beki(2,i-(r-1),mod);\n \t\t\tans%=mod;\n \t\t}\n \t\telse if(ima[i]=='1' &&x[i]=='0'){\n \t\t\t\n \t\t}\n \t\telse{\n \t\t\tans+=beki(2,i-(r-1),mod);\n \t\t\tans%=mod;\n \t\t\tgoto lll;\n \t\t}\n \t\t\n \t\tfor(int j=0;j<r;j++){\n \t\t\tif(s[j]=='1'){\n \t\t\t\tif(ima[i-r+1+j]=='1')ima[i-r+1+j]--;\n \t\t\t\telse ima[i-r+1+j]++;\n \t\t\t}\n \t\t}\n \t\tlll:;\n \t//\tcout<<ans<<\" \"<<ima<<\" \"<<i-r+1<<endl;\n \t}\n \t\n \tbool b=0;\n \tfor(int i=l-1;i>=0;i--){\n \t\tif(x[i]>ima[i]){\n \t\t\tb=1;\n \t\t\tbreak;\n \t\t}\n \t\telse if(x[i]<ima[i]){\n \t\t\tgoto ll2;\n \t\t}\n \t}\n \t\n \tans++;\n \tll2:;\n \t/*\n \tb=0;\n \t\n \tfor(int i=0;i<r;i++){\n \t\tif(s[i]=='1'){\n \t\t\tif(ima[i]=='0')ima[i]++;\n \t\t\telse ima[i]--;\n \t\t}\n \t}\n \t \tfor(int i=l-1;i>=0;i--){\n \t\tif(x[i]>ima[i]){\n \t\t\tb=1;\n \t\t\tbreak;\n \t\t}\n \t\telse if(x[i]<ima[i]){\n \t\t\tbreak;\n \t\t}\n \t}\n \t\n \tif(b)ans++;\n \t*/\n \tcout<<ans%mod<<endl;\n \t\n \t\n  \treturn 0;\n  }\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mo=998244353;\nbitset <4050> a,b,c; int n,m,ans,h[4050],p,fl;\nint main(){\n\tcin>>n; cin>>a;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (cin>>c;c.any();swap(b,c)){\n\t\t\tfor (p=4000;;--p) if (c[p]) break;\n\t//\t\tfor (int j=0;j<=p;++j) printf(\"%d\",(int)c[j]); puts(\"\");\n\t//\t\tputs(\"\");\n\t\t\tfor (int j=4000;j>=p;--j)\n\t\t\tif (b[j]) b^=c<<j-p;\n\t\t}\n\tfor (p=4000;;--p) if (b[p]) break;\n//\tfor (int i=0;i<=p;++i) printf(\"%d\",(int)b[i]); puts(\"\");\n\tc=a; h[0]=fl=1;\n\tfor (int i=1;i<=4000;++i) h[i]=h[i-1]*2%mo;\n\tfor (int i=p;i<4001;++i)\n\tif (a[i]) (ans+=h[i-p])%=mo;\n\tfor (int i=4000;i>=p;--i)\n\tif (a[i]) a^=b<<i-p;\n\t\n//\tputs(\"hh\");\n//\tfor (int i=0;i<=p;++i) printf(\"%d\",(int)c[i]); puts(\"\");\n//\tfor (int i=0;i<=p;++i) printf(\"%d\",(int)a[i]); puts(\"\");\n\tfor (int i=p;~i;--i)\n\tif (a[i]&&!c[i]) {fl=0; break;}\n\tprintf(\"%d\\n\",(ans+1)%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdint>\n#include <cassert>\n\n\n#include <iostream>\n#include <bitset>\n\ntemplate<const std::size_t N>\nstruct binfps {\n  using size_type = std::size_t;\n  using bit_type = std::uint_fast64_t;\n\n  const static size_type lg = 6;\n  const static size_type lgmask = (1ull << lg) - 1;\n  const static size_type _w_len = (N + (1ull << lg) - 1) >> lg;\n  std::array<bit_type, _w_len> w;\n  size_type len;\n\n  binfps(): len(0) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n  }\n\n  binfps(const std::bitset<N>& b) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n    for(size_type i = 0; i < N; i++) {\n      if(b[i]) set(i);\n    }\n    recalc();\n  }\n\n  size_type size() const { return this->len; }\n  void recalc() {\n    len = 0;\n    for(size_type i = w.size(); i --> 0; ) {\n      if(w[i]) {\n        for(size_type j = (1 << lg); j --> 0;) {\n          if(w[i] >> j) {\n            len = j + 1 + (i << lg);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  void set(size_type i) { w[i >> lg] |= (1ull << (i & lgmask)); }\n  void unset(size_type i) { w[i >> lg] &= ~(1ull << (i & lgmask)); }\n\n  bool any() const {\n    for(size_type i = 0; i < _w_len; i++) {\n      if(w[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool operator[](size_type i) const {\n    return !!(w[i >> lg] & (1ull << (i & lgmask)));\n  }\n\n  binfps& operator^=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] ^= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator&=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator|=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n\n\n  binfps& operator<<=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    size_type off = x >> lg;\n    size_type m = x & lgmask;\n    size_type dwmask = ((size_type)(1) << (64 - m)) - 1;\n    if(m == 0) {\n      dwmask = ~(size_type)(0);\n    }\n    size_type upmask = ~dwmask;\n    // up\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i + off + 1] |= (w[i] & upmask) >> m;\n    }\n    // down\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i + off] |= (w[i] & dwmask) << m;\n    }\n\n    w = std::move(next);\n    len = std::min(N, len + x);\n    return (*this);\n  }\n\n  binfps& operator>>=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    size_type off = x >> lg;\n    size_type m = x & lgmask;\n    size_type dwmask = (1ull << m) - 1;\n    if(m == 0) {\n      dwmask = 0;\n    }\n    size_type upmask = ~dwmask;\n    // down\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i] |= (w[i + off + 1] & dwmask) << (64 - m);\n    }\n    // up\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i] |= (w[i + off] & upmask) >> m;\n    }\n    w = std::move(next);\n    if(len < x) {\n      len = 0;\n    }\n    else {\n      len = len - x;\n    }\n    return (*this);\n  }\n\n  binfps operator^(const binfps& b) const { return binfps(*this) ^= b; }\n  binfps operator&(const binfps& b) const { return binfps(*this) &= b; }\n  binfps operator|(const binfps& b) const { return binfps(*this) |= b; }\n  binfps operator<<(const size_type x) const { return binfps(*this) <<= x; }\n  binfps operator>>(const size_type x) const { return binfps(*this) >>= x; }\n  binfps operator~() {\n    binfps a = *this;\n    for(size_type i = w.size(); i --> 0;) {\n      a.w[i] = ~w[i];\n    }\n    return a;\n  }\n\n  bool operator<(const binfps& b) const {\n    bool OK = false;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] < b.w[i]) {\n          OK = true;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n  bool operator<=(const binfps& b) const {\n    bool OK = true;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] > b.w[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n\n  static binfps mod(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    for(int i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static binfps div(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    binfps d;\n    for(int i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        binfps e;\n        e.set(i);\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static binfps gcd(binfps a, binfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = std::move(b);\n      b = std::move(m);\n    }\n    return a;\n  }\n\n  void dump() const {\n    for(size_type i = _w_len; i --> 0; ) {\n      std::cerr << std::bitset<64>(w[i]) << \"|\" << std::endl;\n    }\n    std::cerr << std::endl;\n  }\n};\n\n\nconst int BN = 5000;\nusing bits = binfps<BN>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n \nint main() {\n  i64 N;\n  cin >> N;\n  std::bitset<BN> binp;\n  cin >> binp;\n  bits X(binp);\n  X.recalc();\n \n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> binp;\n    A[i] = bits(binp);\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    if(now <= X) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\nconst int m = 4010;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel rui(m + 10, 1);\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nint max_true(bs &a,int jou) {\n\tint ans = jou;\n\trep(i, jou) {\n\t\tif (a[i]) { ans = i; }\n\t}\n\treturn ans;\n}\nbool can_div(bs &a, bs b, int &sza, int szb) {\n\tfor (int i = sza; i >= szb; i--) {\n\t\tif (a[i]) {\n\t\t\ta ^= b << (i - szb);\n\t\t}\n\t}\n\tsza = max_true(a, szb);\n\tif (sza == szb) { return true; }\n\treturn false;\n}\nbs gcd(bs a, bs b) {\n\tint sza = max_true(a,m);\n\tint szb = max_true(b,m);\n\tif (sza < szb) { swap(sza, szb); swap(a, b); }\n\twhile (true) {\n\t\tif (can_div(a, b, sza, szb)) { return b; }\n\t\tif (can_div(b, a, szb, sza)) { return a; }\n\t}\n}\nvoid solve(bs &x, bs &a) {\n\tint szx = max_true(x,m);\n\tint sza = max_true(a,m);\n\tbs to;\n\tint ans = 0;\n\tfor (int i = szx; i >= sza; i--) {\n\t\tif (x[i]) {\n\t\t\tans += rui[i - sza];\n\t\t}\n\t\tif (x[i] != to[i]) {\n\t\t\tto ^= a << (i - sza);\n\t\t}\n\t}\n\tcout << (ans + 1)%p << endl;\n}\nbs mak(string s) {\n\trev(s);\n\tbs ans;\n\trep(i, s.size()) {\n\t\tans[i] = (s[i] == '1');\n\t}\n\treturn ans;\n}\nsigned main() {\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tstring x; cin >> x;\n\t\tstring s; cin >> s;\n\t\tbs gcd0 = mak(s);\n\t\trep(i, n - 1) {\n\t\t\tstring ne; cin >> ne;\n\t\t\tbs newb = mak(ne);\n\t\t\tgcd0 = gcd(newb, gcd0);\n\t\t}\n\t\tbs nw = mak(x);\n\t\trep(i, m + 9) { rui[i + 1] = rui[i] * 2; rui[i + 1] %= p; }\n\t\tsolve(nw, gcd0);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int N, lb, a, z;\nbitset<4444> A[7], X, Y, Z;\nchar s[4444];\n\ntemplate <size_t N>\nlong long to_modllong(bitset<N> n){\n    long long ret = 0;\n    for(int i = N; --i >= 0;ret += n[i]){\n        ret <<= 1;\n        ret %= 998244353;\n    }\n    return ret;\n}\n\ntemplate <typename T>\nstatic inline T gcd(T u, T v){\n    int sftu = 0, sftv = 0;\n    T t;\n    if(u.none()) return v;\n    if(v.none()) return u;\n    while(!u[0]){\n        ++sftu;\n        u >>= 1;\n    }\n    while(!v[0]){\n        ++sftv;\n        v >>= 1;\n    }\n    sftu = min(sftu, sftv);\n    do{\n        while(!v[0])v >>= 1;\n        swap(u, v);\n        v = v ^ u;\n    }while(v.any());\n    return u << sftu;\n}\n\nint main(){\n    scanf(\"%lld %s\", &N, s);\n    X = bitset<4444>(s);\n    Z = X;\n    for(int i = 0; i < N; ++i){\n        scanf(\" %s\", s);\n        A[i] = bitset<4444>(s);\n    }\n    Y = A[0];\n    for(int i = 1; i < N; ++i)Y = gcd(A[i], Y);\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (lb = i))break;\n    for(int i = 4443 - lb; i >= 0; --i){\n        if(X[i + lb]){\n            X ^= Y << i;\n            A[6] ^= Y << i;\n        }\n    }\n    long long d = -1;\n    Y = A[6] ^ Z;\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (d = i))break;\n    cout << (to_modllong(Z >> lb) + (d < 0 || Z[d])) % 998244353 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 998244353\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nvector<int> _sub(const vector<int>& a, const vector<int>& b)\n{\n    int n = (int)a.size(), m = (int)b.size();\n    assert(n >= m);\n    vector<int> res;\n    for(int i = 0; i < n - m; ++i) res.push_back(a[i]);\n    for(int i = 0; i < m; ++i){\n        if((a[i + n - m] ^ b[i]) == 1 || !res.empty()) res.push_back(a[i + n - m] ^ b[i]);\n    }\n    return res;\n}\n\n// \nvector<int> _div(const vector<int>& a, const vector<int>& b)\n{\n    int n = (int)a.size(), m = (int)b.size();\n    vector<int> rem;\n    for(int i = 0; i < n; ++i){\n        if(a[i] == 1 || !rem.empty()) rem.push_back(a[i]);\n        if((int)rem.size() < m) continue;\n        rem = _sub(rem, b);\n    }\n    return rem;\n}\n\nvector<int> _gcd(const vector<int>& a, const vector<int>& b)\n{\n    int n = (int)a.size(), m = (int)b.size();\n    if(m == 0) return a;\n    return (n >= m) ? _gcd(b, _div(a, b)) : _gcd(b, a);\n}\n\nint two[4005];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vi x;\n    rep(i,(int)s.size()) x.pb((s[i] == '1'));\n    vvi a(n);\n    rep(i,n){\n        string s;\n        cin >> s;\n        rep(j,(int)s.size()){\n            a[i].pb((s[j] == '1'));\n        }\n    }\n    vi g = a[0];\n    rep(i,n-1){\n        g = _gcd(g, a[i+1]);\n    }\n    int p = (int)x.size(), q = (int)g.size();\n    if(p < q){\n        cout << \"1\\n\";\n        return 0;\n    }\n    two[0] = 1;\n    rep(i,4004){\n        two[i+1] = two[i] * 2 % MOD;\n    }\n    vi _x = x;\n    srep(i,p-q+1,p) _x[i] = 0;\n    vi rem = _div(_x, g);\n    int ans = 0;\n    for(int i = 0; i < p - q + 1; ++i){\n        if(x[i]) ans = (ans + two[p-q-i]) % MOD;\n    }\n    bool add = true;\n    int r = q - 1 - (int)rem.size();\n    rep(i,q-1){\n        if(i < r){\n            if(x[p-q+1+i]) break;\n        }else{\n            if(rem[i-r] > x[p-q+1+i]){\n                add = false;\n                break;\n            }else if(rem[i-r] < x[p-q+1+i]){\n                break;\n            }\n        }\n    }\n    cout << (ans + add) % MOD << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=998244353;\nconstexpr double EPS=1e-9;\n\nvi mod(vi a,vi b)\n{\n\tint m=a.size(),n=b.size();\n\tint j=find(all(b),1)-begin(b);\n\tfor(int i=0;i+(n-j)<=m;i++) if(a[i])\n\t\trep(k,n-j) a[i+k]^=b[j+k];\n\treturn a;\n}\n\nvi gcd(vi a,vi b)\n{\n\twhile(count(all(b),1))\n\t\ttie(a,b)=mt(b,mod(a,b));\n\treturn vi(find(all(a),1),end(a));\n}\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfor(int n;cin>>n&&n;){\n\t\tvi x;\n\t\t{\n\t\t\tstring s; cin>>s;\n\t\t\trep(j,s.size()) x.push_back(s[j]-'0');\n\t\t}\n\t\tvvi a(n);\n\t\trep(i,n){\n\t\t\tstring s; cin>>s;\n\t\t\trep(j,s.size()) a[i].push_back(s[j]-'0');\n\t\t}\n\n\t\tvi g=a[0];\n\t\trepi(i,1,n) g=gcd(g,a[i]);\n\n\t\tll res=0;\n\t\tvi y(x.size());\n\t\tfor(int i=0;i+g.size()<=y.size();i++){\n\t\t\tres=(res*2+x[i])%MOD;\n\t\t\tif(y[i]!=x[i])\n\t\t\t\trep(j,g.size()) y[i+j]^=g[j];\n\t\t}\n\t\tif(x<y)\n\t\t\tres=(res-1+MOD)%MOD;\n\t\tcout<<res+1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=998244353;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing BS = bitset<4000>;\n\nint N;\nstring X;\nLL pw2[4010];\nBS bases[4010];\nvector<BS> A;\n\nvoid Add(LL &t, LL v) {\n  t += v;\n  while (t >= MOD) t -= MOD;\n}\n\nBS MakeBitset(string &s) {\n  BS ret;\n  int idx = 3999;\n  rrep(i, s.size()) {\n    if (s[i] == '1') ret[idx] = 1;\n    else if (s[i] == '0') ret[idx] = 0;\n    else assert(0);\n    idx--;\n  }\n  return ret;\n}\n\nint RegBase(BS &v) {\n  while (1) {\n    int idx = v._Find_first();\n    if (idx == v.size()) {\n      assert(v.count() == 0);\n      return -1;\n    }\n\n    if (bases[idx].count() == 0) {\n      bases[idx] = v;\n      return idx;\n    }\n\n    v ^= bases[idx];\n    assert(v._Find_first() > idx);\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  cin >> N >> X;\n  rep(i, N) {\n    string s;\n    cin >> s;\n    A.eb(MakeBitset(s));\n  }\n  sort(all(A), [](const BS &a, const BS &b) {\n    return a._Find_first() < b._Find_first();\n  });\n  while (!A.empty() && !A.back().count()) A.pop_back();\n  reverse(all(A));\n\n  if (A.empty()) {\n    cout << \"1\\n\";\n    return 0;\n  }\n\n  int idx = A[0]._Find_first();\n  BS v = A[0];\n  while (1) {\n    int res = RegBase(v);\n    assert(res == idx);\n    if (res == -1) break;\n    v = bases[res] >> 1;\n    if (idx == 0) break;\n    idx--;\n  }\n\n  reps(i, 1, N) {\n    v = A[i];\n    idx = A[i]._Find_first();\n    while (1) {\n      int res = RegBase(v);\n      if (res == -1) break;\n      v = bases[res] >> 1;\n    }\n  }\n\n  int m = 0;\n  pw2[0] = 1;\n  rep(i, 4000) {\n    if (bases[i].count()) m++;\n    if (i > 0) {\n      Add(pw2[i], pw2[i-1]);\n      Add(pw2[i], pw2[i-1]);\n    }\n  }\n\n  X = string(4000-X.size(), '0') + X;\n  assert(X.size() == 4000);\n\n  BS cur;\n  LL ans = 1;\n  rep(i, 4000) {\n    if (!bases[i].count()) {\n      if (cur[i] > X[i]-'0') {\n        Add(ans, MOD-1);\n        break;\n      } else if (cur[i] < X[i] - '0') {\n        Add(ans, pw2[m]);\n        Add(ans, MOD-1);\n        break;\n      }\n      continue;\n    }\n\n    if (X[i] == '1') {\n      assert(m > 0);\n      Add(ans, pw2[m-1]);\n      if (!cur[i]) cur ^= bases[i];\n    } else if (X[i] == '0') {\n      if (cur[i]) cur ^= bases[i];\n    }\n\n    --m;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\nconst int m = 4010;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel rui(m + 10, 1);\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nint max_true(bs &a,int jou) {\n\tint ans = jou;\n\trep(i, jou) {\n\t\tif (a[i]) { ans = i; }\n\t}\n\treturn ans;\n}\nbool can_div(bs &a, bs b, int &sza, int szb) {\n\tfor (int i = sza; i >= szb; i--) {\n\t\tif (a[i]) {\n\t\t\ta ^= b << (i - szb);\n\t\t}\n\t}\n\tsza = max_true(a, szb);\n\tif (sza == szb) { return true; }\n\treturn false;\n}\nbs gcd(bs a, bs b) {\n\tint sza = max_true(a,m);\n\tint szb = max_true(b,m);\n\tif (sza < szb) { swap(sza, szb); swap(a, b); }\n\twhile (true) {\n\t\tif (can_div(a, b, sza, szb)) { return b; }\n\t\tif (can_div(b, a, szb, sza)) { return a; }\n\t}\n}\nvoid solve(bs &x, bs &a) {\n\tint szx = max_true(x,m);\n\tint sza = max_true(a,m);\n\tbs to;\n\trep(i, m) { ans[i] = 0; }\n\tint ans = 0;\n\tfor (int i = szx; i >= sza; i--) {\n\t\tif (x[i]) {\n\t\t\tans += rui[i - sza];\n\t\t}\n\t\tif (x[i] != to[i]) {\n\t\t\tto ^= a << (i - sza);\n\t\t}\n\t}\n\tcout << (ans + 1)%p << endl;\n}\nbs mak(string s) {\n\trev(s);\n\tbs ans;\n\trep(i, m) { ans[i] = 0; }\n\trep(i, s.size()) {\n\t\tans[i] = (s[i] == '1');\n\t}\n\treturn ans;\n}\nsigned main() {\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tstring x; cin >> x;\n\t\tstring s; cin >> s;\n\t\tbs gcd0 = mak(s);\n\t\trep(i, n - 1) {\n\t\t\tstring ne; cin >> ne;\n\t\t\tbs newb = mak(ne);\n\t\t\tgcd0 = gcd(newb, gcd0);\n\t\t}\n\t\tbs nw = mak(x);\n\t\trep(i, m + 9) { rui[i + 1] = rui[i] * 2; rui[i + 1] %= p; }\n\t\tsolve(nw, gcd0);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353;\n\nll n;\nvector<bool> x;\nvector<bool> a,b;\n\nvoid mns(){\n    for(ll i=(int)a.size()-1;i>=(int)b.size()-1;i--){\n        if(a[i]==1){\n            for(int t=0;t<b.size();t++){\n                a[i-t]=a[i-t]^b[b.size()-t-1];\n            }\n        }\n    }\n    while(!a.empty() && a.back()==0){a.pop_back();}\n    swap(a,b);\n}\n\n\n\n\n\n\n\n\nint main(){\n    vector<ll> P(100000,1);\n    for(ll i=1;i<P.size();i++){P[i]=P[i-1]*2%MOD;}\n    cin>>n;\n    string X;\n    cin>>X;\n    reverse(X.begin(),X.end());\n    x.resize(X.size());\n    for(int i=0;i<X.size();i++){\n        x[i]=X[i]-'0';\n    }\n    string A;\n    cin>>A;\n    reverse(A.begin(),A.end());\n    a.resize(A.size());\n    for(int i=0;i<A.size();i++){\n        a[i]=A[i]-'0';\n    }\n    for(int i=1;i<n;i++){\n        string B;\n        cin>>B;\n        reverse(B.begin(),B.end());\n        b.resize(B.size());\n        for(int i=0;i<B.size();i++){\n            b[i]=B[i]-'0';\n        }\n        if(a.size()<b.size()){swap(a,b);}\n        while(b.size()){mns();}\n    }\n    ll ans=0;\n    vector<bool> Z(x.size(),false);\n    for(ll i=(int)x.size()-1;i>=(int)a.size()-1;i--){\n        if(x[i]){\n            ans+=P[i-(a.size()-1)];\n            ans%=MOD;\n            if(Z[i]==0){\n                for(int t=0;t<a.size();t++){\n                    Z[i-t]=Z[i-t]^a[a.size()-1-t];\n                }\n            }\n        }\n        else{\n            if(Z[i]){\n                for(int t=0;t<a.size();t++){\n                    Z[i-t]=Z[i-t]^a[a.size()-1-t];\n                }\n            }\n        }\n    }\n    bool j=true;\n    for(ll i=X.size()-1;i>=0;i--){\n        if(X[i]==false && Z[i]==true){j=false;}\n        if(X[i]==true && Z[i]==false){break;}\n    }\n    if(j){ans++;}\n    cout<<ans%MOD<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nconst int L = 4005;\nconst int N = 100;\nconst int mo = 998244353;\n\nbitset<L>a[N],Lim;\nint n;\nint key[N];\nLL mi[L];\n\nvoid getbit(bitset<L> &a){\n\tchar s[L];\n\tscanf(\"%s\",s+1);\n\tint len=strlen(s+1);\n\tfo(i,0,len-1)a[i]=s[len-i]-'0';\n}\n\nbitset<L> trs(bitset<L> a,bitset<L> b){\n\tint wa,wb;\n\tfd(i,4000,0)if (a[i]){wa=i;break;}\n\tfd(i,4000,0)if (b[i]){wb=i;break;}\n\tif (wa<wb)swap(a,b),swap(wa,wb);\n\twhile(wb>-1){\n\t\ta=a^(b<<(wa-wb));\n\t\tbool fd=0;\n\t\tfd(i,wa,0)if (a[i]){wa=i;fd=1;break;}\n\t\tif (!fd)wa=-1;\n\t\tswap(a,b),swap(wa,wb);\n\t}\n\treturn a;\n}\n\nint main(){\n\tmi[0]=1;\n\tfo(i,1,4000)mi[i]=mi[i-1]*2%mo;\n\tscanf(\"%d\",&n);\n\tgetbit(Lim);\n\tfo(i,1,n)getbit(a[i]);\n\tint n_=0;\n\tfo(i,1,n){\n\t\tfo(j,1,i-1)\n\t\tif (a[i][key[j]])a[i]=a[i]^a[j];\n\t\tint w=-1;\n\t\tfd(x,4000,0)if (a[i][x]){w=x;break;}\n\t\tkey[i]=w;\n\t\tif (w!=-1){\n\t\t\tkey[++n_]=w;\n\t\t\ta[n_]=a[i];\n\t\t}\n\t}\n\tn=n_;\n\tint pre=0;\n\tfor(bool pd=1;pd;){\n\t\tint pn=n;\n\t\tpd=0;\n\t\tint w=(pre==0)?n:pre;\n\t\tfo(i,1,w)\n\t\t\tfo(j,pre+1,pn)\n\t\t\tif (i!=j){\n\t\t\t\tbitset<L> now=trs(a[i],a[j]);\n\t\t\t\tfo(p,1,n)\n\t\t\t\tif (now[key[p]])now=now^a[p];\n\t\t\t\tif (now.count()>0){\n\t\t\t\t\ta[++n]=now;\n\t\t\t\t\tkey[n]=0;\n\t\t\t\t\tfd(x,4000,0)if (now[x]){key[n]=x;break;}\n\t\t\t\t}\n\t\t\t}\n\t\tpre=pn;\n\t}\n\tint keyw=1;\n\tfo(i,2,n)\n\tif (key[i]<key[keyw])keyw=i;\n\tint w=0;\n\tfd(i,4000,0)\n\tif (Lim[i]){w=i;break;}\n\tLL ans=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i])ans=(ans+mi[i-key[keyw]])%mo;\n\tbitset<L>now;\n\tfo(i,0,4000)now=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i]!=now[i])now=now^(a[keyw]<<(i-key[keyw]));\n\tint prefer=1;\n\tfd(i,key[keyw],0)\n\tif (Lim[i]!=now[i]){\n\t\tif (now[i]>Lim[i])prefer=0;\n\t\tbreak;\n\t}\n\tans=(ans+prefer)%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\nconst int limit = 4010;\nusing T = bitset<limit>;\n\nT gcd(T a, T b) {\n\tif (b.none()) return a;\n\tint ta = 0, tb = 0;\n\trep(i, limit) if (a[i]) ta = i;\n\trep(i, limit) if (b[i]) tb = i;\n\n\tif (ta < tb) {\n\t\treturn gcd(b, a);\n\t} else {\n\t\tT ab = a;\n\t\tfor (int i = ta; i >= tb; --i) {\n\t\t\tif (ab[i]) {\n\t\t\t\tab ^= b << (i - tb);\n\t\t\t}\n\t\t}\n\t\treturn gcd(b, ab);\n\t}\n\treturn b;\n}\n\nT read() {\n\tstring s;\n\tcin >> s;\n\tconst int n = s.size();\n\tT ret;\n\tret.reset();\n\trep(i, n) if (s[i] == '1') ret.set(n - 1 - i);\n\treturn ret;\n}\n\nconst ll mod = 998244353LL;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\tT x, a[6];\n\n\tx = read();\n\trep(i, n) a[i] = read();\n\n\tT g = a[0];\n\trep(i, 1, n) g = gcd(g, a[i]);\n\n\tint tg = 0, tx = 0;\n\trep(i, limit) if (g[i]) tg = i;\n\trep(i, limit) if (x[i]) tx = i;\n\n\tll ans = 0LL;\n\tfor (int i = tx; i >= tg; --i) ans = (2LL * ans + x[i]) % mod;\n\tans = (ans + 1) % mod;\n\n\tT y;\n\ty.reset();\n\n\tfor (int i = tx; i >= tg; --i) {\n\t\tif (x[i] != y[i]) {\n\t\t\ty ^= g << (i - tg);\n\t\t}\n\t}\n\n\tbool big = false;\n\trrep(i, tg) {\n\t\tif (x[i] != y[i]) {\n\t\t\tif (x[i] < y[i]) big = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (big) ans = (ans + mod - 1) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#define MOD 998244353\nstd::bitset<4005> lim, res, tmp; \nint fact[4005]; \ninline int deg(std::bitset<4005> a)\n{\n\tfor (int i = 4000; i; i--)\n\t{\n\t\tif (a[i])\n\t\t\treturn i; \n\t}\n\treturn 0; \n}\ninline void gcd()\n{\n\twhile (true)\n\t{\n\t\tif (deg(tmp) > deg(res))\n\t\t\tstd::swap(tmp, res);\n\t\tint x = deg(tmp), y = deg(res); \n\t\tfor (int i = y; i >= x; i--)\n\t\t{\n\t\t\tif (res[i])\n\t\t\t\tres ^= tmp << (i - x); \n\t\t}\n\t\tif (res.none())\n\t\t{\n\t\t\tstd::swap(tmp, res);\n\t\t\tbreak; \n\t\t}\n\t}\n}\nint main()\n{\n\t// freopen(\"ARC084-F.in\", \"r\", stdin); \n\tstd::ios::sync_with_stdio(false); \n\tstd::cin.tie(0); \n\tfact[0] = 1; \n\tfor (int i = 1; i < 4005; i++)\n\t\tfact[i] = fact[i - 1] * 2 % MOD; \n\tint n; \n\tstd::cin >> n >> lim >> res; \n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tstd::cin >> tmp; \n\t\tgcd(); \n\t}\n\tint ans = 0, g = deg(res); \n\ttmp.reset(); \n\tfor (int i = 4000; i >= g; i--)\n\t{\n\t\tif (lim[i])\n\t\t\t(ans += fact[i - g]) %= MOD; \n\t\tif (lim[i] != tmp[i])\n\t\t\ttmp ^= res << (i - g); \n\t}\n\tbool f = false; \n\tfor (int i = g; i >= 0; i--)\n\t{\n\t\tif (tmp[i] < lim[i])\n\t\t\tbreak; \n\t\tif (tmp[i] > lim[i])\n\t\t\tf = true; \n\t}\n\tprintf(\"%d\\n\", (ans + !f) % MOD);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 4005;\ntypedef v(string) vs;\n\n// Mod int\nconst int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint operator~() const { return mint(1) / *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.pow(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint pow(ll t) const {\n    if(!t) return 1;\n    mint res = pow(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.pow(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].pow(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint operator()(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nstruct D {\n  bitset<MX> d;\n  int n;\n  D():n(0) {}\n  D(const string& s) {\n    n = sz(s);\n    rep(i,n) d[i] = s[n-1-i]-'0';\n  }\n  void sub(const D& a) {\n    d ^= a.d<<(n-a.n);\n    while (n && !d[n-1]) --n;\n  }\n};\n\nD inD() {\n  string s;\n  cin>>s;\n  return D(s);\n}\n\nD g(D a, D b) {\n  while (1) {\n    if (a.n < b.n) swap(a,b);\n    if (!b.n) break;\n    a.sub(b);\n  }\n  return a;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  D x = inD();\n  D a = inD();\n  rep(i,n-1) a = g(a,inD());\n  mint ans;\n  bitset<MX> d;\n  for (int i = x.n-1; i >= a.n-1; --i) {\n    ans = ans*2 + mint(x.d[i]);\n    if (x.d[i]^d[i]) d ^= a.d<<(i-a.n+1);\n  }\n  int add = 1;\n  drep(i,a.n) {\n    if (x.d[i] == d[i]) continue;\n    add = x.d[i];\n    break;\n  }\n  ans += add;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nconst int N=4000;\nbitset<N>x,a[5],g,t,c;\nchar str[N*2];\ninline void read(bitset<N> &bit) {\n\tscanf(\"%s\",str);\n\tint n=strlen(str)-1;\n\tfor (int i=0;i<=n;i++)\n\t\tbit[i]=str[n-i]-'0';\n}\ninline int deg(bitset<N> &bit) {\n\tfor (int i=N;i--;) if (bit[i]) return i;\n\treturn 0;\n}\nint p[N];\nint main()\n{\n\tint n=gi()-1,i,k,low;\n\tconst int mod=998244353;\n\tread(x);read(g);\n\tfor (i=0;i<n;i++) {\n\t\tread(t);\n\t\twhile (1) {\n\t\t\tif (deg(g)<deg(t)) swap(g,t);\n\t\t\tlow=deg(t);\n\t\t\tfor (k=deg(g);k>=low;k--)\n\t\t\t\tif (g[k])\n\t\t\t\t\tg^=t<<(k-low);\n\t\t\tif (g.none()) { g=t; break; }\n\t\t}\n\t}\n\tfor (i=p[0]=1;i<N;i++) p[i]=(p[i-1]<<1)%mod;\n\tk=deg(g);\n\tint ans=0;\n\tfor (i=N-1;i>=k;i--) {\n\t\tif (x[i]) (ans+=p[i-k])%=mod;\n\t\tif (x[i]!=g[i]) c^=g<<(i-k);\n\t}\n\tfor (i=k;~i;i--) {\n\t\tif (x[i]>c[i]) break;\n\t\telse if (x[i]<c[i]) { ans--; break; }\n\t}\n\tans++;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v, w; };\n\nvector<int> gcd(vector<int> s, vector<int> t) {\n\tint N = s.size(), M = t.size();\n\tif (N < M) return gcd(t, s);\n\tif (!M) return s;\n\trep(j, M) s[j] ^= t[j];\n\tint l = N;\n\trep(i, N) if (s[i]) {\n\t\tl = min(l, i);\n\t\tbreak;\n\t}\n\tvector<int> a(N - l);\n\trep(i, N - l) a[i] = s[l + i];\n\treturn gcd(t, a);\n}\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n >>= 1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint N; cin >> N;\n\tstring s; cin >> s;\n\tvector<string> a(N);\n\trep(i, N) cin >> a[i];\n\tvector<int> d;\n\trep(i, N) {\n\t\tint M = a[i].length();\n\t\tvector<int> b(M);\n\t\trep(j, M) b[j] = a[i][j] - '0';\n\t\td = gcd(d, b);\n\t}\n\tint n = s.length();\n\tvector<int> c(n), _c(n);\n\trep(i, n) c[i] = s[i] - '0';\n\tint m = d.size();\n\tint ans = 0;\n\tfor (int i = 0; i + m <= n; i++) {\n\t\tif (c[i]) ans = (ans + pow_mod(2, n - m - i, MOD)) % MOD;\n\t\tif (c[i] == _c[i]) continue;\n\t\trep(j, m) _c[i + j] ^= d[j];\n\t}\n\tbool ok = true;\n\tif (_c >= c) ok = false;\n\tif (ok) ans = (ans + 1) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nconst int N_bit = 4000;\nusing bset = bitset<N_bit>;\n\nbset gcd(bset x, bset y){\n    int nx = N_bit - 1, ny = N_bit - 1;\n    while(nx >= 0 && x[nx] == 0) nx--;\n    while(ny >= 0 && y[ny] == 0) ny--;\n\n    while(true){\n        if(ny > nx){\n            swap(x, y);\n            swap(nx, ny);\n        }\n        if(ny == -1) return x;\n        x ^= (y << (nx - ny));\n        while(nx >= 0 && x[nx] == 0) nx--;\n    }\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    string x; cin >> x; bset X(x);\n    vector<bset> A(N);\n    REP(i, N){\n        string a; cin >> a;\n        A[i] = bset(a);\n    }\n    bset g = A[0];\n    FOR(i, 1, N) g = gcd(g, A[i]);\n    int n = N_bit - 1;\n    while(n >= 0 && g[n] == 0) n--;\n    //debug(g);\n\n    mint ans = 0;\n    bset Y(0);\n    IFOR(i, n, N_bit){\n        if(X[i] == 1) ans += pow((mint)2, i - n);\n        if(X[i] != Y[i]) Y ^= (g << (i - n));\n    }\n    bool f = true;\n    IREP(i, n){\n        if(X[i] > Y[i]) break;\n        if(Y[i] > X[i]){\n            f = false;\n            break;\n        }\n    }\n    if(f) ans += 1;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\t \nusing namespace std;\n\t \ntypedef long long LL;\ntypedef double db;\n\t \nconst int L = 8005;\nconst int N = 8005;\nconst int mo = 998244353;\n \nbitset<L>a[N],Lim;\nint n;\nint key[N];\nLL mi[L];\n \nvoid getbit(bitset<L> &a){\n\tchar s[L];\n\tscanf(\"%s\",s+1);\n\tint len=strlen(s+1);\n\tfo(i,0,len-1)a[i]=s[len-i]-'0';\n}\n \nbitset<L> trs(bitset<L> a,bitset<L> b){\n\tint wa,wb;\n\tfd(i,4000,0)if (a[i]){wa=i;break;}\n\tfd(i,4000,0)if (b[i]){wb=i;break;}\n\tif (wa<wb)swap(a,b),swap(wa,wb);\n\twhile(wb>-1){\n\ta=a^(b<<(wa-wb));\n\t\tbool fd=0;\n\t\tfd(i,wa,0)if (a[i]){wa=i;fd=1;break;}\n\t\tif (!fd)wa=-1;\n\t\tif (wa<wb)swap(a,b),swap(wa,wb);\n\t}\n\treturn a;\n}\n\t \nint main(){\n\tmi[0]=1;\n\tfo(i,1,4000)mi[i]=mi[i-1]*2%mo;\n\tscanf(\"%d\",&n);\n\tgetbit(Lim);\n\tfo(i,1,n)getbit(a[i]);\n\tint n_=0;\n\tfo(i,1,n){\n\t\tfo(j,1,i-1)\n\t\tif (a[i][key[j]])a[i]=a[i]^a[j];\n\t\tif (a[i].count()==0)continue;\n\t\tint w=-1;\n\t\tfd(x,4000,0)if (a[i][x]){w=x;break;}\n\t\tkey[i]=w;\n\t\tif (w!=-1){\n\t\t\tkey[++n_]=w;\n\t\t\ta[n_]=a[i];\n\t\t}\n\t}\n\tn=n_;\n\tint pre=0;\n\tfor(bool pd=1;pd;){\n\t\tint pn=n;\n\t\tpd=0;\n\t\tint w=(pre==0)?n:pre;\n\t\tfo(i,1,w)\n\t\t\tfo(j,pre+1,pn)\n\t\t\tif (i!=j){\n\t\t\t\tbitset<L> now=trs(a[i],a[j]);\n\t\t\t\tfo(p,1,n)\n\t\t\t\tif (now[key[p]])now=now^a[p];\n\t\t\t\tif (now.count()>0){\n\t\t\t\t\ta[++n]=now;\n\t\t\t\t\tkey[n]=0;\n\t\t\t\t\tfd(x,4000,0)if (now[x]){key[n]=x;break;}\n\t\t\t\t}\n\t\t\t}\n\t\tpre=pn;\n\t}\n\tint keyw=1;\n\tfo(i,2,n)\n\tif (key[i]<key[keyw])keyw=i;\n\tint w=0;\n\tfd(i,4000,0)\n\tif (Lim[i]){w=i;break;}\n\tLL ans=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i])ans=(ans+mi[i-key[keyw]])%mo;\n\tbitset<L>now;\n\tfo(i,0,4000)now=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i]!=now[i])now=now^(a[keyw]<<(i-key[keyw]));\n\tint prefer=1;\n\tfd(i,key[keyw],0)\n\tif (Lim[i]!=now[i]){\n\t\tif (now[i]>Lim[i])prefer=0;\n\t\tbreak;\n\t}\n\tans=(ans+prefer)%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\n#define N_bit 4000\nusing bin = bitset<N_bit>;\nbin gcd(bin a, bin b){\n    int na = 0, nb = 0;\n    while(true){\n        while(na < N_bit && a[N_bit - 1 - na] == 0) na++;\n        while(nb < N_bit && b[N_bit - 1 - nb] == 0) nb++;\n        if(na > nb){\n            swap(a, b);\n            swap(na, nb);\n        }\n        if(nb == N_bit) return a;\n\n        a ^= b << (nb - na);\n    }\n}\n\nbool compare(bin a, bin b){\n    IREP(i, N_bit){\n        if(a[i] == 0 && b[i] == 1) return true;\n        if(a[i] == 1 && b[i] == 0) return true;\n    }\n    return true;\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    string X; cin >> X;\n    vector<string> A(N); cin >> A;\n\n    bin x(X);\n    vector<bin> a(N);\n    REP(i, N) a[i] = bin(A[i]);\n    bin g = a[0];\n    FOR(i, 1, N){\n        g = gcd(g, a[i]);\n    }\n    //debug(g);\n\n    int nx = 0, ng = 0;\n    while(nx < N_bit && x[N_bit - 1 - nx] == 0) nx++;\n    while(ng < N_bit && g[N_bit - 1 - ng] == 0) ng++;\n\n    nx = N_bit - nx;\n    ng = N_bit - ng;\n\n    mint ans = 0;\n    bin t(0);\n    REP(i, nx - ng + 1){\n        if(x[nx - 1 - i] == 1){\n            if(t[nx - 1 - i] == 0){\n                ans += pow((mint)2, nx - ng - i);\n                t ^= g << (nx - ng - i);\n            }else{\n                ans += pow((mint)2, nx - ng - i);\n            }\n        }else if(x[nx - 1 - i] == 0){\n            if(t[nx - 1 - i] == 1){\n                t ^= g << (nx - ng - i);\n            }\n        }\n    }\n    if(compare(t, x)) ans += 1;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=300005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint k,n,a[N];\n\ninline void make(){\n\tint i=n;\n\twhile(!a[i]) i--;\n\ta[i]--;\n\tif(a[i]){\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\ta[j]=k;\n\t}\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tread(k,n);\n\tif(k==1){\n\t\tfor(int i=1;i<=(n+1)/2;i++)\n\t\t\tprintf(\"%d \",k);\n\t\treturn 0;\n\t}\n\tif(k%2==0){\n\t\tprintf(\"%d \",k/2);\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tprintf(\"%d \",k);\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=(k+1)/2;\n\tfor(int i=1;i<=n/2;i++)\n\t\tmake();\n\tfor(int i=1;i<=n&&a[i];i++)\n\t\tprintf(\"%d \",a[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include <cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nconst int DEBUG = 0;\n\n\nconst int N=DEBUG?20:4000;\ntypedef bitset<N> bs;\nconst lint MOD=998244353;\n\nbs read(){\n  string s;\n  cin>>s;\n  int l=s.length();\n  bs ret;\n  rep(i,l)ret[i]=s[l-i-1]=='1';\n  return ret;\n}\n\nbs div(bs a, bs b){\n  int hi=-1;\n  rep(i,N){\n    if(b[i]){\n      hi=i;\n    }\n  }\n  assert(hi>=0);\n  for(int i=N-hi-1;i>=0;--i){\n    if(a[i+hi]){\n      a^=b<<i;\n    }\n  }\n  return a;\n}\n\nbs gcd(bs a,bs b){\n  while(b.count()!=0){\n    a=div(a,b);\n    swap(a,b);\n  }\n  return a;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  bs x=read();\n  vector<bs> s(n);\n  rep(i,n)s[i]=read();\n  bs t=s[n-1];\n  rep(i,n-1)\n    t=gcd(s[i],t);\n  lint ans=0;\n  lint cur=1;\n  int hi=-1;\n  rep(i,N){\n    if(t[i]){\n      hi=i;\n    }\n  }\n  bs y;\n  for(int i=N-hi-1;i>=0;--i){\n    if(x[i+hi]!=y[i+hi]){\n      y^=t<<i;\n    }\n  }\n  rep(i,N-hi){\n    if(x[i+hi])ans=(ans+cur)%MOD;\n    cur=cur*2%MOD;\n  }\n  bool lt=false;\n  for(int i=N-1;i>=0;--i){\n    if(x[i]!=y[i]){\n      lt=x[i]<y[i];\n      break;\n    }\n  }\n  if(lt)ans=(ans+MOD-1)%MOD;\n  ans=(ans+1)%MOD;\n  if(DEBUG){\n    cerr<<\"x=\"<<x<<endl;\n    cerr<<\"y=\"<<y<<endl;\n    cerr<<\"t=\"<<t<<endl;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e3+10;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,p,bin[N],fl=1,ans=0;\nbitset<N> a,b,c;\n\nint main() {\n\tcin>>n>>a;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>c;\n\t\twhile(c.any()) {\n\t\t\tfor(int i=4000;;i--) if(c[i]) { p=i;break; }\n\t\t\tfor(int i=4000;i>=p;i--) if(b[i]) b^=c<<(i-p);\n\t\t\tswap(b,c);\n\t\t}\n\t}\n\tbin[0]=1;\n\tfor(int i=1;i<N;i++) bin[i]=2ll*bin[i-1]%mod;\n\tfor(int i=4000;;i--) if(b[i]) { p=i;break; }\n\tc.reset();\n\tfor(int i=4000;i>=p;i--) {\n\t\tif(a[i]) ans=(ans+bin[i-p])%mod;\n\t\tif(c[i]!=a[i]) c^=b<<(i-p);\n\t}\n\tfor(int i=p-1;~i;i--)\n\t\tif(c[i]<a[i]) break;\n\t\telse if(c[i]>a[i]) { fl=0;break; }\n\tcout<<(ans+fl)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nvector<int> calc(vector<int> a,vector<int> b){\n    int n = a.size();\n    int m = b.size();\n    for(int i=0;i<=n-m;i++){\n        if(a[i]=='0')continue;\n        for(int j=0;j<m;j++){\n            a[i+j] ^= b[j];\n        }\n    }\n    bool flag = 0;\n    vector<int> c;\n    rep(i,n){\n        if(flag){\n            c.push_back(a[i]);\n        }else if(a[i]==1){\n            c.push_back(a[i]);\n            flag =1;\n        }\n    }\n    return c;\n}\n\nvector<int> gcd(vector<int> a,vector<int> b){\n    if(a.size()<b.size()){\n        swap(a,b);\n    }\n    vector<int> t = calc(a,b);\n    if(t.size()==0)return b;\n    return gcd(b,t);\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 998244353\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> p;\n    string t;\n    cin >> t;\n    rep(i,t.size()){\n        p.push_back(t[i]-'0');\n    }\n    vector<int>a;\n    rep(i,n){\n        string s;\n        cin >> s;\n        vector<int> b;\n        rep(j,s.size()){\n            b.push_back(s[j]-'0');\n        }\n        if(a.size()==0){\n            a = b;\n        }else{\n            a = gcd(a,b);\n        }\n    }\n    // for(auto x:a){\n    //     cerr << x;\n    // }\n    // cerr << endl;\n    if(p.size()<a.size()){\n        cout << 1 << endl;\n    }else{\n        mod res = 0;\n        int m = p.size();\n        int k = a.size();\n        \n        vector<int> q(m);\n        for(int i=0;i<=m-k;i++){\n            // rep(j,m){\n            //     cerr << q[j];\n            // }\n            // cerr << endl;\n            if(p<q){\n                if(p[i]==1){\n                    res += mod_pow((mod)2,m-k-i);\n                }else{\n                    if(q[i]==1){\n                        rep(j,k){\n                            q[i+j] ^= a[j];\n                        }\n                    }\n                }\n            }else{\n                if(p[i]==1){\n                    res += mod_pow((mod)2,m-k-i);\n                    if(q[i]==0){\n                        rep(j,k){\n                            q[i+j] ^= a[j];\n                        }\n                    }\n                }else{\n\n                }\n            }\n        }\n        if(p>=q){\n            cout << res+1 << endl;\n        }else{\n            cout << res << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ayy\n// ' lamo\n// SUBLIME HAX\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\n// const int P=1e9+7;\n\n\n\n\nconst int N=4096;\n// const int N=12;\nint n;\ntypedef bitset<N> BS;\nBS X,A[6],Y,Q;\nvoid read(BS &bs) {\n\tstring s; cin>>s;\n\treverse(s.begin(),s.end());\n\tfor(int i=0;i<sz(s);i++) bs[i]=int(s[i]=='1');\n}\nbool operator<(const BS &L,const BS &R) {\n\tfor(int i=N;--i>=0;) if(L[i]!=R[i]) return L[i]<R[i];\n\treturn 0;\n}\nint len(const BS &bs) {\n\tfor(int i=N;--i>=0;) if(bs[i]) return i+1;\n\treturn 0;\n}\n\nint h[6];\nvoid rref() {\n\tfor(int i=0;i<n;i++) h[i]=len(A[i])-1;\n\tfor(;;) {\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if(h[i]>=h[j]) {\n\t\t\tif(A[i] != A[j]<<(h[i]-h[j])) {\n\t\t\t\tA[i] ^= A[j]<<(h[i]-h[j]);\n\t\t\t\th[i]=len(A[i])-1;\n\t\t\t\tgoto win;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\twin:;\n\t}\n\tQ=A[min_element(h,h+n)-h];\n}\n\n\n\nconst int P=998244353;\nint powq(int x,int e) {\n\tif(!e) return 1;\n\tif(e&1) return int(1LL*x*powq(x,e-1)%P);\n\tx=powq(x,e>>1);\n\treturn int(1LL*x*x%P);\n}\n\n\nint32_t main() {\n\tcin>>n;\n\tread(X);\n\tfor(int i=0;i<n;i++) read(A[i]);\n\trref();\n\t// dbg(Q);\n\n\tint w=len(Q); assert(w>0);\n\tint m=len(X); assert(m>0);\n\tY.reset();\n\tif(w>m) return cout<<1<<endl,0;\n\tll Z=0;\n\tfor(int i=m-1;i>=w-1;i--) {\n\t\t// dbg(i,X,Y,i-(w-1));\n\t\tif(X[i]) Z+=powq(2,i-(w-1));\n\t\tif(X[i] != Y[i]) Y^=Q<<(i-(w-1));\n\t}\n\t++Z;\n\tcout<<Z%P<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 4040\n\nlong long mod=998244353;\nlong long n,powlist[N+1],pfig,xfig,ans;\nbitset<N> p,q,x;\n\nint countFigure(bitset<N> masu){\n    int cnt=0;\n    for(int i=0;masu[N-i]==0;i++)cnt++;\n    return N-cnt+1;\n}\n\nvoid bitsetSubtract(bitset<N> &x, const bitset<N> &y) {\n    bool b = false;\n\n    for (int i = 0; i < N; i++) {\n        if (b) {\n            if (x[i]) {\n                x[i] = y[i];\n                b = y[i];\n            } else {\n                x[i] = !y[i];\n                b = true;\n            }\n        } else {\n            if (x[i]) {\n                x[i] = !y[i];\n                b = false;\n            } else {\n                x[i] = y[i];\n                b = y[i];\n            }\n        }\n    }\n}\n\nbitset<N> gcd(bitset<N> u, bitset<N> v) {\n    bitset<N> one (string(\"1\"));\n    bitset<N> zero (string(\"0\"));\n\n    int shift;\n\n    if (u == 0) return v;\n    if (v == 0) return u;\n\n    for (shift = 0; ((u | v) & one) == zero; ++shift) {\n        u >>= 1;\n        v >>= 1;\n    }\n\n    while ((u & one) == zero) u >>= 1;\n\n    do {\n        while ((v & one) == zero) v >>= 1;\n\n        if (u.to_string() > v.to_string()) {\n            bitset<N> t = v;\n            v = u;\n            u = t;\n        }\n\n        bitsetSubtract(v,u);\n    } while (v != 0);\n\n    return u << shift;\n}\n\nint bitPowerlist(){\n    powlist[1]=1;\n    for(int i=2;i<=N;i++){\n        powlist[i]=powlist[i-1]*2%mod;\n    }\n}\n\nint bitPower(bitset<N> ma,int res){\n    int ret=0;int j=res;\n    for(int i=res;i<=N;i++){\n        //cout<<powlist[i]<<endl;\n        ret+=powlist[j]*ma[i]*2%mod;\n        j++;\n    }\n    return ret;\n}\n\nint main(){\n    bitPowerlist();\n    cin>>n>>x>>p;\n    int pfig,xfig;\n    for(int i=1;i<n;i++){\n        cin>>q;\n        p=gcd(p,q);\n    }\n    pfig=countFigure(p);\n    xfig=countFigure(x);\n    ans=bitPower(x,xfig-pfig);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\n\n\ntemplate<const std::size_t N>\nstruct bfps: public std::bitset<N> {\n  using size_type = std::size_t;\n  size_type len;\n\n  void recalc() {\n    this->len = 0;\n    for(i64 j = N; j --> 0;) {\n      if((*this)[j]) {\n        this->len = j + 1;\n        return;\n      }\n    }\n  }\n\n  bfps() : std::bitset<N>() { this->len = 0; }\n  //bfps(const std::uint_fast64_t x) : std::bitset<N>(x) { recalc(); }\n  bfps(const std::bitset<N>& b) : std::bitset<N>(b) { recalc(); }\n  size_type size() const { return this->len; }\n\n\n  static bfps mod(bfps a, const bfps& b) {\n    assert(b.size() > 0);\n    for(i64 i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static bfps div(bfps a, const bfps& b) {\n    assert(b.size() > 0);\n    bfps d;\n    for(i64 i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        bfps e;\n        e[i] = 1;\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static bfps gcd(bfps a, bfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = b;\n      b = m;\n    }\n    return a;\n  }\n\n  bool operator<(const bfps& b) const {\n    bool OK = false;\n    for(i64 i = N; i --> 0; ) {\n      if((*this)[i] != b[i]) {\n        if(b[i]) {\n          OK = true;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n  bool operator<=(const bfps& b) const {\n    bool OK = true;\n    for(i64 i = N; i --> 0; ) {\n      if((*this)[i] != b[i]) {\n        if((*this)[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n};\n\nconst int BN = 4000;\nusing bits = bfps<BN>;\n\nint main() {\n  i64 N;\n  cin >> N;\n  bits X;\n  cin >> X;\n  X.recalc();\n\n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    if(now <= X) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nconst int N=4000;\ntypedef bitset<N> bs;\nconst lint MOD=998244353;\n\nbs read(){\n  string s;\n  cin>>s;\n  int l=s.length();\n  bs ret;\n  rep(i,l)ret[i]=s[l-i-1]=='1';\n  return ret;\n}\n\n// a%b\nbs rem(bs a,bs b){\n  int hi=-1;\n  rep(i,N)\n    if(b[i])hi=i;\n  assert(hi>=0);\n  for(int i=N-hi-1;i>=0;--i)\n    if(a[i+hi])a^=b<<i;\n  return a;\n}\n\nbs gcd(bs a,bs b){\n  while(b.count()!=0){\n    a=rem(a,b);\n    swap(a,b);\n  }\n  return a;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  bs x=read();\n  vector<bs> s(n);\n  rep(i,n)s[i]=read();\n  bs g=s[n-1];\n  rep(i,n-1)g=gcd(s[i],g);\n  lint ans=0;\n  lint cur=1;\n  int hi=-1;\n  rep(i,N)\n    if(g[i])hi=i;\n  rep(i,N-hi){\n    if(x[i+hi])ans=(ans+cur)%MOD;\n    cur=cur*2%MOD;\n  }\n  bs y=x^rem(x,g);\n  bool lt=false; //x<y?\n  for(int i=N-1;i>=0;--i){\n    if(x[i]!=y[i]){\n      lt=x[i]<y[i];\n      break;\n    }\n  }\n  if(!lt)ans=(ans+1)%MOD; // y<=x; counts y\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i*i <= N; ++i)\n\t{\n\t\tif (N%i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD> &other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD> &other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//\n\tuint64_t a;\n};\n//mint_base\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_base\n//O(x)fact_set\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_base\n//0x\n//O(x)\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_basestream\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_basestream\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_base\n//0x\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//O(logMOD)\n\tstatic const auto fact_v = fact_set_c<100001>();\n\treturn fact_v[all] / (fact_v[get] * fact_v[all - get]);\n#elif 0\n\t//O(1)\n\t//O(N^2)\n\tconstexpr int32_t ALL_MAX = 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n\n\nint32_t N;\nstd::bitset<4010> X;\nstd::bitset<4010> A[6];\nstd::bitset<4010> operatable;\nint32_t min_1 = 8000;\n\nmint dp[4010][2];\nbool used[4010][2];\n\nmint func(int i, bool upup)\n{\n\tif (i == -1) {\n\t\treturn 1_mi;\n\t}\n\tif (used[i][upup]) { return dp[i][upup]; }\n\tused[i][upup] = true;\n\tmint res = 0;\n\tif (upup)\n\t{\n\t\tif (X[i]) {\n\t\t\tres += func(i - 1, true);\n\t\t\tres += func(i - 1, false);\n\t\t}\n\t\telse {\n\t\t\tres = func(i - 1, true);\n\t\t}\n\t}\n\telse if(i >= min_1)\n\t{\n\t\tres = func(i - 1, false)*2;\n\t}\n\telse {\n\t\tres = func(i - 1, false);\n\t}\n\treturn dp[i][upup] = res;\n}\n\n// Greatest Common Divisor\nuint64_t gcd(uint64_t m, uint64_t n)\n{\n\t// \n\tfor (;;)\n\t{\n\t\tif (0 == m) { return n; }\n\t\tn %= m;\n\t\tif (0 == n) { return m; }\n\t\tm %= n;\n\t}\n}\n// Least Common Multiple\nuint64_t lcm(uint64_t m, uint64_t n)\n{\n\tif (0 == m) { return n; }\n\tif (0 == n) { return m; }\n\treturn ((m / gcd(m, n)) * n); // lcm = m * n / gcd(m,n)\n}\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N;\n\tin >> X;\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tin >> A[i];\n\t}\n\n\tbool one = false;\n\t//1\n\tfor (int32_t i = 0; i < N; i++)\n\t{\n\t\tfor (int32_t j = 0; j < 4010; j++)\n\t\t{\n\t\t\tif (A[i][j] == true) {\n\t\t\t\tmin_1 = std::min(min_1, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tone = (one || (A[i].count() == 1));\n\t}\n\tfor (int32_t i = 0; i < N; i++)\n\t\tfor (int32_t j = i+1; j < N; j++)\n\t{\n\t\tif (gcd(A[i].count(), A[j].count()) == 1) {\n\t\t\t\tone = true;\n\t\t}\n\t}\n\n\tif (one)\n\t{\n\t\t//min_1\n\t\t//for (int32_t j = 0; j < 4010; j++)\n\t\t//{\n\t\t//\tif (j >= min_1) {\n\t\t//\t\toperatable[j] = true;\n\t\t//\t}\n\t\t//\telse {\n\t\t//\t\toperatable[j] = false;\n\t\t//\t}\n\t\t//}\n\n\t\t//out << func(4005, true) << endl;\n\n\t\tif (0 >= min_1) {\n\t\t\tdp[0][false] = 2_mi;\n\t\t\tdp[0][true] = X[0] ? 2_mi : 1_mi;\n\t\t}\n\t\telse {\n\t\t\tdp[0][false] = 1_mi;\n\t\t\tdp[0][true] = 1_mi;\n\t\t}\n\n\t\tfor (int32_t i = 1; i < 4010; i++)\n\t\t{\n\t\t\tif (X[i]) {\n\t\t\t\tdp[i][true] = dp[i - 1][true];\n\t\t\t\tdp[i][true] += dp[i - 1][false];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][true] = dp[i - 1][true];\n\t\t\t}\n\n\n\t\t\tif (i >= min_1)\n\t\t\t{\n\t\t\t\tdp[i][false] = dp[i - 1][false] * 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][false] = dp[i - 1][false];\n\t\t\t}\n\t\t}\n\n\t\tout << dp[4009][true] << endl;\n\t}\n\telse {\n\t\tfor (;;);\n\t}\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Ankur Dua\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nusing ll = long long;\nll mod=1000000007;\nll *fact, *ifact;\n\nusing cd = complex<long double>;\nconst long double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        long double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\nvector<ll> multiply(vector<ll> const& a, vector<ll> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size())\n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<ll> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int &cid = ptr[v]; cid < (int) adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n\n//Min cost max flow using dijkstra from https://codeforces.com/contest/1107/submission/49033783\ntemplate<typename flow_t, typename cost_t>\nstruct MinCostMaxFlow {\n    static const flow_t FLOW_INF = numeric_limits<flow_t>::max() / 2;\n    const cost_t COST_INF = numeric_limits<cost_t>::max() / 2;\n    struct edge {\n        int node, rev;\n        flow_t capacity;\n        cost_t cost;\n\n        edge(int _node = -1, int _rev = -1, flow_t _capacity = 0, cost_t _cost = 0)\n                : node(_node), rev(_rev), capacity(_capacity), cost(_cost) {}\n    };\n\n    int V = -1;\n    vector<vector<edge>> adj;\n    vector<cost_t> dist;\n    vector<int> prev;\n    vector<edge*> prev_edge;\n\n    MinCostMaxFlow(int vertices = -1) {\n        if (vertices >= 0)\n            init(vertices);\n    }\n\n    void init(int vertices) {\n        V = vertices;\n        adj.assign(V, {});\n        dist.resize(V);\n        prev.resize(V);\n        prev_edge.resize(V);\n    }\n\n    void addEdge(int u, int v, flow_t capacity, cost_t cost) {\n        edge uv_edge(v, adj[v].size() + (u == v ? 1 : 0), capacity, cost);\n        edge vu_edge(u, adj[u].size(), 0, -cost);\n        adj[u].push_back(uv_edge);\n        adj[v].push_back(vu_edge);\n    }\n\n    edge &reverse_edge(const edge &e) {\n        return adj[e.node][e.rev];\n    }\n\n    bool bellman_ford(int source, int sink) {\n        for (int i = 0; i < V; i++) {\n            dist[i] = COST_INF;\n            prev[i] = -1;\n            prev_edge[i] = nullptr;\n        }\n\n        vector<int> last_seen(V, -1);\n        vector<int> nodes(1, source);\n        dist[source] = 0;\n\n        for (int iteration = 0; iteration < V; iteration++) {\n            vector<int> next_nodes;\n\n            for (int node : nodes)\n                for (edge &e : adj[node])\n                    if (e.capacity > 0 && dist[node] + e.cost < dist[e.node]) {\n                        dist[e.node] = dist[node] + e.cost;\n                        prev[e.node] = node;\n                        prev_edge[e.node] = &e;\n\n                        if (last_seen[e.node] != iteration) {\n                            last_seen[e.node] = iteration;\n                            next_nodes.push_back(e.node);\n                        }\n                    }\n\n            swap(nodes, next_nodes);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    struct dijkstra_state {\n        cost_t dist;\n        int node;\n\n        bool operator<(const dijkstra_state &other) const {\n            return dist > other.dist;\n        }\n    };\n\n    void dijkstra_check(int node, cost_t potential_dist, int previous, edge *previous_edge, auto &pq) {\n        if (potential_dist < dist[node]) {\n            dist[node] = potential_dist;\n            prev[node] = previous;\n            prev_edge[node] = previous_edge;\n            pq.push({dist[node], node});\n        }\n    }\n\n    bool dijkstra(int source, int sink) {\n        dist.assign(V, COST_INF);\n        prev.assign(V, -1);\n        prev_edge.assign(V, nullptr);\n\n        priority_queue<dijkstra_state> pq;\n        dijkstra_check(source, 0, -1, nullptr, pq);\n\n        while (!pq.empty()) {\n            dijkstra_state top = pq.top();\n            pq.pop();\n\n            if (top.dist > dist[top.node])\n                continue;\n\n            for (edge &e : adj[top.node])\n                if (e.capacity > 0)\n                    dijkstra_check(e.node, top.dist + e.cost, top.node, &e, pq);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    void reduce_cost() {\n        for (int i = 0; i < V; i++)\n            for (edge &e : adj[i])\n                e.cost += dist[i] - dist[e.node];\n    }\n\n    pair<flow_t, cost_t> minCostFlow(int source, int sink, flow_t flow_goal = FLOW_INF) {\n        assert(V >= 0);\n\n        if (!bellman_ford(source, sink))\n            return make_pair(0, 0);\n\n        flow_t total_flow = 0;\n        cost_t total_cost = 0;\n        cost_t reduce_sum = 0;\n\n        do {\n            reduce_cost();\n            reduce_sum += dist[sink];\n            flow_t path_cap = flow_goal - total_flow;\n\n            for (int node = sink; prev[node] != -1; node = prev[node])\n                path_cap = min(path_cap, prev_edge[node]->capacity);\n\n            for (int node = sink; prev[node] != -1; node = prev[node]) {\n                edge *e = prev_edge[node];\n                assert(e->cost == 0);\n                e->capacity -= path_cap;\n                reverse_edge(*e).capacity += path_cap;\n            }\n\n            total_flow += path_cap;\n            total_cost += reduce_sum * path_cap;\n        } while (total_flow < flow_goal && dijkstra(source, sink));\n\n        return make_pair(total_flow, total_cost);\n    }\n};\n\nll modExp(ll base, ll exp, ll mod=::mod){\n    ll ans=1;\n    while(exp) {\n        if (exp & 1) {\n            (ans *= base) %= mod;\n        }\n        (base *= base) %= mod;\n        exp>>=1;\n    }\n    return ans;\n}\nll modInv(ll x, ll mod=::mod){\n    return modExp(x,mod-2,mod);\n}\nvoid modFact(ll n, ll mod=::mod){\n    ifact=new ll[n+1];\n    fact=new ll[n+1];\n    fact[0]=fact[1]=1;\n    for(int i=2;i<=n;i++){\n        fact[i]=(i*fact[i-1])%mod;\n    }\n    ifact[n]=modInv(fact[n], mod);\n    for(int i=n-1;i>=0;i--){\n        ifact[i]=((i+1)*ifact[i+1])%mod;\n    }\n}\nll ncr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[r];\n    ans%=mod;\n    ans*=ifact[n-r];\n    ans%=mod;\n    return ans;\n}\nll npr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[n-r];\n    return ans%mod;\n}\nclass DSU{\npublic:\n    int*p, *r;\n    DSU(int n){\n        p=new int[n+50];\n        r=new int[n+50];\n        for(int i=0;i<=n+10;i++){\n            p[i]=i;\n            r[i]=0;\n        }\n    }\n    ~DSU(){\n        delete[] p;\n        delete[] r;\n    }\n    int find(int x){\n        if(p[x]==x)\n            return x;\n        return p[x]=find(p[x]);\n    }\n    bool Unite(int a, int b){\n        a=find(a);\n        b=find(b);\n        if(a==b)\n            return false;\n        if(r[a]<r[b])\n            p[a]=b;\n        else\n            p[b]=a;\n        if(r[a]==r[b])\n            r[a]++;\n        return true;\n    }\n};\nusing namespace std;\nconst int mx=4000;\ntypedef bitset<mx> BS;\nll p2[mx];\nBS b;\nclass ARC84D {\npublic:\n    ll dfs(BS &x,vector<int> &cnt, int bp, bool eq, vector<BS> &basis){\n        if(bp==-1)\n            return 1;\n        if(!eq)\n            return p2[cnt[bp]];\n        ll ans=0;\n        if(x[bp] && b[bp]){\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,false,basis);\n                b^=basis[bp];\n                ans%=mod;\n            }\n        }else if(x[bp] && !b[bp]){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n            ans+=dfs(x,cnt,bp-1,false,basis);\n\n            ans%=mod;\n        }else if((!x[bp]) && (b[bp])){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n        }else{\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n        }\n\n        return ans;\n    }\n    BS ggcd(BS a, BS b){\n        if(!b.any())\n            return a;\n        int ha,hb;\n        for(int i=mx-1;i>=0;i--){\n            if(a[i])\n                ha=i;\n        }\n\n        for(int i=mx-1;i>=0;i--){\n            if(b[i])\n                hb=i;\n        }\n        if(ha<hb){\n            a<<(hb-ha);\n        }else if(hb<ha){\n            b<<(ha-hb);\n        }\n        return ggcd(b,a^b);\n    }\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        int n;\n        cin>>n;\n\n        string xx;\n        cin>>xx;\n        BS x(xx);\n        vector<BS> basis(mx);\n        BS gcd;\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            BS cur(s);\n            gcd=ggcd(gcd,cur);\n        }\n        mod=998244353;\n        p2[0]=1;\n        for(int i=1;i<mx;i++){\n            p2[i]=(2*p2[i-1])%mod;\n        }\n        BS least=gcd;\n        for(int i=0;i<mx-1;i++){\n            if(least[i]){\n                //least=basis[i]<<1;\n                for(int j=i;j<mx;j++,least<<=1){\n                    basis[j]=least;\n                }\n                break;\n            }\n        }\n        vector<int> cnt(mx);\n        for(int i=0;i<mx;i++)\n            if(basis[i][i])\n                cnt[i]=1;\n        for(int i=1;i<mx;i++)\n            cnt[i]+=cnt[i-1];\n        b=BS();\n        cout<<dfs(x,cnt,mx-1,true,basis)<<endl;\n\t}\n};\n\n\nint main() {\n\tARC84D solver;\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(NULL);\n\tstd::cout.tie(NULL);\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\nvector<bool> input(){\n\tstring s;\n\tcin>>s;\n\tint N = s.size();\n\tvector<bool> x(N);\n\trep(i,N) x[i] = s[i]=='1';\n\treturn x;\n}\nvoid normalize(vector<bool>& a){\n\tvector<bool> b;\n\tint N = a.size();\n\tbool yet = 1;\n\trep(i,N){\n\t\tif(a[i]){\n\t\t\tyet = 0;\n\t\t}\n\t\tif(!yet) b.pb(a[i]);\n\t}\n\ta = b;\n}\nint cnt;\nvector<bool> gcd(vector<bool> a,vector<bool> b){\n\tcnt++;\n\tif(cnt>=20) exit(0);\n\tnormalize(a);\n\tnormalize(b);\n\tint N = a.size(), M = b.size();\n\tif(N<M) swap(a,b),swap(N,M);\n\n\tif(M==0) return a;\n\n\trep(i,M) a[i] = a[i] ^ b[i];\n\treturn gcd(a,b);\n}\n\nint N;\nint main(){\n\tcin>>N;\n\tvector<bool> X = input();\n\tvector<bool> g;\n\trep(i,N){\n\t\tvector<bool> f;\n\t\tf = input();\n\t\tg = gcd(g,f);\n\t}\n\tvector<mint> p2(5000);\n\tp2[0] = 1;\n\trep1(i,4999) p2[i] = p2[i-1]*2;\n\n\tmint ans = 1;\n\tvector<bool> oX = X;\n\tint a = X.size();\n\tint b = g.size();\n\trep(i,a-b+1){\n\t\tif(X[i]){\n\t\t\trep(j,b) X[i+j] = X[i+j] ^ g[j];\n\t\t}\n\t\tif(oX[i]){\n\t\t\tans += p2[a-(i+b)];\n\t\t}\n\t}\n\trep(i,a) oX[i] = oX[i] ^ X[i];\n\tif(X>oX) ans += 1;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bitset>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nconst LL MOD = 998244353;\n\nconst int SIZE = 4096;\n//const int SIZE = 16;\nusing Bits = bitset<SIZE>;\nint N;\nBits X, A[6];\nBits B[SIZE];\nchar buf[SIZE];\n\nvoid read(Bits &b) {\n    scanf(\"%s\", buf);\n    b = Bits(buf);\n}\n\nint get_high(const Bits &b) {\n    for (int i=SIZE; i--;) if (b.test(i)) return i;\n    return -1;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    read(X);\n    REP (i, N) read(A[i]);\n\n    REP (i, N) {\n\tBits b = A[i];\n\tint high = get_high(b);\n\n\twhile (0 <= high && high < SIZE) {\n\t    if (B[high].test(high)) {\n\t\tb ^= B[high];\n\t\thigh = get_high(b);\n\t    } else {\n\t\tB[high] = b;\n\t\tb <<= 1;\n\t\thigh++;\n\t    }\n\t}\n    }\n\n    int z = -1;\n    REP (i, SIZE) if (B[i].test(i)) {\n\tz = i;\n\tbreak;\n    }\n\n    LL cnt = 0;\n    Bits ex;\n\n    for (int i=SIZE-1; i>=z; i--) {\n\tcnt *= 2;\n\tif (X.test(i)) {\n\t    cnt += 1;\n\t}\n\tif (cnt >= MOD) cnt -= MOD;\n\n\tif (X.test(i) != ex.test(i)) {\n\t    ex.flip(i);\n\t}\n    }\n//    REP (i, SIZE) cerr << B[i].to_ullong()<< \" \" << B[i] << endl;\n//    cerr << X << endl;\n//    cerr << ex << endl;\n    bool le = true;\n    for (int i=z; i>=0; i--) if (!X.test(i) && ex.test(i)) {\n\tle = false;\n\tbreak;\n    }\n    if (le) cnt++;\n\n    cnt %= MOD;\n    printf(\"%lld\\n\", cnt);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nlong long int N, lb, a, z;\nbitset<4444> A[7], X, Y, Z;\nchar s[4444];\n \ntemplate <size_t N>\nlong long to_modllong(bitset<N> n){\n    long long ret = 0;\n    for(int i = N; --i >= 0;ret += n[i]){\n        ret <<= 1;\n        ret %= 998244353;\n    }\n    return ret;\n}\n \ntemplate <typename T>\nstatic inline T gcd(T u, T v){\n    int sftu = 0, sftv = 0;\n    T t;\n    if(u.none()) return v;\n    if(v.none()) return u;\n    while(!u[0]){\n        ++sftu;\n        u >>= 1;\n    }\n    while(!v[0]){\n        ++sftv;\n        v >>= 1;\n    }\n    sftu = min(sftu, sftv);\n    do{\n        while(!v[0])v >>= 1;\n        swap(u, v);\n        v = v ^ u;\n    }while(v.any());\n    return u << sftu;\n}\n \nint main(){\n    scanf(\"%lld %s\", &N, s);\n    X = bitset<4444>(s);\n    Z = X;\n    for(int i = 0; i < N; ++i){\n        scanf(\" %s\", s);\n        A[i] = bitset<4444>(s);\n    }\n    Y = A[0];\n    for(int i = 1; i < N; ++i)Y = gcd(A[i], Y);\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (lb = i))break;\n    for(int i = 4443 - lb; i >= 0; --i){\n        if(X[i + lb]){\n            X ^= Y << i;\n            A[6] ^= Y << i;\n        }\n    }\n    if(lb < 64){\n        a = (A[6] & ~(Z & A[6])).to_ullong();\n        z = (Z & ~(Z & A[6])).to_ullong();\n        cout << (to_modllong(Z >> lb) + (a <= z)) % 998244353 << endl;\n    }else{\n        long long d;\n        Y = A[6] ^ Z;\n        for(int i = 4443; i >= 0; --i)if(Y[i] && (d = i))break;\n        cout << (to_modllong(Z >> lb) + (d >= 0 || Z[d])) % 998244353 << endl;\n \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << endl\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/2;\nconst ll MOD = 998244353;\n\ninline ll add(ll a, ll b, ll M) { // a + b (mod M)\n    return (a += b) >= M ? a - M : a;\n}\ninline ll sub(ll a, ll b, ll M) { // a - b (mod M)\n    return (a -= b) < 0 ? a + M : a;\n}\ninline ll mul(ll a, ll b, ll M) { // a * b (mod M)\n    ll r = a*b - (ll)((long double)(a)*b/M+.5)*M;\n    return r < 0 ? r + M: r;\n}\ninline ll div(ll a, ll b, ll M) { // solve b x == a (mod M)\n    ll u = 1, x = 0, s = b, t = M;\n    while (s) { // extgcd for b x + M s = t\n        ll q = t / s;\n        swap(x -= u * q, u);\n        swap(t -= s * q, s);\n    }\n    if (a % t) return -1; // infeasible\n    return mul(x < 0 ? x + M : x, a / t, M); // b (xa/t) == a (mod M)\n}\ninline ll pow(ll a, ll b, ll M) {\n    ll x = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) x = (a * x) % M;\n        a = (a * a) % M;\n    }\n    return x;\n}\n\n// p(x) = p[0] + p[1] x + ... + p[n-1] x^n-1\n// assertion: p.back() != 0\ntypedef vector<ll> poly;\nostream& operator<<(ostream &os, const poly &p) {\n    bool head = true;\n    for (size_t i = 0; i < p.size(); ++i) {\n        if (p[i] == 0) continue;\n        if (!head) os << \" + \";\n        os << p[i];\n        head = false;\n        if (i >= 1) os << \" x\";\n        if (i >= 2) os << \"^\" << i;\n    }\n    return os;\n}\ninline poly add(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = add(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\ninline poly sub(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = sub(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\n\n\n/*\n// FFT-based multiplication: this works correctly for M in [int]\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root, int sign>\ninline void fmt(vector<ll>& x) {\n    const int n = x.size();\n    int h = pow(primitive_root, (mod-1)/n, mod);\n    if (sign < 0) h = div(1, h, mod);\n    for (int i = 0, j = 1; j < n-1; ++j) {\n        for (int k = n >> 1; k > (i ^= k); k >>= 1);\n        if (j < i) swap(x[i], x[j]);\n    }\n    for (int m = 1; m < n; m *= 2) {\n        ll w = 1, wk = pow(h, n / (2*m), mod);\n        for (int i = 0; i < m; ++i) {\n            for (int s = i; s < n; s += 2*m) {\n                ll u = x[s], d = x[s + m] * w % mod;\n                if ((x[s] = u + d) >= mod) x[s] -= mod;\n                if ((x[s + m] = u - d) < 0) x[s + m] += mod;\n            }\n            w = w * wk % mod;\n        }\n    }\n    if (sign < 0) {\n        ll inv = div(1, n, mod);\n        for (auto &a: x)\n            a = a * inv % mod;\n    }\n}\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root>\ninline vector<ll> conv(vector<ll> a, vector<ll> b){\n    fmt<mod,primitive_root,+1>(a); fmt<mod,primitive_root,+1>(b);\n    for (size_t i = 0; i < a.size(); ++i)\n        a[i] = a[i] * b[i] % mod;\n    fmt<mod,primitive_root,-1>(a);\n    return a;\n}\n// general convolution where mod < 2^31.\ninline vector<ll> conv(vector<ll> a, vector<ll> b, ll mod){\n    int n = a.size() + b.size() - 1;\n    for (int k: {1,2,4,8,16}) n |= (n >> k);\n    ++n;\n    a.resize(n); b.resize(n);\n    const int A = 167772161, B = 469762049, C = 1224736769, D = (ll)(A) * B % mod;\n    if(mod==A)return conv<A,3>(a,b);\n    if(mod==B)return conv<B,3>(a,b);\n    if(mod==C)return conv<C,3>(a,b);\n    if(mod==924844033)return conv<924844033,5>(a,b);\n    vector<ll> x = conv<A,3>(a,b), y = conv<B,3>(a,b), z = conv<C,3>(a,b);\n    for (size_t i = 0; i < x.size(); ++i) {\n        ll X = (y[i] - x[i]) * 104391568;\n        if ((X %= B) < 0) X += B;\n        ll Y = (z[i] - (x[i] + A * X) % C) * 721017874;\n        if ((Y %= C) < 0) Y += C;\n        x[i] += A * X + D * Y;\n        if ((x[i] %= mod) < 0) x[i] += mod;\n    }\n    x.resize(n);\n    return x;\n}\n\ninline poly mul(poly p, poly q, ll M) {\n    poly pq = conv(p, q, M);\n    pq.resize(p.size() + q.size() - 1);\n    while (!pq.empty() && !pq.back()) pq.pop_back();\n    return pq;\n}\n*/\nnamespace FFT {\n    const int max_base = 19, maxN = 1 << max_base; // N <= 2e5\n    const double PI = acos(-1);\n    struct num {\n        double x{}, y{};\n        num() = default;\n        num(double x,double y): x(x), y(y) {}\n        explicit num(double r): x(cos(r)), y(sin(r)) {}\n    };\n    inline num operator+(num a, num b) { return {a.x + b.x, a.y + b.y}; }\n    inline num operator-(num a, num b) { return {a.x - b.x, a.y - b.y}; }\n    inline num operator*(num a, num b) { return {a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x}; }\n    inline num conj(num a) {return {a.x, -a.y}; }\n    num root[maxN];\n    int rev[maxN];\n    bool is_root_prepared = false;\n\n    inline void prepare_root(){\n        if(is_root_prepared) return;\n        is_root_prepared = true;\n        root[1] = num(1, 0);\n        for (int i = 1; i < max_base; ++i) {\n            num x(2*PI / (1LL << (i+1)));\n            for (ll j = (1LL << (i-1)); j < (1LL << (i)); ++j) {\n                root[2*j] = root[j];\n                root[2*j+1] = root[j]*x;\n            }\n        }\n    }\n\n    int base=1, N=2;\n    int lastN = -1;\n\n    inline void prepare_rev(){\n        if(lastN == N) return;\n        lastN = N;\n        for (int i = 0; i < N; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (base - 1));\n    }\n\n    inline void fft(num *a, num *f){\n        for (int i = 0; i < N; ++i) f[i] = a[rev[i]];\n        for (int k = 1; k < N; k <<= 1) {\n            for (int i = 0; i < N; i += 2*k) {\n                for (int j = 0; j < k; ++j) {\n                    num z = f[i+j+k]* root[j+k];\n                    f[i+j+k] = f[i+j] - z;\n                    f[i+j] = f[i+j] + z;\n                }\n            }\n        }\n    }\n    num a[maxN], b[maxN], f[maxN], g[maxN];\n    ll A[maxN], B[maxN], C[maxN];\n\n    inline void multi_mod(int m){\n        for (int i = 0; i < N; ++i) {\n            ll x = A[i] % m;\n            a[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        for (int i = 0; i < N; ++i) {\n            ll x = B[i] % m;\n            b[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            int j = (N-i) &(N-1);\n            num a1 = (f[i] + conj(f[j])) * num(0.5, 0);\n            num a2 = (f[i] - conj(f[j])) * num(0, -0.5);\n            num b1 = (g[i] + conj(g[j])) * num(0.5/N, 0);\n            num b2 = (g[i] - conj(g[j])) * num(0, -0.5/N);\n            a[j] = a1*b1 + a2*b2 * num(0, 1);\n            b[j] = a1*b2 + a2*b1;\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            ll aa = f[i].x + 0.5;\n            ll bb = g[i].x + 0.5;\n            ll cc = f[i].y + 0.5;\n            C[i] = (aa + bb % m * (1LL << 15) + cc% m *(1LL << 30)) % m;\n        }\n    }\n\n    inline void prepare_AB(int n1, int n2){\n        if(N > n1+n2){\n            base = 1;\n            N = 2;\n        }\n        while(N < n1+n2) base++, N <<= 1;\n        for (int i = n1; i < N; ++i) A[i] = 0;\n        for (int i = n2; i < N; ++i) B[i] = 0;\n        prepare_root();\n        prepare_rev();\n    }\n\n    inline void multi_mod(int n1, int n2, int m){\n        prepare_AB(n1, n2);\n        multi_mod(m);\n    }\n}\ninline poly mul(poly A, poly B,int M){\n    while(!A.empty()&&!A.back())A.pop_back();\n    while(!B.empty()&&!B.back())B.pop_back();\n    poly C(A.size() + B.size()-1);\n    for (size_t i = 0; i < A.size(); ++i) FFT::A[i] = A[i];\n    for (size_t i = 0; i < B.size(); ++i) FFT::B[i] = B[i];\n    FFT::multi_mod(A.size(), B.size(), M);\n    for (size_t i = 0; i < C.size(); ++i) C[i] = FFT::C[i];\n    while(!C.empty()&&!C.back())C.pop_back();\n    return C;\n}\n\n\ninline pair<poly,poly> divmod(poly p, poly q, ll M) {\n    if (p.size() < q.size()) return { {}, p };\n    reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    poly t = {div(1, q[0], M)};\n    if (t[0] < 0) return { {}, {} }; // infeasible\n    for (size_t k = 1; k <= 2*(p.size()-q.size()+1); k *= 2) {\n        poly qq=q;\n        if(k+1<q.size())qq.resize(k+1);\n        while (!qq.empty() && !qq.back()) qq.pop_back();\n        poly s = mul(mul(t, t, M), qq, M);\n        t.resize(k);\n        for (size_t i = 0; i < k; ++i)\n            t[i] = sub(2*t[i], s[i], M);\n    }\n    t.resize(p.size() - q.size() + 1);\n    poly pp=p;\n    pp.resize(p.size() - q.size() + 1);\n    while (!pp.empty() && !pp.back()) pp.pop_back();\n    t = mul(t, pp, M);\n    t.resize(p.size() - q.size() + 1);\n    reverse(t.begin(),t.end()); reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    while (!t.empty() && !t.back()) t.pop_back();\n    return {t, sub(p, mul(q, t, M), M) };\n}\npoly gcd(poly p, poly q, ll M) {\n    for (; !p.empty(); swap(p, q = divmod(q, p, M).second)){\n      while(!p.empty()&&!p.back())p.pop_back();\n      while(!q.empty()&&!q.back())q.pop_back();\n    }\n    while(!q.empty()&&!q.back())q.pop_back();\n    return q;\n}\n\n#include <ctime>\ndouble tick() {\n  static clock_t oldtick;\n  clock_t newtick = clock();\n  double diff = 1.0*(newtick - oldtick) / CLOCKS_PER_SEC;\n  oldtick = newtick;\n  return diff;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  //tick();\n  ll N;cin>>N;\n  string X;cin>>X;reverse(X.begin(),X.end());\n  string A;cin>>A;reverse(A.begin(),A.end());\n  poly g(A.length());\n  for(size_t i=0;i<A.length();i++){\n    g[i]=A[i]-'0';\n  }\n  //debug(g);\n  for(ll i=1;i<N;i++){\n    cin >> A;\n    reverse(A.begin(),A.end());\n    poly p(A.length());\n    for(size_t i=0;i<A.length();i++){\n      p[i]=A[i]-'0';\n    }\n    g=gcd(p,g,2);\n  }\n  //debug(g);\n  ll ans=0;\n  size_t d=g.size();\n  //debug(d);\n  poly q(X.length(),0);\n  ll pw=1;\n  for(size_t i=d-1;i<X.length();i++){\n    q[i]=X[i]-'0';\n    if(X[i]>'0')ans = (ans+pw)%MOD;\n    pw = pw*2%MOD;\n  }\n  //debug(q);\n  poly r=divmod(q,g,2).second;\n  bool isok=true;\n  for(size_t i=X.length()-1;i>=d;i--){\n    if(r[i]==X[i]-'0')continue;\n    isok = r[i]<X[i]-'0';\n    break;\n  }\n  ans = (ans+isok)%MOD;\n  cout<<ans<<endl;\n  //debug(tick());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 998244353;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\nconst ll len = 4010;\ntypedef bitset<len> bs;\nnamespace SOLVE {\n    bs gcd(bs a, bs b){\n        while (a.count() and b.count()) {\n            int h[2] = {0,0};\n            REP(i,0,len){\n                if(a[i])h[0] = i;\n                if(b[i])h[1] = i;\n            }\n            if(h[0]<=h[1]){\n                b^=a<<(h[1]-h[0]);\n            }else{\n                a^=b<<(h[0]-h[1]);\n            }\n        }\n        if(a.count())return a;\n        return b;\n    }\n    bs g,x;\n    int get_deg(bs x){\n        RREP(i,len-1,0)if(x[i])return i;\n        return -1;\n    }\n    bool operator<(const bs&a,const bs&b){\n        RREP(i,len-1,0)if(a[i]!=b[i])return a[i]<b[i];\n        return false;\n    }\n    ll ans = 0;\n    void main(){\n        int n;\n        cin>>n>>x;\n\n        REP(i,0,n){\n            bs b;\n            cin>>b;\n            g = gcd(b, g);\n        }\n        int deg = get_deg(g);\n        RREP(i,len-1,deg){\n            if(x[i]){\n                ans += fast(2, i-deg, mod);\n            }\n        }\n//        dbg(x.to_string());\n//        dbg(g.to_string());\n        ans++;\n        cout<< MOD(ans,mod)<<endl;\n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=998244353;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing BS = bitset<4000>;\n\nint N;\nstring X;\nLL pw2[4010];\nBS A[6];\nBS bases[4010];\n\nvoid Add(LL &t, LL v) {\n  t += v;\n  while (t >= MOD) t -= MOD;\n}\n\nBS MakeBitset(string &s) {\n  BS ret;\n  int idx = 3999;\n  rrep(i, s.size()) {\n    if (s[i] == '1') ret[idx] = 1;\n    else if (s[i] == '0') ret[idx] = 0;\n    else assert(0);\n    idx--;\n  }\n  return ret;\n}\n\nint RegBase(BS &v) {\n  while (1) {\n    int idx = v._Find_first();\n    if (idx == v.size()) {\n      assert(v.count() == 0);\n      return -1;\n    }\n\n    if (bases[idx].count() == 0) {\n      bases[idx] = v;\n      return idx;\n    }\n\n    v ^= bases[idx];\n    assert(v._Find_first() > idx);\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  cin >> N >> X;\n  rep(i, N) {\n    string s;\n    cin >> s;\n    A[i] = MakeBitset(s);\n  }\n\n  int idx = A[0]._Find_first();\n  BS v = A[0];\n  while (1) {\n    int res = RegBase(v);\n    assert(res == idx);\n    if (res == -1) break;\n    v = bases[res] >> 1;\n    if (idx == 0) break;\n    idx--;\n  }\n\n  reps(i, 1, N) {\n    v = A[i];\n    idx = A[i]._Find_first();\n    while (1) {\n      int res = RegBase(v);\n      if (res == -1) break;\n      v = bases[res] >> 1;\n    }\n  }\n\n  int m = 0;\n  pw2[0] = 1;\n  rep(i, 4000) {\n    if (bases[i].count()) m++;\n    if (i > 0) pw2[i] = pw2[i-1]*2 % MOD;\n  }\n\n  X = string(4000-X.size(), '0') + X;\n  assert(X.size() == 4000);\n\n  BS cur;\n  LL ans = 1;\n  rep(i, 4000) {\n    if (!bases[i].count()) {\n      if (cur[i] > X[i]-'0') {\n        //auto s = cur.to_string().substr(0, 20);\n        //reverse(all(s));\n        //cout << s << endl;\n        //cout << X.substr(3980) << endl;\n        Add(ans, MOD-1);\n        break;\n      } else if (cur[i] < X[i] - '0') {\n        Add(ans, pw2[m]);\n        Add(ans, MOD-1);\n        break;\n      }\n    }\n\n    if (X[i] == '1') {\n      if (m > 0) Add(ans, pw2[m-1]);\n      if (!cur[i]) cur ^= bases[i];\n    } else if (X[i] == '0') {\n      if (cur[i]) cur ^= bases[i];\n    }\n\n    --m;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bitset>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\nbitset <N> x, y, G, a[10];\nint n;\n\nbitset <N> gcd(bitset <N> A, bitset <N> B)\n{\n    int i = N - 1, j = N - 1;\n    while(1)\n    {\n        for(; ~i && !A[i]; --i);\n        for(; ~j && !B[j]; --j);\n        if (i == -1) return B;\n        if (j == -1) return A;\n        if (i > j) A ^= (B << (i - j));\n            else B ^= (A << (j - i));\n    }\n}\n\nint div(bitset <N> A, bitset <N> B)\n{\n    int i = N - 1, j = N - 1, ans = 0;\n    for(; ~j && ~B[j]; --j);\n    for(; i >= j; --i)\n    {\n        ans = (ans * 2 + (A[i] ? 1 : 0)) % mod;\n        if (A[i] != y[i]) y[i] ^= B << (i - j);\n    }\n    for(int i = N - 1; ~i; --i) if (A[i] < y[i])\n    {\n        ans = (ans - 1 + mod) % mod;\n        break;\n    }\n    else if (A[i] > y[i]) break;\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> x;\n    FOR(i, 1, n) cin >> a[i];\n    G = a[1];\n    FOR(i, 2, n) G = gcd(G, a[i]);\n    printf(\"%d\\n\", (div(x, G) + 1) % mod);\n    return 0;\n}\n;\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[4009];\nstruct bin{\n\tbitset<4009> bit;\n\tint L;\n\tvoid inp(){\n\t\tscanf(\"%s\",s);\n\t\tL = strlen(s);\n\t\treverse(s,s+L);\n\t\t--L;\n\t\tfor(int i=0; i<=L; i++)if(s[i] == '1')\n\t\t\tbit.set(i);\n\t\telse\n\t\t\tbit.reset(i);\n\t}\n\tvoid add1(){\n\t\tfor(int i=0; i<=L+1; i++)if(bit.test(i))bit.reset(i);else{\n\t\t\tbit.set(i);\n\t\t\tbreak;\n\t\t}\n\t\tif(bit.test(L+1))++L;\n\t}\n\tvoid out(){\n\t\tprintf(\"##\");\n\t\tif(L==-1)printf(\"0\\n\");else{\n\t\t\tfor(int i=L; i>=0; i--)printf(\"%d\",bit.test(i));\n\t\t\tputs(\"\");\n\t\t}\n\t}\n};\n\nint n;\nbin Y,X,Z;\n\nbool gaussian(bin&A, bin&B, bin&C){\n\tC = B;\n\tif(A.L > B.L){\n\t\treturn true;\n\t}\n\tint dif = B.L - A.L;\n\tbin g = A;\n\tg.bit <<= dif;\n\tg.L += dif;\n\twhile(dif >= 0){\n\t\tif(C.bit.test(C.L))\n\t\t\tC.bit ^= g.bit;\n\t\tg.bit >>= 1;\n\t\tC.L--;\n\t\tdif--;\n\t}\n\twhile(C.L >=0 && !C.bit.test(C.L))C.L--;\n\treturn C.L >= 0;\n}\n\nbin gcd(bin A, bin B){\n\tbin C;\n\tif(!gaussian(A, B, C))return A;\n\treturn gcd(C,A);\n}\n\n#define mod 998244353\nint add(int x,int y){return (x+=y)<mod?x:x-mod;}\nint mul(int x,int y){return (int)((long long int)(x)*y%mod);}\nint p2[4009];\nint main(){\n\tscanf(\"%d\",&n);\n\tX.inp();X.add1();\n\tY.inp();\n\tfor(int i=1; i<n; i++){\n\t\tZ.inp();\n\t\tY = gcd(Y, Z);\n\t}\n\tp2[0] = 1;\n\tfor(int i=1; i<=X.L; i++)p2[i] = add(p2[i-1],p2[i-1]);\n\tbin cur = Y;\n\tint res= 0;\n\tfor(int i=X.L; i>=0; i--){\n\t\tif(!X.bit.test(i))continue;\n\t\tif(i >= cur.L){\n\t\t\tres=add(res, p2[i - cur.L]);\n\t\t\tcontinue;\n\t\t}\n\t\tbin B;\n\t\tgaussian(cur, X, B);\n\t\tB.bit ^= X.bit;\n\t\tbool ff = false;\n\t\tfor(int j=cur.L-1; j>=0; j--)if(B.bit.test(j) ^ X.bit.test(j)){\n\t\t\tif(!B.bit.test(j) && X.bit.test(j))\n\t\t\t\tff = true;\n\t\t\tbreak;\n\t\t}\n\t\tif(ff)res=add(res,1);\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<bitset>\n#include<cstdio>\n#define MN 4000\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,ans,pw[MN+5];\nchar s[MN+5],t[8][MN+5];\nbitset<MN+5> b[8],g,a;\nbitset<MN+5> gcd(const bitset<MN+5>&a,const bitset<MN+5>&b,int d,int D)\n{\n\twhile(d&&!a[d-1]) --d;while(D&&!b[D-1]) --D;\n\tif(!d) return b;if(!D) return a;\t\n\tif(d<=D) return gcd(a,(a<<D-d)^b,d,D);\n\telse return gcd(b,(b<<d-D)^a,D,d);\n}\nint main()\n{\n\tn=read();scanf(\"%s\",s+1); \n\tfor(int i=1;i<=n;++i) scanf(\"%s\",t[i]+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint d=strlen(t[i]+1);\n\t\tfor(int j=0;j<d;++j) b[i][j]=t[i][d-j]-'0';\t\n\t}\n\tg=b[1];for(int i=2;i<=n;++i) g=gcd(g,b[i],MN,MN);\n\tint deg=MN,len=strlen(s+1);for(;!g[deg-1];) --deg;pw[0]=1;\n\tfor(int i=1;i<=len;++i) pw[i]=2*pw[i-1]%mod;\n\tfor(int i=1;i<=len;++i)\n\t{\n\t\tbitset<MN+5> nx;int flag=0; \n\t\tif(!(s[i]=='0'&&a[len-i]))\n\t\t{\n\t\t\tif(a[len-i]<s[i]-'0') (ans+=pw[max(0,len-deg+1-i)])%=mod;\n\t\t\telse nx=a,flag=1;\n\t\t}\n\t\tif(i+deg-1<=len&&!(s[i]=='0'&&!a[len-i]))\n\t\t{\n\t\t\tif((a[len-i]^1)<s[i]-'0') (ans+=pw[max(0,len-deg+1-i)])%=mod;\n\t\t\telse nx=a,flag=1;\t\n\t\t}\n\t\tif(!flag) {--ans;break;} else a=nx;\n\t}\n\tcout<<(ans+1)%mod;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef bitset<4010> B;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nll POW[4002];\nvoid init(){\n\tPOW[0] = 1;\n\tfor(int i = 0 ; i < 4001 ; i ++){\n\t\tPOW[i+1] = POW[i]*2;\n\t\tif(POW[i+1] >= MOD)POW[i+1] -= MOD;\n\t}\n}\n\nint find_last(B x){\n\tfor(int i = 4009 ; i >= 0 ; i --){\n\t\tif(x[i])return i;\n\t}\n\treturn -1;\n}\n\nB gcd(B x,B y){\n\tif(x.none())return y;\n\tint s = find_last(x);\n\tint t = find_last(y);\n\tif(s < t){\n\t\tswap(x,y);\n\t\tswap(s,t);\n\t}\n\twhile(y.any()){\n\t\tx ^= y<<(s-t);\n\t\ts = find_last(x);\n\t\tif(s < t){\n\t\t\tswap(x,y);\n\t\t\tswap(s,t);\n\t\t}\n\t}\n\treturn x;\n}\n\nint main(){\n\tinit();\n\tint n;\n\tB x,a[7];\n\tcin >> n;\n\tcin >> x;\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tcin >> a[i];\n\t}\n\t\n\tfor(int i = 1 ; i < n ; i ++){\n\t\ta[0] = gcd(a[0],a[i]);\n\t}\n\t\n\tll ret = 0;\n\tint s = find_last(x);\n\tint t = find_last(a[0]);\n\tB y; y.reset();\n\t\n\tfor(int i = s ; i >= t ; i --){\n\t\tif(x[i])ret += POW[i-t];\n\t\tif(x[i] != y[i])y ^= a[0] << (i-t);\n\t}\n\tfor(int i = s ; i >= 0 ; i --){\n\t\tif(x[i] == y[i]){\n\t\t\tif(i == 0)ret ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(x[i])ret ++;\n\t\tbreak;\n\t}\n\tcout << ret%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4010;\ntypedef bitset<N>B;\ntypedef long long ll;\nconst int mod=998244353;\nll p[N];\nvoid init()\n{\n    p[0]=1;\n    for(int i=1;i<N;i++) p[i]=p[i-1]*2%mod;\n}\nint last(B x)\n{\n    for(int i=N-1;i>=0;i--)\n        if(x[i]) return i;\n    return -1;\n}\nB gcd(B x,B y)\n{\n    if(x.none()) return y;\n    if(y.none()) return x;\n    int a=last(x),b=last(y);\n    if(a<b) swap(x,y),swap(a,b);\n    return gcd(y,x^(y<<a-b));\n}\nint n;\nB x,y,a[7];\nint main()\n{\n    init();\n    cin>>n>>x;\n    for(int i=0;i<n;i++) cin>>a[i];\n    for(int i=1;i<n;i++) a[0]=gcd(a[0],a[i]);\n    ll ans=0;\n    int s=last(x),t=last(a[0]);\n    y.reset();\n    for(int i=s;i>=t;i--)\n    {\n        if(x[i]) ans=(ans+p[i-t])%mod;\n        if(x[i]!=y[i]) y^=a[0]<<(i-t);\n    }\n    for(int i=s;i>=0;i--)\n    {\n        if(x[i]==y[i])\n        {\n            if(i==0) ans++;\n            continue;\n        }\n        if(x[i]) ans++;\n        break;\n    }\n    printf(\"%lld\\n\",ans%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 4001, mod = 998244353;\n\nint n;\nvector<bitset<N> > a;\nbitset<N> k;\n\nstring in;\n\nint sz (bitset<N> &T) {\n\tfor(int i=N;i--;) {\n\t\tif(T[i] == 1) return i+1;\n\t}\n\treturn 0;\n}\n\nint val (bitset<N> T) {\n\tint R = 0;\n\tfor(int i=N;i--;) {\n\t\tR = (2*R + T[i]) % mod;\n\t}\n\treturn (R + 1) % mod;\n}\n\nbool cmp (bitset<N> A, bitset<N> B) {\n\tfor(int i=N;i--;) {\n\t\tif(A[i] < B[i]) return true;\n\t\tif(A[i] > B[i]) return false;\n\t}\n\treturn false;\n}\n\nvoid elim (bitset<N> &A, bitset<N> &B) {\n\tint S = sz(B)-1;\n\tfor(int i=N-1;i>=S;i--) {\n\t\tif(A[i] == 1) A ^= (B << (i-S));\n\t}\n}\n\nint main()\n{\n\tcin >> n >> in;\n\tk = bitset<N>(in);\n\tfor(int i=1;i<=n;i++) {\n\t\tcin >> in;\n\t\ta.push_back(bitset<N>(in));\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tif(sz(a[0]) > sz(a[i])) {\n\t\t\tswap(a[0], a[i]);\n\t\t}\n\t}\n\twhile(a.size() > 1) {\n\t\tauto &A = a[0], &B = a.back(), T = B;\n\t\telim(B, A);\n\t\tswap(A, B);\n\t\tif(sz(A) == 0) {\n\t\t\tA = T;\n\t\t\tswap(A, B);\n\t\t\ta.pop_back();\n\t\t}\n\t}\n\tauto T = k;\n\telim(T, a[0]);\n\tcout << (val(k>>(sz(a[0])-1)) + mod - cmp(k, k^T)) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353;\n\nll n;\nvector<bool> x;\nvector<bool> a,b;\n\nvoid mns(){\n    for(ll i=(int)a.size()-1;i>=(int)b.size()-1;i--){\n        if(a[i]==1){\n            for(int t=0;t<b.size();t++){\n                a[i-t]=a[i-t]^b[b.size()-t-1];\n            }\n        }\n    }\n    while(!a.empty() && a.back()==0){a.pop_back();}\n    swap(a,b);\n}\n\n\n\n\n\n\n\n\nint main(){\n    vector<ll> P(1000000,1);\n    for(ll i=1;i<P.size();i++){P[i]=P[i-1]*2%MOD;}\n    cin>>n;\n    string X;\n    cin>>X;\n    reverse(X.begin(),X.end());\n    x.resize(X.size());\n    for(int i=0;i<X.size();i++){\n        x[i]=X[i]-'0';\n    }\n    string A;\n    cin>>A;\n    reverse(A.begin(),A.end());\n    a.resize(A.size());\n    for(int i=0;i<A.size();i++){\n        a[i]=A[i]-'0';\n    }\n    for(int i=1;i<n;i++){\n        string B;\n        cin>>B;\n        reverse(B.begin(),B.end());\n        b.resize(B.size());\n        for(int i=0;i<B.size();i++){\n            b[i]=B[i]-'0';\n        }\n        if(a.size()<b.size()){swap(a,b);}\n        while(b.size()){mns();}\n    }\n    ll ans=0;\n    vector<bool> Z(x.size(),false);\n    for(ll i=(int)x.size()-1;i>=(int)a.size()-1;i--){\n        if(x[i]){\n            ans+=P[i-(a.size()-1)];\n            ans%=MOD;\n            if(Z[i]==0){\n                for(int t=0;t<a.size();t++){\n                    Z[i-t]=Z[i-t]^a[a.size()-1-t];\n                }\n            }\n        }\n        else{\n            if(Z[i]){\n                for(int t=0;t<a.size();t++){\n                    Z[i-t]=Z[i-t]^a[a.size()-1-t];\n                }\n            }\n        }\n    }\n    bool j=true;\n    for(ll i=x.size()-1;i>=0;i--){\n        if(x[i]==false && Z[i]==true){j=false;}\n        if(x[i]==true && Z[i]==false){break;}\n    }\n    if(j){ans++;}\n    cout<<ans%MOD<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\n\n\ntemplate<const std::size_t N>\nstruct bfps: public std::bitset<N> {\n  using size_type = std::size_t;\n  size_type len;\n\n  void recalc() {\n    this->len = 0;\n    for(i64 j = N; j --> 0;) {\n      if((*this)[j]) {\n        this->len = j + 1;\n        return;\n      }\n    }\n  }\n\n  bfps() : std::bitset<N>() { this->len = 0; }\n  //bfps(const std::uint_fast64_t x) : std::bitset<N>(x) { recalc(); }\n  bfps(const std::bitset<N>& b) : std::bitset<N>(b) { recalc(); }\n  size_type size() const { return this->len; }\n\n\n  static bfps mod(bfps a, const bfps& b) {\n    assert(b.size() > 0);\n    for(i64 i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static bfps div(bfps a, const bfps& b) {\n    assert(b.size() > 0);\n    bfps d;\n    for(i64 i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        bfps e;\n        e[i] = 1;\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static bfps gcd(bfps a, bfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = b;\n      b = m;\n    }\n    return a;\n  }\n};\n\nconst int BN = 4000;\nusing bits = bfps<BN>;\n\nint main() {\n  i64 N;\n  cin >> N;\n  bits X;\n  cin >> X;\n  X.recalc();\n\n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    bool OK = true;\n    for(i64 i = BN; i --> 0; ) {\n      if(now[i] != X[i]) {\n        if(now[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    if(OK) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v, w; };\n\nvector<int> gcd(vector<int> s, vector<int> t) {\n\tint N = s.size(), M = t.size();\n\tif (N < M) return gcd(t, s);\n\tif (!M) return s;\n\trep(j, M) s[j] ^= t[j];\n\tint l = N;\n\trep(i, N) if (s[i]) {\n\t\tl = i;\n\t\tbreak;\n\t}\n\tvector<int> a(N - l);\n\trep(i, N - l) a[i] = s[l + i];\n\treturn gcd(t, a);\n}\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n >>= 1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint N; cin >> N;\n\tstring s; cin >> s;\n\tvector<string> a(N);\n\trep(i, N) cin >> a[i];\n\tvector<int> d;\n\trep(i, N) {\n\t\tint M = a[i].length();\n\t\tvector<int> b(M);\n\t\trep(j, M) b[j] = a[i][j] - '0';\n\t\td = gcd(d, b);\n\t}\n\tint n = s.length();\n\tvector<int> c(n), _c(n);\n\trep(i, n) c[i] = s[i] - '0';\n\tint m = d.size();\n\tint ans = 1;\n\tfor (int i = 0; i + m <= n; i++) {\n\t\tif (c[i]) ans = (ans + pow_mod(2, n - m - i, MOD)) % MOD;\n\t\tif (c[i] == _c[i]) continue;\n\t\trep(j, m) _c[i + j] ^= d[j];\n\t}\n\tbool ok = true;\n\trep(i, n) if (c[i]) ok = false;\n\tif (ok) ans = (ans + MOD + 1) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\t \nusing namespace std;\n\t \ntypedef long long LL;\ntypedef double db;\n\t \nconst int L = 8005;\nconst int N = 8005;\nconst int mo = 998244353;\n \nbitset<L>a[N],Lim;\nint n;\nint key[N];\nLL mi[L];\n \nvoid getbit(bitset<L> &a){\n\tchar s[L];\n\tscanf(\"%s\",s+1);\n\tint len=strlen(s+1);\n\tfo(i,0,len-1)a[i]=s[len-i]-'0';\n}\n \nbitset<L> trs(bitset<L> a,bitset<L> b){\n\tint wa,wb;\n\tfd(i,4000,0)if (a[i]){wa=i;break;}\n\tfd(i,4000,0)if (b[i]){wb=i;break;}\n\tif (wa<wb)swap(a,b),swap(wa,wb);\n\twhile(wb>-1){\n\ta=a^(b<<(wa-wb));\n\t\tbool fd=0;\n\t\tfd(i,wa,0)if (a[i]){wa=i;fd=1;break;}\n\t\tif (!fd)wa=-1;\n\t\tif (wa<wb)swap(a,b),swap(wa,wb);\n\t}\n\treturn a;\n}\n\t \nint main(){\n\tmi[0]=1;\n\tfo(i,1,4000)mi[i]=mi[i-1]*2%mo;\n\tscanf(\"%d\",&n);\n\tgetbit(Lim);\n\tfo(i,1,n)getbit(a[i]);\n\tint n_=0;\n\tfo(i,1,n){\n\t\tfo(j,1,i-1)\n\t\tif (a[i][key[j]])a[i]=a[i]^a[j];\n\t\tint w=-1;\n\t\tfd(x,4000,0)if (a[i][x]){w=x;break;}\n\t\tkey[i]=w;\n\t\tif (w!=-1){\n\t\t\tkey[++n_]=w;\n\t\t\ta[n_]=a[i];\n\t\t}\n\t}\n\tn=n_;\n\tint pre=0;\n\tfor(bool pd=1;pd;){\n\t\tint pn=n;\n\t\tpd=0;\n\t\tint w=(pre==0)?n:pre;\n\t\tfo(i,1,w)\n\t\t\tfo(j,pre+1,pn)\n\t\t\tif (i!=j){\n\t\t\t\tbitset<L> now=trs(a[i],a[j]);\n\t\t\t\tfo(p,1,n)\n\t\t\t\tif (now[key[p]])now=now^a[p];\n\t\t\t\tif (now.count()>0){\n\t\t\t\t\ta[++n]=now;\n\t\t\t\t\tkey[n]=0;\n\t\t\t\t\tfd(x,4000,0)if (now[x]){key[n]=x;break;}\n\t\t\t\t}\n\t\t\t}\n\t\tpre=pn;\n\t}\n\tint keyw=1;\n\tfo(i,2,n)\n\tif (key[i]<key[keyw])keyw=i;\n\tint w=0;\n\tfd(i,4000,0)\n\tif (Lim[i]){w=i;break;}\n\tLL ans=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i])ans=(ans+mi[i-key[keyw]])%mo;\n\tbitset<L>now;\n\tfo(i,0,4000)now=0;\n\tfd(i,w,key[keyw])\n\tif (Lim[i]!=now[i])now=now^(a[keyw]<<(i-key[keyw]));\n\tint prefer=1;\n\tfd(i,key[keyw],0)\n\tif (Lim[i]!=now[i]){\n\t\tif (now[i]>Lim[i])prefer=0;\n\t\tbreak;\n\t}\n\tans=(ans+prefer)%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Ankur Dua\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nusing ll = long long;\nll mod=1000000007;\nll *fact, *ifact;\n\nusing cd = complex<long double>;\nconst long double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        long double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\nvector<ll> multiply(vector<ll> const& a, vector<ll> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size())\n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<ll> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int &cid = ptr[v]; cid < (int) adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n\n//Min cost max flow using dijkstra from https://codeforces.com/contest/1107/submission/49033783\ntemplate<typename flow_t, typename cost_t>\nstruct MinCostMaxFlow {\n    static const flow_t FLOW_INF = numeric_limits<flow_t>::max() / 2;\n    const cost_t COST_INF = numeric_limits<cost_t>::max() / 2;\n    struct edge {\n        int node, rev;\n        flow_t capacity;\n        cost_t cost;\n\n        edge(int _node = -1, int _rev = -1, flow_t _capacity = 0, cost_t _cost = 0)\n                : node(_node), rev(_rev), capacity(_capacity), cost(_cost) {}\n    };\n\n    int V = -1;\n    vector<vector<edge>> adj;\n    vector<cost_t> dist;\n    vector<int> prev;\n    vector<edge*> prev_edge;\n\n    MinCostMaxFlow(int vertices = -1) {\n        if (vertices >= 0)\n            init(vertices);\n    }\n\n    void init(int vertices) {\n        V = vertices;\n        adj.assign(V, {});\n        dist.resize(V);\n        prev.resize(V);\n        prev_edge.resize(V);\n    }\n\n    void addEdge(int u, int v, flow_t capacity, cost_t cost) {\n        edge uv_edge(v, adj[v].size() + (u == v ? 1 : 0), capacity, cost);\n        edge vu_edge(u, adj[u].size(), 0, -cost);\n        adj[u].push_back(uv_edge);\n        adj[v].push_back(vu_edge);\n    }\n\n    edge &reverse_edge(const edge &e) {\n        return adj[e.node][e.rev];\n    }\n\n    bool bellman_ford(int source, int sink) {\n        for (int i = 0; i < V; i++) {\n            dist[i] = COST_INF;\n            prev[i] = -1;\n            prev_edge[i] = nullptr;\n        }\n\n        vector<int> last_seen(V, -1);\n        vector<int> nodes(1, source);\n        dist[source] = 0;\n\n        for (int iteration = 0; iteration < V; iteration++) {\n            vector<int> next_nodes;\n\n            for (int node : nodes)\n                for (edge &e : adj[node])\n                    if (e.capacity > 0 && dist[node] + e.cost < dist[e.node]) {\n                        dist[e.node] = dist[node] + e.cost;\n                        prev[e.node] = node;\n                        prev_edge[e.node] = &e;\n\n                        if (last_seen[e.node] != iteration) {\n                            last_seen[e.node] = iteration;\n                            next_nodes.push_back(e.node);\n                        }\n                    }\n\n            swap(nodes, next_nodes);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    struct dijkstra_state {\n        cost_t dist;\n        int node;\n\n        bool operator<(const dijkstra_state &other) const {\n            return dist > other.dist;\n        }\n    };\n\n    void dijkstra_check(int node, cost_t potential_dist, int previous, edge *previous_edge, auto &pq) {\n        if (potential_dist < dist[node]) {\n            dist[node] = potential_dist;\n            prev[node] = previous;\n            prev_edge[node] = previous_edge;\n            pq.push({dist[node], node});\n        }\n    }\n\n    bool dijkstra(int source, int sink) {\n        dist.assign(V, COST_INF);\n        prev.assign(V, -1);\n        prev_edge.assign(V, nullptr);\n\n        priority_queue<dijkstra_state> pq;\n        dijkstra_check(source, 0, -1, nullptr, pq);\n\n        while (!pq.empty()) {\n            dijkstra_state top = pq.top();\n            pq.pop();\n\n            if (top.dist > dist[top.node])\n                continue;\n\n            for (edge &e : adj[top.node])\n                if (e.capacity > 0)\n                    dijkstra_check(e.node, top.dist + e.cost, top.node, &e, pq);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    void reduce_cost() {\n        for (int i = 0; i < V; i++)\n            for (edge &e : adj[i])\n                e.cost += dist[i] - dist[e.node];\n    }\n\n    pair<flow_t, cost_t> minCostFlow(int source, int sink, flow_t flow_goal = FLOW_INF) {\n        assert(V >= 0);\n\n        if (!bellman_ford(source, sink))\n            return make_pair(0, 0);\n\n        flow_t total_flow = 0;\n        cost_t total_cost = 0;\n        cost_t reduce_sum = 0;\n\n        do {\n            reduce_cost();\n            reduce_sum += dist[sink];\n            flow_t path_cap = flow_goal - total_flow;\n\n            for (int node = sink; prev[node] != -1; node = prev[node])\n                path_cap = min(path_cap, prev_edge[node]->capacity);\n\n            for (int node = sink; prev[node] != -1; node = prev[node]) {\n                edge *e = prev_edge[node];\n                assert(e->cost == 0);\n                e->capacity -= path_cap;\n                reverse_edge(*e).capacity += path_cap;\n            }\n\n            total_flow += path_cap;\n            total_cost += reduce_sum * path_cap;\n        } while (total_flow < flow_goal && dijkstra(source, sink));\n\n        return make_pair(total_flow, total_cost);\n    }\n};\n\nll modExp(ll base, ll exp, ll mod=::mod){\n    ll ans=1;\n    while(exp) {\n        if (exp & 1) {\n            (ans *= base) %= mod;\n        }\n        (base *= base) %= mod;\n        exp>>=1;\n    }\n    return ans;\n}\nll modInv(ll x, ll mod=::mod){\n    return modExp(x,mod-2,mod);\n}\nvoid modFact(ll n, ll mod=::mod){\n    ifact=new ll[n+1];\n    fact=new ll[n+1];\n    fact[0]=fact[1]=1;\n    for(int i=2;i<=n;i++){\n        fact[i]=(i*fact[i-1])%mod;\n    }\n    ifact[n]=modInv(fact[n], mod);\n    for(int i=n-1;i>=0;i--){\n        ifact[i]=((i+1)*ifact[i+1])%mod;\n    }\n}\nll ncr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[r];\n    ans%=mod;\n    ans*=ifact[n-r];\n    ans%=mod;\n    return ans;\n}\nll npr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[n-r];\n    return ans%mod;\n}\nclass DSU{\npublic:\n    int*p, *r;\n    DSU(int n){\n        p=new int[n+50];\n        r=new int[n+50];\n        for(int i=0;i<=n+10;i++){\n            p[i]=i;\n            r[i]=0;\n        }\n    }\n    ~DSU(){\n        delete[] p;\n        delete[] r;\n    }\n    int find(int x){\n        if(p[x]==x)\n            return x;\n        return p[x]=find(p[x]);\n    }\n    bool Unite(int a, int b){\n        a=find(a);\n        b=find(b);\n        if(a==b)\n            return false;\n        if(r[a]<r[b])\n            p[a]=b;\n        else\n            p[b]=a;\n        if(r[a]==r[b])\n            r[a]++;\n        return true;\n    }\n};\nusing namespace std;\nconst int mx=4500;\ntypedef bitset<mx> BS;\nll p2[mx];\nBS b;\nclass ARC84D {\npublic:\n    ll dfs(BS &x,vector<int> &cnt, int bp, bool eq, vector<BS> &basis){\n        if(bp==-1)\n            return 1;\n        if(!eq)\n            return p2[cnt[bp]];\n        ll ans=0;\n        if(x[bp] && b[bp]){\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,false,basis);\n                b^=basis[bp];\n                ans%=mod;\n            }\n        }else if(x[bp] && !b[bp]){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n            ans+=dfs(x,cnt,bp-1,false,basis);\n\n            ans%=mod;\n        }else if((!x[bp]) && (b[bp])){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n        }else{\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n        }\n\n        return ans;\n    }\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        int n;\n        cin>>n;\n\n        string xx;\n        cin>>xx;\n        BS x(xx);\n        vector<BS> basis(mx);\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            BS cur(s);\n\n            do{\n                BS v=cur;\n                for(int j=mx-1;j>=0;j--){\n                    if(v[j] && basis[j][j])\n                        v^=basis[j];\n                    else if(v[j]){\n                        basis[j]=v;\n                        break;\n                    }\n                }\n                if(!cur[mx-1])\n                    cur<<=1;\n                else break;\n            }while(true);\n        }\n        mod=998244353;\n        p2[0]=1;\n        for(int i=1;i<mx;i++){\n            p2[i]=(2*p2[i-1])%mod;\n        }\n        BS least;\n        for(int i=0;i<mx-1;i++){\n            if(basis[i][i]){\n                least=basis[i]<<1;\n                for(int j=i+1;j<mx;j++,least<<=1){\n                    if(!basis[j][j]){\n                        basis[j]=least;\n                    }\n                }\n                break;\n            }\n        }\n        vector<int> cnt(mx);\n        for(int i=0;i<mx;i++)\n            if(basis[i][i])\n                cnt[i]=1;\n        for(int i=1;i<mx;i++)\n            cnt[i]+=cnt[i-1];\n        b=BS();\n        cout<<dfs(x,cnt,mx-1,true,basis)<<endl;\n\t}\n};\n\n\nint main() {\n\tARC84D solver;\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(NULL);\n\tstd::cout.tie(NULL);\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 4010;\nll pow2[4020];\n\nvi bxor(const vi& a, const vi& b) {\n\tvi res(N, 0);\n\trep(i, 0, N) res[i] = (a[i] ^ b[i]);\n\treturn res;\n}\n\nint fbit(const vi& a) { //fbit(0101) = 3\n\trer(i, N, 0) {\n\t\tif(a[i] == 1) return i + 1;\n\t}\n\treturn 0;\n}\n\nvi shift(const vi& a, int k) {\n\tvi res(N, 0);\n\tint fa = fbit(a);\n\tassert(fa + k <= N);\n\trep(i, 0, fa) {\n\t\tres[i + k] = a[i];\n\t}\n\treturn res;\n}\n\nbool is_zero(const vi& a) {\n\trep(i, 0, N) {\n\t\tif(a[i]) return false;\n\t}\n\treturn true;\n}\n\nvi gcd(const vi& a, const vi& b) {\n\tif(is_zero(b)) return a;\n\tvi c = a;\n\twhile(true) {\n\t\tint fc = fbit(c), fb = fbit(b);\n\t\tif(fc < fb) break;\n\t\tint diff = fc - fb;\n\t\tc = bxor(c, shift(b, diff));\n\t}\n\treturn gcd(b, c);\n}\n\nvi stobit(const string& str) {\n\tvector<int> res(N, 0);\n\tint n = sz(str);\n\trep(i, 0, n) {\n\t\tres[n - i - 1] = str[i] - '0';\n\t}\n\treturn res;\n}\n\nint M;\nvi X;\nvi B[10];\n\nvoid solve() {\n\tstring str;\n\tcin >> M >> str;\n\tpow2[0] = 1;\n\trep(i, 1, 4010) pow2[i] = pow2[i - 1] * 2 % mod;\n\tX = stobit(str);\n\trep(i, 0, M) {\n\t\tcin >> str;\n\t\tB[i] = stobit(str);\n\t}\n\tvi g = B[0];\n\trep(i, 0, M - 1) g = gcd(g, B[i + 1]);\n\tint a = fbit(X), b = fbit(g);\n\tvi c(N, 0);\n\tll res = 0;\n\trep(i, 0, (a - b + 1)) {\n\t\tif(X[a - i - 1] == 1) {\n\t\t\tADD(res, pow2[a - b - i]);\n\t\t\tif(c[a - i - 1] == 0) c = bxor(c, shift(g, (a - b - i)));\n\t\t}\n\t\tif(X[a - i - 1] == 0 && c[a - i - 1] == 1) {\n\t\t\tc = bxor(c, shift(g, (a - b - i)));\n\t\t}\n\t}\n\trer(i, N, 0) {\n\t\tif(X[i] == 0 && c[i] == 1) {\n\t\t\tcout << res << \"\\n\";\n\t\t\treturn;\n\t\t}\n\t\telse if(X[i] == 1 && c[i] == 0) {\n\t\t\tcout << (res + 1) % mod << \"\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << (res + 1) % mod << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nusing bits = bitset<4000>;\n\nint main() {\n\n  auto bitlen = [](const bits& a) {\n    for(i64 j = 4000; j --> 0;) {\n      if(a[j]) {\n        return j + 1;\n      }\n    }\n    return 0ll;\n  };\n\n  i64 N;\n  cin >> N;\n  bits X;\n  i64 xs;\n  cin >> X;\n  xs = bitlen(X);\n\n  vector<bits> A(N);\n  vector<i64> S(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    S[i] = bitlen(A[i]);\n  }\n  auto bitmod = [](bits a, i64 as, bits b, i64 bs) {\n    for(i64 i = as - bs + 1; i --> 0;) {\n      if(a[i + bs - 1]) {\n        a ^= (b << i);\n      }\n    }\n    return a;\n  };\n\n  auto bitgcd = [&](bits a, i64 as, bits b, i64 bs) {\n    while(b.any()) {\n      auto m = bitmod(a, as, b, bs);\n      a = b;\n      as = bs;\n      b = m;\n      bs = bitlen(b);\n    }\n    return pair<bits, i64>(a, as);\n  };\n\n  auto g = A[0];\n  auto gs = S[0];\n  for(i64 i = 1; i < N; i++) {\n    auto p = bitgcd(g, gs, A[i], S[i]);\n    g = p.first;\n    gs = p.second;\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(xs - gs + 1 > 0) {\n    vector<i64> Bs(xs - gs + 1, 1);\n    for(i64 i = 1; i < xs - gs + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = xs - gs + 1; i --> 0;) {\n      if(X[i + gs - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + gs - 1] != X[i + gs - 1]) {\n        now ^= (g << i);\n      }\n    }\n    if(bitmod(X, xs, now, bitlen(now)) != X) { ans = (ans + 1) % MOD; }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nvector<int> calc(vector<int> a,vector<int> b){\n    int n = a.size();\n    int m = b.size();\n    for(int i=0;i<=n-m;i++){\n        if(a[i]=='0')continue;\n        for(int j=0;j<m;j++){\n            a[i+j] ^= b[j];\n        }\n    }\n    bool flag = 0;\n    vector<int> c;\n    rep(i,n){\n        if(flag){\n            c.push_back(a[i]);\n        }else if(a[i]==1){\n            c.push_back(a[i]);\n            flag =1;\n        }\n    }\n    return c;\n}\n\nvector<int> gcd(vector<int> a,vector<int> b){\n    if(a.size()<b.size()){\n        swap(a,b);\n    }\n    vector<int> t = calc(a,b);\n    if(t.size()==0)return b;\n    return gcd(b,t);\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 998244353\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> p;\n    string t;\n    cin >> t;\n    rep(i,t.size()){\n        p.push_back(t[i]-'0');\n    }\n    vector<int>a;\n    rep(i,n){\n        string s;\n        cin >> s;\n        vector<int> b;\n        rep(j,s.size()){\n            b.push_back(s[j]-'0');\n        }\n        if(a.size()==0){\n            a = b;\n        }else{\n            a = gcd(a,b);\n        }\n    }\n    // for(auto x:a){\n    //     cout << x;\n    // }\n    // cout << endl;\n    if(p.size()<a.size()){\n        cout << 1 << endl;\n    }else{\n        mod res = 0;\n        int m = p.size();\n        int k = a.size();\n        vector<int> q(m);\n        for(int i=0;i<=m-k;i++){\n            if(p<q){\n                if(p[i]==1){\n                    res += mod_pow((mod)2,m-k-i);\n                }else{\n                    if(q[i]==1){\n                        rep(j,k){\n                            q[i+j] ^= a[j];\n                        }\n                    }\n                }\n            }else{\n                if(p[i]==1){\n                    res += mod_pow((mod)2,m-k-i);\n                }else{\n\n                }\n            }\n        }\n        cout << res+1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\n#define N_bit 4000\nusing bin = bitset<N_bit>;\nbin gcd(bin a, bin b){\n    int na = 0, nb = 0;\n    while(true){\n        while(na < N_bit && a[N_bit - 1 - na] == 0) na++;\n        while(nb < N_bit && b[N_bit - 1 - nb] == 0) nb++;\n        if(na > nb){\n            swap(a, b);\n            swap(na, nb);\n        }\n        if(nb == N_bit) return a;\n\n        a ^= b << (nb - na);\n    }\n}\n\nbool compare(bin a, bin b){\n    IREP(i, N_bit){\n        if(a[i] == 0 && b[i] == 1) return true;\n        if(a[i] == 1 && b[i] == 0) return true;\n    }\n    return true;\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    string X; cin >> X;\n    vector<string> A(N); cin >> A;\n\n    bin x(X);\n    vector<bin> a(N);\n    REP(i, N) a[i] = bin(A[i]);\n    bin g = a[0];\n    FOR(i, 1, N){\n        g = gcd(g, a[i]);\n    }\n\n    int nx = 0, ng = 0;\n    while(nx < N_bit && x[N_bit - 1 - nx] == 0) nx++;\n    while(ng < N_bit && g[N_bit - 1 - ng] == 0) ng++;\n\n    nx = N_bit - nx;\n    ng = N_bit - ng;\n    if(nx < ng){\n        Out(1);\n        return 0;\n    }\n\n    mint ans = 0;\n    bin t(0);\n    REP(i, nx - ng + 1){\n        if(x[nx - 1 - i] == 1){\n            if(t[nx - 1 - i] == 0){\n                ans += pow((mint)2, nx - ng - i);\n                t ^= g << (nx - ng - i);\n            }else{\n                ans += pow((mint)2, nx - ng - i);\n            }\n        }else if(x[nx - 1 - i] == 0){\n            if(t[nx - 1 - i] == 1){\n                t ^= g << (nx - ng - i);\n            }\n        }\n    }\n    if(compare(t, x)) ans += 1;\n    Out(ans + 1);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=4005,mu=998244353;\nint a[N],c[N],tmp[N],ans[N],x[N],lx,mx,n;\nchar s[N],sx[N];\nint deg(int *a){\n\tfor (int i=mx;i>=0;i--) \n\t\tif (a[i]) return i;\n\treturn 0; \n}\nvoid del(int *a,int *b,int t){\n\tfor (int i=mx;i>=t;i--)\n\t\ta[i]^=b[i-t];\n}\nvoid gcd(int *a,int *b,int *c){\n\tint l1=deg(a),l2=deg(b);\n\tif (l1<l2) std::swap(a,b),std::swap(l1,l2);\n\tif (l2==0 && b[0]==0){\n\t\tfor (int i=0;i<mx;i++) c[i]=a[i];\n\t\treturn;\n\t}\n\tfor(int i=l1;i>=l2;i--)\n\t\tif (a[i]) del(a,b,i-l2);\n\tgcd(b,a,c);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",sx);\n\tint lx=strlen(sx);\n\tfor (int i=lx-1,j=0;i>=0;i--,j++) x[i]=sx[j]-'0';\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%s\",s);\n\t\tint t=strlen(s);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor (int i=t-1,j=0;i>=0;i--,j++) a[i]=s[j]-'0';\n\t\tmx=std::max(mx,t);\n\t\tfor (int i=0;i<mx;i++) tmp[i]=ans[i];\n\t\tgcd(a,tmp,ans);\n\t}\n\tint len=deg(ans);\n\tmemset(a,0,sizeof(a));\n\tfor(int i=lx-1;i>=len;i--)\n\t\tif (a[i]!=x[i]) del(a,ans,i-len);\n\tint Ans=0;\n\tfor (int i=lx-1;i>=len;i--)\n\t\tAns=(Ans*2ll+x[i])%mu;\n\tfor (int i=len-1;i>=0;i--){\n\t\tif (a[i]<x[i]) break;\n\t\tif (a[i]>x[i]){\n\t\t\tAns--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int MAXN = 4096;\nconst int mod = 998244353;\nusing bs = bitset<MAXN>;\n\nint len(bs &x){\n\tfor(int i=MAXN-1; i>=0; i--){\n\t\tif(x[i]) return i + 1;\n\t}\n\treturn 0;\n}\n\nbs MOD(bs a, bs b){\n\tint d = len(a) - len(b);\n\tif(d < 0) return a;\n\treturn a ^ (b << d);\n}\n\nbs gcd(bs a, bs b){\n\tif(len(b) == 0) return a;\n\treturn gcd(b, MOD(a, b));\n}\n\nbs input(){\n\tstring s;\n\tcin >> s;\n\tbs ret = 0;\n\treverse(s.begin(), s.end());\n\tfor(int i=0; i<s.size(); i++){\n\t\tif(s[i] == '1') ret.set(i);\n\t}\n\treturn ret;\n}\n\nint pwr(int x){\n\tint ret = 1;\n\tfor(int i=0; i<x; i++) ret = ret * 2 % mod;\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tbs x = input();\n\tbs g = 0;\n\tfor(int i=0; i<n; i++){\n\t\tg = gcd(g, input());\n\t}\n\tn = len(x);\n\tint m = len(g);\n\tint ret = 1;\n\tbs cur = 0;\n\tfor(int i=n-1; i>=m-1; i--){\n\t\tif(x[i] == 0){\n\t\t\tif(cur[i] == 1){\n\t\t\t\tcur ^= (g << (i - m + 1));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(cur[i] == 0){\n\t\t\t\tret += pwr(i - m + 1);\n\t\t\t\tret %= mod;\n\t\t\t\tcur ^= (g << (i - m + 1));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret += pwr(i - m + 1);\n\t\t\t\tret %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE=4000;\nusing Bit=bitset<SIZE>;\n\nusing ll=long long;\nconst ll MOD=998244353;\n\nll powm(ll x,ll k){\n    ll res=1;\n    while(k){\n        if(k&1) res=res*x%MOD;\n        x=x*x%MOD;\n        k>>=1;\n    }\n    return res;\n}\nint main(){\n    int n;\n    Bit x;\n    cin>>n>>x;\n    vector<int> tp(n);\n    vector<Bit> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n    for(int i=0;i<n;i++){\n        if(a[i]!=0) break;\n        if(i+1==n){\n            cout<<1<<endl;\n            return 0;\n        }\n    }\n    auto baseId=[&](){\n        int id=-1;\n        for(int i=0;i<n;i++){\n            if(a[i]==0) continue;\n            if(id==-1){\n                id=i;\n                continue;\n            }\n            for(int j=SIZE-1;j>=0;j--){\n                if(a[id][j] && !a[i][j]){\n                    id=i;\n                    break;\n                }\n                if(!a[id][j] && a[i][j]) break;\n            }\n        }\n        return id;\n    };\n    auto topBit=[&](int id){\n        for(int i=SIZE-1;i>=0;i--){\n            if(a[id][i]){\n                return i;\n            }\n        }\n        return -1;\n    };\n    for(int i=SIZE-1;i>=0;i--){\n        int bid=baseId();\n        int top=topBit(bid);\n        if(top<i) break;\n        bool delt=false;\n        for(int j=0;j<n;j++){\n            if(a[j]!=0 && j!=bid && a[j][i]){\n                delt=true;\n                a[j]^=(a[bid]<<(i-top));\n            }\n        }\n    }\n\n    ll res=0;\n    int bid=baseId();\n    int top=topBit(bid);\n    Bit base=a[bid];    \n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]) res+=powm(2,i-top);\n    }\n    Bit v;\n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]^v[i]) v^=(a[bid]<<(i-top));\n    }\n    for(int i=SIZE-1;i>=0;i--){\n        if(!x[i] && v[i]){\n            break;\n        }\n        if(x[i] && !v[i]){\n            res++;\n            break;\n        }\n        if(i==0) res++;\n    }\n    res%=MOD;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define whlie while\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define rep(i,N) for(int i = 0; i < (N); i++)\n#define repr(i,N) for(int i = (N) - 1; i >= 0; i--)\n#define rep1(i,N) for(int i = 1; i <= (N) ; i++)\n#define repr1(i,N) for(int i = (N) ; i > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\nusing namespace std; void solve();\nusing ll = long long; using vl = vector<ll>;\nusing vi = vector<int>; using vvi = vector< vector<int> >;\nconstexpr int inf = 1001001001;\nconstexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);cout << endl;} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\nusing P = pair<int,int>; using vp = vector<P>;\nconstexpr int MOD = /** 1000000007; //*/ 998244353;\n//////////\n\n\n// verify\n// https://atcoder.jp/contests/agc038/submissions/7683063\n// https://www.codechef.com/viewsolution/26767783\nstruct multiple_transform{\n  template <typename T>\n  static constexpr void zeta_transform(vector<T> &a){\n    int N = a.size() - 1;\n    vector<int> sieve(N + 1, true);\n    for(int p = 2; p <= N; ++p)\n      if(sieve[p])\n        for(int k = N / p; k > 0; --k)\n          sieve[k * p] = false , a[k] += a[k * p];\n  }\n  template <typename T>\n  static constexpr void mobius_transform(vector<T> &a){\n    int N = a.size() - 1;\n    vector<int> sieve(N + 1, true);\n    for(int p = 2; p <= N; ++p)\n      if(sieve[p])\n        for(int k = 1; k * p <= N; ++k)\n          sieve[k * p] = false , a[k] -= a[k * p];\n  }\n\n  template<typename T>\n  static constexpr void zeta_transform(map<long long, T> &a){\n    for(auto it=a.rbegin(); it!=a.rend(); it++)\n      for(auto it2=a.rbegin(); it2!=it; it2++)\n        if(it2->first % it->first == 0)\n          it->second += it2->second;\n  }\n  template<typename T>\n  static constexpr void mobius_transform(map<long long, T> &a){\n    for(auto it=a.rbegin(); it!=a.rend(); it++)\n      for(auto it2=a.rbegin(); it2!=it; it2++)\n        if(it2->first % it->first == 0)\n          it->second -= it2->second;\n  }\n\n};\n\ntemplate<int wsize>\nstruct F2 : bitset<wsize>{\n\n  F2() : bitset<wsize>(){}\n  F2(unsigned long long n) : bitset<wsize>(n){}\n  F2(const string& s) : bitset<wsize>(s){}\n\n  const int msb() const{\n    for(int ret = wsize - 1 ; ret >= 0 ; ret-- )\n      if( (*this)[ret] == 1 ) return ret;\n    return -1;\n  }\n\n  const bool operator<(const F2<wsize> &other) const{\n    for(int i = wsize - 1 ; i >= 0 ; i-- )\n      if( (*this)[i] != other[i] ) return other[i];\n    return true;\n  }\n};\ntemplate<int wsize>\nF2<wsize> gcd(F2<wsize> x , F2<wsize> y){\n  if(x < y) swap(x , y);\n  while(!y.none()){\n    int xm = x.msb() , ym = y.msb();\n    x ^= y << (xm - ym);\n    if(x < y) swap(x , y);\n  }\n  return x;\n}\n\nusing f2 = F2<4096>;\n\nvoid solve(){\n  ini(N); ins(x);\n  vector<string> v(N); in(v);\n  f2 g;\n  rep(i , N) g = gcd(g , f2(v[i]));\n\n  f2 X(x);\n\n  if(X.msb() < g.msb()) die(0);\n  // d\n  ll ans = 0;\n  for(int i = X.msb(); i >= g.msb(); i--){\n    ans *= 2;\n    ans += (X[i] == 1);\n    if(ans >= MOD) ans %= MOD;\n  }\n  ans = (ans + 1) % MOD;\n  // \n  f2 Y = X;\n  rep(i , g.msb() ) Y[i] = 0;\n\n  for(int i = Y.msb(); i >= g.msb() ; i--){\n    if(Y[i]) Y ^= g << ( i - g.msb() );\n  }\n\n  for(int i = g.msb() - 1 ; i >= 0 ; i--){\n    if(X[i] > Y[i]) break;\n    if(Y[i] > X[i]) {ans =(ans + MOD - 1) % MOD; break;}\n  }\n\n  out(ans);\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 4010;\nconst LL mod = 998244353;\nint N;\nbitset<MC> X;\nbitset<MC> A[9],B;\nint d[9];\nint s[9];\n\nint main(){\n\tcin >> N;\n\tcin >> X;\n\trepp(i,0,N) cin >> A[i];\n\trepp(i,0,N) repp(j,0,MC) if(A[i][j]) d[i] = j;\n\tif(N>1){\n\t\trepp(i,0,N) s[i] = i;\n\t\tauto comp = [&](const int p , const int q){return d[p] > d[q];};\n\t\tsort(s,s+N,comp);\n\t\twhile(d[s[1]] >= 0){\n\t\t\tA[s[0]] = (A[s[0]]^(A[s[1]]<<(d[s[0]]-d[s[1]])));\n\t\t\twhile(d[s[0]] >= 0 && !A[s[0]][d[s[0]]]) --d[s[0]];\n\t\t\tsort(s,s+N,comp);\n\t\t}\n\t\tA[0] = A[s[0]];\n\t\td[0] = d[s[0]];\n\t}\n\tint z = 0;\n\trepp(j,0,MC) if(X[j]) z = j;\n\tLL ans = 0;\n\trepm(i,z,d[0]-1) ans = (ans * 2 + X[i]) % mod;\n\trepm(i,z,d[0]-1) if(B[i]^X[i]) B ^= (A[0]<<(i-d[0]));\n\t++ans;\n\trepm(i,d[0]-1,-1){\n\t\tif(B[i]^X[i]){\n\t\t\tif(B[i]) ans += mod-1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans % mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 998244353;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 4010\nll p2[N];\n\nvoid xo(string &a, string &b){\n\tint n = min(a.size(), b.size());\n\trep(i, n) a[i] = '0'+(a[i]^b[i]);\n}\n\nbool le(string &a, string &b){\n\tint n = min(a.size(), b.size());\n\trep(i, n) if(a[i]>b[i]) return false;\n\treturn true;\n}\n\nvoid ker(vector<string> &s){\n\tint n = s.size();\n\trep(i, n-1){\n\t\twhile(s[i].size()>0){\n\t\t\tif(s[i].size()<s[i+1].size()) s[i].swap(s[i+1]);\n\t\t\txo(s[i], s[i+1]);\n\t\t\tint j = 0;\n\t\t\twhile(j<s[i].size() &&s[i][j]=='0') j++;\n\t\t\ts[i].erase(0, j);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tstring x;\n\tcin>>n>>x;\n\tint m = x.size();\n\tvector<string> s(n);\n\trep(i, n) cin>>s[i];\n\tker(s);\n\tstring a(s[n-1]), b(m, '0');\n\tp2[0] = 1;\n\trep(i, N-1) p2[i+1] = p2[i]*2%mod;\n\tll res = 0;\n\tint m2 = a.size(), l = m-m2+1;\n\trep(i, l){\n\t\tb.erase(0, 1); b += '0';\n\t\tif(x[i]=='1'){\n\t\t\tres += p2[l-i-1];\n\t\t\tif(b[0]=='0'){\n\t\t\t\txo(b, a);\n\t\t\t}\n\t\t} else {\n\t\t\tif(b[0]=='1'){\n\t\t\t\txo(b, a);\n\t\t\t}\n\t\t}\n\t\tres %= mod;\n\t}\n\tif(le(b, x)) res++;\n\tcout<<res%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e3+10;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,p,bin[N],fl=1,ans=0;\nbitset<N> a,b,c;\n\nint main() {\n\tcin>>n>>a;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>c;\n\t\twhile(c.any()) {\n\t\t\tfor(int i=4000;;i--) if(c[i]) { p=i;break; }\n\t\t\tfor(int i=4000;i>=p;i--) if(b[i]) b^=c<<(i-p);\n\t\t\tswap(b,c);\n\t\t}\n\t}\n\tbin[0]=1;\n\tfor(int i=1;i<N;i++) bin[i]=2ll*bin[i-1]%mod;\n\tfor(int i=4000;;i--) if(b[i]) { p=i;break; }\n\tc.reset();\n\tfor(int i=4000;i>=p;i--) {\n\t\tif(a[i]) ans=(ans+bin[i-p])%mod;\n\t\tif(c[i]!=a[i]) c^=a<<(i-p);\n\t}\n\tfor(int i=p-1;~i;i--)\n\t\tif(c[i]<a[i]) break;\n\t\telse if(c[i]>a[i]) { fl=0;break; }\n\tcout<<(ans+fl)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 998244353;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\nconst ll len = 4005;\ntypedef bitset<len> bs;\nnamespace SOLVE {\n    bs gcd(bs a, bs b){\n        while (a.count() and b.count()) {\n            int h[2] = {0,0};\n            REP(i,0,len){\n                if(a[i])h[0] = i;\n                if(b[i])h[1] = i;\n            }\n            if(h[0]<=h[1]){\n                b^=a<<(h[1]-h[0]);\n            }else{\n                a^=b<<(h[0]-h[1]);\n            }\n        }\n        if(a.count())return a;\n        return b;\n    }\n    bs g,x;\n    int get_deg(bs x){\n        RREP(i,len-1,0)if(x[i])return i;\n        return -1;\n    }\n    bool operator<(const bs&a,const bs&b){\n        RREP(i,len-1,0)if(a[i]!=b[i])return a[i]<b[i];\n        return false;\n    }\n    ll ans = 0;\n    void main(){\n        int n;\n        cin>>n>>x;\n\n        REP(i,0,n){\n            bs b;\n            cin>>b;\n            g = gcd(b, g);\n        }\n        int deg = get_deg(g);\n        RREP(i,len-1,deg){\n            if(x[i]){\n                ans += fast(2, i-deg, mod);\n                \n            }\n        }\n//        dbg(x.to_string());\n//        dbg(g.to_string());\n        ans++;\n        ans-=gcd(x, g)==g;\n        cout<< MOD(ans,mod)<<endl;\n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 6;\nconst int MAXLEN = 4000;\nconst int MOD = 998244353;\n\nint n, maxlen;\nchar s[MAXLEN + 1];\nint bound[MAXLEN];\nint A[MAXN][MAXLEN];\nint B[MAXLEN];\nint p2[MAXLEN + 1];\n\nvoid read(int *x) {\n\tscanf(\"%s\", s); int len = strlen(s); maxlen = max(maxlen, len);\n\tREP(i, MAXLEN - len) x[i] = 0; REP(i, len) x[MAXLEN - len + i] = s[i] - '0';\n}\n\nvoid print(int *x) {\n\tFOR(i, MAXLEN - maxlen, MAXLEN) printf(\"%d\", x[i]); puts(\"\");\n}\n\nvoid gaussjord() {\n\tint r = 0, c = 0;\n\twhile (r < n&&c < MAXLEN) {\n\t\t{ int rr = r; while (rr < n&&A[rr][c] == 0) ++rr; if (rr >= n) { ++c; continue; } if (r != rr) FOR(cc, c, MAXLEN) swap(A[r][cc], A[rr][cc]); }\n\t\tFOR(rr, r + 1, n) if (A[rr][c] == 1) FOR(cc, c, MAXLEN) if (A[r][cc]) A[rr][cc] = 1 - A[rr][cc];\n\t\t++r, ++c;\n\t}\n\tn = r;\n\tfor (--r; r >= 0; --r) {\n\t\tc = 0; while (A[r][c] == 0) ++c;\n\t\tREP(rr,r) if (A[rr][c] == 1) FOR(cc, c, MAXLEN) if (A[r][cc]) A[rr][cc] = 1 - A[rr][cc];\n\t}\n}\n\nint solve() {\n\tp2[0] = 1; FORE(i, 1, MAXLEN) p2[i] = (ll)2 * p2[i - 1] % MOD;\n\t//print(bound); REP(i, n) print(A[i]);\n\tgaussjord();\n\t//printf(\"init:\\n\"); REP(i, n) print(A[i]);\n\twhile (n >= 2) {\n\t\tint pcol = 0; while (A[n - 2][pcol] == 0) ++pcol;\n\t\tint col = 0; while (A[n - 1][col] == 0) ++col;\n\t\tREP(i, MAXLEN) B[i] = A[n - 1][i];\n\t\twhile (B[pcol] == 0) {\n\t\t\tFOR(i, 1, MAXLEN) B[i] = B[i + 1]; B[MAXLEN - 1] = 0;\n\t\t\tif (B[col] != 0) FOR(i, col, MAXLEN) if (A[n - 1][i] == 1) B[i] = 1 - B[i];\n\t\t\tint ccol = 0; while (B[ccol] == 0) ++ccol; if (A[n - 2][ccol] != 0 && ccol != pcol) FOR(i, ccol, MAXLEN) if (B[i] == 1) A[n - 2][i] = 1 - A[n - 2][i];\n\t\t}\n\t\tFOR(i, pcol, MAXLEN) if (A[n - 2][i] == 1) B[i] = 1 - B[i];\n\t\tbool same = true; REP(i, MAXLEN) if (B[i] != 0) same = false;\n\t\tif (same) {\n\t\t\tREP(i, MAXLEN) A[n - 2][i] = A[n - 1][i]; --n;\n\t\t}\n\t\telse {\n\t\t\tREP(i, MAXLEN) A[n - 2][i] = A[n - 1][i];\n\t\t\tREP(i, MAXLEN) A[n - 1][i] = B[i];\n\t\t\tint ncol = 0; while (A[n - 1][ncol] == 0) ++ncol;\n\t\t\tREP(r, n - 1) if (A[r][ncol] == 1) FOR(c, ncol, MAXLEN) if (A[n - 1][c] == 1) A[r][c] = 1 - A[r][c];\n\t\t}\n\t\t//printf(\"step:\\n\"); REP(i, n) print(A[i]);\n\t}\n\tint bcol = 0; while (bound[bcol] == 0) ++bcol;\n\tint rcol = 0; while (A[0][rcol] == 0) ++rcol;\n\tif (rcol < bcol) return 1;\n\tREP(i, MAXLEN) B[i] = 0;\n\tint ret = 0;\n\tREPE(i, rcol - bcol) {\n\t\t//printf(\"%d: %d vs %d\\n\", i, B[bcol + i], bound[bcol + i]);\n\t\tint x = B[bcol + i], y = bound[bcol + i];\n\t\tif (y == 1) ret = (ret + p2[rcol - bcol - i]) % MOD;\n\t\tif (x != y) FOR(j, rcol, MAXLEN) if (A[0][j] != 0) B[bcol + i + j - rcol] = 1 - B[bcol + i + j - rcol];\n\t}\n\tbool ok = true; REP(i, MAXLEN) if (B[i] < bound[i]) break; else if (B[i] > bound[i]) { ok = false; break; } if (ok) ret = (ret + 1) % MOD;\n\tprintf(\"%d\\n\", ret);\n}\n\nvoid run() {\n\tscanf(\"%d\", &n); maxlen = 0;\n\tread(bound);\n\tREP(i, n) read(A[i]);\n\tsolve();\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int LG = 21;\nconst int N = 4005;\nconst long long MOD = 998244353;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define pb push_back\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring YES[2] = {\"NO\", \"YES\"};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint Root(int x, vector<int> &root)\n{\n    if (x == root[x]) return x;\n    return root[x] = Root(root[x], root);\n}\n\nvoid Merge(int v, int u, vector<int> &root, vector<int> &sz)\n{\n    v = Root(v, root), u = Root(u, root);\n    if (v == u) return;\n    if (sz[v] < sz[u])\n    {\n        sz[u] += sz[v];\n        root[v] = u;\n    }\n    else\n    {\n        sz[v] += sz[u];\n        root[u] = v;\n    }\n}\n\nint ok(int x, int n)\n{\n    return 0 <= x && x < n;\n}\n\nvoid bfs(int v, vi &dist, vector<vi> &graph)\n{\n    fill(all(dist), -1);\n    dist[v] = 0;\n    vi q = {v};\n    for (int i = 0; i < q.size(); i++)\n    {\n        for (auto u : graph[q[i]])\n        {\n            if (dist[u] == -1)\n            {\n                dist[u] = dist[q[i]] + 1;\n                q.push_back(u);\n            }\n        }\n    }\n}\n\nvector<int> z_func(string &s)\n{\n    vector<int> z(s.size());\n    z[0] = s.size();\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    return z;\n}\n\nvector<int> p_func(string &s)\n{\n    vector<int> p(s.size());\n    for (int i = 1; i < s.size(); i++)\n    {\n        int j = p[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = p[j - 1];\n        if (s[i] == s[j])\n            j++;\n        p[i] = j;\n    }\n    return p;\n}\n\nvector<int> d1_func(string &s)\n{\n    vector<int> d1(s.size());\n    int L = 0, R = -1;\n    for (int i = 0; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d1[R - i + L]);\n        while (i + k < s.size() && i - k >= 0 && s[i - k] == s[i + k])\n            k++;\n        d1[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k;\n            R = i + k;\n        }\n    }\n    return d1;\n}\n\nvector<int> d2_func(string &s)\n{\n    vector<int> d2(s.size());\n    int L = 0, R = -1;\n    for (int i = 1; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d2[R - i + L + 1]);\n        while (i + k < s.size() && i - k - 1 >= 0 && s[i - k - 1] == s[i + k])\n            k++;\n        d2[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k - 1;\n            R = i + k;\n        }\n    }\n    return d2;\n}\n\nll log10(ll x)\n{\n    if (x < 10) re 1;\n    re 1 + log10(x / 10);\n}\n\nll ds(ll x)\n{\n    if (x < 10) return x;\n    re x % 10 + ds(x / 10);\n}\n\ndouble sqr(double x)\n{\n    return x * x;\n}\n\nbool in(int bit, int mask)\n{\n    return (mask & (1 << bit)) > 0;\n}\n\nvoid Del(vector<int> &v, int pos)\n{\n    swap(v[pos], v[v.size() - 1]);\n    v.pop_back();\n}\n\nlong long g(vector<long long> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nint g(vector<int> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nbool comp(pii a, pii b)\n{\n    if (abs(a.first - a.second) == abs(b.first - b.second))\n        return a > b;\n    return abs(a.first - a.second) > abs(b.first - b.second);\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    string s;\n    cin >> n >> s;\n    bitset<N> x;\n    for (int i = s.size() - 1; i >= 0; i--)\n        x[s.size() - 1 - i] = s[i] - '0';\n    bitset<N> g;\n    forn(i, n)\n    {\n        cin >> s;\n        bitset<N> a;\n        for (int i = s.size() - 1; i >= 0; i--)\n            a[s.size() - 1 - i] = s[i] - '0';\n        if (!i) g = a;\n        while (g != a)\n        {\n            int x = -1, y = -1;\n            for (int i = 0; i < N; i++)\n            {\n                if (a[i]) x = i;\n                if (g[i]) y = i;\n            }\n            if (x >= y)\n            {\n                if (a == (g << (x - y))) break;\n                a = a ^ (g << (x - y));\n            }\n            else\n            {\n                if (g == (a << (y - x)))\n                {\n                    g = a;\n                    break;\n                }\n                g = g ^ (a << (y - x));\n            }\n        }\n    }\n    int d = 0, D = 0;\n    for (int i = 0; i < N; i++)\n    {\n        if (g[i]) d = i;\n        if (x[i]) D = i;\n    }\n    if (d > D) cout << 1, exit(0);\n    ll ans = 0;\n    for (int i = D; i >= d; i--)\n    {\n        ans = (2 * ans + x[i]) % MOD;\n    }\n    cout << (ans) % MOD;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef long long ll;\nconst int M = 4020;\ntypedef bitset<M> bit;\n\nint n;\nstring xs;\nstring as[10];\n\nconst ll MOD = 998244353ll;\nll bin[5252];\n\nint deg(bit a){\n\tint ret = -1;\n\tREP(i,M)if(a[i])ret=i;\n\treturn ret;\n}\n\nint main(){\n\tcin>>n;\n\tcin>>xs;\n\tREP(i,n)cin>>as[i];\n\n\tbin[0] = 1;\n\tREP(i,5251)bin[i+1] = bin[i]*2ll%MOD;\n\t\n\tbit g = bit(as[0]);\n\tREP(i,n){\n\t\tbit a = bit(as[i]);\n\t\twhile(true){\n\t\t\tint gdeg = deg(g);\n\t\t\tint adeg = deg(a);\n\t\t\tif(adeg == -1){\n\t\t\t\tbreak;\n\t\t\t}else if(gdeg == -1){\n\t\t\t\tg = a;\n\t\t\t\tbreak;\n\t\t\t}else if(adeg == gdeg){\n\t\t\t\ta = a ^ g;\n\t\t\t}else if(adeg < gdeg){\n\t\t\t\tg = g ^ (a << (gdeg - adeg));\n\t\t\t}else if(adeg > gdeg){\n\t\t\t\ta = a ^ (g << (adeg - gdeg));\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tint gdeg = deg(g);\n\tbit x = bit(xs);\n\tint xdeg = deg(x);\n\tif(gdeg > xdeg){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tstring s = xs.substr(0,xdeg-gdeg+1);\n\tREP(i,s.size()){\n\t\tans = ans * 2ll % MOD;\n\t\tans = (ans + (s[i]-'0')) % MOD;\n\t}\n\tbit y = bit(0);\n\tREP(_i,xdeg-gdeg+1){\n\t\tint i = xdeg-gdeg-_i;\n\t\tbit z = y ^ (g << i);\n\t\tif(deg(z^x) < deg(y^x)){\n\t\t\ty = z;\n\t\t}\n\t}\n\tbool less = false;\n\tif(gdeg==0)less = true;\n\tREP(_i,gdeg){\n\t\tint i = gdeg-1-_i;\n\t\tif(y[i]==1 && x[i]==0){\n\t\t\tbreak;\n\t\t}else if(y[i]==0 && x[i]==1){\n\t\t\tless = true;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tif(i==0)less = true;\n\t\t}\n\t}\n\tif(less){\n\t\tans = (ans + 1) % MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << endl\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/2;\nconst ll MOD = 998244353;\n\ninline ll add(ll a, ll b, ll M) { // a + b (mod M)\n    return (a += b) >= M ? a - M : a;\n}\ninline ll sub(ll a, ll b, ll M) { // a - b (mod M)\n    return (a -= b) < 0 ? a + M : a;\n}\ninline ll mul(ll a, ll b, ll M) { // a * b (mod M)\n    ll r = a*b - (ll)((long double)(a)*b/M+.5)*M;\n    return r < 0 ? r + M: r;\n}\ninline ll div(ll a, ll b, ll M) { // solve b x == a (mod M)\n    ll u = 1, x = 0, s = b, t = M;\n    while (s) { // extgcd for b x + M s = t\n        ll q = t / s;\n        swap(x -= u * q, u);\n        swap(t -= s * q, s);\n    }\n    if (a % t) return -1; // infeasible\n    return mul(x < 0 ? x + M : x, a / t, M); // b (xa/t) == a (mod M)\n}\ninline ll pow(ll a, ll b, ll M) {\n    ll x = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) x = (a * x) % M;\n        a = (a * a) % M;\n    }\n    return x;\n}\n\n// p(x) = p[0] + p[1] x + ... + p[n-1] x^n-1\n// assertion: p.back() != 0\ntypedef vector<ll> poly;\nostream& operator<<(ostream &os, const poly &p) {\n    bool head = true;\n    for (size_t i = 0; i < p.size(); ++i) {\n        if (p[i] == 0) continue;\n        if (!head) os << \" + \";\n        os << p[i];\n        head = false;\n        if (i >= 1) os << \" x\";\n        if (i >= 2) os << \"^\" << i;\n    }\n    return os;\n}\ninline poly add(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = add(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\ninline poly sub(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = sub(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\n\n\n/*\n// FFT-based multiplication: this works correctly for M in [int]\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root, int sign>\ninline void fmt(vector<ll>& x) {\n    const int n = x.size();\n    int h = pow(primitive_root, (mod-1)/n, mod);\n    if (sign < 0) h = div(1, h, mod);\n    for (int i = 0, j = 1; j < n-1; ++j) {\n        for (int k = n >> 1; k > (i ^= k); k >>= 1);\n        if (j < i) swap(x[i], x[j]);\n    }\n    for (int m = 1; m < n; m *= 2) {\n        ll w = 1, wk = pow(h, n / (2*m), mod);\n        for (int i = 0; i < m; ++i) {\n            for (int s = i; s < n; s += 2*m) {\n                ll u = x[s], d = x[s + m] * w % mod;\n                if ((x[s] = u + d) >= mod) x[s] -= mod;\n                if ((x[s + m] = u - d) < 0) x[s + m] += mod;\n            }\n            w = w * wk % mod;\n        }\n    }\n    if (sign < 0) {\n        ll inv = div(1, n, mod);\n        for (auto &a: x)\n            a = a * inv % mod;\n    }\n}\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root>\ninline vector<ll> conv(vector<ll> a, vector<ll> b){\n    fmt<mod,primitive_root,+1>(a); fmt<mod,primitive_root,+1>(b);\n    for (size_t i = 0; i < a.size(); ++i)\n        a[i] = a[i] * b[i] % mod;\n    fmt<mod,primitive_root,-1>(a);\n    return a;\n}\n// general convolution where mod < 2^31.\ninline vector<ll> conv(vector<ll> a, vector<ll> b, ll mod){\n    int n = a.size() + b.size() - 1;\n    for (int k: {1,2,4,8,16}) n |= (n >> k);\n    ++n;\n    a.resize(n); b.resize(n);\n    const int A = 167772161, B = 469762049, C = 1224736769, D = (ll)(A) * B % mod;\n    if(mod==A)return conv<A,3>(a,b);\n    if(mod==B)return conv<B,3>(a,b);\n    if(mod==C)return conv<C,3>(a,b);\n    if(mod==924844033)return conv<924844033,5>(a,b);\n    vector<ll> x = conv<A,3>(a,b), y = conv<B,3>(a,b), z = conv<C,3>(a,b);\n    for (size_t i = 0; i < x.size(); ++i) {\n        ll X = (y[i] - x[i]) * 104391568;\n        if ((X %= B) < 0) X += B;\n        ll Y = (z[i] - (x[i] + A * X) % C) * 721017874;\n        if ((Y %= C) < 0) Y += C;\n        x[i] += A * X + D * Y;\n        if ((x[i] %= mod) < 0) x[i] += mod;\n    }\n    x.resize(n);\n    return x;\n}\n\ninline poly mul(poly p, poly q, ll M) {\n    poly pq = conv(p, q, M);\n    pq.resize(p.size() + q.size() - 1);\n    while (!pq.empty() && !pq.back()) pq.pop_back();\n    return pq;\n}\n*/\nnamespace FFT {\n    const int max_base = 19, maxN = 1 << max_base; // N <= 2e5\n    const double PI = acos(-1);\n    struct num {\n        double x{}, y{};\n        num() = default;\n        num(double x, double y): x(x), y(y) {}\n        explicit num(double r): x(cos(r)), y(sin(r)) {}\n    };\n    inline num operator+(num a, num b) { return {a.x + b.x, a.y + b.y}; }\n    inline num operator-(num a, num b) { return {a.x - b.x, a.y - b.y}; }\n    inline num operator*(num a, num b) { return {a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x}; }\n    inline num conj(num a) {return {a.x, -a.y}; }\n    num root[maxN];\n    int rev[maxN];\n    bool is_root_prepared = false;\n\n    inline void prepare_root(){\n        if(is_root_prepared) return;\n        is_root_prepared = true;\n        root[1] = num(1, 0);\n        for (int i = 1; i < max_base; ++i) {\n            num x(2*PI / (1LL << (i+1)));\n            for (ll j = (1LL << (i-1)); j < (1LL << (i)); ++j) {\n                root[2*j] = root[j];\n                root[2*j+1] = root[j]*x;\n            }\n        }\n    }\n\n    int base=1, N=2;\n    int lastN = -1;\n\n    inline void prepare_rev(){\n        if(lastN == N) return;\n        lastN = N;\n        for (int i = 0; i < N; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (base - 1));\n    }\n\n    inline void fft(num *a, num *f){\n        for (int i = 0; i < N; ++i) f[i] = a[rev[i]];\n        for (int k = 1; k < N; k <<= 1) {\n            for (int i = 0; i < N; i += 2*k) {\n                for (int j = 0; j < k; ++j) {\n                    num z = f[i+j+k]* root[j+k];\n                    f[i+j+k] = f[i+j] - z;\n                    f[i+j] = f[i+j] + z;\n                }\n            }\n        }\n    }\n    num a[maxN], b[maxN], f[maxN], g[maxN];\n    ll A[maxN], B[maxN], C[maxN];\n\n    inline void multi_mod(int m){\n        for (int i = 0; i < N; ++i) {\n            ll x = A[i] % m;\n            a[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        for (int i = 0; i < N; ++i) {\n            ll x = B[i] % m;\n            b[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            int j = (N-i) &(N-1);\n            num a1 = (f[i] + conj(f[j])) * num(0.5, 0);\n            num a2 = (f[i] - conj(f[j])) * num(0, -0.5);\n            num b1 = (g[i] + conj(g[j])) * num(0.5/N, 0);\n            num b2 = (g[i] - conj(g[j])) * num(0, -0.5/N);\n            a[j] = a1*b1 + a2*b2 * num(0, 1);\n            b[j] = a1*b2 + a2*b1;\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            ll aa = f[i].x + 0.5;\n            ll bb = g[i].x + 0.5;\n            ll cc = f[i].y + 0.5;\n            C[i] = (aa + bb % m * (1LL << 15) + cc% m *(1LL << 30)) % m;\n        }\n    }\n\n    inline void prepare_AB(int n1, int n2){\n        if(N > n1+n2){\n            base = 1;\n            N = 2;\n        }\n        while(N < n1+n2) base++, N <<= 1;\n        for (int i = n1; i < N; ++i) A[i] = 0;\n        for (int i = n2; i < N; ++i) B[i] = 0;\n        prepare_root();\n        prepare_rev();\n    }\n\n    inline void multi_mod(int n1, int n2, int m){\n        prepare_AB(n1, n2);\n        multi_mod(m);\n    }\n}\ninline poly mul(poly A, poly B,int M){\n    while(!A.empty()&&!A.back())A.pop_back();\n    while(!B.empty()&&!B.back())B.pop_back();\n    poly C(A.size() + B.size()-1);\n    for (size_t i = 0; i < A.size(); ++i) FFT::A[i] = A[i];\n    for (size_t i = 0; i < B.size(); ++i) FFT::B[i] = B[i];\n    FFT::multi_mod(A.size(), B.size(), M);\n    for (size_t i = 0; i < C.size(); ++i) C[i] = FFT::C[i];\n    while(!C.empty()&&!C.back())C.pop_back();\n    return C;\n}\n\n\ninline pair<poly,poly> divmod(poly p, poly q, ll M) {\n    if (p.size() < q.size()) return { {}, p };\n    reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    poly t = {div(1, q[0], M)};\n    if (t[0] < 0) return { {}, {} }; // infeasible\n    for (size_t k = 1; k <= 2*(p.size()-q.size()+1); k *= 2) {\n        poly qq=q;\n        if(k+1<q.size())qq.resize(k+1);\n        while (!qq.empty() && !qq.back()) qq.pop_back();\n        poly s = mul(mul(t, t, M), qq, M);\n        t.resize(k);\n        for (size_t i = 0; i < k; ++i)\n            t[i] = sub(2*t[i], s[i], M);\n    }\n    t.resize(p.size() - q.size() + 1);\n    poly pp=p;\n    pp.resize(p.size() - q.size() + 1);\n    while (!pp.empty() && !pp.back()) pp.pop_back();\n    t = mul(t, pp, M);\n    t.resize(p.size() - q.size() + 1);\n    reverse(t.begin(),t.end()); reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    while (!t.empty() && !t.back()) t.pop_back();\n    return {t, sub(p, mul(q, t, M), M) };\n}\npoly gcd(poly p, poly q, ll M) {\n    for (; !p.empty(); swap(p, q = divmod(q, p, M).second)){\n      while(!p.empty()&&!p.back())p.pop_back();\n      while(!q.empty()&&!q.back())q.pop_back();\n    }\n    while(!q.empty()&&!q.back())q.pop_back();\n    return q;\n}\n\n#include <ctime>\ndouble tick() {\n  static clock_t oldtick;\n  clock_t newtick = clock();\n  double diff = 1.0*(newtick - oldtick) / CLOCKS_PER_SEC;\n  oldtick = newtick;\n  return diff;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  //tick();\n  ll N;cin>>N;\n  string X;cin>>X;reverse(X.begin(),X.end());\n  string A;cin>>A;reverse(A.begin(),A.end());\n  poly g(A.length());\n  for(size_t i=0;i<A.length();i++){\n    g[i]=A[i]-'0';\n  }\n  for(ll i=1;i<N;i++){\n    cin >> A;\n    reverse(A.begin(),A.end());\n    poly p(A.length());\n    for(size_t i=0;i<A.length();i++){\n      p[i]=A[i]-'0';\n    }\n    g=gcd(p,g,2);\n  }\n  ll ans=0;\n  size_t d=g.size();\n  poly q(X.length(),0);\n  ll pw=pow(2,d-1,MOD);\n  for(size_t i=d-1;i<X.length();i++){\n    q[i]=X[i]-'0';\n    if(X[i]>'0')ans = (ans+pw)%MOD;\n    pw = pw*2%MOD;\n  }\n  poly r=divmod(q,g,2).second;\n  bool isok=true;\n  for(size_t i=X.length()-1;i>=d;i--){\n    if(r[i]==X[i]-'0')continue;\n    isok = r[i]<X[i]-'0';\n    break;\n  }\n  ans = (ans+isok)%MOD;\n  cout<<ans<<endl;\n  //debug(tick());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include <cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nconst int DEBUG = 0;\n\n\nconst int N=4000;\ntypedef bitset<N> bs;\nconst lint MOD=998244353;\n\nbs read(){\n  string s;\n  cin>>s;\n  int l=s.length();\n  bs ret;\n  rep(i,l)ret[i]=s[l-i-1]=='1';\n  return ret;\n}\n\nbs div(bs a, bs b){\n  int hi=-1;\n  rep(i,N){\n    if(b[i]){\n      hi=i;\n    }\n  }\n  assert(hi>=0);\n  for(int i=N-hi-1;i>=0;--i){\n    if(a[i+hi]){\n      a^=b<<i;\n    }\n  }\n  return a;\n}\n\nbs gcd(bs a,bs b){\n  while(b.count()!=0){\n    a=div(a,b);\n    swap(a,b);\n  }\n  return a;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  bs x=read();\n  vector<bs> s(n);\n  rep(i,n)s[i]=read();\n  bs t=s[n-1];\n  rep(i,n-1)\n    t=gcd(s[i],t);\n  lint ans=0;\n  lint cur=1;\n  int hi=-1;\n  rep(i,N){\n    if(t[i]){\n      hi=i;\n    }\n  }\n  bs y;\n  for(int i=N-hi-1;i>=0;--i){\n    if(x[i+hi]!=y[i+hi]){\n      y^=t<<i;\n    }\n  }\n  rep(i,N-hi){\n    if(x[i+hi])ans=(ans+cur)%MOD;\n    cur=cur*2%MOD;\n  }\n  bool lt=false;\n  for(int i=N-1;i>=0;--i){\n    if(x[i]!=y[i]){\n      lt=x[i]<y[i];\n      break;\n    }\n  }\n  if(lt)cur=(cur+MOD-1)%MOD;\n  cout<<(ans+1)%MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\n#define N_bit 4000\nusing bin = bitset<N_bit>;\nbin gcd(bin a, bin b){\n    int na = 0, nb = 0;\n    while(true){\n        while(na < N_bit && a[N_bit - 1 - na] == 0) na++;\n        while(nb < N_bit && b[N_bit - 1 - nb] == 0) nb++;\n        if(na > nb){\n            swap(a, b);\n            swap(na, nb);\n        }\n        if(nb == N_bit) return a;\n\n        a ^= b << (nb - na);\n    }\n}\n\nbool compare(bin a, bin b){\n    IREP(i, N_bit){\n        if(a[i] == 0 && b[i] == 1) return true;\n        if(a[i] == 1 && b[i] == 0) return true;\n    }\n    return true;\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    string X; cin >> X;\n    vector<string> A(N); cin >> A;\n\n    bin x(X);\n    vector<bin> a(N);\n    REP(i, N) a[i] = bin(A[i]);\n    bin g = a[0];\n    FOR(i, 1, N){\n        g = gcd(g, a[i]);\n    }\n\n    int nx = 0, ng = 0;\n    while(nx < N_bit && x[N_bit - 1 - nx] == 0) nx++;\n    while(ng < N_bit && g[N_bit - 1 - ng] == 0) ng++;\n\n    nx = N_bit - nx;\n    ng = N_bit - ng;\n    if(nx < ng){\n        Out(1);\n        return 0;\n    }\n\n    mint ans = 0;\n    bin t(0);\n    REP(i, nx - ng + 1){\n        if(x[nx - 1 - i] == 1){\n            if(t[nx - 1 - i] == 0){\n                ans += pow((mint)2, nx - ng - i);\n                t ^= g << (nx - ng - i);\n            }else{\n                ans += pow((mint)2, nx - ng - i);\n            }\n        }else if(x[nx - 1 - i] == 0){\n            if(t[nx - 1 - i] == 1){\n                t ^= g << (nx - ng - i);\n            }\n        }\n    }\n    if(compare(t, x)) ans += 1;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 998244353LL;\n\nvector<int> gcd(vector<int> A, vector<int> B) {\n\tif (B[0] == 0) {\n\t\treturn A;\n\t}\n\tint N = A.size(), M = B.size();\n\tfor (int i = 0; i <= N - M; i++) {\n\t\tif (A[i] == 1) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tA[i + j] ^= B[j];\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> R;\n\tbool zero = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i]) zero = 0;\n\t\tif (!zero) R.push_back(A[i]);\n\t}\n\tif (zero) R.push_back(0);\n\treturn gcd(B, R);\n}\nint main() {\n\tint N; cin >> N;\n\tstring X; cin >> X;\n\tvector<int> x;\n\tfor (int i = 0; i < X.size(); i++) x.push_back(X[i] - '0');\n\tvector<int> g(1, 0);\n\tfor (int i = 0; i < N; i++) {\n\t\tstring A; cin >> A;\n\t\tvector<int> a;\n\t\tfor (int i = 0; i < A.size(); i++) a.push_back(A[i] - '0');\n\t\tg = gcd(g, a);\n\t}\n\tif (g.size() > x.size()) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= x.size() - g.size(); i++) {\n\t\t(ans *= 2) %= MOD;\n\t\t(ans += x[i]) %= MOD;\n\t}\n\tvector<int> y(x.size(), 0);\n\tfor (int i = 0; i <= x.size() - g.size(); i++) {\n\t\tif (y[i] != x[i]) {\n\t\t\tfor (int j = 0; j < g.size(); j++) y[i + j] ^= g[j];\n\t\t}\n\t}\n\tbool ok = 1;\n\tfor (int i = x.size() - g.size() + 1; i < x.size(); i++) {\n\t\tif (y[i] < x[i]) break;\n\t\tif (y[i] > x[i]) {\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ok) (ans += 1) %= MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define md 998244353\n\nvoid show(vi x){\n  rep(i,x.size())cout<<x[i];\n  cout<<endl;\n  cout<<endl;\n}\n\nvi mod(const vi& a,const vi& b){\n  vi crt=a;\n  while(crt.size()>=b.size()){\n    vi nxt;\n    bool mada=true;\n    rep(j,b.size()){\n      if(!mada){\n        nxt.push_back(crt[j]^b[j]);\n      }else{\n        if(crt[j]^b[j]){\n          nxt.push_back(1); mada=false;\n        }\n      }\n    }\n    repl(j,b.size(),crt.size()){\n      if(!mada){\n        nxt.push_back(crt[j]);\n      }else{\n        if(crt[j]){\n          nxt.push_back(1); mada=false;\n        }\n      }\n    }\n    crt=nxt;\n  }\n  return crt;\n}\n\nvi mgcd(vi a,vi b){\n  if(b.size()==0) return a;\n  else return mgcd(b,mod(a,b));\n}\n\nll N;\nvi X;\nvi A[6];\nll dp[4001][2];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N;\n  {\n    string s;\n    cin>>s;\n    rep(j,s.size())X.push_back(s[j]-'0');\n  }\n  rep(i,N){\n    string s;\n    cin>>s;\n    rep(j,s.size())A[i].push_back(s[j]-'0');\n  }\n\n  vi g=A[0];\n  repl(i,1,N){\n    g=mgcd(g,A[i]);\n  }\n\n  ll d=g.size();\n  ll m=X.size()-d+1;\n  dp[0][0]=1;\n  rep(i,m)rep(j,2){\n    rep(nxt,(j==0?X[i]+1:2)){\n      (dp[i+1][!(j==0&&nxt==X[i])]+=dp[i][j])%=md;\n    }\n  }\n  ll res=dp[m][1];\n\n  vi Y;\n  rep(i,X.size()){\n    if(i<m) Y.push_back(X[i]);\n    else Y.push_back(0);\n  }\n\n  vi r=mod(Y,g);\n\n  rep(i,r.size()){\n    Y[Y.size()-1-i]^=r[r.size()-1-i];\n  }\n\n  if(Y<=X) cout<<(res+1)%md<<endl;\n  else cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5010, mod = 998244353;\nvector<int> nm[N], s, g, t;\n\nint add(int x, int y) {\n  return (x += y) >= mod ? x - mod : x;\n}\n\nint mul(int x, int y) {\n  return 1ll * x * y % mod;\n}\n\nvector<int> gcd(vector<int> a, vector<int> b) {\n  if(a.size() < b.size()) swap(a, b);\n  if(!b.size()) return a;\n/*  puts(\"WWWW\");\n  for(int i = 0; i < a.size(); ++i)\n    printf(\"%d\", a[i]);\n  puts(\"\");\n  for(int i = 0; i < b.size(); ++i)\n    printf(\"%d\", b[i]);\n  puts(\"\");*/\n  int l = a.size() - b.size();\n  vector<int> d(a.size());\n  for(int i = 0; i < b.size(); ++i)\n    d[i + l] = a[i + l] ^ b[i];\n  for(int i = 0; i < l; ++i) d[i] = a[i];\n  while(d.size() && !d[d.size() - 1]) {\n    d.pop_back();\n  }\n/*  for(int i = 0; i < d.size(); ++i)\n    printf(\"%d\", d[i]);\n  puts(\"\\nd!\");*/\n//  assert(0);\n  return gcd(b, d);\n}\n\nchar lx[N];\n\nvoid solve() {\n  if(g.size() > s.size()) {\n    puts(\"1\");\n    return ;\n  }  \n  t = s;\n  int l = s.size() - g.size() + 1;\n  int ls = s.size(), lg = g.size();\n  int ans = 0;\n  for(int i = ls - 1; i >= lg - 1; --i) {\n    ans = add(mul(ans, 2), s[i]);\n  }\n  ans = add(ans, 1);\n//  printf(\"%d\\n\", ans);\n  for(int i = 0; i < g.size() - 1; ++i) t[i] = 0;\n//  puts(\"XX\");\n  for(int i = ls - 1; i >= lg - 1; --i) {\n    if(t[i]) {\n      for(int j = 0; j < g.size(); ++j) {\n        t[i - j] ^= g[g.size() - j - 1];\n      }\n    }\n  }\n//  puts(\"WWW\");\n  for(int i = g.size() - 2; i >= 0; --i)\n    if(t[i] > s[i]) {\n      ans = add(ans, mod - 1);\n      break;\n    } else if(t[i] < s[i]) {\n      break;\n    }\n  printf(\"%d\\n\", ans);\n}\n\n// s[0] * x ^ 0 + s[1] * x ^ 1 + s[2] * x ^ 2 + .. +\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  scanf(\"%s\", lx + 1);\n  int len = strlen(lx + 1);\n  for(int i = len; i >= 1; --i) {\n    s.push_back(lx[i] - '0');\n  }\n  for(int i = 1; i <= n; ++i) {\n    scanf(\"%s\", lx + 1);\n    len = strlen(lx + 1);\n    for(int j = len; j >= 1; --j) {\n      nm[i].push_back(lx[j] - '0');\n    }\n  }\n  g = nm[1];\n  for(int i = 2; i <= n; ++i)\n    g = gcd(g, nm[i]);\n/*  for(int i = 0; i < g.size(); ++i)\n    printf(\"%d\", g[i]);\n  puts(\"\\nggg\");*/\n  solve(); \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\ninline int deg(const bitset <N> &b) {\n  int t = N - 1;\n  while (t >= 0 && !b[t]) t --;\n  return t + 1;\n}\n\nint n;\nchar buf[N];\n\ninline void read(bitset <N> &b) {\n  scanf(\"%s\", buf);\n  reverse(buf, buf + strlen(buf));\n  for (int i = 0; buf[i]; i ++)\n    b[i] = (bool)(buf[i] - '0');\n}\n\nbitset <N> X, A[10];\n\ninline bitset <N> gcd(bitset <N> p, bitset <N> q) {\n  int a = deg(p);\n  int b = deg(q);\n  while (true) {\n    if (!a) return q;\n    if (!b) return p;\n    if (a < b) {\n      swap(p, q); swap(a, b);\n    }\n    p ^= q << (a - b);\n    while (a >= 0 && p[a] == 0) a --;\n    a ++;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  read(X);\n  for (int i = 1; i <= n; i ++) read(A[i]);\n  for (int i = 2; i <= n; i ++)\n    A[1] = gcd(A[1], A[i]);\n  int ans = 0, j = deg(A[1]);\n  for (int i = deg(X) - 1; i >= j - 1; i --) \n    ans = ((ans << 1) + X[i]) % mod;\n  for (int i = deg(X) - 1; i >= j; i --)\n    if (X[i]) X ^= A[1] << (i - j);\n  for (int i = j - 1; ~ i; i --)\n    if (A[1][i] != X[i]) {\n      if (A[1][i] > X[1]) ans --;\n      break;\n    }\n  ans = (ans + 1) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5010, mod = 998244353;\nvector<int> nm[N], s, g, t;\n\nint add(int x, int y) {\n  return (x += y) >= mod ? x - mod : x;\n}\n\nint mul(int x, int y) {\n  return 1ll * x * y % mod;\n}\n\nvector<int> gcd(vector<int> a, vector<int> b) {\n  if(a.size() < b.size()) swap(a, b);\n  if(!b.size()) return a;\n/*  puts(\"WWWW\");\n  for(int i = 0; i < a.size(); ++i)\n    printf(\"%d\", a[i]);\n  puts(\"\");\n  for(int i = 0; i < b.size(); ++i)\n    printf(\"%d\", b[i]);\n  puts(\"\");*/\n  int l = a.size() - b.size();\n  vector<int> d(a.size());\n  for(int i = 0; i < b.size(); ++i)\n    d[i + l] = a[i + l] ^ b[i];\n  for(int i = 0; i < l; ++i) d[i] = a[i];\n  while(d.size() && !d[d.size() - 1]) {\n    d.pop_back();\n  }\n/*  for(int i = 0; i < d.size(); ++i)\n    printf(\"%d\", d[i]);\n  puts(\"\\nd!\");*/\n//  assert(0);\n  return gcd(b, d);\n}\n\nchar lx[N];\n\nvoid solve() {\n  if(g.size() > s.size()) {\n    puts(\"1\");\n    return ;\n  }  \n  t = s;\n  int l = s.size() - g.size() + 1;\n  int ls = s.size(), lg = g.size();\n  int ans = 0;\n  for(int i = ls - 1; i >= lg - 1; --i) {\n    ans = add(mul(ans, 2), s[i]);\n  }\n  ans = add(ans, 1);\n//  printf(\"%d\\n\", ans);\n  for(int i = 0; i < g.size() - 1; ++i) t[i] = 0;\n  for(int i = ls - 1; i >= g.size(); --i) {\n    if(t[i]) {\n      for(int j = 0; j < g.size(); ++j) {\n        t[i + j] ^= g[g.size() - j - 1];\n      }\n    }\n  }\n  for(int i = g.size() - 2; i >= 0; --i)\n    if(t[i] > s[i]) {\n      ans = add(ans, mod - 1);\n      break;\n    } else if(t[i] < s[i]) {\n      break;\n    }\n  printf(\"%d\\n\", ans);\n}\n\n// s[0] * x ^ 0 + s[1] * x ^ 1 + s[2] * x ^ 2 + .. +\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  scanf(\"%s\", lx + 1);\n  int len = strlen(lx + 1);\n  for(int i = len; i >= 1; --i) {\n    s.push_back(lx[i] - '0');\n  }\n  for(int i = 1; i <= n; ++i) {\n    scanf(\"%s\", lx + 1);\n    len = strlen(lx + 1);\n    for(int j = len; j >= 1; --j) {\n      nm[i].push_back(lx[j] - '0');\n    }\n  }\n  g = nm[1];\n  for(int i = 2; i <= n; ++i)\n    g = gcd(g, nm[i]);\n/*  for(int i = 0; i < g.size(); ++i)\n    printf(\"%d\", g[i]);\n  puts(\"\\nggg\");*/\n  solve(); \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n#define MOD 998244353\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\ntypedef bitset<4000> Num;\n\nint N;\nNum X, A[6];\n\nNum in()\n{\n\tchar buf[4040];\n\tscanf(\"%s\", buf);\n\n\tint len = strlen(buf);\n\tNum ret;\n\tfor (int i = 0; i < len; ++i) {\n\t\tif (buf[i] == '1') ret.set(len - 1 - i);\n\t}\n\treturn ret;\n}\n\nint msb(Num a)\n{\n\tfor (int i = 3999; i >= 0; --i) {\n\t\tif (a[i]) return i;\n\t}\n\treturn -1;\n}\n\nNum gcd(Num a, Num b)\n{\n\tfor (;;) {\n\t\tint na = msb(a), nb = msb(b);\n\t\tif (na == -1) return b;\n\t\tif (nb == -1) return a;\n\t\tif (na < nb) {\n\t\t\tb ^= a << (nb - na);\n\t\t} else {\n\t\t\ta ^= b << (na - nb);\n\t\t}\n\t}\n}\n\ni64 toint(Num n)\n{\n\ti64 ret = 0;\n\tfor (int i = 3999; i >= 0; --i) {\n\t\tret = ret * 2 % MOD;\n\t\tret += n[i];\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tX = in();\n\tfor (int i = 0; i < N; ++i) A[i] = in();\n\n\tNum g = A[0];\n\tfor (int i = 1; i < N; ++i) {\n\t\tg = gcd(g, A[i]);\n\t}\n\tint mg = msb(g);\n\ti64 ret = toint(X >> mg);\n\n\tNum waf;\n\tfor (int i = mg; i < 4000; ++i) {\n\t\tif (X[i]) {\n\t\t\twaf ^= g << (i - mg);\n\t\t}\n\t}\n\tbool toolarge = false;\n\tfor (int i = mg - 1; i >= 0; --i) {\n\t\tint xi = X[i];\n\t\tint wi = waf[i];\n\n\t\tif (xi > wi) break;\n\t\tif (xi < wi) {\n\t\t\ttoolarge = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!toolarge) ADD(ret, 1);\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 998244353;\n\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  string X;\n  cin >> N >> X;\n  vector<string> A(N);\n  vector<ll> pow(4040);\n  pow[0] = 1;\n  for(int i = 0; i < N; ++i) cin >> A[i];\n  for(int i = 1; i <4040; ++i) pow[i] = pow[i-1] * 2 % MOD;\n\n  string g = \"0\";\n  for(int i = 0; i < N; ++i) {\n\n    string a = g, b = A[i];\n    while(true) {\n      if(a.size() < b.size()) swap(a, b);\n      if(a == \"0\" || b == \"0\") {\n        if(a == \"0\") g = b;\n        else g = a;\n        break;\n      }\n      for(int j = 0; j < (int)b.size(); ++j) {\n        a[j] = \"01\"[(a[j] - '0') ^ (b[j] - '0')];\n      }\n      \n      string c;\n      int j = 0;\n      while(a[j] == '0') ++j;\n      for(; j < (int)a.size(); ++j) c.push_back(a[j]);\n      if(c.size() == 0) c.push_back('0');\n      a = b, b = c;\n    }\n  }\n  if(g.size() > X.size()) {\n      cout << 0 << endl;\n      return 0;\n  }\n\n  // matome\n  ll ans = 0;\n  vector<bool> res((int)X.size());\n  string Y(X.size(), '0');\n  for(int i = 0; i < (int)X.size() - (int)g.size() + 1; ++i) {\n    if(X[i] != Y[i]) {\n      for(int j = 0; j < (int)g.size(); ++j)\n        Y[i + j] = \"01\"[(g[j] - '0') ^ (Y[i + j] - '0')];\n    }\n  }\n  if(X >= Y) ++ans;\n\n  for(int i = 0; i < (int)X.size() - (int)g.size() + 1; ++i) {\n    if(X[i] == '1') {\n      ans = (ans + pow[(int)X.size() - ((int)g.size()) - i]) % MOD;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 998244353;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nconst int D = 4000;\ntypedef std::bitset<D + 10> B;\nB X, t, g;\nint get(B x, int at = D) {\n\twhile (at && !x.test(at)) --at;\n\treturn at;\n}\nB gcd(B a, B b) {\n\tfor (int i = D; ~i; )\n\t\tif (a.test(i) || b.test(i)) {\n\t\t\tif (b.test(i) && !a.test(i)) std::swap(a, b);\n\t\t\tif (b.none()) return a;\n\t\t\ta ^= b << i - get(b);\n\t\t} else --i;\n}\nint n, ans = 0;\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> X;\n\twhile (n --> 0) std::cin >> t, g = gcd(g, t);\n\tint u = get(X), d = get(g);\n\tans = 1;\n\tfor (int i = d; i <= u; ++i) if (X.test(i))\n\t\treduce(ans += pow(2, i - d) - mod);\n\tB r;\n\tfor (int i = u; i >= d; --i)\n\t\tif (X.test(i) != r.test(i)) r ^= g << i - d;\n\tfor (int i = u; ~i; --i)\n\t\tif (X.test(i) != r.test(i)) {\n\t\t\tif (!X.test(i)) reduce(ans -= 1);\n\t\t\tbreak;\n\t\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    constexpr uint MOD = 998244353;\n    using mint = ModInt<MOD>;\n    constexpr int L = 4000;\n    const int N = read<int>();\n    using B = std::bitset<L>;\n    B X(read<std::string>());\n    auto gcd = [&](auto&& self, B a, B b) {\n        if (a.count() == 0) { return b; }\n        if (a.to_string() > b.to_string()) { return self(self, b, a); }\n        int d = L - 1;\n        for (; d >= 0 and b[d] == 0; d--) {}\n        int dd = L - 1;\n        for (; dd >= 0 and a[dd] == 0; dd--) {}\n        for (; d >= 0; d--) {\n            if (b[d] == 0) { continue; }\n            const int sft = d - dd;\n            b ^= a << sft;\n        }\n        return self(self, b, a);\n    };\n    B g;\n    for (int i = 0; i < N; i++) { g = gcd(gcd, g, B(read<std::string>())); }\n    int d = L - 1;\n    auto x = X;\n    for (; d >= 0 and g[d] == 0; d--) {}\n    for (int l = L - 1; l >= 0; l--) {\n        if (x[l] == 0) { continue; }\n        const int sft = l - d;\n        x ^= g << sft;\n    }\n    B mask;\n    for (int i = 0; i < d; i++) { mask[i] = 1; }\n    X >>= d;\n    mint ans = (x.to_string() >= (X & mask).to_string()) ? 1 : 0, base = 1;\n    for (int i = 0; i < L; i++) { ans += base * X[i], base *= 2; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int BIT = 4000;\nconst int MOD = 998244353;\n\nbitset<BIT> gcd(bitset<BIT> a, bitset<BIT> b)\n{\n    int i = BIT - 1;\n    int j = BIT - 1;\n\n    for(;;){\n        while(i >= 0 && !a[i])\n            -- i;\n        if(i == -1)\n            return b;\n\n        while(j >= 0 && !b[j])\n            -- j;\n        if(j == -1)\n            return a;\n\n        if(i < j)\n            b ^= a << (j - i);\n        else\n            a ^= b << (i - j);\n    }\n}\n\nlong long div(const bitset<BIT>& x, const bitset<BIT>& a)\n{\n    int i = BIT - 1;\n    while(!a[i])\n        -- i;\n\n    long long ans = 0;\n    bitset<BIT> y;\n    for(int j=BIT-1; j>=i; --j){\n        ans *= 2;\n        ans %= MOD;\n        if(x[j]){\n            ++ ans;\n            ans %= MOD;\n        }\n        if(x[j] != y[j])\n            y ^= a << (j - i);\n    }\n\n    while(--i >= 0){\n        if(x[i] && !y[i])\n            break;\n        else if(!x[i] && y[i])\n            return ans;\n    }\n\n    ++ ans;\n    ans %= MOD;\n    return ans;\n}\n\nint main()\n{\n    int n;\n    bitset<BIT> x;\n    cin >> n >> x;\n\n    vector<bitset<BIT> > a(n);\n    for(int i=0; i<n; ++i)\n        cin >> a[i];\n\n    bitset<BIT> b = a[0];\n    for(int i=1; i<n; ++i)\n        b = gcd(a[i], b);\n\n    cout << div(x, b) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\nconst int m = 4010;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel rui(m + 10, 1);\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nint max_true(bs &a,int jou) {\n\tint ans = jou;\n\trep(i, jou) {\n\t\tif (a[i]) { ans = i; }\n\t}\n\treturn ans;\n}\nbool can_div(bs &a, bs b, int &sza, int szb) {\n\tfor (int i = sza; i >= szb; i--) {\n\t\tif (a[i]) {\n\t\t\ta ^= b << (i - szb);\n\t\t}\n\t}\n\tsza = max_true(a, szb);\n\tif (sza == szb) { return true; }\n\treturn false;\n}\nbs gcd(bs a, bs b) {\n\tint sza = max_true(a,m);\n\tint szb = max_true(b,m);\n\tif (sza < szb) { swap(sza, szb); swap(a, b); }\n\twhile (true) {\n\t\tif (can_div(a, b,sza,szb)) { swap(a, b); break; }\n\t\tif (can_div(b, a,szb,sza)) { break; }\n\t}\n\treturn a;\n}\nvoid solve(bs &x, bs &a) {\n\tint szx = max_true(x,m);\n\tint sza = max_true(a,m);\n\tbs to;\n\tint ans = 0;\n\tfor (int i = szx; i >= sza; i--) {\n\t\tif (x[i]) {\n\t\t\tans += rui[i - sza];\n\t\t}\n\t\tif (x[i] != to[i]) {\n\t\t\tto ^= a << (i - sza);\n\t\t}\n\t}\n\tcout << (ans + 1)%p << endl;\n}\nbs mak(string s) {\n\trev(s);\n\tbs  ans;\n\trep(i, s.size()) {\n\t\tans[i] = (s[i] == '1');\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint n; cin >> n;\n\tstring x; cin >> x;\n\tstring s; cin >> s;\n\tbs gcd0 = mak(s);\n\trep(i, n - 1) {\n\t\tstring ne; cin >> ne;\n\t\tbs newb = mak(ne);\n\t\tgcd0 = gcd(newb, gcd0);\n\t}\n\tbs nw = mak(x);\n\trep(i, m + 9) { rui[i + 1] = rui[i] * 2; rui[i + 1] %= p; }\n\tsolve(nw, gcd0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=998244353;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=1e6+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=1e3+10;\n\t//------------------FIXED------------------\n\ttypedef bitset<N> bs;\n\tbool operator > (bs &a,bs &b)\n\t{\n\t\tfd(i,N-1,0) if(a[i]!=b[i]) return a[i]>b[i];\n\t\treturn 0;\n\t}\n\tchar str[N];bs read(){ bs ret;scanf(\"%s\",str+1);int ln=strlen(str+1);fo(i,1,ln) ret[ln-i]=(str[i]-'0');return ret; }\n\tnamespace BS\n\t{\n\t\tbs bit[N];int cnt;\n\t\tvoid insert(bs x)\n\t\t{\n\t\t\tfd(i,N-1,0) if(x[i])\n\t\t\t{\n\t\t\t\tif(bit[i][i]==0){bit[i]=x;cnt++;break;}\n\t\t\t\telse x^=bit[i];\n\t\t\t}\n\t\t}\n\t\tvoid solve(bs MX)//<=MX\n\t\t{\n\t\t\tbs mx;fd(i,N-1,0) if(bit[i][i] and mx[i]==0) mx^=bit[i];\n\t\t\tbs ans;\n\t\t\tfd(i,cnt-1,0)\n\t\t\t{\n\t\t\t\tans[i]=1;\n\t\t\t\tbs now;for(int i=N-1,j=cnt;i>=0;i--)if(bit[i][i]){ j--;if(ans[j]^now[i]) now^=bit[i]; }\n\t\t\t\tif(now>MX) ans[i]=0;\n\t\t\t}\n\t\t\tbs now;for(int i=N-1,j=cnt;i>=0;i--)if(bit[i][i]){ j--;if(ans[j]^now[i]) now^=bit[i]; }\n\t\t\tll ret=0;fd(i,cnt-1,0) ret=(ret*2+ans[i])%MOD;add(ret,1);write(ret);//debug 0\n\t\t}\n\t};\n\tbs a[10];\n\tvoid main()\n\t{\n\t\tint n=qread();bs MX=read();int L=strlen(str+1);\n\t\tfo(i,1,n) {\n\t\t\ta[i]=read();int ln=strlen(str+1);\n\t\t\tfo(j,0,N-1-ln) BS::insert(a[i]<<j);\n\t\t}\n\t\tBS::solve(MX);\n\t}\n};//\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();\n\tmine::main();\n\tdebug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "// ayy\n// ' lamo\n// SUBLIME HAX\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\n// const int P=1e9+7;\n\n\n\n\nconst int N=4096;\n// const int N=12;\nint n;\ntypedef bitset<N> BS;\nBS X,A[6],Y,Q;\nvoid read(BS &bs) {\n\tstring s; cin>>s;\n\treverse(s.begin(),s.end());\n\tfor(int i=0;i<sz(s);i++) bs[i]=int(s[i]=='1');\n}\nbool operator<(const BS &L,const BS &R) {\n\tfor(int i=N;--i>=0;) if(L[i]!=R[i]) return L[i]<R[i];\n\treturn 0;\n}\nint len(const BS &bs) {\n\tfor(int i=N;--i>=0;) if(bs[i]) return i+1;\n\treturn 0;\n}\n\nint h[6];\nvoid rref() {\n\tfor(int i=0;i<n;i++) h[i]=len(A[i])-1;\n\tfor(;;) {\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if(h[i]>=h[j]) {\n\t\t\tif(A[i] != A[j]<<(h[i]-h[j])) {\n\t\t\t\tA[i] ^= A[j]<<(h[i]-h[j]);\n\t\t\t\th[i]=len(A[i])-1;\n\t\t\t\tgoto win;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\twin:;\n\t}\n\tQ=A[min_element(h,h+n)-h];\n}\n\n\n\nconst int P=998244353;\nint powq(int x,int e) {\n\tif(!e) return 1;\n\tif(e&1) return int(1LL*x*powq(x,e-1)%P);\n\tx=powq(x,e>>1);\n\treturn int(1LL*x*x%P);\n}\n\n\nint32_t main() {\n\tcin>>n;\n\tread(X);\n\tfor(int i=0;i<n;i++) read(A[i]);\n\trref();\n\t// dbg(Q);\n\n\tint w=len(Q); assert(w>0);\n\tint m=len(X); assert(m>0);\n\tY.reset();\n\tif(w>m) return cout<<1<<endl,0;\n\tll Z=0;\n\tfor(int i=m-1;i>=w-1;i--) {\n\t\t// dbg(i,X,Y,i-(w-1));\n\t\tif(X[i]) Z+=powq(2,i-(w-1));\n\t\tif(X[i] != Y[i]) Y^=Q<<(i-(w-1));\n\t}\n\tif(!(X<Y)) ++Z;\n\tcout<<Z%P<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Ankur Dua\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nusing ll = long long;\nll mod=1000000007;\nll *fact, *ifact;\n\nusing cd = complex<long double>;\nconst long double PI = acos(-1);\n\nvoid fft(vector<cd> & a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        long double ang = 2 * PI / len * (invert ? -1 : 1);\n        cd wlen(cos(ang), sin(ang));\n        for (int i = 0; i < n; i += len) {\n            cd w(1);\n            for (int j = 0; j < len / 2; j++) {\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if (invert) {\n        for (cd & x : a)\n            x /= n;\n    }\n}\nvector<ll> multiply(vector<ll> const& a, vector<ll> const& b) {\n    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n    int n = 1;\n    while (n < a.size() + b.size())\n        n <<= 1;\n    fa.resize(n);\n    fb.resize(n);\n\n    fft(fa, false);\n    fft(fb, false);\n    for (int i = 0; i < n; i++)\n        fa[i] *= fb[i];\n    fft(fa, true);\n\n    vector<ll> result(n);\n    for (int i = 0; i < n; i++)\n        result[i] = round(fa[i].real());\n    return result;\n}\nstruct FlowEdge {\n    int v, u;\n    long long cap, flow = 0;\n\n    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}\n};\n\nstruct Dinic {\n    const long long flow_inf = 1e18;\n    vector<FlowEdge> edges;\n    vector<vector<int>> adj;\n    int n, m = 0;\n    int s, t;\n    vector<int> level, ptr;\n    queue<int> q;\n\n    Dinic(int n, int s, int t) : n(n), s(s), t(t) {\n        adj.resize(n);\n        level.resize(n);\n        ptr.resize(n);\n    }\n\n    void add_edge(int v, int u, long long cap) {\n        edges.emplace_back(v, u, cap);\n        edges.emplace_back(u, v, 0);\n        adj[v].push_back(m);\n        adj[u].push_back(m + 1);\n        m += 2;\n    }\n\n    bool bfs() {\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int id : adj[v]) {\n                if (edges[id].cap - edges[id].flow < 1)\n                    continue;\n                if (level[edges[id].u] != -1)\n                    continue;\n                level[edges[id].u] = level[v] + 1;\n                q.push(edges[id].u);\n            }\n        }\n        return level[t] != -1;\n    }\n\n    long long dfs(int v, long long pushed) {\n        if (pushed == 0)\n            return 0;\n        if (v == t)\n            return pushed;\n        for (int &cid = ptr[v]; cid < (int) adj[v].size(); cid++) {\n            int id = adj[v][cid];\n            int u = edges[id].u;\n            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)\n                continue;\n            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));\n            if (tr == 0)\n                continue;\n            edges[id].flow += tr;\n            edges[id ^ 1].flow -= tr;\n            return tr;\n        }\n        return 0;\n    }\n\n    long long flow() {\n        long long f = 0;\n        while (true) {\n            fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            q.push(s);\n            if (!bfs())\n                break;\n            fill(ptr.begin(), ptr.end(), 0);\n            while (long long pushed = dfs(s, flow_inf)) {\n                f += pushed;\n            }\n        }\n        return f;\n    }\n};\n\n//Min cost max flow using dijkstra from https://codeforces.com/contest/1107/submission/49033783\ntemplate<typename flow_t, typename cost_t>\nstruct MinCostMaxFlow {\n    static const flow_t FLOW_INF = numeric_limits<flow_t>::max() / 2;\n    const cost_t COST_INF = numeric_limits<cost_t>::max() / 2;\n    struct edge {\n        int node, rev;\n        flow_t capacity;\n        cost_t cost;\n\n        edge(int _node = -1, int _rev = -1, flow_t _capacity = 0, cost_t _cost = 0)\n                : node(_node), rev(_rev), capacity(_capacity), cost(_cost) {}\n    };\n\n    int V = -1;\n    vector<vector<edge>> adj;\n    vector<cost_t> dist;\n    vector<int> prev;\n    vector<edge*> prev_edge;\n\n    MinCostMaxFlow(int vertices = -1) {\n        if (vertices >= 0)\n            init(vertices);\n    }\n\n    void init(int vertices) {\n        V = vertices;\n        adj.assign(V, {});\n        dist.resize(V);\n        prev.resize(V);\n        prev_edge.resize(V);\n    }\n\n    void addEdge(int u, int v, flow_t capacity, cost_t cost) {\n        edge uv_edge(v, adj[v].size() + (u == v ? 1 : 0), capacity, cost);\n        edge vu_edge(u, adj[u].size(), 0, -cost);\n        adj[u].push_back(uv_edge);\n        adj[v].push_back(vu_edge);\n    }\n\n    edge &reverse_edge(const edge &e) {\n        return adj[e.node][e.rev];\n    }\n\n    bool bellman_ford(int source, int sink) {\n        for (int i = 0; i < V; i++) {\n            dist[i] = COST_INF;\n            prev[i] = -1;\n            prev_edge[i] = nullptr;\n        }\n\n        vector<int> last_seen(V, -1);\n        vector<int> nodes(1, source);\n        dist[source] = 0;\n\n        for (int iteration = 0; iteration < V; iteration++) {\n            vector<int> next_nodes;\n\n            for (int node : nodes)\n                for (edge &e : adj[node])\n                    if (e.capacity > 0 && dist[node] + e.cost < dist[e.node]) {\n                        dist[e.node] = dist[node] + e.cost;\n                        prev[e.node] = node;\n                        prev_edge[e.node] = &e;\n\n                        if (last_seen[e.node] != iteration) {\n                            last_seen[e.node] = iteration;\n                            next_nodes.push_back(e.node);\n                        }\n                    }\n\n            swap(nodes, next_nodes);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    struct dijkstra_state {\n        cost_t dist;\n        int node;\n\n        bool operator<(const dijkstra_state &other) const {\n            return dist > other.dist;\n        }\n    };\n\n    void dijkstra_check(int node, cost_t potential_dist, int previous, edge *previous_edge, auto &pq) {\n        if (potential_dist < dist[node]) {\n            dist[node] = potential_dist;\n            prev[node] = previous;\n            prev_edge[node] = previous_edge;\n            pq.push({dist[node], node});\n        }\n    }\n\n    bool dijkstra(int source, int sink) {\n        dist.assign(V, COST_INF);\n        prev.assign(V, -1);\n        prev_edge.assign(V, nullptr);\n\n        priority_queue<dijkstra_state> pq;\n        dijkstra_check(source, 0, -1, nullptr, pq);\n\n        while (!pq.empty()) {\n            dijkstra_state top = pq.top();\n            pq.pop();\n\n            if (top.dist > dist[top.node])\n                continue;\n\n            for (edge &e : adj[top.node])\n                if (e.capacity > 0)\n                    dijkstra_check(e.node, top.dist + e.cost, top.node, &e, pq);\n        }\n\n        return prev[sink] != -1;\n    }\n\n    void reduce_cost() {\n        for (int i = 0; i < V; i++)\n            for (edge &e : adj[i])\n                e.cost += dist[i] - dist[e.node];\n    }\n\n    pair<flow_t, cost_t> minCostFlow(int source, int sink, flow_t flow_goal = FLOW_INF) {\n        assert(V >= 0);\n\n        if (!bellman_ford(source, sink))\n            return make_pair(0, 0);\n\n        flow_t total_flow = 0;\n        cost_t total_cost = 0;\n        cost_t reduce_sum = 0;\n\n        do {\n            reduce_cost();\n            reduce_sum += dist[sink];\n            flow_t path_cap = flow_goal - total_flow;\n\n            for (int node = sink; prev[node] != -1; node = prev[node])\n                path_cap = min(path_cap, prev_edge[node]->capacity);\n\n            for (int node = sink; prev[node] != -1; node = prev[node]) {\n                edge *e = prev_edge[node];\n                assert(e->cost == 0);\n                e->capacity -= path_cap;\n                reverse_edge(*e).capacity += path_cap;\n            }\n\n            total_flow += path_cap;\n            total_cost += reduce_sum * path_cap;\n        } while (total_flow < flow_goal && dijkstra(source, sink));\n\n        return make_pair(total_flow, total_cost);\n    }\n};\n\nll modExp(ll base, ll exp, ll mod=::mod){\n    ll ans=1;\n    while(exp) {\n        if (exp & 1) {\n            (ans *= base) %= mod;\n        }\n        (base *= base) %= mod;\n        exp>>=1;\n    }\n    return ans;\n}\nll modInv(ll x, ll mod=::mod){\n    return modExp(x,mod-2,mod);\n}\nvoid modFact(ll n, ll mod=::mod){\n    ifact=new ll[n+1];\n    fact=new ll[n+1];\n    fact[0]=fact[1]=1;\n    for(int i=2;i<=n;i++){\n        fact[i]=(i*fact[i-1])%mod;\n    }\n    ifact[n]=modInv(fact[n], mod);\n    for(int i=n-1;i>=0;i--){\n        ifact[i]=((i+1)*ifact[i+1])%mod;\n    }\n}\nll ncr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[r];\n    ans%=mod;\n    ans*=ifact[n-r];\n    ans%=mod;\n    return ans;\n}\nll npr(ll n, ll r, ll mod=::mod){\n    if(n<r || r<0)\n        return 0;\n    ll ans=fact[n];\n    ans*=ifact[n-r];\n    return ans%mod;\n}\nclass DSU{\npublic:\n    int*p, *r;\n    DSU(int n){\n        p=new int[n+50];\n        r=new int[n+50];\n        for(int i=0;i<=n+10;i++){\n            p[i]=i;\n            r[i]=0;\n        }\n    }\n    ~DSU(){\n        delete[] p;\n        delete[] r;\n    }\n    int find(int x){\n        if(p[x]==x)\n            return x;\n        return p[x]=find(p[x]);\n    }\n    bool Unite(int a, int b){\n        a=find(a);\n        b=find(b);\n        if(a==b)\n            return false;\n        if(r[a]<r[b])\n            p[a]=b;\n        else\n            p[b]=a;\n        if(r[a]==r[b])\n            r[a]++;\n        return true;\n    }\n};\nusing namespace std;\nconst int mx=4500;\ntypedef bitset<mx> BS;\nll p2[mx];\nBS b;\nclass ARC84D {\npublic:\n    ll dfs(BS &x,vector<int> &cnt, int bp, bool eq, vector<BS> &basis){\n        if(bp==-1)\n            return 1;\n        if(!eq)\n            return p2[cnt[bp]];\n        ll ans=0;\n        if(x[bp] && b[bp]){\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,false,basis);\n                b^=basis[bp];\n                ans%=mod;\n            }\n        }else if(x[bp] && !b[bp]){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n            ans+=dfs(x,cnt,bp-1,false,basis);\n\n            ans%=mod;\n        }else if((!x[bp]) && (b[bp])){\n            if(basis[bp][bp]){\n                b^=basis[bp];\n                ans+=dfs(x,cnt,bp-1,eq,basis);\n                b^=basis[bp];\n            }\n        }else{\n            ans+=dfs(x,cnt,bp-1,eq,basis);\n        }\n\n        return ans;\n    }\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        int n;\n        cin>>n;\n\n        string xx;\n        cin>>xx;\n        BS x(xx);\n        vector<BS> basis(mx);\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            BS cur(s);\n\n            do{\n                BS v=cur;\n                for(int j=mx-1;j>=0;j--){\n                    if(v[j] && basis[j][j])\n                        v^=basis[j];\n                    else if(v[j]){\n                        basis[j]=v;\n                        break;\n                    }\n                }\n                if(!cur[mx-1])\n                    cur<<=1;\n                else break;\n            }while(true);\n        }\n        mod=998244353;\n        p2[0]=1;\n        for(int i=1;i<mx;i++){\n            p2[i]=(2*p2[i-1])%mod;\n        }\n        BS least;\n        for(int i=0;i<mx-1;i++){\n            if(basis[i][i]){\n                least=basis[i]<<1;\n                for(int j=i+1;j<mx;j++,least<<=1){\n                    if(!basis[j][j]){\n                        basis[j]=least;\n                    }\n                }\n                break;\n            }\n        }\n        vector<int> cnt(mx);\n        for(int i=0;i<mx;i++)\n            if(basis[i][i])\n                cnt[i]=1;\n        for(int i=1;i<mx;i++)\n            cnt[i]+=cnt[i-1];\n        b=BS();\n        cout<<dfs(x,cnt,mx-1,true,basis)<<endl;\n\t}\n};\n\n\nint main() {\n\tARC84D solver;\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(NULL);\n\tstd::cout.tie(NULL);\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\ninline int deg(const bitset <N> &b) {\n  int t = N - 1;\n  while (t >= 0 && !b[t]) t --;\n  return t + 1;\n}\n\nint n;\nchar buf[N];\n\ninline void read(bitset <N> &b) {\n  scanf(\"%s\", buf);\n  reverse(buf, buf + strlen(buf));\n  for (int i = 0; buf[i]; i ++)\n    b[i] = (bool)(buf[i] - '0');\n}\n\nbitset <N> X, A[N];\n\ninline bitset <N> gcd(bitset <N> p, bitset <N> q) {\n  int a = deg(p);\n  int b = deg(q);\n  while (true) {\n    if (!a) return q;\n    if (!b) return p;\n    if (a < b) {\n      swap(p, q); swap(a, b);\n    }\n    p ^= q << (a - b);\n    while (a >= 0 && p[a] == 0) a --;\n    a ++;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  read(X);\n  for (int i = 1; i <= n; i ++) read(A[i]);\n  for (int i = 2; i <= n; i ++)\n    A[1] = gcd(A[1], A[i]);\n  int ans = 0;\n  for (int i = deg(X) - 1, j = deg(A[1]) - 1; i >= j; i --) \n    ans = ((ans << 1) + X[i]) % mod;\n  ans = (ans + 1) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\ninline int deg(const bitset <N> &b) {\n  int t = N - 1;\n  while (t >= 0 && !b[t]) t --;\n  return t + 1;\n}\n\nint n;\nchar buf[N];\n\ninline void read(bitset <N> &b) {\n  scanf(\"%s\", buf);\n  reverse(buf, buf + strlen(buf));\n  for (int i = 0; buf[i]; i ++)\n    b[i] = (bool)(buf[i] - '0');\n}\n\nbitset <N> X, A[10];\n\ninline bitset <N> gcd(bitset <N> p, bitset <N> q) {\n  int a = deg(p);\n  int b = deg(q);\n  while (true) {\n    if (!a) return q;\n    if (!b) return p;\n    if (a < b) {\n      swap(p, q); swap(a, b);\n    }\n    p ^= q << (a - b);\n    while (a >= 0 && p[a] == 0) a --;\n    a ++;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  read(X);\n  for (int i = 1; i <= n; i ++) read(A[i]);\n  for (int i = 2; i <= n; i ++)\n    A[1] = gcd(A[1], A[i]);\n  int ans = 0, j = deg(A[1]);\n  for (int i = deg(X) - 1; i >= j - 1; i --) \n    ans = ((ans << 1) + X[i]) % mod;\n  for (int i = deg(X) - 1; i >= j - 1; i --)\n    if (X[i]) X ^= A[1] << (i - j + 1);\n  for (int i = j - 1; ~ i; i --)\n    if (A[1][i] != X[i]) {\n      if (A[1][i] < X[i]) ans --;\n      break;\n    }\n  ans = (ans + 1) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    constexpr uint MOD = 998244353;\n    using mint = ModInt<MOD>;\n    constexpr int L = 4000;\n    const int N = read<int>();\n    using B = std::bitset<L>;\n    B X(read<std::string>());\n    auto gcd = [&](auto&& self, B a, B b) {\n        if (a.count() == 0) { return b; }\n        if (a.to_string() > b.to_string()) { std::swap(a, b); }\n        int d = L - 1;\n        for (; d >= 0 and b[d] == 0; d--) {}\n        int dd = L - 1;\n        for (; dd >= 0 and a[dd] == 0; dd--) {}\n        for (; d >= 0; d--) {\n            if (b[d] == 0) { continue; }\n            const int sft = d - dd;\n            b ^= a << sft;\n        }\n        return self(self, b, a);\n    };\n    B g;\n    for (int i = 0; i < N; i++) { g = gcd(gcd, g, B(read<std::string>())); }\n    int d = L - 1;\n    auto x = X;\n    for (; d >= 0 and g[d] == 0; d--) {}\n    for (int l = L - 1; l >= 0; l--) {\n        if (x[l] == 0) { continue; }\n        const int sft = l - d;\n        x ^= g << sft;\n    }\n    B mask;\n    for (int i = 0; i < d; i++) { mask[i] = 1; }\n    X >>= d;\n    mint ans = (x.to_string() >= (X & mask).to_string()) ? 1 : 0, base = 1;\n    for (int i = 0; i < L; i++) { ans += base * X[i], base *= 2; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=100005;\nconst int mod=998244353;\nvoid debug(bitset<max_n> a){\n    for(int i=a._Find_first();i<max_n;i=a._Find_next(i))cout<<i<<' ';\n    cout<<\"ffff\"<<endl;\n}\ninline int Add(int x,int y){\n    return (x+=y)>=mod?x-mod:x;\n}\nbitset<max_n> gcd(bitset<max_n> a,bitset<max_n> b){\n    while(1){\n        //debug(a),debug(b);\n        int n=-1,m=-1;\n        for(int i=a._Find_first();i<max_n;i=a._Find_next(i))n=i;\n        for(int i=b._Find_first();i<max_n;i=b._Find_next(i))m=i;\n        if(n==-1)return b;\n        if(m==-1)return a;\n        if(n>=m)a^=b<<(n-m);\n        else b^=a<<(m-n);\n    }\n}\nint n;\nbitset<max_n> x;\nbitset<max_n> a;\nchar s[max_n];\nint solve(){\n    int res=0;\n    int n=-1,m=-1;\n    for(int i=x._Find_first();i<max_n;i=x._Find_next(i))n=i;\n    for(int i=a._Find_first();i<max_n;i=a._Find_next(i))m=i;\n    for(int i=n;i>=m;i--)res=(res*2+x[i])%mod;\n    bitset<max_n> r;r.reset();\n    for(int i=n;i>=m;i--){\n        if(r[i]!=x[i])r^=a<<(i-m);\n    }\n    int p=m-1;\n    while(p>=0&&r[p]==x[p])p--;\n    if(p==-1||r[p]<x[p])res=(res+1)%mod;\n    return res;\n}\nint main(){\n    scanf(\"%d\",&n);\n    scanf(\" %s\",s);\n    x=(bitset<max_n>)s; \n    for(int i=0;i<n;i++){\n        scanf(\" %s\",s);\n        a=gcd(a,(bitset<max_n>)s);\n    }\n    //debug(a);\n    printf(\"%d\\n\",solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 998244353;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 4010\nll p2[N];\n\nvoid xo(string &a, string &b){\n\tint n = min(a.size(), b.size());\n\trep(i, n) a[i] = '0'+(a[i]^b[i]);\n}\n\nvoid ker(vector<string> &s){\n\tint n = s.size();\n\trep(i, n-1){\n\t\twhile(s[i].size()>0){\n\t\t\tif(s[i].size()<s[i+1].size()) s[i].swap(s[i+1]);\n\t\t\txo(s[i], s[i+1]);\n\t\t\tint j = 0;\n\t\t\twhile(j<s[i].size() &&s[i][j]=='0') j++;\n\t\t\ts[i].erase(0, j);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tstring x;\n\tcin>>n>>x;\n\tint m = x.size();\n\tvector<string> s(n);\n\trep(i, n) cin>>s[i];\n\tker(s);\n\tstring a(s[n-1]), b(m, '0');\n\tp2[0] = 1;\n\trep(i, N-1) p2[i+1] = p2[i]*2%mod;\n\tll res = 1;\n\tint m2 = a.size(), l = m-m2+1;\n\trep(i, l){\n\t\tb.erase(0, 1); b += '0';\n\t\tif(x[i]=='1'){\n\t\t\tres += p2[l-i-1];\n\t\t\tif(b[0]=='0') xo(b, a);\n\t\t\t// todo\n\t\t} else {\n\t\t\tif(b[0]=='1') xo(b, a);\n\t\t}\n\t\tres %= mod;\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nconst int SZ = 4000;\nusing B = bitset< SZ >;\n\nint msb(const B &x) {\n  for(int i = SZ - 1; i > 0; i--) if(x[i]) return i;\n  return 0;\n}\n\nB gcd(B a, B b) {\n  int aa = msb(a), bb = msb(b);\n  if(aa < bb) swap(a, b), swap(aa, bb);\n  if(b.none()) return a;\n  return gcd(b, a ^ (b << (aa - bb)));\n}\n\nB in() {\n  string s;\n  cin >> s;\n  return B(s);\n}\n\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt &operator^=(int64_t n) {\n    int y = x;\n    x = 1;\n    while(n > 0) {\n      if(n & 1) x = 1LL * x * y % mod;\n      y = 1LL * y * y % mod;\n      n >>= 1;\n    }\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  ModInt operator^(const int64_t n) const { return ModInt(*this) ^= n; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\nint main() {\n  int N;\n\n  cin >> N;\n  B X = in();\n\n  B T(in());\n  for(int i = 1; i < N; i++) T = gcd(T, in());\n\n  vector< modint > mul(SZ);\n  mul[0] = 1;\n  for(int i = 1; i < SZ; i++) mul[i] = mul[i - 1] * 2;\n  modint ret = 1;\n  int m = msb(T);\n  B Y;\n  for(int i = SZ - 1; i >= m; i--) {\n    if(X[i]) ret += mul[i - m];\n    if(X[i] ^ Y[i]) Y ^= (T << (i - m));\n  }\n  for(int i = m - 1; i >= 0; i--) {\n    if(X[i]) break;\n    if(Y[i]) {\n      ret -= 1;\n      break;\n    }\n  }\n  cout << ret << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 4100;\nconst int base = 998244353;\n\nint X[maxn],G[maxn],b[maxn],p2[maxn],n,L1,L2,res,m;\n\nvoid poli_gcd() {\n    while (true) {\n        if (L1 > L2) {\n            swap(L1,L2);\n            swap(G,b);\n        }\n        for (int i=0;i<L1;i++) b[L2-L1+i] ^= G[i];\n        while (L2>0 && b[L2-1]==0) L2--;\n        if (L2==0) break;\n    }\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    p2[0]=1;\n    for (int i=1;i<maxn;i++) p2[i] = (2ll * p2[i-1])%base;\n    cin>>n;\n    string s;\n    cin>>s;\n    m = s.length();\n    for (int i=0;i<s.length();i++) X[i] = (s[s.length()-i-1]=='1');\n    cin>>s;\n    L1 = s.length();\n    for (int i=0;i<s.length();i++) G[i] = (s[s.length()-i-1]=='1');\n    for (int i=1;i<n;i++) {\n        cin>>s;\n        L2 = s.length();\n        for (int i=0;i<s.length();i++) b[i] = (s[s.length()-i-1]=='1');\n        poli_gcd();\n    }\n    if (L1 <=m) {\n        for (int i=L1-1;i<m;i++) {\n            if (X[i] == 1) res = (res + p2[i-L1+1]) % base;\n            if (b[i] != X[i]) {\n                for (int j = 0; j < L1; j++)\n                    b[i - L1 + 1 + j] ^= G[j];\n            }\n\t\t}\n        int p = L1 - 1;\n        while(p >= 0 && b[p] == X[p]) p--;\n        if (p < 0 || b[p] < X[p]) res = (res+1)%base;\n    }\n    cout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 4005;\nconst int MM = 998244353;\n\ntypedef bitset<MX> Integer;\nvoid print(Integer P);\n\nbool divide(Integer X, Integer Y, Integer &P, Integer &Q)\n{\n\tInteger Z = X;\n\tP.reset();\n\tint high = MX-1;\n\tfor(; high >= 0; high--) if(Y[high]) break;\n\tfor(int i = MX-high-1; i >= 0; i--){\n\t\tif( X[i+high] ){\n\t\t\tX ^= Y<<i;\n\t\t}\n\t\tif( Z[i+high] ){\n\t\t\tZ[i+high] = 0;\n\t\t\tP[i] = 1;\n\t\t}\n\t}\n\tQ = X;\n\tprint(Z);\n\tprint(Q);\n\tfor(int i = high-1; i >= 0; i--) if( Q[i] ) return Z[i];\n\treturn true;\n}\n\nchar buf[MX];\n\nInteger gcd(Integer A, Integer B){\n\tInteger C, D;\n\tdivide(A, B, C, D);\n\tif( D.none() ) return B;\n\telse return gcd(B, D);\n}\n\nInteger input(){\n\tInteger X; X.reset();\n\tscanf(\"%s\", buf);\n\tint L = strlen(buf);\n\tfor(int i = 0; buf[i]; i++) X[L-i-1] = buf[i]-'0';\n\treturn X;\n}\n\nvoid print(Integer P){\n//\tfor(int i = 0; i < 10; i++) printf(\"%d\", !!P[i]); printf(\"\\n\");\n}\n\nint main()\n{\n\tint N;\n\tInteger X, A[10];\n\tX.reset();\n\tscanf(\"%d\", &N);\n\tX = input();\n\tfor(int i = 1; i <= N; i++){\n\t\tA[i] = input();\n\t\tprint(A[i]);\n\t}\n\n\tInteger G = A[1];\n\tfor(int i = 2; i <= N; i++) G = gcd(G, A[i]);\n\tprint(G);\n\n\tInteger tmp, t2;\n\tint ans = 0, flag = 0;\n\tflag = divide(X, G, tmp, t2);\n\tfor(int i = MX-1; i >= 0; i--){\n\t\tans = (ans * 2 + tmp[i]) % MM;\n\t}\n\tprintf(\"%d\\n\", (ans+flag)%MM);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt operator+(const modInt &n){return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n){return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n){return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n){return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n){return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n){return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n){return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n){return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return ll(m.v)*modpow(n%mod,-1,mod)%mod;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\n\n\nmint solve(bitset<4000> x,int n,\n\t\t\t\t\t bitset<4000> a,int m){\n\trrep(i,4000){\n\t\tif(a[i] && !x[i]) return 1;\n\t\tif(!a[i] && x[i]) break;\n\t}\n\tif(n<m) return 1;\n\t//rrep(j,20)cout<<x[j];cout<<endl;\n\tmint re,ret;\n\tbitset<4000> sum; sum.reset();\n\trreps(i,m,n){\n\t\tre*=2;\n\t\tif(x[i]) re+=1;\n\t\tif(x[i]!=sum[i]) sum^=a<<(i-m+1);\n\t}\n\tre*=2;\n\trep(_,2){\n\t\tint ok=1;\n\t\t// rrep(j,20)cout<<sum[j];cout<<endl;\n\t\t// rrep(j,20)cout<<x[j];cout<<endl;\n\t\trrep(i,4000){\n\t\t\tif(i>=m) assert(x[i]==sum[i]);\n\t\t\tif(sum[i] && !x[i]){ ok=0; break;}\n\t\t\tif(!sum[i] && x[i]){ break;}\n\t\t}\n\t\t// out(ok,1);\n\t\tif(ok) ret+=1;\n\t\tsum^=a;\n\t}\n\t//out(re,ret,1);\n\treturn re+ret;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n\tstring x;\n\tcin>>n>>x;\n\tvector<pair<bitset<4000>,int>> as(n);\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tas[i].Y=s.size();\n\t\tas[i].X.reset();\n\t\trep(j,s.size()) as[i].X[j]=(s[s.size()-1-j]-'0');\n\t}\n\t// rep(i,as.size()){rrep(j,20)cout<<as[i].X[j];cout<<endl;}cout<<endl;\n\twhile(as.size()>1){\n\t\tsort(rall(as),[&](auto &l,auto &r){\n\t\t\t\treturn l.Y<r.Y;\n\t\t\t});\n\t\twhile(1){\n\t\t\tint upd=0;\n\t\t\trep(i,as.size())rep(j,i)if(as[i]==as[j]){\n\t\t\t\tas.erase(as.begin()+j);\n\t\t\t\tupd=1;\n\t\t\t}\n\t\t\trep(i,as.size())if(as[i].Y==0){\n\t\t\t\tas.erase(as.begin()+i);\n\t\t\t\tupd=1;\n\t\t\t}\n\t\t\tif(!upd) break;\n\t\t}\n\t\twhile(as.size() && as.back().Y==0) as.pop_back();\n\t\tif(as.size()<=1) break;\n\t\tas[0].X^=as[1].X<<(as[0].Y-as[1].Y);\n\t\tas[0].Y=0;\n\t\trep(i,4000){\n\t\t\tif(as[0].X[i]) as[0].Y=i+1;\n\t\t}\n\t}\n\t// rep(i,as.size()){rrep(j,20)cout<<as[i].X[j];cout<<\",\"<<as[i].Y<<endl;}cout<<endl;\n\n\tbitset<4000> st; st.reset();\n\trep(j,x.size()) st[j]=(x[x.size()-1-j]-'0');\n\tcout<<solve(st,x.size(),as[0].X,as[0].Y)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=998244353;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing BS = bitset<4000>;\n\nint N;\nstring X;\nLL pw2[4010];\nvector<BS> A;\nBS bases[4010];\n\nvoid Add(LL &t, LL v) {\n  t += v;\n  while (t >= MOD) t -= MOD;\n}\n\nBS MakeBitset(string &s) {\n  BS ret;\n  int idx = 3999;\n  rrep(i, s.size()) {\n    if (s[i] == '1') ret[idx] = 1;\n    else if (s[i] == '0') ret[idx] = 0;\n    else assert(0);\n    idx--;\n  }\n  return ret;\n}\n\nint RegBase(BS &v) {\n  while (1) {\n    int idx = v._Find_first();\n    if (idx == v.size()) {\n      assert(v.count() == 0);\n      return -1;\n    }\n\n    if (bases[idx].count() == 0) {\n      bases[idx] = v;\n      return idx;\n    }\n\n    v ^= bases[idx];\n    assert(v._Find_first() > idx);\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  cin >> N >> X;\n  rep(i, N) {\n    string s;\n    cin >> s;\n    A.eb(MakeBitset(s));\n  }\n  sort(all(A), [](const BS &a, const BS &b) {\n    return a._Find_first() < b._Find_first();\n  });\n  while (!A.empty() && !A.back().count()) A.pop_back();\n  reverse(all(A));\n\n  if (A.empty()) {\n    cout << \"1\\n\";\n    return 0;\n  }\n\n  int idx = A[0]._Find_first();\n  BS v = A[0];\n  while (1) {\n    int res = RegBase(v);\n    assert(res == idx);\n    if (res == -1) break;\n    v = bases[res] >> 1;\n    if (idx == 0) break;\n    idx--;\n  }\n\n  reps(i, 1, N) {\n    v = A[i];\n    idx = A[i]._Find_first();\n    while (1) {\n      int res = RegBase(v);\n      if (res == -1) break;\n      v = bases[res] >> 1;\n    }\n  }\n\n  int m = 0;\n  pw2[0] = 1;\n  rep(i, 4000) {\n    if (bases[i].count()) m++;\n    if (i > 0) {\n      Add(pw2[i], pw2[i-1]);\n      Add(pw2[i], pw2[i-1]);\n    }\n  }\n\n  X = string(4000-X.size(), '0') + X;\n  assert(X.size() == 4000);\n\n  BS cur;\n  LL ans = 1;\n  rep(i, 4000) {\n    if (!bases[i].count()) {\n      if (cur[i] > X[i]-'0') {\n        Add(ans, MOD-1);\n        break;\n      } else if (cur[i] < X[i] - '0') {\n        Add(ans, pw2[m]);\n        Add(ans, MOD-1);\n        break;\n      }\n    }\n\n    if (X[i] == '1') {\n      assert(m > 0);\n      Add(ans, pw2[m-1]);\n      if (!cur[i]) cur ^= bases[i];\n    } else if (X[i] == '0') {\n      if (cur[i]) cur ^= bases[i];\n    }\n\n    --m;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<LP> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nstruct F_2 {\n\tvector<int>  s;\n\tF_2(string t) {\n\t\ts.resize(t.length());\n\t\trep(i, t.length()) {\n\t\t\tif (t[i] == '1')s[i] = 1;\n\t\t\telse s[i] = 0;\n\t\t}\n\t}\n\tF_2(int c) {\n\t\ts = { c };\n\t}\n};\nbool operator!=(const F_2 &a, const F_2 &b) {\n\treturn a.s != b.s;\n}\nbool operator<=(const F_2 &a, const F_2 &b) {\n\tif (a.s.size() != b.s.size()) {\n\t\treturn a.s.size() < b.s.size();\n\t}\n\treturn a.s <= b.s;\n}\nF_2 operator-(const F_2 &a, const F_2 &b) {\n\t//assert(a.s.size()>=b.s.size())\n\tint len = b.s.size();\n\tF_2 ret = a;\n\trep(i, len) {\n\t\tif (b.s[i]) {\n\t\t\tret.s[i] ^= 1;\n\t\t}\n\t}\n\trep(i, ret.s.size()) {\n\t\tif (ret.s[i] || i == (int)ret.s.size() - 1) {\n\t\t\tret.s.erase(ret.s.begin(), ret.s.begin() + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nF_2 operator+(const F_2 &a, const F_2 &b) {\n\tint l1 = a.s.size(), l2 = b.s.size();\n\tint len = max(a.s.size(), b.s.size());\n\tF_2 ret(0); ret.s.resize(len);\n\trep(i, len) {\n\t\tint c = 0;\n\t\tif (i < l1&&a.s[l1 - 1 - i])c ^= 1;\n\t\tif (i < l2&&b.s[l2 - 1 - i])c ^= 1;\n\t\tret.s[len - 1 - i] = c;\n\t}\n\trep(i, ret.s.size()) {\n\t\tif (ret.s[i] || i == (int)ret.s.size() - 1) {\n\t\t\tret.s.erase(ret.s.begin(), ret.s.begin() + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nF_2 operator%(const F_2 &a, const F_2 &b) {\n\tF_2 ret = a;\n\tint len = b.s.size();\n\twhile (ret.s.size() >= len&&ret!=0) {\n\t\trep(i, len) {\n\t\t\tif(b.s[i])ret.s[i] ^= 1;\n\t\t}\n\t\trep(i, ret.s.size()) {\n\t\t\tif (ret.s[i] || i == (int)ret.s.size() - 1) {\n\t\t\t\tret.s.erase(ret.s.begin(), ret.s.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nF_2 gcd(F_2 a, F_2 b) {\n\tif (a.s.size() < b.s.size())swap(a, b);\n\twhile (b!=0) {\n\t\tF_2 r = a % b; a = b; b = r;\n\t\t/*rep(i, b.s.size()) {\n\t\t\tcout << b.s[i];\n\t\t}\n\t\tcout << endl;*/\n\t}\n\treturn a;\n}\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n > 0) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nvoid solve() {\n\tint n; string x; cin >> n >> x;\n\tF_2 s(x);\n\tF_2 g(\"0\");\n\trep(i, n) {\n\t\tstring s; cin >> s;\n\t\tF_2 f(s);\n\t\tg = gcd(g, s);\n\t}\n\tll ans = 0;\n\tF_2 cur(\"0\");\n\tint dif = (int)s.s.size() - (int)g.s.size();\n\tif (dif < 0) {\n\t\tcout << 1 << endl; return;\n\t}\n\tfor (int d = dif; d >= 0; d--) {\n\t\tint z = 0;\n\t\tif (cur.s.size() >= g.s.size() + d) {\n\t\t\tint len = cur.s.size();\n\t\t\tint id = len - (int)g.s.size() - d;\n\t\t\tif (cur.s[id])z = 1;\n\t\t}\n\t\tint l = s.s[dif - d];\n\t\tif (l == 1 && z == 1) {\n\t\t\tans += mod_pow(2, d);\n\t\t\tif (ans >= mod)ans -= mod;\n\t\t}\n\t\telse if (l == 1 && z == 0) {\n\t\t\tans += mod_pow(2, d);\n\t\t\tif (ans >= mod)ans -= mod;\n\n\t\t\tF_2 u = g;\n\t\t\trep(i, d)u.s.push_back(0);\n\t\t\tcur = cur + u;\n\t\t}\n\t\telse if (l == 0 && z == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tF_2 u = g;\n\t\t\trep(i, d)u.s.push_back(0);\n\t\t\tcur = cur + u;\n\t\t}\n\n\t}\n\tif (cur <= s)ans++;\n\tcout << ans % mod << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define mod 998244353\n\nlong long a,b;\nbitset<4040> p;\nlong long dp1[4000],dp2[4000];\n\nint main(){\n  dp1[0]=1;\n  dp2[0]=1;\n  cin>>a>>p;\n  for(int i=1;i<=4000;i++){\n    dp2[i]*=(dp2[i-1]*2)%mod;\n    if(p[i]){\n      b=i;\n      dp1[i]*=(dp1[i-1]*2)%mod;\n    }\n  }\n  cout<<(dp1[b]/dp2[b-1])%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <bitset>\n#include <iostream>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\nconst int N=4000;\nconst int mod=998244353;\nint n,m,len,a[9][N+1],f[N+1][N+1],s[N+1],ans;\nbool ex[N+1];\nvoid inc(int d){\n\tans=(ans+s[d])%mod;\n}\nint main(){\n\ts[0]=1;\n\tref(i,1,N)s[i]=s[i-1]*2%mod;\n\tscanf(\"%d\",&n);\n\tref(i,0,n){\n\t\tchar c=getchar();while(c<'0'||c>'1')c=getchar();\n\t\tm=-1;\n\t\twhile(c>='0'&&c<='1')a[i][++m]=c-48,c=getchar();\n\t\tref(j,0,m/2)swap(a[i][j],a[i][m-j]);\n\t\twhile(m>=0&&!a[i][m])m--;\n\t\tif(!i){len=m;continue;}\n\t\twhile(m>=0&&m<=N){\n\t\t\twhile(m>=0&&ex[m]){\n\t\t\t\tref(j,0,m)a[i][j]^=f[m][j];\n\t\t\t\twhile(m>=0&&!a[i][m])m--;\n\t\t\t}\n\t\t\tif(m<0)break;\n\t\t\tref(j,0,m)f[m][j]=a[i][j];ex[m]=1;\n\t\t\tdef(j,m,0)a[i][j+1]=a[i][j];a[i][0]=0;m++;\n\t\t}\n\t}\n\tm=N+1;\n\twhile(m>0&&ex[m-1])m--;\n\tif(m>N){printf(\"0\\n\");return 0;}\n\tdef(i,len,m){\n\t\tif(a[0][i]==1)inc(i-m);\n\t\tif(a[8][i]!=a[0][i])ref(j,0,i)a[8][j]^=f[i][j];\n\t}\n\tbool flag=1;\n\tdef(i,m-1,0)if(a[8][i]>a[0][i]){flag=0;break;}\n\t\telse if(a[8][i]<a[0][i])break;\n\tif(flag)inc(0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdint>\n#include <cassert>\n\n\n#include <iostream>\n#include <bitset>\n\ntemplate<const std::size_t N>\nstruct binfps {\n  using size_type = std::size_t;\n  using bit_type = std::uint_fast64_t;\n\n  const static size_type lg = 6;\n  const static bit_type lgmask = (bit_type(1) << lg) - 1;\n  const static size_type _w_len = (N + (bit_type(1) << lg) - 1) >> lg;\n  std::array<bit_type, _w_len> w;\n  size_type len;\n\n  binfps(): len(0) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n  }\n\n  binfps(const std::bitset<N>& b) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n    for(size_type i = 0; i < N; i++) {\n      if(b[i]) set(i);\n    }\n    recalc();\n  }\n\n  size_type size() const { return this->len; }\n  void recalc() {\n    len = 0;\n    for(size_type i = w.size(); i --> 0; ) {\n      if(w[i]) {\n        for(size_type j = (1 << lg); j --> 0;) {\n          if(w[i] >> j) {\n            len = j + 1 + (i << lg);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  void set(size_type i) { w[i >> lg] |= (bit_type(1) << (i & lgmask)); }\n  void unset(size_type i) { w[i >> lg] &= ~(bit_type(1) << (i & lgmask)); }\n\n  bool any() const {\n    for(size_type i = 0; i < _w_len; i++) {\n      if(w[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool operator[](size_type i) const {\n    return (w[i >> lg] >> (i & lgmask)) & 1;\n  }\n\n  binfps& operator^=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] ^= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator&=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator|=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n\n\n  binfps& operator<<=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    bit_type off = x >> lg;\n    bit_type m = x & lgmask;\n    bit_type dwmask = ((bit_type)(1) << (64 - m)) - 1;\n    if(m == 0) {\n      dwmask = ~(bit_type)(0);\n    }\n    bit_type upmask = ~dwmask;\n    // up\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i + off + 1] |= (w[i] & upmask) >> m;\n    }\n    // down\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i + off] |= (w[i] & dwmask) << m;\n    }\n\n    w = std::move(next);\n    len = std::min(N, len + x);\n    return (*this);\n  }\n\n  binfps& operator>>=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    bit_type off = x >> lg;\n    bit_type m = x & lgmask;\n    bit_type dwmask = (bit_type(1) << m) - 1;\n    if(m == 0) {\n      dwmask = 0;\n    }\n    bit_type upmask = ~dwmask;\n    // down\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i] |= (w[i + off + 1] & dwmask) << (64 - m);\n    }\n    // up\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i] |= (w[i + off] & upmask) >> m;\n    }\n    w = std::move(next);\n    if(len < x) {\n      len = 0;\n    }\n    else {\n      len = len - x;\n    }\n    return (*this);\n  }\n\n  binfps operator^(const binfps& b) const { return binfps(*this) ^= b; }\n  binfps operator&(const binfps& b) const { return binfps(*this) &= b; }\n  binfps operator|(const binfps& b) const { return binfps(*this) |= b; }\n  binfps operator<<(const size_type x) const { return binfps(*this) <<= x; }\n  binfps operator>>(const size_type x) const { return binfps(*this) >>= x; }\n  binfps operator~() {\n    binfps a = *this;\n    for(size_type i = w.size(); i --> 0;) {\n      a.w[i] = ~w[i];\n    }\n    return a;\n  }\n\n  bool operator<(const binfps& b) const {\n    bool OK = false;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] < b.w[i]) {\n          OK = true;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n  bool operator<=(const binfps& b) const {\n    bool OK = true;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] > b.w[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n\n  static binfps mod(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    for(int i = (int)a.size() - (int)b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static binfps div(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    binfps d;\n    for(int i = (int)a.size() - (int)b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        binfps e;\n        e.set(i);\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static binfps gcd(binfps a, binfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = std::move(b);\n      b = std::move(m);\n    }\n    return a;\n  }\n\n  void dump() const {\n    for(size_type i = _w_len; i --> 0; ) {\n      std::cerr << std::bitset<64>(w[i]) << \"|\" << std::endl;\n    }\n    std::cerr << std::endl;\n  }\n};\n\n\nconst int BN = 5000;\nusing bits = binfps<BN>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n \nint main() {\n  i64 N;\n  cin >> N;\n  std::bitset<BN> binp;\n  cin >> binp;\n  bits X(binp);\n  X.recalc();\n \n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> binp;\n    A[i] = bits(binp);\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    if(now <= X) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2018-05-06 20:54:33\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst ll mod=(ll)998244353;\nconst int N=4096;\ntypedef bitset<N> oo;\nbitset<N> an[11],x,gd;\nint clz(oo &a){\n    int l=1,r=a.size(),mid,ans=0;\n    while(l<=r){\n        mid=(l+r)>>1;\n        if((a>>(N-mid)).none()){\n            ans=mid;\n            l=mid+1;\n        } else r=mid-1;\n    }\n    return ans;\n}\noo gcd(oo a,oo b){\n    oo *x=&a,*y=&b;\n    int dx=N-clz(*x),dy=N-clz(*y);\n    if(dx<dy){\n        swap(dx,dy);\n        swap(x,y);\n    }\n    if(y->none())return *y;\n    oo res=gcd((*x)^((*y)<<(dx-dy)),*y);\n    if(res.none())return *y;\n    return res;\n}\nbool operator<=(const oo &a, const oo &b){\n    int l=1,r=a.size(),mid,ans=0;\n    while(l<=r){\n        mid=(l+r)>>1;\n        if((a>>(N-mid))==(b>>(N-mid))){\n            ans=mid;\n            l=mid+1;\n        }else r=mid-1;\n    }\n    if(ans==a.size())return 1;\n    return a[N-ans-1]<=b[N-ans-1];\n}\noo divide(oo a,oo b){\n    int da,db;\n    while(1){\n        da=N-clz(a);\n        db=N-clz(b);\n        if(da<db)break;\n        a^=b<<(da-db);\n    }\n    return a;\n}\nint main(){\n    // freopen(\"F.in\",\"r\",stdin);\n    // freopen(\"F.out\",\"w\",stdout);\n    int n;cin>>n;\n    string s;cin>>s;\n    x=bitset<N>(s);\n    rep(i,0,n){\n        cin>>s;an[i]=bitset<N>(s);\n    }\n    gd=an[0];\n    rep(i,1,n){\n        gd=gcd(gd,an[i]);\n    }\n    // per(i,SZ(gd),0)printf(\"%d\\n\",gd[i]?1:0);\n    int d=N-clz(gd),m=N-clz(x);\n    string sx=x.to_string();\n    reverse(all(sx));\n    ll ans=0;\n    per(i,m,d-1){ \n        if(sx[i]=='1'){\n            ans+=powmod(2,i-d+1,mod);\n        }\n    }\n    oo yu=divide(x,gd),tmp=x^yu;\n    assert(divide(tmp,gd).none());\n    if(tmp<=x)ans++;\n    ans%=mod;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <bitset>\n#include <iostream>\n#include <algorithm>\n\nconst int N=4005,P=998244353;\nint n,m,Ans,h[N],p,Fl;\nstd::bitset<N> a,b,c;\n\nint main()\n{\n    std::cin>>n>>a;\n    for(int i=1;i<=n;++i)\n        for(std::cin>>c;c.any();std::swap(b,c))\n        {\n            for(p=4000;;--p)if(c[p])break;\n            for(int j=4000;j>=p;--j)if(b[j])b^=c<<(j-p);\n        }\n    for(p=4000;;--p)if(b[p])break;\n    c=a,h[0]=Fl=1;\n    for(int i=1;i<=4000;++i)h[i]=(h[i-1]<<1)%P;\n    for(int i=p;i<=4000;++i)if(a[i])Ans=(Ans+h[i-p])%P;\n    for(int i=4000;i>=p;--i)if(a[i])a^=b<<(i-p);\n    for(int i=p;i>=0;--i)if(a[i])Fl=c[i],i=0;\n    printf(\"%d\\n\",(Ans+Fl)%P);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\ninline int deg(const bitset <N> &b) {\n  int t = N - 1;\n  while (!b[t] && t >= 0) t --;\n  return t + 1;\n}\n\nint n;\n\ninline void read(bitset <N> &b) {\n  static char buf[N];\n  scanf(\"%s\", buf);\n  reverse(buf, buf + strlen(buf));\n  for (int i = 0; buf[i]; i ++)\n    b[i] = (bool)(buf[i] - '0');\n}\n\nbitset <N> X, A[N];\n\ninline bitset <N> gcd(bitset <N> p, bitset <N> q) {\n  int a = deg(p);\n  int b = deg(q);\n  while (true) {\n    if (!a) return q;\n    if (!b) return p;\n    if (a < b) {\n      swap(p, q);\n      swap(a, b);\n    }\n    p ^= q << (a - b);\n    while (p[a] == 0 && a >= 0) a --;\n    a ++;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  read(X);\n  for (int i = 1; i <= n; i ++) read(A[i]);\n  for (int i = 2; i <= n; i ++)\n    A[1] = gcd(A[1], A[i]);\n  int ans = 0;\n  for (int i = deg(X) - 1, j = deg(A[1]) - 1; i >= j; i--) \n    ans = ((ans << 1) + X[i]) % mod;\n  ans = (ans + 1) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint n;\n\n#define MAX 4002\n\nchar buf[MAX];\n\n\nbitset<MAX> x;\n\nvoid read(bitset<MAX> &b) {\n\tb.reset();\n\tscanf(\"%s\", buf);\n\tint sz = strlen(buf);\n\tfor (int i = 0; i < sz; i++) {\n\t\tb.set(sz - i - 1, buf[i] - '0');\n\t}\n}\n\nbitset<MAX> gc;\nbitset<MAX> tmp;\n\nint idx(bitset<MAX> &a) {\n\tfor (int i = MAX - 1; i >= 0; i--) {\n\t\tif (a.test(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\nbitset<MAX> gcd(bitset<MAX> a, bitset<MAX> b) {\n\twhile (1) {\n\t\tint A = idx(a);\n\t\tint B = idx(b);\n\t\tif (A == -1) {\n\t\t\treturn b;\n\t\t}\n\t\tif (B == -1) {\n\t\t\treturn a;\n\t\t}\n\t\tif (A >= B) {\n\t\t\ta ^= b << (A - B);\n\t\t}\n\t\telse {\n\t\t\tb ^= a << (B - A);\n\t\t}\n\t}\n\treturn a;\n}\n#define MOD  998244353\nbitset<MAX> xx;\nlong long int p2[MAX];\nint main() {\n\tp2[0] = 1;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tp2[i] = p2[i - 1];\n\t\tp2[i] *= 2LL;\n\t\tp2[i] %= MOD;\n\t}\n\tcin >> n;\n\tread(x);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0) {\n\t\t\tread(gc);\n\t\t\tcontinue;\n\t\t}\n\t\tread(tmp);\n\t\tgc = gcd(gc, tmp);\n\t}\n\tint d = idx(gc);\n\tlong long int ans = 0;\n\tlong long int way = 0;\n\tfor (int i = MAX - 1; i >= d; i--) {\n\t\tif (x.test(i)) {\n\t\t\tway += p2[i - (d)];\n\t\t\tway %= MOD;\n\t\t}\n\t}\n\txx = x;\n\twhile (1) {\n\t\tint id1 = idx(xx);\n\t\tint id2 = idx(gc);\n\t\tif (id1 >= id2) {\n\t\t\txx ^= gc << (id1 - id2);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\txx ^= x;\n\tway++;\n\tfor (int i = MAX - 1; i >= 0; i--) {\n\t\tint A = x.test(i);\n\t\tint B = xx.test(i);\n\t\tif (A == B)continue;\n\t\tif (A < B) {\n\t\t\tway += MOD-1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tway %= MOD;\n\tprintf(\"%lld\\n\", way);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdint>\n#include <cassert>\n\n\n#include <iostream>\n#include <bitset>\n\ntemplate<const std::size_t N>\nstruct binfps {\n  using size_type = std::size_t;\n  using bit_type = std::uint_fast64_t;\n\n  const static size_type lg = 6;\n  const static size_type lgmask = (bit_type(1) << lg) - 1;\n  const static size_type _w_len = (N + (bit_type(1) << lg) - 1) >> lg;\n  std::array<bit_type, _w_len> w;\n  size_type len;\n\n  binfps(): len(0) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n  }\n\n  binfps(const std::bitset<N>& b) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n    for(size_type i = 0; i < N; i++) {\n      if(b[i]) set(i);\n    }\n    recalc();\n  }\n\n  int size() const { return this->len; }\n  void recalc() {\n    len = 0;\n    for(size_type i = w.size(); i --> 0; ) {\n      if(w[i]) {\n        for(size_type j = (1 << lg); j --> 0;) {\n          if(w[i] >> j) {\n            len = j + 1 + (i << lg);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  void set(size_type i) { w[i >> lg] |= (bit_type(1) << (i & lgmask)); }\n  void unset(size_type i) { w[i >> lg] &= ~(bit_type(1) << (i & lgmask)); }\n\n  bool any() const {\n    for(size_type i = 0; i < _w_len; i++) {\n      if(w[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool operator[](size_type i) const {\n    return (w[i >> lg] >> (i & lgmask)) & 1;\n  }\n\n  binfps& operator^=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] ^= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator&=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator|=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n\n\n  binfps& operator<<=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    size_type off = x >> lg;\n    size_type m = x & lgmask;\n    bit_type dwmask = ((bit_type)(1) << (64 - m)) - 1;\n    if(m == 0) {\n      dwmask = ~(bit_type)(0);\n    }\n    bit_type upmask = ~dwmask;\n    // up\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i + off + 1] |= (w[i] & upmask) >> (64 - m);\n    }\n    // down\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i + off] |= (w[i] & dwmask) << m;\n    }\n\n    w = std::move(next);\n    len = std::min(N, len + x);\n    return (*this);\n  }\n\n  binfps& operator>>=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    bit_type off = x >> lg;\n    bit_type m = x & lgmask;\n    bit_type dwmask = (bit_type(1) << m) - 1;\n    if(m == 0) {\n      dwmask = 0;\n    }\n    bit_type upmask = ~dwmask;\n    // down\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i] |= (w[i + off + 1] & dwmask) << (64 - m);\n    }\n    // up\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i] |= (w[i + off] & upmask) >> m;\n    }\n    w = std::move(next);\n    if(len < x) {\n      len = 0;\n    }\n    else {\n      len = len - x;\n    }\n    return (*this);\n  }\n\n  binfps operator^(const binfps& b) const { return binfps(*this) ^= b; }\n  binfps operator&(const binfps& b) const { return binfps(*this) &= b; }\n  binfps operator|(const binfps& b) const { return binfps(*this) |= b; }\n  binfps operator<<(const size_type x) const { return binfps(*this) <<= x; }\n  binfps operator>>(const size_type x) const { return binfps(*this) >>= x; }\n  binfps operator~() {\n    binfps a = *this;\n    for(size_type i = w.size(); i --> 0;) {\n      a.w[i] = ~w[i];\n    }\n    return a;\n  }\n\n  bool operator<(const binfps& b) const {\n    bool OK = false;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] < b.w[i]) {\n          OK = true;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n  bool operator<=(const binfps& b) const {\n    bool OK = true;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] > b.w[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n\n  static binfps mod(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    for(int i = (int)a.size() - (int)b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static binfps div(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    binfps d;\n    for(int i = (int)a.size() - (int)b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        binfps e;\n        e.set(i);\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static binfps gcd(binfps a, binfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = std::move(b);\n      b = std::move(m);\n    }\n    return a;\n  }\n\n  void dump() const {\n    for(size_type i = _w_len; i --> 0; ) {\n      std::cerr << std::bitset<64>(w[i]) << \"|\" << std::endl;\n    }\n    std::cerr << std::endl;\n  }\n};\n\n\nconst int BN = 5000;\nusing bits = binfps<BN>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n \nint main() {\n  i64 N;\n  cin >> N;\n  std::bitset<BN> binp;\n  cin >> binp;\n  bits X(binp);\n  X.recalc();\n \n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> binp;\n    A[i] = bits(binp);\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    if(now <= X) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\nstring str;\nint main() {\n    while (cin >> str) {\n        cout << str[0] << (int)str.size() - 1 << str.back() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define maxn 5005\n#define plus qaq\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\nint n;\nchar s[maxn];\nint t[maxn],a[10][maxn],g[maxn],temp[maxn];\nvoid trans(char *x,int *y)\n{\n\tint len=strlen(x);\n\tfor(int i=0;i<=len-1;i++)\n\t\ty[i]=x[len-1-i]-'0';\n}\nint deg(int *a)\n{\n\tfor(int i=4000;i>=0;i--)\n\t\tif(a[i])\n\t\t\treturn i;\n\treturn 0;\n}\nvoid plus(int *a,int *b,int m)\n{\n\tfor(int i=m;i<=4000;i++)\n\t\ta[i]=(a[i]^b[i-m]);\n}\nvoid getgcd(int *a,int *b,int *gg)\n{\n//\tfor(int i=0;i<=5;i++)\n//\t\tcerr<<a[i];\n//\tcerr<<endl;\n//\tfor(int i=0;i<=5;i++)\n//\t\tcerr<<b[i];\n//\tcerr<<endl;\n\tint da=deg(a),db=deg(b);\n\tif(da<db) swap(a,b),swap(da,db);\n//\tcerr<<\"this \"<<da<<\" \"<<db<<endl;\n\tif(db==0 && b[0]==0)\n\t{\n//\t\tmemcpy(gg,a,sizeof(a));\n\t\tfor(int i=0;i<=4000;i++)\n\t\t\tgg[i]=a[i];\n\t\treturn;\n\t}\n\tplus(a,b,da-db);\n\tgetgcd(b,a,gg);\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,s); trans(s,t);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",s); trans(s,a[i]);\n\t\tgetgcd(a[i],g,temp);\n\t\tmemcpy(g,temp,sizeof(g));\n//\t\tcerr<<\"its \"<<i<<endl;\n//\t\tfor(int j=0;j<=11;j++)\n///\t\t\tcerr<<g[j];\n//\t\tcerr<<endl;\n\t}\n\n\tint d=deg(g);\n\n//\tfor(int i=0;i<=11;i++)\n//\t\tcerr<<g[i];\n//\tcerr<<endl;\n\n\tmemset(temp,0,sizeof(temp));\n\n\tfor(int i=4000;i>=d;i--)\n\tif(temp[i]^t[i])\n\t{\n\t\tplus(temp,g,i-d);\n\t}\n\n\tll ans=0;\n\tint dd=deg(t);\n\tfor(int i=dd;i>=d;i--)\n\t\tans=((ans<<1)+t[i])%mod;\n\tfor(int i=dd-1;i>=0;i--)\n\t{\n\t\tif(temp[i]<t[i])\n\t\t\tbreak;\n\t\telse if(temp[i]>t[i])\n\t\t{\n\t\t\tans--;\n\t\t\tans=(ans%mod+mod)%mod;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ans+1)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 4005;\ntypedef bitset < maxN > bs;\nbs read() {\n    string s;\n    cin >> s;\n    bs f = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '1') f[s.size() - 1 - i] = true;\n    }\n    return f;\n}\nbs a[6];\nint get_last(const bs& f) {\n    for (int i = maxN - 1; i >= 0; i--) {\n        if (f[i] == true) return i;\n    }\n    return -1;\n}\nbs bs_gcd(bs x, bs y) {\n    while (true) {\n        int p1 = get_last(x);\n        int p2 = get_last(y);\n        if (p1 == -1) return y;\n        if (p2 == -1) return x;\n        if (p1 < p2) {\n            swap(x, y);\n            swap(p1, p2);\n        }\n        x = x ^ (y << (p1 - p2));\n    }\n}\nconst int mod = 998244353;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint pw2[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    bs x = read();\n    for (int i = 0; i < n; i++) {\n        a[i] = read();\n    }\n    bs gc = a[0];\n    for (int i = 1; i < n; i++) {\n        gc = bs_gcd(gc, a[i]);\n    }\n    pw2[0] = 1;\n    for (int i = 1; i < maxN; i++) pw2[i] = sum(pw2[i - 1], pw2[i - 1]);\n    int ans = 0;\n    int p1 = get_last(gc);\n    int p2 = get_last(x);\n    bs cur_xor = 0;\n    if (p1 >= p2) {\n        ans = sum(ans, 1);\n        bool bad = false;\n        for (int i = maxN - 1; i >= 0; i--) {\n            if (gc[i] != x[i]) {\n                if (gc[i] == true) {\n                    bad  = true;\n                    break;\n                }\n                break;\n            }\n        }\n        if (!bad) ans = sum(ans, 1);\n        cout << ans << '\\n';\n        return 0;\n    }\n\n    for (int i = p2; i >= p1; i--) {\n        if (cur_xor[i] == x[i]) {\n            if (x[i] == 1) {\n                ans = sum(ans, pw2[i - p1]);\n            }\n            //i shouldn't take\n        }\n        else if (x[i] == true) {\n            ans = sum(ans, pw2[i - p1]);\n            cur_xor ^= (gc << (i - p1));\n        }\n        else {\n            // should xor\n            cur_xor ^= (gc << (i - p1));\n        }\n    }\n    if (p2 >= p1) {\n        bool bad = false;\n        for (int i = p1 - 1; i >= 0; i--) {\n            if (cur_xor[i] != x[i]) {\n                if (cur_xor[i] == true) {\n                    bad  = true;\n                    break;\n                }\n                break;\n            }\n        }\n        if (!bad) ans = sum(ans, 1);\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\nconst int m = 4010;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel rui(m + 10, 1);\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nint max_true(bs &a,int jou) {\n\tint ans = jou;\n\trep(i, jou) {\n\t\tif (a[i]) { ans = i; }\n\t}\n\treturn ans;\n}\nbool can_div(bs &a, bs b, int &sza, int szb) {\n\tfor (int i = sza; i >= szb; i--) {\n\t\tif (a[i]) {\n\t\t\ta ^= b << (i - szb);\n\t\t}\n\t}\n\tsza = max_true(a, szb);\n\tif (sza == szb) { return true; }\n\treturn false;\n}\nbs gcd(bs a, bs b) {\n\tint sza = max_true(a,m);\n\tint szb = max_true(b,m);\n\tif (sza < szb) { swap(sza, szb); swap(a, b); }\n\twhile (true) {\n\t\tif (can_div(a, b, sza, szb)) { return b; }\n\t\tif (can_div(b, a, szb, sza)) { return a; }\n\t}\n}\nvoid solve(bs &x, bs &a) {\n\tint szx = max_true(x,m);\n\tint sza = max_true(a,m);\n\tbs to;\n\tint ans = 0;\n\tfor (int i = szx; i >= sza; i--) {\n\t\tif (x[i]) {\n\t\t\tans += rui[i - sza];\n\t\t}\n\t\tif (x[i] != to[i]) {\n\t\t\tto ^= a << (i - sza);\n\t\t}\n\t}\n\tcout << (ans + 1)%p << endl;\n}\nbs mak(string s) {\n\trev(s);\n\tbs ans;\n\trep(i, s.size()) {\n\t\tans[i] = (s[i] == '1');\n\t}\n\treturn ans;\n}\nsigned main() {\n\t\tint n; cin >> n;\n\t\tstring x; cin >> x;\n\t\tstring s; cin >> s;\n\t\tbs gcd0 = mak(s);\n\t\trep(i, n - 1) {\n\t\t\tstring ne; cin >> ne;\n\t\t\tbs newb = mak(ne);\n\t\t\tgcd0 = gcd(newb, gcd0);\n\t\t}\n\t\tbs nw = mak(x);\n\t\trep(i, m + 9) { rui[i + 1] = rui[i] * 2; rui[i + 1] %= p; }\n\t\tsolve(nw, gcd0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 998244353;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<u32 M = 1000000007>\nstruct modint{\n    u32 val;\n    modint(): val(0){}\n    template<typename T>\n    modint(T t){t %= (T)M; if(t < 0) t += (T)M; val = t;}\n\n    modint pow(ll k) const {\n        modint res(1), x(val);\n        while(k){\n            if(k&1) res *= x;\n            x *= x;\n            k >>= 1;\n        }\n        return res;\n    }\n    template<typename T>\n    modint& operator=(T t){t %= (T)M; if(t < 0) t += (T)M; val = t; return *this;}\n    modint inv() const {return pow(M-2);}\n    modint& operator+=(modint a){val += a.val; if(val >= M) val -= M; return *this;}\n    modint& operator-=(modint a){if(val < a.val) val += M-a.val; else val -= a.val; return *this;}\n    modint& operator*=(modint a){val = (u64)val*a.val%M; return *this;}\n    modint& operator/=(modint a){return (*this) *= a.inv();}\n    modint operator+(modint a) const {return modint(val) +=a;}\n    modint operator-(modint a) const {return modint(val) -=a;}\n    modint operator*(modint a) const {return modint(val) *=a;}\n    modint operator/(modint a) const {return modint(val) /=a;}\n    modint operator-(){return modint(M-val);}\n    bool operator==(const modint a) const {return val == a.val;}\n    bool operator!=(const modint a) const {return val != a.val;}\n    bool operator<(const modint a) const {return val < a.val;}\n};\nusing mint = modint<MOD>;\n\nint main() {\n    using B = bitset<4000>;\n    auto f = [&](string &s) -> B {\n        B res;\n        for (int i = 0; i < s.size(); ++i) {\n            if(s[i] == '1') res.set(4000+i-(int)s.size());\n        }\n        return res;\n    };\n    int n; B X;\n    cin >> n;\n    vector<B> v(n);\n    {\n        string x;\n        cin >> x;\n        X = f(x);\n        for (int i = 0; i < n; ++i) cin >> x, v[i] = f(x);\n    }\n    for (int i = 1; i < n; ++i) {\n        int a = v[0]._Find_first(), b = v[i]._Find_first();\n\n        while(true){\n            if(a == 4000 || b == 4000) {\n                if(a == 4000) swap(v[0], v[i]);\n                break;\n            }\n            if(a > b){\n                v[i] ^= (v[0] >> (a-b));\n                b = v[i]._Find_first();\n            }else {\n                v[0] ^= (v[i] >> (b-a));\n                a = v[0]._Find_first();\n            }\n        }\n    }\n\n    int a = v[0]._Find_first(), b = X._Find_first();\n    B Y;\n    mint ans = 0;\n    for (int i = b; i <= a; ++i) {\n        if(X[i]) {\n            ans += mint(2).pow(a-i);\n        }\n        if(X[i] != Y[i]){\n            Y ^= (v[0] >> (a-i));\n        }\n    }\n    int ok = 1;\n    for (int i = 3999; i >= 0; --i) {\n        if(X[0] && !Y[0]) {\n            ok = 0;\n            break;\n        }\n        else if(!X[0] && Y[0]) break;\n    }\n    if(ok) ans += mint(1);\n    cout << ans.val << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing B = bitset<4000>;\nusing ll = long long;\nstring str; \nll N, ans, dp[4000];\nconstexpr ll M{ 998244353 };\nB bit_gcd(B a, B b) {\n    if(a == B{}) return b;\n    int msb_a{}, msb_b{};\n    for(int i{}; i < 4000; ++i) {\n        if(a.test(i)) msb_a = i;\n        if(b.test(i)) msb_b = i;\n    }\n    b ^= a << (msb_b - msb_a);\n    return bit_gcd(b, a);\n}\nint main() {\n    dp[0] = 1;\n    for(int i{ 1 }; i < 4000; ++i) dp[i] = dp[i - 1] * 2 % M;\n    cin >> N >> str;\n    B X(str), x, a;\n    vector<B> v;\n    for(int i{}; i < N; ++i) {\n        cin >> str;\n        v.emplace_back(str);\n    }\n    a = v.front();\n    for(auto& b : v) {\n        if(a == b) continue;\n        for(int i{ 3999 }; i >= 0; --i) {\n            if(a.test(i) && !b.test(i)) {\n                swap(a, b);\n                break;\n            }\n            if(!a.test(i) && b.test(i)) break;\n        }\n        a = bit_gcd(a, b);\n    }\n    int msb_X{}, msb_a{};\n    for(int i{}; i < 4000; ++i) {\n        if(X.test(i)) msb_X = i;\n        if(a.test(i)) msb_a = i;\n    }\n    for(int i{ msb_X }; i >= msb_a; --i) {\n        if(X.test(i)) ans = (ans + dp[i - msb_a]) % M;\n        if(X.test(i) ^ x.test(i)) x ^= a << (i - msb_a);\n    }\n    ans = (ans + 1) % M;\n    for(int i{ msb_a }; i >= 0; --i) {\n        if(X.test(i) && !x.test(i)) break;\n        if(!X.test(i) && x.test(i)) { --ans; break; }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<998244353> mint;\n/*---------------------------------------------------------------------------------------------------\n   \n  <_  Welcome to My Coding Space!\n  _`/ i     \n   ||     \n / //|  \n _(__/    / .| .|  \n //u  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N; string X, A[10];\n//---------------------------------------------------------------------------------------------------\nchar XOR(char a, char b) {\n    if (a == b) return '0';\n    return '1';\n}\n//---------------------------------------------------------------------------------------------------\nstring gcd(string a, string b) {\n    while (true) {\n        if (a.size() < b.size()) swap(a, b);\n        rep(i, 0, b.size()) a[i] = XOR(a[i], b[i]);\n        int pos = a.find('1');\n        if (pos == string::npos) return b;\n        a.erase(0, pos);\n    }\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> X;\n    rep(i, 0, N) cin >> A[i];\n\n    string g = A[0];\n    rep(i, 1, N) g = gcd(g, A[i]);\n\n    mint ans = 0;\n    int M = (int)X.length() - (int)g.length() + 1;\n    rep(i, 0, M) {\n        ans *= 2;\n        if (X[i] == '1') ans += mint(1);\n    }\n\n    if (0 <= M) {\n        string Y = \"\";\n        rep(i, 0, X.length()) Y += \"0\";\n        rep(i, 0, M) {\n            if (X[i] != Y[i]) {\n                rep(j, 0, g.length()) Y[i + j] = XOR(Y[i + j], g[j]);\n            }\n        }\n\n        int ok = 1;\n        rep(i, M, X.length()) if(X[i] != Y[i]){\n            if (X[i] < Y[i]) ok = 0;\n            break;\n        }\n        if (ok) ans += 1;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define bits bitset<N>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=4005,mod=998244353;\nint pw[N],n,m,l,ans;\nbits a[N],x,g,now;\nchar st[N];\n\nbits gcd(bits a,bits b){\n\tint la=N-1,lb=N-1;\n\twhile(la>=0&&lb>=0){\n\t\twhile(la>=0&&!a[la]) la--;\n\t\twhile(lb>=0&&!b[lb]) lb--;\n\t\tif(la<0||lb<0) break;\n\t\tif(la<lb) b^=a<<(lb-la);\n\t\telse a^=b<<(la-lb);\n\t}\n\treturn la<0?b:a;\n}\n\nint main(){\n\tpw[0]=1;\n\trep(i,1,N-1) pw[i]=2*pw[i-1]%mod;\n\tscanf(\"%d%s\",&n,st),m=strlen(st);\n\tREP(i,m) if(st[i]=='1') x.set(m-1-i);\n\trep(i,1,n){\n\t\tscanf(\"%s\",st),m=strlen(st);\n\t\tREP(j,m) if(st[j]=='1') a[i].set(m-1-j);\n\t}\n\tg=a[1];\n\trep(i,2,n) g=gcd(g,a[i]);\n\tl=N-1;\n\twhile(!g[l]) l--;\n\tper(i,N-1,l)\n\t\tif(x[i]){\n\t\t\tif(!now[i]) now^=g<<(i-l);\n\t\t\tans=(ans+pw[i-l])%mod;\n\t\t}\n\t\telse{\n\t\t\tif(now[i]) now^=g<<(i-l);\n\t\t}\n\tint flag=0;\n\tper(i,l,0){\n\t\tif(now[i]==x[i]) continue;\n\t\tif(now[i]&&!x[i]) flag=1;\n\t\tbreak;\n\t}\n\tif(!flag) ans=(ans+1)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 998244353;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<u32 M = 1000000007>\nstruct modint{\n    u32 val;\n    modint(): val(0){}\n    template<typename T>\n    modint(T t){t %= (T)M; if(t < 0) t += (T)M; val = t;}\n\n    modint pow(ll k) const {\n        modint res(1), x(val);\n        while(k){\n            if(k&1) res *= x;\n            x *= x;\n            k >>= 1;\n        }\n        return res;\n    }\n    template<typename T>\n    modint& operator=(T t){t %= (T)M; if(t < 0) t += (T)M; val = t; return *this;}\n    modint inv() const {return pow(M-2);}\n    modint& operator+=(modint a){val += a.val; if(val >= M) val -= M; return *this;}\n    modint& operator-=(modint a){if(val < a.val) val += M-a.val; else val -= a.val; return *this;}\n    modint& operator*=(modint a){val = (u64)val*a.val%M; return *this;}\n    modint& operator/=(modint a){return (*this) *= a.inv();}\n    modint operator+(modint a) const {return modint(val) +=a;}\n    modint operator-(modint a) const {return modint(val) -=a;}\n    modint operator*(modint a) const {return modint(val) *=a;}\n    modint operator/(modint a) const {return modint(val) /=a;}\n    modint operator-(){return modint(M-val);}\n    bool operator==(const modint a) const {return val == a.val;}\n    bool operator!=(const modint a) const {return val != a.val;}\n    bool operator<(const modint a) const {return val < a.val;}\n};\nusing mint = modint<MOD>;\n\nint main() {\n    using B = bitset<4000>;\n    auto f = [&](string &s) -> B {\n        B res;\n        for (int i = 0; i < s.size(); ++i) {\n            if(s[i] == '1') res.set(4000+i-(int)s.size());\n        }\n        return res;\n    };\n    int n; B X;\n    cin >> n;\n    vector<B> v(n);\n    {\n        string x;\n        cin >> x;\n        X = f(x);\n        for (int i = 0; i < n; ++i) cin >> x, v[i] = f(x);\n    }\n    for (int i = 1; i < n; ++i) {\n        int a = v[0]._Find_first(), b = v[i]._Find_first();\n\n        while(true){\n            if(a == 4000 || b == 4000) {\n                if(a == 4000) swap(v[0], v[i]);\n                break;\n            }\n            if(a > b){\n                v[i] ^= (v[0] >> (a-b));\n                b = v[i]._Find_first();\n            }else {\n                v[0] ^= (v[i] >> (b-a));\n                a = v[0]._Find_first();\n            }\n        }\n    }\n\n    int a = v[0]._Find_first(), b = X._Find_first();\n    B Y;\n    mint ans = 0;\n    for (int i = b; i <= a; ++i) {\n        if(X[i]) {\n            ans += mint(2).pow(a-i);\n        }\n        if(X[i] != Y[i]){\n            Y ^= (v[0] >> (a-i));\n        }\n    }\n    int ok = 1;\n    for (int i = 0; i < 4000; ++i) {\n        if(!X[i] && Y[i]) {\n            ok = 0;\n            break;\n        } else if(X[i] && !Y[i]) break;\n    }\n    if(ok) ans += mint(1);\n    cout << ans.val << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nbitset<4000> X,P;\nll mo=998244353;\nll p2[202020];\nint ng;\n\nbitset<4000> gcd(bitset<4000> A,bitset<4000> B) {\n\tint i;\n\tfor(i=3999;i>=0;i--) {\n\t\tif(A[i]==1 && B[i]==1) {\n\t\t\tB^=A;\n\t\t\tbreak;\n\t\t}\n\t\tif(A[i]==1) break;\n\t\tif(B[i]==1) {\n\t\t\tswap(A,B);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// A>B\n\twhile(1) {\n\t\tint x;\n\t\tfor(x=i-1;x>=0;x--) if(B[x]) break;\n\t\tif(x<0) break;\n\t\twhile(i>=x) {\n\t\t\tif(A[i]) A^=B<<(i-x);\n\t\t\ti--;\n\t\t}\n\t\ti=x;\n\t\tswap(A,B);\n\t}\n\treturn A;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tp2[0]=1;\n\tFOR(i,101010) p2[i+1]=p2[i]*2%mo;\n\t\n\tcin>>N>>S;\n\tFOR(i,S.size()) if(S[i]=='1') X[S.size()-1-i]=1;\n\tFOR(j,N) {\n\t\tcin>>S;\n\t\tbitset<4000> B;\n\t\tFOR(i,S.size()) if(S[i]=='1') B[S.size()-1-i]=1;\n\t\tif(j==0) P=B;\n\t\telse P=gcd(P,B);\n\t}\n\t\n\tll ret=0;\n\tFOR(i,4000) if(P[i]) x=i;\n\tfor(i=3999;i>=x;i--) if(X[i]) ret+=p2[i-x];\n\tfor(i=3999;i>=x;i--) if(X[i]) X^=P<<(i-x);\n\t\n\tret++;\n\tfor(i=x-1;i>=0;i--) {\n\t\tif(X[i]<P[i]) {\n\t\t\tret--;\n\t\t\tbreak;\n\t\t}\n\t\tif(X[i]>P[i]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 998244353;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 4010\nll p2[N];\n\nvoid xo(string &a, string &b){\n\tint n = min(a.size(), b.size());\n\trep(i, n) a[i] = '0'+(a[i]^b[i]);\n}\n\nbool le(string &a, string &b){\n\tint n = min(a.size(), b.size());\n\trep(i, n){\n\t\tif(a[i]<b[i]) return true;\n\t\tif(a[i]>b[i]) return false;\n\t}\n\treturn true;\n}\n\nvoid ker(vector<string> &s){\n\tint n = s.size();\n\trep(i, n-1){\n\t\twhile(s[i].size()>0){\n\t\t\tif(s[i].size()<s[i+1].size()) s[i].swap(s[i+1]);\n\t\t\txo(s[i], s[i+1]);\n\t\t\tint j = 0;\n\t\t\twhile(j<s[i].size() &&s[i][j]=='0') j++;\n\t\t\ts[i].erase(0, j);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tstring x;\n\tcin>>n>>x;\n\tint m = x.size();\n\tvector<string> s(n);\n\trep(i, n) cin>>s[i];\n\tker(s);\n\tstring a(s[n-1]), b(m, '0');\n\tp2[0] = 1;\n\trep(i, N-1) p2[i+1] = p2[i]*2%mod;\n\tll res = 0;\n\tint m2 = a.size(), l = m-m2+1;\n\trep(i, l){\n\t\tb.erase(0, 1); b += '0';\n\t\tif(x[i]=='1'){\n\t\t\tres += p2[l-i-1];\n\t\t\tif(b[0]=='0'){\n\t\t\t\txo(b, a);\n\t\t\t}\n\t\t} else {\n\t\t\tif(b[0]=='1'){\n\t\t\t\txo(b, a);\n\t\t\t}\n\t\t}\n\t\tres %= mod;\n\t}\n\t/*cerr<<\"debug\"<<endl;\n\tcerr<<a<<endl;\n\tcerr<<b<<endl;\n\tcerr<<x<<endl;*/\n\tif(le(b, x)) res++;\n\tcout<<res%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<bitset>\n#include<cstdio>\n#define MN 4000\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,ans,pw[MN+5];\nchar s[MN+5],t[8][MN+5];\nbitset<MN+5> b[8],g,a;\nbitset<MN+5> gcd(const bitset<MN+5>&a,const bitset<MN+5>&b,int d,int D)\n{\n\twhile(d&&!a[d-1]) --d;while(D&&!b[D-1]) --D;\n\tif(!d) return b;if(!D) return a;\t\n\tif(d<=D) return gcd(a,(a<<D-d)^b,d,D);\n\telse return gcd(b,(b<<d-D)^a,D,d);\n}\nint main()\n{\n\tn=read();scanf(\"%s\",s+1); \n\tfor(int i=1;i<=n;++i) scanf(\"%s\",t[i]+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint d=strlen(t[i]+1);\n\t\tfor(int j=0;j<d;++j) b[i][j]=t[i][d-j]-'0';\t\n\t}\n\tg=b[1];for(int i=2;i<=n;++i) g=gcd(g,b[i],MN,MN);\n\tint deg=MN,len=strlen(s+1);for(;!g[deg-1];) --deg;pw[0]=1;\n\tfor(int i=1;i<=len;++i) pw[i]=2*pw[i-1]%mod;\n\tfor(int i=1;i+deg-1<=len;++i)\n\t{\n\t\tbitset<MN+5> nx;int flag=0; \n\t\tif(!(s[i]=='0'&&a[len-i]))\n\t\t{\n\t\t\tif(a[len-i]<s[i]-'0') (ans+=pw[len-deg+1-i])%=mod;\n\t\t\telse nx=a,flag=1;\n\t\t}\n\t\tif(!(s[i]=='0'&&!a[len-i]))\n\t\t{\n\t\t\tif((a[len-i]^1)<s[i]-'0') (ans+=pw[len-deg+1-i])%=mod;\n\t\t\telse nx=(a^(g<<(len-deg+1-i))),flag=1;\n\t\t}\n\t\tif(!flag) {--ans;break;} else a=nx;\n\t}\n\tcout<<(ans+1)%mod;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 4005;\nconst int MM = 998244353;\n\ntypedef bitset<MX> Integer;\n\nvoid divide(Integer X, Integer Y, Integer &P, Integer &Q)\n{\n\tInteger Z = X;\n\tP.reset();\n\tint high = MX-1;\n\tfor(; high >= 0; high--) if(Y[high]) break;\n\tfor(int i = MX-high-1; i >= 0; i--){\n\t\tif( X[i+high] ){\n\t\t\tX ^= Y<<i;\n\t\t}\n\t\tif( Z[i+high] ){\n\t\t\tP[i] = 1;\n\t\t}\n\t}\n\tQ = X;\n}\n\nchar buf[MX];\n\nInteger gcd(Integer A, Integer B){\n\tInteger C, D;\n\tdivide(A, B, C, D);\n\tif( D.none() ) return B;\n\telse return gcd(B, D);\n}\n\nInteger input(){\n\tInteger X; X.reset();\n\tscanf(\"%s\", buf);\n\tint L = strlen(buf);\n\tfor(int i = 0; buf[i]; i++) X[L-i-1] = buf[i]-'0';\n\treturn X;\n}\n\nvoid print(Integer P){\n//\tfor(int i = 0; i < 10; i++) printf(\"%d\", !!P[i]); printf(\"\\n\");\n}\n\nint main()\n{\n\tint N;\n\tInteger X, A[10];\n\tX.reset();\n\tscanf(\"%d\", &N);\n\tX = input();\n\tfor(int i = 1; i <= N; i++){\n\t\tA[i] = input();\n\t\tprint(A[i]);\n\t}\n\n\tInteger G = A[1];\n\tfor(int i = 2; i <= N; i++) G = gcd(G, A[i]);\n\tprint(G);\n\n\tInteger tmp, t2;\n\tdivide(X, G, tmp, t2);\n\tint ans = 0;\n\tfor(int i = MX-1; i >= 0; i--){\n\t\tans = (ans * 2 + tmp[i]) % MM;\n\t}\n\tprintf(\"%d\\n\", (ans+1)%MM);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<998244353> mint;\n/*---------------------------------------------------------------------------------------------------\n   \n  <_  Welcome to My Coding Space!\n  _`/ i     \n   ||     \n / //|  \n _(__/    / .| .|  \n //u  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N; string X, A[10];\n//---------------------------------------------------------------------------------------------------\nchar XOR(char a, char b) {\n    if (a == b) return '0';\n    return '1';\n}\n//---------------------------------------------------------------------------------------------------\nstring gcd(string a, string b) {\n    while (true) {\n        if (a.size() < b.size()) swap(a, b);\n        rep(i, 0, b.size()) a[i] = XOR(a[i], b[i]);\n        int pos = a.find('1');\n        if (pos == string::npos) return b;\n        a.erase(0, pos);\n    }\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> X;\n    rep(i, 0, N) cin >> A[i];\n\n    string g = A[0];\n    rep(i, 1, N) g = gcd(g, A[i]);\n\n    mint ans = 0;\n    rep(i, 0, (int)X.length() - (int)g.length() + 1) {\n        ans *= 2;\n        if (X[i] == '1') ans += mint(1);\n    }\n\n    if (0 <= (int)X.length() - (int)g.length()) {\n        string Y = \"\";\n        rep(i, 0, X.length()) Y += \"0\";\n        rep(i, 0, (int)X.length() - (int)g.length()) {\n            if (X[i] != Y[i]) {\n                rep(j, 0, g.length()) Y[i + j] = XOR(Y[i + j], g[j]);\n            }\n        }\n\n        int ok = 1;\n        rep(i, (int)X.length() - (int)g.length(), (int)X.length()) {\n            if (X[i] < Y[i]) {\n                ok = 0;\n                break;\n            }\n            if (X[i] > Y[i]) break;\n        }\n        if (ok) {\n            ans += 1;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, i,j, s, k, o;\nint main()\n{\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\tif ((i ^ j ^ k) == 0) {\n\t\t\t\t\t\tif (o) s += i *j;\n\t\t\t\t\t\to = 1 - o;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << s;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n\nconst long long mod = 998244353;\n\nstring normalize(string s) {\n  int pos = s.find(1);\n  if (pos == string::npos) return \"\";\n  return s.substr(pos);\n}\n\nstring gcd(string a, string b) {\n  while (true) {\n    if (a.size() > b.size()) {\n      for (int i = 0; i < b.size(); i++) {\n        a[i] ^= b[i];\n      }\n      a = normalize(a);\n      if (a.empty()) return b;\n    } else {\n      for (int i = 0; i < a.size(); i++) {\n        b[i] ^= a[i];\n      }\n      b = normalize(b);\n      if (b.empty()) return a;\n    }\n  }\n}\n\nstring input() {\n  string s;\n  cin >> s;\n  for (char &c : s) c -= '0';\n  return s;\n}\n\nlong long modpow(long long x, long long y) {\n  long long ret = 1;\n  while (y > 0) {\n    if (y & 1) ret = ret * x % mod;\n    x = x * x % mod;\n    y >>= 1;\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  string x = input();\n  string g = input();\n  for (int i = 1; i < n; i++) {\n    g = gcd(g, input());\n  }\n\n  long long ans = 0;\n  string curr(x.size(), 0);\n  for (int i = 0; i + g.size() <= x.size(); i++) {\n    if (curr[i] == 0 && x[i] == 0) {\n      // can't use\n    } else if (curr[i] == 1 && x[i] == 0) {\n      for (int j = 0; j < g.size(); j++) {\n        curr[i + j] ^= g[j];\n      }\n    } else if (curr[i] == 0 && x[i] == 1) {\n      for (int j = 0; j < g.size(); j++) {\n        curr[i + j] ^= g[j];\n      }\n      ans += modpow(2, x.size() - i - g.size());\n      ans %= mod;\n    } else if (curr[i] == 1 && x[i] == 1) {\n      ans += modpow(2, x.size() - i - g.size());\n      ans %= mod;\n    }\n  }\n  if (curr <= x) {\n    ans++;\n    ans %= mod;\n  }\n  \n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int LG = 21;\nconst int N = 4005;\nconst long long MOD = 998244353;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define pb push_back\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring YES[2] = {\"NO\", \"YES\"};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint Root(int x, vector<int> &root)\n{\n    if (x == root[x]) return x;\n    return root[x] = Root(root[x], root);\n}\n\nvoid Merge(int v, int u, vector<int> &root, vector<int> &sz)\n{\n    v = Root(v, root), u = Root(u, root);\n    if (v == u) return;\n    if (sz[v] < sz[u])\n    {\n        sz[u] += sz[v];\n        root[v] = u;\n    }\n    else\n    {\n        sz[v] += sz[u];\n        root[u] = v;\n    }\n}\n\nint ok(int x, int n)\n{\n    return 0 <= x && x < n;\n}\n\nvoid bfs(int v, vi &dist, vector<vi> &graph)\n{\n    fill(all(dist), -1);\n    dist[v] = 0;\n    vi q = {v};\n    for (int i = 0; i < q.size(); i++)\n    {\n        for (auto u : graph[q[i]])\n        {\n            if (dist[u] == -1)\n            {\n                dist[u] = dist[q[i]] + 1;\n                q.push_back(u);\n            }\n        }\n    }\n}\n\nvector<int> z_func(string &s)\n{\n    vector<int> z(s.size());\n    z[0] = s.size();\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    return z;\n}\n\nvector<int> p_func(string &s)\n{\n    vector<int> p(s.size());\n    for (int i = 1; i < s.size(); i++)\n    {\n        int j = p[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = p[j - 1];\n        if (s[i] == s[j])\n            j++;\n        p[i] = j;\n    }\n    return p;\n}\n\nvector<int> d1_func(string &s)\n{\n    vector<int> d1(s.size());\n    int L = 0, R = -1;\n    for (int i = 0; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d1[R - i + L]);\n        while (i + k < s.size() && i - k >= 0 && s[i - k] == s[i + k])\n            k++;\n        d1[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k;\n            R = i + k;\n        }\n    }\n    return d1;\n}\n\nvector<int> d2_func(string &s)\n{\n    vector<int> d2(s.size());\n    int L = 0, R = -1;\n    for (int i = 1; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d2[R - i + L + 1]);\n        while (i + k < s.size() && i - k - 1 >= 0 && s[i - k - 1] == s[i + k])\n            k++;\n        d2[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k - 1;\n            R = i + k;\n        }\n    }\n    return d2;\n}\n\nll log10(ll x)\n{\n    if (x < 10) re 1;\n    re 1 + log10(x / 10);\n}\n\nll ds(ll x)\n{\n    if (x < 10) return x;\n    re x % 10 + ds(x / 10);\n}\n\ndouble sqr(double x)\n{\n    return x * x;\n}\n\nbool in(int bit, int mask)\n{\n    return (mask & (1 << bit)) > 0;\n}\n\nvoid Del(vector<int> &v, int pos)\n{\n    swap(v[pos], v[v.size() - 1]);\n    v.pop_back();\n}\n\nlong long g(vector<long long> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nint g(vector<int> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nbool comp(pii a, pii b)\n{\n    if (abs(a.first - a.second) == abs(b.first - b.second))\n        return a > b;\n    return abs(a.first - a.second) > abs(b.first - b.second);\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    string s;\n    cin >> n >> s;\n    bitset<N> x;\n    for (int i = s.size() - 1; i >= 0; i--)\n        x[s.size() - 1 - i] = s[i] - '0';\n    bitset<N> g;\n    forn(i, n)\n    {\n        cin >> s;\n        bitset<N> a;\n        for (int i = s.size() - 1; i >= 0; i--)\n            a[s.size() - 1 - i] = s[i] - '0';\n        if (!i) g = a;\n        while (g != a)\n        {\n            int x = -1, y = -1;\n            for (int i = 0; i < N; i++)\n            {\n                if (a[i]) x = i;\n                if (g[i]) y = i;\n            }\n            if (x >= y)\n            {\n                if (a == (g << (x - y))) break;\n                a = a ^ (g << (x - y));\n            }\n            else\n            {\n                if (g == (a << (y - x)))\n                {\n                    g = a;\n                    break;\n                }\n                g = g ^ (a << (y - x));\n            }\n        }\n    }\n    int d = 0, D = 0;\n    for (int i = 0; i < N; i++)\n    {\n        if (g[i]) d = i;\n        if (x[i]) D = i;\n    }\n    if (d > D) cout << 1, exit(0);\n    ll ans = 0;\n    for (int i = D; i >= d; i--)\n    {\n        ans = (2 * ans + x[i]) % MOD;\n    }\n    bitset<N> y;\n    for (int i = N - 1; i >= d; i--)\n    {\n        if (y[i] != x[i])\n        {\n            y = y ^ (g << (i - d));\n        }\n    }\n    int t = 1;\n    for (int i = N - 1; i >= 0; i--)\n    {\n        if (y[i] < x[i]) break;\n        if (y[i] > x[i])\n        {\n            t = 0;\n            break;\n        }\n    }\n    cout << (ans + t) % MOD;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 6,Len = 4000 + 10,mod = 998244353;\n\nchar str[Len];\ntypedef bitset <Len> Bs;\nbool X[Len],A[N][Len],Gcd[Len],cur[Len],Mul[Len];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Getstr(bool S[]) {\n\tscanf(\"%s\",str);\n\tint len = strlen(str);\n\treverse(str,str + len);\n\tFor(i,0,len - 1) S[i] = str[i] - '0';\n}\n\ninline int Length(bool a[]) {\n\tFordown(i,Len - 1,0) if(a[i]) return i;\n\treturn 0;\n}\n\ninline void Plus(bool a[],bool b[],int Delta) {\n\tFor(i,Delta,Len - 1) a[i] = a[i] ^ b[i - Delta];\n}\n\ninline void gcd(bool a[],bool b[],bool c[]) {\n\tint Lena = Length(a),Lenb = Length(b);\n\tif(Lena < Lenb) swap(a,b),swap(Lena,Lenb);\n\tif(Lenb == 0 && b[0] == 0) { For(i,0,Len - 1) c[i] = a[i]; return; }\n\tPlus(a,b,Lena - Lenb);\n\tgcd(b,a,c);\n}\n\nint main() {\n\tint n = read();Getstr(X);\n\tFor(i,1,n) Getstr(A[i]);\n\tFor(i,1,n) {\n\t\tFor(j,0,Length(Gcd)) cur[j] = Gcd[j];\n\t\tgcd(A[i],cur,Gcd);\n\t}\n\tint ans = 0,LenG = Length(Gcd);\n\tFordown(i,Length(X),LenG) ans = ((ans << 1) + X[i]) % mod;\n\tFordown(i,Length(X),LenG) if(Mul[i] ^ X[i]) Plus(Mul,Gcd,i - LenG);\n\n\tFordown(i,LenG - 1,0) {\n\t\tif(Mul[i] < X[i]) break;\n\t\tif(Mul[i] > X[i]) { ans--;break; }\n\t}\n\n\tprintf(\"%d\\n\",ans + 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 4005;\nconst int MM = 998244353;\n\ntypedef bitset<MX> Integer;\n\nbool divide(Integer X, Integer Y, Integer &P, Integer &Q)\n{\n\tInteger Z = X;\n\tP.reset();\n\tint high = MX-1;\n\tfor(; high >= 0; high--) if(Y[high]) break;\n\tfor(int i = MX-high-1; i >= 0; i--){\n\t\tif( X[i+high] ){\n\t\t\tX ^= Y<<i;\n\t\t}\n\t\tif( Z[i+high] ){\n\t\t\tP[i] = 1;\n\t\t}\n\t}\n\tQ = X;\n\tfor(int i = high-1; i >= 0; i--) if( X[i] != Z[i] ) return X[i] > Z[i];\n\treturn true;\n}\n\nchar buf[MX];\n\nInteger gcd(Integer A, Integer B){\n\tInteger C, D;\n\tdivide(A, B, C, D);\n\tif( D.none() ) return B;\n\telse return gcd(B, D);\n}\n\nInteger input(){\n\tInteger X; X.reset();\n\tscanf(\"%s\", buf);\n\tint L = strlen(buf);\n\tfor(int i = 0; buf[i]; i++) X[L-i-1] = buf[i]-'0';\n\treturn X;\n}\n\nvoid print(Integer P){\n//\tfor(int i = 0; i < 10; i++) printf(\"%d\", !!P[i]); printf(\"\\n\");\n}\n\nint main()\n{\n\tint N;\n\tInteger X, A[10];\n\tX.reset();\n\tscanf(\"%d\", &N);\n\tX = input();\n\tfor(int i = 1; i <= N; i++){\n\t\tA[i] = input();\n\t\tprint(A[i]);\n\t}\n\n\tInteger G = A[1];\n\tfor(int i = 2; i <= N; i++) G = gcd(G, A[i]);\n\tprint(G);\n\n\tInteger tmp, t2;\n\tint ans = 0, flag = 0;\n\tflag = divide(X, G, tmp, t2);\n\tfor(int i = MX-1; i >= 0; i--){\n\t\tans = (ans * 2 + tmp[i]) % MM;\n\t}\n\tprintf(\"%d\\n\", (ans+flag)%MM);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 998244353;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\nconst ll len = 4010;\ntypedef bitset<len> bs;\nnamespace SOLVE {\n    bs gcd(bs a, bs b){\n        while (a.count() and b.count()) {\n            int h[2] = {0,0};\n            REP(i,0,len){\n                if(a[i])h[0] = i;\n                if(b[i])h[1] = i;\n            }\n            if(h[0]<=h[1]){\n                b^=a<<(h[1]-h[0]);\n            }else{\n                a^=b<<(h[0]-h[1]);\n            }\n        }\n        if(a.count())return a;\n        return b;\n    }\n    bs g,x;\n    int get_deg(bs x){\n        RREP(i,len-1,0)if(x[i])return i;\n        return -1;\n    }\n    bool operator<(const bs&a,const bs&b){\n        RREP(i,len-1,0)if(a[i]!=b[i])return a[i]<b[i];\n        return false;\n    }\n    ll ans = 0;\n    void main(){\n        int n;\n        cin>>n>>x;\n        \n        REP(i,0,n){\n            bs b;\n            cin>>b;\n            g = gcd(b, g);\n        }\n        int deg = get_deg(g);\n        RREP(i,len-1,deg){\n            if(x[i]){\n                ans += fast(2, i-deg, mod);\n                \n            }\n        }\n        if(x<g){\n            cout<<1<<endl;\n            return;\n        }\n        ans+=gcd(x, g)==g;\n        cout<< MOD(ans,mod)<<endl;\n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdint>\n#include <cassert>\n\n\n#include <iostream>\n#include <bitset>\n\ntemplate<const std::size_t N>\nstruct binfps {\n  using size_type = std::size_t;\n  using bit_type = std::uint_fast64_t;\n\n  const static size_type lg = 6;\n  const static size_type lgmask = (1ull << lg) - 1;\n  const static size_type _w_len = (N + (1ull << lg) - 1) >> lg;\n  std::array<bit_type, _w_len> w;\n  size_type len;\n\n  binfps(): len(0) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n  }\n\n  binfps(const std::bitset<N>& b) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n    for(size_type i = 0; i < N; i++) {\n      if(b[i]) set(i);\n    }\n    recalc();\n  }\n\n  size_type size() const { return this->len; }\n  void recalc() {\n    len = 0;\n    for(size_type i = w.size(); i --> 0; ) {\n      if(w[i]) {\n        for(size_type j = (1 << lg); j --> 0;) {\n          if(w[i] >> j) {\n            len = j + 1 + (i << lg);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  void set(size_type i) { w[i >> lg] |= (1ull << (i & lgmask)); }\n  void unset(size_type i) { w[i >> lg] &= ~(1ull << (i & lgmask)); }\n\n  bool any() const {\n    for(size_type i = 0; i < _w_len; i++) {\n      if(w[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool operator[](size_type i) const {\n    return !!(w[i >> lg] & (1ull << (i & lgmask)));\n  }\n\n  binfps& operator^=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] ^= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator&=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator|=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n\n\n  binfps& operator<<=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    size_type off = x >> lg;\n    size_type m = x & lgmask;\n    size_type dwmask = ((size_type)(1) << (64 - m)) - 1;\n    if(m == 0) {\n      dwmask = ~(size_type)(0);\n    }\n    size_type upmask = ~dwmask;\n    // up\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i + off + 1] |= (w[i] & upmask) >> m;\n    }\n    // down\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i + off] |= (w[i] & dwmask) << m;\n    }\n\n    w = std::move(next);\n    len = std::min(N, len + x);\n    return (*this);\n  }\n\n  binfps& operator>>=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    size_type off = x >> lg;\n    size_type m = x & lgmask;\n    size_type dwmask = (1ull << m) - 1;\n    if(m == 0) {\n      dwmask = 0;\n    }\n    size_type upmask = ~dwmask;\n    // down\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i] |= (w[i + off + 1] & dwmask) << (64 - m);\n    }\n    // up\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i] |= (w[i + off] & upmask) >> m;\n    }\n    w = std::move(next);\n    if(len < x) {\n      len = 0;\n    }\n    else {\n      len = len - x;\n    }\n    return (*this);\n  }\n\n  binfps operator^(const binfps& b) const { return binfps(*this) ^= b; }\n  binfps operator&(const binfps& b) const { return binfps(*this) &= b; }\n  binfps operator|(const binfps& b) const { return binfps(*this) |= b; }\n  binfps operator<<(const size_type x) const { return binfps(*this) <<= x; }\n  binfps operator>>(const size_type x) const { return binfps(*this) >>= x; }\n  binfps operator~() {\n    binfps a = *this;\n    for(size_type i = w.size(); i --> 0;) {\n      a.w[i] = ~w[i];\n    }\n    return a;\n  }\n\n  bool operator<(const binfps& b) const {\n    bool OK = false;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] < b.w[i]) {\n          OK = true;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n  bool operator<=(const binfps& b) const {\n    bool OK = true;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] > b.w[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n\n  static binfps mod(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    for(int i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static binfps div(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    binfps d;\n    for(int i = a.size() - b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        binfps e;\n        e.set(i);\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static binfps gcd(binfps a, binfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = std::move(b);\n      b = std::move(m);\n    }\n    return a;\n  }\n\n  void dump() const {\n    for(size_type i = _w_len; i --> 0; ) {\n      std::cerr << std::bitset<64>(w[i]) << \"|\" << std::endl;\n    }\n    std::cerr << std::endl;\n  }\n};\n\n\nconst int BN = 128;\nusing bits = binfps<BN>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n \nint main() {\n  i64 N;\n  cin >> N;\n  std::bitset<BN> binp;\n  cin >> binp;\n  bits X(binp);\n  X.recalc();\n \n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> binp;\n    A[i] = bits(binp);\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    if(now <= X) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\nconst int m = 4010;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel rui(m + 10, 1);\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nint max_true(bs &a,int jou) {\n\tint ans = jou;\n\trep(i, jou) {\n\t\tif (a[i]) { ans = i; }\n\t}\n\treturn ans;\n}\nbool can_div(bs &a, bs b, int &sza, int szb) {\n\tfor (int i = sza; i >= szb; i--) {\n\t\tif (a[i]) {\n\t\t\ta ^= b << (i - szb);\n\t\t}\n\t}\n\tsza = max_true(a, szb);\n\tif (sza == szb) { return true; }\n\treturn false;\n}\nbs gcd(bs a, bs b) {\n\tint sza = max_true(a,m);\n\tint szb = max_true(b,m);\n\tif (sza < szb) { swap(sza, szb); swap(a, b); }\n\twhile (true) {\n\t\tif (can_div(a, b, sza, szb)) { return b; }\n\t\tif (can_div(b, a, szb, sza)) { return a; }\n\t}\n}\nvoid solve(bs &x, bs &a) {\n\tint szx = max_true(x,m);\n\tint sza = max_true(a,m);\n\tbs to;\n\trep(i, m) { to[i] = 0; }\n\tint ans = 0;\n\tfor (int i = szx; i >= sza; i--) {\n\t\tif (x[i]) {\n\t\t\tans += rui[i - sza];\n\t\t}\n\t\tif (x[i] != to[i]) {\n\t\t\tto ^= a << (i - sza);\n\t\t}\n\t}\n\tcout << (ans + 1)%p << endl;\n}\nbs mak(string s) {\n\trev(s);\n\tbs ans;\n\trep(i, m) { ans[i] = 0; }\n\trep(i, s.size()) {\n\t\tans[i] = (s[i] == '1');\n\t}\n\treturn ans;\n}\nsigned main() {\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tstring x; cin >> x;\n\t\tstring s; cin >> s;\n\t\tbs gcd0 = mak(s);\n\t\trep(i, n - 1) {\n\t\t\tstring ne; cin >> ne;\n\t\t\tbs newb = mak(ne);\n\t\t\tgcd0 = gcd(newb, gcd0);\n\t\t}\n\t\tbs nw = mak(x);\n\t\trep(i, m + 9) { rui[i + 1] = rui[i] * 2; rui[i + 1] %= p; }\n\t\tsolve(nw, gcd0);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 6;\nconst int MAXLEN = 4000;\nconst int MOD = 998244353;\n\nint n, maxlen;\nchar s[MAXLEN + 1];\nint bound[MAXLEN];\nint A[MAXN][MAXLEN];\nint B[MAXLEN];\nint p2[MAXLEN + 1];\n\nvoid read(int *x) {\n\tscanf(\"%s\", s); int len = strlen(s); maxlen = max(maxlen, len);\n\tREP(i, MAXLEN - len) x[i] = 0; REP(i, len) x[MAXLEN - len + i] = s[i] - '0';\n}\n\nvoid print(int *x) {\n\tFOR(i, MAXLEN - maxlen, MAXLEN) printf(\"%d\", x[i]); puts(\"\");\n}\n\nvoid gaussjord() {\n\tint r = 0, c = 0;\n\twhile (r < n&&c < MAXLEN) {\n\t\t{ int rr = r; while (rr < n&&A[rr][c] == 0) ++rr; if (rr >= n) { ++c; continue; } if (r != rr) FOR(cc, c, MAXLEN) swap(A[r][cc], A[rr][cc]); }\n\t\tFOR(rr, r + 1, n) if (A[rr][c] == 1) FOR(cc, c, MAXLEN) if (A[r][cc]) A[rr][cc] = 1 - A[rr][cc];\n\t\t++r, ++c;\n\t}\n\tn = r;\n\tfor (--r; r >= 0; --r) {\n\t\tc = 0; while (A[r][c] == 0) ++c;\n\t\tREP(rr,r) if (A[rr][c] == 1) FOR(cc, c, MAXLEN) if (A[r][cc]) A[rr][cc] = 1 - A[rr][cc];\n\t}\n}\n\nint solve() {\n\tp2[0] = 1; FORE(i, 1, MAXLEN) p2[i] = (ll)2 * p2[i - 1] % MOD;\n\t//print(bound); REP(i, n) print(A[i]);\n\tgaussjord();\n\t//printf(\"init:\\n\"); REP(i, n) print(A[i]);\n\twhile (n >= 2) {\n\t\tint pcol = 0; while (A[n - 2][pcol] == 0) ++pcol;\n\t\tint col = 0; while (A[n - 1][col] == 0) ++col;\n\t\tREP(i, MAXLEN) B[i] = A[n - 1][i];\n\t\twhile (B[pcol] == 0) {\n\t\t\tREP(i, MAXLEN) B[i] = B[i + 1]; B[MAXLEN - 1] = 0;\n\t\t\tif (B[col] != 0) FOR(i, col, MAXLEN) if (A[n - 1][i] == 1) B[i] = 1 - B[i];\n\t\t\tint ccol = 0; while (B[ccol] == 0) ++ccol; if (A[n - 2][ccol] != 0 && ccol != pcol) FOR(i, ccol, MAXLEN) if (B[i] == 1) A[n - 2][i] = 1 - A[n - 2][i];\n\t\t}\n\t\tFOR(i, pcol, MAXLEN) if (A[n - 2][i] == 1) B[i] = 1 - B[i];\n\t\tbool same = true; REP(i, MAXLEN) if (B[i] != 0) same = false;\n\t\tif (same) {\n\t\t\tREP(i, MAXLEN) A[n - 2][i] = A[n - 1][i]; --n;\n\t\t}\n\t\telse {\n\t\t\tREP(i, MAXLEN) A[n - 2][i] = A[n - 1][i];\n\t\t\tREP(i, MAXLEN) A[n - 1][i] = B[i];\n\t\t\tint ncol = 0; while (A[n - 1][ncol] == 0) ++ncol;\n\t\t\tREP(r, n - 1) if (A[r][ncol] == 1) FOR(c, ncol, MAXLEN) if (A[n - 1][c] == 1) A[r][c] = 1 - A[r][c];\n\t\t}\n\t\t//if (n == 2) { printf(\"step:\\n\"); REP(i, n) print(A[i]); }\n\t\t//printf(\"n=%d\\n\", n);\n\t}\n\tint bcol = 0; while (bound[bcol] == 0) ++bcol;\n\tint rcol = 0; while (A[0][rcol] == 0) ++rcol;\n\tif (rcol < bcol) return 1;\n\tREP(i, MAXLEN) B[i] = 0;\n\tint ret = 0;\n\tREPE(i, rcol - bcol) {\n\t\t//printf(\"%d: %d vs %d\\n\", i, B[bcol + i], bound[bcol + i]);\n\t\tint x = B[bcol + i], y = bound[bcol + i];\n\t\tif (y == 1) ret = (ret + p2[rcol - bcol - i]) % MOD;\n\t\tif (x != y) FOR(j, rcol, MAXLEN) if (A[0][j] != 0) B[bcol + i + j - rcol] = 1 - B[bcol + i + j - rcol];\n\t}\n\tbool ok = true; REP(i, MAXLEN) if (B[i] < bound[i]) break; else if (B[i] > bound[i]) { ok = false; break; } if (ok) ret = (ret + 1) % MOD;\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d\", &n); maxlen = 0;\n\tread(bound);\n\tREP(i, n) read(A[i]);\n\tint ret = solve();\n\tprintf(\"%d\\n\", ret);\n}\n\nvoid stress() {\n\twhile (true) {\n\t\tn = 6; maxlen = 4000;\n\t\twhile (true) { REP(j, maxlen) bound[MAXLEN - maxlen + j] = rand() % 2; bool nonzero = false; REP(j, maxlen) if (bound[MAXLEN - maxlen + j] != 0) nonzero = true; if (nonzero) break; }\n\t\tREP(i, n) while (true) { REP(j, maxlen) A[i][MAXLEN - maxlen + j] = rand() % 2; bool nonzero = false; REP(j, maxlen) if (A[i][MAXLEN - maxlen + j] != 0) nonzero = true; if (nonzero) break; }\n\t\tsolve();\n\t\tprintf(\".\"); fflush(stdout);\n\t}\n}\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//be naame khodaa\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <cassert>\n#include <iomanip>\n#include <cstring>\n#include <sstream>\n#define fi first\n#define se second\n#define rep(i, x, n) for (int i = x; i < n; i++)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef vector <int> VI;\n\nconst int maxd = 4*1000 + 5;\nconst int maxp = 10;\nconst int P = 998244353;\n\nstruct Poly {\n\tint c[maxd];\n\tint deg;\n\n\tfriend istream &operator >> (istream &inp, Poly &p){\n\t\tstring s;\n\t\tinp >> s;\n\t\tp.deg = s.length() - 1;\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t\tp.c[p.deg-i] = (s[i] - '0');\n\t\treturn inp;\n\t}\n\n\tfriend ostream &operator << (ostream &out, Poly &p){\n\t\tfor (int i = p.deg; i >= 0; i--)\n\t\t\tout << p.c[i];\n\t\treturn out;\n\t}\n\n\tPoly () {\n\t\tdeg = -1;\n\t}\n\n} poly[maxp];\n\nPoly gcd (Poly a, Poly b){\n\tif (a.deg < b.deg) swap (a, b);\n\tif (b.deg == -1) return a;\n\tfor (int i = 0; i <= b.deg; i++)\n\t\ta.c[a.deg-i] ^= b.c[b.deg-i];\n\twhile (a.deg >= 0 && a.c[a.deg] == 0)\n\t\ta.deg--;\n\treturn gcd (a, b);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tPoly X;\n\tint n;\n\tcin >> n >> X;\n\tPoly g;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> poly[i];\n\t\tg = gcd (g, poly[i]);\n\t}\n\tif (X.deg < g.deg)\n\t\treturn (cout << 1 << endl), 0;\n\tll res = 0;\n\tfor (int i = X.deg; i >= g.deg; i--)\n\t\tres = (res*2 + X.c[i])%P;\n\n\tPoly Y = X;\n\twhile (Y.deg >= g.deg){\n\t\tfor (int i = 0; i <= g.deg; i++)\n\t\t\tY.c[Y.deg-i] ^= g.c[g.deg-i];\n\t\twhile (Y.deg >= g.deg && Y.c[Y.deg] == 0)\n\t\t\tY.deg--;\n\t}\n\n\tres++;\n\tfor (int i = g.deg-1; i >= 0; i--){\n\t\tif (X.c[i] != (X.c[i] ^ Y.c[i])) {\n\t\t\tif (X.c[i] < (X.c[i] ^ Y.c[i]))\n\t\t\t\tres--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tres %= P;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\ninline int deg(const bitset <N> &b) {\n  int t = N - 1;\n  while (t >= 0 && !b[t]) t --;\n  return t + 1;\n}\n\nint n;\nchar buf[N];\n\ninline void read(bitset <N> &b) {\n  scanf(\"%s\", buf);\n  reverse(buf, buf + strlen(buf));\n  for (int i = 0; buf[i]; i ++)\n    b[i] = (bool)(buf[i] - '0');\n}\n\nbitset <N> X, A[10];\n\ninline bitset <N> gcd(bitset <N> p, bitset <N> q) {\n  int a = deg(p);\n  int b = deg(q);\n  while (true) {\n    if (!a) return q;\n    if (!b) return p;\n    if (a < b) {\n      swap(p, q); swap(a, b);\n    }\n    p ^= q << (a - b);\n    while (a >= 0 && p[a] == 0) a --;\n    a ++;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  read(X);\n  for (int i = 1; i <= n; i ++) read(A[i]);\n  for (int i = 2; i <= n; i ++)\n    A[1] = gcd(A[1], A[i]);\n  int ans = 0, j = deg(A[1]);\n  for (int i = deg(X) - 1; i >= j - 1; i --) \n    ans = ((ans << 1) + X[i]) % mod;\n  for (int i = deg(X) - 1; i >= j; i --)\n    if (X[i]) X ^= A[1] << (i - j + 1);\n  for (int i = j - 1; ~ i; i --)\n    if (A[1][i] != X[i]) {\n      if (A[1][i] < X[i]) ans --;\n      break;\n    }\n  ans = (ans + 1) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nconst int SZ = 4000;\nusing B = bitset< SZ >;\n\nint msb(const B &x) {\n  for(int i = SZ - 1; i > 0; i--) if(x[i]) return i;\n  return 0;\n}\n\nB gcd(B a, B b) {\n  int aa = msb(a), bb = msb(b);\n  if(aa < bb) swap(a, b), swap(aa, bb);\n  if(b.none()) return a;\n  return gcd(b, a ^ (b << (aa - bb)));\n}\n\nB in() {\n  string s;\n  cin >> s;\n  return B(s);\n}\n\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt &operator^=(int64_t n) {\n    int y = x;\n    x = 1;\n    while(n > 0) {\n      if(n & 1) x = 1LL * x * y % mod;\n      y = 1LL * y * y % mod;\n      n >>= 1;\n    }\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  ModInt operator^(const int64_t n) const { return ModInt(*this) ^= n; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\nint main() {\n  int N;\n\n  cin >> N;\n  B X = in();\n\n  B T(in());\n  for(int i = 1; i < N; i++) T = gcd(T, in());\n\n  vector< modint > mul(SZ);\n  mul[0] = 1;\n  for(int i = 1; i < SZ; i++) mul[i] = mul[i - 1] * 2;\n  modint ret = 1;\n  int m = msb(T);\n  B Y;\n  for(int i = SZ - 1; i >= m; i--) {\n    if(X[i]) ret += mul[i - m];\n    if(X[i] ^ Y[i]) Y ^= (T << (i - m));\n  }\n  for(int i = m - 1; i >= 0; i--) {\n    if(X[i] > Y[i]) break;\n    if(Y[i] < Y[i]) {\n      ret -= 1;#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nconst int SZ = 4000;\nusing B = bitset< SZ >;\n\nint msb(const B &x) {\n  for(int i = SZ - 1; i > 0; i--) if(x[i]) return i;\n  return 0;\n}\n\nB gcd(B a, B b) {\n  int aa = msb(a), bb = msb(b);\n  if(aa < bb) swap(a, b), swap(aa, bb);\n  if(b.none()) return a;\n  return gcd(b, a ^ (b << (aa - bb)));\n}\n\nB in() {\n  string s;\n  cin >> s;\n  return B(s);\n}\n\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt &operator^=(int64_t n) {\n    int y = x;\n    x = 1;\n    while(n > 0) {\n      if(n & 1) x = 1LL * x * y % mod;\n      y = 1LL * y * y % mod;\n      n >>= 1;\n    }\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  ModInt operator^(const int64_t n) const { return ModInt(*this) ^= n; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\nint main() {\n  int N;\n\n  cin >> N;\n  B X = in();\n\n  B T(in());\n  for(int i = 1; i < N; i++) T = gcd(T, in());\n\n  vector< modint > mul(SZ);\n  mul[0] = 1;\n  for(int i = 1; i < SZ; i++) mul[i] = mul[i - 1] * 2;\n  modint ret = 1;\n  int m = msb(T);\n  B Y;\n  for(int i = SZ - 1; i >= m; i--) {\n    if(X[i]) ret += mul[i - m];\n    if(X[i] ^ Y[i]) Y ^= (T << (i - m));\n  }\n  for(int i = m - 1; i >= 0; i--) {\n    if(X[i] > Y[i]) break;\n    if(Y[i] < Y[i]) {\n      ret -= 1;\n      break;\n    }\n  }\n  cout << ret << endl;\n}\n\n\n\n\n\n      break;\n    }\n  }\n  cout << ret << endl;\n}\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\n\nconst int SZ = 4000;\nusing B = bitset< SZ >;\n\nint msb(const B &x) {\n  for(int i = SZ - 1; i > 0; i--) if(x[i]) return i;\n  return 0;\n}\n\nB gcd(B a, B b) {\n  int aa = msb(a), bb = msb(b);\n  if(aa < bb) swap(a, b), swap(aa, bb);\n  if(b.none()) return a;\n  return gcd(b, a ^ (b << (aa - bb)));\n}\n\nB in() {\n  string s;\n  cin >> s;\n  return B(s);\n}\n\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt &operator^=(int64_t n) {\n    int y = x;\n    x = 1;\n    while(n > 0) {\n      if(n & 1) x = 1LL * x * y % mod;\n      y = 1LL * y * y % mod;\n      n >>= 1;\n    }\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  ModInt operator^(const int64_t n) const { return ModInt(*this) ^= n; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\nint main() {\n  int N;\n\n  cin >> N;\n  B X = in();\n\n  B T(in());\n  for(int i = 1; i < N; i++) T = gcd(T, in());\n\n  vector< modint > mul(SZ);\n  mul[0] = 1;\n  for(int i = 1; i < SZ; i++) mul[i] = mul[i - 1] * 2;\n  modint ret = 1;\n  int m = msb(T);\n  B Y;\n  for(int i = SZ - 1; i >= m; i--) {\n    if(X[i]) ret += mul[i - m];\n    if(X[i] ^ Y[i]) Y ^= (T << (i - m));\n  }\n  for(int i = m - 1; i >= 0; i--) {\n    if(X[i] > Y[i]) break;\n    if(Y[i] < Y[i]) {\n      ret -= 1;\n      break;\n    }\n  }\n  cout << ret << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << endl\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/2;\nconst ll MOD = 998244353;\n\ninline ll add(ll a, ll b, ll M) { // a + b (mod M)\n    return (a += b) >= M ? a - M : a;\n}\ninline ll sub(ll a, ll b, ll M) { // a - b (mod M)\n    return (a -= b) < 0 ? a + M : a;\n}\ninline ll mul(ll a, ll b, ll M) { // a * b (mod M)\n    ll r = a*b - (ll)((long double)(a)*b/M+.5)*M;\n    return r < 0 ? r + M: r;\n}\ninline ll div(ll a, ll b, ll M) { // solve b x == a (mod M)\n    ll u = 1, x = 0, s = b, t = M;\n    while (s) { // extgcd for b x + M s = t\n        ll q = t / s;\n        swap(x -= u * q, u);\n        swap(t -= s * q, s);\n    }\n    if (a % t) return -1; // infeasible\n    return mul(x < 0 ? x + M : x, a / t, M); // b (xa/t) == a (mod M)\n}\ninline ll pow(ll a, ll b, ll M) {\n    ll x = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) x = (a * x) % M;\n        a = (a * a) % M;\n    }\n    return x;\n}\n\n// p(x) = p[0] + p[1] x + ... + p[n-1] x^n-1\n// assertion: p.back() != 0\ntypedef vector<ll> poly;\nostream& operator<<(ostream &os, const poly &p) {\n    bool head = true;\n    for (size_t i = 0; i < p.size(); ++i) {\n        if (p[i] == 0) continue;\n        if (!head) os << \" + \";\n        os << p[i];\n        head = false;\n        if (i >= 1) os << \" x\";\n        if (i >= 2) os << \"^\" << i;\n    }\n    return os;\n}\ninline poly add(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = add(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\ninline poly sub(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = sub(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\n\n\n\n// FFT-based multiplication: this works correctly for M in [int]\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root, int sign>\ninline void fmt(vector<ll>& x) {\n    const int n = x.size();\n    int h = pow(primitive_root, (mod-1)/n, mod);\n    if (sign < 0) h = div(1, h, mod);\n    for (int i = 0, j = 1; j < n-1; ++j) {\n        for (int k = n >> 1; k > (i ^= k); k >>= 1);\n        if (j < i) swap(x[i], x[j]);\n    }\n    for (int m = 1; m < n; m *= 2) {\n        ll w = 1, wk = pow(h, n / (2*m), mod);\n        for (int i = 0; i < m; ++i) {\n            for (int s = i; s < n; s += 2*m) {\n                ll u = x[s], d = x[s + m] * w % mod;\n                if ((x[s] = u + d) >= mod) x[s] -= mod;\n                if ((x[s + m] = u - d) < 0) x[s + m] += mod;\n            }\n            w = w * wk % mod;\n        }\n    }\n    if (sign < 0) {\n        ll inv = div(1, n, mod);\n        for (auto &a: x)\n            a = a * inv % mod;\n    }\n}\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root>\ninline vector<ll> conv(vector<ll> a, vector<ll> b){\n    fmt<mod,primitive_root,+1>(a); fmt<mod,primitive_root,+1>(b);\n    for (size_t i = 0; i < a.size(); ++i)\n        a[i] = a[i] * b[i] % mod;\n    fmt<mod,primitive_root,-1>(a);\n    return a;\n}\n// general convolution where mod < 2^31.\ninline vector<ll> conv(vector<ll> a, vector<ll> b, ll mod){\n    int n = a.size() + b.size() - 1;\n    for (int k: {1,2,4,8,16}) n |= (n >> k);\n    ++n;\n    a.resize(n); b.resize(n);\n    const int A = 167772161, B = 469762049, C = 1224736769, D = (ll)(A) * B % mod;\n    if(mod==A)return conv<A,3>(a,b);\n    if(mod==B)return conv<B,3>(a,b);\n    if(mod==C)return conv<C,3>(a,b);\n    if(mod==924844033)return conv<924844033,5>(a,b);\n    vector<ll> x = conv<A,3>(a,b), y = conv<B,3>(a,b), z = conv<C,3>(a,b);\n    for (size_t i = 0; i < x.size(); ++i) {\n        ll X = (y[i] - x[i]) * 104391568;\n        if ((X %= B) < 0) X += B;\n        ll Y = (z[i] - (x[i] + A * X) % C) * 721017874;\n        if ((Y %= C) < 0) Y += C;\n        x[i] += A * X + D * Y;\n        if ((x[i] %= mod) < 0) x[i] += mod;\n    }\n    x.resize(n);\n    return x;\n}\n\ninline poly mul(poly p, poly q, ll M) {\n    poly pq = conv(p, q, M);\n    pq.resize(p.size() + q.size() - 1);\n    while (!pq.empty() && !pq.back()) pq.pop_back();\n    return pq;\n}\n\ninline pair<poly,poly> divmod(poly p, poly q, ll M) {\n    if (p.size() < q.size()) return { {}, p };\n    reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    poly t = {div(1, q[0], M)};\n    if (t[0] < 0) return { {}, {} }; // infeasible\n    for (size_t k = 1; k <= 2*(p.size()-q.size()+1); k *= 2) {\n        poly qq=q;\n        if(k+1<q.size())qq.resize(k+1);\n        while (!qq.empty() && !qq.back()) qq.pop_back();\n        poly s = mul(mul(t, t, M), qq, M);\n        t.resize(k);\n        for (size_t i = 0; i < k; ++i)\n            t[i] = sub(2*t[i], s[i], M);\n    }\n    t.resize(p.size() - q.size() + 1);\n    poly pp=p;\n    pp.resize(p.size() - q.size() + 1);\n    while (!pp.empty() && !pp.back()) pp.pop_back();\n    t = mul(t, pp, M);\n    t.resize(p.size() - q.size() + 1);\n    reverse(t.begin(),t.end()); reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    while (!t.empty() && !t.back()) t.pop_back();\n    return {t, sub(p, mul(q, t, M), M) };\n}\npoly gcd(poly p, poly q, ll M) {\n    for (; !p.empty(); swap(p, q = divmod(q, p, M).second));\n    return q;\n}\n\n#include <ctime>\ndouble tick() {\n  static clock_t oldtick;\n  clock_t newtick = clock();\n  double diff = 1.0*(newtick - oldtick) / CLOCKS_PER_SEC;\n  oldtick = newtick;\n  return diff;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N;cin>>N;\n  string X;cin>>X;\n  string A;cin>>A;\n  poly g(A.length());\n  for(size_t i=0;i<A.length();i++){\n    g[i]=A[A.length()-1-i]-'0';\n  }\n  for(ll i=1;i<N;i++){\n    cin >> A;\n    poly p(A.length());\n    for(size_t i=0;i<A.length();i++){\n      p[i]=A[A.length()-1-i]-'0';\n    }\n    g=gcd(p,g,2);\n  }\n  ll ans=0;\n  ll d=(ll)g.size();\n  string Xleft=X.substr(0,X.length()-d+1);\n  poly q(X.size(),0);\n  for(size_t i=0;i<X.length()-d+1;i++){\n    q[d-1+i]=X[X.length()-d-i]-'0';\n    if(Xleft[i]>'0')ans = (ans+pow(2,X.length()-d-i,MOD))%MOD;\n  }\n  poly r=divmod(q,g,2).second;\n  bool isok=true;\n  for(size_t i=X.length()-d+1;i<X.length();i++){\n    if(r[X.length()-1-i]==X[i]-'0')continue;\n    isok = r[X.length()-1-i]<X[i]-'0';\n    break;\n  }\n  ans = (ans+isok)%MOD;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 4010;\nll pow2[4020];\n\nvi bxor(const vi& a, const vi& b) {\n\tvi res(N, 0);\n\trep(i, 0, N) res[i] = (a[i] ^ b[i]);\n\treturn res;\n}\n\nint fbit(const vi& a) { //fbit(0101) = 3\n\trer(i, N, 0) {\n\t\tif(a[i] == 1) return i + 1;\n\t}\n\treturn 0;\n}\n\nvi shift(const vi& a, int k) {\n\tvi res(N, 0);\n\tint fa = fbit(a);\n\tassert(fa + k <= N);\n\trep(i, 0, fa) {\n\t\tres[i + k] = a[i];\n\t}\n\treturn res;\n}\n\nbool is_zero(const vi& a) {\n\trep(i, 0, N) {\n\t\tif(a[i]) return false;\n\t}\n\treturn true;\n}\n\nvi gcd(const vi& a, const vi& b) {\n\tif(is_zero(b)) return a;\n\tvi c = a;\n\twhile(true) {\n\t\tint fc = fbit(c), fb = fbit(b);\n\t\tif(fc < fb) break;\n\t\tint diff = fc - fb;\n\t\tc = bxor(c, shift(b, diff));\n\t}\n\treturn gcd(b, c);\n}\n\nvi stobit(const string& str) {\n\tvector<int> res(N, 0);\n\tint n = sz(str);\n\trep(i, 0, n) {\n\t\tres[n - i - 1] = str[i] - '0';\n\t}\n\treturn res;\n}\n\nll loop(const vi& a, const vi& b) {\n\tint fa = fbit(a), fb = fbit(b);\n\tif(fa < fb) return 0;\n\tvi c = bxor(a, shift(b, fa - fb));\n\treturn (loop(c, b) + pow2[fa - fb]) % mod;\n}\n\nint M;\nvi X;\nvi B[10];\n\nvoid solve() {\n\tstring str;\n\tcin >> M >> str;\n\tpow2[0] = 1;\n\trep(i, 1, 4010) pow2[i] = pow2[i - 1] * 2 % mod;\n\tX = stobit(str);\n\trep(i, 0, M) {\n\t\tcin >> str;\n\t\tB[i] = stobit(str);\n\t}\n\tvi g = B[0];\n\trep(i, 0, M - 1) g = gcd(g, B[i + 1]);\n\tint a = fbit(X), b = fbit(g);\n\tvi c(N, 0);\n\tll res = 0;\n\trep(i, 0, (a - b + 1)) {\n\t\tif(X[a - i - 1] == 1) {\n\t\t\tc = bxor(c, shift(g, (a - b - i)));\n\t\t\tADD(res, pow2[a - b - i]);\n\t\t}\n\t\tif(X[a - i - 1] == 0 && c[a - i - 1] == 1) {\n\t\t\tc = bxor(c, shift(g, (a - b - i)));\n\t\t}\n\t}\n\trer(i, N, 0) {\n\t\tif(X[i] == 0 && c[i] == 1) {\n\t\t\tcout << res << \"\\n\";\n\t\t\treturn;\n\t\t}\n\t\telse if(X[i] == 1 && c[i] == 0) {\n\t\t\tcout << (res + 1) % mod << \"\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << (res + 1) % mod << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<bitset>\n#include<cstdio>\n#define MN 4000\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,ans,pw[MN+5];\nchar s[MN+5],t[8][MN+5];\nbitset<MN+5> b[8],g,a;\nbitset<MN+5> gcd(const bitset<MN+5>&a,const bitset<MN+5>&b,int d,int D)\n{\n\twhile(d&&!a[d-1]) --d;while(D&&!b[D-1]) --D;\n\tif(!d) return b;if(!D) return a;\t\n\tif(d<=D) return gcd(a,(a<<D-d)^b,d,D);\n\telse return gcd(b,(b<<d-D)^a,D,d);\n}\nint main()\n{\n\tn=read();scanf(\"%s\",s+1); \n\tfor(int i=1;i<=n;++i) scanf(\"%s\",t[i]+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint d=strlen(t[i]+1);\n\t\tfor(int j=0;j<d;++j) b[i][j]=t[i][d-j]-'0';\t\n\t}\n\tg=b[1];for(int i=2;i<=n;++i) g=gcd(g,b[i],MN,MN);\n\tint deg=MN,len=strlen(s+1);for(;!g[deg-1];) --deg;pw[0]=1;\n\tfor(int i=1;i<=len;++i) pw[i]=2*pw[i-1]%mod;\n\tfor(int i=1;i+deg-1<=len;++i)\n\t{\n\t\tbitset<MN+5> nx;int flag=0; \n\t\tif(!(s[i]=='0'&&a[len-i]))\n\t\t{\n\t\t\tif(a[len-i]<s[i]-'0') (ans+=pw[len-deg+1-i])%=mod;\n\t\t\telse nx=a,flag=1;\n\t\t}\n\t\tif(i+deg-1<=len&&!(s[i]=='0'&&!a[len-i]))\n\t\t{\n\t\t\tif((a[len-i]^1)<s[i]-'0') (ans+=pw[len-deg+1-i])%=mod;\n\t\t\telse nx=a,flag=1;\t\n\t\t}\n\t\tif(!flag) {--ans;break;} else a=nx;\n\t}\n\tcout<<(ans+1)%mod;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nbitset<4000> X,P;\nll mo=998244353;\nll p2[202020];\nint ng;\n\nbitset<4000> gcd(bitset<4000> A,bitset<4000> B) {\n\tint i;\n\tfor(i=3999;i>=0;i--) {\n\t\tif(A[i]==1 && B[i]==1) {\n\t\t\tB^=A;\n\t\t\tbreak;\n\t\t}\n\t\tif(A[i]==1) break;\n\t\tif(B[i]==1) {\n\t\t\tswap(A,B);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// A>B\n\twhile(1) {\n\t\tint x;\n\t\tfor(x=i-1;x>=0;x--) if(B[x]) break;\n\t\tif(x<0) break;\n\t\twhile(i>=x) {\n\t\t\tif(A[i]) A^=B<<(i-x);\n\t\t\ti--;\n\t\t}\n\t\ti=x;\n\t\tswap(A,B);\n\t}\n\treturn A;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tp2[0]=1;\n\tFOR(i,101010) p2[i+1]=p2[i]*2%mo;\n\t\n\tcin>>N>>S;\n\tFOR(i,S.size()) if(S[i]=='1') X[S.size()-1-i]=1;\n\tFOR(j,N) {\n\t\tcin>>S;\n\t\tbitset<4000> B;\n\t\tFOR(i,S.size()) if(S[i]=='1') B[S.size()-1-i]=1;\n\t\tif(j==0) P=B;\n\t\telse P=gcd(P,B);\n\t}\n\t\n\tll ret=0;\n\tFOR(i,4000) if(P[i]) x=i;\n\tfor(i=3999;i>=x+1;i--) if(X[i]) ret+=p2[i-x];\n\tfor(i=3999;i>=x;i--) if(X[i]) X^=P<<(i-x);\n\t\n\tret++;\n\tfor(i=x-1;i>=0;i--) {\n\t\tif(X[i]<P[i]) {\n\t\t\tret--;\n\t\t\tbreak;\n\t\t}\n\t\tif(X[i]>P[i]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=4096,M=100005,mod=998244353;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\n#define big bitset<N>\n\nint n,pw[N];\nbig x,d,a;\n\ninline bool operator <= (big a,big b){\n\tfor(int i=4000;~i;i--)\n\t\tif(a[i]&&!b[i]) return 0; else if(!a[i]&&b[i]) return 1;\n\treturn 1;\n}\n\ninline void in(big &a){\n\ta=0;\n\tstatic char s[N];\n\tstatic int n;\n\treads(s);n=strlen(s);\n\treverse(s,s+n);\n\tfor(int i=0;i<n;i++)\n\t\ta[i]=(s[i]=='1');\n}\ninline int getlen(big a){\n\tfor(int i=4000;~i;i--)\n\t\tif(a[i]) return i;\n\treturn -1;\n}\ninline big gcd(big a,big b){\n\tint la=getlen(a),lb=getlen(b);\n\twhile(~la&&~lb){\n\t\tif(la>=lb){\n\t\t\tfor(int i=la;i>=lb;i--)\n\t\t\t\tif(a[i]) a^=(b<<i-lb);\n\t\t\twhile(~la&&!a[la]) la--;\n\t\t}\n\t\telse{\n\t\t\tfor(int i=lb;i>=la;i--)\n\t\t\t\tif(b[i]) b^=(a<<i-la);\n\t\t\twhile(~lb&&!b[lb]) lb--;\n\t\t}\n\t}\n\treturn a|b;\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tpw[0]=1;\n\tfor(int i=1;i<N;i++) pw[i]=pw[i-1]*2%mod;\n\tread(n);in(x);\n\td.reset();\n\tfor(int i=1;i<=n;i++){\n\t\tin(a);\n\t\td=gcd(d,a);\n\t}\n\tint m=getlen(x),n=getlen(d);\n\tbig tmp=0;int ans=0;\n\tfor(int i=m;i>=n;i--){\n\t\tif(x[i]) ch(ans,pw[i-n]);\n\t\tif(x[i]^tmp[i]) tmp^=d<<i-n;\n\t}\n\tif(tmp<=x) ch(ans,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 20;\ntypedef v(string) vs;\n\n// Mod int\nconst int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint operator~() const { return mint(1) / *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.pow(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint pow(ll t) const {\n    if(!t) return 1;\n    mint res = pow(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.pow(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].pow(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint operator()(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nstruct D {\n  bitset<MX> d;\n  int n;\n  D():n(0) {}\n  D(const string& s) {\n    n = sz(s);\n    rep(i,n) d[i] = s[n-1-i]-'0';\n  }\n  void sub(const D& a) {\n    d ^= a.d<<(n-a.n);\n    while (n && !d[n-1]) --n;\n  }\n};\n\nD inD() {\n  string s;\n  cin>>s;\n  return D(s);\n}\n\nD g(D a, D b) {\n  while (1) {\n    if (a.n < b.n) swap(a,b);\n    if (!b.n) break;\n    a.sub(b);\n  }\n  return a;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  D x = inD();\n  D a = inD();\n  rep(i,n-1) a = g(a,inD());\n  mint ans;\n  bitset<MX> d;\n  for (int i = x.n-1; i >= a.n-1; --i) {\n    ans = ans*2 + mint(x.d[i]);\n    if (x.d[i]^d[i]) d ^= a.d<<(i-a.n+1);\n  }\n  int add = 1;\n  drep(i,a.n) {\n    if (x.d[i] == d[i]) continue;\n    add = x.d[i];\n    break;\n  }\n  ans += add;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator >> (istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Graph.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Range.h\"\n#include \"Tree.h\"\n#include \"Union_Find.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator >> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nconst int M = 4064;\nusing Bits = bitset<M>;\nconst int MOD = 998244353;\n\nint Digit(const Bits& a) {\n\tREM(i, 0, M) {\n\t\tif (a[i]) {\n\t\t\treturn i + 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nBits GCD(Bits a, Bits b) {\n\tBits* p = &a;\n\tBits* q = &b;\n\tint as = Digit(a) - 1;\n\tint bs = Digit(b) - 1;\n\n\twhile (bs >= 0) {\n\t\twhile (as >= bs) {\n\t\t\t*p ^= *q << (as - bs);\n\t\t\twhile (as >= 0 && (*p)[as] == 0) {\n\t\t\t\t--as;\n\t\t\t}\n\t\t}\n\t\tswap(p, q);\n\t\tswap(as, bs);\n\t}\n\treturn *p;\n}\n\nbool Less(const Bits& a, const Bits& b) {\n\tREM(i, 0, M) {\n\t\tif (a[i] < b[i]) return true;\n\t\tif (a[i] > b[i]) return false;\n\t}\n\treturn false;\n}\n\nBits Inc(const Bits& a) {\n\tBits ret(a);\n\n\tREP(i, 0, M) {\n\t\tif (ret[i]) {\n\t\t\tret[i] = 0;\n\t\t} else {\n\t\t\tret[i] = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nint N;\nBits X;\nBits A[6];\nint P[M];\nint main() {\n\tcin >> N >> X;\n\tREP(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\tX = Inc(X);\n\n\tP[0] = 1;\n\tREP(i, 1, M) {\n\t\tP[i] = P[i - 1] * 2;\n\t\tif (P[i] >= MOD) P[i] -= MOD;\n\t}\n\n\tBits gcd = 0;\n\tREP(i, 0, N) {\n\t\tgcd = GCD(gcd, A[i]);\n\t}\n\t\n\tint xs = Digit(X);\n\tint gs = Digit(gcd);\n\n\tint sum = 0;\n\tREM(i, gs - 1, xs) {\n\t\tif (X[i]) {\n\t\t\tsum += P[i - gs + 1];\n\t\t\tif (sum >= MOD) sum -= MOD;\n\t\t}\n\t}\n\n\tBits Y = 0;\n\tREM(i, gs - 1, xs) {\n\t\tif (Y[i] != X[i]) {\n\t\t\tY ^= gcd << (i - gs + 1);\n\t\t}\n\t}\n\n\tcout << sum + Less(Y, X) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\nconst int m = 4010;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel rui(m + 10, 1);\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nint max_true(bs &a,int jou) {\n\tint ans = jou;\n\trep(i, jou) {\n\t\tif (a[i]) { ans = i; }\n\t}\n\treturn ans;\n}\nbool can_div(bs &a, bs b, int &sza, int szb) {\n\tfor (int i = sza; i >= szb; i--) {\n\t\tif (a[i]) {\n\t\t\ta ^= b << (i - szb);\n\t\t}\n\t}\n\tsza = max_true(a, szb);\n\tif (sza == szb) { return true; }\n\treturn false;\n}\nbs gcd(bs a, bs b) {\n\tint sza = max_true(a,m);\n\tint szb = max_true(b,m);\n\tif (sza < szb) { swap(sza, szb); swap(a, b); }\n\twhile (true) {\n\t\tif (can_div(a, b,sza,szb)) { swap(a, b); break; }\n\t\tif (can_div(b, a,szb,sza)) { break; }\n\t}\n\treturn a;\n}\nint solve(bs &x, bs &a,bool gr) {\n\tint szx = max_true(x,m);\n\tint sza = max_true(a,m);\n\tif (szx == m || szx<sza) {\n\t\tif (gr) { return 1; }\n\t\treturn 0;\n\t}\n\tbool fl = true;\n\tint y = (szx+1) % (sza+1);\n\tfor (int i = szx; i >= y; i--) {\n\t\tfl &= x[i];\n\t\tx[i] = x[i] xor true;\n\t}\n\tif (fl) {\n\t\tif (gr) {\n\t\t\treturn rui[szx - sza + 1];\n\t\t}\n\t\treturn (rui[szx - sza + 1] + p - 1)%p;\n\t}\n\telse {\n\t\treturn (rui[szx - sza + 1] - solve(x, a,gr xor true)+p)%p;\n\t}\n}\nbs mak(string s) {\n\trev(s);\n\tbs  ans;\n\trep(i, s.size()) {\n\t\tans[i] = (s[i] == '1');\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint n; cin >> n;\n\tstring x; cin >> x;\n\tstring s; cin >> s;\n\tbs gcd0 = mak(s);\n\trep(i, n - 1) {\n\t\tstring ne; cin >> ne;\n\t\tbs newb = mak(ne);\n\t\tgcd0 = gcd(newb, gcd0);\n\t}\n\tbs nw = mak(x);\n\trep(i, m + 9) { rui[i + 1] = rui[i] * 2; rui[i + 1] %= p; }\n\tcout << solve(nw, gcd0,true) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 998244353;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 4010\nll p2[N];\n\nvoid xo(string &a, string &b){\n\tint n = min(a.size(), b.size());\n\trep(i, n) a[i] = '0'+(a[i]^b[i]);\n}\n\nbool le(string &a, string &b){\n\tint n = min(a.size(), b.size());\n\trep(i, n){\n\t\tif(a[i]<b[i]) return true;\n\t\tif(a[i]>b[i]) return false;\n\t}\n\treturn true;\n}\n\nvoid ker(vector<string> &s){\n\tint n = s.size();\n\trep(i, n-1){\n\t\twhile(s[i].size()>0){\n\t\t\tif(s[i].size()<s[i+1].size()) s[i].swap(s[i+1]);\n\t\t\txo(s[i], s[i+1]);\n\t\t\tint j = 0;\n\t\t\twhile(j<s[i].size() &&s[i][j]=='0') j++;\n\t\t\ts[i].erase(0, j);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tstring x;\n\tcin>>n>>x;\n\tint m = x.size();\n\tvector<string> s(n);\n\trep(i, n) cin>>s[i];\n\tker(s);\n\tstring a(s[n-1]), b(m, '0');\n\tp2[0] = 1;\n\trep(i, N-1) p2[i+1] = p2[i]*2%mod;\n\tll res = 0;\n\tint m2 = a.size(), l = m-m2+1;\n\trep(i, l){\n\t\tb.erase(0, 1); b += '0';\n\t\tif(x[i]=='1'){\n\t\t\tres += p2[l-i-1];\n\t\t\tif(b[0]=='0'){\n\t\t\t\txo(b, a);\n\t\t\t}\n\t\t} else {\n\t\t\tif(b[0]=='1'){\n\t\t\t\txo(b, a);\n\t\t\t}\n\t\t}\n\t\tres %= mod;\n\t}\n\t/*cerr<<\"debug\"<<endl;\n\tcerr<<a<<endl;\n\tcerr<<b<<endl;\n\tcerr<<x<<endl;*/\n\tstring y = x.substr(m-m2);\n\tif(le(b, y)) res++;\n\tcout<<res%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\ntypedef bitset<4000> b4000;\n\nconst int MOD = 998244353;\n\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint pow2[4444];\nb4000 cyc[4001];\nint dp[4111];\nint curmin;\nb4000 smallest;\n\nint getmx(b4000 &x)\n{\n\tfor(int i=3999;i>=0;i--)\n\t{\n\t\tif(x[i]) return i;\n\t}\n\treturn -1;\n}\n\nvoid solve(vector<b4000> &vec)\n{\n\tint n=vec.size();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\twhile(vec[i].count()>0&&vec[j].count()>0)\n\t\t\t{\n\t\t\t\t//cerr<<vec[i].count()<<' '<<vec[j].count()<<'\\n';\n\t\t\t\tint i2=i; int j2=j;\n\t\t\t\tint siz1=getmx(vec[i]); int siz2=getmx(vec[j]);\n\t\t\t\tif(siz1<siz2) \n\t\t\t\t{\n\t\t\t\t\tswap(i2,j2); swap(siz1,siz2);\n\t\t\t\t}\n\t\t\t\tvec[i2] = (vec[i2]^(vec[j2]<<(siz1-siz2)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\t//cerr<<i<<' '<<vec[i].count()<<'\\n';\n\t\tif(!vec[i].count()) continue;\n\t\tsmallest=vec[i];\n\t\treturn ;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tpow2[0]=1;\n\tfor(int i=1;i<=4440;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t}\n\tint n; string s; cin>>n>>s;\n\tvector<b4000> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tstring z; cin>>z;\n\t\tb4000 tmp; tmp.reset();\n\t\treverse(z.begin(),z.end());\n\t\tfor(int j=0;j<z.length();j++)\n\t\t{\n\t\t\tif(z[j]=='1') tmp.set(j,1);\n\t\t}\n\t\tvec.pb(tmp);\n\t}\n\tsolve(vec);\n\t//cerr<<smallest<<'\\n';\n\tfor(int i=3999;i>=0;i--)\n\t{\n\t\tif(smallest[i])\n\t\t{\n\t\t\tcyc[i]=smallest;\n\t\t\tfor(int j=i+1;j<4000;j++)\n\t\t\t{\n\t\t\t\tsmallest<<=1;\n\t\t\t\tcyc[j]=smallest;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tb4000 cur; cur.reset();\n\tb4000 tmp;\n\tdp[0]=(cyc[0].count()>0?1:0);\n\tfor(int i=1;i<4000;i++)\n\t{\n\t\tif(cyc[i].count()>0) dp[i]=1;\n\t\tdp[i]+=dp[i-1];\n\t}\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tif(s[i]=='1') tmp.set(int(s.length())-1-i,1);\n\t}\n\tint ans=0;\n\tfor(int i=int(s.length())-1;i>=0;i--)\n\t{\n\t\tif(tmp[i])\n\t\t{\n\t\t\tif(cur[i])\n\t\t\t{\n\t\t\t\tif(cyc[i].count()>0)\n\t\t\t\t{\n\t\t\t\t\tint v=1;\n\t\t\t\t\tif(i-1>=0) v=pow2[dp[i-1]];\n\t\t\t\t\tans=add(ans,v);\n\t\t\t\t}\n\t\t\t\tif(i==0) ans++;\n\t\t\t\t//otherwise proceed as usual\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint v=1;\n\t\t\t\tif(i-1>=0) v=pow2[dp[i-1]];\n\t\t\t\tans=add(ans,v);\n\t\t\t\tif(cyc[i].count()==0) break;\n\t\t\t\tif(i==0) ans++;\n\t\t\t\tcur^=cyc[i];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(cur[i])\n\t\t\t{\n\t\t\t\tif(cyc[i].count()>0)\n\t\t\t\t{\n\t\t\t\t\tif(i==0) ans++;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcur^=cyc[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==0) ans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int N, lb, a, z;\nbitset<4444> A[7], X, Y, Z;\nchar s[4444];\n\ntemplate <size_t N>\nlong long to_modllong(bitset<N> n){\n    long long ret = 0;\n    for(int i = N; --i >= 0;ret += n[i]){\n        ret <<= 1;\n        ret %= 998244353;\n    }\n    return ret;\n}\n\ntemplate <typename T>\nstatic inline T gcd(T u, T v){\n    int sftu = 0, sftv = 0;\n    T t;\n    if(u.none()) return v;\n    if(v.none()) return u;\n    while(!u[0]){\n        ++sftu;\n        u >>= 1;\n    }\n    while(!v[0]){\n        ++sftv;\n        v >>= 1;\n    }\n    sftu = min(sftu, sftv);\n    do{\n        while(!v[0])v >>= 1;\n        swap(u, v);\n        v = v ^ u;\n    }while(v.any());\n    return u << sftu;\n}\n\nint main(){\n    scanf(\"%lld %s\", &N, s);\n    X = bitset<4444>(s);\n    Z = X;\n    for(int i = 0; i < N; ++i){\n        scanf(\" %s\", s);\n        A[i] = bitset<4444>(s);\n    }\n    Y = A[0];\n    for(int i = 1; i < N; ++i)Y = gcd(A[i], Y);\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (lb = i))break;\n    for(int i = 4443 - lb; i >= 0; --i){\n        if(X[i + lb]){\n            X ^= Y << i;\n            A[6] ^= Y << i;\n        }\n    }\n    if(lb < 64){\n        a = (A[6] & ~(Z & A[6])).to_ullong();\n        z = (Z & ~(Z & A[6])).to_ullong();\n        cout << (to_modllong(Z >> lb) + (a < z)) % 998244353 << endl;\n    }else{\n        long long d;\n        Y = A[6] ^ Z;\n        for(int i = 4443; i >= 0; --i)if(Y[i] && (d = i))break;\n        cout << (to_modllong(Z >> lb) + (!d || Z[d])) % 998244353 << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdint>\n#include <cassert>\n\n\n#include <iostream>\n#include <bitset>\n\ntemplate<const std::size_t N>\nstruct binfps {\n  using size_type = std::size_t;\n  using bit_type = std::uint_fast64_t;\n\n  const static size_type lg = 6;\n  const static bit_type lgmask = (bit_type(1) << lg) - 1;\n  const static size_type _w_len = (N + (bit_type(1) << lg) - 1) >> lg;\n  std::array<bit_type, _w_len> w;\n  size_type len;\n\n  binfps(): len(0) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n  }\n\n  binfps(const std::bitset<N>& b) {\n    for(size_type i = 0; i < _w_len; i++) {\n      w[i] = 0;\n    }\n    for(size_type i = 0; i < N; i++) {\n      if(b[i]) set(i);\n    }\n    recalc();\n  }\n\n  int size() const { return this->len; }\n  void recalc() {\n    len = 0;\n    for(size_type i = w.size(); i --> 0; ) {\n      if(w[i]) {\n        for(size_type j = (1 << lg); j --> 0;) {\n          if(w[i] >> j) {\n            len = j + 1 + (i << lg);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  void set(size_type i) { w[i >> lg] |= (bit_type(1) << (i & lgmask)); }\n  void unset(size_type i) { w[i >> lg] &= ~(bit_type(1) << (i & lgmask)); }\n\n  bool any() const {\n    for(size_type i = 0; i < _w_len; i++) {\n      if(w[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool operator[](size_type i) const {\n    return (w[i >> lg] >> (i & lgmask)) & 1;\n  }\n\n  binfps& operator^=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] ^= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator&=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n  binfps& operator|=(const binfps& b) {\n    for(size_type i = w.size(); i --> 0;) {\n      w[i] &= b.w[i];\n    }\n    return *this;\n  }\n\n\n  binfps& operator<<=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    bit_type off = x >> lg;\n    bit_type m = x & lgmask;\n    bit_type dwmask = ((bit_type)(1) << (64 - m)) - 1;\n    if(m == 0) {\n      dwmask = ~(bit_type)(0);\n    }\n    bit_type upmask = ~dwmask;\n    // up\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i + off + 1] |= (w[i] & upmask) >> m;\n    }\n    // down\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i + off] |= (w[i] & dwmask) << m;\n    }\n\n    w = std::move(next);\n    len = std::min(N, len + x);\n    return (*this);\n  }\n\n  binfps& operator>>=(size_type x) {\n    std::array<bit_type, _w_len> next;\n    for(size_type i = 0; i < _w_len; i++) {\n      next[i] = 0;\n    }\n    bit_type off = x >> lg;\n    bit_type m = x & lgmask;\n    bit_type dwmask = (bit_type(1) << m) - 1;\n    if(m == 0) {\n      dwmask = 0;\n    }\n    bit_type upmask = ~dwmask;\n    // down\n    for(size_type i = 0; i + off + 1 < _w_len; i++) {\n      next[i] |= (w[i + off + 1] & dwmask) << (64 - m);\n    }\n    // up\n    for(size_type i = 0; i + off < _w_len; i++) {\n      next[i] |= (w[i + off] & upmask) >> m;\n    }\n    w = std::move(next);\n    if(len < x) {\n      len = 0;\n    }\n    else {\n      len = len - x;\n    }\n    return (*this);\n  }\n\n  binfps operator^(const binfps& b) const { return binfps(*this) ^= b; }\n  binfps operator&(const binfps& b) const { return binfps(*this) &= b; }\n  binfps operator|(const binfps& b) const { return binfps(*this) |= b; }\n  binfps operator<<(const size_type x) const { return binfps(*this) <<= x; }\n  binfps operator>>(const size_type x) const { return binfps(*this) >>= x; }\n  binfps operator~() {\n    binfps a = *this;\n    for(size_type i = w.size(); i --> 0;) {\n      a.w[i] = ~w[i];\n    }\n    return a;\n  }\n\n  bool operator<(const binfps& b) const {\n    bool OK = false;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] < b.w[i]) {\n          OK = true;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n  bool operator<=(const binfps& b) const {\n    bool OK = true;\n    for(size_type i = _w_len; i --> 0; ) {\n      if(w[i] != b.w[i]) {\n        if(w[i] > b.w[i]) {\n          OK = false;\n        }\n        break;\n      }\n    }\n    return OK;\n  }\n\n  static binfps mod(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    for(int i = (int)a.size() - (int)b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n      }\n    }\n    a.recalc();\n    return a;\n  }\n\n  static binfps div(binfps a, const binfps& b) {\n    assert(b.size() > 0);\n    binfps d;\n    for(int i = (int)a.size() - (int)b.size() + 1; i --> 0;) {\n      if(a[i + b.size() - 1]) {\n        a ^= (b << i);\n\n        binfps e;\n        e.set(i);\n        d ^= e;\n      }\n    }\n    d.recalc();\n    return d;\n  }\n\n  static binfps gcd(binfps a, binfps b) {\n    while(b.any()) {\n      auto m = mod(a, b);\n      a = std::move(b);\n      b = std::move(m);\n    }\n    return a;\n  }\n\n  void dump() const {\n    for(size_type i = _w_len; i --> 0; ) {\n      std::cerr << std::bitset<64>(w[i]) << \"|\" << std::endl;\n    }\n    std::cerr << std::endl;\n  }\n};\n\n\nconst int BN = 5000;\nusing bits = binfps<BN>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n \nint main() {\n  i64 N;\n  cin >> N;\n  std::bitset<BN> binp;\n  cin >> binp;\n  bits X(binp);\n  X.recalc();\n \n  vector<bits> A(N);\n  rep(i,0,N) {\n    cin >> binp;\n    A[i] = bits(binp);\n    A[i].recalc();\n  }\n  auto G = A[0];\n  for(i64 i = 1; i < N; i++) {\n    G = bits::gcd(G, A[i]);\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  if(X.size() - G.size() + 1 >= 0) {\n    vector<i64> Bs(X.size() - G.size() + 1, 1);\n    for(i64 i = 1; i < X.size() - G.size() + 1; i++) {\n      Bs[i] = (Bs[i - 1] * 2) % MOD;\n    } \n    bits now;\n    for(i64 i = X.size() - G.size() + 1; i --> 0;) {\n      if(X[i + G.size() - 1]) {\n        ans = (ans + Bs[i]) % MOD;\n      }\n      if(now[i + G.size() - 1] != X[i + G.size() - 1]) {\n        now ^= (G << i);\n      }\n    }\n    if(now <= X) ans = (ans + 1) % MOD;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define maxn 5005\n#define plus qaq\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\nint n;\nchar s[maxn];\nint t[maxn],a[10][maxn],g[maxn],temp[maxn];\nvoid trans(char *x,int *y)\n{\n\tint len=strlen(x);\n\tfor(int i=0;i<=len-1;i++)\n\t\ty[i]=x[len-1-i]-'0';\n}\nint deg(int *a)\n{\n\tfor(int i=4000;i>=0;i--)\n\t\tif(a[i])\n\t\t\treturn i;\n\treturn 0;\n}\nvoid plus(int *a,int *b,int m)\n{\n\tfor(int i=m;i<=4000;i++)\n\t\ta[i]=(a[i]^b[i-m]);\n}\nvoid getgcd(int *a,int *b,int *gg)\n{\n//\tfor(int i=0;i<=5;i++)\n//\t\tcerr<<a[i];\n//\tcerr<<endl;\n//\tfor(int i=0;i<=5;i++)\n//\t\tcerr<<b[i];\n//\tcerr<<endl;\n\tint da=deg(a),db=deg(b);\n\tif(da<db) swap(a,b),swap(da,db);\n//\tcerr<<\"this \"<<da<<\" \"<<db<<endl;\n\tif(db==0 && b[0]==0)\n\t{\n//\t\tmemcpy(gg,a,sizeof(a));\n\t\tfor(int i=0;i<=4000;i++)\n\t\t\tgg[i]=a[i];\n\t\treturn;\n\t}\n\tplus(a,b,da-db);\n\tgetgcd(b,a,gg);\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,s); trans(s,t);\n\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",s); trans(s,a[i]);\n\t\tgetgcd(a[i],g,temp);\n\t\tmemcpy(g,temp,sizeof(g));\n//\t\tcerr<<\"its \"<<i<<endl;\n//\t\tfor(int j=0;j<=11;j++)\n///\t\t\tcerr<<g[j];\n//\t\tcerr<<endl;\n\t}\n\n\tint d=deg(g);\n\n//\tfor(int i=0;i<=11;i++)\n//\t\tcerr<<g[i];\n//\tcerr<<endl;\n\n\tmemset(temp,0,sizeof(temp));\n\n\tfor(int i=4000;i>=d;i--)\n\tif(temp[i]^t[i])\n\t{\n\t\tplus(temp,g,i-d);\n\t}\n\n\tll ans=0;\n\tint dd=deg(t);\n\tfor(int i=dd;i>=d;i--)\n\t\tans=((ans<<1)+t[i])%mod;\n\tfor(int i=dd-1;i>=0;i--)\n\t{\n\t\tif(temp[i]<t[i])\n\t\t\tbreak;\n\t\telse if(temp[i]>t[i])\n\t\t{\n\t\t\tans--;\n\t\t\tans=(ans%mod+mod)%mod;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ans+1)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 205;\nconst int   mod = 1e9 + 7;\n\nvoid add(int&a,int b)   {   a += b; if (a >= mod)   a -= mod;   }\nvoid sub(int&a,int b)   {   a -= b; if (a <  0)     a += mod;   }\n\nint mul(int a,int b)    {   return  1ll * a * b % mod;  }\nint inv(int a,int p)    {   return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;    }\nint Pow(int a,int b)    {\n    int ans = 1;\n    while  (b)  {\n        if (b & 1)  ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\n\nstring calc(string A,string B)  {\n    while (A.size() && B.size())    {\n        if (A.size() > B.size())\n            A.swap(B);\n        \n        for(int i = 0 ; i < sz(A) ; ++i)    {\n            if (A[i] == B[i])   B[i] = '0';\n            else                B[i] = '1';\n        }\n        reverse(all(B));    while (sz(B) && B.back() == '0')    B.pop_back();\n        reverse(all(B));\n    }\n    if (A.empty())  return  B;\n    if (B.empty())  return  A;\n\n    assert(0);\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    string lim; cin >> lim;\n    string gcd;\n\n    for(int i = 0 ; i < n ; ++i)    {\n        string S;   cin >> S;\n        if (i == 0) gcd = S;\n        else        gcd = calc(gcd,S);\n    }\n    if (sz(lim) < sz(gcd))  {\n        cout << \"1\\n\";\n        return  0;\n    }\n    string tmp = string(sz(lim),'0');\n    int ans = 0;\n\n    for(int i = 0 ; i <= sz(lim) - sz(gcd) ; ++i)   {\n        if (lim[i] != tmp[i])\n            for(int j = 0 ; j < sz(gcd) ; ++j)  {\n                tmp[i + j] ^= gcd[j];\n                tmp[i + j] += '0';\n            }\n        if (lim[i] == '1')\n            add(ans,Pow(2,sz(lim) - sz(gcd) - i));\n    }    \n    if (tmp <= lim)\n        ans++;\n    \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint N;\nstring X, G;\nvector<string> A;\n\nstring gcd(string a, string b) {\n    if(a.size() < b.size()) return gcd(b, a);\n    if(b.size() == 0) return a;\n\n    string ret;\n    bool t = false;\n    for(int i = 0; i < b.size(); i++) {\n        char c = a[i] == b[i]? '0' : '1';\n        if(c == '1') t = true;\n        if(t) ret.push_back(c);\n    }\n    for(int i = b.size(); i < a.size(); i++) {\n        if(a[i] == '1') t = true;\n        if(t) ret.push_back(a[i]);\n    }\n    return gcd(ret, b);\n}\n\nbool cmp(string a, string b) {\n    if(a.size() != b.size()) return a.size() < b.size();\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] != b[i]) return a[i] < b[i];\n    }\n    return false;\n}\n\nint str_to_int(string s) {\n    if(s.size() == 0) return 0;\n    int ret = 0;\n    for(int i = 0; i < s.size(); i++) {\n        ret = ret * 2 % mod;\n        if(s[i] == '1') ret = (ret + 1) % mod;\n    }\n    return ret;\n}\n\nstring C;\n\nint dfs(int idx) {\n    if(idx == X.size() - G.size() + 1) return cmp(C, X) || C == X;\n    if(C[idx] != X[idx]) {\n        for(int i = idx; i < idx + G.size(); i++) {\n            C[i] = C[i] == G[i - idx]? '0' : '1';\n        }\n    }\n    return dfs(idx + 1);\n}\n\nint ans;\n\nint main() {\n    cin >> N >> X;\n\n    A.resize(N);\n    for(int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n\n    G = \"\";\n    for(int i = 0; i < N; i++) {\n        G = gcd(A[i], G);\n    }\n\n    if(cmp(X, G)) {\n        cout << 1;\n        return 0;\n    }\n\n    ans = str_to_int(X.substr(0, X.size() - G.size() + 1));\n\n    for(int i = 0; i < X.size(); i++) C.push_back('0');\n    ans += dfs(0);\n    ans %= mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE=4010;\nusing Bit=bitset<SIZE>;\n\nusing ll=long long;\nconst ll MOD=998244353;\n\nll powm(ll x,ll k){\n    ll res=1;\n    while(k){\n        if(k&1) res=res*x%MOD;\n        x=x*x%MOD;\n        k>>=1;\n    }\n    return res;\n}\nint main(){\n    int n;\n    Bit x;\n    cin>>n>>x;\n    vector<Bit> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n    auto baseId=[&](){\n        int id=-1;\n        for(int i=0;i<n;i++){\n            if(a[i]==0) continue;\n            if(id==-1){\n                id=i;\n                continue;\n            }\n            for(int j=SIZE-1;j>=0;j--){\n                if(a[id][j] && !a[i][j]){\n                    id=i;\n                    break;\n                }\n                if(!a[id][j] && a[i][j]) break;\n            }\n        }\n        return id;\n    };\n    auto topBit=[&](int id){\n        for(int i=SIZE-1;i>=0;i--){\n            if(a[id][i]){\n                return i;\n            }\n        }\n        return -1;\n    };\n    for(int i=SIZE-1;i>=0;i--){\n        int bid=baseId();\n        int top=topBit(bid);\n        if(i<top) break;\n        for(int j=0;j<n;j++){\n            if(j!=bid && a[j][i]){\n                a[j]^=(a[bid]<<(i-top));\n            }\n        }\n    }\n\n    ll res=0;\n    int bid=baseId();\n    int top=topBit(bid);\n    Bit base=a[bid];    \n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]) res=(res+powm(2,i-top))%MOD;\n    }\n    Bit v;\n    for(int i=SIZE-1;i>=top;i--){\n        if(x[i]^v[i]) v^=(base<<(i-top));\n    }\n    for(int i=SIZE-1;i>=0;i--){\n        if(!x[i] && v[i]){\n            break;\n        }\n        if(x[i] && !v[i]){\n            res++;\n            break;\n        }\n        if(i==0) res++;\n    }\n    res%=MOD;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\nconst int N = 4010;\nconst int mod = 998244353;\n\ninline int deg(const bitset <N> &b) {\n  int t = N - 1;\n  while (t >= 0 && !b[t]) t --;\n  return t + 1;\n}\n\nint n;\nchar buf[N];\n\ninline void read(bitset <N> &b) {\n  scanf(\"%s\", buf);\n  reverse(buf, buf + strlen(buf));\n  for (int i = 0; buf[i]; i ++)\n    b[i] = (bool)(buf[i] - '0');\n}\n\nbitset <N> X, A[10], oppo, Y;\n\ninline bitset <N> gcd(bitset <N> p, bitset <N> q) {\n  int a = deg(p);\n  int b = deg(q);\n  while (true) {\n    if (!a) return q;\n    if (!b) return p;\n    if (a < b) {\n      swap(p, q); swap(a, b);\n    }\n    p ^= q << (a - b);\n    while (a >= 0 && p[a] == 0) a --;\n    a ++;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  read(X);\n  for (int i = 1; i <= n; i ++) read(A[i]);\n  for (int i = 2; i <= n; i ++)\n    A[1] = gcd(A[1], A[i]);\n  int ans = 0, j = deg(A[1]);\n  for (int i = deg(X) - 1; i >= j - 1; i --) \n    ans = ((ans << 1) + X[i]) % mod;\n  Y = X;\n  for (int i = deg(X) - 1; i >= j - 1; i --)\n    if (X[i]) {\n      X ^= A[1] << (i - j + 1);\n      oppo ^= A[1] << (i - j + 1);\n    }\n  for (int i = deg(Y) - 1; ~ i; i --)\n    if (oppo[i] != Y[i]) {\n      if (oppo[i] > Y[i]) ans --;\n      break;\n    }\n  ans = (ans + 1) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nconstexpr int DMAX = 4001;\nconstexpr lint MOD = 998244353;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<bitset<DMAX>> A;\n\n    string S;\n    cin >> S;\n    bitset<DMAX> X(S);\n    for (int i = 0; i < N; i++)\n    {\n        cin >> S;\n        A.push_back(bitset<DMAX>(S));\n    }\n\n    int d = 0;\n    for (int ii = 0; ii <= DMAX*2; ii++)\n    {\n        sort(A.begin(), A.end(), [](const auto &l, const auto &r) { return l.to_string() < r.to_string(); });\n        if (!A[0].any()) A.erase(A.begin());\n        bitset<DMAX> tmp = A[0];\n        d = 0;\n        while ((tmp >> d).any()) d++;\n        for (int i = 1; i < A.size(); i++)\n        {\n            while ((A[i] >> d).any())\n            {\n                d++;\n                tmp <<= 1;\n            }\n            A[i] ^= tmp;\n        }\n    }\n    bitset<DMAX> making;\n    for (int i = DMAX - d; i >= 0; i--)\n    {\n        bitset<DMAX> making_tmp = making ^ (A[0] << i);\n        if (making.to_string() > making_tmp.to_string()) swap(making, making_tmp);\n        if ((making_tmp >> (i + d - 1)).to_string() <= (X >> (i + d - 1)).to_string()) making = making_tmp;\n    }\n    lint ans = 0;\n    lint dig = 1;\n    for (int i = 0; i < DMAX; i++)\n    {\n        (ans += (X >> (d - 1))[i] * dig) %= MOD;\n        (dig *= 2) %= MOD;\n    }\n    \n    cout << (ans + (making.to_string() <= X.to_string())) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353;\n\nll n;\nvector<bool> x;\nvector<bool> a,b;\n\nvoid mns(){\n    for(ll i=(int)a.size()-1;i>=(int)b.size()-1;i--){\n        if(a[i]==1){\n            for(int t=0;t<b.size();t++){\n                a[i-t]=a[i-t]^b[b.size()-t-1];\n            }\n        }\n    }\n    while(!a.empty() && a.back()==0){a.pop_back();}\n    swap(a,b);\n}\n\n\n\n\n\n\n\n\nint main(){\n    vector<ll> P(1000000,1);\n    for(ll i=1;i<P.size();i++){P[i]=P[i-1]*2%MOD;}\n    cin>>n;\n    string X;\n    cin>>X;\n    reverse(X.begin(),X.end());\n    x.resize(X.size());\n    for(int i=0;i<X.size();i++){\n        x[i]=X[i]-'0';\n    }\n    string A;\n    cin>>A;\n    reverse(A.begin(),A.end());\n    a.resize(A.size());\n    for(int i=0;i<A.size();i++){\n        a[i]=A[i]-'0';\n    }\n    for(int i=1;i<n;i++){\n        string B;\n        cin>>B;\n        reverse(B.begin(),B.end());\n        b.resize(B.size());\n        for(int i=0;i<B.size();i++){\n            b[i]=B[i]-'0';\n        }\n        if(a.size()<b.size()){swap(a,b);}\n        while(b.size()){mns();}\n    }\n    ll ans=0;\n    vector<bool> Z(x.size(),false);\n    for(ll i=(int)x.size()-1;i>=(int)a.size()-1;i--){\n        if(x[i]){\n            ans+=P[i-(a.size()-1)];\n            ans%=MOD;\n            if(Z[i]==0){\n                for(int t=0;t<a.size();t++){\n                    Z[i-t]=Z[i-t]^a[a.size()-1-t];\n                }\n            }\n        }\n        else{\n            if(Z[i]){\n                for(int t=0;t<a.size();t++){\n                    Z[i-t]=Z[i-t]^a[a.size()-1-t];\n                }\n            }\n        }\n    }\n    bool j=true;\n    for(ll i=X.size()-1;i>=0;i--){\n        if(X[i]==false && Z[i]==true){j=false;}\n        if(X[i]==true && Z[i]==false){break;}\n    }\n    //if(j){ans++;}\n    cout<<ans%MOD<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nusing bits = bitset<4000>;\n\nint main() {\n\n  auto bitlen = [](const bits& a) {\n    for(i64 j = 4000; j --> 0;) {\n      if(a[j]) {\n        return j + 1;\n      }\n    }\n    return 0ll;\n  };\n\n  i64 N;\n  cin >> N;\n  bits X;\n  i64 xs;\n  cin >> X;\n  xs = bitlen(X);\n\n  vector<bits> A(N);\n  vector<i64> S(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    S[i] = bitlen(A[i]);\n  }\n  auto bitmod = [](bits a, i64 as, bits b, i64 bs) {\n    for(i64 i = as - bs + 1; i --> 0;) {\n      if(a[i + bs - 1]) {\n        a ^= (b << i);\n      }\n    }\n    return a;\n  };\n\n  auto bitgcd = [&](bits a, i64 as, bits b, i64 bs) {\n    while(b.any()) {\n      auto m = bitmod(a, as, b, bs);\n      a = b;\n      as = bs;\n      b = m;\n      bs = bitlen(b);\n    }\n    return pair<bits, i64>(a, as);\n  };\n\n  auto g = A[0];\n  auto gs = S[0];\n  for(i64 i = 1; i < N; i++) {\n    auto p = bitgcd(g, gs, A[i], S[i]);\n    g = p.first;\n    gs = p.second;\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  vector<i64> Bs(xs - gs + 1, 1);\n  for(i64 i = 1; i < xs - gs + 1; i++) {\n    Bs[i] = (Bs[i - 1] * 2) % MOD;\n  } \n  bits now;\n  for(i64 i = xs - gs + 1; i --> 0;) {\n    if(X[i + gs - 1]) {\n      ans = (ans + Bs[i]) % MOD;\n    }\n    if(now[i + gs - 1] != X[i + gs - 1]) {\n      now ^= (g << i);\n    }\n  }\n  if(bitmod(X, xs, now, bitlen(now)) != X) { ans = (ans + 1) % MOD; }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 998244353;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nconst int D = 4000;\ntypedef std::bitset<D + 10> B;\nB X, t, g;\nint get(B x, int at = D) {\n\twhile (at && !x.test(at)) --at;\n\treturn at;\n}\nB gcd(B a, B b) {\n\tfor (int i = D; ~i; )\n\t\tif (a.test(i) || b.test(i)) {\n\t\t\tif (b.test(i) && !a.test(i)) std::swap(a, b);\n\t\t\tif (b.none()) return a;\n\t\t\ta ^= b << i - get(b);\n\t\t} else --i;\n}\nint n, ans = 0;\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> X;\n\twhile (n --> 0) std::cin >> t, g = gcd(g, t);\n\tint u = get(X), d = get(g);\n\tans = 1;\n\tfor (int i = d; i <= u; ++i) if (X.test(i))\n\t\treduce(ans += pow(2, i - d) - mod);\n\tB r;\n\tfor (int i = u; i > d; --i)\n\t\tif (X.test(i) != r.test(i)) r ^= g << i - d;\n\tfor (int i = u; ~i; --i)\n\t\tif (X.test(i) != r.test(i)) {\n\t\t\tif (!X.test(i)) reduce(ans -= 1);\n\t\t\tbreak;\n\t\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nvector<int> num[7],x,g,t;\nint N;\nchar s[4005];\nvector<int> gcd(vector<int> a,vector<int> b) {\n\tif(a.size() < b.size()) swap(a,b);\n\tif(b.size() == 1 && b[0] == 0) return a;\n\tvector<int> d(a.size());\n\tint t = a.size() - 1;\n\tfor(int i = b.size() - 1 ; i >= 0 ; --i) {\n\t\td[t] = a[t] ^ b[i];\n\t\t--t;\n\t}\n\tfor(int i = t ; i >= 0 ; --i) d[i] = a[i];\n\twhile(d.size() > 1) {\n\t\tif(d.back() == 0) d.pop_back();\n\t\telse break;\n\t}\n\treturn gcd(b,d);\n}\nvoid Init() {\n\tread(N);\n\tscanf(\"%s\",s + 1);\n\tint len = strlen(s + 1);\n\tfor(int i = len ; i >= 1 ; --i) {\n\t\tx.pb(s[i] - '0');\n\t}\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tscanf(\"%s\",s + 1);\n\t\tlen = strlen(s + 1);\n\t\tfor(int j = len ; j >= 1 ; --j) num[i].pb(s[j] - '0');\n\t}\n\tg = num[1];\n\tfor(int i = 2 ; i <= N ; ++i) g = gcd(g,num[i]);\n}\nvoid Solve() {\n\tt = x;\n\tif(g.size() > x.size()) {out(1);enter;return;}\n\tint l = x.size() - g.size() + 1;\n\tint d = x.size() - 1;\n\tint ans = 0;\n\tfor(int i = 0 ; i < l ; ++i) {\n\t\tans = (1LL * ans * 2 + x[d - i]) % MOD;\n\t}\n\tans = (ans + 1) % MOD;\n\tfor(int i = l ; i < x.size() ; ++i) t[d - i] = 0;\n\tfor(int i = 0 ; i < l ; ++i) {\n\t\tif(t[d - i] == 1) {\n\t\t\tint k = g.size() - 1;\n\t\t\tfor(int j = 0 ; j < g.size() ; ++j) {\n\t\t\t\tt[d - i - j] = t[d - i - j] ^ g[k - j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = l ; i < x.size() ; ++i) {\n\t\tif(t[d - i] != x[d - i]) {\n\t\t\tif(t[d - i] > x[d - i]) ans = (ans + MOD - 1) % MOD;\n\t\t\telse break;\n\t\t}\n\t}\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tInit();\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << endl\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/2;\nconst ll MOD = 998244353;\n\ninline ll add(ll a, ll b, ll M) { // a + b (mod M)\n    return (a += b) >= M ? a - M : a;\n}\ninline ll sub(ll a, ll b, ll M) { // a - b (mod M)\n    return (a -= b) < 0 ? a + M : a;\n}\ninline ll mul(ll a, ll b, ll M) { // a * b (mod M)\n    ll r = a*b - (ll)((long double)(a)*b/M+.5)*M;\n    return r < 0 ? r + M: r;\n}\ninline ll div(ll a, ll b, ll M) { // solve b x == a (mod M)\n    ll u = 1, x = 0, s = b, t = M;\n    while (s) { // extgcd for b x + M s = t\n        ll q = t / s;\n        swap(x -= u * q, u);\n        swap(t -= s * q, s);\n    }\n    if (a % t) return -1; // infeasible\n    return mul(x < 0 ? x + M : x, a / t, M); // b (xa/t) == a (mod M)\n}\ninline ll pow(ll a, ll b, ll M) {\n    ll x = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) x = (a * x) % M;\n        a = (a * a) % M;\n    }\n    return x;\n}\n\n// p(x) = p[0] + p[1] x + ... + p[n-1] x^n-1\n// assertion: p.back() != 0\ntypedef vector<ll> poly;\nostream& operator<<(ostream &os, const poly &p) {\n    bool head = true;\n    for (size_t i = 0; i < p.size(); ++i) {\n        if (p[i] == 0) continue;\n        if (!head) os << \" + \";\n        os << p[i];\n        head = false;\n        if (i >= 1) os << \" x\";\n        if (i >= 2) os << \"^\" << i;\n    }\n    return os;\n}\ninline poly add(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = add(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\ninline poly sub(poly p, const poly &q, ll M) {\n    if (p.size() < q.size()) p.resize(q.size());\n    for (size_t i = 0; i < q.size(); ++i)\n        p[i] = sub(p[i], q[i], M);\n    while (!p.empty() && !p.back()) p.pop_back();\n    return p;\n}\n\n\n/*\n// FFT-based multiplication: this works correctly for M in [int]\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root, int sign>\ninline void fmt(vector<ll>& x) {\n    const int n = x.size();\n    int h = pow(primitive_root, (mod-1)/n, mod);\n    if (sign < 0) h = div(1, h, mod);\n    for (int i = 0, j = 1; j < n-1; ++j) {\n        for (int k = n >> 1; k > (i ^= k); k >>= 1);\n        if (j < i) swap(x[i], x[j]);\n    }\n    for (int m = 1; m < n; m *= 2) {\n        ll w = 1, wk = pow(h, n / (2*m), mod);\n        for (int i = 0; i < m; ++i) {\n            for (int s = i; s < n; s += 2*m) {\n                ll u = x[s], d = x[s + m] * w % mod;\n                if ((x[s] = u + d) >= mod) x[s] -= mod;\n                if ((x[s + m] = u - d) < 0) x[s + m] += mod;\n            }\n            w = w * wk % mod;\n        }\n    }\n    if (sign < 0) {\n        ll inv = div(1, n, mod);\n        for (auto &a: x)\n            a = a * inv % mod;\n    }\n}\n// assume: size of a/b is power of two, mod is predetermined\ntemplate <int mod,int primitive_root>\ninline vector<ll> conv(vector<ll> a, vector<ll> b){\n    fmt<mod,primitive_root,+1>(a); fmt<mod,primitive_root,+1>(b);\n    for (size_t i = 0; i < a.size(); ++i)\n        a[i] = a[i] * b[i] % mod;\n    fmt<mod,primitive_root,-1>(a);\n    return a;\n}\n// general convolution where mod < 2^31.\ninline vector<ll> conv(vector<ll> a, vector<ll> b, ll mod){\n    int n = a.size() + b.size() - 1;\n    for (int k: {1,2,4,8,16}) n |= (n >> k);\n    ++n;\n    a.resize(n); b.resize(n);\n    const int A = 167772161, B = 469762049, C = 1224736769, D = (ll)(A) * B % mod;\n    if(mod==A)return conv<A,3>(a,b);\n    if(mod==B)return conv<B,3>(a,b);\n    if(mod==C)return conv<C,3>(a,b);\n    if(mod==924844033)return conv<924844033,5>(a,b);\n    vector<ll> x = conv<A,3>(a,b), y = conv<B,3>(a,b), z = conv<C,3>(a,b);\n    for (size_t i = 0; i < x.size(); ++i) {\n        ll X = (y[i] - x[i]) * 104391568;\n        if ((X %= B) < 0) X += B;\n        ll Y = (z[i] - (x[i] + A * X) % C) * 721017874;\n        if ((Y %= C) < 0) Y += C;\n        x[i] += A * X + D * Y;\n        if ((x[i] %= mod) < 0) x[i] += mod;\n    }\n    x.resize(n);\n    return x;\n}\n\ninline poly mul(poly p, poly q, ll M) {\n    poly pq = conv(p, q, M);\n    pq.resize(p.size() + q.size() - 1);\n    while (!pq.empty() && !pq.back()) pq.pop_back();\n    return pq;\n}\n*/\nnamespace FFT {\n    const int max_base = 19, maxN = 1 << max_base; // N <= 2e5\n    const double PI = acos(-1);\n    struct num {\n        long double x{}, y{};\n        num() = default;\n        num(long double x,long double y): x(x), y(y) {}\n        explicit num(double r): x(cos(r)), y(sin(r)) {}\n    };\n    inline num operator+(num a, num b) { return {a.x + b.x, a.y + b.y}; }\n    inline num operator-(num a, num b) { return {a.x - b.x, a.y - b.y}; }\n    inline num operator*(num a, num b) { return {a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x}; }\n    inline num conj(num a) {return {a.x, -a.y}; }\n    num root[maxN];\n    int rev[maxN];\n    bool is_root_prepared = false;\n\n    inline void prepare_root(){\n        if(is_root_prepared) return;\n        is_root_prepared = true;\n        root[1] = num(1, 0);\n        for (int i = 1; i < max_base; ++i) {\n            num x(2*PI / (1LL << (i+1)));\n            for (ll j = (1LL << (i-1)); j < (1LL << (i)); ++j) {\n                root[2*j] = root[j];\n                root[2*j+1] = root[j]*x;\n            }\n        }\n    }\n\n    int base=1, N=2;\n    int lastN = -1;\n\n    inline void prepare_rev(){\n        if(lastN == N) return;\n        lastN = N;\n        for (int i = 0; i < N; ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (base - 1));\n    }\n\n    inline void fft(num *a, num *f){\n        for (int i = 0; i < N; ++i) f[i] = a[rev[i]];\n        for (int k = 1; k < N; k <<= 1) {\n            for (int i = 0; i < N; i += 2*k) {\n                for (int j = 0; j < k; ++j) {\n                    num z = f[i+j+k]* root[j+k];\n                    f[i+j+k] = f[i+j] - z;\n                    f[i+j] = f[i+j] + z;\n                }\n            }\n        }\n    }\n    num a[maxN], b[maxN], f[maxN], g[maxN];\n    ll A[maxN], B[maxN], C[maxN];\n\n    inline void multi_mod(int m){\n        for (int i = 0; i < N; ++i) {\n            ll x = A[i] % m;\n            a[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        for (int i = 0; i < N; ++i) {\n            ll x = B[i] % m;\n            b[i] = num(x & ((1LL << 15)-1), x >> 15);\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            int j = (N-i) &(N-1);\n            num a1 = (f[i] + conj(f[j])) * num(0.5, 0);\n            num a2 = (f[i] - conj(f[j])) * num(0, -0.5);\n            num b1 = (g[i] + conj(g[j])) * num(0.5/N, 0);\n            num b2 = (g[i] - conj(g[j])) * num(0, -0.5/N);\n            a[j] = a1*b1 + a2*b2 * num(0, 1);\n            b[j] = a1*b2 + a2*b1;\n        }\n        fft(a, f);\n        fft(b, g);\n        for (int i = 0; i < N; ++i) {\n            ll aa = f[i].x + 0.5;\n            ll bb = g[i].x + 0.5;\n            ll cc = f[i].y + 0.5;\n            C[i] = (aa + bb % m * (1LL << 15) + cc% m *(1LL << 30)) % m;\n        }\n    }\n\n    inline void prepare_AB(int n1, int n2){\n        if(N > n1+n2){\n            base = 1;\n            N = 2;\n        }\n        while(N < n1+n2) base++, N <<= 1;\n        for (int i = n1; i < N; ++i) A[i] = 0;\n        for (int i = n2; i < N; ++i) B[i] = 0;\n        prepare_root();\n        prepare_rev();\n    }\n\n    inline void multi_mod(int n1, int n2, int m){\n        prepare_AB(n1, n2);\n        multi_mod(m);\n    }\n}\ninline poly mul(poly A, poly B,int M){\n    while(!A.empty()&&!A.back())A.pop_back();\n    while(!B.empty()&&!B.back())B.pop_back();\n    poly C(A.size() + B.size()-1);\n    for (size_t i = 0; i < A.size(); ++i) FFT::A[i] = A[i];\n    for (size_t i = 0; i < B.size(); ++i) FFT::B[i] = B[i];\n    FFT::multi_mod(A.size(), B.size(), M);\n    for (size_t i = 0; i < C.size(); ++i) C[i] = FFT::C[i];\n    while(!C.empty()&&!C.back())C.pop_back();\n    return C;\n}\n\n\ninline pair<poly,poly> divmod(poly p, poly q, ll M) {\n    if (p.size() < q.size()) return { {}, p };\n    if (q.size()==1){\n      for(ll x:p)x=div(x,q[0],M);\n      return {p,{}};\n    }\n    reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    poly t = {div(1, q[0], M)};\n    if (t[0] < 0) return { {}, {} }; // infeasible\n    for (size_t k = 1; k <= 2*(p.size()-q.size()+1); k *= 2) {\n        poly qq=q;\n        if(k+1<q.size())qq.resize(k+1);\n        while (!qq.empty() && !qq.back()) qq.pop_back();\n        poly s = mul(mul(t, t, M), qq, M);\n        t.resize(k);\n        for (size_t i = 0; i < k; ++i)\n            t[i] = sub(2*t[i], s[i], M);\n    }\n    t.resize(p.size() - q.size() + 1);\n    poly pp=p;\n    pp.resize(p.size() - q.size() + 1);\n    while (!pp.empty() && !pp.back()) pp.pop_back();\n    t = mul(t, pp, M);\n    t.resize(p.size() - q.size() + 1);\n    reverse(t.begin(),t.end()); reverse(p.begin(),p.end()); reverse(q.begin(),q.end());\n    while (!t.empty() && !t.back()) t.pop_back();\n    return {t, sub(p, mul(q, t, M), M) };\n}\npoly gcd(poly p, poly q, ll M) {\n    for (; !p.empty(); swap(p, q = divmod(q, p, M).second)){\n      while(!p.empty()&&!p.back())p.pop_back();\n      while(!q.empty()&&!q.back())q.pop_back();\n    }\n    while(!q.empty()&&!q.back())q.pop_back();\n    return q;\n}\n\n#include <ctime>\ndouble tick() {\n  static clock_t oldtick;\n  clock_t newtick = clock();\n  double diff = 1.0*(newtick - oldtick) / CLOCKS_PER_SEC;\n  oldtick = newtick;\n  return diff;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  //tick();\n  ll N;cin>>N;\n  string X;cin>>X;reverse(X.begin(),X.end());\n  string A;cin>>A;reverse(A.begin(),A.end());\n  poly g(A.length());\n  for(size_t i=0;i<A.length();i++){\n    g[i]=A[i]-'0';\n  }\n  //debug(g);\n  for(ll i=1;i<N;i++){\n    cin >> A;\n    reverse(A.begin(),A.end());\n    poly p(A.length());\n    for(size_t i=0;i<A.length();i++){\n      p[i]=A[i]-'0';\n    }\n    g=gcd(p,g,2);\n  }\n  //debug(g);\n  ll ans=0;\n  size_t d=g.size();\n  //debug(d);\n  poly q(X.length(),0);\n  ll pw=1;\n  for(size_t i=d-1;i<X.length();i++){\n    q[i]=X[i]-'0';\n    if(X[i]>'0')ans = (ans+pw)%MOD;\n    pw = pw*2%MOD;\n  }\n  //debug(q);\n  poly r=divmod(q,g,2).second;\n  //debug(r);\n  r.resize(d-1);\n  bool isok=true;\n  for(int i=d-2;i>=0;i--){\n    if(r[i]==X[i]-'0')continue;\n    isok = r[i]<X[i]-'0';\n    break;\n  }\n  ans = (ans+isok)%MOD;\n  cout<<ans<<endl;\n  //debug(tick());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n \ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\n\n\n\ninline long long mod(long long a, long long m) {\n\treturn (a % m + m) % m;\n}\n\nlong long pow(long long a, long long n, long long m) {\n\tif (n == 0) return 1 % m;\n\tlong long t = pow(a, n / 2, m);\n\tt = mod(t * t, m);\n\tif (n & 1) t = mod(t * a, m);\n\treturn t;\n}\n\nlong long inv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn mod(u, m);\n}\n\nstruct ModPolynomial : vector<long long> {\n\tlong long MOD = 2;\n\tModPolynomial() : vector<long long>(1, 0) { }\n\tModPolynomial(long long num) : vector<long long>(1, num) { }\n\tModPolynomial(int size, long long num) : vector<long long>(size, num) { }\n\tModPolynomial(vector<long long> vec) { (*this) = vec; }\n\n\tModPolynomial& normalize() {\n\t\tfor (int i = 0; i < (*this).size(); ++i) (*this)[i] = mod((*this)[i], MOD);\n\t\twhile ((*this).size() > 1 && (*this).back() == 0) (*this).pop_back();\n\t\treturn (*this);\n\t}\n\n\tinline ModPolynomial operator - () {\n\t\tfor (int i = 0; i < (*this).size(); ++i) (*this)[i] = (*this)[i] * (-1);\n\t\treturn (*this).normalize();\n\t}\n\tinline const ModPolynomial& operator += (const ModPolynomial &x);\n\tinline const ModPolynomial& operator -= (const ModPolynomial &x);\n\tinline const ModPolynomial& operator *= (long long x);\n\tinline const ModPolynomial& operator *= (const ModPolynomial &x);\n\tinline const ModPolynomial& operator /= (long long x);\n\tinline const ModPolynomial& operator /= (const ModPolynomial &x);\n\tinline const ModPolynomial& operator %= (long long x);\n\tinline const ModPolynomial& operator %= (const ModPolynomial &x);\n};\n\ninline bool operator > (ModPolynomial x, ModPolynomial y) { return x.size() > y.size(); }\ninline bool operator < (ModPolynomial x, ModPolynomial y) { return y > x; }\ninline bool operator <= (ModPolynomial x, ModPolynomial y) { return !(y < x); }\ninline bool operator >= (ModPolynomial x, ModPolynomial y) { return !(x < y); }\ninline bool operator != (ModPolynomial x, ModPolynomial y) { return x < y || y < x; }\ninline bool operator == (ModPolynomial x, ModPolynomial y) { return !(x < y) && !(y < x); }\n\nostream &operator << (ostream &os, ModPolynomial x) {\n\tfor (int i = (int)x.size() - 1; i >= 0; --i) {\n\t\tif (i != (int)x.size() - 1) os << abs(x[i]); else os << x[i];\n\t\tif (i != 0) {\n\t\t\tos << \"x\"; if (i != 1) os << \"^\" << i; os << \" \";\n\t\t\tif (x[i - 1] < 0) os << \"- \"; else os << \"+ \";\n\t\t}\n\t}\n\treturn os;\n}\n\ninline ModPolynomial operator + (ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\twhile (x.size() > y.size()) y.push_back(0);\n\twhile (y.size() > x.size()) x.push_back(0);\n\tModPolynomial z((int)x.size(), 0);\n\tfor (int i = 0; i < (int)x.size(); ++i) z[i] = x[i] + y[i];\n\treturn z.normalize();\n}\ninline ModPolynomial operator - (ModPolynomial x, ModPolynomial y) {\n\ty = -y;\n\treturn x + y;\n}\ninline ModPolynomial operator * (ModPolynomial x, long long a) {\n\tx.normalize();\n\tModPolynomial z((int)x.size(), 0);\n\tfor (int i = 0; i < (int)x.size(); ++i) z[i] = mod(x[i] * a, x.MOD);\n\treturn z.normalize();\n}\ninline ModPolynomial operator * (ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\tModPolynomial z((int)x.size() + (int)y.size() - 1, 0);\n\tfor (int i = 0; i < (int)x.size(); ++i) for (int j = 0; j < (int)y.size(); ++j) z[i + j] = mod(z[i + j] + x[i] * y[j], z.MOD);\n\treturn z.normalize();\n}\npair<ModPolynomial, long long> divmod(ModPolynomial x, long long a) {\n\tx.normalize();\n\tfor (int i = (int)x.size() - 1; i >= 0; --i) x[i] = mod(x[i] * inv(a, x.MOD), x.MOD);\n\treturn pair<ModPolynomial, long long>(x, 0);\n}\nModPolynomial operator / (ModPolynomial x, long long a) {\n\tx.normalize();\n\treturn divmod(x, a).first;\n}\nlong long operator % (ModPolynomial x, long long a) {\n\tx.normalize();\n\treturn divmod(x, a).second;\n}\npair<ModPolynomial, ModPolynomial> divmod(ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\tif (x.size() < y.size()) return make_pair(0, x);\n\tif (y.size() == 1) return divmod(x, y.back());\n\tModPolynomial q((int)x.size() - (int)y.size() + 1, 0);\n\tfor (int i = (int)x.size() - 1; i >= (int)y.size() - 1; --i) {\n\t\tlong long div = mod(x[i] * inv(y.back(), x.MOD), x.MOD);\n\t\tq[i - (int)y.size() + 1] = div;\n\t\tfor (int j = 0; j < (int)y.size(); ++j) x[i + j - (int)y.size() + 1] = mod(x[i + j - (int)y.size() + 1] - y[j] * div, x.MOD);\n\t}\n\treturn make_pair(q, x.normalize());\n}\nModPolynomial operator / (ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\treturn divmod(x, y).first;\n}\nModPolynomial operator % (ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\treturn divmod(x, y).second;\n}\nModPolynomial pow(ModPolynomial a, long long n) {\n\ta.normalize();\n\tModPolynomial res(1, 1);\n\twhile (n > 0) { if (n & 1) { res = res * a; } a = a * a; n >>= 1; }\n\treturn res;\n}\nModPolynomial pow(ModPolynomial a, long long n, ModPolynomial PMOD) {\n\ta.normalize(); PMOD.normalize();\n\tModPolynomial res(1, 1);\n\twhile (n > 0) { if (n & 1) { res = (res * a) % PMOD; } a = (a * a) % PMOD; n >>= 1; }\n\treturn res;\n}\nModPolynomial gcd(ModPolynomial x, ModPolynomial y) {\n\tx.normalize(); y.normalize();\n\tif (y.size() == 1 && y.back() == 0) return x;\n\telse return gcd(y, x%y);\n}\ninline const ModPolynomial& ModPolynomial::operator += (const ModPolynomial &x) { *this = *this + x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator -= (const ModPolynomial &x) { *this = *this - x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator *= (long long x) { *this = *this * x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator *= (const ModPolynomial &x) { *this = *this * x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator /= (long long x) { *this = *this / x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator /= (const ModPolynomial &x) { *this = *this / x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator %= (long long x) { *this = *this % x; return *this; }\ninline const ModPolynomial& ModPolynomial::operator %= (const ModPolynomial &x) { *this = *this % x; return *this; }\nModPolynomial generateX() { ModPolynomial X(2, 0); X[1] = 1; return X; }\nModPolynomial EX = generateX();\n\n\n\nstruct Fp {\n\tint MOD = 998244353;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator > (Fp x, Fp y) { return x.val > y.val; }\ninline bool operator < (Fp x, Fp y) { return y > x; }\ninline bool operator <= (Fp x, Fp y) { return !(y < x); }\ninline bool operator >= (Fp x, Fp y) { return !(x < y); }\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n\n\n\n\n\nint N;\nModPolynomial X;\nModPolynomial A[10];\n\n\nint main() {\n\twhile (cin >> N) {\n\t\tstring str;\n\t\tcin >> str;\n\t\treverse(str.begin(), str.end());\n\t\tX.resize(str.size(), 0);\n\t\tfor (int i = 0; i < str.size(); ++i) X[i] = (long long)(str[i] - '0');\n\t\t//COUT(X);\n\n\t\tModPolynomial g;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> str;\n\t\t\treverse(str.begin(), str.end());\n\t\t\tA[i].resize(str.size(), 0);\n\t\t\tfor (int j = 0; j < str.size(); ++j) A[i][j] = (long long)(str[j] - '0');\n\t\t\t//COUT(A[i]);\n\t\t}\n\n\t\tg = A[0];\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tg = gcd(g, A[i]);\n\t\t}\n\n\n\t\tFp res = 0;\n\t\tint d = (int)g.size() - 1;\n\n\t\tModPolynomial EEX = pow(EX, d);\n\t\tModPolynomial q = X / EEX;\n\t\tModPolynomial r = X % EEX;\n\n\t\tfor (int i = (int)q.size() - 1; i >= 0; --i) {\n\t\t\tres *= 2;\n\t\t\tif (q[i] == 1) res += 1;\n\t\t}\n\n\t\tModPolynomial DX = (X - X%g);\n\t\t\n\n\t\tbool ok = true;\n\t\tfor (int i = (int)X.size() - 1; i >= 0; --i) {\n\t\t\tif (DX[i] < X[i]) break;\n\t\t\telse if (DX[i] == X[i]) continue;\n\t\t\tif (DX[i] > X[i]) ok = false;\n\t\t}\n\t\tif (ok) res += 1;\n\n\n\t\t/*\n\t\tCOUT(g);\n\t\tCOUT(d);\n\t\tCOUT(X);\n\t\tCOUT(EEX);\n\t\tCOUT(q);\n\t\tCOUT(r);\n\t\tCOUT(DX);\n\t\tCOUT(DX % g);\n\t\tCOUT(ok);\n\t\t*/\n\n\t\tcout << res << endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n\t#define _GLIBCXX_DEBUG\n#else\n\t#define NDEBUG\n#endif\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { cout << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n\ntemplate<long long MOD>\nclass ModInt {\npublic:\n\tconst static long long mod = MOD;\n\tlong long x;\n\t\n\tModInt() {\n\t\tx = 0;\n\t}\n\n\tModInt(long long x) {\n\t\tx %= mod;\n\t\tthis->x = x < 0 ? x+mod : x;\n\t}\n\n\tint get() const {\n\t\treturn (int)x;\n\t}\n\n\tModInt &operator+=(ModInt that) {\n\t\tif((x += that.get()) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator-=(ModInt that) {\n\t\tif((x += mod-that.get()) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator*=(ModInt that) {\n\t\tx = x*that.get()%mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= that.inverse();\n\t}\n\n\tModInt operator+(ModInt that) const {\n\t\treturn ModInt(*this) += that;\n\t}\n\n\tModInt operator-(ModInt that) const {\n\t\treturn ModInt(*this) -= that;\n\t}\n\n\tModInt operator*(ModInt that) const {\n\t\treturn ModInt(*this) *= that;\n\t}\n\n\tModInt operator/(ModInt that) const {\n\t\treturn ModInt(*this) /= that;\n\t}\n\n\tModInt inverse() const {\n\t\tusing std::swap;\n\t\tlong long a = x, b = mod, u = 1, v = 0;\n\t\twhile(b) {\n\t\t\tlong long t = a/b;\n\t\t\ta -= t*b; swap(a,b);\n\t\t\tu -= t*v; swap(u,v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\n\tModInt pow(int n) const{\n\t\tModInt b = *this;\n\t\tModInt res = 1;\n\t\twhile(n != 0) {\n\t\t\tif(n&1){\n\t\t\t\tres *= b;\n\t\t\t}\n\t\t\tb *= b;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tbool operator==(ModInt that) const { return x == that.get(); }\n\tbool operator!=(ModInt that) const { return x != that.get(); }\n\tModInt operator-() const { return x == 0 ? 0 : ModInt(mod-x); }\n};\n\ntemplate<long long MOD> ostream& operator<< (ostream& os, const ModInt<MOD>& m) { os << m.get(); return os; }\ntemplate<long long MOD> istream& operator>> (istream& is, ModInt<MOD>& m){ long long n; is >> n; m = n; return is;}\ntypedef ModInt<1000000007> mint;\n\n\n\n\n\n// \n// 0\ntemplate<long long MOD>\nclass RowPoly {\nprivate:\n\tusing mint = ModInt<MOD>;\n\tstatic const int mod = MOD;\n\ttypedef typename vector<mint>::iterator iterator;\n\ttypedef typename vector<mint>::const_iterator const_iterator;\n\tvector<mint> v;\n\tmint root;\n\npublic:\n\tRowPoly(int n, mint root = 5){\n\t\tthis->root = root;\n\t\tv = vector<mint>(n, mint(0));\n\t}\n\n\ttemplate<typename T>\n\tRowPoly(const vector<T>& x, const mint& root){\n\t\tthis->root = root;\n\t\tv.resize(x.size());\n\t\tfor(int i = 0; i < (int)x.size(); ++i) {\n\t\t\tv[i] = x[i].get();\n\t\t}\n\t}\n\n\n\titerator begin(){return v.begin();}\n\tconst_iterator begin() const {return v.begin();}\n\titerator end(){return v.end();}\n\tconst_iterator end() const {return v.end();}\n\tvoid push_back(mint x) {v.push_back(x);}\n\n\tconst vector<mint>& look_coefv() const {\n\t\treturn v;\n\t}\n\n\tint size() const {\n\t\treturn v.size();\n\t}\n\n\tmint& operator[](int i){\n\t\treturn v[i];\n\t}\n\n\tconst mint& operator[](int i) const {\n\t\treturn v[i];\n\t}\n\n\tunsigned int bit_reverse(unsigned int x) const {\n\t\tx = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1));\n\t\tx = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2));\n\t\tx = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4));\n\t\tx = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8));\n\t\treturn((x >> 16) | (x << 16));\n\t}\n\n\tvoid set_root(mint x) {\n\t\troot = x;\n\t}\n\n\tmint get_root() {\n\t\treturn root;\n\t}\n\n\tRowPoly dft(int n) const {\n\t\tRowPoly p(n, root);\n\t\tfor(int i = 0; i < (int)v.size(); ++i) {\n\t\t\tp[i] = v[i];\n\t\t}\n\t\tfor(int i = (int)v.size(); i < n; ++i) {\n\t\t\tp[i] = 0;\n\t\t}\n\t\tvector<unsigned int> iv(n);\n\t\tfor(unsigned int i = 0; (int)i < n; ++i) {\n\t\t\tiv[i] = bit_reverse(i);\n\t\t}\n\t\tsort(iv.begin(), iv.end());\n\t\tRowPoly res(n, root);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tres[i] = p[bit_reverse(iv[i])];\n\t\t}\n\t\t\n\t\tfor(int l = 2; l <= n; l <<= 1) {\n\t\t\tmint theta = mint(root).pow((mod-1)/l);\n\t\t\tfor(int s = 0; s < n; s += l) {\n\t\t\t\tmint t = 1;\n\t\t\t\tfor(int i = 0; i < l/2; i++) {\n\t\t\t\t\tmint t1 = res[s+i]+t*res[s+l/2+i];\n\t\t\t\t\tmint t2 = res[s+i]-t*res[s+l/2+i];\n\t\t\t\t\tres[s+i] = t1;\n\t\t\t\t\tres[s+l/2+i] = t2;\n\t\t\t\t\tt *= theta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tRowPoly inverse_dft() const {\n\t\tRowPoly res(size(), root.inverse());\n\t\tfor(int i = 0; i < (int)res.size(); ++i) {\n\t\t\tres[i] = (*this)[i];\n\t\t}\n\t\tint n= (int)v.size();\n\t\tres = res.dft(n);\n\t\tfor(int i = 0; i < (int)res.size(); ++i) {\n\t\t\tres[i] /= res.size();\n\t\t}\n\t\treturn res;\n\t}\n\n\tmint calc(mint c) const {\n\t\tmint res = 0;\n\t\tmint x = 1;\n\t\tfor(int i = 0; i < (int)v.size(); ++i) {\n\t\t\tres += v[i]*x;\n\t\t\tx *= c;\n\t\t}\n\t\treturn res;\n\t}\n\n\tRowPoly operator*(const RowPoly& y) const {\n\t\tint m = y.size()+size();\n\t\tint n = 1;\n\t\twhile(n < m) {\n\t\t\tn <<= 1;\n\t\t}\n\t\tauto gg = dft(n);\n\t\tauto hh = y.dft(n);\n\t\tRowPoly res(n, root);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tres[i] = gg[i]*hh[i];\n\t\t}\n\t\tres = res.inverse_dft();\n\t\tres.set_root(root);\n\t\treturn res;\n\t}\n\n\tRowPoly operator*(const mint& x) const {\n\t\tauto res = *this;\n\t\tfor(auto&& e : res) {\n\t\t\te *= x;\n\t\t}\n\t\treturn res;\n\t}\n\n\tRowPoly operator+(const RowPoly& y) const {\n\t\tint n = max(size(), y.size());\n\t\tRowPoly p(n, root);\n\t\tfor(int i = 0; i < size(); ++i) {\n\t\t\tp[i] += v[i];\n\t\t}\n\t\tfor(int i = 0; i < y.size(); ++i) {\n\t\t\tp[i] += y[i];\n\t\t}\n\t\treturn p;\n\t}\n\n\tRowPoly operator-() const {\n\t\tauto res = *this;\n\t\tfor(auto&& e : res) {\n\t\t\te = -e;\n\t\t}\n\t\treturn res;\n\t}\n\n\tRowPoly operator-(const RowPoly& y) const {\n\t\tint n = max(size(), y.size());\n\t\tRowPoly p(n, root);\n\t\tfor(int i = 0; i < size(); ++i) {\n\t\t\tp[i] += v[i];\n\t\t}\n\t\tfor(int i = 0; i < y.size(); ++i) {\n\t\t\tp[i] -= y[i];\n\t\t}\n\t\treturn p;\n\t}\n\n\tvoid resize(size_t x) {\n\t\tv.resize(x);\n\t}\n\n\tRowPoly get_inv_p2(int k) {\n\t\tassert(__builtin_popcount(k) == 1);\n\t\tRowPoly res(1, root);\n\t\tres[0] = mint(1)/(*this)[0];\n\t\tint power = 1;\n\t\twhile(k != power) {\n\t\t\tres = res*mint(2)-res*res*(*this);\n\t\t\tpower <<= 1;\n\t\t\tres.resize(power);\n\t\t}\n\t\treturn res;\n\t}\n\n\tRowPoly operator/(const RowPoly& that) const {\n\t\tif(size() < that.size()) {\n\t\t\treturn RowPoly(1, root);\n\t\t}\n\t\tauto x = *this, y = that;\n\t\treverse(x.begin(), x.end());\n\t\treverse(y.begin(), y.end());\n\t\tint n = x.size();\n\t\tint m = y.size();\n\t\tint k = 1;\n\t\twhile(k < n-m+1) k <<= 1;\n\t\tRowPoly res = y.get_inv_p2(k);\n\t\tres = res*x;\n\t\tres.resize(n-m+1);\n\t\treverse(res.begin(), res.end());\n\t\treturn res;\n\t}\n\n};\n\ntemplate<long long MOD>\nclass Polynomial {\nprivate:\n\tusing mint = ModInt<MOD>;\n\tstatic const int mod = MOD;\n\ttypedef typename vector<mint>::iterator iterator;\n\ttypedef typename vector<mint>::const_iterator const_iterator;\n\t\n\tstatic const long long mod0 = 167772161;\n\tstatic const long long mod1 = 469762049;\n\tstatic const long long mod2 = 1224736769;\n\tusing rpoly0 = RowPoly<mod0>;\n\tusing rpoly1 = RowPoly<mod1>;\n\tusing rpoly2 = RowPoly<mod2>;\n\tusing mint0 = ModInt<mod0>;\n\tusing mint1 = ModInt<mod1>;\n\tusing mint2 = ModInt<mod2>;\n\tstatic const int root = 3;\n\n\tpair<long long, long long> extgcd(long long a,long long b) {\n\t\tif(b==1){\n\t\t\treturn pair<long long, long long>(0,1);\n\t\t}\n\t\tpair<long long, long long> t=extgcd(b,a%b);\n\t\treturn pair<long long, long long>(t.second,t.first-a/b*t.second);\n\t}\n\n\t//mod\n\tlong long inverse(long long a,long long modl) {\n\t\treturn (extgcd(modl,a).second+modl)%modl;\n\t}\n\npublic:\n\tvector<mint> v;\n\titerator begin(){return v.begin();}\n\tconst_iterator begin() const {return v.begin();}\n\titerator end(){return v.end();}\n\tconst_iterator end() const {return v.end();}\n\tvoid push_back(mint x) {v.push_back(x);}\n\n\tPolynomial(int deg) {\n\t\tv = vector<mint>(deg, 0);\n\t}\n\n\tint size() const {\n\t\treturn v.size();\n\t}\n\n\tmint calc(mint x) {\n\t\tmint res = 0;\n\t\tmint power = 1;\n\t\tfor(int i = 0; i < (int)v.size(); ++i) {\n\t\t\tres += v[i]*x;\n\t\t\t\n\t\t}\n\t\treturn res;\n\t}\n\tvoid resize(size_t x) {\n\t\tv.resize(x);\n\t}\n\n\tmint& operator[](int i) {\n\t\treturn v[i];\n\t}\n\n\tconst mint& operator[](int i) const {\n\t\treturn v[i];\n\t}\n\n\tconst vector<mint>& look_coefv() const {\n\t\treturn v;\n\t}\n\n\tPolynomial operator-() const {\n\t\tauto res = *this;\n\t\tfor(auto&& e : res) {\n\t\t\te = -e;\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolynomial operator-(const Polynomial& y) const {\n\t\tint n = max(size(), y.size());\n\t\tPolynomial p(n);\n\t\tfor(int i = 0; i < size(); ++i) {\n\t\t\tp[i] += v[i];\n\t\t}\n\t\tfor(int i = 0; i < y.size(); ++i) {\n\t\t\tp[i] -= y[i];\n\t\t}\n\t\treturn p;\n\t}\n\n\tPolynomial operator*(const Polynomial& that) const {\n\t\trpoly0 p1(v.size(), root), q1(that.size(), root);\n\t\trpoly1 p2(v.size(), root), q2(that.size(), root);\n\t\trpoly2 p3(v.size(), root), q3(that.size(), root);\n\t\tfor(int i = 0; i < (int)v.size(); ++i) {\n\t\t\tp1[i] = v[i].get();\n\t\t\tp2[i] = v[i].get();\n\t\t\tp3[i] = v[i].get();\n\t\t}\n\n\t\tfor(int i = 0; i < (int)that.size(); ++i) {\n\t\t\tq1[i] = that.look_coefv()[i].get();\n\t\t\tq2[i] = that.look_coefv()[i].get();\n\t\t\tq3[i] = that.look_coefv()[i].get();\n\t\t}\n\n\t\trpoly0 ans0 = p1*q1;\n\t\trpoly1 ans1 = p2*q2;\n\t\trpoly2 ans2 = p3*q3;\n\t\t\n\t\tPolynomial res(ans1.size());\n\t\tfor(int i = 0; i < res.size(); ++i) {\n\t\t\tarray<long long, 3> v;\n\t\t\tv[0] = ans0[i].get();\n\t\t\tv[1] = ((ans1[i]-v[0])/mint1(mod0)).get();\n\t\t\tv[2] = ((ans2[i]-v[0]-v[1]*mod0)/mint2(mod0*mod1)).get();\n\t\t\t// dpite(ALL(v));\n\t\t\tres[i] = mint(v[0])+v[1]*mod0+mint(v[2]*mod0)*mod1;\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tPolynomial operator*(const mint& x) const {\n\t\tauto res = *this;\n\t\tfor(auto&& e : res) {\n\t\t\te *= x;\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolynomial get_inv_p2(int k) const {\n\t\tassert(__builtin_popcount(k) == 1);\n\t\tPolynomial res(1);\n\t\tres[0] = mint(1)/(*this)[0];\n\t\tint power = 1;\n\t\twhile(k != power) {\n\t\t\tres = res*mint(2)-res*res*(*this);\n\t\t\tpower <<= 1;\n\t\t\tres.resize(power);\n\t\t}\n\t\treturn res;\n\t}\n\n\tPolynomial operator/(const Polynomial& that) const {\n\t\tif(size() < that.size()) {\n\t\t\treturn Polynomial(1);\n\t\t}\n\t\tauto x = *this, y = that;\n\t\treverse(x.begin(), x.end());\n\t\treverse(y.begin(), y.end());\n\t\tint n = x.size();\n\t\tint m = y.size();\n\t\tint k = 1;\n\t\twhile(k < n-m+1) k <<= 1;\n\t\tPolynomial res = y.get_inv_p2(k);\n\t\tres = res*x;\n\t\tres.resize(n-m+1);\n\t\treverse(res.begin(), res.end());\n\t\treturn res;\n\t}\n\n\tPolynomial operator%(const Polynomial& that) const {\n\t\tauto res = *this-that*(*this/that);\n\t\tres.resize(that.size()-1);\n\t\twhile(!res.v.empty() && res.v.back() == 0) res.v.pop_back();\n\t\treturn res;\n\t}\n\n};\n\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\ntemplate <typename T>\nT gcd(T x, T y){\n\tDEBUG(x.size());\n\tdpite(ALL(x)); dpite(ALL(y)); DEBUG(endl);\n\treturn y.size()==0 ? x : gcd(y, x%y);\n}\n\nint main()\n{\n\tusing poly = Polynomial<2>;\n\tios_init();\n\tint n;\n\tconst int len = 4040;\n\tstring x;\n\twhile(cin >> n >> x) {\n\t\tvector<string> a(n);\n\t\tREP(i,n){\n\t\t\tcin >> a[i];\n\t\t\treverse(ALL(a[i]));\n\t\t}\n\t\tpoly g(SZ(a[0]));\n\t\tREP(j,SZ(a[0])) g[j] = a[0][j]-'0';\n\t\tFOR(i,1,n){\n\t\t\tpoly t(SZ(a[i]));\n\t\t\tREP(j,SZ(a[i])) t[j] = a[i][j]-'0';\n\t\t\twhile(!t.v.empty() && t.v.back() == 0) t.v.pop_back();\n\t\t\tg = gcd(g, t);\n\t\t}\n\t\tbitset<len> xs = 0;\n\t\treverse(ALL(x));\n\t\tREP(i,SZ(x)) xs[i] = x[i] == '1';\n\t\tbitset<len> gs = 0;\n\t\tREP(i,SZ(g)) gs[i] = g[i] == 1;\n\t\tbitset<len> ts = 0;\n\t\tint gl = SZ(g);\n\t\tusing mint = ModInt<998244353>;\n\t\tmint ans = 0;\n\t\tRFOR(i, gl-1, SZ(xs)) {\n\t\t\tDEBUG(i);\n\t\t\tif(xs[i]) {\n\t\t\t\tans += mint(2).pow(i-(gl-1));\n\t\t\t\tDEBUG(ans);\n\t\t\t}\n\t\t\tif(ts[i] != xs[i]) {\n\t\t\t\tts ^= gs<<(i-(gl-1));\n\t\t\t}\n\t\t}\n\t\tREP(i,SZ(xs)) {\n\t\t\tif(xs[i] > ts[i]) {\n\t\t\t\tDEBUG(1);\n\t\t\t\tans += 1;\n\t\t\t\tbreak;\n\t\t\t} else if(xs[i] < ts[i]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ts == xs) ans += 1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\nvector<bool> input(){\n\tstring s;\n\tcin>>s;\n\tint N = s.size();\n\tvector<bool> x(N);\n\trep(i,N) x[i] = s[i]=='1';\n\treturn x;\n}\nvoid normalize(vector<bool>& a){\n\tvector<bool> b;\n\tint N = a.size();\n\tbool yet = 1;\n\trep(i,N){\n\t\tif(a[i]){\n\t\t\tyet = 0;\n\t\t}\n\t\tif(!yet) b.pb(a[i]);\n\t}\n\ta = b;\n}\nint cnt;\nvector<bool> gcd(vector<bool> a,vector<bool> b){\n\tcnt++;\n\tif(cnt>=20) exit(0);\n\tnormalize(a);\n\tnormalize(b);\n\tint N = a.size(), M = b.size();\n\tif(N<M) swap(a,b),swap(N,M);\n\n\tif(M==0) return a;\n\n\trep(i,M) a[i] = a[i] ^ b[i];\n\treturn gcd(a,b);\n}\n\nint N;\nint main(){\n\tcin>>N;\n\tvector<bool> X = input();\n\tvector<bool> g;\n\trep(i,N){\n\t\tvector<bool> f;\n\t\tf = input();\n\t\tg = gcd(g,f);\n\t}\n\tvector<mint> p2(5000);\n\tp2[0] = 1;\n\trep1(i,4999) p2[i] = p2[i-1]*2;\n\n\tmint ans = 0;\n\tvector<bool> oX = X;\n\tint a = X.size();\n\tint b = g.size();\n\trep(i,a-b+1){\n\t\tif(X[i]){\n\t\t\trep(j,b) X[i+j] = X[i+j] ^ g[j];\n\t\t}\n\t\tif(oX[i]){\n\t\t\tans += p2[a-(i+b)];\n\t\t}\n\t}\n\tcout<<ans+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 998244353;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<u32 M = 1000000007>\nstruct modint{\n    u32 val;\n    modint(): val(0){}\n    template<typename T>\n    modint(T t){t %= (T)M; if(t < 0) t += (T)M; val = t;}\n\n    modint pow(ll k) const {\n        modint res(1), x(val);\n        while(k){\n            if(k&1) res *= x;\n            x *= x;\n            k >>= 1;\n        }\n        return res;\n    }\n    template<typename T>\n    modint& operator=(T t){t %= (T)M; if(t < 0) t += (T)M; val = t; return *this;}\n    modint inv() const {return pow(M-2);}\n    modint& operator+=(modint a){val += a.val; if(val >= M) val -= M; return *this;}\n    modint& operator-=(modint a){if(val < a.val) val += M-a.val; else val -= a.val; return *this;}\n    modint& operator*=(modint a){val = (u64)val*a.val%M; return *this;}\n    modint& operator/=(modint a){return (*this) *= a.inv();}\n    modint operator+(modint a) const {return modint(val) +=a;}\n    modint operator-(modint a) const {return modint(val) -=a;}\n    modint operator*(modint a) const {return modint(val) *=a;}\n    modint operator/(modint a) const {return modint(val) /=a;}\n    modint operator-(){return modint(M-val);}\n    bool operator==(const modint a) const {return val == a.val;}\n    bool operator!=(const modint a) const {return val != a.val;}\n    bool operator<(const modint a) const {return val < a.val;}\n};\nusing mint = modint<MOD>;\n\nint main() {\n    using B = bitset<4000>;\n    auto f = [&](string &s) -> B {\n        B res;\n        for (int i = 0; i < s.size(); ++i) {\n            if(s[i] == '1') res.set(4000+i-(int)s.size());\n        }\n        return res;\n    };\n    int n; B X;\n    cin >> n;\n    vector<B> v(n);\n    {\n        string x;\n        cin >> x;\n        X = f(x);\n        for (int i = 0; i < n; ++i) cin >> x, v[i] = f(x);\n    }\n    for (int i = 1; i < n; ++i) {\n        int a = v[0]._Find_first(), b = v[i]._Find_first();\n\n        while(true){\n            if(a == 4000 || b == 4000) {\n                if(a == 4000) swap(v[0], v[i]);\n                break;\n            }\n            if(a > b){\n                v[i] ^= (v[0] >> (a-b));\n                b = v[i]._Find_first();\n            }else {\n                v[0] ^= (v[i] >> (b-a));\n                a = v[0]._Find_first();\n            }\n        }\n    }\n\n    int a = v[0]._Find_first(), b = X._Find_first();\n    B Y;\n    mint ans = 0;\n    for (int i = b; i <= a; ++i) {\n        if(X[i]) {\n            ans += mint(2).pow(a-i);\n        }\n        if(X[i] != Y[i]){\n            Y ^= (v[0] >> (a-i));\n        }\n    }\n    int ok = 1;\n    for (int i = 0; i < 4000; ++i) {\n        if(X[i] && !Y[i]) {\n            ok = 0;\n            break;\n        }\n        else if(!X[i] && Y[i]) break;\n    }\n    if(ok) ans += mint(1);\n    cout << ans.val << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=998244353;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing BS = bitset<4000>;\n\nint N;\nstring X;\nint pw2[4010];\nBS A[6];\nBS bases[4010];\n\nvoid Add(LL &t, LL v) {\n  t += v;\n  while (t >= MOD) t -= MOD;\n}\n\nBS MakeBitset(string &s) {\n  BS ret;\n  int idx = 3999;\n  rrep(i, s.size()) {\n    if (s[i] == '1') ret[idx] = 1;\n    else if (s[i] == '0') ret[idx] = 0;\n    else assert(0);\n    idx--;\n  }\n  return ret;\n}\n\nint RegBase(BS &v) {\n  while (1) {\n    int idx = v._Find_first();\n    if (idx == v.size()) {\n      assert(v.count() == 0);\n      return -1;\n    }\n\n    if (bases[idx].count() == 0) {\n      bases[idx] = v;\n      return idx;\n    }\n\n    v ^= bases[idx];\n    assert(v._Find_first() > idx);\n  }\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  \n  cin >> N >> X;\n  rep(i, N) {\n    string s;\n    cin >> s;\n    A[i] = MakeBitset(s);\n  }\n\n  int idx = A[0]._Find_first();\n  BS v = A[0];\n  while (1) {\n    int res = RegBase(v);\n    assert(res == idx);\n    if (res == -1) break;\n    v = bases[res] >> 1;\n    if (idx == 0) break;\n    idx--;\n  }\n\n  reps(i, 1, N) {\n    v = A[i];\n    idx = A[i]._Find_first();\n    while (1) {\n      int res = RegBase(v);\n      if (res == -1) break;\n      v = bases[res] >> 1;\n    }\n  }\n\n  int m = 0;\n  pw2[0] = 1;\n  rep(i, 4000) {\n    if (bases[i].count()) m++;\n    if (i > 0) pw2[i] = pw2[i-1]*2 % MOD;\n  }\n\n  X = string(4000-X.size(), '0') + X;\n  assert(X.size() == 4000);\n\n  BS cur;\n  LL ans = 1;\n  rep(i, 4000) {\n    if (!bases[i].count()) {\n      if (cur[i] > X[i]-'0') {\n        //auto s = cur.to_string().substr(0, 20);\n        //reverse(all(s));\n        //cout << s << endl;\n        //cout << X.substr(3980) << endl;\n        Add(ans, MOD-1);\n        break;\n      } else if (cur[i] < X[i] - '0') {\n        Add(ans, pw2[m]);\n        Add(ans, MOD-1);\n        break;\n      }\n    }\n\n    if (X[i] == '1') {\n      if (m > 0) Add(ans, pw2[m-1]);\n      if (!cur[i]) cur ^= bases[i];\n    } else if (X[i] == '0') {\n      if (cur[i]) cur ^= bases[i];\n    }\n\n    --m;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_poizcy.hpp>\ntypedef long long  ll;\n#define pb                push_back\n#define mp                make_pair\n#define all(a)            (a).begin(), (a).end()\n#define mem(a,h)          memset(a, (h), sizeof(a))\n#define se second\n#define fi first\n#define por(a,b) (((a%MOD) * (b%MOD))%MOD)\n#define forg(i, b, e, c)    for (ll i = (ll)b; i < (ll)e; i+=c)\n#define forr(i, b, e)    for (ll i = b; i < e; i++)\n \n \nusing namespace std;\n//using namespace __gnu_pbds;\ntypedef double lldb;\ntypedef pair<ll, ll>  ii;\ntypedef pair<ll, ii>  iii;\ntypedef pair<double, double>  iidb;\n//typedef tree<ii,null_type,less<ii>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nconst ll INF = 1e9+7;\nconst double PI = acos(-1);\n#define initseg ll new_nodo=(pnodo*2),mid=(iz+der)/2;\n \n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define tam 600020\n#define offset 3000\n#define ptr nodo*\nconst ll MOD=998244353;\n\nusing namespace std;\nconst ll inf=1e15;\nconst ll cmplog=19;\nll pot(ll b,ll e)\n{\n\tll res=1;b%=MOD;\n\twhile(e){if (e&1)res*=b,res%=MOD;\te/=2;b*=b;b%=MOD;}\n\treturn res;\n}\nstruct basis\n{\n\tbitset<4001> base[4001];\n\tbool marca[4001],cero=0;\n\tbool llegar(bitset<4001> otro,int pos,int n)\n\t{\n\t\tfor(int i=n-1;i>=pos;i--)\n\t\t{\n\t\t\tif (otro[i])\n\t\t\t\totro^=base[i];\n\t\t\tif (otro[i])return 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tvoid add(bitset<4001> otro,int n)\n\t{\n\t\tn=4000;\n\t\tif (otro.count()==0)\n\t\t\tcero=1;\n\t\tforr(j,n,4000)\n\t\t\tif (otro[j])return;\n\n\t\tfor(int bit=n-1;bit>=0;bit--)\n\t\t{\n\t\t\tif (!otro[bit])continue;\n\t\t\tif (marca[bit]==1)\n\t\t\t\totro^=base[bit];\n\t\t\telse\n\t\t\t\t{marca[bit]=1;base[bit]=otro;break;}\n\t\t}\n\t\t\n\t}\n\tvoid hasta(bitset<4001> otro,int n)\n\t{\n\t\tint c=0;\n\t\tint vc[4000];\n\t\tforr(i,0,4001)\n\t\t\tc+=marca[i],vc[i]=c;\n\t\tll tot=0;\n\t\t\n\t\tfor(int bit=n-1;bit>=0;bit--)\n\t\t{\n\t\t\tif (!otro[bit])continue;\n\t\t\totro[bit]=0;\n\t\t\t/*forr(l,0,10)\n\t\t\t\tcout<<otro[l];\n\t\t\tcout<<endl;*/\n\t\t\t//cout<<llegar(otro,bit,n)<<' ';\n\t\t\tif (llegar(otro,bit,n))\n\t\t\t\ttot+=pot(2,vc[bit]-marca[bit]);\n\t\t\ttot%=MOD;\n\t\t\t//cout<<tot<<endl;\n\t\t\totro[bit]=1;\n\t\t}\n\t\t//cout<<llegar(otro,0,n)<<endl;\n\t\ttot+=llegar(otro,0,n);\n\t\tcout<<tot<<endl;\n\t}\n\n};\nint main()\n{\t\n\tios::sync_with_stdio(false);cin.tie(0);\n\tbitset<4001> alguno,hasta;\n\tint n;\n\tcin>>n;\n\tstring t1;\n\tcin>>t1;\n\tint m=t1.size();\n\n\treverse(all(t1));\n\tforr(i,0,t1.size())\n\t\thasta[i]=t1[i]-'0';\n\t\n\n\tbasis solve;memset(solve.marca,0,sizeof solve.marca);\n\tforr(j,0,n)\n\t{\n\t\tcin>>t1;\n\t\treverse(all(t1));\n\t\talguno.reset();\n\t\tforr(i,0,t1.size())\n\t\t\talguno[i]=t1[i]-'0';\n\t\twhile(!alguno[4000]){\n\t\t\tsolve.add(alguno,m);\n\t\t\talguno<<=1;\n\t\t}\n\t}\n\t\n\tsolve.hasta(hasta,m);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\ntypedef unsigned long long wolf;\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nchar in[4100];\nchar str[4100];\nint main(){\n\tint a;\n\tscanf(\"%d%s\",&a,in);\n\tint n=strlen(in);\n\treverse(in,in+n);\n \n\tbitset<4020> x;\n\tfor(int i=0;i<n;i++)if(in[i]=='1')x[i]=true;\n\tbitset<4020> y;\n\tint by,bz;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",str);\n\t\tint m=strlen(str);\n\t\tbitset<4020> z;\n\t\treverse(str,str+m);\n\t\tfor(int j=0;j<m;j++)if(str[j]=='1')z[j]=true;\n\t\t//printf(\"%s %s\\n\",str+1990,z.to_string().c_str()+1990);\n\t\tif(i==0){\n\t\t\ty=z;\n\t\t\tby=strlen(str);\n\t\t}else{\n\t\t\tbz=strlen(str);\n\t\t\twhile(bz){\n\t\t\t\tif(by>=bz){\n\t\t\t\t\ty^=(z<<(by-bz));\n\t\t\t\t\twhile(by>0&&y[by-1]==false){\n\t\t\t\t\t\tby--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(by<bz){\n\t\t\t\t\tswap(y,z);\n\t\t\t\t\tswap(by,bz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%s\\n\",y.to_string().c_str());\n\tlong long ret=0;\n\tfor(int i=0;i<=n-by;i++){\n\t\tret=ret*2%mod;\n\t\tif(in[n-1-i]=='1')ret=(ret+1)%mod;\n\t}\n\tbitset<4020> tmp;\n\tfor(int i=n-1;i>=by-1;i--){\n\t\tif(tmp[i]!=x[i])tmp^=(y<<(i-by+1));\n\t}\n\t//printf(\"%s\\n\",tmp.to_string().c_str());\n\tbool ok=true;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(tmp[i]!=x[i]){\n\t\t\tif(tmp[i]){ok=false;break;}\n\t\t\telse {break;}\n\t\t}\n\t}\n\tif(ok)ret=(ret+1)%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n//#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx_ori[4] = { -1,0, 1,0 }, dy_ori[4] = { 0,1,0,-1 };\nint dx[4] = {0, 0, 0, 0}, dy[4] = {0, 0, 0, 0};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int M = 4000;\n#define bit bitset<M>\n\nbool eq_less(bit a, bit b) {\n  bool is_big = false;\n  rrep (i, M) {\n    if (a[i] != b[i]) {\n      if (a[i]) is_big = true;\n      break;\n    }\n  }\n  return not is_big;\n}\n\nbit gcd(bit a, bit b) {\n  //DEBUG(make_pair(a, b));\n  if (eq_less(a, b)) swap(a, b);\n\n  int da = -1, db = -1;\n  rrep (i, M) {\n    if (da == -1 and a[i]) {\n      da = i;\n    }\n    if (db == -1 and b[i]) {\n      db = i;\n    }\n  }\n  //DEBUG(pii(da, db));\n  if (db == -1) {\n    return a;\n  }\n  assert(db <= da);\n  bit b2 = b << (da - db);\n  bit r = a ^ b2;\n  return gcd(b, r);\n}\n\nbitset<M> convert(string x) {\n  int n = x.size();\n  string pad(M - n, '0');\n  x = pad + x;\n  return bitset<M>(x);\n}\n\nsigned main() {\n  int n;\n  string _x;\n  cin >> n >> _x;\n  bitset<M> x = convert(_x);\n  \n  vector<bitset<M>> a;\n  rep (i, n) {\n    string _s;\n    cin >> _s;\n    a.push_back(convert(_s));\n  }\n\n  bit p = a[0];\n  rep1 (i, n - 1) {\n    p = gcd(p, a[i]);\n  }\n  //DEBUG(p);\n\n  int top;\n  rrep (i, M) {\n    if (p[i]) {\n      top = i;\n      break;\n    }\n  }\n\n  vl power(M + 1);\n  power[0] = 1;\n  rep (i, M) {\n    power[i + 1] = power[i] * 2 % MOD;\n  }\n  //DEBUG(top);\n  bit x2 = x >> (top + 1);\n  //DEBUG(x2);\n  ll ans = 0;\n  rep (i, M) {\n    if (x2[i]) (ans += power[i]) %= MOD;\n  }\n  ans = (ans - 1 + 1) * 2 % MOD;\n\n  bit now;\n  int op_num = M - top - 1;\n  rep (i, op_num) {\n    if (x[M - 1 -i] != now[top]) now = now ^ p;\n    now <<= 1;\n  }\n  \n  if (eq_less(now, x)) ans++;\n  now = now ^ p;\n  if (eq_less(now, x)) ans++;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lsk 998244353\nbitset<4005> c,d,GCD;\nint C[4005];\nint n;\nint F(bitset<4005> A){\n\tfor(int i=4000;i;--i)if(A[i])return i;return 0;\n}\nvoid gcd(){\n\twhile(1){\n\t\tif(F(c)>F(GCD))swap(c,GCD);\n\t\tint cc=F(c),GG=F(GCD);\n\t\tfor(int i=GG;i>=cc;--i){\n\t\t\tif(GCD[i])GCD^=(c<<(i-cc));\n\t\t}\n\t\tif(GCD.none()){swap(c,GCD);break;}\n\t}\n}\nint main(){\n\tC[0]=1;\n\tfor(int i=1;i<=4000;++i)C[i]=(C[i-1]<<1)%lsk;\n\tscanf(\"%d\",&n);\n\tcin>>d;cin>>GCD;\n\tfor(int i=2;i<=n;++i)cin>>c,gcd();\n\tint res=0,G=F(GCD);\n\tc.reset();\n\tfor(int i=4000;i>=G;--i){\n\t\tif(d[i])res=(res+C[i-G])%lsk;\n\t\tif(d[i]!=c[i])c^=GCD<<(i-G);\n\t}\n\tint F=0;\n\tfor(int i=G;~i;--i)if(d[i]>c[i])break;else if(d[i]<c[i])F=1;\n\tif(!F)res++;\n\tcout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 16;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <int> in[8];\nbool dchk[26];\n\nchar u[4050];\nvector<int> readvec() {\n\tscanf(\"%s\", u);\n\tvector <int> rv;\n\tfor (int i = 0; u[i] != 0; i++) rv.push_back(u[i] - '0');\n\treverse(all(rv));\n\treturn rv;\n}\n\nbool cmp(vector<int> &a, vector<int> &b) {\n\tif (a.size() != b.size()) return a.size() < b.size();\n\tfor (int i = a.size() - 1; i >= 0; i--) if (a[i] != b[i]) return a[i] < b[i];\n\treturn false;\n}\nint main() {\n\tint N, i, j;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i <= N; i++) in[i] = readvec();\n\t\n\n\twhile(1) {\n\t\tint c = 0;\n\t\tint mx = 7;\n\t\tfor (j = 1; j <= N; j++) {\n\t\t\tif (dchk[j]) continue;\n\t\t\tc++;\n\t\t\tif (cmp(in[mx], in[j])) mx = j;\n\t\t}\n\t\tif (c == 1) {\n\t\t\tswap(in[1], in[mx]);\n\t\t\tbreak;\n\t\t}\n\t\tint t;\n\t\tfor (j = 1; j <= N; j++) {\n\t\t\tif (dchk[j] || j == mx) continue;\n\t\t\tt = j;\n\t\t}\n\n\t\tint L1 = in[mx].size(), L2 = in[t].size();\n\t\tfor (i = 0; i < L2; i++) in[mx][i + L1 - L2] ^= in[t][i];\n\t\twhile (!in[mx].empty() && !in[mx].back()) in[mx].pop_back();\n\t\tif (in[mx].empty()) {\n\t\t\tdchk[mx] = true;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tif (dchk[i] || i == mx) continue;\n\t\t\tif (in[i] == in[mx]) dchk[mx] = true;\n\t\t}\n\t}\n\t\n\tll ans = 0;\n\tint L1 = in[0].size(), L2 = in[1].size();\n\tfor (i = L1 - 1; i >= L2 - 1; i--) ans = (ans * 2 + in[0][i]) % MOD;\n\t\n\tin[2].resize(L1);\n\tfor (i = 0; i < L1; i++) in[2][i] = 0;\n\tfor (i = L1 - 1; i >= L2 - 1; i--) {\n\t\tif (in[0][i] != in[2][i]) {\n\t\t\tint t = i - (L2 - 1);\n\t\t\tfor (j = L2 - 1; j >= 0; j--) in[2][t + j] ^= in[1][j];\n\t\t}\n\t}\n\t\n\tbool chk = true;\n\tfor (i = L2 - 2; i >= 0; i--) {\n\t\tif (in[0][i] == in[2][i]) continue;\n\t\tif (in[0][i] < in[2][i]) chk = false;\n\t\tbreak;\n\t}\n\tif (chk) ans = (ans + 1) % MOD;\n\treturn !printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\n\nmint mod_pow(mint a, ll x) {\n  mint res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nbitset<4000> gcd(bitset<4000>& p, bitset<4000>& q) {\n  int dp, dq;\n  dp = dq = -1;\n  rep(i, 4000) {\n    if (p[i]) dp = i;\n    if (q[i]) dq = i;\n  }\n  if (dq > dp) {\n    swap(dp, dq);\n    swap(p, q);\n  }\n  if (dq == -1) {\n    return p;\n  }\n  int d = dp-dq;\n  p ^= (q<<d);\n  return gcd(p, q);\n}\n\nmint calc(bitset<4000>& x, bitset<4000>& r) {\n  bitset<4000> k;\n  int dx, dr;\n  rep(i, 4000) {\n    if (x[i]) dx = i;\n    if (r[i]) dr = i;\n  }\n  mint ret = 0;\n\n  r <<= dx-dr;\n  for(int i=dx; i>=dr; i--) {\n    if (x[i]) {\n      ret += mod_pow(2, i-dr);\n      debug(ret.x);\n    }\n    if (k[i] ^ x[i]) {\n      k ^= r;\n    }\n    r >>= 1;\n  }\n\n  bool flag = true;\n  for(int i=dr-1; i>=0; i--) {\n    if (x[i] && !k[i]) {\n      break;\n    } else if (!x[i] && k[i]) {\n      flag = false;\n      break;\n    }\n  }\n  if (flag) ret += 1;\n  return ret;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  string s; cin >> s;\n  bitset<4000> x;\n  reverse(s.begin(), s.end());\n  rep(i, s.size()) {\n    if (s[i] == '1') {\n      x.set(i);\n    }\n  }\n\n  vector<bitset<4000>> vec(n);\n  rep(i, n) {\n    cin >> s;\n    reverse(s.begin(), s.end());\n    rep(j, s.size()) {\n      if (s[j] == '1') {\n        vec[i].set(j);\n      }\n    }\n  }\n\n  bitset<4000> r;\n  rep(i, n) {\n    r = gcd(r, vec[i]);\n  }\n\n  cout << calc(x, r) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 998244353;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\nconst ll len = 4020;\ntypedef bitset<len> bs;\nnamespace SOLVE {\n    bs gcd(bs a, bs b){\n        while (a.count() and b.count()) {\n            int h[2] = {0,0};\n            REP(i,0,len){\n                if(a[i])h[0] = i;\n                if(b[i])h[1] = i;\n            }\n            if(h[0]<=h[1]){\n                b^=a<<(h[1]-h[0]);\n            }else{\n                a^=b<<(h[0]-h[1]);\n            }\n        }\n        if(a.count())return a;\n        return b;\n    }\n    bs g,x;\n    int get_deg(bs x){\n        RREP(i,len-1,0)if(x[i])return i;\n        return -1;\n    }\n    bool operator<(const bs&a,const bs&b){\n        RREP(i,len-1,0)if(a[i]!=b[i])return a[i]<b[i];\n        return false;\n    }\n    ll ans = 0;\n    void main(){\n        int n;\n        cin>>n>>x;\n        \n        REP(i,0,n){\n            bs b;\n            cin>>b;\n            g = gcd(b, g);\n        }\n        int deg = get_deg(g);\n        RREP(i,len-1,deg){\n            if(x[i]){\n                ans += fast(2, i-deg, mod);\n                \n            }\n        }\n//        dbg(x.to_string());\n//        dbg(g.to_string());\n        if(x<g){\n            cout<<1<<endl;\n            return;\n        }\n        bs tmp;\n        RREP(i,len-1,deg){\n            if(x[i] != tmp[i]){\n                tmp ^= g<<(i-deg);\n            }\n        }\n        ans += tmp < x or tmp == x;\n        cout<< MOD(ans,mod)<<endl;\n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=4005,mu=998244353;\nint a[N],c[N],tmp[N],ans[N],x[N],lx,mx,n;\nchar s[N],sx[N];\nint deg(int *a){\n\tfor (int i=mx;i>=0;i--) \n\t\tif (a[i]) return i;\n\treturn 0; \n}\nvoid del(int *a,int *b,int t){\n\tfor (int i=mx;i>=t;i--)\n\t\ta[i]^=b[i-t];\n}\n/*void gcd(int *a,int *b,int *c){\n\tint l1=deg(a),l2=deg(b);\n\tif (l1<l2) std::swap(a,b),std::swap(l1,l2);\n\tif (l2==0 && b[0]==0){\n\t\tfor (int i=0;i<mx;i++) c[i]=a[i];\n\t\treturn;\n\t}\n\tfor(int i=l1;i>=l2;i--)\n\t\tif (a[i]) del(a,b,i-l2);\n\tgcd(b,a,c);\n}*/\nvoid gcd(int *a,int *b,int *d)\n{\n    int da=deg(a),db=deg(b);\n    if(da<db) std::swap(a,b),std::swap(da,db);\n    if(db==0&&b[0]==0) {for(int i=0;i<=4000;i++) d[i]=a[i];return ;}\n    del(a,b,da-db);\n    gcd(b,a,d);\n} \nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",sx);\n\tint lx=strlen(sx);\n\tfor (int i=lx-1,j=0;i>=0;i--,j++) x[i]=sx[j]-'0';\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%s\",s);\n\t\tint t=strlen(s);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor (int i=t-1,j=0;i>=0;i--,j++) a[i]=s[j]-'0';\n\t\tmx=std::max(mx,t);\n\t\tfor (int i=0;i<mx;i++) tmp[i]=ans[i];\n\t\tgcd(a,tmp,ans);\n\t}\n\tint len=deg(ans);\n\tmemset(a,0,sizeof(a));\n\tfor(int i=lx-1;i>=len;i--)\n\t\tif (a[i]!=x[i]) del(a,ans,i-len);\n\tint Ans=0;\n\tfor (int i=lx-1;i>=len;i--)\n\t\tAns=(Ans*2ll+x[i])%mu;\n\tfor (int i=len-1;i>=0;i--){\n\t\tif (a[i]<x[i]) break;\n\t\tif (a[i]>x[i]){\n\t\t\tAns--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(Ans+1)%mu);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int mod=998244353;\nint n;\nbool r[7][4010],c[4010],g[4010],tmp[4010];\nvoid trans(char *s,bool *a)\n{\n\tint len=strlen(s)-1;\n\tfor(int i=0;i<=len;i++)\n\t\ta[i]=s[len-i]-'0';\n}\nint deg(bool *a)\n{\n\tfor(int i=4000;i>=0;i--)\n\t\tif(a[i]) return i;\n}\nvoid pls(bool *a,bool *b,int t)\n{\n\tfor(int i=t;i<=4000;i++)\n\t\ta[i]=a[i]^b[i-t];\t\n}\nvoid gcd(bool *a,bool *b,bool *d)\n{\n\tint da=deg(a),db=deg(b);\n\tif(da<db) swap(a,b),swap(da,db);\n//\tfor(int i=da;i>=0;i--)\n//\t\tcout<<a[i];\n//\tcout<<endl;\n//\tfor(int i=db;i>=0;i--)\n//\t\tcout<<b[i];\n//\tcout<<endl;\t\n\tif(db==0&&b[0]==0) {for(int i=0;i<=4000;i++) d[i]=a[i];return ;}\n\t\n\t\n\tpls(a,b,da-db);\n\tgcd(b,a,d);\n}\nint main()\n{\n\tchar cs[4010];\n\tscanf(\"%d%s\",&n,cs);\n\ttrans(cs,c);\n\tint dc=deg(c);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",cs);\n\t\ttrans(cs,r[i]);\n\t}\n//\tfor(int i=1;i<=n;i++,puts(\"\"))\n//\t\tfor(int j=deg(r[i]);j>=0;j--)\n//\t\t\tcout<<r[i][j];\n\tmemset(g,0,sizeof(g));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=deg(g);j>=0;j--)\n\t\t\ttmp[j]=g[j];\n\t\tgcd(r[i],tmp,g);\n//\t\tfor(int i=deg(g);i>=0;i--)\n//\t\t\tcout<<g[i];\n//\t\tcout<<\"*****************************\"<<endl;\t\n\t}\n\tint dgcd=deg(g);\n\t//cout<<dgcd<<' '<<dc<<endl;\n\t\n\tmemset(tmp,0,sizeof(tmp));\n\tfor(int i=dc;i>=dgcd;i--)\n\t\tif(tmp[i]^c[i])\n\t\t\tpls(tmp,g,i-dgcd);\n//\tfor(int i=dc;i>=0;i--)\n//\t\tcout<<tmp[i];\n//\tcout<<endl;\t\t\t\t\n\tint ans=0;\n\tfor(int i=dc;i>=dgcd;i--)\n\t\tans=((ans<<1)+c[i])%mod;\t\n\tfor(int i=dgcd-1;i>=0;i--)\n\t\tif(tmp[i]<c[i])\tbreak;\n\t\telse if(tmp[i]>c[i]) {ans--;break;}\n\tprintf(\"%d\",ans+1);\t\t\t\n\treturn 0;\n}\n/*4 100100\n1110\n1011\n110101\n1010110*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long int N, lb, a, z;\nbitset<4444> A[7], X, Y, Z;\nchar s[4444];\n\ntemplate <size_t N>\nlong long to_modllong(bitset<N> n){\n    long long ret = 0;\n    for(int i = N; --i >= 0;ret += n[i]){\n        ret <<= 1;\n        ret %= 998244353;\n    }\n    return ret;\n}\n\ntemplate <typename T>\nstatic inline T gcd(T u, T v){\n    int sftu = 0, sftv = 0;\n    T t;\n    if(u.none()) return v;\n    if(v.none()) return u;\n    while(!u[0]){\n        ++sftu;\n        u >>= 1;\n    }\n    while(!v[0]){\n        ++sftv;\n        v >>= 1;\n    }\n    sftu = min(sftu, sftv);\n    do{\n        while(!v[0])v >>= 1;\n        swap(u, v);\n        v = v ^ u;\n    }while(v.any());\n    return u << sftu;\n}\n\nint main(){\n    scanf(\"%lld %s\", &N, s);\n    X = bitset<4444>(s);\n    Z = X;\n    for(int i = 0; i < N; ++i){\n        scanf(\" %s\", s);\n        A[i] = bitset<4444>(s);\n    }\n    Y = A[0];\n    for(int i = 1; i < N; ++i)Y = gcd(A[i], Y);\n    for(int i = 4443; i >= 0; --i)if(Y[i] && (lb = i))break;\n    for(int i = 4443 - lb; i >= 0; --i){\n        if(X[i + lb]){\n            X ^= Y << i;\n            A[6] ^= Y << i;\n        }\n    }\n    if(lb < 64){\n        a = (A[6] & ~(Z & A[6])).to_ullong();\n        z = (Z & ~(Z & A[6])).to_ullong();\n        cout << (to_modllong(Z >> lb) + (a <= z)) % 998244353 << endl;\n    }else{\n        long long d;\n        Y = A[6] ^ Z;\n        for(int i = 4443; i >= 0; --i)if(Y[i] && (d = i))break;\n        cout << (to_modllong(Z >> lb) + (!d || Z[d])) % 998244353 << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n\nconst int MOD = 998244353;\nusing mn = modnum<MOD>;\n\nconst int SZ = 4000;\nusing num = bitset<SZ>;\n\nint clz(num a) {\n    int i = 0;\n    while (i < sz(a) && !a[sz(a) - 1 - i]) i++;\n    return i;\n}\n\nnum gcd(num a, num b) {\n    int az = clz(a), bz = clz(b);\n    if (az > bz) {\n        swap(a, b);\n        swap(az, bz);\n    }\n    if (bz == sz(b)) return a;\n    return gcd(a ^ (b << (bz - az)), b);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N; num X;\n    cin >> N >> X;\n\n    vector<num> a(N);\n    for (auto& v : a) cin >> v;\n\n    num g = a[0];\n    for (int i = 1; i < N; i++)\n        g = gcd(g, a[i]);\n\n    int gl = SZ - 1 - clz(g), xl = SZ - 1 - clz(X);\n    if (gl > xl) { cout << \"0\\n\"; return 0; }\n\n    mn ans = 0;\n    num last;\n    for (int d = xl; d >= gl; d--) {\n        if (X[d]) {\n            ans += mn(2).pow(d - gl);\n        }\n        if (last[d] != X[d]) {\n            last ^= g << (d - gl);\n        }\n    }\n\n    ans += 1;\n    for (int d = gl - 1; d >= 0; d--) {\n        if (last[d] != X[d]) {\n            if (last[d] > X[d]) ans -= 1;\n            break;\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) {\n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; } else { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); } else { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/*  */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// TODO\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tIntMod Combination(const IntMod& right) const {\n\t\tif (value_m < right.value_m) throw \"okashii\";\n\t\treturn Fact() / ((*this - right).Fact() * right.Fact());\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\ntypedef IntMod<1000000007> MInt;\n\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator*(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret *= right;\n//\treturn ret;\n//}\n//template <unsigned int Modulus>\n//IntMod<Modulus> operator/(const int left, const IntMod<Modulus>& right) {\n//\tIntMod<Modulus> ret(left);\n//\tret /= right;\n//\treturn ret;\n//}\n\n#if 0\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator >> (istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Graph.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Range.h\"\n#include \"Tree.h\"\n#include \"Union_Find.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator >> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nconst int M = 4064;\nusing Bits = bitset<M>;\nusing Mit = IntMod<998244353>;\n\nint Digit(const Bits& a) {\n\tREM(i, 0, M) {\n\t\tif (a[i]) {\n\t\t\treturn i + 1;\n\t\t}\n\t}\n}\n\nBits GCD(Bits a, Bits b) {\n\tBits* p = &a;\n\tBits* q = &b;\n\tint as = Digit(a) - 1;\n\tint bs = Digit(b) - 1;\n\n\twhile (bs >= 0) {\n\t\twhile (as >= bs) {\n\t\t\t*p ^= *q << (as - bs);\n\t\t\twhile (as >= 0 && (*p)[as] == 0) {\n\t\t\t\t--as;\n\t\t\t}\n\t\t}\n\t\tswap(p, q);\n\t\tswap(as, bs);\n\t}\n\treturn *p;\n}\n\nbool Less(const Bits& a, const Bits& b) {\n\tREM(i, 0, M) {\n\t\tif (a[i] < b[i]) return true;\n\t\tif (a[i] > b[i]) return false;\n\t}\n\treturn false;\n}\n\nBits Inc(const Bits& a) {\n\tBits ret(a);\n\n\tREP(i, 0, M) {\n\t\tif (ret[i]) {\n\t\t\tret[i] = 0;\n\t\t} else {\n\t\t\tret[i] = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nint N;\nBits X;\nBits A[6];\nMit P[M];\nint main() {\n\tcin >> N >> X;\n\tREP(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\tX = Inc(X);\n\n\tP[0] = 1;\n\tREP(i, 1, M) {\n\t\tP[i] = P[i - 1] * 2;\n\t}\n\n\tBits gcd = 0;\n\tREP(i, 0, N) {\n\t\tgcd = GCD(gcd, A[i]);\n\t}\n\t\n\tint xs = Digit(X);\n\tint gs = Digit(gcd);\n\n\tMit sum = 0;\n\tREM(i, gs - 1, xs) {\n\t\tif (X[i]) {\n\t\t\tsum += P[i - gs + 1];\n\t\t}\n\t}\n\n\tBits Y = 0;\n\tREM(i, gs - 1, xs) {\n\t\tif (Y[i] != X[i]) {\n\t\t\tY ^= gcd << (i - gs + 1);\n\t\t}\n\t}\n\n\tcout << sum + Less(Y, X) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nconst int MOD = 998244353;\nconst int INF = INT_MAX / 2;\nstruct edge { int i, v, w; };\n\nvector<int> gcd(vector<int> s, vector<int> t) {\n\tint N = s.size(), M = t.size();\n\tif (N < M) return gcd(t, s);\n\tif (!M) return s;\n\trep(j, M) s[j] ^= t[j];\n\tint l = N;\n\trep(i, N) if (s[i]) {\n\t\tl = i;\n\t\tbreak;\n\t}\n\tvector<int> a(N - l);\n\trep(i, N - l) a[i] = s[l + i];\n\treturn gcd(t, a);\n}\n\nint pow_mod(ll x, ll n, int M) {\n\tll ans = 1;\n\tfor (; n; n >>= 1) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint N; cin >> N;\n\tstring s; cin >> s;\n\tvector<string> a(N);\n\trep(i, N) cin >> a[i];\n\tvector<int> d;\n\trep(i, N) {\n\t\tint M = a[i].length();\n\t\tvector<int> b(M);\n\t\trep(j, M) b[j] = a[i][j] - '0';\n\t\td = gcd(d, b);\n\t}\n\tint n = s.length();\n\tvector<int> c(n), _c(n);\n\trep(i, n) c[i] = s[i] - '0';\n\tint m = d.size();\n\tint ans = 1;\n\tfor (int i = 0; i + m <= n; i++) {\n\t\tif (c[i]) ans = (ans + pow_mod(2, n - m - i, MOD)) % MOD;\n\t\tif (c[i] == _c[i]) continue;\n\t\trep(j, m) _c[i + j] ^= d[j];\n\t}\n\tbool ok = true;\n\tif (_c <= c) ok = false;\n\tif (ok) ans = (ans + 1) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 4001, mod = 998244353;\n\nint n;\nvector<bitset<N> > a;\nbitset<N> k;\n\nstring in;\n\nint sz (bitset<N> &T) {\n\tfor(int i=N;i--;) {\n\t\tif(T[i] == 1) return i+1;\n\t}\n\treturn 0;\n}\n\nint val (bitset<N> T) {\n\tint R = 0;\n\tfor(int i=N;i--;) {\n\t\tR = (2*R + T[i]) % mod;\n\t}\n\treturn (R + 1) % mod;\n}\n\nbool cmp (bitset<N> A, bitset<N> B) {\n\tfor(int i=N;i--;) {\n\t\tif(A[i] < B[i]) return true;\n\t\tif(A[i] > B[i]) return false;\n\t}\n\treturn false;\n}\n\nvoid elim (bitset<N> &A, bitset<N> &B) {\n\tint S = sz(B)-1;\n\tfor(int i=N-1;i>=S;i--) {\n\t\tif(A[i] == 1) A ^= (B << (i-S));\n\t}\n}\n\nint main()\n{\n\tcin >> n >> in;\n\tk = bitset<N>(in);\n\tfor(int i=1;i<=n;i++) {\n\t\tcin >> in;\n\t\ta.push_back(bitset<N>(in));\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tif(sz(a[0]) > sz(a[i])) {\n\t\t\tswap(a[0], a[i]);\n\t\t}\n\t}\n\twhile(a.size() > 1) {\n\t\tauto &A = a[0], &B = a.back(), T = B;\n\t\telim(B, A);\n\t\tswap(A, B);\n\t\tif(sz(A) == 0) {\n\t\t\tA = T;\n\t\t\tswap(A, B);\n\t\t\ta.pop_back();\n\t\t}\n\t\telse {\n\t\t\ta.push_back(T);\n\t\t}\n\t}\n\tauto T = k;\n\telim(T, a[0]);\n\tcout << (val(k>>(sz(a[0])-1)) + mod - cmp(k, k^T)) % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\n\nconst int N = 4054, mod = 998244353;\ntypedef std::bitset <N> bitset;\n\nbitset GCD(bitset A, bitset B) {\n\tint dA = N - 1, dB = N - 1;\n\tfor (; ; ) {\n\t\tfor (; dA >= 0 && !A.test(dA); --dA);\n\t\tfor (; dB >= 0 && !B.test(dB); --dB);\n\t\tif (!(~dA && ~dB)) return A | B;\n\t\tdA < dB ? B ^= A << (dB - dA) : A ^= B << (dA - dB);\n\t}\n}\n\nint main() {\n\tint i, n, deg, ans = 0; bitset t, d, X;\n\tcin >> n >> X >> d;\n\tfor (i = 1; i < n; ++i) cin >> t, d = GCD(d, t);\n\tfor (deg = N - 1; deg >= 0 && !d.test(deg); --deg);\n\tassert(~deg);\n\tfor (i = N - 1; i >= deg; --i) ans = (ans * 2 + X.test(i)) % mod;\n\tfor (n = N - 1, t = X; ; t ^= d << (n - deg)) {\n\t\tfor (; n >= deg && !t.test(n); --n);\n\t\tif (n < deg) break;\n\t}\n\tfor (++ans, i = deg - 1; i >= 0; --i)\n\t\tif (t.test(i)) {ans -= !X.test(i); break;}\n\tcout << ans % mod << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nstatic const int MOD = 998244353;\n\nvector<int> BitsetGcd(vector<int> s, vector<int> t) {\n        int n = s.size(), m = t.size();\n        if (n < m) return BitsetGcd(t, s);\n        if (!m) return s;\n        for (int i = 0; i < m; i ++) s[i] ^= t[i];\n        int l = n;\n        for (int i = 0; i < n; i ++) {\n                if (s[i]) {\n                        l = min(l, i);\n                        break;\n                }\n        }\n        vector<int> a(n - l);\n        for (int i = 0; i < n - l; i ++) {\n                a[i] = s[l + i];\n        }\n        return BitsetGcd(t, a);\n}\n\n//#define N 4040\n//\n//int Len(const bitset<N> &a) {\n//        for (int res = N - 1; res >= 0; res --) {\n//                if (a[res]) return res + 1;\n//        }\n//        return 0;\n//}\n//\n//bitset<N> gcd(bitset<N> s, bitset<N> t) {\n//        int n = Len(s), m = Len(t);\n//        if (n < m) return gcd(t, s);\n//        if (t.none()) return s;\n//        int d = n - m;\n//        bitset<N> u = t;\n//        u <<= d;\n//        s ^= u;\n//        return gcd(t, s);\n//}\n\nlong long ModPow(long long x, long long n, long long m) {\n        long long res = 1;\n        while (n > 0) {\n                if (n & 1) res = res * x % m;\n                x = x * x % m;\n                n >>= 1;\n        }\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        //bitset<N> x;\n        //cin >> x;\n        //bitset<N> g;\n        //for (int i = 0; i < n; i ++) {\n        //        bitset<N> s;\n        //        cin >> s;\n        //        g = gcd(g, s);\n        //}\n        //cerr << g << endl;\n        string x;\n        cin >> x;\n        vector<int> g;\n        for (int i = 0; i < n; i ++) {\n                string s;\n                cin >> s;\n                int k = s.size();\n                vector<int> b(k);\n                for (int i = 0; i < k; i ++) b[i] = s[i] - '0';\n                g = BitsetGcd(g, b);\n        }\n        for (int i = 0; i < g.size(); i ++) {\n                cerr << g[i];\n        }\n        cerr << endl;\n        n = x.size();\n        vector<int> c(n), d(n);\n        for (int i = 0; i < n; i ++) c[i] = x[i] - '0';\n        int m = g.size();\n        int ans = 0;\n        for (int i = 0; i + m <= n; i ++) {\n                if (c[i]) ans = (ans + ModPow(2, n - m - i, MOD)) % MOD;\n                if (c[i] == d[i]) continue;\n                for (int j = 0; j < m; j ++) d[i + j] ^= g[j];\n        }\n        printf(\"%d\\n\", (ans + (d > c ? 0 : 1)) % MOD);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<bitset>\n#define BS 4096\nusing namespace std;\nbitset<4096>w[6], X, G, TP;\nint n, GL, Mod = 998244353, po[4096];\nchar p[4096];\nvoid Put(bitset<4096> &TP, char *key) {\n\tint i, L;\n\tfor (i = 0; key[i]; i++);\n\tL = i;\n\tfor (i = 0; i < L; i++) {\n\t\tTP[L - i - 1] = key[i]-'0';\n\t}\n}\nint Len(bitset<4096> &TP) {\n\tint j;\n\tfor (j = BS - 1; j >= 0; j--) {\n\t\tif (G[j])break;\n\t}\n\treturn j+1;\n}\nint main() {\n\tint i, j;\n\tpo[0] = 1;\n\tfor (i = 1; i <= 4000; i++)po[i] = po[i - 1] * 2 % Mod;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tPut(X, p);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%s\", p);\n\t\tPut(w[i], p);\n\t}\n\tG = w[0];\n\twhile (1) {\n\t\tint ck = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tTP = w[i];\n\t\t\tGL = Len(G);\n\t\t\tfor (j = BS - 1; j >= GL - 1; j--) {\n\t\t\t\tif (TP[j]) {\n\t\t\t\t\tTP ^= G << (j + 1 - GL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = BS - 1; j >= 0; j--)if (TP[j])break;\n\t\t\tif (j != -1) {\n\t\t\t\tck = 1;\n\t\t\t\tG = TP;\n\t\t\t}\n\t\t}\n\t\tif (!ck)break;\n\t}\n\tGL = Len(G);\n\tlong long res = 0;\n\tTP.reset();\n\tfor (i = BS - 1; i >= GL - 1; i--) {\n\t\tif (X[i]) {\n\t\t\tres = (res + po[i - (GL - 1)]) % Mod;\n\t\t}\n\t\tif (TP[i] != X[i]) {\n\t\t\tTP ^= G << (i + 1 - GL);\n\t\t}\n\t}\n\tint ck = 0;\n\tfor (i = BS - 1; i >= 0; i--) {\n\t\tif (X[i] != TP[i]) {\n\t\t\tif (TP[i]) ck = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tres = (res + 1 - ck) % Mod;\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include <cassert>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\n\nconst int N=4000;\ntypedef bitset<N> bs;\nconst lint MOD=998244353;\n\nbs read(){\n  string s;\n  cin>>s;\n  int l=s.length();\n  bs ret;\n  rep(i,l)ret[i]=s[l-i-1]=='1';\n  return ret;\n}\n\nbs div(bs a, bs b){\n  int hi=-1;\n  rep(i,N){\n    if(b[i]){\n      hi=i;\n    }\n  }\n  assert(hi>=0);\n  for(int i=N-hi-1;i>=0;--i){\n    if(a[i+hi]){\n      a^=b<<i;\n    }\n  }\n  return a;\n}\n\nbs gcd(bs a,bs b){\n  while(b.count()!=0){\n    a=div(a,b);\n    swap(a,b);\n  }\n  return a;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  bs x=read();\n  vector<bs> s(n);\n  rep(i,n)s[i]=read();\n  bs t=s[n-1];\n  rep(i,n-1)\n    t=gcd(s[i],t);\n  lint ans=0;\n  lint cur=1;\n  int hi=-1;\n  rep(i,N){\n    if(t[i]){\n      hi=i;\n    }\n  }\n  rep(i,N-hi){\n    if(x[i+hi])ans=(ans+cur)%MOD;\n    cur=cur*2%MOD;\n  }\n  bs y = x ^ div(x,t);\n  bool lt=false;\n  for(int i=N-1;i>=0;--i){\n    if(x[i]!=y[i]){\n      lt=x[i]<y[i];\n      break;\n    }\n  }\n  if(lt)ans=(ans+MOD-1)%MOD;\n  ans=(ans+1)%MOD;\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 100005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nvector<int> num[7],x,g,t;\nint N;\nchar s[4005];\nvector<int> gcd(vector<int> a,vector<int> b) {\n\tif(a.size() < b.size()) swap(a,b);\n\tif(b.size() == 1 && b[0] == 0) return a;\n\tvector<int> d(a.size());\n\tint t = a.size() - 1;\n\tfor(int i = b.size() - 1 ; i >= 0 ; --i) {\n\t\td[t] = a[t] ^ b[i];\n\t\t--t;\n\t}\n\tfor(int i = t ; i >= 0 ; --i) d[i] = a[i];\n\twhile(d.size() > 1) {\n\t\tif(d.back() == 0) d.pop_back();\n\t\telse break;\n\t}\n\treturn gcd(b,d);\n}\nvoid Init() {\n\tread(N);\n\tscanf(\"%s\",s + 1);\n\tint len = strlen(s + 1);\n\tfor(int i = len ; i >= 1 ; --i) {\n\t\tx.pb(s[i] - '0');\n\t}\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tscanf(\"%s\",s + 1);\n\t\tlen = strlen(s + 1);\n\t\tfor(int j = len ; j >= 1 ; --j) num[i].pb(s[j] - '0');\n\t}\n\tg = num[1];\n\tfor(int i = 2 ; i <= N ; ++i) g = gcd(g,num[i]);\n}\nvoid Solve() {\n\tt = x;\n\tint l = x.size() - g.size() + 1;\n\tint d = x.size() - 1;\n\tint ans = 0;\n\tfor(int i = 0 ; i < l ; ++i) {\n\t\tans = (1LL * ans * 2 + x[d - i]) % MOD;\n\t}\n\tans = (ans + 1) % MOD;\n\tfor(int i = 0 ; i < l ; ++i) {\n\t\tif(t[d - i] == 1) {\n\t\t\tint k = g.size() - 1;\n\t\t\tfor(int j = 0 ; j < g.size() ; ++j) {\n\t\t\t\tt[d - i - j] = t[d - i - j] ^ g[k - j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = l ; i < x.size() ; ++i) {\n\t\tif(t[d - i] != x[d - i]) {\n\t\t\tif(t[d - i] > x[d - i]) ans = (ans + MOD - 1) % MOD;\n\t\t\telse break;\n\t\t}\n\t}\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tInit();\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\ntypedef bitset<4005> poly;\n\nllint n;\npoly x;\npoly a[6];\nllint beki[4005];\n\nvoid adjust(string &s, poly &bs){\n\tbs.reset();\n\treverse(s.begin(), s.end());\n\tfor(int i = 0; i < s.size(); i++) bs[i] = s[i]-'0';\n}\n\nllint deg(poly &a)\n{\n\tfor(int i = (int)a.size()-1; i >= 0; i--){\n \t\tif(a[i]) return i;\n\t}\n\treturn -1;\n}\n\npoly rem(poly a, poly b)\n{\n\tint A = deg(a), B = deg(b);\n\tfor(int i = A-B; i >= 0; i--){\n\t\tif(a[i+B]) a ^= (b << i);\n\t}\n\treturn a;\n}\n\npoly gcd(poly a, poly b)\n{\n \tif(b.none()) return a;\n  \treturn gcd(b, rem(a, b));\n}\n\nint main(void)\n{\n\tcin >> n;\n\t\n\tstring s;\n\tcin >> s;\n\tadjust(s, x);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> s;\n\t\tadjust(s, a[i]);\n\t}\n\t\n\tpoly d;\n\tfor(int i = 0; i < n; i++) d = gcd(d, a[i]);\n\tllint D = deg(d);\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 4005; i++) beki[i] = beki[i-1] * 2 % mod;\n\t\n\tllint ans = 0, X = deg(x); poly y;\n\tfor(int i = X-D; i >= 0; i--){\n\t  if(x[i+D]) ans += beki[i], ans %= mod;\n\t  if(x[i+D] != y[i+D]) y ^= (d << i);\n\t}\n\tbool flag = true;\n\tfor(int i = D-1; i >= 0; i--){\n\t\tif(x[i] > y[i]) break;\n\t\tif(x[i] < y[i]) flag = false;\n\t}\n\tif(flag) ans++, ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nconst int S = 4e3;\nconst int N = 4010;\nconst int Mod = 998244353;\nint n, ans; bool c[N], g[N], d[N], r[7][N]; char cs[N];\n\ninline int deg(bool *a) {\n\tfor (int i = S; ~ i; --i) if (a[i]) return i;\n}\ninline void pls(bool *a, bool *b, int l) {\n\tfor (int i = l; i <= S; ++i) a[i] = a[i] ^ b[i-l];\n}\ninline void gcd(bool *a, bool *b, bool *d) {\n\tint da = deg(a), db = deg(b);\n\tif (da < db) swap(da, db), swap(a, b);\n\tif (!db && !b[0]) {for (int i = 0; i <= S; ++i) d[i] = a[i]; return;}\n\tpls(a, b, da - db), gcd(b, a, d);\n}\ntemplate <class T> inline void in(T &x) {\n\tx = 0; int f = 1; char ch = getchar();\n\tfor (; ch<'0' || ch>'9';) {if (ch=='-') f=-1; ch = getchar();}\n\tfor (; ch>='0' && ch<='9';) x = x*10 + ch-'0', ch = getchar();\n\tx *= f;\n}\n\ninline void red(bool *a) {\n\tint ls; scanf(\"%s\", cs), ls = strlen(cs) - 1;\n\tfor (int i = 0; i <= ls; ++i) a[i] = cs[ls - i] - '0';\n}\n\ninline void work() {\n\tin(n), red(c);\n\tfor (int i = 1; i <= n; ++i) red(r[i]);\n\tmemset(g, 0, sizeof g);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = deg(g); ~ j; --j) d[j] = g[j];\n\t\tgcd(r[i], d, g);\n\t}\n\tint dc = deg(c), dgcd = deg(g);\n\tmemset(d, 0, sizeof d);\n\tfor (int i = dc; i >= dgcd; --i)\n\t\tif (d[i] ^ c[i]) pls(d, g, i - dgcd);\n\tans = 0;\n\tfor (int i = dc; i >= dgcd; --i) ans = ((ans << 1) + c[i]) % Mod;\n\tfor (int i = dgcd - 1; ~ i; --i)\n\t\tif (d[i] < c[i]) break;\n\t\telse if (d[i] > c[i]) {--ans; break;}\n\tprintf(\"%d\", ans + 1);\n}\n\nint main() {work(); return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nconstexpr int DMAX = 4001;\nconstexpr lint MOD = 998244353;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<bitset<DMAX>> A;\n\n    string S;\n    cin >> S;\n    bitset<DMAX> X(S);\n    for (int i = 0; i < N; i++)\n    {\n        cin >> S;\n        A.push_back(bitset<DMAX>(S));\n    }\n\n    int d = 0;\n    while (true)\n    {\n        sort(A.begin(), A.end(), [](const auto &l, const auto &r) { return l.to_string() < r.to_string(); });\n        while (A[0].none()) A.erase(A.begin());\n        bitset<DMAX> tmp = A[0];\n        d = 0;\n        for (int j = 1; j <= DMAX; j++) if (tmp[j-1]) d = j;\n\n        for (int i = 1; i < A.size(); i++)\n        {\n            int d_ = 0;\n            for (int j = d; j <= DMAX; j++) if (A[i][j-1]) d_ = j;\n            A[i] ^= tmp << (d_ - d);\n        }\n        if (A.size() == 1) break;\n    }\n    bitset<DMAX> making;\n    for (int i = DMAX - d; i >= 0; i--)\n    {\n        bitset<DMAX> making_tmp = making ^ (A[0] << i);\n        if (making.to_string() > making_tmp.to_string()) swap(making, making_tmp);\n        if ((making_tmp >> (i + d - 1)).to_string() <= (X >> (i + d - 1)).to_string()) making = making_tmp;\n    }\n    lint ans = 0;\n    lint dig = 1;\n    for (int i = 0; i < DMAX; i++)\n    {\n        (ans += (X >> (d - 1))[i] * dig) %= MOD;\n        (dig *= 2) %= MOD;\n    }\n    \n    cout << (ans + (making.to_string() <= X.to_string())) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\nconst int limit = 4010;\nusing T = bitset<limit>;\n\nT gcd(T a, T b) {\n\tif (b.none()) return a;\n\tint ta = 0, tb = 0;\n\trep(i, limit) if (a[i]) ta = i;\n\trep(i, limit) if (b[i]) tb = i;\n\n\tif (ta < tb) {\n\t\treturn gcd(b, a);\n\t} else {\n\t\tT ab = a;\n\t\tfor (int i = ta; i >= tb; --i) {\n\t\t\tif (ab[i]) {\n\t\t\t\tab ^= b << (i - tb);\n\t\t\t}\n\t\t}\n\t\treturn gcd(b, ab);\n\t}\n\treturn b;\n}\n\nT read() {\n\tstring s;\n\tcin >> s;\n\tconst int n = s.size();\n\tT ret;\n\tret.reset();\n\trep(i, n) if (s[i] == '1') ret.set(n - 1 - i);\n\treturn ret;\n}\n\nconst ll mod = 998244353LL;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\tT x, a[6];\n\n\tx = read();\n\trep(i, n) a[i] = read();\n\n\tT g = a[0];\n\trep(i, 1, n) g = gcd(g, a[i]);\n\n\tint tg = 0, tx = 0;\n\trep(i, limit) if (g[i]) tg = i;\n\trep(i, limit) if (x[i]) tx = i;\n\n\tll ans = 0LL;\n\tfor (int i = tx; i >= tg; --i) ans = (2LL * ans + x[i]) % mod;\n\tans = (ans + 1) % mod;\n\n\tT y;\n\ty.reset();\n\n\tfor (int i = tx; i >= tg; --i) {\n\t\tif (x[i] != y[i]) {\n\t\t\ty ^= g << (i - tg);\n\t\t}\n\t}\n\n\tbool big = false;\n\trrep(i, tg) {\n\t\tif (x[i] != y[i]) {\n\t\t\tif (x[i] > y[i]) big = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (big) ans = (ans + mod - 1) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 998244353;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\nconst ll len = 4010;\ntypedef bitset<len> bs;\nnamespace SOLVE {\n    bs gcd(bs a, bs b){\n        while (a.count() and b.count()) {\n            int h[2] = {0,0};\n            REP(i,0,len){\n                if(a[i])h[0] = i;\n                if(b[i])h[1] = i;\n            }\n            if(h[0]<=h[1]){\n                b^=a<<(h[1]-h[0]);\n            }else{\n                a^=b<<(h[0]-h[1]);\n            }\n        }\n        if(a.count())return a;\n        return b;\n    }\n    bs g,x;\n    int get_deg(bs x){\n        RREP(i,len-1,0)if(x[i])return i;\n        return -1;\n    }\n    bool operator<(const bs&a,const bs&b){\n        RREP(i,len-1,0)if(a[i]!=b[i])return a[i]<b[i];\n        return false;\n    }\n    ll ans = 0;\n    void main(){\n        int n;\n        cin>>n>>x;\n        \n        REP(i,0,n){\n            bs b;\n            cin>>b;\n            g = gcd(b, g);\n        }\n        int deg = get_deg(g);\n        RREP(i,len-1,deg){\n            if(x[i]){\n                ans += fast(2, i-deg, mod);\n                \n            }\n        }\n//        dbg(x.to_string());\n//        dbg(g.to_string());\n        if(x<g){\n            cout<<1<<endl;\n            return;\n        }\n        bs tmp;\n        RREP(i,len-1,deg){\n            if(x[i]){\n                tmp ^= g<<(i-deg);\n            }\n        }\n        ans += tmp < x or tmp == x;\n        cout<< MOD(ans,mod)<<endl;\n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int MOD = 998244353;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y) {\n\treturn ((ll)x * y) % MOD;\n}\n\nconst int N = 4010;\nint n;\nint a[N];\nint b[N];\nint c[N];\nint m, L1, L2;\nchar s[N];\nint p2[N];\n\nvoid reduce() {\n\t//cerr << \"REDUCE\" << endl;\n\twhile(true) {\n\t\t//cerr << L1 << \" \" << L2 << endl;\n\t\tif (L1 > L2) {\n\t\t\tswap(a, b);\n\t\t\tswap(L1, L2);\n\t\t}\n\t\tfor (int i = 0; i < L1; i++)\n\t\t\tb[L2 - L1 + i] ^= a[i];\n\t\twhile(L2 > 0 && b[L2 - 1] == 0) L2--;\n\t\tif (L2 == 0) break;\n\t}\n}\n\nint solve() {\n\tif (L1 > m) return 0;\n\tfor (int i = 0; i < m; i++)\n\t\tb[i] = 0;\n\tint ans = 0;\n\tfor (int i = m - 1; i >= L1 - 1; i--) {\n\t\tif (c[i] == 1) ans = add(ans, p2[1 + i - L1]);\n\t\tif (b[i] != c[i]) {\n\t\t\tfor (int j = 0; j < L1; j++)\n\t\t\t\tb[i - L1 + 1 + j] ^= a[j];\n\t\t}\n\t}\n\tint p = L1 - 1;\n\twhile(p >= 0 && b[p] == c[p]) p--;\n\tif (p < 0 || b[p] < c[p]) ans = add(ans, 1);\n\treturn ans;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tp2[i] = add(p2[i - 1], p2[i - 1]);\n\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s);\n\tm = strlen(s);\n\tfor (int i = 0; i < m; i++)\n\t\tc[i] = s[m - 1 - i] - '0';\n\tscanf(\"%s\", s);\n\tL1 = strlen(s);\n\tfor (int i = 0; i < L1; i++)\n\t\ta[i] = s[L1 - 1 - i] - '0';\n\tn--;\n\twhile(n--) {\n\t\tscanf(\"%s\", s);\n\t\tL2 = strlen(s);\n\t\tfor (int i = 0; i < L2; i++)\n\t\t\tb[i] = s[L2 - 1 - i] - '0';\n\t\treduce();\n\t}\n\t/*\n\tprintf(\"%d \", L1);\n\tfor (int i = 0; i < L1; i++)\n\t\tprintf(\"%d\", a[i]);\n\tprintf(\"\\n\");\n\t*/\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "-- Your code here!\nimport Data.Bits\nb2i xs = foldl (\\x y -> 2 * x + y) 0 $ map (\\x -> read [x]) xs\n\nmain = print =<< solve <$> ((\\[a,b] -> [0, b2i b, fromIntegral $ length b]) <$> words <$> getLine) <*> ((fmap b2i) <$> lines <$> getContents)\n\nsolve :: [Integer] -> [Integer] -> Integer\nsolve (_:x:xn:_) (a:bs) = mod (conf + obv a) 998244353 where\n    obv a\n        |a == 1 = x - conf + 1\n        |otherwise = filterSum (x >=) (fmap (xorProduct (spBit bas)) [conf..conf*2])\n    conf = 2 ^ (xn - count bas)\n    bas = base a bs\n    filterSum _pred []    = 0\n    filterSum pred (x:xs)\n        | pred x         = 1 + filterSum pred xs\n        | otherwise      = filterSum pred xs\nbase 1 _ = 1\nbase a [] = a\nbase a (b:bs) = base (f a b) bs where\n    f 0 b = b\n    f 1 _ = 1\n    f a b \n        |a == b = a\n        |otherwise = f (g a b) (min a b)\n    g a b = let amb = count a - count b in xor (sl a (-amb)) (sl b amb)\n    sl a b = if (b > 0) then shiftL a b else a\ncount a = h a 0 where\n    h 0 s = s\n    h a s = h (shiftR a 1) (s + 1)\nxorProduct a b = foldr1 xor (fmap (b*) a)\nspBit a = zipWith (*) (iterate (*2) 1) (f a) where\n    f 0 = []\n    f a = mod a 2 : f (div a 2)"
  },
  {
    "language": "C",
    "code": "/* https://probgate.org/viewanalysis.php?pid=978 */\n#include <stdio.h>\n#include <string.h>\n\n#define N\t4000\n#define L\t62\n#define K\t((N + L - 1) / L)\n#define MD\t998244353\n\nvoid shift(long long *aa, long long *bb, int s) {\n\tint h, q, r;\n\n\tmemset(bb, 0, K * sizeof *bb);\n\tq = s / L, r = s % L;\n\tfor (h = 0; h + q < K; h++) {\n\t\tbb[h + q] |= (aa[h] & (1LL << L - r) - 1) << r;\n\t\tif (h + q + 1 < K && r > 0)\n\t\t\tbb[h + q + 1] |= aa[h] >> L - r;\n\t}\n}\n\nvoid xor(long long *aa, long long *bb) {\n\tint h;\n\n\tfor (h = 0; h < K; h++)\n\t\taa[h] ^= bb[h];\n}\n\nint main() {\n\tstatic char s[N + 1];\n\tstatic long long aa[K], bb_[K], cc[K], dd_[K], *bb = bb_, *dd = dd_;\n\tstatic int p2[N];\n\tint m, n, l, i, j, p, ans;\n\n\tscanf(\"%d%s\", &m, s), n = strlen(s);\n\tfor (i = 0; i < n; i++)\n\t\tif (s[i] == '1')\n\t\t\taa[(n - 1 - i) / L] |= 1LL << (n - 1 - i) % L;\n\twhile (m--) {\n\t\tscanf(\"%s\", s), l = strlen(s);\n\t\tmemset(bb, 0, K * sizeof *bb);\n\t\tfor (i = 0; i < l; i++)\n\t\t\tif (s[i] == '1')\n\t\t\t\tbb[(l - 1 - i) / L] |= 1LL << (l - 1 - i) % L;\n\t\ti = j = N - 1;\n\t\twhile (1) {\n\t\t\tlong long *tt;\n\t\t\tint tmp;\n\n\t\t\twhile (i >= 0 && (dd[i / L] & 1LL << i % L) == 0)\n\t\t\t\ti--;\n\t\t\twhile (j >= 0 && (bb[j / L] & 1LL << j % L) == 0)\n\t\t\t\tj--;\n\t\t\tif (i < j)\n\t\t\t\ttt = dd, dd = bb, bb = tt, tmp = i, i = j, j = tmp;\n\t\t\tif (j < 0)\n\t\t\t\tbreak;\n\t\t\tshift(bb, cc, i - j);\n\t\t\txor(dd, cc);\n\t\t}\n\t}\n\tl = N;\n\twhile (l > 0 && (dd[(l - 1) / L] & 1LL << (l - 1) % L) == 0)\n\t\tl--;\n\tp = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tp2[i] = p;\n\t\tp = p * 2 % MD;\n\t}\n\tmemset(bb, 0, K * sizeof *bb);\n\tans = 0;\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tint x = aa[i / L] >> i % L & 1, y = bb[i / L] >> i % L & 1;\n\n\t\tif (i >= l - 1 && x == 1)\n\t\t\tans = (ans + p2[i - l + 1]) % MD;\n\t\tif (x != y) {\n\t\t\tif (i >= l - 1) {\n\t\t\t\tshift(dd, cc, i - l + 1);\n\t\t\t\txor(bb, cc);\n\t\t\t} else {\n\t\t\t\tif (x > y)\n\t\t\t\t\tans = (ans + 1) % MD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (i < 0)\n\t\tans = (ans + 1) % MD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic boolean[] tob(char[] s)\n\t{\n\t\tboolean[] ret = new boolean[4000];\n\t\tfor(int i = 0;i < s.length;i++){\n\t\t\tret[i] = s[s.length-1-i] == '1';\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tboolean[] X = tob(ns().toCharArray());\n\t\tboolean[][] v = new boolean[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tv[i] = tob(ns().toCharArray());\n\t\t}\n\t\t\n\t\tboolean[] basis = null;\n\t\twhile(true){\n\t\t\tArrays.sort(v, new Comparator<boolean[]>() {\n\t\t\t\tpublic int compare(boolean[] a, boolean[] b) {\n\t\t\t\t\tfor(int i = 3999;i >= 0;i--){\n\t\t\t\t\t\tif(a[i] != b[i]){\n\t\t\t\t\t\t\tif(a[i])return 1;\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tboolean[] b = Arrays.copyOf(v[0], 4000);\n\t\t\t\n\t\t\tint[] h = new int[n];\n\t\t\tArrays.fill(h, -1);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 3999;j >= 0;j--){\n\t\t\t\t\tif(v[i][j]){\n\t\t\t\t\t\th[i] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(h.length >= 2 && h[0] == h[1]){\n\t\t\t\tfor(int j = 0;j < 4000;j++){\n\t\t\t\t\tb[j] ^= v[1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\touter:\n//\t\t\tfor(int j = 3999;j >= 0;j--){\n//\t\t\t\tif(b[j]){\n//\t\t\t\t\tfor(int i = 1;i < n;i++){\n//\t\t\t\t\t\tif(h[i] == j){\n//\t\t\t\t\t\t\tfor(int k = 0;k <= j;k++){\n//\t\t\t\t\t\t\t\tb[k] ^= v[i][k];\n//\t\t\t\t\t\t\t\tcontinue outer;\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tint hb = -1;\n\t\t\tfor(int j = 3999;j >= 0;j--){\n\t\t\t\tif(b[j]){\n\t\t\t\t\thb = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint p = 0;\n\t\t\touter:\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 3999;j >= hb;j--){\n\t\t\t\t\tif(v[i][j]){\n\t\t\t\t\t\tfor(int k = 0;k <= hb;k++){\n\t\t\t\t\t\t\tv[i][j-hb+k] ^= b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = hb-1;k >= 0;k--){\n\t\t\t\t\tif(v[i][k]){\n\t\t\t\t\t\tv[p] = v[i];\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv = Arrays.copyOf(v, p);\n//\t\t\ttf(b);\n//\t\t\tfor(int i = 0;i < p;i++){\n//\t\t\t\ttf(v[i]);\n//\t\t\t}\n\t\t\tif(p == 0){\n\t\t\t\tbasis = b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = p;\n\t\t}\n\t\t\n\t\tint hba = -1;\n\t\tfor(int i = 3999;i >= 0;i--){\n\t\t\tif(basis[i]){\n\t\t\t\thba = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tint mod = 998244353;\n\t\tboolean[] o = new boolean[4000];\n\t\tfor(int i = 3999;i >= hba;i--){\n\t\t\tif(X[i]){\n\t\t\t\tans += pow(2, i-hba, mod);\n\t\t\t}\n\t\t\tif(X[i] != o[i]){\n\t\t\t\tfor(int j = hba;j >= 0;j--){\n\t\t\t\t\to[i-hba+j] ^= basis[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\ttf(X);\n//\t\ttf(o);\n\t\tboolean ok = true;\n\t\tfor(int i = hba-1;i >= 0;i--){\n\t\t\tif(!X[i] && o[i]){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(X[i] &&!o[i]){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)ans++;\n\t\tout.println(ans%mod);\n\t}\n\t\n\tpublic static void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic int Z = 63;\n\t\n\tstatic long[] tob(char[] s)\n\t{\n\t\tlong[] ret = new long[Z];\n\t\tfor(int i = 0;i < s.length;i++){\n\t\t\tret[i>>>6] |= (long)s[s.length-1-i]-'0'<<i;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tlong[] X = tob(ns().toCharArray());\n\t\tlong[][] v = new long[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tv[i] = tob(ns().toCharArray());\n\t\t}\n\t\t\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tv[0] = gcd(v[0], v[i]);\n\t\t}\n\t\t\n\t\tout.println(count(v[0], X, 998244353));\n\t}\n\t\n\tstatic long count(long[] b, long[] x, int mod)\n\t{\n\t\tint n = x.length;\n\t\tint hb = height(b);\n\t\tassert hb > 0;\n\t\tlong ret = 0;\n\t\tlong[] o = new long[x.length];\n\t\tfor(int i = n*64-1;i >= hb-1;i--){\n\t\t\tret = ret * 2 % mod;\n\t\t\tif(x[i>>>6]<<~i<0){\n\t\t\t\tret++;\n\t\t\t}\n\t\t\tif((x[i>>>6]^o[i>>>6])<<~i<0){\n\t\t\t\txor(b, 0, hb, o, i-hb+1);\n\t\t\t}\n\t\t}\n\t\tret++;\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint comp = Long.compareUnsigned(x[i], o[i]);\n\t\t\tif(comp < 0){\n\t\t\t\tret--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(comp > 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (int)(ret%mod);\n\t}\n\t\n\tstatic int height(long[] a)\n\t{\n\t\tfor(int i = a.length-1;i >= 0;i--){\n\t\t\tif(a[i] != 0)return i*64+64-Long.numberOfLeadingZeros(a[i]);\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tstatic long[] gcd(long[] a, long[] b)\n\t{\n\t\tint ha = height(a);\n\t\tint hb = height(b);\n\t\twhile(hb != 0){\n\t\t\tif(ha >= hb)xor(b, 0, hb, a, ha-hb);\n\t\t\tlong[] d = a; a = b; b = d;\n\t\t\tha = hb; hb = height(b);\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static void xor(long[] from, int fl, int fr, long[] to, int tl)\n\t{\n\t\tif(fl >= fr)return;\n\t\tif(!(fl >= 0 && fl < from.length<<6))throw new RuntimeException();\n\t\tif(!(fr >= 0 && fr <= from.length<<6))throw new RuntimeException();\n\t\tif(!(tl >= 0 && tl < to.length<<6))throw new RuntimeException();\n\t\tif(!(tl+(fr-fl) >= 0 && tl+(fr-fl) <= to.length<<6))throw new RuntimeException();\n\t\t\n\t\tint tr = tl+(fr-fl);\n\t\tif(tl>>>6 == tr-1>>>6){\n\t\t\tif(fl>>>6 == fr-1>>>6){\n\t\t\t\tto[tl>>>6] ^= from[fl>>>6]<<-fr>>>fl-fr<<tl;\n\t\t\t}else{\n\t\t\t\tto[tl>>>6] ^= from[fl>>>6]>>>fl<<tl ^ from[(fl>>>6)+1]<<-fr>>>-fr<<tr-fr;\n\t\t\t}\n\t\t}else if((fl&63) < (tl&63)){\n\t\t\tto[tl>>>6] ^= from[fl>>>6]>>>fl<<tl;\n\t\t\tfor(int i = (tl>>>6)+1, j = (fl>>>6);i <= (tr-1>>>6)-1;i++,j++){\n\t\t\t\tto[i] ^= from[j]>>>fl-tl ^ from[j+1]<<-(fl-tl);\n\t\t\t}\n\t\t\tif((fr-1&63) < (tr-1&63)){\n\t\t\t\tto[tr-1>>>6] ^= from[(fr-1>>>6)-1]>>>fl-tl ^ from[fr-1>>>6]<<-fr>>>-tr;\n\t\t\t}else{\n\t\t\t\tto[tr-1>>>6] ^= from[fr-1>>>6]<<-fr>>>-tr;\n\t\t\t}\n\t\t}else if((fl&63) > (tl&63)){\n\t\t\tto[tl>>>6] ^= from[fl>>>6]>>>fl<<tl ^ from[(fl>>>6)+1]<<-(fl-tl);\n\t\t\tfor(int i = (tl>>>6)+1, j = (fl>>>6)+1;i <= (tr-1>>>6)-1;i++,j++){\n\t\t\t\tto[i] ^= from[j]>>>fl-tl ^ from[j+1]<<-(fl-tl);\n\t\t\t}\n\t\t\tif((fr-1&63) > (tr-1&63)){\n\t\t\t\tto[tr-1>>>6] ^= from[fr-1>>>6]<<-fr>>>-tr;\n\t\t\t}else{\n\t\t\t\tto[tr-1>>>6] ^= from[(fr-1>>>6)-1]>>>fl-tl ^ from[fr-1>>>6]<<-fr>>>-tr;\n\t\t\t}\n\t\t}else{\n\t\t\tto[tl>>>6] ^= from[fl>>>6]>>>fl<<tl;\n\t\t\tfor(int i = (tl>>>6)+1, j = (fl>>>6)+1;i <= (tr-1>>>6)-1;i++,j++){\n\t\t\t\tto[i] ^= from[j];\n\t\t\t}\n\t\t\tto[tr-1>>>6] ^= from[fr-1>>>6]<<-fr>>>-tr;\n\t\t}\n\t}\n\t\n//\t\t\n//\t\tint hba = -1;\n//\t\tfor(int i = 3999;i >= 0;i--){\n//\t\t\tif(basis[i]){\n//\t\t\t\thba = i;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n//\t\t\n//\t\tlong ans = 0;\n//\t\tint mod = 998244353;\n//\t\tboolean[] o = new boolean[4000];\n//\t\tfor(int i = 3999;i >= hba;i--){\n//\t\t\tif(X[i]){\n//\t\t\t\tans += pow(2, i-hba, mod);\n//\t\t\t}\n//\t\t\tif(X[i] != o[i]){\n//\t\t\t\tfor(int j = hba;j >= 0;j--){\n//\t\t\t\t\to[i-hba+j] ^= basis[j];\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n////\t\ttf(X);\n////\t\ttf(o);\n//\t\tboolean ok = true;\n//\t\tfor(int i = hba-1;i >= 0;i--){\n//\t\t\tif(!X[i] && o[i]){\n//\t\t\t\tok = false;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tif(X[i] &&!o[i]){\n//\t\t\t\tok = true;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n//\t\tif(ok)ans++;\n//\t\tout.println(ans%mod);\n//\t}\n\t\n\tpublic static void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final int HASH_MOD = (int) 1e9 + 7;\n\n    class MyNumber {\n        BitSet value;\n        int[] hash;\n        int[] firstOne;\n        int len;\n\n        MyNumber(BitSet s) {\n            value = s;\n            int slen = s.length();\n            hash = new int[slen + 1];\n            for (int i = 0; i < slen; i++) {\n                hash[i + 1] = (int) ((hash[i] * 29L + (s.get(s.length() - 1 - i) ? 1 : 0)) % HASH_MOD);\n            }\n            len = slen;\n            firstOne = new int[slen + 1];\n            firstOne[slen] = slen;\n            for (int i = slen - 1; i >= 0; i--) {\n                if (s.get(slen - 1 - i)) {\n                    firstOne[i] = i;\n                } else {\n                    firstOne[i] = firstOne[i + 1];\n                }\n            }\n        }\n\n        MyNumber(String s) {\n            this(read(s));\n        }\n\n        @Override\n        public String toString() {\n            return value.toString();\n        }\n    }\n\n    int MAX;\n\n    MyNumber[] numbers;\n\n    int getSameLen(MyNumber a, MyNumber b) {\n        int r = Math.min(a.len, b.len) + 1;\n        int l = 0;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            if (a.hash[m] == b.hash[m]) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        return l;\n    }\n\n    int calcLenOfDiff(MyNumber a, MyNumber b) {\n        if (a.len < b.len) {\n            return calcLenOfDiff(b, a);\n        }\n        int sameLen = getSameLen(a, b);\n        if (sameLen == b.len) {\n            int firstOne = a.firstOne[sameLen];\n            return a.len - firstOne;\n        } else {\n            return a.len - sameLen;\n        }\n    }\n\n    List<MyNumber> list = new ArrayList<>();\n\n    BitSet shiftLeft(BitSet x, int shift) {\n        if (x.cardinality() == 0) {\n            throw new AssertionError();\n        }\n        int len = x.length();\n        BitSet newOne = new BitSet(len + shift);\n        for (int i = 0; i < len; i++) {\n            if (x.get(i)) {\n                newOne.set(i + shift);\n            }\n        }\n        return newOne;\n    }\n\n    BitSet xor(BitSet one, BitSet two, int len) {\n        BitSet res = new BitSet(len);\n        for (int i = 0; i < len; i++) {\n            if (one.get(i) != two.get(i)) {\n                res.set(i);\n            }\n        }\n        return res;\n    }\n\n    void add(MyNumber number) {\n        if (numbers[number.len] == null) {\n            numbers[number.len] = number;\n        }\n        for (int i = 0; i < MAX; i++) {\n            if (numbers[i] != null) {\n\n                int diffLen = calcLenOfDiff(number, numbers[i]);\n                if (diffLen != 0 && numbers[diffLen] == null) {\n\n                    BitSet first = number.value;\n                    BitSet second = numbers[i].value;\n                    if (number.len > numbers[i].len) {\n                        second = shiftLeft(second, number.len - numbers[i].len);\n                    } else {\n                        first = shiftLeft(first, numbers[i].len - number.len);\n                    }\n                    MyNumber next = new MyNumber(xor(first, second, diffLen));\n                    numbers[diffLen] = next;\n                    if (next.len != diffLen) {\n                        throw new AssertionError();\n                    }\n                    list.add(next);\n                }\n\n            } else {\n\n                if (i > number.len) {\n                    MyNumber next = new MyNumber(shiftLeft(number.value, i - number.len));\n                    numbers[i] = next;\n                    if (next.len != i) {\n                        System.err.println(number + \" \" + i + \" \" + next + \" \" + (i - number.len));\n                        throw new AssertionError();\n                    }\n                    list.add(next);\n                }\n\n            }\n        }\n    }\n\n    MyNumber gcd(MyNumber a, MyNumber b) {\n        if (a == null) {\n            return b;\n        }\n        if (a.len < b.len) {\n            return gcd(b, a);\n        }\n        int shift = a.len - b.len;\n        BitSet next = new BitSet(a.len);\n        for (int i = 0; i < a.len; i++) {\n            boolean xx = a.value.get(i);\n            if (i >= shift) {\n                xx ^= b.value.get(i - shift);\n            }\n            if (xx) {\n                next.set(i);\n            }\n        }\n        if (next.cardinality() == 0) {\n            return b;\n        }\n        return gcd(b, new MyNumber(next));\n    }\n\n    BitSet read(String s) {\n        BitSet res = new BitSet(s.length());\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '1') {\n                res.set(s.length() - 1 - i);\n            }\n        }\n        return res;\n    }\n\n    private void solve() {\n        int n = in.nextInt();\n        long START = System.currentTimeMillis();\n        BitSet X = read(in.next());\n        MAX = X.length() + 5;\n        MyNumber GCD = null;\n        numbers = new MyNumber[MAX];\n        for (int i = 0; i < n; i++) {\n            MyNumber number = new MyNumber(in.next());\n            GCD = gcd(GCD, number);\n//            add(number);\n        }\n        add(GCD);\n        final int mod = 998244353;\n        BitSet current = new BitSet();\n        int[] pow2 = new int[MAX];\n        pow2[0] = 1;\n        for (int i = 1; i < MAX; i++) {\n            pow2[i] = pow2[i - 1];\n            if (numbers[i] != null) {\n                pow2[i] *= 2;\n                pow2[i] %= mod;\n            }\n        }\n        long result = 0;\n        boolean found = true;\n        for (int i = MAX - 2; i >= 0; i--) {\n            boolean xBit = X.get(i);\n            boolean myBit = current.get(i);\n            if (numbers[i + 1] != null) {\n                if (xBit) {\n                    result += pow2[i];\n                    if (!myBit) {\n                        current.xor(numbers[i + 1].value);\n                    }\n                } else {\n                    if (myBit) {\n                        current.xor(numbers[i + 1].value);\n                    }\n                }\n            } else {\n                if (xBit != myBit) {\n                    if (myBit) {\n                    } else {\n                        result += pow2[i + 1];\n                    }\n                    found = false;\n                    break;\n                }\n            }\n        }\n        if (found) {\n            result++;\n        }\n        out.println(result % mod);\n        System.err.println(System.currentTimeMillis() - START);\n    }\n\n    private void run() {\n        try {\n            in = new FastScanner(new File(\"ARC_084_D.in\"));\n            out = new PrintWriter(new File(\"ARC_084_D.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void runIO() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic boolean[] tob(char[] s)\n\t{\n\t\tboolean[] ret = new boolean[4000];\n\t\tfor(int i = 0;i < s.length;i++){\n\t\t\tret[i] = s[s.length-1-i] == '1';\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tboolean[] X = tob(ns().toCharArray());\n\t\tboolean[][] v = new boolean[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tv[i] = tob(ns().toCharArray());\n\t\t}\n\t\t\n\t\tboolean[] basis = null;\n\t\twhile(true){\n\t\t\tArrays.sort(v, new Comparator<boolean[]>() {\n\t\t\t\tpublic int compare(boolean[] a, boolean[] b) {\n\t\t\t\t\tfor(int i = 3999;i >= 0;i--){\n\t\t\t\t\t\tif(a[i] != b[i]){\n\t\t\t\t\t\t\tif(a[i])return 1;\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tboolean[] b = Arrays.copyOf(v[0], 4000);\n\t\t\t\n\t\t\tint[] h = new int[n];\n\t\t\tArrays.fill(h, -1);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 3999;j >= 0;j--){\n\t\t\t\t\tif(v[i][j]){\n\t\t\t\t\t\th[i] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1;i < n;i++){\n\t\t\t\tif(h[0] == h[i]){\n\t\t\t\t\tif(Arrays.equals(v[0], v[i]))continue;\n\t\t\t\t\tfor(int j = 0;j < 4000;j++){\n\t\t\t\t\t\tb[j] ^= v[1][j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\touter:\n//\t\t\tfor(int j = 3999;j >= 0;j--){\n//\t\t\t\tif(b[j]){\n//\t\t\t\t\tfor(int i = 1;i < n;i++){\n//\t\t\t\t\t\tif(h[i] == j){\n//\t\t\t\t\t\t\tfor(int k = 0;k <= j;k++){\n//\t\t\t\t\t\t\t\tb[k] ^= v[i][k];\n//\t\t\t\t\t\t\t\tcontinue outer;\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tint hb = -1;\n\t\t\tfor(int j = 3999;j >= 0;j--){\n\t\t\t\tif(b[j]){\n\t\t\t\t\thb = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint p = 0;\n\t\t\touter:\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 3999;j >= hb;j--){\n\t\t\t\t\tif(v[i][j]){\n\t\t\t\t\t\tfor(int k = 0;k <= hb;k++){\n\t\t\t\t\t\t\tv[i][j-hb+k] ^= b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = hb-1;k >= 0;k--){\n\t\t\t\t\tif(v[i][k]){\n\t\t\t\t\t\tv[p] = v[i];\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv = Arrays.copyOf(v, p);\n//\t\t\ttf(b);\n//\t\t\tfor(int i = 0;i < p;i++){\n//\t\t\t\ttf(v[i]);\n//\t\t\t}\n\t\t\tif(p == 0){\n\t\t\t\tbasis = b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = p;\n\t\t}\n\t\t\n\t\tint hba = -1;\n\t\tfor(int i = 3999;i >= 0;i--){\n\t\t\tif(basis[i]){\n\t\t\t\thba = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tint mod = 998244353;\n\t\tboolean[] o = new boolean[4000];\n\t\tfor(int i = 3999;i >= hba;i--){\n\t\t\tif(X[i]){\n\t\t\t\tans += pow(2, i-hba, mod);\n\t\t\t}\n\t\t\tif(X[i] != o[i]){\n\t\t\t\tfor(int j = hba;j >= 0;j--){\n\t\t\t\t\to[i-hba+j] ^= basis[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\ttf(X);\n//\t\ttf(o);\n\t\tboolean ok = true;\n\t\tfor(int i = hba-1;i >= 0;i--){\n\t\t\tif(!X[i] && o[i]){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(X[i] &&!o[i]){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)ans++;\n\t\tout.println(ans%mod);\n\t}\n\t\n\tpublic static void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\t// 101\n\t// 0001 -> 01\n\t\n\t// 01\n\t// 1\n\t\n\t\n\t\n\tstatic boolean[] tob(char[] s)\n\t{\n\t\tboolean[] ret = new boolean[4000];\n\t\tfor(int i = 0;i < s.length;i++){\n\t\t\tret[i] = s[s.length-1-i] == '1';\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tboolean[] X = tob(ns().toCharArray());\n\t\tboolean[][] v = new boolean[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tv[i] = tob(ns().toCharArray());\n\t\t}\n\t\t\n\t\tboolean[] basis = null;\n\t\twhile(true){\n\t\t\tArrays.sort(v, new Comparator<boolean[]>() {\n\t\t\t\tpublic int compare(boolean[] a, boolean[] b) {\n\t\t\t\t\tfor(int i = 3999;i >= 0;i--){\n\t\t\t\t\t\tif(a[i] != b[i]){\n\t\t\t\t\t\t\tif(a[i])return 1;\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tboolean[] b = Arrays.copyOf(v[0], 4000);\n\t\t\t\n\t\t\tint[] h = new int[n];\n\t\t\tArrays.fill(h, -1);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 3999;j >= 0;j--){\n\t\t\t\t\tif(v[i][j]){\n\t\t\t\t\t\th[i] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1;i < n;i++){\n\t\t\t\tif(h[0] == h[i]){\n\t\t\t\t\tif(Arrays.equals(v[0], v[i]))continue;\n\t\t\t\t\tfor(int j = 0;j < 4000;j++){\n\t\t\t\t\t\tb[j] ^= v[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\touter:\n//\t\t\tfor(int j = 3999;j >= 0;j--){\n//\t\t\t\tif(b[j]){\n//\t\t\t\t\tfor(int i = 1;i < n;i++){\n//\t\t\t\t\t\tif(h[i] == j){\n//\t\t\t\t\t\t\tfor(int k = 0;k <= j;k++){\n//\t\t\t\t\t\t\t\tb[k] ^= v[i][k];\n//\t\t\t\t\t\t\t\tcontinue outer;\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tint hb = -1;\n\t\t\tfor(int j = 3999;j >= 0;j--){\n\t\t\t\tif(b[j]){\n\t\t\t\t\thb = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint p = 0;\n\t\t\touter:\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 3999;j >= hb;j--){\n\t\t\t\t\tif(v[i][j]){\n\t\t\t\t\t\tfor(int k = 0;k <= hb;k++){\n\t\t\t\t\t\t\tv[i][j-hb+k] ^= b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = hb-1;k >= 0;k--){\n\t\t\t\t\tif(v[i][k]){\n\t\t\t\t\t\tv[p] = v[i];\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv = Arrays.copyOf(v, p+1);\n\t\t\tv[p] = b;\n\t\t\t\n//\t\t\ttr();\n//\t\t\ttf(b);\n//\t\t\tfor(int i = 0;i < p;i++){\n//\t\t\t\ttf(v[i]);\n//\t\t\t}\n\t\t\tif(p == 0){\n\t\t\t\tbasis = b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = p+1;\n\t\t}\n\t\t\n\t\tint hba = -1;\n\t\tfor(int i = 3999;i >= 0;i--){\n\t\t\tif(basis[i]){\n\t\t\t\thba = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tint mod = 998244353;\n\t\tboolean[] o = new boolean[4000];\n\t\tfor(int i = 3999;i >= hba;i--){\n\t\t\tif(X[i]){\n\t\t\t\tans += pow(2, i-hba, mod);\n\t\t\t}\n\t\t\tif(X[i] != o[i]){\n\t\t\t\tfor(int j = hba;j >= 0;j--){\n\t\t\t\t\to[i-hba+j] ^= basis[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\ttf(X);\n//\t\ttf(o);\n\t\tboolean ok = true;\n\t\tfor(int i = hba-1;i >= 0;i--){\n\t\t\tif(!X[i] && o[i]){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(X[i] &&!o[i]){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)ans++;\n\t\tout.println(ans%mod);\n\t}\n\t\n\tpublic static void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final int HASH_MOD = (int) 1e9 + 7;\n\n    class MyNumber {\n        BitSet value;\n        int[] hash;\n        int[] firstOne;\n        int len;\n\n        MyNumber(BitSet s) {\n            value = s;\n            int slen = s.length();\n            hash = new int[slen + 1];\n            for (int i = 0; i < slen; i++) {\n                hash[i + 1] = (int) ((hash[i] * 29L + (s.get(s.length() - 1 - i) ? 1 : 0)) % HASH_MOD);\n            }\n            len = slen;\n            firstOne = new int[slen + 1];\n            firstOne[slen] = slen;\n            for (int i = slen - 1; i >= 0; i--) {\n                if (s.get(slen - 1 - i)) {\n                    firstOne[i] = i;\n                } else {\n                    firstOne[i] = firstOne[i + 1];\n                }\n            }\n        }\n\n        MyNumber(String s) {\n            this(read(s));\n        }\n\n        @Override\n        public String toString() {\n            return value.toString();\n        }\n    }\n\n    int MAX;\n\n    MyNumber[] numbers;\n\n    int getSameLen(MyNumber a, MyNumber b) {\n        int r = Math.min(a.len, b.len) + 1;\n        int l = 0;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            if (a.hash[m] == b.hash[m]) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        return l;\n    }\n\n    int calcLenOfDiff(MyNumber a, MyNumber b) {\n        if (a.len < b.len) {\n            return calcLenOfDiff(b, a);\n        }\n        int sameLen = getSameLen(a, b);\n        if (sameLen == b.len) {\n            int firstOne = a.firstOne[sameLen];\n            return a.len - firstOne;\n        } else {\n            return a.len - sameLen;\n        }\n    }\n\n    List<MyNumber> list = new ArrayList<>();\n\n    BitSet shiftLeft(BitSet x, int shift) {\n        if (x.cardinality() == 0) {\n            throw new AssertionError();\n        }\n        int len = x.length();\n        BitSet newOne = new BitSet(len + shift);\n        for (int i = 0; i < len; i++) {\n            if (x.get(i)) {\n                newOne.set(i + shift);\n            }\n        }\n        return newOne;\n    }\n\n    BitSet xor(BitSet one, BitSet two, int len) {\n        BitSet res = new BitSet(len);\n        for (int i = 0; i < len; i++) {\n            if (one.get(i) != two.get(i)) {\n                res.set(i);\n            }\n        }\n        return res;\n    }\n\n    void add(MyNumber number) {\n        if (numbers[number.len] == null) {\n            numbers[number.len] = number;\n        }\n        for (int i = 0; i < MAX; i++) {\n            if (numbers[i] != null) {\n\n                int diffLen = calcLenOfDiff(number, numbers[i]);\n                if (diffLen != 0 && numbers[diffLen] == null) {\n\n                    BitSet first = number.value;\n                    BitSet second = numbers[i].value;\n                    if (number.len > numbers[i].len) {\n                        second = shiftLeft(second, number.len - numbers[i].len);\n                    } else {\n                        first = shiftLeft(first, numbers[i].len - number.len);\n                    }\n                    MyNumber next = new MyNumber(xor(first, second, diffLen));\n                    numbers[diffLen] = next;\n                    if (next.len != diffLen) {\n                        throw new AssertionError();\n                    }\n                    list.add(next);\n                }\n\n            } else {\n\n                if (i > number.len) {\n                    MyNumber next = new MyNumber(shiftLeft(number.value, i - number.len));\n                    numbers[i] = next;\n                    if (next.len != i) {\n                        System.err.println(number + \" \" + i + \" \" + next + \" \" + (i - number.len));\n                        throw new AssertionError();\n                    }\n                    list.add(next);\n                }\n\n            }\n        }\n    }\n\n    BitSet read(String s) {\n        BitSet res = new BitSet(s.length());\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '1') {\n                res.set(s.length() - 1 - i);\n            }\n        }\n        return res;\n    }\n\n    private void solve() {\n        int n = in.nextInt();\n        long START = System.currentTimeMillis();\n        BitSet X = read(in.next());\n        MAX = X.length() + 5;\n        numbers = new MyNumber[MAX];\n        for (int i = 0; i < n; i++) {\n            MyNumber number = new MyNumber(in.next());\n            add(number);\n        }\n        while (list.size() > 0) {\n            MyNumber last = list.get(list.size() - 1);\n            list.remove(list.size() - 1);\n            add(last);\n        }\n        final int mod = 998244353;\n        BitSet current = new BitSet();\n        int[] pow2 = new int[MAX];\n        pow2[0] = 1;\n        for (int i = 1; i < MAX; i++) {\n            pow2[i] = pow2[i - 1];\n            if (numbers[i] != null) {\n                pow2[i] *= 2;\n                pow2[i] %= mod;\n            }\n        }\n        long result = 0;\n        boolean found = true;\n        for (int i = MAX - 2; i >= 0; i--) {\n            boolean xBit = X.get(i);\n            boolean myBit = current.get(i);\n            if (numbers[i + 1] != null) {\n                if (xBit) {\n                    result += pow2[i];\n                    if (!myBit) {\n                        current.xor(numbers[i + 1].value);\n                    }\n                } else {\n                    if (myBit) {\n                        current.xor(numbers[i + 1].value);\n                    }\n                }\n            } else {\n                if (xBit != myBit) {\n                    if (myBit) {\n                        found = false;\n                        break;\n                    } else {\n                        result += pow2[i + 1];\n                    }\n                }\n            }\n        }\n        if (found) {\n            result++;\n        }\n        out.println(result % mod);\n        System.err.println(System.currentTimeMillis() - START);\n    }\n\n    private void run() {\n        try {\n            in = new FastScanner(new File(\"ARC_084_D.in\"));\n            out = new PrintWriter(new File(\"ARC_084_D.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void runIO() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final int HASH_MOD = (int) 1e9 + 7;\n\n    class MyNumber {\n        BigInteger value;\n        int[] hash;\n        int[] firstOne;\n        int len;\n\n        MyNumber(String s) {\n            value = new BigInteger(s, 2);\n            hash = new int[s.length() + 1];\n            for (int i = 0; i < s.length(); i++) {\n                hash[i + 1] = (int) ((hash[i] * 29L + s.charAt(i) - '0') % HASH_MOD);\n            }\n            len = s.length();\n            firstOne = new int[s.length() + 1];\n            firstOne[s.length()] = s.length();\n            for (int i = s.length() - 1; i >= 0; i--) {\n                if (s.charAt(i) == '1') {\n                    firstOne[i] = i;\n                } else {\n                    firstOne[i] = firstOne[i + 1];\n                }\n            }\n        }\n\n        @Override\n        public String toString() {\n            return value.toString(2);\n        }\n    }\n\n    final int MAX = 1010;\n\n    MyNumber[] numbers = new MyNumber[MAX];\n\n    int getSameLen(MyNumber a, MyNumber b) {\n        int r = Math.min(a.len, b.len) + 1;\n        int l = 0;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            if (a.hash[m] == b.hash[m]) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        return l;\n    }\n\n    int calcLenOfDiff(MyNumber a, MyNumber b) {\n        if (a.len < b.len) {\n            return calcLenOfDiff(b, a);\n        }\n        int sameLen = getSameLen(a, b);\n        if (sameLen == b.len) {\n            int firstOne = a.firstOne[sameLen];\n            return a.len - firstOne;\n        } else {\n            return a.len - sameLen;\n        }\n    }\n\n    List<MyNumber> list = new ArrayList<>();\n\n    void add(MyNumber number) {\n        if (numbers[number.len] == null) {\n            numbers[number.len] = number;\n        }\n        for (int i = 0; i < MAX; i++) {\n            if (numbers[i] != null) {\n                int diffLen = calcLenOfDiff(number, numbers[i]);\n                if (diffLen != 0 && numbers[diffLen] == null) {\n                    BigInteger first = number.value;\n                    BigInteger second = numbers[i].value;\n                    if (number.len > numbers[i].len) {\n                        second = second.shiftLeft(number.len - numbers[i].len);\n                    } else {\n                        first = first.shiftLeft(numbers[i].len - number.len);\n                    }\n                    MyNumber next = new MyNumber(first.xor(second).toString(2));\n                    numbers[diffLen] = next;\n                    if (next.len != diffLen) {\n                        throw new AssertionError();\n                    }\n                    list.add(next);\n                }\n            } else {\n                if (i > number.len) {\n                    MyNumber next = new MyNumber(number.value.shiftLeft(i - number.len).toString(2));\n                    numbers[i] = next;\n                    list.add(next);\n                }\n            }\n        }\n    }\n\n    private void solve() {\n        int n = in.nextInt();\n        long START = System.currentTimeMillis();\n        BigInteger X = new BigInteger(in.next(), 2);\n        for (int i = 0; i < n; i++) {\n            MyNumber number = new MyNumber(in.next());\n            add(number);\n        }\n        while (list.size() > 0) {\n            MyNumber last = list.get(list.size() - 1);\n            list.remove(list.size() - 1);\n            add(last);\n        }\n        final int mod = 998244353;\n        BigInteger current = BigInteger.ZERO;\n        int[] pow2 = new int[MAX];\n        pow2[0] = 1;\n        for (int i = 1; i < MAX; i++) {\n            pow2[i] = pow2[i - 1];\n            if (numbers[i] != null) {\n                pow2[i] *= 2;\n                pow2[i] %= mod;\n            }\n        }\n        long result = 0;\n        boolean found = true;\n        for (int i = MAX - 2; i >= 0; i--) {\n            boolean xBit = X.testBit(i);\n            boolean myBit = current.testBit(i);\n            if (numbers[i + 1] != null) {\n                if (xBit) {\n                    result += pow2[i];\n                    if (!myBit) {\n                        current = current.xor(numbers[i + 1].value);\n                    }\n                } else {\n                    if (myBit) {\n                        current = current.xor(numbers[i + 1].value);\n                    }\n                }\n            } else {\n                if (xBit != myBit) {\n                    if (myBit) {\n                        found = false;\n                        break;\n                    } else {\n                        result += pow2[i + 1];\n                    }\n                }\n            }\n        }\n        if (found) {\n            result++;\n        }\n        out.println(result % mod);\n        System.err.println(System.currentTimeMillis() - START);\n    }\n\n    private void run() {\n        try {\n            in = new FastScanner(new File(\"ARC_084_D.in\"));\n            out = new PrintWriter(new File(\"ARC_084_D.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void runIO() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class Poly {\n\t\tint[] coef;\n\t\tint lead;\n\n\t\tpublic Poly(int[] coef, int lead) {\n\t\t\tthis.coef = coef;\n\t\t\tthis.lead = lead;\n\t\t}\n\n\t\tvoid trim() {\n\t\t\twhile (lead >= 0 && coef[lead] == 0) {\n\t\t\t\tlead--;\n\t\t\t}\n\t\t}\n\t}\n\n\tPoly getPoly() {\n\t\tString s = nextToken();\n\t\tint[] coef = new int[s.length()];\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tcoef[i] = s.charAt(s.length() - 1 - i) - '0';\n\t\t}\n\t\treturn new Poly(coef, coef.length - 1);\n\t}\n\n\tvoid divideLeading(Poly a, Poly b) {\n\t\t// b.lead -> a.lead\n\t\t// b.lead-1 -> a.lead-1\n\t\tfor (int i = 0; i <= b.lead; i++) {\n\t\t\ta.coef[i + a.lead - b.lead] ^= b.coef[i];\n\t\t}\n\t\ta.trim();\n\t}\n\n\tPoly gcd(Poly a, Poly b) {\n\t\tif (a.lead < b.lead) {\n\t\t\tPoly tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\tif (b.lead == -1) {\n\t\t\treturn a;\n\t\t}\n\t\tdivideLeading(a, b);\n\t\treturn gcd(b, a);\n\t}\n\n\tstatic final int P = 998244353;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tPoly x = getPoly();\n\n\t\tPoly g = getPoly();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tPoly p = getPoly();\n\t\t\tg = gcd(g, p);\n\t\t}\n\n\t\tint[] gcd = Arrays.copyOf(g.coef, g.lead + 1);\n\t\t\n//\t\tSystem.err.println(Arrays.toString(gcd));\n\n\t\tint[] our = Arrays.copyOf(x.coef, Math.max(x.lead + 1, gcd.length));\n\n\t\tint valLess = 0;\n//\t\tfor (int i = gcd.length - 1; i < our.length; i++) {\n\t\tfor (int i = our.length - 1; i >= gcd.length - 1; i--) {\n\t\t\tvalLess = (valLess * 2 + our[i]) % P;\n\t\t}\n\n\t\tPoly xx = new Poly(x.coef.clone(), x.lead);\n\t\tfor (int i = 0; i < gcd.length - 1; i++) {\n\t\t\tif (i < xx.coef.length) {\n\t\t\t\txx.coef[i] = 0;\n\t\t\t}\n\t\t}\n\t\txx.trim();\n\t\twhile (xx.lead >= g.lead) {\n\t\t\tdivideLeading(xx, g);\n\t\t}\n\t\t\n\t\tint[] gMult = Arrays.copyOf(xx.coef, gcd.length - 1);\n\t\t\n\t\tif (compare(gMult, Arrays.copyOf(x.coef, gcd.length - 1)) <= 0) {\n\t\t\tvalLess++;\n\t\t\tif (valLess >= P) {\n\t\t\t\tvalLess -= P;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(valLess);\n\t}\n\t\n\tint compare(int[] a, int[] b){\n\t\tif (a.length != b.length) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\t\t\n\t\tfor (int i = b.length - 1; i >= 0; i--) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\treturn a[i] < b[i] ? -1 : 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic boolean[] tob(char[] s)\n\t{\n\t\tboolean[] ret = new boolean[4000];\n\t\tfor(int i = 0;i < s.length;i++){\n\t\t\tret[i] = s[s.length-1-i] == '1';\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tboolean[] X = tob(ns().toCharArray());\n\t\tboolean[][] v = new boolean[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tv[i] = tob(ns().toCharArray());\n\t\t}\n\t\t\n\t\tboolean[] basis = null;\n\t\twhile(true){\n\t\t\tArrays.sort(v, new Comparator<boolean[]>() {\n\t\t\t\tpublic int compare(boolean[] a, boolean[] b) {\n\t\t\t\t\tfor(int i = 3999;i >= 0;i--){\n\t\t\t\t\t\tif(a[i] != b[i]){\n\t\t\t\t\t\t\tif(a[i])return 1;\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tboolean[] b = Arrays.copyOf(v[0], 4000);\n\t\t\t\n\t\t\tint[] h = new int[n];\n\t\t\tArrays.fill(h, -1);\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 3999;j >= 0;j--){\n\t\t\t\t\tif(v[i][j]){\n\t\t\t\t\t\th[i] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1;i < n;i++){\n\t\t\t\tif(h[0] == h[i]){\n\t\t\t\t\tif(Arrays.equals(v[0], v[i]))continue;\n\t\t\t\t\tfor(int j = 0;j < 4000;j++){\n\t\t\t\t\t\tb[j] ^= v[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\touter:\n//\t\t\tfor(int j = 3999;j >= 0;j--){\n//\t\t\t\tif(b[j]){\n//\t\t\t\t\tfor(int i = 1;i < n;i++){\n//\t\t\t\t\t\tif(h[i] == j){\n//\t\t\t\t\t\t\tfor(int k = 0;k <= j;k++){\n//\t\t\t\t\t\t\t\tb[k] ^= v[i][k];\n//\t\t\t\t\t\t\t\tcontinue outer;\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tint hb = -1;\n\t\t\tfor(int j = 3999;j >= 0;j--){\n\t\t\t\tif(b[j]){\n\t\t\t\t\thb = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint p = 0;\n\t\t\touter:\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 3999;j >= hb;j--){\n\t\t\t\t\tif(v[i][j]){\n\t\t\t\t\t\tfor(int k = 0;k <= hb;k++){\n\t\t\t\t\t\t\tv[i][j-hb+k] ^= b[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = hb-1;k >= 0;k--){\n\t\t\t\t\tif(v[i][k]){\n\t\t\t\t\t\tv[p] = v[i];\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv = Arrays.copyOf(v, p);\n//\t\t\ttf(b);\n//\t\t\tfor(int i = 0;i < p;i++){\n//\t\t\t\ttf(v[i]);\n//\t\t\t}\n\t\t\tif(p == 0){\n\t\t\t\tbasis = b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = p;\n\t\t}\n\t\t\n\t\tint hba = -1;\n\t\tfor(int i = 3999;i >= 0;i--){\n\t\t\tif(basis[i]){\n\t\t\t\thba = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tint mod = 998244353;\n\t\tboolean[] o = new boolean[4000];\n\t\tfor(int i = 3999;i >= hba;i--){\n\t\t\tif(X[i]){\n\t\t\t\tans += pow(2, i-hba, mod);\n\t\t\t}\n\t\t\tif(X[i] != o[i]){\n\t\t\t\tfor(int j = hba;j >= 0;j--){\n\t\t\t\t\to[i-hba+j] ^= basis[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\ttf(X);\n//\t\ttf(o);\n\t\tboolean ok = true;\n\t\tfor(int i = hba-1;i >= 0;i--){\n\t\t\tif(!X[i] && o[i]){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(X[i] &&!o[i]){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)ans++;\n\t\tout.println(ans%mod);\n\t}\n\t\n\tpublic static void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class ARC_084_DOK {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final int HASH_MOD = (int) 1e9 + 7;\n\n    class MyNumber {\n        BitSet value;\n        int[] hash;\n        int[] firstOne;\n        int len;\n\n        MyNumber(BitSet s) {\n            value = s;\n            int slen = s.length();\n            hash = new int[slen + 1];\n            for (int i = 0; i < slen; i++) {\n                hash[i + 1] = (int) ((hash[i] * 29L + (s.get(s.length() - 1 - i) ? 1 : 0)) % HASH_MOD);\n            }\n            len = slen;\n            firstOne = new int[slen + 1];\n            firstOne[slen] = slen;\n            for (int i = slen - 1; i >= 0; i--) {\n                if (s.get(slen - 1 - i)) {\n                    firstOne[i] = i;\n                } else {\n                    firstOne[i] = firstOne[i + 1];\n                }\n            }\n        }\n\n        MyNumber(String s) {\n            this(read(s));\n        }\n\n        @Override\n        public String toString() {\n            return value.toString();\n        }\n    }\n\n    int MAX;\n\n    MyNumber[] numbers;\n\n    int getSameLen(MyNumber a, MyNumber b) {\n        int r = Math.min(a.len, b.len) + 1;\n        int l = 0;\n        while (r - l > 1) {\n            int m = (l + r) >> 1;\n            if (a.hash[m] == b.hash[m]) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        return l;\n    }\n\n    int calcLenOfDiff(MyNumber a, MyNumber b) {\n        if (a.len < b.len) {\n            return calcLenOfDiff(b, a);\n        }\n        int sameLen = getSameLen(a, b);\n        if (sameLen == b.len) {\n            int firstOne = a.firstOne[sameLen];\n            return a.len - firstOne;\n        } else {\n            return a.len - sameLen;\n        }\n    }\n\n    List<MyNumber> list = new ArrayList<>();\n\n    BitSet shiftLeft(BitSet x, int shift) {\n        if (x.cardinality() == 0) {\n            throw new AssertionError();\n        }\n        int len = x.length();\n        BitSet newOne = new BitSet(len + shift);\n        for (int i = 0; i < len; i++) {\n            if (x.get(i)) {\n                newOne.set(i + shift);\n            }\n        }\n        return newOne;\n    }\n\n    BitSet xor(BitSet one, BitSet two, int len) {\n        BitSet res = new BitSet(len);\n        for (int i = 0; i < len; i++) {\n            if (one.get(i) != two.get(i)) {\n                res.set(i);\n            }\n        }\n        return res;\n    }\n\n    void add(MyNumber number) {\n        if (numbers[number.len] == null) {\n            numbers[number.len] = number;\n        }\n        for (int i = 0; i < MAX; i++) {\n            if (numbers[i] != null) {\n\n                int diffLen = calcLenOfDiff(number, numbers[i]);\n                if (diffLen != 0 && numbers[diffLen] == null) {\n\n                    BitSet first = number.value;\n                    BitSet second = numbers[i].value;\n                    if (number.len > numbers[i].len) {\n                        second = shiftLeft(second, number.len - numbers[i].len);\n                    } else {\n                        first = shiftLeft(first, numbers[i].len - number.len);\n                    }\n                    MyNumber next = new MyNumber(xor(first, second, diffLen));\n                    numbers[diffLen] = next;\n                    if (next.len != diffLen) {\n                        throw new AssertionError();\n                    }\n                    list.add(next);\n                }\n\n            } else {\n\n                if (i > number.len) {\n                    MyNumber next = new MyNumber(shiftLeft(number.value, i - number.len));\n                    numbers[i] = next;\n                    if (next.len != i) {\n                        System.err.println(number + \" \" + i + \" \" + next + \" \" + (i - number.len));\n                        throw new AssertionError();\n                    }\n                    list.add(next);\n                }\n\n            }\n        }\n    }\n\n    BitSet read(String s) {\n        BitSet res = new BitSet(s.length());\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '1') {\n                res.set(s.length() - 1 - i);\n            }\n        }\n        return res;\n    }\n\n    private void solve() {\n        int n = in.nextInt();\n        long START = System.currentTimeMillis();\n        BitSet X = read(in.next());\n        MAX = X.length() + 5;\n        numbers = new MyNumber[MAX];\n        for (int i = 0; i < n; i++) {\n            MyNumber number = new MyNumber(in.next());\n            add(number);\n        }\n        while (list.size() > 0) {\n            MyNumber last = list.get(list.size() - 1);\n            list.remove(list.size() - 1);\n            add(last);\n        }\n        final int mod = 998244353;\n        BitSet current = new BitSet();\n        int[] pow2 = new int[MAX];\n        pow2[0] = 1;\n        for (int i = 1; i < MAX; i++) {\n            pow2[i] = pow2[i - 1];\n            if (numbers[i] != null) {\n                pow2[i] *= 2;\n                pow2[i] %= mod;\n            }\n        }\n        long result = 0;\n        boolean found = true;\n        for (int i = MAX - 2; i >= 0; i--) {\n            boolean xBit = X.get(i);\n            boolean myBit = current.get(i);\n            if (numbers[i + 1] != null) {\n                if (xBit) {\n                    result += pow2[i];\n                    if (!myBit) {\n                        current.xor(numbers[i + 1].value);\n                    }\n                } else {\n                    if (myBit) {\n                        current.xor(numbers[i + 1].value);\n                    }\n                }\n            } else {\n                if (xBit != myBit) {\n                    if (myBit) {\n                        found = false;\n                        break;\n                    } else {\n                        result += pow2[i + 1];\n                    }\n                }\n            }\n        }\n        if (found) {\n            result++;\n        }\n        out.println(result % mod);\n        System.err.println(System.currentTimeMillis() - START);\n    }\n\n    private void run() {\n        try {\n            in = new FastScanner(new File(\"ARC_084_D.in\"));\n            out = new PrintWriter(new File(\"ARC_084_D.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void runIO() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new ARC_084_DOK().runIO();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        bool[] X;\n        {\n            string S = re.s();\n            X = new bool[S.Length];\n            for(int i=0;i<S.Length;i++){\n                X[i] = S[S.Length-1-i] == '1';\n            }\n        }\n        bool[] B = new bool[0];\n        for(int i=0;i<N;i++){\n            string S = re.s();\n            bool[] C = new bool[S.Length];\n            for(int j=0;j<S.Length;j++){\n                C[j] = S[S.Length-1-j] == '1';\n            }\n            if(i == 0){\n                B = C;\n            }\n            else{\n                B = gcd(B,C);\n            }\n        }\n        long count = 0;\n        if(X.Length < B.Length){\n            count = 1;\n        }\n        else{\n            for(int i=0;i<X.Length-B.Length+1;i++){\n                count *= 2;\n                if(X[X.Length-1-i]){\n                    count++;\n                }\n                count %= Define.mod;\n            }\n            count++;\n            count %= Define.mod;\n            bool[] XC = new bool[X.Length];\n            for(int i=X.Length-1;i>=B.Length-1;i--){\n                if(XC[i] != X[i]){\n                    for(int j=i;j>=i-B.Length+1;j--){\n                        XC[j] ^= B[j-i+B.Length-1];\n                    }\n                }\n            }\n            for(int i=0;i<X.Length;i++){\n                if(X[i] && !XC[i]){\n                    break;\n                }\n                if(!X[i] && XC[i]){\n                    count = (count + Define.mod - 1) % Define.mod;\n                    break;\n                }\n            }\n        }\n        sb.Append(count+\"\\n\");\n    }\n    bool[] gcd(bool[] X,bool[] Y){\n        if(X.Length < Y.Length){\n            bool[] temp = X;\n            X = Y;\n            Y = temp;\n        }\n        for(int i=X.Length-1;i>=Y.Length-1;i--){\n            if(X[i]){\n                for(int j=i;j>=i-Y.Length+1;j--){\n                    X[j] = X[j] ^ Y[Y.Length-1-i+j];\n                }\n            }\n        }\n        int p = Y.Length-2;\n        while(p >= 0 && !X[p]){\n            p--;\n        }\n        if(p == -1){\n            return Y;\n        }\n        else{\n            bool[] ans = new bool[p+1];\n            for(int i=0;i<=p;i++){\n                ans[i] = X[i];\n            }\n            return gcd(ans,Y);\n        }\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 998244353;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        bool[] X;\n        {\n            string S = re.s();\n            X = new bool[S.Length];\n            for(int i=0;i<S.Length;i++){\n                X[i] = S[S.Length-1-i] == '1';\n            }\n        }\n        bool[] B = new bool[0];\n        for(int i=0;i<N;i++){\n            string S = re.s();\n            bool[] C = new bool[S.Length];\n            for(int j=0;j<S.Length;j++){\n                C[j] = S[S.Length-1-j] == '1';\n            }\n            if(i == 0){\n                B = C;\n            }\n            else{\n                B = gcd(B,C);\n            }\n        }\n        long count = 0;\n        if(X.Length < B.Length){\n            count = 1;\n        }\n        else{\n            for(int i=0;i<X.Length-B.Length+1;i++){\n                count *= 2;\n                if(X[X.Length-1-i]){\n                    count++;\n                }\n                count %= Define.mod;\n            }\n            count++;\n            count %= Define.mod;\n            bool[] XC = new bool[X.Length];\n            for(int i=X.Length-1;i>=B.Length-1;i--){\n                if(XC[i] != X[i]){\n                    for(int j=i;j>=i-B.Length+1;j--){\n                        XC[j] ^= B[j-i+B.Length-1];\n                    }\n                }\n            }\n            for(int i=X.Length-1;i>=0;i--){\n                if(X[i] && !XC[i]){\n                    break;\n                }\n                if(!X[i] && XC[i]){\n                    count = (count + Define.mod - 1) % Define.mod;\n                    break;\n                }\n            }\n        }\n        sb.Append(count+\"\\n\");\n    }\n    bool[] gcd(bool[] X,bool[] Y){\n        if(X.Length < Y.Length){\n            bool[] temp = X;\n            X = Y;\n            Y = temp;\n        }\n        for(int i=X.Length-1;i>=Y.Length-1;i--){\n            if(X[i]){\n                for(int j=i;j>=i-Y.Length+1;j--){\n                    X[j] = X[j] ^ Y[Y.Length-1-i+j];\n                }\n            }\n        }\n        int p = Y.Length-2;\n        while(p >= 0 && !X[p]){\n            p--;\n        }\n        if(p == -1){\n            return Y;\n        }\n        else{\n            bool[] ans = new bool[p+1];\n            for(int i=0;i<=p;i++){\n                ans[i] = X[i];\n            }\n            return gcd(ans,Y);\n        }\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 998244353;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "Go",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nusing bits = bitset<4000>;\n\nint main() {\n\n  auto bitlen = [](const bits& a) {\n    for(i64 j = 4000; j --> 0;) {\n      if(a[j]) {\n        return j + 1;\n      }\n    }\n    return 0ll;\n  };\n\n  i64 N;\n  cin >> N;\n  bits X;\n  i64 xs;\n  cin >> X;\n  xs = bitlen(X);\n\n  vector<bits> A(N);\n  vector<i64> S(N);\n  rep(i,0,N) {\n    cin >> A[i];\n    S[i] = bitlen(A[i]);\n  }\n  auto bitmod = [](bits a, i64 as, bits b, i64 bs) {\n    for(i64 i = as - bs + 1; i --> 0;) {\n      if(a[i + bs - 1]) {\n        a ^= (b << i);\n      }\n    }\n    return a;\n  };\n\n  auto bitgcd = [&](bits a, i64 as, bits b, i64 bs) {\n    while(b.any()) {\n      auto m = bitmod(a, as, b, bs);\n      a = b;\n      as = bs;\n      b = m;\n      bs = bitlen(b);\n    }\n    return pair<bits, i64>(a, as);\n  };\n\n  auto g = A[0];\n  auto gs = S[0];\n  for(i64 i = 1; i < N; i++) {\n    auto p = bitgcd(g, gs, A[i], S[i]);\n    g = p.first;\n    gs = p.second;\n  }\n  i64 ans = 0;\n  const i64 MOD = 998244353;\n  vector<i64> Bs(xs - gs + 1, 1);\n  for(i64 i = 1; i < xs - gs + 1; i++) {\n    Bs[i] = (Bs[i - 1] * 2) % MOD;\n  } \n  bits now;\n  for(i64 i = xs - gs + 1; i --> 0;) {\n    if(X[i + gs - 1]) {\n      ans = (ans + Bs[i]) % MOD;\n    }\n    if(now[i + gs - 1] != X[i + gs - 1]) {\n      now ^= (g << i);\n    }\n  }\n  if(bitmod(X, xs, now, bitlen(now)) != X) { ans = (ans + 1) % MOD; }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nimmutable long MOD = 998244353;\n\nint[] gcd(int[] a, int[] b) {\n    while (true) {\n        if (a.length < b.length) swap(a, b);\n        if (b.length == 0) return a.dup;\n        ulong msb = a.length;\n\n        foreach (i; 0..a.length) {\n            if (i < b.length) {\n                a[i] ^= b[i];\n            }\n            if (a[i]) {\n                msb = min(i, msb);\n            }\n        }\n\n        a = a[msb..$];\n    }\n}\n\nvoid main() {\n    auto s = readln.split;\n    auto N = s[0].to!int;\n    auto X = s[1].map!(a => to!int(a == '1')).array;\n    auto P = N.iota.map!(_ => readln.chomp.map!(a => to!int(a == '1')).array).array;\n\n    auto G = P.front.dup;\n    foreach (i; 1..N) G = gcd(G, P[i].dup);\n\n    long ans = 0;\n\n    for (long i = X.length.to!long - G.length.to!long, tmp = 1; i >= 0; i -= 1, tmp = tmp * 2 % MOD) {\n        if (X[i]) {\n            ans = (ans + tmp) % MOD;\n        }\n    }\n\n\n    auto M = new int[](X.length);\n\n    for (int i = 0; i + G.length <= M.length; ++i) {\n        if (M[i] != X[i]) {\n            for (int j = 0; j < G.length; ++j) {\n                M[i+j] ^= G[j];\n            }\n        }\n    }\n\n    if (M <= X) {\n        ans = (ans + 1)  % MOD;\n    }\n\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\nbool[] rem(bool[] a, bool[] b) {\n    if (a.length < b.length) return a;\n    b.length = a.length;\n    bool[] c = new bool[a.length];\n    c[] = a[] ^ b[];\n    size_t i = 0;\n    while (i < a.length && !c[i]) i++;\n    return c[i..$];\n}\n\nbool[] gcd(bool[] a, bool[] b) {\n//    writeln(\"GCD \", a, \" \", b);\n    if (!b.length) return a;\n    return gcd(b, rem(a, b));\n}\n\n// import dcomp.modint, dcomp.numeric.primitive;\nalias Mint = ModInt!(998244353);\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    int n; string X;\n    sc.read(n, X);\n    bool[] x = X.map!\"a=='1'\".array;\n\n    bool[] g = [];\n    foreach (i; 0..n) {\n        string Y;\n        sc.read(Y);\n        bool[] y = Y.map!\"a=='1'\".array;\n//        writeln(g, \" \", y, \"GCD->\");\n//        writeln(gcd(g, y));\n        g = gcd(g, y);\n    }\n//    writeln(g);\n    int A = x.length.to!int, B = g.length.to!int;\n    if (A < B) {\n        writeln(0);\n        return 0;\n    }\n    bool[] z = new bool[A];\n    Mint sm = 1;\n    foreach (i; 0..A-B+1) {\n        if (!x[i]) {\n            if (z[i]) {\n                foreach (j; 0..B) {\n                    z[i+j] ^= g[j];\n                }                \n            }\n            continue;\n        }\n        //rnk(A-i-1)\n//        writeln(\"WOW \", pow(Mint(2), A-i-1-B));\n        sm += pow(Mint(2), A-i-B);\n        if (!z[i]) {\n            foreach (j; 0..B) {\n                z[i+j] ^= g[j];\n            }\n        }\n    }\n    writeln(sm);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n\nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    while (n) {\n        if (n & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        n >>= 1;\n    }\n    return r % md;\n}\n\nulong ulongPowMod(U)(ulong x, U n, ulong md)\nif (isIntegral!U || is(U == BigInt)) {\n//     import dcomp.int128;\n    x %= md;\n    ulong r = 1;\n    while (n) {\n        if (n & 1) {\n            r = mul128(r, x).mod128(md);\n        }\n        x = mul128(x, x).mod128(md);\n        n >>= 1;\n    }\n    return r % md;\n}\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/ldc/inline.d */\n// module dcomp.ldc.inline;\n\nversion(LDC) {\n    pragma(LDC_inline_ir)\n        R inlineIR(string s, R, P...)(P);\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\nimport core.bitop : popcnt;\nstatic if (!__traits(compiles, popcnt(ulong.max))) {\n    public import core.bitop : popcnt;\n    int popcnt(ulong v) {\n        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));\n    }\n}\n\nbool poppar(ulong v) {\n    v^=v>>1;\n    v^=v>>2;\n    v&=0x1111111111111111UL;\n    v*=0x1111111111111111UL;\n    return ((v>>60) & 1) != 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/int128.d */\n \n\n// module dcomp.int128;\n\n// import dcomp.array;\n\nversion(LDC) {\n//     import dcomp.ldc.inline;\n}\n\nversion(LDC) version(X86_64) {\n    version = LDC_IR;\n}\n\n \nulong[2] mul128(ulong a, ulong b) {\n    ulong[2] res;\n    version(LDC_IR) {\n        ulong upper, lower;\n        inlineIR!(`\n            %r0 = zext i64 %0 to i128 \n            %r1 = zext i64 %1 to i128\n            %r2 = mul i128 %r1, %r0\n            %r3 = trunc i128 %r2 to i64\n            %r4 = lshr i128 %r2, 64\n            %r5 = trunc i128 %r4 to i64\n            store i64 %r3, i64* %2\n            store i64 %r5, i64* %3`, void)(a, b, &lower, &upper);\n        return [lower, upper];\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper, lower;\n        asm {\n            mov RAX, a;\n            mul b;\n            mov lower, RAX;\n            mov upper, RDX;\n        }\n        return [lower, upper];\n    } else {\n        ulong B = 2UL^^32;\n        ulong[2] a2 = [a % B, a / B];\n        ulong[2] b2 = [b % B, b / B];\n        ulong[4] c;\n        foreach (i; 0..2) {\n            foreach (j; 0..2) {\n                c[i+j] += a2[i] * b2[j] % B;\n                c[i+j+1] += a2[i] * b2[j] / B;\n            }\n        }\n        foreach (i; 0..3) {\n            c[i+1] += c[i] / B;\n            c[i] %= B;\n        }\n        return [c[0] + c[1] * B, c[2] + c[3] * B];\n    }\n}\n\n \n\n \nulong div128(ulong[2] a, ulong b) {\n    version(LDC_IR) {\n        return inlineIR!(`\n            %r0 = zext i64 %0 to i128\n            %r1 = zext i64 %1 to i128\n            %r2 = shl i128 %r1, 64\n            %r3 = add i128 %r0, %r2\n            %r4 = zext i64 %2 to i128\n            %r5 = udiv i128 %r3, %r4\n            %r6 = trunc i128 %r5 to i64\n            ret i64 %r6`,ulong)(a[0], a[1], b);\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RAX;\n        }\n        return res;\n    } else {\n        if (b == 1) return a[0];\n        while (!(b & (1UL << 63))) {\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n            b <<= 1;\n        }\n        ulong ans = 0;\n        foreach (i; 0..64) {\n            bool up = (a[1] & (1UL << 63)) != 0;\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n\n            ans <<= 1;\n            if (up || b <= a[1]) {\n                a[1] -= b;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n\n \nulong mod128(ulong[2] a, ulong b) {\n    version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RDX;\n        }\n        return res;\n    } else {\n        return a[0] - div128(a, b) * b;\n    }\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\nbool[] rem(bool[] a, bool[] b) {\n    if (a.length < b.length) return a;\n    b.length = a.length;\n    bool[] c = new bool[a.length];\n    c[] = a[] ^ b[];\n    size_t i = 0;\n    while (i < a.length && !c[i]) i++;\n    return c[i..$];\n}\n\nbool[] gcd(bool[] a, bool[] b) {\n//    writeln(\"GCD \", a, \" \", b);\n    if (!b.length) return a;\n    return gcd(b, rem(a, b));\n}\n\n// import dcomp.modint, dcomp.numeric.primitive;\nalias Mint = ModInt!(998244353);\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    int n; string X;\n    sc.read(n, X);\n    bool[] x = X.map!\"a=='1'\".array;\n\n    bool[] g = [];\n    foreach (i; 0..n) {\n        string Y;\n        sc.read(Y);\n        bool[] y = Y.map!\"a=='1'\".array;\n//        writeln(g, \" \", y, \"GCD->\");\n//        writeln(gcd(g, y));\n        g = gcd(g, y);\n    }\n//    writeln(g);\n    int A = x.length.to!int, B = g.length.to!int;\n    if (A < B) {\n        writeln(0);\n        return 0;\n    }\n    bool[] z = new bool[A];\n    Mint sm = 0;\n    foreach (i; 0..A-B+1) {\n        if (!x[i]) {\n            if (z[i]) {\n                foreach (j; 0..B) {\n                    z[i+j] ^= g[j];\n                }                \n            }\n            continue;\n        }\n        //rnk(A-i-1)\n//        writeln(\"WOW \", pow(Mint(2), A-i-1-B));\n        sm += pow(Mint(2), A-i-B);\n        if (!z[i]) {\n            foreach (j; 0..B) {\n                z[i+j] ^= g[j];\n            }\n        }\n    }\n//    writeln(g);\n//    writeln(x, \"\\n\", z);\n    bool la = true;\n    foreach (i; A-B+1..A) {\n        if (x[i] && !z[i]) break;\n        if (!x[i] && z[i]) la = false;\n    }\n    if (la) sm += Mint(1);\n    writeln(sm);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n\nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    while (n) {\n        if (n & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        n >>= 1;\n    }\n    return r % md;\n}\n\nulong ulongPowMod(U)(ulong x, U n, ulong md)\nif (isIntegral!U || is(U == BigInt)) {\n//     import dcomp.int128;\n    x %= md;\n    ulong r = 1;\n    while (n) {\n        if (n & 1) {\n            r = mul128(r, x).mod128(md);\n        }\n        x = mul128(x, x).mod128(md);\n        n >>= 1;\n    }\n    return r % md;\n}\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/ldc/inline.d */\n// module dcomp.ldc.inline;\n\nversion(LDC) {\n    pragma(LDC_inline_ir)\n        R inlineIR(string s, R, P...)(P);\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\nimport core.bitop : popcnt;\nstatic if (!__traits(compiles, popcnt(ulong.max))) {\n    public import core.bitop : popcnt;\n    int popcnt(ulong v) {\n        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));\n    }\n}\n\nbool poppar(ulong v) {\n    v^=v>>1;\n    v^=v>>2;\n    v&=0x1111111111111111UL;\n    v*=0x1111111111111111UL;\n    return ((v>>60) & 1) != 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/int128.d */\n \n\n// module dcomp.int128;\n\n// import dcomp.array;\n\nversion(LDC) {\n//     import dcomp.ldc.inline;\n}\n\nversion(LDC) version(X86_64) {\n    version = LDC_IR;\n}\n\n \nulong[2] mul128(ulong a, ulong b) {\n    ulong[2] res;\n    version(LDC_IR) {\n        ulong upper, lower;\n        inlineIR!(`\n            %r0 = zext i64 %0 to i128 \n            %r1 = zext i64 %1 to i128\n            %r2 = mul i128 %r1, %r0\n            %r3 = trunc i128 %r2 to i64\n            %r4 = lshr i128 %r2, 64\n            %r5 = trunc i128 %r4 to i64\n            store i64 %r3, i64* %2\n            store i64 %r5, i64* %3`, void)(a, b, &lower, &upper);\n        return [lower, upper];\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper, lower;\n        asm {\n            mov RAX, a;\n            mul b;\n            mov lower, RAX;\n            mov upper, RDX;\n        }\n        return [lower, upper];\n    } else {\n        ulong B = 2UL^^32;\n        ulong[2] a2 = [a % B, a / B];\n        ulong[2] b2 = [b % B, b / B];\n        ulong[4] c;\n        foreach (i; 0..2) {\n            foreach (j; 0..2) {\n                c[i+j] += a2[i] * b2[j] % B;\n                c[i+j+1] += a2[i] * b2[j] / B;\n            }\n        }\n        foreach (i; 0..3) {\n            c[i+1] += c[i] / B;\n            c[i] %= B;\n        }\n        return [c[0] + c[1] * B, c[2] + c[3] * B];\n    }\n}\n\n \n\n \nulong div128(ulong[2] a, ulong b) {\n    version(LDC_IR) {\n        return inlineIR!(`\n            %r0 = zext i64 %0 to i128\n            %r1 = zext i64 %1 to i128\n            %r2 = shl i128 %r1, 64\n            %r3 = add i128 %r0, %r2\n            %r4 = zext i64 %2 to i128\n            %r5 = udiv i128 %r3, %r4\n            %r6 = trunc i128 %r5 to i64\n            ret i64 %r6`,ulong)(a[0], a[1], b);\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RAX;\n        }\n        return res;\n    } else {\n        if (b == 1) return a[0];\n        while (!(b & (1UL << 63))) {\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n            b <<= 1;\n        }\n        ulong ans = 0;\n        foreach (i; 0..64) {\n            bool up = (a[1] & (1UL << 63)) != 0;\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n\n            ans <<= 1;\n            if (up || b <= a[1]) {\n                a[1] -= b;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n\n \nulong mod128(ulong[2] a, ulong b) {\n    version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RDX;\n        }\n        return res;\n    } else {\n        return a[0] - div128(a, b) * b;\n    }\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils, sugar\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\ntemplate SeqImpl(lens: varargs[int]; init; d: int): untyped =\n  when d + 1 == lens.len:\n    when init is typedesc: newSeq[init](lens[d])\n    else: newSeqWith(lens[d], init)\n  else: newSeqWith(lens[d], SeqImpl(lens, init, d + 1))\n\ntemplate Seq(lens: varargs[int]; init): untyped = SeqImpl(lens, init, 0)\n\ntemplate ArrayImpl(lens: varargs[int]; init: typedesc; d: int): typedesc =\n  when d + 1 == lens.len: array[lens[d], init]\n  else: array[lens[d], ArrayImpl(lens, init, d + 1)]\n\ntemplate ArrayFill(a, val): void =\n  when a is array:\n    for v in a.mitems: ArrayFill(v, val)\n  else:\n    a = val\n\ntemplate Array(lens: varargs[int]; init): auto =\n  when init is typedesc:\n    ArrayImpl(@lens, init, 0).default\n  else:\n    var a:ArrayImpl(@lens, typeof(init), 0)\n    ArrayFill(a, init)\n    a\n#}}}\n\n\n# dump {{{\nimport macros\n\nmacro dump*(n: varargs[untyped]): untyped =\n  result = newNimNode(nnkStmtList, n)\n  for i,x in n:\n    result.add(newCall(\"write\", newIdentNode(\"stderr\"), toStrLit(x)))\n    result.add(newCall(\"write\", newIdentNode(\"stderr\"), newStrLitNode(\" = \")))\n    result.add(newCall(\"write\", newIdentNode(\"stderr\"), x))\n    if i < n.len - 1: result.add(newCall(\"write\", newIdentNode(\"stderr\"), newStrLitNode(\", \")))\n  result.add(newCall(\"write\", newIdentNode(\"stderr\"), newStrLitNode(\"\\n\")))\n# }}}\n\nconst MOD = 998244353\nvar N:int\nvar X:string\nvar A:seq[string]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  X = nextString()\n  A = newSeqWith(N, nextString())\n#}}}\n\n#{{{ bitutils\nimport bitops\n\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (if b.testBit(n): 1 else: 0)\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (B(1) shl (s.b - s.a + 1))\n#proc testBit[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\n#proc setBit[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\n#proc clearBit[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\n\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.clearBit(n)\n  elif t == 1: b.setBit(n)\n  else: doAssert(false)\nproc writeBits[B:SomeInteger](b:B) =\n  var n = sizeof(B) * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B =\n  if n == 64:\n    return not uint64(0)\n  else:\n    return (B(1) shl B(n)) - B(1)\n#proc countTrailingZeroBits(n:int):int =\n#  for i in 0..<(8 * sizeof(n)):\n#    if n[i] == 1: return i\n#  assert(false)\n#proc popcount(n:int):int =\n#  result = 0\n#  for i in 0..<(8 * sizeof(n)):\n#    if n[i] == 1: result += 1\niterator subsets[B:SomeInteger](b:B):B =\n  var v = newSeq[int]()\n  for i in 0..<(8 * sizeof(B)):\n    if b[i] == 1: v.add(i)\n  var s = B(0)\n  yield s\n  while true:\n    var found = false\n    for i in v:\n      if not s.testBit(i):\n        found = true\n        s.setBit(i)\n        yield s\n        break\n      else:\n        s[i] = 0\n    if not found: break\n#}}}\n\n#{{{ bitset\nimport strutils, sequtils, algorithm\n\nconst BitWidth = 64\n\nproc toBin(b:uint64, n: int): string =\n  result = \"\"\n  for i in countdown(n-1, 0):\n    if (b and (1'u64 shl uint64(i))) != 0'u64: result &= \"1\"\n    else: result &= \"0\"\n\ntype StaticBitSet[N:static[int]] = ref object\n  data: array[(N + BitWidth - 1) div BitWidth, uint64]\n\nproc initStaticBitSet[N:static[int]](): StaticBitSet[N] =\n  const size = (N + BitWidth - 1) div BitWidth\n  var data: array[size, uint64]\n  return StaticBitSet[N](data: data)\nproc initStaticBitSet1[N:static[int]](): StaticBitSet[N] =\n  result = initStaticBitSet(N)\n  let\n    q = (N + BitWidth - 1) div BitWidth\n    r = N div BitWidth\n  for i in 0..<q:result.data[i] = (not 0'u64)\n  if r > 0:result.data[q] = ((1'u64 shl uint64(r)) - 1)\n\nproc `not`[N:static[int]](a: StaticBitSet[N]): StaticBitSet[N] =\n  result = initStaticBitSet1[N]()\n  for i in 0..<a.data.len: result.data[i] = (not a.data[i]) and result.data[i]\nproc `or`[N:static[int]](a, b: StaticBitSet[N]): StaticBitSet[N] =\n  result = initStaticBitSet[N]()\n  for i in 0..<a.data.len: result.data[i] = a.data[i] or b.data[i]\nproc `and`[N:static[int]](a, b: StaticBitSet[N]): StaticBitSet[N] =\n  result = initStaticBitSet[N]()\n  for i in 0..<a.data.len: result.data[i] = a.data[i] and b.data[i]\nproc `xor`[N:static[int]](a, b: StaticBitSet[N]): StaticBitSet[N] =\n  result = initStaticBitSet[N]()\n  for i in 0..<a.data.len: result.data[i] = a.data[i] xor b.data[i]\n\nproc `$`[N:static[int]](a: StaticBitSet[N]):string =\n  var\n    q = N div BitWidth\n    r = N mod BitWidth\n  var v = newSeq[string]()\n  for i in 0..<q: v.add(a.data[i].toBin(BitWidth))\n  if r > 0: v.add(a.data[q].toBin(r))\n  v.reverse()\n  return v.join(\"\")\n\nproc `[]`[N:static[int]](b:StaticBitSet[N],n:int):int =\n  assert 0 <= n and n < N\n  let\n    q = n div BitWidth\n    r = n mod BitWidth\n  return b.data[q][r]\nproc `[]=`[N:static[int]](b:var StaticBitSet[N],n:int,t:int) =\n  assert 0 <= n and n < N\n  assert t == 0 or t == 1\n  let\n    q = n div BitWidth\n    r = n mod BitWidth\n  b.data[q][r] = t\n\nproc `shl`[N:static[int]](a: StaticBitSet[N], n:int): StaticBitSet[N] =\n  result = initStaticBitSet[N]()\n  var r = int(n mod BitWidth)\n  if r < 0: r += BitWidth\n  let q = (n - r) div BitWidth\n  let maskl = setBits[uint64](BitWidth - r)\n  for i in 0..<a.data.len:\n    let d = (a.data[i] and maskl) shl uint64(r)\n    let i2 = i + q\n    if 0 <= i2 and i2 < a.data.len: result.data[i2] = result.data[i2] or d\n  if r != 0:\n    let maskr = setBits[uint64](r) shl uint64(BitWidth - r)\n    for i in 0..<a.data.len:\n      let d = (a.data[i] and maskr) shr uint64(BitWidth - r)\n      let i2 = i + q + 1\n      if 0 <= i2 and i2 < a.data.len: result.data[i2] = result.data[i2] or d\n  block:\n    let r = a.N mod BitWidth\n    if r != 0:\n      let mask = not (setBits[uint64](BitWidth - r) shl uint64(r))\n      result.data[^1] = result.data[^1] and mask\nproc `shr`[N:static[int]](a: StaticBitSet[N], n:int): StaticBitSet[N] = a shl (-n)\n#}}}\n\n#{{{ ModInt[Mod]\n\ntype ModInt[Mod: static[int]] = object\n  v:int32\n\nproc initModInt[T](a:T, Mod:static[int]):ModInt[Mod] =\n  when T is ModInt:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    return ModInt[Mod](v:a.int32)\n\n#proc init[Mod: static[int], T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity[Mod: static[int]](self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[Mod: static[int],T](a:ModInt[Mod], b:T):bool = a.v == initModInt(b, Mod).v\nproc `!=`[Mod: static[int],T](a:ModInt[Mod], b:T):bool = a.v != initModInt(b, Mod).v\nproc `-`[Mod: static[int]](self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:Mod - self.v)\nproc `$`[Mod: static[int]](a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[Mod: static[int], T](self:var ModInt[Mod]; a:T) =\n  self.v += initModInt(a, Mod).v\n  if self.v >= Mod: self.v -= Mod\nproc `-=`[Mod: static[int], T](self:var ModInt[Mod], a:T) =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += Mod\nproc `*=`[Mod: static[int], T](self:var ModInt[Mod],a:T) =\n  self.v = (self.v.int * initModInt(a, Mod).v.int mod Mod).int32\nproc `^=`[Mod: static[int]](self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse[Mod:static[int]](self: ModInt[Mod]):ModInt[Mod] =\n  var\n    a = self.v.int\n    b = Mod\n    u = 1\n    v = 0\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[Mod: static[int], T](a:var ModInt[Mod],b:T):void =\n  a *= initModInt(b, Mod).inverse()\nproc `+`[Mod: static[int], T](a:ModInt[Mod],b:T):ModInt[Mod] = \n  result = a;result += b\nproc `-`[Mod: static[int], T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[Mod: static[int], T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[Mod: static[int], T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`[Mod: static[int]](a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n##}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\nconverter toMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\nproc `$`(a:Mint):string = $(a.v)\n\nconst B = 4000\n#const B = 15\n\nproc calc(a,b:StaticBitSet[B]):StaticBitSet[B] =\n  var\n    a = a\n    b = b\n    i = B - 1\n    j = B - 1\n#  dump(a)\n  #dump(b)\n  while a[i] == 0:i.dec\n  while b[j] == 0:j.dec\n  if i < j:swap(a,b);swap(i,j)\n  while true:\n    # i > j\n    for t in countdown(i - j, 0):\n      if a[j+t] == 1:\n        a = a xor (b shl t)\n    var allzero = true\n    for d in a.data:\n      if d != 0.uint64:\n        allzero = false\n    while i >= 0 and a[i] == 0:\n      i.dec\n    if i < 0: return b\n    swap(a,b)\n    swap(i,j)\n\nproc main() =\n  var a = initStaticBitSet[B]()\n  for i in 0..<N:\n    var b = initStaticBitSet[B]()\n    for j in 0..<A[i].len:\n      if A[i][j] == '1':\n        b[A[i].len - 1 - j] = 1\n    if i == 0:\n      a = b\n    else:\n      a = calc(a, b)\n  var ai = B - 1\n  while a[ai] == 0: ai.dec\n  ans := Mint(0)\n  x := initStaticBitSet[B]()\n  for j in 0..<X.len:\n    t := X.len - 1 - j\n    if t < ai:\n      break\n    if X[j] == '1':\n      # set 0\n      ans += Mint(2)^(t-ai)\n      if x[t] == 0:\n        x = x xor (a shl (t - ai))\n    else:\n      if x[t] == 1:\n        x = x xor (a shl (t - ai))\n  var valid = true\n  for i in 0..<X.len:\n    if X[i] == '0' and x[X.len - 1 - i] == 1:\n      valid = false\n      break\n    elif X[i] == '1' and x[X.len - 1 - i] == 0:\n      break\n  if valid: ans += 1\n  echo ans\n  return\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import random\n\nmod=998244353\nN,X=input().split()\nN=int(N)\nA=[]\nfor i in range(N):\n    A.append(int(input(),2))\nA.sort()\n\na=A[-1]\nM=max(len(X)-1,a.bit_length()-1)\ndata=[0]*(M+1)\nn=a.bit_length()-1\nfor i in range(M-n,-1,-1):\n    data[i+n]=a<<i\n\nfor i in range(0,N-1):\n    a=A[i]\n    flag=True\n    while flag:\n        n=a.bit_length()\n        for j in range(n-1,-1,-1):\n            a=min(a,a^data[j])\n        if a!=0:\n            data[a.bit_length()-1]=a\n            id=a.bit_length()-1\n            while data[id+1]==0:\n                data[id+1]=min((data[id]<<1)^a,(data[id]<<1))\n                if data[id+1]:\n                    id+=1\n                else:\n                    flag=False\n            else:\n                a=data[id]<<1\n        else:\n            break\n\ndata2=[0]*(M+1)\nfor i in range(M+1):\n    data2[i]=(data[i]!=0)\n\nfor i in range(1,M+1):\n    data2[i]+=data2[i-1]\n\ndata2=[0]+data2\n\n#print(data)\n#print(data2)\n\nx=0\nans=0\nn=len(X)-1\nfor i in range(len(X)):\n    if X[i]==\"1\":\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                ans+=pow(2,data2[n-i],mod)\n                ans%=mod\n        else:\n            ans+=pow(2,data2[n-i],mod)\n            ans%=mod\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n    else:\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n        else:\n            continue\nelse:\n    ans+=1\n    ans%=mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# xor shiftF_2 gcd \n\nfrom functools import reduce\n\nX = int(readline().split()[1],2)\nA = [int(x,2) for x in readlines()]\n\nMOD = 998244353\n\ndef gcd(a,b):\n    if a < b:\n        a,b = b,a\n    while b:\n        LA = a.bit_length()\n        LB = b.bit_length()\n        a ^= b << (LA - LB)\n        if a < b:\n            a,b = b,a\n    return a\n\ng = reduce(gcd,A)\n\n# g  \"\" X\n# g\n# X\n\nLX = X.bit_length()\nLg = g.bit_length()\nanswer = X >> (Lg - 1)\n\nprod = 0\nx = X; Lx = LX\nwhile Lx >= Lg:\n    prod ^= g << (Lx - Lg)\n    x ^= g << (Lx - Lg)\n    Lx = x.bit_length()\n\nif prod <= X:\n    answer += 1\n\nanswer %= MOD\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# xor shiftF_2 gcd \n\nfrom functools import reduce\n\nX = int(readline().split()[1],2)\nA = [int(x,2) for x in readlines()]\n\nMOD = 998244353\n\ndef gcd(a,b):\n    if a < b:\n        a,b = b,a\n    while b:\n        LA = a.bit_length()\n        LB = b.bit_length()\n        a ^= b << (LA - LB)\n        if a < b:\n            a,b = b,a\n    return a\n\ng = reduce(gcd,A)\n\n# g  \"\" X\n# g\n# X\n\nLX = X.bit_length()\nLg = g.bit_length()\nanswer = X >> (Lg - 1)\n\nprod = 0\nx = X; Lx = LX\nwhile Lx >= Lg:\n    prod ^= g << (Lx - Lg)\n    x ^= g << (Lx - Lg)\n    Lx = x.bit_length()\n\nif prod <= X:\n    answer += 1\n\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef gcd(a,b):\n    if b==0:return a\n    if a<b:a,b=b,a\n    k=a.bit_length()-b.bit_length()\n    return gcd(b,a^(b<<k))\n\ndef main():\n    md=998244353\n    n,x=input().split()\n    x=int(x,2)\n    aa=[input() for _ in range(int(n))]\n    aa=[int(a,2) for a in aa]\n    #bitGCD\n    g=aa[0]\n    for a in aa[1:]:\n        g=gcd(g,a)\n    #print(bin(g))\n    #GCD\n    ans=x>>(g.bit_length()-1)\n    s=0\n    # GCDxx\n    while 1:\n        k=(x^s).bit_length()-g.bit_length()\n        #print(k,bin(x^s),bin(x),bin(s))\n        if k<0:break\n        s^=g<<k\n    if s<=x:ans+=1\n    print(ans%md)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\ndef divmod(f, g):\n    assert g\n    h = 0\n    for i in reversed(range(f.bit_length() - g.bit_length() + 1)):\n        if f & (1 << (g.bit_length() + i - 1)):\n            f ^= g << i\n            h ^= 1 << i\n    return h, f\n\ndef gcd(f, g):\n    while g:\n        q, r = divmod(f, g)\n        f, g = g, r\n    return f\n\nimport functools\ndef solve(n, x, a):\n    # (g) = (a_1, ..., a_n) is a principal ideal since F_2[x] is a PID\n    g = functools.reduce(gcd, a)\n\n    # count h in F_2[x] s.t. h g <= x\n    cnt = 0\n    h = 0\n    for k in reversed(range(x.bit_length() - g.bit_length() + 1)):\n        bit = 1 << (g.bit_length() + k - 1)\n        if (x & bit):\n            cnt += 1 << k\n        if (x & bit) != (h & bit):\n            h ^= g << k\n    cnt += (h <= x)\n    return cnt % 998244353\n\n\ndef main():\n    n, x = input().split()\n    n = int(n)\n    x = int(x, 2)\n    a = [ int(input(), 2) for _ in range(n) ]\n    print(solve(n, x, a))\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# xor shiftF_2 gcd \n\nfrom functools import reduce\n\nX = int(readline().split()[1],2)\nA = [int(x,2) for x in readlines()]\n\nMOD = 998244353\n\ndef gcd(a,b):\n    if a < b:\n        a,b = b,a\n    while b:\n        LA = a.bit_length()\n        LB = b.bit_length()\n        a ^= b << (LA - LB)\n        if a < b:\n            a,b = b,a\n    return a\n\ng = reduce(gcd,A)\n\n# g  \"\" X\n# g\n# X\n\nLX = X.bit_length()\nLg = g.bit_length()\nanswer = X >> (Lg - 1)\n\nprod = 0\nx = X; Lx = LX\nwhile Lx >= Lg:\n    prod ^= g << (Lx - Lg)\n    x ^= g << (Lx - Lg)\n    Lx = x.bit_length()\n\nif prod <= X:\n    answer += 1\n\nanswer %= MOD\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import random\n\nmod=998244353\nN,X=input().split()\nN=int(N)\nA=[]\nfor i in range(N):\n    A.append(int(input(),2))\nA.sort()\n\na=A[-1]\nM=max(len(X)-1,a.bit_length()-1)\ndata=[0]*(M+1)\nn=a.bit_length()-1\nfor i in range(M-n,-1,-1):\n    data[i+n]=a<<i\n\nlow=n\nfor i in range(0,N-1):\n    a=A[i]\n    flag=True\n    while flag:\n        n=a.bit_length()\n        for j in range(n-1,low-1,-1):\n            a=min(a,a^data[j])\n        if a!=0:\n            data[a.bit_length()-1]=a\n            id=a.bit_length()-1\n            low=id\n            while data[id+1]==0:\n                data[id+1]=min((data[id]<<1)^a,(data[id]<<1))\n                id+=1\n            else:\n                a=data[id]<<1\n        else:\n            break\n\ndata2=[0]*(M+1)\nfor i in range(M+1):\n    data2[i]=(data[i]!=0)\n\nfor i in range(1,M+1):\n    data2[i]+=data2[i-1]\n\ndata2=[0]+data2\n\n#print(data)\n#print(data2)\n\nx=0\nans=0\nn=len(X)-1\nfor i in range(len(X)):\n    if X[i]==\"1\":\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                ans+=pow(2,data2[n-i],mod)\n                ans%=mod\n        else:\n            ans+=pow(2,data2[n-i],mod)\n            ans%=mod\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n    else:\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n        else:\n            continue\nelse:\n    ans+=1\n    ans%=mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import random\n\nmod=998244353\nN,X=input().split()\nN=int(N)\nA=[]\nfor i in range(N):\n    A.append(int(input(),2))\nA.sort()\n\na=A[-1]\nM=max(len(X)-1,a.bit_length()-1)\nbase=[]\nn=a.bit_length()-1\nfor i in range(M-n,-1,-1):\n    base.append(a<<i)\n\nfor i in range(0,N-1):\n    a=A[i]\n    for j in range(M):\n        for b in base:\n            a=min(a,a^b)\n        if a==0:\n            break\n        else:\n            base.append(a)\n            a=a<<1\n\ndata=[0]*(M+1)\ndata2=[0]*(M+1)\nfor b in base:\n    data[b.bit_length()-1]=b\n    data2[b.bit_length()-1]=1\n\nfor i in range(1,M+1):\n    data2[i]+=data2[i-1]\n\ndata2=[0]+data2\n\n#print(data)\n#print(data2)\n\nx=0\nans=0\nn=len(X)-1\nfor i in range(len(X)):\n    if X[i]==\"1\":\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                ans+=pow(2,data2[n-i],mod)\n                ans%=mod\n        else:\n            ans+=pow(2,data2[n-i],mod)\n            ans%=mod\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n    else:\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n        else:\n            continue\nelse:\n    ans+=1\n    ans%=mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\ndef divmod(f, g):\n    assert g\n    h = 0\n    for i in reversed(range(f.bit_length() - g.bit_length() + 1)):\n        if f & (1 << (g.bit_length() + i - 1)):\n            f ^= g << i\n            h ^= 1 << i\n    return h, f\n\ndef gcd(f, g):\n    while g:\n        q, r = divmod(f, g)\n        f, g = g, r\n    return f\n\nimport functools\ndef solve(n, x, a):\n    # (g) = (a_1, ..., a_n) is a principal ideal since F_2[x] is a PID\n    g = functools.reduce(gcd, a)\n\n    # count h in F_2[x] s.t. h g <= x\n    cnt = 0\n    h = 0\n    for k in reversed(range(x.bit_length() - g.bit_length() + 1)):\n        bit = 1 << (g.bit_length() + k - 1)\n        if (x & bit):\n            cnt += 1 << k\n        if (x & bit) != (h & bit):\n            h ^= g << k\n    cnt += 1  # zero\n    return cnt % 998244353\n\n\ndef main():\n    n, x = input().split()\n    n = int(n)\n    x = int(x, 2)\n    a = [ int(input(), 2) for _ in range(n) ]\n    print(solve(n, x, a))\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "N, X = input().split()\nN = int(N); X = int(X, 2)\np = int(input(), 2)\nfor i in range(N-1):\n    v = int(input(), 2)\n    if p > v:\n        p, v = v, p\n    while 0 < p:\n        q = (v ^ (p << (v.bit_length() - p.bit_length())))\n        if p < q:\n            p, v = p, q\n        else:\n            p, v = q, p\n    p = v\n\nlx = X.bit_length()\nlp = p.bit_length()\n\nMOD = 998244353\nans = (X >> (p.bit_length() - 1)) % MOD\n\nq = p << (lx - lp)\nb = 1 << (lx - 1)\n\nx = 0; y = 0\nfor k in range(lx - lp, -1, -1):\n    if b & (X ^ y):\n        y ^= q\n    b >>= 1; q >>= 1\nif y <= X:\n    ans = (ans + 1) % MOD\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**5)\n\nn,x = readline().split()\nn = int(n)\nx = int(x,2)\n*a, = map(lambda x:int(x,2), read().split())\n\ndef gcd(a,b):\n    c = 0\n    while b:\n        if a < b:\n            a,b = b,a\n            continue\n        a ^= b<<(a.bit_length() - b.bit_length())\n    return a\n\nv = 0\nfor ai in a: v = gcd(ai,v)\n\nMOD = 998244353\np2 = [1]\nfor _ in range(5000): p2.append(p2[-1]*2%MOD)\n\ndv = v.bit_length()\ndx = x.bit_length()\n\ndef dfs(x,y,d):\n    if d < dv:\n        return int(x >= y)\n    else:\n        bx = x>>(d-1)&1\n        by = y>>(d-1)&1\n        if bx and by:\n            return (p2[d-dv] + dfs(x,y,d-1)) %MOD\n        elif not bx and by:\n            return dfs(x,y^(v<<(d-dv)),d-1)\n        elif not by and bx:\n            return (p2[d-dv] + dfs(x,y^(v<<(d-dv)),d-1)) %MOD\n        else:\n            return dfs(x,y,d-1)\n\nprint(dfs(x,0,dx))\n\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by: https://atcoder.jp/contests/pakencamp-2018-day3/submissions/3878249\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy + Clone { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<*const M> }\n    impl<M: Mod> ModInt<M> {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < M::m());\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt::new_internal(self.x * other.x % M::m())\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new_internal(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 { sum += cur; }\n                cur += cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod> Add for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod> Sub for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod> Mul for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self { self.mul_fast(other) }\n    }\n    impl<M: Mod> AddAssign for ModInt<M> {\n        fn add_assign(&mut self, other: Self) { *self = *self + other; }\n    }\n    impl<M: Mod> SubAssign for ModInt<M> {\n        fn sub_assign(&mut self, other: Self) { *self = *self - other; }\n    }\n    impl<M: Mod> MulAssign for ModInt<M> {\n        fn mul_assign(&mut self, other: Self) { *self = *self * other; }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998_244_353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    buf: Vec<usize>,\n}\n\nimpl BitSet {\n    // size should be a multiple of bit-size of usize.\n    fn new(size: usize) -> Self {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(size & (w - 1), 0);\n        let count = size / w;\n        BitSet {\n            size: size,\n            buf: vec![0; count],\n        }\n    }\n    fn set(&mut self, idx: usize, val: bool) {\n        debug_assert!(idx < self.size);\n        let w = 8 * std::mem::size_of::<usize>();\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        if val {\n            self.buf[idx0] |= 1 << idx1;\n        } else {\n            self.buf[idx0] &= !(1 << idx1);\n        }\n    }\n    fn shl(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i];\n            }\n        } else {\n            ans.buf[sh0] = self.buf[0] << sh1;\n            for i in 1 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i] << sh1\n                    | self.buf[i - 1] >> (w - sh1);\n            }\n        }\n        ans\n    }\n    fn shr(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i] = self.buf[i + sh0];\n            }\n        } else {\n            for i in 0 .. count - sh0 - 1 {\n                ans.buf[i] = self.buf[i + sh0] >> sh1\n                    | self.buf[i + sh0 + 1] << (w - sh1);\n            }\n            ans.buf[self.size - sh0 - 1] = self.buf[self.size - 1] >> sh1;\n        }\n        ans\n    }\n    fn msb(&self) -> Option<usize> {\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        for i in (0 .. count).rev() {\n            if self.buf[i] != 0 {\n                return Some(w * i + w - 1 - self.buf[i].leading_zeros() as usize);\n            }\n        }\n        None\n    }\n    fn get(&self, idx: usize) -> bool {\n        let w = 8 * std::mem::size_of::<usize>();\n        debug_assert!(idx < self.size);\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        (self.buf[idx0] >> idx1 & 1) == 1\n    }\n}\nimpl std::fmt::Display for BitSet {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        let size = match self.msb() {\n            None => return f.write_str(\"0\"),\n            Some(size) => size + 1,\n        };\n        for i in (0 .. size).rev() {\n            f.write_str(if self.get(i) { \"1\" } else { \"0\" })?\n        }\n        Ok(())\n    }\n}\nimpl std::fmt::Debug for BitSet {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        std::fmt::Display::fmt(&self, f)\n    }\n}\n\n// TODO reference is not allowed as rhs\nimpl<'a> std::ops::BitXorAssign for BitSet {\n    fn bitxor_assign(&mut self, other: BitSet) {\n        debug_assert_eq!(self.size, other.size);\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        for i in 0 .. count {\n            self.buf[i] ^= other.buf[i];\n        }\n    }\n}\n\nfn gcd(mut a: BitSet, mut b: BitSet) -> BitSet {\n    let (mut da, mut db) = match (a.msb(), b.msb()) {\n        (None, _) => return b,\n        (_, None) => return a,\n        (Some(da), Some(db)) => (da, db),\n    };\n    if da < db {\n        std::mem::swap(&mut da, &mut db);\n        std::mem::swap(&mut a, &mut b);\n    }\n\n    for i in (db .. da + 1).rev() {\n        if a.get(i) {\n            a ^= b.shl(i - db);\n        }\n    }\n    gcd(b, a)\n}\n\nconst W: usize = 4032;\nfn to_bitset(mut c: Vec<char>) -> BitSet {\n    let mut ans = BitSet::new(W);\n    c.reverse();\n    for i in 0 .. c.len() {\n        if c[i] == '1' {\n            ans.set(i, true);\n        }\n    }\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        x: chars,\n        a: [chars; n],\n    }\n    let x = to_bitset(x);\n    let a: Vec<BitSet> = a.into_iter().map(to_bitset).collect();\n    let mut g = to_bitset(vec!['0']);\n    for a in a { g = gcd(g, a); }\n    let hi = g.msb().unwrap();\n    let mut y = to_bitset(vec!['0']);\n    let mut r = x.clone();\n    // What is the largest multiple of g that is <= x?\n    for i in (hi .. W).rev() {\n        if r.get(i) {\n            r ^= g.shl(i - hi);\n            y.set(i - hi, true);\n        }\n    }\n    let mut z = x.clone();\n    z ^= r;\n    let mut lt = false;\n    for i in (0 .. W).rev() {\n        if x.get(i) != z.get(i) {\n            lt = x.get(i) < z.get(i);\n            break;\n        }\n    }\n    let mut tot = ModInt::new(0);\n    for i in (hi .. W).rev() {\n        tot += tot;\n        if z.get(i) {\n            tot += ModInt::new(1);\n        }\n    }\n    if !lt {\n        tot += ModInt::new(1);\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc084/tasks/arc084_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nfn polymod(a: Vec<i32>, mut b: Vec<i32>) -> Vec<i32> {\n    if a.len() > b.len() {\n        return b;\n    }\n    let al = a.len();\n    let bl = b.len();\n    assert!(a[0] == 1 && b[0] == 1);\n\n    for i in 0..bl-al+1 {\n        if b[i] == 1 {\n            for j in 0..al {\n                b[i+j] ^= a[j];\n            }\n        }\n    }\n\n    let mut res = vec![];\n    for i in bl-al+1..bl {\n        if b[i] == 1 {\n            for j in i..bl {\n                res.push(b[j]);\n            }\n            break;\n        }\n    }\n    res\n}\n\nfn polygcd(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\n    if b.len() == 0 {\n        return a;\n    } else {\n        let bb = b.clone();\n        polygcd(bb, polymod(b, a))\n    }\n}\n\nconst MOD: i64 = 998244353;\n\nfn main() {\n    input! {\n        n: usize, x: chars,\n        a: [chars; n]\n    };\n\n    let a = a.into_iter().map(|s| s.into_iter().map(|c| ifv!(c == '0', 0, 1)).collect::<Vec<_>>()).collect::<Vec<_>>();\n    let x = x.into_iter().map(|c| ifv!(c == '0', 0, 1)).collect::<Vec<_>>();\n\n    let mut g = vec![];\n    for i in 0..n {\n        g = polygcd(g, a[i].clone());\n    }\n\n    let mut p2 = vec![0; 4010];\n    p2[0] = 1;\n    for i in 1..4010 {\n        p2[i] = p2[i-1] * 2 % MOD;\n    }\n\n    let xl = x.len();\n    let gl = g.len();\n    let mut ans = 0;\n    if gl <= xl {\n        let w = xl-gl;\n        for i in 0..w+1 {\n            if x[i] == 1 {\n                ans += p2[w-i];\n                ans %= MOD;\n            }\n        }\n\n        let mut xx = vec![0; xl];\n        for i in 0..w+1 {\n            if xx[i] ^ x[i] == 1 {\n                for j in 0..gl {\n                    xx[i+j] ^= g[j];\n                }\n            }\n        }\n\n        let mut ov = false;\n        for i in 0..gl-1 {\n            if xx[w+1+i] > x[w+1+i] {\n                ov = true;\n                break;\n            } else if xx[w+1+i] < x[w+1+i] {\n                break;\n            }\n        }\n        if !ov {\n            ans += 1;\n        }\n    } else {\n        // zero\n        ans = 1;\n    }\n    println!(\"{}\", ans % MOD);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::VecDeque;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nconst MOD: i64 = 998244353;\nstruct Solver {\n    x: VecDeque<u8>,\n    aseq: Vec<VecDeque<u8>>,\n    base: Vec<Option<VecDeque<u8>>>,\n    memo: Vec<Option<i64>>,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        let n: usize = read();\n        let x = read::<String>()\n            .chars()\n            .rev()\n            .map(|v| v as u8 - '0' as u8)\n            .collect::<VecDeque<_>>();\n        let mut aseq = vec![VecDeque::new(); n];\n        for i in 0..n {\n            aseq[i] = read::<String>()\n                .chars()\n                .rev()\n                .map(|v| v as u8 - '0' as u8)\n                .collect::<VecDeque<_>>();\n        }\n        Solver {\n            x: x,\n            aseq: aseq,\n            base: vec![None; 9000],\n            memo: vec![None; 9000],\n        }\n    }\n    fn xor(&self, lhs: &VecDeque<u8>, rhs: &VecDeque<u8>) -> VecDeque<u8> {\n        let (mut lhs, mut rhs) = (lhs, rhs);\n        if lhs.len() < rhs.len() {\n            let temp = lhs;\n            lhs = rhs;\n            rhs = temp;\n        }\n        let mut ret = lhs.clone();\n        for i in 0..rhs.len() {\n            ret[i] = lhs[i] ^ rhs[i];\n        }\n        while ret.len() > 0 && *ret.back().unwrap() == 0 {\n            ret.pop_back();\n        }\n        ret\n    }\n    fn set_base(&mut self, vs: &VecDeque<u8>) -> usize {\n        let mut vs = vs.clone();\n        while let Some(ref b) = self.base[vs.len()] {\n            vs = self.xor(&vs, &b);\n        }\n        if vs.len() == 0 {\n            return 0;\n        }\n        assert!(*vs.back().unwrap() == 1);\n        let len = vs.len();\n        self.base[len] = Some(vs);\n        return len;\n    }\n    fn dfs(&mut self, vs: &VecDeque<u8>, depth: usize, upper: bool) -> i64 {\n        if !upper && self.memo[depth].is_some() {\n            return self.memo[depth].unwrap();\n        }\n        if depth == 0 {\n            return 1;\n        }\n        let mut ret = 0;\n        {\n            let v = if vs.len() <= depth - 1 {\n                0\n            } else {\n                vs[depth - 1]\n            };\n            if !upper || self.x[depth - 1] == 1 || v == 0 {\n                let nupper = upper && (self.x[depth - 1] == v);\n                ret += self.dfs(vs, depth - 1, nupper);\n            }\n        }\n        if self.base[depth].is_some() {\n            let nvs = self.xor(vs, &self.base[depth].clone().unwrap());\n            let nv = if nvs.len() <= depth - 1 {\n                0\n            } else {\n                nvs[depth - 1]\n            };\n            if !upper || self.x[depth - 1] == 1 || nv == 0 {\n                let nupper = upper && (self.x[depth - 1] == nv);\n                ret += self.dfs(&nvs, depth - 1, nupper);\n            }\n        }\n        ret %= MOD;\n        if !upper {\n            self.memo[depth] = Some(ret);\n        }\n        ret\n    }\n    fn solve(&mut self) {\n        let mut que = VecDeque::<usize>::new();\n        for vs in self.aseq.clone().iter() {\n            let len = self.set_base(vs);\n            if len > 0 {\n                que.push_back(len);\n            }\n        }\n        while let Some(len) = que.pop_front() {\n            let mut vs = self.base[len].clone().unwrap();\n            if vs.len() > 4100 {\n                continue;\n            }\n            vs.push_front(0);\n            let nvs = vs;\n            let nlen = self.set_base(&nvs);\n            if nlen > 0 {\n                que.push_back(nlen);\n            }\n        }\n        let l = self.x.len();\n        let ans = self.dfs(&VecDeque::new(), l, true);\n        println!(\"{}\", ans);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.solve();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::VecDeque;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nconst MOD: i64 = 998244353;\nstruct Solver {\n    x: VecDeque<u8>,\n    aseq: Vec<VecDeque<u8>>,\n    base: Vec<Option<VecDeque<u8>>>,\n    memo: Vec<Option<i64>>,\n}\n\nimpl Solver {\n    fn new() -> Solver {\n        let n: usize = read();\n        let x = read::<String>()\n            .chars()\n            .rev()\n            .map(|v| v as u8 - '0' as u8)\n            .collect::<VecDeque<_>>();\n        let mut aseq = vec![VecDeque::new(); n];\n        for i in 0..n {\n            aseq[i] = read::<String>()\n                .chars()\n                .rev()\n                .map(|v| v as u8 - '0' as u8)\n                .collect::<VecDeque<_>>();\n        }\n        Solver {\n            x: x,\n            aseq: aseq,\n            base: vec![None; 9000],\n            memo: vec![None; 9000],\n        }\n    }\n    fn xor(&self, lhs: &VecDeque<u8>, rhs: &VecDeque<u8>) -> VecDeque<u8> {\n        let (mut lhs, mut rhs) = (lhs, rhs);\n        if lhs.len() < rhs.len() {\n            let temp = lhs;\n            lhs = rhs;\n            rhs = temp;\n        }\n        let mut ret = lhs.clone();\n        for i in 0..rhs.len() {\n            ret[i] = lhs[i] ^ rhs[i];\n        }\n        while ret.len() > 0 && *ret.back().unwrap() == 0 {\n            ret.pop_back();\n        }\n        ret\n    }\n    fn set_base(&mut self, vs: &VecDeque<u8>) -> usize {\n        let mut vs = vs.clone();\n        while let Some(ref b) = self.base[vs.len()] {\n            vs = self.xor(&vs, &b);\n        }\n        if vs.len() == 0 {\n            return 0;\n        }\n        assert!(*vs.back().unwrap() == 1);\n        let len = vs.len();\n        self.base[len] = Some(vs);\n        return len;\n    }\n    fn dfs(&mut self, vs: &VecDeque<u8>, depth: usize, upper: bool) -> i64 {\n        if !upper && self.memo[depth].is_some() {\n            return self.memo[depth].unwrap();\n        }\n        if depth == 0 {\n            return 1;\n        }\n        let mut ret = 0;\n        {\n            let v = if vs.len() <= depth - 1 {\n                0\n            } else {\n                vs[depth - 1]\n            };\n            if !upper || self.x[depth - 1] == 1 || v == 0 {\n                let nupper = upper && (self.x[depth - 1] == v);\n                ret += self.dfs(vs, depth - 1, nupper);\n            }\n        }\n        if self.base[depth].is_some() {\n            let nvs = self.xor(vs, &self.base[depth].clone().unwrap());\n            let nv = if nvs.len() <= depth - 1 {\n                0\n            } else {\n                nvs[depth - 1]\n            };\n            if !upper || self.x[depth - 1] == 1 || nv == 0 {\n                let nupper = upper && (self.x[depth - 1] == nv);\n                ret += self.dfs(&nvs, depth - 1, nupper);\n            }\n        }\n        ret %= MOD;\n        if !upper {\n            self.memo[depth] = Some(ret);\n        }\n        ret\n    }\n    fn solve(&mut self) {\n        let mut que = VecDeque::<usize>::new();\n        for vs in self.aseq.clone().iter() {\n            let len = self.set_base(vs);\n            if len > 0 {\n                que.push_back(len);\n            }\n        }\n        while let Some(len) = que.pop_front() {\n            let mut vs = self.base[len].clone().unwrap();\n            if vs.len() > 8100 {\n                continue;\n            }\n            vs.push_front(0);\n            let nvs = vs;\n            let nlen = self.set_base(&nvs);\n            if nlen > 0 {\n                que.push_back(nlen);\n            }\n        }\n        let l = self.x.len();\n        let ans = self.dfs(&VecDeque::new(), l, true);\n        println!(\"{}\", ans);\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n    solver.solve();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by: https://atcoder.jp/contests/pakencamp-2018-day3/submissions/3878249\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy + Clone { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<*const M> }\n    impl<M: Mod> ModInt<M> {\n        fn check_integrity(self) {\n            debug_assert!(self.x >= 0);\n            debug_assert!(self.x < M::m());\n        }\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        #[allow(dead_code)]\n        pub fn mul_fast(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            ModInt::new_internal(self.x * other.x % M::m())\n        }\n        #[allow(dead_code)]\n        pub fn mul_slow(self, other: Self) -> Self {\n            // Naive multiplication in order to avoid overflow\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = ModInt::new_internal(0);\n            let mut cur = self;\n            let mut e = other.x;\n            if self.x < other.x {\n                cur = other;\n                e = self.x;\n            }\n            while e > 0 {\n                if e % 2 == 1 { sum += cur; }\n                cur += cur;\n                e /= 2;\n            }\n            sum\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            self.check_integrity();\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod> Add for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod> Sub for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            self.check_integrity();\n            other.check_integrity();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod> Mul for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self { self.mul_fast(other) }\n    }\n    impl<M: Mod> AddAssign for ModInt<M> {\n        fn add_assign(&mut self, other: Self) { *self = *self + other; }\n    }\n    impl<M: Mod> SubAssign for ModInt<M> {\n        fn sub_assign(&mut self, other: Self) { *self = *self - other; }\n    }\n    impl<M: Mod> MulAssign for ModInt<M> {\n        fn mul_assign(&mut self, other: Self) { *self = *self * other; }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998_244_353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    buf: Vec<usize>,\n}\n\nimpl BitSet {\n    // size should be a multiple of bit-size of usize.\n    fn new(size: usize) -> Self {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(size & (w - 1), 0);\n        let count = size / w;\n        BitSet {\n            size: size,\n            buf: vec![0; count],\n        }\n    }\n    fn set(&mut self, idx: usize, val: bool) {\n        debug_assert!(idx < self.size);\n        let w = 8 * std::mem::size_of::<usize>();\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        if val {\n            self.buf[idx0] |= 1 << idx1;\n        } else {\n            self.buf[idx0] &= !(1 << idx1);\n        }\n    }\n    fn shl(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i];\n            }\n        } else {\n            ans.buf[sh0] = self.buf[0] << sh1;\n            for i in 1 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i] << sh1\n                    | self.buf[i - 1] >> (w - sh1);\n            }\n        }\n        ans\n    }\n    // Not verified\n    fn shr(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i] = self.buf[i + sh0];\n            }\n        } else {\n            for i in 0 .. count - sh0 - 1 {\n                ans.buf[i] = self.buf[i + sh0] >> sh1\n                    | self.buf[i + sh0 + 1] << (w - sh1);\n            }\n            ans.buf[self.size - sh0 - 1] = self.buf[self.size - 1] >> sh1;\n        }\n        ans\n    }\n    fn msb(&self) -> Option<usize> {\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        for i in (0 .. count).rev() {\n            let v = self.buf[i];\n            if v != 0 {\n                return Some(w * i + w - 1 - v.leading_zeros() as usize);\n            }\n        }\n        None\n    }\n    fn get(&self, idx: usize) -> bool {\n        let w = 8 * std::mem::size_of::<usize>();\n        debug_assert!(idx < self.size);\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        (self.buf[idx0] >> idx1 & 1) == 1\n    }\n}\n\n// TODO reference is not allowed as rhs\nimpl std::ops::BitXorAssign for BitSet {\n    fn bitxor_assign(&mut self, other: BitSet) {\n        debug_assert_eq!(self.size, other.size);\n        for i in 0 .. self.buf.len() {\n            self.buf[i] ^= other.buf[i];\n        }\n    }\n}\n\nfn gcd(mut a: BitSet, mut b: BitSet) -> BitSet {\n    let (mut da, mut db) = match (a.msb(), b.msb()) {\n        (None, _) => return b,\n        (_, None) => return a,\n        (Some(da), Some(db)) => (da, db),\n    };\n    if da < db {\n        std::mem::swap(&mut da, &mut db);\n        std::mem::swap(&mut a, &mut b);\n    }\n\n    for i in (db .. da + 1).rev() {\n        if a.get(i) {\n            a ^= b.shl(i - db);\n        }\n    }\n    gcd(b, a)\n}\n\nconst W: usize = 4032;\nfn to_bitset(mut c: Vec<char>) -> BitSet {\n    let mut ans = BitSet::new(W);\n    c.reverse();\n    for i in 0 .. c.len() {\n        if c[i] == '1' {\n            ans.set(i, true);\n        }\n    }\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        x: chars,\n        a: [chars; n],\n    }\n    let x = to_bitset(x);\n    let a: Vec<BitSet> = a.into_iter().map(to_bitset).collect();\n    let mut g = to_bitset(vec!['0']);\n    for a in a { g = gcd(g, a); }\n    let hi = g.msb().unwrap();\n    let mut y = to_bitset(vec!['0']);\n    let mut r = x.clone();\n    // What is the largest multiple of g that is <= x?\n    for i in (hi .. W).rev() {\n        if r.get(i) {\n            r ^= g.shl(i - hi);\n            y.set(i - hi, true);\n        }\n    }\n    let mut z = x.clone();\n    z ^= r;\n    let mut lt = false;\n    for i in (0 .. W).rev() {\n        if x.get(i) != z.get(i) {\n            lt = x.get(i) < z.get(i);\n            break;\n        }\n    }\n    let mut tot = ModInt::new(0);\n    for i in (hi .. W).rev() {\n        tot += tot;\n        if z.get(i) {\n            tot += ModInt::new(1);\n        }\n    }\n    if !lt {\n        tot += ModInt::new(1);\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc084/tasks/arc084_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n#[derive(Clone,Debug)]\nstruct BitVector {\n    n: usize,\n    size: usize,\n    data: Vec<u64>\n}\n\nimpl BitVector {\n    fn new(n: usize) -> Self {\n        let bsize = 8 * std::mem::size_of::<usize>();\n        let size = (n+bsize-1)/bsize;\n        BitVector {\n            n: n,\n            size: size,\n            data: vec![0; size]\n        }\n    }\n\n    fn get(&self, i: usize) -> bool {\n        let bsize = 8 * std::mem::size_of::<usize>();\n        self.data[i/bsize]>>(i&(bsize-1)) & 1 != 0\n    }\n\n    fn set(&mut self, i: usize, v: bool) {\n        let bsize = 8 * std::mem::size_of::<usize>();\n        let (bucket, index) = (i/bsize, i&(bsize-1));\n        if v {\n            self.data[bucket] |= 1<<index;\n        } else {\n            self.data[bucket] &= !(1<<index);\n        }\n    }\n\n    fn msb(&self) -> Option<usize> {\n        let bsize = 8 * std::mem::size_of::<usize>();\n        for i in (0..self.size).rev() {\n            if self.data[i] != 0 {\n                return Some(bsize * i + bsize - 1 - self.data[i].leading_zeros() as usize);\n            }\n        }\n        None\n    }\n}\n\nimpl<'a> std::ops::Shl<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shl(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n        let bsize = 8 * std::mem::size_of::<usize>();\n\n        let diff = amount / bsize;\n        let diff_mod = amount & (bsize - 1);\n        if diff_mod == 0 {\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<(bsize-diff_mod))-1;\n            let upper_mask = ((1<<diff_mod)-1)<<(bsize-diff_mod);\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] |= (self.data[i] & lower_mask)<<diff_mod;\n                if i+diff+1 < self.size {\n                    new_vector.data[i+diff+1] |= (self.data[i] & upper_mask)>>(bsize-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\nimpl std::ops::BitAndAssign for BitVector {\n    fn bitand_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] &= rhs.data[i];\n        }\n    }\n}\n\nimpl std::ops::BitOrAssign for BitVector {\n    fn bitor_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] |= rhs.data[i];\n        }\n    }\n}\n\nimpl std::ops::BitXorAssign for BitVector {\n    fn bitxor_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] ^= rhs.data[i];\n        }\n    }\n}\n\n// ===\n\nfn to_bv(a: &Vec<char>) -> BitVector {\n    assert!(a.len() <= 4000);\n    let mut bv = BitVector::new(4000);\n    for i in 0..a.len() {\n        if a[i] == '1' {\n            bv.set(a.len()-i-1, true);\n        }\n    }\n    bv\n}\n\nfn gcd(mut a: BitVector, mut b: BitVector) -> BitVector {\n    let (alen, blen) = match (a.msb(), b.msb()) {\n        (None, _) => return b,\n        (_, None) => return a,\n        (Some(alen), Some(blen)) => (alen, blen)\n    };\n    if alen < blen {\n        std::mem::swap(&mut a, &mut b);\n    }\n    let al = max(alen, blen);\n    let bl = min(alen, blen);\n\n    // al >= bl\n    use std::ops::Shl;\n    for i in 0..al-bl+1 {\n        let d = al-bl-i;\n        if a.get(al-i) {\n            a ^= b.shl(d);\n        }\n    }\n    gcd(a, b)\n}\n\nconst MOD: i64 = 998244353;\n\nfn solve(mut x: BitVector, g: BitVector, pow2: &Vec<i64>) -> i64 {\n    let xl = x.msb().unwrap();\n    let gl = g.msb().unwrap();\n\n    // debug!(x, g, xl, gl);\n\n    if xl < gl {\n        return 1; // '0'\n    }\n\n    let mut ans = 0;\n    for i in gl..xl+1 {\n        if x.get(i) {\n            ans += pow2[i-gl];\n            ans %= MOD;\n        }\n    }\n\n    let mx = x.clone();\n\n    use std::ops::Shl;\n    for i in (gl..xl+1).rev() {\n        if x.get(i) {\n            x ^= g.shl(i-gl);\n        }\n    }\n\n    // debug!(x, mx, gl);\n\n    let mut rx = mx.clone();\n    rx ^= x;\n    let mut less_or_eq = true;\n    for i in (0..gl).rev() {\n        if rx.get(i) != mx.get(i) {\n            less_or_eq = mx.get(i);\n            break;\n        }\n    }\n    if less_or_eq {\n        ans += 1;\n    }\n    ans % MOD\n}\n\nfn main() {\n    input! {\n        n: usize, x: chars,\n        a: [chars; n]\n    };\n\n    let x = to_bv(&x);\n\n    let mut g = to_bv(&a[0]);\n    for i in 1..n {\n        g = gcd(g, to_bv(&a[i]));\n    }\n    // debug!(g);\n\n    let mut pow2 = vec![1; 4001];\n    for i in 1..pow2.len() {\n        pow2[i] = (pow2[i-1] * 2) % MOD;\n    }\n    let ans = solve(x, g, &pow2);\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc084/tasks/arc084_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nfn polymod(a: Vec<i32>, mut b: Vec<i32>) -> Vec<i32> {\n    if a.len() > b.len() {\n        return b;\n    }\n    let al = a.len();\n    let bl = b.len();\n    assert!(a[0] == 1 && b[0] == 1);\n\n    for i in 0..bl-al+1 {\n        if b[i] == 1 {\n            for j in 0..al {\n                b[i+j] ^= a[j];\n            }\n        }\n    }\n\n    let mut res = vec![];\n    for i in bl-al+1..bl {\n        if b[i] == 1 {\n            for j in i..bl {\n                res.push(b[j]);\n            }\n            break;\n        }\n    }\n    res\n}\n\nfn gcd(a: i64, b: i64) -> i64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a%b)\n    }\n}\n\nfn polygcd(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\n    if b.len() == 0 {\n        return a;\n    } else {\n        let bb = b.clone();\n        polygcd(bb, polymod(b, a))\n    }\n}\n\nconst MOD: i64 = 998244353;\n\nfn main() {\n    input! {\n        n: usize, x: chars,\n        a: [chars; n]\n    };\n\n    let a = a.into_iter().map(|s| s.into_iter().map(|c| ifv!(c == '0', 0, 1)).collect::<Vec<_>>()).collect::<Vec<_>>();\n    let x = x.into_iter().map(|c| ifv!(c == '0', 0, 1)).collect::<Vec<_>>();\n\n    let mut g = vec![];\n    for i in 0..n {\n        g = polygcd(g, a[i].clone());\n    }\n\n    let mut p2 = vec![0; 4010];\n    p2[0] = 1;\n    for i in 1..4010 {\n        p2[i] = p2[i-1] * 2 % MOD;\n    }\n\n    let xl = x.len();\n    let gl = g.len();\n    let mut ans = 0;\n    if gl <= xl {\n        let w = xl-gl;\n        for i in 0..w+1 {\n            if x[i] == 1 {\n                ans += p2[w-i];\n                ans %= MOD;\n            }\n        }\n        let mut md = polymod(x.clone(), g);\n        while md.len() < gl-1 {\n            md.insert(0, 0);\n        }\n\n        let mut ov = false;\n        for i in (0..gl-1).rev() {\n            if md[i] > x[w+i+1] {\n                ov = true;\n                break;\n            }\n        }\n        if !ov {\n            ans += 1;\n        }\n    } else {\n        // zero\n        ans = 1;\n    }\n    println!(\"{}\", ans % MOD);\n}\n"
  }
]