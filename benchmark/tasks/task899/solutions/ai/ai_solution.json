[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100005\n#define MAX_LOG 20\n\ntypedef struct Edge {\n    int to;\n    int length;\n    struct Edge* next;\n} Edge;\n\nEdge* graph[MAX_N];\nint depth[MAX_N];\nint parent[MAX_N][MAX_LOG];\nint dist[MAX_N][MAX_LOG];\nint n, k;\n\nvoid add_edge(int u, int v, int w) {\n    Edge* edge = malloc(sizeof(Edge));\n    edge->to = v;\n    edge->length = w;\n    edge->next = graph[u];\n    graph[u] = edge;\n}\n\nvoid dfs(int node, int par, int d) {\n    depth[node] = d;\n    parent[node][0] = par;\n    \n    for (int j = 1; j < MAX_LOG; j++) {\n        if (parent[node][j-1] != -1) {\n            parent[node][j] = parent[parent[node][j-1]][j-1];\n            dist[node][j] = dist[node][j-1] + dist[parent[node][j-1]][j-1];\n        }\n    }\n    \n    for (Edge* edge = graph[node]; edge; edge = edge->next) {\n        if (edge->to != par) {\n            dist[edge->to][0] = edge->length;\n            dfs(edge->to, node, d + 1);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    \n    for (int j = MAX_LOG - 1; j >= 0; j--) {\n        if (parent[u][j] != -1 && depth[parent[u][j]] >= depth[v]) {\n            u = parent[u][j];\n        }\n    }\n    \n    if (u == v) return u;\n    \n    for (int j = MAX_LOG - 1; j >= 0; j--) {\n        if (parent[u][j] != parent[v][j]) {\n            u = parent[u][j];\n            v = parent[v][j];\n        }\n    }\n    \n    return parent[u][0];\n}\n\nint get_distance(int u, int v) {\n    int common = lca(u, v);\n    int dist_u = 0, dist_v = 0;\n    \n    for (int j = MAX_LOG - 1; j >= 0; j--) {\n        if (parent[u][j] != -1 && depth[parent[u][j]] >= depth[common]) {\n            dist_u += dist[u][j];\n            u = parent[u][j];\n        }\n        if (parent[v][j] != -1 && depth[parent[v][j]] >= depth[common]) {\n            dist_v += dist[v][j];\n            v = parent[v][j];\n        }\n    }\n    \n    return dist_u + dist_v;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    \n    memset(parent, -1, sizeof(parent));\n    memset(dist, 0, sizeof(dist));\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        add_edge(u, v, w);\n        add_edge(v, u, w);\n    }\n    \n    dfs(1, -1, 0);\n    \n    int q;\n    scanf(\"%d\", &q);\n    \n    while (q--) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        \n        int dist_x_k = get_distance(x, k);\n        int dist_y_k = get_distance(y, k);\n        int dist_x_y = get_distance(x, y);\n        \n        printf(\"%d\\n\", dist_x_k + dist_y_k);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:16:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n#define MAX_LOG 20\n\ntypedef struct {\n    int to, len;\n} Edge;\n\nEdge edges[MAX_N * 2];\nint head[MAX_N + 1], next_edge[MAX_N * 2];\nint edge_count = 0;\n\nint depth[MAX_N + 1];\nint parent[MAX_LOG][MAX_N + 1];\nlong long dist[MAX_N + 1];\n\nvoid add_edge(int u, int v, int len) {\n    edges[edge_count] = (Edge){v, len};\n    next_edge[edge_count] = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u, int p, int d, long long current_dist) {\n    parent[0][u] = p;\n    depth[u] = d;\n    dist[u] = current_dist;\n    for (int i = head[u]; i != -1; i = next_edge[i]) {\n        Edge e = edges[i];\n        if (e.to != p) {\n            dfs(e.to, u, d + 1, current_dist + e.len);\n        }\n    }\n}\n\nvoid build_lca(int N) {\n    for (int k = 0; k + 1 < MAX_LOG; k++) {\n        for (int v = 1; v <= N; v++) {\n            if (parent[k][v] == -1) {\n                parent[k + 1][v] = -1;\n            } else {\n                parent[k + 1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] > depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    for (int k = MAX_LOG - 1; k >= 0; k--) {\n        if (((depth[v] - depth[u]) >> k) & 1) {\n            v = parent[k][v];\n        }\n    }\n    if (u == v) return u;\n    for (int k = MAX_LOG - 1; k >= 0; k--) {\n        if (parent[k][u] != parent[k][v]) {\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nlong long get_dist(int u, int v) {\n    int ancestor = lca(u, v);\n    return dist[u] + dist[v] - 2 * dist[ancestor];\n}\n\nint main() {\n    int N, Q, K;\n    scanf(\"%d\", &N);\n    \n    memset(head, -1, sizeof(head));\n    for (int i = 0; i < N - 1; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        add_edge(a, b, c);\n        add_edge(b, a, c);\n    }\n    \n    memset(parent, -1, sizeof(parent));\n    dfs(1, -1, 0, 0);\n    build_lca(N);\n    \n    scanf(\"%d %d\", &Q, &K);\n    \n    for (int i = 0; i < Q; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        long long d1 = get_dist(x, K);\n        long long d2 = get_dist(K, y);\n        printf(\"%lld\\n\", d1 + d2);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvoid bfs(int start, vector<int>& dist, const vector<vector<pair<int, int>>>& adj) {\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (const auto& edge : adj[u]) {\n            int v = edge.first;\n            int w = edge.second;\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + w;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    vector<vector<pair<int, int>>> adj(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        adj[a].emplace_back(b, c);\n        adj[b].emplace_back(a, c);\n    }\n\n    int Q, K;\n    cin >> Q >> K;\n\n    vector<int> dist_from_K(N + 1, -1);\n    bfs(K, dist_from_K, adj);\n\n    while (Q--) {\n        int x, y;\n        cin >> x >> y;\n        cout << dist_from_K[x] + dist_from_K[y] << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class TreeShortestPath {\n    static class Edge {\n        int to, length;\n        Edge(int to, int length) {\n            this.to = to;\n            this.length = length;\n        }\n    }\n\n    static List<List<Edge>> tree;\n    static int[] distFromK;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] parts = br.readLine().split(\" \");\n        int N = Integer.parseInt(parts[0]);\n        int Q = Integer.parseInt(parts[1]);\n        int K = Integer.parseInt(parts[2]);\n\n        tree = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            tree.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            parts = br.readLine().split(\" \");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int l = Integer.parseInt(parts[2]);\n            tree.get(a).add(new Edge(b, l));\n            tree.get(b).add(new Edge(a, l));\n        }\n\n        distFromK = new int[N + 1];\n        Arrays.fill(distFromK, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(K);\n        distFromK[K] = 0;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (Edge edge : tree.get(u)) {\n                if (distFromK[edge.to] == -1) {\n                    distFromK[edge.to] = distFromK[u] + edge.length;\n                    queue.add(edge.to);\n                }\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int q = 0; q < Q; q++) {\n            parts = br.readLine().split(\" \");\n            int x = Integer.parseInt(parts[0]);\n            int y = Integer.parseInt(parts[1]);\n            sb.append(distFromK[x] + distFromK[y]).append('\\n');\n        }\n        System.out.print(sb.toString());\n    }\n}",
    "timestamp": "2025-08-05 23:17:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class TreePathQuery {\n    static final int MAXN = 100005;\n    static List<List<Pair>> graph = new ArrayList<>();\n    static int[][] parent = new int[MAXN][20];\n    static int[] depth = new int[MAXN];\n    static long[][] dist = new long[MAXN][20];\n\n    static class Pair {\n        int node, weight;\n        Pair(int node, int weight) {\n            this.node = node;\n            this.weight = weight;\n        }\n    }\n\n    static void dfs(int u, int p, int d) {\n        parent[u][0] = p;\n        depth[u] = d;\n        for (Pair v : graph.get(u)) {\n            if (v.node != p) {\n                dist[v.node][0] = v.weight;\n                dfs(v.node, u, d + 1);\n            }\n        }\n    }\n\n    static void precompute(int n) {\n        for (int j = 1; j < 20; j++) {\n            for (int i = 1; i <= n; i++) {\n                if (parent[i][j-1] != 0) {\n                    parent[i][j] = parent[parent[i][j-1]][j-1];\n                    dist[i][j] = dist[i][j-1] + dist[parent[i][j-1]][j-1];\n                }\n            }\n        }\n    }\n\n    static long lca_distance(int x, int y, int k) {\n        if (depth[x] < depth[y]) {\n            int temp = x;\n            x = y;\n            y = temp;\n        }\n\n        long total_dist = 0;\n        for (int j = 19; j >= 0; j--) {\n            if (parent[x][j] != 0 && depth[parent[x][j]] >= depth[y]) {\n                total_dist += dist[x][j];\n                x = parent[x][j];\n            }\n        }\n\n        if (x == y) {\n            return findPathThroughK(x, k);\n        }\n\n        for (int j = 19; j >= 0; j--) {\n            if (parent[x][j] != parent[y][j]) {\n                total_dist += dist[x][j] + dist[y][j];\n                x = parent[x][j];\n                y = parent[y][j];\n            }\n        }\n\n        total_dist += dist[x][0] + dist[y][0];\n        int lca = parent[x][0];\n\n        return findPathThroughK(lca, k) + total_dist;\n    }\n\n    static long findPathThroughK(int lca, int k) {\n        int current = k;\n        long path_to_k = 0;\n        \n        while (current != lca) {\n            for (int j = 19; j >= 0; j--) {\n                if (parent[current][j] != 0 && depth[parent[current][j]] >= depth[lca]) {\n                    path_to_k += dist[current][j];\n                    current = parent[current][j];\n                }\n            }\n        }\n        \n        return path_to_k;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int q = Integer.parseInt(st.nextToken());\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 1; i < n; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            int w = Integer.parseInt(st.nextToken());\n            graph.get(u).add(new Pair(v, w));\n            graph.get(v).add(new Pair(u, w));\n        }\n\n        dfs(1, 0, 0);\n        precompute(n);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < q; i++) {\n            st = new StringTokenizer(br.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            sb.append(lca_distance(x, y, k)).append(\"\\n\");\n        }\n\n        System.out.print(sb);\n    }\n}",
    "timestamp": "2025-08-05 23:18:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<pair<int, int>> graph[MAXN];\nint dist_from_start[MAXN];\nint dist_from_k[MAXN];\nint n, q, k;\n\nvoid dijkstra(int start, int dist[]) {\n    for (int i = 1; i <= n; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[start] = 0;\n    \n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int curr_dist = pq.top().first;\n        int curr_node = pq.top().second;\n        pq.pop();\n        \n        if (curr_dist > dist[curr_node]) continue;\n        \n        for (auto& edge : graph[curr_node]) {\n            int next_node = edge.first;\n            int weight = edge.second;\n            \n            if (dist[curr_node] + weight < dist[next_node]) {\n                dist[next_node] = dist[curr_node] + weight;\n                pq.push({dist[next_node], next_node});\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> n >> q >> k;\n    \n    for (int i = 1; i < n; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n        graph[v].push_back({u, w});\n    }\n    \n    dijkstra(k, dist_from_k);\n    \n    for (int j = 0; j < q; j++) {\n        int x, y;\n        cin >> x >> y;\n        \n        dijkstra(x, dist_from_start);\n        \n        int result = dist_from_start[k] + dist_from_k[y];\n        cout << result << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef preprocess_tree(N, edges):\n    adjacency_list = defaultdict(list)\n    for u, v, length in edges:\n        adjacency_list[u].append((v, length))\n        adjacency_list[v].append((u, length))\n    return adjacency_list\n\ndef dijkstra(adjacency_list, start_node, N):\n    distances = {node: float('inf') for node in range(1, N+1)}\n    distances[start_node] = 0\n    queue = deque([(start_node, 0)])\n    \n    while queue:\n        current_node, current_distance = queue.popleft()\n        for neighbor, length in adjacency_list[current_node]:\n            distance = current_distance + length\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append((neighbor, distance))\n    \n    return distances\n\ndef solve(N, edges, Q, K, queries):\n    adjacency_list = preprocess_tree(N, edges)\n    distances_from_K = dijkstra(adjacency_list, K, N)\n    \n    results = []\n    for x, y in queries:\n        results.append(distances_from_K[x] + distances_from_K[y])\n    \n    return results\n\n# Example usage:\n# N = number of vertices\n# edges = [(u, v, length), ...]\n# Q = number of queries\n# K = integer vertex required in the path\n# queries = [(x1, y1), (x2, y2), ...]\n\n# result = solve(N, edges, Q, K, queries)",
    "timestamp": "2025-08-13 14:25:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreePathQueries {\n    static class Edge {\n        int to, length;\n        Edge(int to, int length) {\n            this.to = to;\n            this.length = length;\n        }\n    }\n\n    private static void dfs(int node, int parent, int[] dist, List<Edge>[] tree) {\n        for (Edge edge : tree[node]) {\n            if (edge.to != parent) {\n                dist[edge.to] = dist[node] + edge.length;\n                dfs(edge.to, node, dist, tree);\n            }\n        }\n    }\n\n    public static int[] shortestPathsThroughK(int N, int[][] edges, int Q, int[][] queries, int K) {\n        List<Edge>[] tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        \n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], length = edge[2];\n            tree[u].add(new Edge(v, length));\n            tree[v].add(new Edge(u, length));\n        }\n\n        int[] distFromK = new int[N + 1];\n        Arrays.fill(distFromK, 0);\n        dfs(K, -1, distFromK, tree);\n        \n        int[] result = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            int x = queries[i][0];\n            int y = queries[i][1];\n            result[i] = distFromK[x] + distFromK[y];\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        int N = 5; // number of vertices\n        int[][] edges = {\n            {1, 2, 3},\n            {2, 3, 4},\n            {2, 4, 5},\n            {4, 5, 6}\n        };\n        int Q = 2; // number of queries\n        int[][] queries = {\n            {1, 5},\n            {3, 4}\n        };\n        int K = 2; // given vertex K\n\n        int[] results = shortestPathsThroughK(N, edges, Q, queries, K);\n        System.out.println(Arrays.toString(results));\n    }\n}",
    "timestamp": "2025-08-13 14:25:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAXN 100000\n\ntypedef struct {\n    int to;\n    int length;\n    struct Edge* next;\n} Edge;\n\nEdge* graph[MAXN];\nint dist[MAXN];\n\nvoid addEdge(int u, int v, int length) {\n    Edge* edge = (Edge*)malloc(sizeof(Edge));\n    edge->to = v;\n    edge->length = length;\n    edge->next = graph[u];\n    graph[u] = edge;\n}\n\nvoid dfs(int node, int parent, int currentDist) {\n    dist[node] = currentDist;\n    for (Edge* edge = graph[node]; edge != NULL; edge = edge->next) {\n        if (edge->to != parent) {\n            dfs(edge->to, node, currentDist + edge->length);\n        }\n    }\n}\n\nint main() {\n    int N, Q, K;\n    scanf(\"%d %d %d\", &N, &Q, &K);\n    K--; // Convert to 0-based indexing\n\n    for (int i = 0; i < N; ++i) {\n        graph[i] = NULL;\n    }\n\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v, length;\n        scanf(\"%d %d %d\", &u, &v, &length);\n        u--; v--; // Convert to 0-based indexing\n        addEdge(u, v, length);\n        addEdge(v, u, length);\n    }\n\n    dfs(K, -1, 0);\n\n    for (int i = 0; i < Q; ++i) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--; y--; // Convert to 0-based indexing\n        int shortestPathLength = dist[x] + dist[y] - 2 * dist[K];\n        printf(\"%d\\n\", shortestPathLength);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:25:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\nvector<vector<pair<int, int>>> adj;\nvector<int> dist;\n\nvoid dijkstra(int start) {\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    dist[start] = 0;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        \n        if (d > dist[u]) continue;\n        \n        for (auto& edge : adj[u]) {\n            int v = edge.first;\n            int len = edge.second;\n            \n            if (dist[u] + len < dist[v]) {\n                dist[v] = dist[u] + len;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    int N, Q, K;\n    cin >> N >> Q >> K;\n    adj.resize(N + 1);\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    \n    dist.resize(N + 1, INF);\n    dijkstra(K);\n    \n    for (int i = 0; i < Q; ++i) {\n        int x, y;\n        cin >> x >> y;\n        cout << dist[x] + dist[y] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:25:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_tree_path_problem(N, edges, Q, K, queries):\n    # Create adjacency list representation of the tree\n    graph = defaultdict(list)\n    for u, v, length in edges:\n        graph[u].append((v, length))\n        graph[v].append((u, length))\n\n    # Function to find shortest paths from a source vertex\n    def dijkstra(source):\n        distances = [float('inf')] * (N + 1)\n        distances[source] = 0\n        pq = [(0, source)]\n        \n        while pq:\n            curr_dist, curr_node = min(pq)\n            pq.remove((curr_dist, curr_node))\n            \n            for neighbor, edge_length in graph[curr_node]:\n                dist = curr_dist + edge_length\n                if dist < distances[neighbor]:\n                    distances[neighbor] = dist\n                    pq.append((dist, neighbor))\n        \n        return distances\n\n    # Compute distances from vertex K to all other vertices\n    k_distances = dijkstra(K)\n\n    # Process queries\n    results = []\n    for x, y in queries:\n        # Shortest path through K is: x -> K -> y\n        path_length = k_distances[x] + k_distances[y]\n        results.append(path_length)\n\n    return results\n\n# Example usage\nN = 5  # Number of vertices\nedges = [(1, 2, 3), (1, 3, 4), (2, 4, 5), (3, 5, 6)]  # (u, v, length)\nQ = 3  # Number of queries\nK = 1  # Vertex through which path must pass\nqueries = [(2, 4), (3, 5), (1, 5)]  # (x, y) pairs\n\nresult = solve_tree_path_problem(N, edges, Q, K, queries)\nprint(result)",
    "timestamp": "2025-08-13 14:25:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        a = int(input[ptr])\n        b = int(input[ptr+1])\n        c = int(input[ptr+2])\n        ptr += 3\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n    \n    Q, K = map(int, input[ptr:ptr+2])\n    ptr += 2\n    \n    # BFS to compute distances from K\n    dist = [0] * (N + 1)\n    visited = [False] * (N + 1)\n    q = deque()\n    q.append(K)\n    visited[K] = True\n    \n    while q:\n        u = q.popleft()\n        for v, c in adj[u]:\n            if not visited[v]:\n                dist[v] = dist[u] + c\n                visited[v] = True\n                q.append(v)\n    \n    output = []\n    for _ in range(Q):\n        x = int(input[ptr])\n        y = int(input[ptr+1])\n        ptr += 2\n        res = dist[x] + dist[y]\n        output.append(str(res))\n    \n    print('\\n'.join(output))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 14:25:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function shortestPathThroughK(N, edges, Q, queries, K) {\n    // Create adjacency list representation of the tree\n    const graph = Array.from({ length: N + 1 }, () => []);\n    edges.forEach(([u, v, length]) => {\n        graph[u].push([v, length]);\n        graph[v].push([u, length]);\n    });\n\n    // Function to perform Dijkstra's algorithm from a given source vertex\n    function dijkstra(source) {\n        const dist = Array(N + 1).fill(Infinity);\n        const visited = Array(N + 1).fill(false);\n        const pq = [[0, source]];  // [distance, vertex]\n        dist[source] = 0;\n\n        while (pq.length > 0) {\n            pq.sort((a, b) => a[0] - b[0]);\n            const [currentDist, currentVertex] = pq.shift();\n            if (visited[currentVertex]) continue;\n            visited[currentVertex] = true;\n\n            graph[currentVertex].forEach(([neighbor, length]) => {\n                if (!visited[neighbor] && dist[currentVertex] + length < dist[neighbor]) {\n                    dist[neighbor] = dist[currentVertex] + length;\n                    pq.push([dist[neighbor], neighbor]);\n                }\n            });\n        }\n        return dist;\n    }\n\n    // Determine shortest path distances from vertex K\n    const distFromK = dijkstra(K);\n\n    // Determine shortest paths for each query\n    const results = queries.map(([x, y]) => distFromK[x] + distFromK[y]);\n    return results;\n}",
    "timestamp": "2025-08-13 14:26:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class Solution {\n    constructor(N) {\n        this.graph = Array.from({ length: N + 1 }, () => []);\n        this.dist = Array(N + 1).fill(0);\n    }\n\n    addEdge(u, v, length) {\n        this.graph[u].push([v, length]);\n        this.graph[v].push([u, length]);\n    }\n\n    dfs(node, parent, currentDist) {\n        this.dist[node] = currentDist;\n        for (let [neighbor, edgeLength] of this.graph[node]) {\n            if (neighbor !== parent) {\n                this.dfs(neighbor, node, currentDist + edgeLength);\n            }\n        }\n    }\n\n    findShortestPath(K, x, y) {\n        this.dist.fill(0);\n        this.dfs(K, 0, 0);\n\n        let distToK1 = this.dist[x];\n        this.dist.fill(0);\n        this.dfs(K, 0, 0);\n\n        let distToK2 = this.dist[y];\n        this.dist.fill(0);\n        this.dfs(x, 0, 0);\n\n        let distFromXtoY = this.dist[y];\n\n        return distToK1 + distToK2;\n    }\n\n    solve(queries, K) {\n        return queries.map(([x, y]) => this.findShortestPath(K, x, y));\n    }\n}",
    "timestamp": "2025-08-13 14:26:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n\nfunction main() {\n    let ptr = 0;\n    const [N, Q, K] = input[ptr++].split(' ').map(Number);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    \n    for (let i = 0; i < N - 1; i++) {\n        const [a, b, c] = input[ptr++].split(' ').map(Number);\n        adj[a].push([b, c]);\n        adj[b].push([a, c]);\n    }\n    \n    const distFromK = new Array(N + 1).fill(-1);\n    distFromK[K] = 0;\n    const queue = [K];\n    \n    while (queue.length > 0) {\n        const u = queue.shift();\n        for (const [v, c] of adj[u]) {\n            if (distFromK[v] === -1) {\n                distFromK[v] = distFromK[u] + c;\n                queue.push(v);\n            }\n        }\n    }\n    \n    const output = [];\n    for (let i = 0; i < Q; i++) {\n        const [x, y] = input[ptr++].split(' ').map(Number);\n        const res = distFromK[x] + distFromK[y];\n        output.push(res);\n    }\n    \n    console.log(output.join('\\n'));\n}\n\nmain();",
    "timestamp": "2025-08-13 14:26:46"
  }
]