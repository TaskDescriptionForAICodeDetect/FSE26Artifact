[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int votes;\n    int is_favorite;\n    int index;\n} Character;\n\nint compare(const void *a, const void *b) {\n    Character *charA = (Character *)a;\n    Character *charB = (Character *)b;\n    if (charB->votes != charA->votes) {\n        return charB->votes - charA->votes;\n    }\n    return charA->index - charB->index;\n}\n\nint main() {\n    int N, K, M, L;\n    scanf(\"%d %d %d %d\", &N, &K, &M, &L);\n\n    Character *chars = (Character *)malloc(N * sizeof(Character));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &chars[i].votes);\n        chars[i].index = i;\n        chars[i].is_favorite = 0;\n    }\n\n    for (int i = 0; i < M; i++) {\n        int fav;\n        scanf(\"%d\", &fav);\n        chars[fav - 1].is_favorite = 1;\n    }\n\n    qsort(chars, N, sizeof(Character), compare);\n\n    int needed_votes = 0;\n    for (int i = 0; i < N && L > 0; i++) {\n        if (chars[i].is_favorite) {\n            if (i < K) {\n                continue;\n            } else {\n                int target_votes = chars[K - 1].votes + 1;\n                int delta = target_votes - chars[i].votes;\n                if (delta <= L) {\n                    chars[i].votes = target_votes;\n                    L -= delta;\n                    needed_votes += delta;\n                } else {\n                    chars[i].votes += L;\n                    needed_votes += L;\n                    L = 0;\n                }\n            }\n        }\n    }\n\n    qsort(chars, N, sizeof(Character), compare);\n\n    int count = 0;\n    for (int i = 0; i < K; i++) {\n        if (chars[i].is_favorite) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    free(chars);\n    return 0;\n}",
    "timestamp": "2025-08-05 19:01:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class EverythingStartsWithYourVote {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int L = scanner.nextInt(); // Total votes available\n        int N = scanner.nextInt(); // Total characters\n        int K = scanner.nextInt(); // Top K characters for products\n        int M = scanner.nextInt(); // Number of favorite characters\n        \n        int[] initialVotes = new int[N];\n        boolean[] favorites = new boolean[N];\n        \n        for (int i = 0; i < N; i++) {\n            initialVotes[i] = scanner.nextInt();\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int favoriteIndex = scanner.nextInt() - 1;\n            favorites[favoriteIndex] = true;\n        }\n        \n        int[] currentVotes = Arrays.copyOf(initialVotes, N);\n        \n        // Sort initial votes in descending order\n        Integer[] indices = new Integer[N];\n        for (int i = 0; i < N; i++) {\n            indices[i] = i;\n        }\n        Arrays.sort(indices, (a, b) -> currentVotes[b] - currentVotes[a]);\n        \n        int maxFavorites = 0;\n        for (int[] distribution : generateDistributions(L, N)) {\n            int[] tempVotes = Arrays.copyOf(currentVotes, N);\n            \n            // Add votes according to distribution\n            for (int i = 0; i < N; i++) {\n                tempVotes[i] += distribution[i];\n            }\n            \n            // Re-sort indices based on new vote counts\n            Arrays.sort(indices, (a, b) -> tempVotes[b] - tempVotes[a]);\n            \n            // Count favorites in top K\n            int currentFavorites = 0;\n            for (int i = 0; i < K; i++) {\n                if (favorites[indices[i]]) {\n                    currentFavorites++;\n                }\n            }\n            \n            maxFavorites = Math.max(maxFavorites, currentFavorites);\n        }\n        \n        System.out.println(maxFavorites);\n        scanner.close();\n    }\n    \n    // Generate all possible vote distributions\n    private static List<int[]> generateDistributions(int totalVotes, int characters) {\n        List<int[]> distributions = new ArrayList<>();\n        generateDistributionsHelper(totalVotes, characters, new int[characters], 0, distributions);\n        return distributions;\n    }\n    \n    private static void generateDistributionsHelper(int remainingVotes, int characters, \n                                                    int[] currentDistribution, \n                                                    int index, \n                                                    List<int[]> distributions) {\n        if (index == characters - 1) {\n            currentDistribution[index] = remainingVotes;\n            distributions.add(Arrays.copyOf(currentDistribution, characters));\n            return;\n        }\n        \n        for (int votes = 0; votes <= remainingVotes; votes++) {\n            currentDistribution[index] = votes;\n            generateDistributionsHelper(remainingVotes - votes, \n                                        characters, \n                                        currentDistribution, \n                                        index + 1, \n                                        distributions);\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:01:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M, K, L;\n    cin >> N >> M >> K >> L;\n\n    vector<int> a(N);\n    vector<int> favorites(M);\n    vector<bool> is_favorite(N, false);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> a[i];\n    }\n\n    for (int i = 0; i < M; ++i) {\n        cin >> favorites[i];\n        favorites[i]--; // converting to 0-based index\n        is_favorite[favorites[i]] = true;\n    }\n\n    int max_in_top_k = 0;\n\n    // We need to try all possible ways to distribute L votes among favorites\n    // Since L can be up to 1e9 and M up to 10, this is not feasible.\n    // Instead, we can use a greedy approach: for each favorite, calculate the minimal votes needed to push them into top K.\n\n    vector<pair<int, int>> candidates;\n    for (int i = 0; i < N; ++i) {\n        if (!is_favorite[i]) {\n            candidates.emplace_back(a[i], i);\n        }\n    }\n\n    // Sort non-favorites in descending order of their votes\n    sort(candidates.begin(), candidates.end(), greater<pair<int, int>>());\n\n    // The threshold is the K-th highest vote count (including favorites)\n    // We need to find how many favorites are already in top K without any votes\n    vector<int> favorite_votes;\n    for (int f : favorites) {\n        favorite_votes.push_back(a[f]);\n    }\n    sort(favorite_votes.begin(), favorite_votes.end(), greater<int>());\n\n    int initial_in_top_k = 0;\n    vector<int> all_votes = a;\n    sort(all_votes.begin(), all_votes.end(), greater<int>());\n    int threshold = K < N ? all_votes[K] : 0;\n\n    for (int f : favorites) {\n        if (a[f] >= threshold) {\n            initial_in_top_k++;\n        }\n    }\n\n    max_in_top_k = initial_in_top_k;\n\n    // Now, we can try to promote other favorites by allocating votes to them\n    // The idea is to find the minimal votes needed for each favorite to reach the K-th position\n\n    vector<int> required_votes;\n    for (int f : favorites) {\n        if (a[f] >= threshold) {\n            // Already in top K, no votes needed\n            required_votes.push_back(0);\n        } else {\n            // Need to get at least threshold + 1 votes\n            int needed = threshold - a[f] + 1;\n            required_votes.push_back(needed);\n        }\n    }\n\n    // Sort required_votes in ascending order to use as few votes as possible\n    sort(required_votes.begin(), required_votes.end());\n\n    int total_used = 0;\n    int count = 0;\n    for (int v : required_votes) {\n        if (total_used + v <= L) {\n            total_used += v;\n            count++;\n        } else {\n            break;\n        }\n    }\n\n    max_in_top_k = max(max_in_top_k, count);\n\n    // Another strategy: push one favorite very high to exclude non-favorites from top K\n    // This might allow more favorites to naturally appear in top K\n\n    if (K < N && candidates.size() >= K) {\n        int non_favorite_threshold = candidates[K - 1].first;\n        for (int f : favorites) {\n            if (a[f] < non_favorite_threshold) {\n                int needed = non_favorite_threshold - a[f] + 1;\n                if (needed <= L) {\n                    // Check how many favorites are already above non_favorite_threshold\n                    int temp_count = 0;\n                    for (int fav : favorites) {\n                        if (a[fav] >= non_favorite_threshold || (fav == f && (a[f] + needed) >= non_favorite_threshold)) {\n                            temp_count++;\n                        }\n                    }\n                    if (temp_count > max_in_top_k) {\n                        max_in_top_k = temp_count;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << max_in_top_k << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_CHARS 1000\n\ntypedef struct {\n    int index;\n    int predicted_votes;\n    int additional_votes;\n} Character;\n\nint compare(const void* a, const void* b) {\n    Character* charA = (Character*)a;\n    Character* charB = (Character*)b;\n    int totalA = charA->predicted_votes + charA->additional_votes;\n    int totalB = charB->predicted_votes + charB->additional_votes;\n    \n    if (totalA != totalB) {\n        return totalB - totalA;\n    }\n    return charA->index - charB->index;\n}\n\nint is_favorite(int* favorites, int M, int index) {\n    for (int i = 0; i < M; i++) {\n        if (favorites[i] == index) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int L, N, K, M;\n    int favorites[MAX_CHARS];\n    Character chars[MAX_CHARS];\n\n    scanf(\"%d %d %d %d\", &L, &N, &K, &M);\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &favorites[i]);\n        favorites[i]--;\n    }\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &chars[i].predicted_votes);\n        chars[i].index = i;\n        chars[i].additional_votes = 0;\n    }\n    \n    int remaining_votes = L;\n    \n    // First, allocate votes to favorites not in top K\n    for (int i = 0; i < M; i++) {\n        qsort(chars, N, sizeof(Character), compare);\n        \n        if (is_favorite(favorites, M, chars[K-1].index)) {\n            break;\n        }\n        \n        int need_votes = chars[K-1].predicted_votes + 1 - \n                         chars[favorites[i]].predicted_votes - \n                         chars[favorites[i]].additional_votes;\n        \n        if (need_votes > 0) {\n            int votes_to_add = (need_votes < remaining_votes) ? need_votes : remaining_votes;\n            chars[favorites[i]].additional_votes += votes_to_add;\n            remaining_votes -= votes_to_add;\n        }\n    }\n    \n    // If votes remain, distribute to any favorites\n    qsort(chars, N, sizeof(Character), compare);\n    \n    for (int i = 0; i < M && remaining_votes > 0; i++) {\n        if (!is_favorite(favorites, M, chars[K-1].index)) {\n            chars[favorites[i]].additional_votes += remaining_votes;\n            break;\n        }\n    }\n    \n    qsort(chars, N, sizeof(Character), compare);\n    \n    int favorites_in_top_k = 0;\n    for (int i = 0; i < K; i++) {\n        if (is_favorite(favorites, M, chars[i].index)) {\n            favorites_in_top_k++;\n        }\n    }\n    \n    printf(\"%d\\n\", favorites_in_top_k);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int L, N, K, M;\n    cin >> L >> N >> K >> M;\n\n    vector<int> predicted_votes(N);\n    vector<int> favorite_characters(M);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> predicted_votes[i];\n    }\n    \n    for (int i = 0; i < M; i++) {\n        cin >> favorite_characters[i];\n        favorite_characters[i]--;\n    }\n    \n    vector<int> votes = predicted_votes;\n    int remaining_votes = L;\n    \n    while (remaining_votes > 0) {\n        vector<pair<int, int>> vote_diff;\n        \n        for (int i = 0; i < M; i++) {\n            int char_index = favorite_characters[i];\n            int current_position = distance(votes.begin(), \n                max_element(votes.begin(), votes.end()));\n            \n            votes[char_index]++;\n            int new_position = distance(votes.begin(), \n                max_element(votes.begin(), votes.end()));\n            \n            vote_diff.push_back({current_position - new_position, char_index});\n            votes[char_index]--;\n        }\n        \n        sort(vote_diff.rbegin(), vote_diff.rend());\n        \n        int best_char = vote_diff[0].second;\n        votes[best_char]++;\n        remaining_votes--;\n    }\n    \n    vector<pair<int, int>> final_ranking;\n    for (int i = 0; i < N; i++) {\n        final_ranking.push_back({votes[i], -i});\n    }\n    \n    sort(final_ranking.rbegin(), final_ranking.rend());\n    \n    int favorites_in_top_k = 0;\n    for (int i = 0; i < K; i++) {\n        int character = -final_ranking[i].second;\n        if (find(favorite_characters.begin(), favorite_characters.end(), character) \n            != favorite_characters.end()) {\n            favorites_in_top_k++;\n        }\n    }\n    \n    cout << favorites_in_top_k << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        int L = scanner.nextInt();\n        \n        int[] a = new int[N];\n        int[] favorites = new int[M];\n        for (int i = 0; i < N; i++) {\n            a[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < M; i++) {\n            favorites[i] = scanner.nextInt() - 1;\n        }\n        \n        int maxCount = 0;\n        \n        for (int mask = 0; mask < (1 << M); mask++) {\n            int[] tempA = a.clone();\n            int votesUsed = 0;\n            \n            for (int i = 0; i < M; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    tempA[favorites[i]] += L;\n                    votesUsed = L;\n                    break;\n                }\n            }\n            \n            if (votesUsed > L) {\n                continue;\n            }\n            \n            int[] sorted = tempA.clone();\n            Arrays.sort(sorted);\n            int threshold = sorted[N - K];\n            int count = 0;\n            \n            for (int i = 0; i < M; i++) {\n                if (tempA[favorites[i]] >= threshold) {\n                    count++;\n                }\n            }\n            \n            if (count > maxCount) {\n                maxCount = count;\n            }\n        }\n        \n        System.out.println(maxCount);\n    }\n}",
    "timestamp": "2025-08-05 19:03:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\n\ndef maximize_favorites(n, k, m, votes, l, favorites):\n    max_favs_in_top_k = 0\n    \n    def get_top_k(allocations):\n        total_votes = [votes[i] + allocations[i] for i in range(n)]\n        sorted_indices = sorted(range(n), key=lambda x: -total_votes[x])\n        top_k = sorted_indices[:k]\n        return top_k\n    \n    def count_favorites_in_top_k(top_k):\n        return len([fav for fav in favorites if fav in top_k])\n    \n    for allocation in combinations(range(l + 1), n):\n        if sum(allocation) == l:\n            top_k_list = get_top_k(allocation)\n            current_favs_in_top_k = count_favorites_in_top_k(top_k_list)\n            if current_favs_in_top_k > max_favs_in_top_k:\n                max_favs_in_top_k = current_favs_in_top_k\n                \n    return max_favs_in_top_k\n\n# Sample usage\n# n = 5  # Total characters\n# k = 3  # Top K characters\n# m = 2  # Number of your favorite characters\n# votes = [5, 7, 6, 3, 8]  # Predicted votes based on screen time for each character\n# l = 9  # Your available votes to use\n# favorites = [1, 3]  # Indices of your favorite characters (0-based indexing)\n\n# print(maximize_favorites(n, k, m, votes, l, favorites))",
    "timestamp": "2025-08-13 02:06:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class AnimePopularityVoter {\n\n    static class Character {\n        int predictedVotes;\n        int id;\n        boolean isFavorite;\n        \n        Character(int id, int predictedVotes, boolean isFavorite) {\n            this.id = id;\n            this.predictedVotes = predictedVotes;\n            this.isFavorite = isFavorite;\n        }\n    }\n    \n    public static int maximizeFavorites(int[] predictedVotes, int[] favoriteCharacters, int N, int L, int K) {\n        int M = favoriteCharacters.length;\n        boolean[] isFavorite = new boolean[N];\n    \n        for (int f : favoriteCharacters) {\n            isFavorite[f] = true;\n        }\n    \n        Character[] characters = new Character[N];\n        for (int i = 0; i < N; i++) {\n            characters[i] = new Character(i, predictedVotes[i], isFavorite[i]);\n        }\n        \n        Arrays.sort(characters, (a, b) -> b.predictedVotes - a.predictedVotes);\n    \n        int additionalVotes = 0;\n        for (Character character : characters) {\n            if (character.isFavorite) additionalVotes++;\n            if (additionalVotes == K) break;\n        }\n        \n        int[] voteChanges = new int[N];\n        for (int i = 0; i < K; i++) {\n            if (!characters[i].isFavorite) {\n                for (int j = K; j < N; j++) {\n                    if (characters[j].isFavorite) {\n                        int votesNeeded = characters[i].predictedVotes - characters[j].predictedVotes + 1;\n                        voteChanges[j] = Math.max(voteChanges[j], votesNeeded);\n                        break;\n                    }\n                }\n            }\n        }\n        \n        Arrays.sort(voteChanges);\n        \n        int totalVotesDistributed = 0;\n        int numbersOfFavoritesMaximized = 0;\n        \n        for (int i = 0; i < N && totalVotesDistributed < L; i++) {\n            if (totalVotesDistributed + voteChanges[i] <= L) {\n                totalVotesDistributed += voteChanges[i];\n                numbersOfFavoritesMaximized++;\n            } else {\n                break;\n            }\n        }\n\n        return numbersOfFavoritesMaximized;\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int[] predictedVotes = {10, 12, 8, 15, 7};\n        int[] favoriteCharacters = {0, 3};\n        int L = 10;\n        int K = 3;\n        \n        int result = maximizeFavorites(predictedVotes, favoriteCharacters, N, L, K);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 02:06:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int predictedVotes;\n    int isFavorite;\n} Character;\n\nint compare(const void *a, const void *b) {\n    Character *char1 = (Character *)a;\n    Character *char2 = (Character *)b;\n    if (char1->predictedVotes != char2->predictedVotes)\n        return char2->predictedVotes - char1->predictedVotes;\n    return char2->isFavorite - char1->isFavorite;\n}\n\nvoid maximizeFavoritesInTopK(int *predictedVotes, int L, int N, int K, int *favorites, int M) {\n    Character characters[N];\n    for (int i = 0; i < N; ++i) {\n        characters[i].id = i;\n        characters[i].predictedVotes = predictedVotes[i];\n        characters[i].isFavorite = 0;\n    }\n\n    for (int i = 0; i < M; ++i) {\n        characters[favorites[i]].isFavorite = 1;\n    }\n\n    qsort(characters, N, sizeof(Character), compare);\n\n    for (int i = 0; i < K; ++i) {\n        if (characters[i].isFavorite == 0) {\n            for (int j = K; j < N; ++j) {\n                if (characters[j].isFavorite == 1) {\n                    characters[i].predictedVotes += L;\n                    L = 0;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (L > 0) {\n        // Distribute remaining votes to the favorites in the top K to ensure their position\n        for (int i = 0; i < K; ++i) {\n            if (characters[i].isFavorite == 1) {\n                characters[i].predictedVotes += L;\n                break;\n            }\n        }\n    }\n\n    qsort(characters, N, sizeof(Character), compare);\n\n    printf(\"Final vote distribution:\\n\");\n    for (int i = 0; i < N; ++i) {\n        printf(\"Character %d: %d votes\\n\", characters[i].id, characters[i].predictedVotes);\n    }\n}\n\nint main() {\n    int predictedVotes[] = {10, 20, 30, 40, 50}; // Example predicted votes\n    int L = 10; // Example votes you can distribute\n    int N = 5; // Total characters\n    int K = 3; // Top K characters' products will be made\n    int favorites[] = {1, 3}; // Your favorite characters\n    int M = 2; // Number of your favorite characters\n\n    maximizeFavoritesInTopK(predictedVotes, L, N, K, favorites, M);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:07:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_voting_problem(L, N, K, M, predicted_votes):\n    # Create a list of (character index, predicted votes) tuples\n    characters = list(enumerate(predicted_votes))\n    \n    # Sort characters by predicted votes in descending order\n    characters.sort(key=lambda x: x[1], reverse=True)\n    \n    # Track your favorite characters\n    favorites = set()\n    for i in range(M):\n        favorites.add(characters[i][0])\n    \n    # Initial top K characters without your votes\n    initial_top_k = set(char[0] for char in characters[:K])\n    \n    # Characters to boost\n    boost_chars = []\n    for i, (idx, votes) in enumerate(characters):\n        if idx not in initial_top_k and idx in favorites:\n            boost_chars.append((idx, votes, i))\n    \n    # Sort boost candidates by how close they are to top K\n    boost_chars.sort(key=lambda x: x[2])\n    \n    # Allocate votes\n    votes_left = L\n    for char_idx, current_votes, _ in boost_chars:\n        if votes_left == 0:\n            break\n        \n        # Find the character just above this one\n        threshold = characters[K-1][1]\n        \n        # Calculate votes needed to push this character into top K\n        votes_needed = max(0, threshold + 1 - current_votes)\n        votes_to_add = min(votes_needed, votes_left)\n        \n        current_votes += votes_to_add\n        votes_left -= votes_to_add\n    \n    # Re-sort with updated votes\n    updated_characters = [(idx, votes + (L-votes_left)) for idx, votes in predicted_votes]\n    updated_characters.sort(key=lambda x: x[1], reverse=True)\n    \n    # Count favorites in top K\n    favorites_in_top_k = sum(1 for idx, _ in updated_characters[:K] if idx in favorites)\n    \n    return favorites_in_top_k\n\n# Input parsing and solving\ndef main():\n    L, N, K, M = map(int, input().split())\n    predicted_votes = list(map(int, input().split()))\n    \n    result = solve_voting_problem(L, N, K, M, predicted_votes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:07:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N, M, K, L = map(int, data[idx:idx+4])\n    idx +=4\n    favorites = list(map(int, data[idx:idx+M]))\n    idx +=M\n    votes = list(map(int, data[idx:idx+N]))\n    \n    # Convert to 0-based index\n    favorites = [x-1 for x in favorites]\n    \n    # We need to find the minimal votes needed for each favorite to be in top K\n    # The approach is to determine the threshold for each favorite to be in top K\n    \n    # The initial votes are sorted, but we need to consider the votes we add\n    # So, for each favorite, we can compute the minimal votes needed to be >= the K-th largest vote\n    \n    # First, sort all characters by their current votes in descending order\n    # We can use a list of tuples (votes, index)\n    characters = [(votes[i], i) for i in range(N)]\n    characters.sort(reverse=True, key=lambda x: (x[0], x[1]))\n    \n    # The current K-th vote is characters[K-1][0]\n    current_K_vote = characters[K-1][0]\n    \n    res = 0\n    remaining_votes = L\n    \n    # For each favorite, check if it's already in top K\n    # If not, calculate the votes needed to reach current_K_vote + 1 (to surpass)\n    needed_votes = []\n    for fav in favorites:\n        if characters[fav][0] >= current_K_vote:\n            # Already in top K, no need to add votes\n            pass\n        else:\n            # Need to add (current_K_vote - characters[fav][0] + 1)\n            needed = current_K_vote - characters[fav][0] + 1\n            needed_votes.append(needed)\n    \n    needed_votes.sort()\n    \n    count = 0\n    total = 0\n    for need in needed_votes:\n        if total + need <= L:\n            total += need\n            count +=1\n        else:\n            break\n    print(count)\n\nsolve()",
    "timestamp": "2025-08-13 02:07:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct Character {\n    int id;\n    int votes;\n    bool isFavorite;\n\n    bool operator<(const Character &other) const {\n        if (votes != other.votes) return votes > other.votes;\n        return id < other.id;\n    }\n};\n\nint main() {\n    int N, M, K, L;\n    cin >> N >> M >> K >> L;\n    vector<Character> characters(N);\n\n    // Reading initial votes\n    for (int i = 0; i < N; ++i) {\n        int votes;\n        cin >> votes;\n        characters[i] = {i, votes, false};\n    }\n\n    // Reading favorite characters\n    for (int i = 0; i < M; ++i) {\n        int favIdx;\n        cin >> favIdx;\n        characters[favIdx - 1].isFavorite = true;\n    }\n\n    auto isTopKFavorite = [&](vector<Character> &cVec) {\n        sort(cVec.begin(), cVec.end());\n        int count = 0;\n        for (int i = 0; i < K; ++i) {\n            if (cVec[i].isFavorite) {\n                count++;\n            }\n        }\n        return count;\n    };\n\n    int maxFavorites = 0;\n    vector<Character> bestAllocation = characters;\n\n    // Try allocating votes and check which allocation gives the max favorite characters in top K\n    for (int favIdx = 0; favIdx < N; ++favIdx) {\n        if (!characters[favIdx].isFavorite) continue;\n\n        vector<Character> currentAllocation = characters;\n        currentAllocation[favIdx].votes += L;\n        int currentFavorites = isTopKFavorite(currentAllocation);\n\n        if (currentFavorites > maxFavorites) {\n            bestAllocation = currentAllocation;\n            maxFavorites = currentFavorites;\n        }\n    }\n\n    // Output the number of votes for each character after allocation\n    for (int i = 0; i < N; ++i) {\n        cout << bestAllocation[i].votes << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:04:17"
  }
]