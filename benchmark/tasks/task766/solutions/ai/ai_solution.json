[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n\nint main() {\n    int N;\n    int A[MAX_N][MAX_N];\n    bool possible_champion[MAX_N];\n\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n        possible_champion[i] = true;\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n\n            bool can_win = false;\n            bool candidate_path[MAX_N] = {false};\n            candidate_path[i] = true;\n\n            for (int k = 0; k < N; k++) {\n                if (k == i || k == j) continue;\n                bool path_exists = true;\n\n                for (int curr = i; curr != j;) {\n                    bool found_next = false;\n                    for (int next = 0; next < N; next++) {\n                        if (next == curr) continue;\n                        if (!candidate_path[next] && A[curr][next] == 1) {\n                            curr = next;\n                            candidate_path[next] = true;\n                            found_next = true;\n                            break;\n                        }\n                    }\n                    if (!found_next) {\n                        path_exists = false;\n                        break;\n                    }\n                }\n\n                if (path_exists && A[curr][j] == 1) {\n                    can_win = true;\n                    break;\n                }\n            }\n\n            if (!can_win) {\n                possible_champion[i] = false;\n            }\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        if (possible_champion[i]) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool canWin(int N, int A[N][N], int candidate) {\n    bool alive[N];\n    for (int i = 0; i < N; i++) {\n        alive[i] = true;\n    }\n    \n    int remaining = N;\n    while (remaining > 1) {\n        int prev = -1;\n        for (int i = 0; i < N; i++) {\n            if (!alive[i]) continue;\n            if (prev == -1) {\n                prev = i;\n            } else {\n                if (A[prev][i] == 1) {\n                    alive[i] = false;\n                } else {\n                    alive[prev] = false;\n                    prev = i;\n                }\n                remaining--;\n                if (remaining == 1) break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        if (alive[i]) {\n            return i == candidate;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int A[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n    \n    int count = 0;\n    for (int candidate = 0; candidate < N; candidate++) {\n        if (canWin(N, A, candidate)) {\n            count++;\n        }\n    }\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> A(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> A[i][j];\n        }\n    }\n\n    vector<bool> can_win(N, false);\n    can_win[0] = true;\n\n    for (int j = 1; j < N; ++j) {\n        bool possible = false;\n        for (int i = 0; i < j; ++i) {\n            if (can_win[i] && A[i][j] == 1) {\n                possible = true;\n                break;\n            }\n        }\n        can_win[j] = possible;\n    }\n\n    int count = 0;\n    for (bool b : can_win) {\n        if (b) count++;\n    }\n    cout << count << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] A = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = scanner.nextInt();\n            }\n        }\n        \n        boolean[] dp = new boolean[N];\n        for (int i = 0; i < N; i++) {\n            dp[i] = true;\n        }\n        \n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                if (!dp[i]) continue;\n                for (int j = 0; j < N; j++) {\n                    if (!dp[j]) continue;\n                    if (A[i][j] == 1) {\n                        dp[j] = false;\n                    }\n                }\n            }\n        }\n        \n        int count = 0;\n        for (boolean b : dp) {\n            if (b) count++;\n        }\n        System.out.println(count);\n    }\n}",
    "timestamp": "2025-08-05 22:50:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RockPaperScissorsTournament {\n    public static int findPossibleChampions(int N, int[][] A) {\n        boolean[][] canBeat = new boolean[N][N];\n        \n        // Determine who can beat whom based on the predefined results\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (A[i][j] == 1) {\n                    canBeat[i][j] = true;\n                }\n            }\n        }\n        \n        // Check each person's possibility of becoming champion\n        int possibleChampions = 0;\n        for (int candidate = 0; candidate < N; candidate++) {\n            if (canBeChampion(candidate, N, canBeat)) {\n                possibleChampions++;\n            }\n        }\n        \n        return possibleChampions;\n    }\n    \n    private static boolean canBeChampion(int candidate, int N, boolean[][] canBeat) {\n        // Try all possible tournament sequences\n        return backtrack(candidate, new boolean[N], canBeat);\n    }\n    \n    private static boolean backtrack(int candidate, boolean[] eliminated, boolean[][] canBeat) {\n        // Check if candidate is already eliminated\n        if (eliminated[candidate]) {\n            return false;\n        }\n        \n        // Check if candidate could survive all possible tournament paths\n        for (int i = 0; i < eliminated.length; i++) {\n            if (i == candidate) continue;\n            \n            for (int j = 0; j < eliminated.length; j++) {\n                if (j == candidate || j == i || eliminated[i] || eliminated[j]) continue;\n                \n                // Create a copy of elimination status\n                boolean[] currentEliminated = eliminated.clone();\n                \n                // Simulate tournament path\n                if (canBeat[i][j]) {\n                    currentEliminated[j] = true;\n                } else {\n                    currentEliminated[i] = true;\n                }\n                \n                // Recursively check this path\n                if (!isEliminated(candidate, currentEliminated, canBeat)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private static boolean isEliminated(int candidate, boolean[] eliminated, boolean[][] canBeat) {\n        // Check for paths where candidate gets eliminated\n        for (int i = 0; i < eliminated.length; i++) {\n            if (i == candidate || eliminated[i]) continue;\n            \n            if (canBeat[i][candidate]) {\n                eliminated[candidate] = true;\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read input\n        int N = scanner.nextInt();\n        int[][] A = new int[N][N];\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // Output result\n        System.out.println(findPossibleChampions(N, A));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:51:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> A(N, vector<int>(N));\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> A[i][j];\n        }\n    }\n    \n    vector<bool> possible_champion(N, false);\n    \n    for (int start = 0; start < N; start++) {\n        vector<int> remaining;\n        for (int i = 0; i < N; i++) {\n            if (i != start) remaining.push_back(i);\n        }\n        \n        bool can_win = true;\n        int current = start;\n        \n        while (remaining.size() > 0) {\n            bool found_match = false;\n            for (int i = 0; i < remaining.size(); i++) {\n                if (A[current][remaining[i]] == 1) {\n                    current = remaining[i];\n                    remaining.erase(remaining.begin() + i);\n                    found_match = true;\n                    break;\n                }\n                if (A[remaining[i]][current] == 1) {\n                    remaining.erase(remaining.begin() + i);\n                    found_match = true;\n                    break;\n                }\n            }\n            \n            if (!found_match) {\n                can_win = false;\n                break;\n            }\n        }\n        \n        possible_champion[start] = can_win;\n    }\n    \n    int count = 0;\n    for (bool possible : possible_champion) {\n        if (possible) count++;\n    }\n    \n    cout << count << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:51:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_possible_champions(N, A):\n    possible_champions = [True] * N\n\n    for k in range(N):\n        for i in range(N):\n            if i != k and possible_champions[i]:\n                can_win = False\n                for j in range(N):\n                    if j != i and j != k and (A[i][j] != A[k][j]):\n                        can_win = True\n                        break\n                if not can_win:\n                    possible_champions[i] = False\n    \n    return sum(possible_champions)\n\n# Example usage\nN = 3\nA = [\n    [0, 1, 1],\n    [1, 0, 0],\n    [0, 1, 0]\n]\n\nprint(count_possible_champions(N, A))  # Output will be based on the input matrix",
    "timestamp": "2025-08-13 12:43:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RockPaperScissorsTournament {\n    public static int findPotentialChampions(int[][] A) {\n        int N = A.length;\n        boolean[] canBeChampion = new boolean[N];\n        Arrays.fill(canBeChampion, true);\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i != j && A[i][j] == 0) {\n                    canBeChampion[j] = false;\n                }\n            }\n        }\n\n        int championCount = 0;\n        for (boolean canBe : canBeChampion) {\n            if (canBe) {\n                championCount++;\n            }\n        }\n        return championCount;\n    }\n\n    public static void main(String[] args) {\n        int[][] A = {\n            {1, 1, 0},\n            {0, 1, 1},\n            {1, 0, 1}\n        };\n        System.out.println(findPotentialChampions(A));\n    }\n}",
    "timestamp": "2025-08-13 12:43:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n\nint A[MAX_N][MAX_N];\nbool possibleChampion[MAX_N];\nbool visited[MAX_N][MAX_N];\n\nvoid dfs(int current, int n) {\n    possibleChampion[current] = true;\n    for (int i = 0; i < n; i++) {\n        if (!visited[current][i] && i != current) {\n            visited[current][i] = visited[i][current] = true;\n            if (A[current][i] == 1) {  // current defeats i\n                dfs(i, n);\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        possibleChampion[i] = false;\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &A[i][j]);\n            visited[i][j] = false;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        dfs(i, n);\n    }\n    \n    int championCount = 0;\n    for (int i = 0; i < n; i++) {\n        if (possibleChampion[i]) {\n            championCount++;\n        }\n    }\n    \n    printf(\"%d\\n\", championCount);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:43:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint count_potential_champions(int N, const vector<vector<int>>& A) {\n    vector<vector<int>> adj(N, vector<int>());\n    vector<int> in_degree(N, 0);\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (A[i][j] == 1) {\n                adj[i].push_back(j);\n                in_degree[j]++;\n            }\n        }\n    }\n    \n    queue<int> q;\n    for (int i = 0; i < N; ++i) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n    \n    vector<bool> can_be_champion(N, false);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        can_be_champion[u] = true;\n        for (int v : adj[u]) {\n            if (--in_degree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n    \n    int count = 0;\n    for (int i = 0; i < N; ++i) {\n        if (can_be_champion[i]) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> A(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> A[i][j];\n        }\n    }\n    \n    cout << count_potential_champions(N, A) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:43:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_tournament(N, A):\n    def can_win(person):\n        # Check if this person can potentially win the tournament\n        visited = [False] * N\n        visited[person] = True\n        \n        def dfs(curr):\n            for next_person in range(N):\n                if next_person == curr or visited[next_person]:\n                    continue\n                \n                # Check if current person can defeat next_person\n                if (A[curr][next_person] == 1):\n                    visited[next_person] = True\n                    dfs(next_person)\n        \n        dfs(person)\n        \n        # Check if all other persons can be eliminated\n        return all(visited[j] or A[person][j] == 1 for j in range(N) if j != person)\n    \n    # Count potential champions\n    return sum(1 for i in range(N) if can_win(i))\n\n# Input parsing\nN = int(input())\nA = [list(map(int, input().split())) for _ in range(N)]\n\n# Output result\nprint(solve_tournament(N, A))",
    "timestamp": "2025-08-13 12:43:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    A = []\n    for _ in range(N):\n        row = list(map(int, data[idx:idx+N]))\n        idx += N\n        A.append(row)\n    \n    # We need to find all i such that there's a topological order where i is the last element\n    # The problem reduces to checking if i can reach all other nodes in the implied tournament graph\n    \n    # The graph is a tournament (for any i != j, either i beats j or j beats i)\n    # So, the champion must be a king in the tournament graph\n    # A king is a node that can reach every other node in <= 2 steps\n    \n    # So, we need to find all nodes that are kings\n    \n    kings = []\n    for i in range(N):\n        is_king = True\n        # Check for all j != i, if i can reach j in <= 2 steps\n        for j in range(N):\n            if i == j:\n                continue\n            if A[i][j] == 1:\n                continue  # direct win\n            # Check if there exists k such that i beats k and k beats j\n            found = False\n            for k in range(N):\n                if k == i or k == j:\n                    continue\n                if A[i][k] == 1 and A[k][j] == 1:\n                    found = True\n                    break\n            if not found:\n                is_king = False\n                break\n        if is_king:\n            kings.append(i + 1)  # 1-based\n    \n    print(len(kings))\n\nsolve()",
    "timestamp": "2025-08-13 12:44:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function possibleChampions(N, A) {\n    let canBeChampion = new Array(N).fill(true);\n\n    function eliminate(i, j) {\n        if (A[i][j] === 1) {\n            canBeChampion[j] = false;\n        } else {\n            canBeChampion[i] = false;\n        }\n    }\n\n    // Traverse all pairs\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            if (i !== j) {\n                if (A[i][j] === 1) {\n                    for (let k = 0; k < N; k++) {\n                        if (k !== i && k !== j && A[j][k] === 1) {\n                            eliminate(i, k);\n                        }\n                    }\n                } else if (A[i][j] === 0) {\n                    for (let k = 0; k < N; k++) {\n                        if (k !== i && k !== j && A[i][k] === 0) {\n                            eliminate(j, k);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return canBeChampion.filter(Boolean).length;\n}",
    "timestamp": "2025-08-13 12:44:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findPossibleChampions(N, A) {\n    function canBecomeChampion(person) {\n        // Try all possible tournament paths\n        const used = new Array(N).fill(false);\n        used[person] = true;\n        \n        function dfs(remainingPeople) {\n            if (remainingPeople === 1) return true;\n            \n            for (let i = 0; i < N; i++) {\n                if (used[i]) continue;\n                \n                for (let j = 0; j < N; j++) {\n                    if (used[j]) continue;\n                    if (i === j) continue;\n                    \n                    // Check if current path allows person to win\n                    if (A[person][i] === 1 && A[person][j] === 0) {\n                        used[i] = true;\n                        if (dfs(remainingPeople - 1)) return true;\n                        used[i] = false;\n                    }\n                }\n            }\n            \n            return false;\n        }\n        \n        return dfs(N - 1);\n    }\n    \n    let possibleChampions = 0;\n    for (let i = 0; i < N; i++) {\n        if (canBecomeChampion(i)) {\n            possibleChampions++;\n        }\n    }\n    \n    return possibleChampions;\n}\n\n// Example usage\nconst N = 4;\nconst A = [\n    [0, 1, 1, 0],\n    [0, 0, 1, 1],\n    [0, 0, 0, 1],\n    [1, 0, 0, 0]\n];\nconsole.log(findPossibleChampions(N, A));",
    "timestamp": "2025-08-13 12:44:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, A) {\n    let reachable = new Array(N).fill(false);\n    let queue = [];\n    \n    for (let i = 0; i < N; i++) {\n        let visited = new Array(N).fill(false);\n        queue.push(i);\n        visited[i] = true;\n        \n        while (queue.length > 0) {\n            let current = queue.shift();\n            for (let j = 0; j < N; j++) {\n                if (!visited[j] && ((A[current][j] === 1) || (A[j][current] === 0))) {\n                    visited[j] = true;\n                    queue.push(j);\n                }\n            }\n        }\n        \n        let canReachAll = true;\n        for (let j = 0; j < N; j++) {\n            if (!visited[j]) {\n                canReachAll = false;\n                break;\n            }\n        }\n        if (canReachAll) {\n            reachable[i] = true;\n        }\n    }\n    \n    return reachable.filter(x => x).length;\n}",
    "timestamp": "2025-08-13 12:44:34"
  }
]