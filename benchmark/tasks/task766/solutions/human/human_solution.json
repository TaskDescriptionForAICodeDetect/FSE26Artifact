[
  {
    "language": "Fortran",
    "code": "program random_tournament\n  implicit none\n  integer :: n, a(2000,2000) = 0, i, j, k, d, ans = 0\n  logical :: dpl(2000,2000) = .false., dpr(2000,2000) = .false.\n  character(2000) :: s\n  read(*,*) n\n  do i = 2, n\n    read(*,*) s\n    do j = 1, i-1\n      a(i,j) = ichar(s(j:j))-48\n      a(j,i) = 1-a(i,j)\n    end do\n  end do\n  do i = 1, n\n    dpl(i,i) = .true.\n    dpr(i,i) = .true.\n  end do\n  do d = 1, n-1\n    do i = 1, n-d\n      j = i+d\n      do k = i, j\n        if (k /= i) dpl(i,j) = dpl(i,j) .or. (a(i,k) == 1 .and. dpl(k,j) .and. dpr(k,i+1))\n        if (k /= j) dpr(j,i) = dpr(j,i) .or. (a(k,j) == 0 .and. dpl(k,j-1) .and. dpr(k,i))\n      end do\n    end do\n  end do\n  do i = 1, n\n    if (dpl(i,n) .and. dpr(i,1)) ans = ans+1\n  end do\n  write(*,'(i0)') ans\nend program random_tournament"
  },
  {
    "language": "Fortran",
    "code": "module mod_bitset\n  implicit none\n  integer, private, parameter :: address_bits_per_word = 6\n  integer, private, parameter :: bits_per_word = lshift(1, address_bits_per_word)\n  integer, private, parameter :: bit_index_mask = bits_per_word - 1\n  integer(8), private, parameter :: word_mask = -1\n  type t_bitset\n    integer(8), private, allocatable :: words(:) ! 0-indexed, [start, end)\n    integer, private :: words_in_use = 0\n  contains\n    procedure, private :: flip0\n    procedure, private :: flip1\n    generic :: flip => flip0, flip1\n    procedure, private :: set0\n    procedure, private :: set1\n    procedure, private :: setval0\n    procedure, private :: setval1\n    generic :: set => set0, set1, setval0, setval1\n    procedure, private :: clear0\n    procedure, private :: clear1\n    procedure, private :: clear2\n    generic :: clear => clear0, clear1, clear2\n    procedure, private :: get0\n    procedure, private :: get1\n    generic :: get => get0, get1\n    procedure :: next_set_bit => next_set_bit\n    procedure :: next_clear_bit => next_clear_bit\n    procedure :: previous_set_bit => previous_set_bit\n    procedure :: previous_clear_bit => previous_clear_bit\n    procedure :: length => length\n    procedure :: is_empty => is_empty\n    procedure :: is_not_empty => is_not_empty\n    procedure :: intersects => intersects\n    procedure :: cardinality => cardinality\n    procedure :: and => and0\n    procedure :: or => or0\n    procedure :: xor => xor0\n    procedure :: and_not => and_not0\n    procedure :: size => size0\n  end type\n  interface bitset\n    module procedure :: newb0, newb3\n  end interface bitset\n  interface slshift\n    module procedure :: slshift0, slshift1\n  end interface slshift\n  interface urshift\n    module procedure :: urshift0, urshift1\n  end interface urshift\ncontains\n  integer function slshift0(i, n) result(res)\n    integer, intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 31)\n    res = lshift(i, m)\n  end\n  integer(8) function slshift1(i, n) result(res)\n    integer(8), intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 63)\n    res = lshift(i, m)\n  end\n  integer function urshift0(i, n) result(res)\n    integer, intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 31)\n    if (m == 0) then\n      res = i\n    else\n      res = rshift(ibclr(rshift(i, 1), 31), m - 1)\n    end if\n  end\n  integer(8) function urshift1(i, n) result(res)\n    integer(8), intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 63)\n    if (m == 0) then\n      res = i\n    else\n      res = rshift(ibclr(rshift(i, 1), 63), m - 1)\n    end if\n  end\n  integer function number_of_leading_zeros(i) result(res)\n    integer(8), intent(in) :: i\n    integer :: x\n    if (i == 0) then\n      res = 64\n      return\n    end if\n    res = 1\n    x = int(urshift(i, 32))\n    if (x == 0) then\n      res = res + 32\n      x = int(i)\n    end if\n    if (urshift(x, 16) == 0) then\n      res = res + 16\n      x = lshift(x, 16)\n    end if\n    if (urshift(x, 24) == 0) then\n      res = res + 8\n      x = lshift(x, 8)\n    end if\n    if (urshift(x, 28) == 0) then\n      res = res + 4\n      x = lshift(x, 4)\n    end if\n    if (urshift(x, 30) == 0) then\n      res = res + 2\n      x = lshift(x, 2)\n    end if\n    res = res - urshift(x, 31)\n  end\n  integer function number_of_trailing_zeros(i) result(res)\n    integer(8), intent(in) :: i\n    integer :: x, y\n    if (i == 0) then\n      res = 64\n      return\n    end if\n    res = 63\n    y = int(i)\n    if (y /= 0) then\n      res = res - 32\n      x = y\n    else\n      x = int(urshift(i, 32))\n    end if\n    y = lshift(x, 16)\n    if (y /= 0) then\n      res = res - 16\n      x = y\n    end if\n    if (y /= 0) then\n      res = res - 8\n      x = y\n    end if\n    if (y /= 0) then\n      res = res - 4\n      x = y\n    end if\n    if (y /= 0) then\n      res = res - 2\n      x = y\n    end if\n    res = res - urshift(lshift(x, 1), 31)\n  end\n  integer function words_index(bit_index) result(res)\n    integer, intent(in) :: bit_index\n    res = rshift(bit_index, address_bits_per_word)\n  end\n  subroutine assert(flag, message)\n    logical, intent(in) :: flag\n    character(*), intent(in), optional :: message\n    if (flag) return\n    write(*,*) \"*** Error occurred ***\"\n    if (present(message)) write(*,'(a)') message\n    stop\n  end\n  subroutine check_invariants(this)\n    type(t_bitset), intent(in) :: this\n    integer :: u, n\n    u = this%words_in_use\n    n = size(this%words)\n    if (u /= 0) call assert(this%words(u - 1) /= 0, \"At check_invariants() (1)\")\n    call assert(u >= 0 .and. u <= n, \"At check_invariants() (2)\")\n    if (u /= n) call assert(this%words(u) == 0, \"At check_invariants() (3)\")\n  end\n  subroutine recalculate_words_in_use(this)\n    type(t_bitset), intent(inout) :: this\n    integer :: i\n    do i = this%words_in_use - 1, 0, -1\n      if (this%words(i) /= 0) then\n        this%words_in_use = i + 1\n        return\n      end if\n    end do\n    this%words_in_use = 0\n  end\n  subroutine init_words(this, nbits)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: nbits\n    if (allocated(this%words)) deallocate(this%words)\n    allocate(this%words(0:words_index(nbits - 1)))\n    this%words = 0\n  end\n  type(t_bitset) function newb0() result(res)\n    call init_words(res, bits_per_word)\n  end\n  type(t_bitset) function newb1(nbits) result(res)\n    integer, intent(in) :: nbits\n    call assert(nbits >= 0, \"nbits < 0 at newb1()\")\n    call init_words(res, nbits)\n  end\n  type(t_bitset) function newb2(words) result(res)\n    integer(8), intent(in) :: words(:)\n    allocate(res%words(0:size(words) - 1))\n    res%words = words\n    res%words_in_use = size(words)\n    call check_invariants(res)\n  end\n  type(t_bitset) function newb3(longs) result(res)\n    integer(8), intent(in) :: longs(:)\n    integer :: i\n    do i = size(longs), 1, -1\n      if (longs(i) /= 0) then\n        res = newb2(longs(1:i))\n        return\n      end if\n    end do\n    res = newb0()\n  end\n  subroutine ensure_capacity(this, words_required)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: words_required\n    integer :: request\n    integer(8), allocatable :: copy(:)\n    if (size(this%words) >= words_required) return\n    request = max(2 * size(this%words), words_required)\n    allocate(copy(size(this%words)))\n    copy = this%words\n    deallocate(this%words)\n    allocate(this%words(0:request - 1))\n    this%words = 0\n    this%words(0:size(copy) - 1) = copy\n  end\n  subroutine expand_to(this, word_index)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: word_index\n    integer :: words_required\n    words_required = word_index + 1\n    if (this%words_in_use < words_required) then\n      call ensure_capacity(this, words_required)\n      this%words_in_use = words_required\n    end if\n  end\n  subroutine check_range(from_index, to_index)\n    integer, intent(in) :: from_index, to_index\n    call assert(0 <= from_index .and. from_index <= to_index, \"At check_range()\")\n  end\n  subroutine flip0(this, bit_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at flip0()\")\n    word_index = words_index(bit_index)\n    call expand_to(this, word_index)\n    this%words(word_index) = xor(this%words(word_index), slshift(1_8, bit_index))\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n  subroutine flip1(this, from_index, to_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index\n    integer :: start_word_index, end_word_index, idx\n    integer(8) :: first_word_mask, last_word_mask\n    call check_range(from_index, to_index)\n    if (from_index == to_index) return\n    start_word_index = words_index(from_index)\n    end_word_index = words_index(to_index - 1)\n    call expand_to(this, end_word_index)\n    first_word_mask = slshift(word_mask, from_index)\n    last_word_mask = urshift(word_mask, -to_index)\n    if (start_word_index == end_word_index) then\n      idx = start_word_index\n      this%words(idx) = xor(this%words(idx), and(first_word_mask, last_word_mask))\n    else\n      idx = start_word_index\n      this%words(idx) = xor(this%words(idx), first_word_mask)\n      do idx = start_word_index + 1, end_word_index - 1\n        this%words(idx) = xor(this%words(idx), word_mask)\n      end do\n      idx = end_word_index\n      this%words(idx) = xor(this%words(idx), last_word_mask)\n    end if\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n  subroutine set0(this, bit_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at set0()\")\n    word_index = words_index(bit_index)\n    call expand_to(this, word_index)\n    this%words(word_index) = or(this%words(word_index), slshift(1_8, bit_index))\n    call check_invariants(this)\n  end\n  subroutine clear0(this, bit_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at clear0()\")\n    word_index = words_index(bit_index)\n    if (word_index >= this%words_in_use) return\n    this%words(word_index) = and(this%words(word_index), not(slshift(1_8, bit_index)))\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n  subroutine setval0(this, bit_index, val)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    logical, intent(in) :: val\n    if (val) then\n      call set0(this, bit_index)\n    else\n      call clear0(this, bit_index)\n    end if\n  end\n  subroutine set1(this, from_index, to_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index\n    integer :: start_word_index, end_word_index, idx\n    integer(8) :: first_word_mask, last_word_mask\n    call check_range(from_index, to_index)\n    if (from_index == to_index) return\n    start_word_index = words_index(from_index)\n    end_word_index = words_index(to_index - 1)\n    call expand_to(this, end_word_index)\n    first_word_mask = slshift(word_mask, from_index)\n    last_word_mask = urshift(word_mask, -to_index)\n    if (start_word_index == end_word_index) then\n      idx = start_word_index\n      this%words(idx) = or(this%words(idx), and(first_word_mask, last_word_mask))\n    else\n      idx = start_word_index\n      this%words(idx) = or(this%words(idx), first_word_mask)\n      do idx = start_word_index + 1, end_word_index - 1\n        this%words(idx) = word_mask\n      end do\n      idx = end_word_index\n      this%words(idx) = or(this%words(idx), last_word_mask)\n    end if\n    call check_invariants(this)\n  end\n  subroutine clear1(this, from_index, to_index_)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index_\n    integer :: to_index\n    integer :: start_word_index, end_word_index, idx\n    integer(8) :: first_word_mask, last_word_mask\n    to_index = to_index_\n    call check_range(from_index, to_index)\n    if (from_index == to_index) return\n    start_word_index = words_index(from_index)\n    if (start_word_index >= this%words_in_use) return\n    end_word_index = words_index(to_index - 1)\n    if (end_word_index >= this%words_in_use) then\n      to_index = length(this)\n      end_word_index = this%words_in_use - 1\n    end if\n    first_word_mask = slshift(word_mask, from_index)\n    last_word_mask = urshift(word_mask, -to_index)\n    if (start_word_index == end_word_index) then\n      idx = start_word_index\n      this%words(idx) = and(this%words(idx), not(and(first_word_mask, last_word_mask)))\n    else\n      idx = start_word_index\n      this%words(idx) = and(this%words(idx), not(first_word_mask))\n      do idx = start_word_index + 1, end_word_index - 1\n        this%words(idx) = 0\n      end do\n      idx = end_word_index\n      this%words(idx) = and(this%words(idx), not(last_word_mask))\n    end if\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n  subroutine setval1(this, from_index, to_index, val)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index\n    logical, intent(in) :: val\n    if (val) then\n      call set1(this, from_index, to_index)\n    else\n      call clear1(this, from_index, to_index)\n    end if\n  end\n  subroutine clear2(this)\n    class(t_bitset), intent(out) :: this\n    this%words(0:this%words_in_use - 1) = 0\n    this%words_in_use = 0\n  end\n  logical function get0(this, bit_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at get0()\")\n    call check_invariants(this)\n    word_index = words_index(bit_index)\n    if (word_index >= this%words_in_use) then\n      res = .false.\n      return\n    end if\n    res = and(this%words(word_index), slshift(1_8, bit_index)) /= 0\n  end\n  type(t_bitset) function get1(this, from_index, to_index_) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index, to_index_\n    integer :: to_index, len\n    integer :: target_words, source_index, idx\n    logical :: word_aligned\n    integer(8) :: last_word_mask\n    to_index = to_index_\n    call check_range(from_index, to_index)\n    call check_invariants(this)\n    len = length(this)\n    if (len <= from_index .or. from_index == to_index) then\n      res = newb0()\n      return\n    end if\n    if (to_index > len) to_index = len\n    res = newb1(to_index - from_index)\n    target_words = words_index(to_index - from_index - 1) + 1\n    source_index = words_index(from_index)\n    word_aligned = and(from_index, bit_index_mask) == 0\n    do idx = 0, target_words - 2\n      if (word_aligned) then\n        res%words(idx) = this%words(source_index)\n      else\n        res%words(idx) = or(urshift(this%words(source_index), from_index), slshift(this%words(source_index + 1), -from_index))\n      end if\n      source_index = source_index + 1\n    end do\n    last_word_mask = urshift(word_mask, -to_index)\n    if (and(to_index - 1, bit_index_mask) < and(from_index, bit_index_mask)) then\n      res%words(target_words - 1) = or(urshift(this%words(source_index), from_index), &\n        slshift(and(this%words(source_index + 1), last_word_mask), -from_index))\n    else\n      res%words(target_words - 1) = urshift(and(this%words(source_index), last_word_mask), from_index)\n    end if\n    res%words_in_use = target_words\n    call recalculate_words_in_use(res)\n    call check_invariants(res)\n  end\n  integer function next_set_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    call assert(from_index >= 0, \"from_index < 0 at next_set_bit()\")\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = -1\n      return\n    end if\n    word = and(this%words(u), slshift(word_mask, from_index))\n    do\n      if (word /= 0) then\n        res = (u * bits_per_word) + number_of_trailing_zeros(word)\n        return\n      end if\n      u = u + 1\n      if (u == this%words_in_use) then\n        res = -1\n        return\n      end if\n      word = this%words(u)\n    end do\n  end\n  integer function next_clear_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    call assert(from_index >= 0, \"from_index < 0 at next_clear_bit()\")\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = from_index\n      return\n    end if\n    word = and(not(this%words(u)), slshift(word_mask, from_index))\n    do\n      if (word /= 0) then\n        res = (u * bits_per_word) + number_of_trailing_zeros(word)\n        return\n      end if\n      u = u + 1\n      if (u == this%words_in_use) then\n        res = this%words_in_use * bits_per_word\n        return\n      end if\n      word = not(this%words(u))\n    end do\n  end\n  integer function previous_set_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    if (from_index < 0) then\n      call assert(from_index == -1, \"from_index < -1 at previous_set_bit()\")\n      res = -1\n      return\n    end if\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = length(this) - 1\n      return\n    end if\n    word = and(this%words(u), urshift(word_mask, -(from_index + 1)))\n    do\n      if (word /= 0) then\n        res = (u + 1) * bits_per_word - 1 - number_of_leading_zeros(word)\n        return\n      end if\n      if (u == 0) then\n        res = -1\n        return\n      end if\n      u = u - 1\n      word = this%words(u)\n    end do\n  end\n  integer function previous_clear_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    if (from_index < 0) then\n      call assert(from_index == -1, \"from_index < -1 at previous_clear_bit()\")\n      res = -1\n      return\n    end if\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = from_index\n      return\n    end if\n    word = and(not(this%words(u)), urshift(word_mask, -(from_index + 1)))\n    do\n      if (word /= 0) then\n        res = (u + 1) * bits_per_word - 1 - number_of_leading_zeros(word)\n        return\n      end if\n      if (u == 0) then\n        res = -1\n        return\n      end if\n      u = u - 1\n      word = not(this%words(u))\n    end do\n  end\n  integer function length(this) result(res)\n    class(t_bitset), intent(in) :: this\n    integer :: u, n\n    u = this%words_in_use\n    if (u == 0) then\n      res = 0\n    else\n      n = number_of_leading_zeros(this%words(u - 1))\n      res = bits_per_word * (u - 1) + (bits_per_word - n)\n    end if\n  end\n  logical function is_empty(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = this%words_in_use == 0\n  end\n  logical function is_not_empty(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = this%words_in_use > 0\n  end\n  logical function intersects(this, other) result(res)\n    class(t_bitset), intent(in) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: m, i\n    m = min(this%words_in_use, other%words_in_use)\n    do i = m, 0, -1\n      if (and(this%words(i), other%words(i)) /= 0) then\n        res = .true.\n      end if\n    end do\n    res = .false.\n  end\n  integer function cardinality(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = sum(popcnt(this%words(0:this%words_in_use - 1)))\n  end\n  subroutine and0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: i\n    do while (this%words_in_use > other%words_in_use)\n      this%words_in_use = this%words_in_use - 1\n      this%words(this%words_in_use) = 0\n    end do\n    do i = 0, this%words_in_use - 1\n      this%words(i) = and(this%words(i), other%words(i))\n    end do\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n  subroutine or0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: u, i\n    u = min(this%words_in_use, other%words_in_use)\n    do i = 0, u - 1\n      this%words(i) = or(this%words(i), other%words(i))\n    end do\n    if (u < other%words_in_use) then\n      call ensure_capacity(this, other%words_in_use)\n      this%words_in_use = other%words_in_use\n      this%words(u:this%words_in_use - 1) = other%words(u:other%words_in_use - 1)\n    end if\n    call check_invariants(this)\n  end\n  subroutine xor0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: u, i\n    u = min(this%words_in_use, other%words_in_use)\n    do i = 0, u - 1\n      this%words(i) = xor(this%words(i), other%words(i))\n    end do\n    if (u < other%words_in_use) then\n      call ensure_capacity(this, other%words_in_use)\n      this%words_in_use = other%words_in_use\n      this%words(u:this%words_in_use - 1) = other%words(u:other%words_in_use - 1)\n    end if\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n  subroutine and_not0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: u, i\n    u = min(this%words_in_use, other%words_in_use)\n    do i = 0, u - 1\n      this%words(i) = and(this%words(i), not(other%words(i)))\n    end do\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n  integer function size0(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = size(this%words) * bits_per_word\n  end\nend module mod_bitset\nprogram random_tournament\n  use mod_bitset\n  implicit none\n  type(t_bitset) :: a(0:2000), dpl(0:2000), dpr(0:2000), tmp\n  integer :: n, i, j, l, r\n  character(2000) :: s\n  read(*,*) n\n  do i = 0, n - 1\n    a(i) = bitset()\n    dpl(i) = bitset()\n    dpr(i) = bitset()\n    call dpl(i)%set(i)\n    call dpr(i)%set(i)\n    if (i == 0) cycle\n    read(*,'(a)') s\n    do j = 0, i - 1\n      call a(i)%set(j, s(j + 1:j + 1) == '1')\n      call a(j)%set(i, s(j + 1:j + 1) == '0')\n    end do\n  end do\n  do i = 1, n - 1\n    do l = 0, n - i - 1\n      r = l + i\n      tmp = a(r)%get(0, n)\n      call tmp%and(dpl(l))\n      call tmp%and(dpr(r - 1))\n      tmp = tmp%get(l, r)\n      call dpl(l)%set(r, tmp%is_not_empty())\n      tmp = a(l)%get(0, n)\n      call tmp%and(dpl(l + 1))\n      call tmp%and(dpr(r))\n      tmp = tmp%get(l + 1, r + 1)\n      call dpr(r)%set(l, tmp%is_not_empty())\n    end do\n  end do\n  j = 0\n  do i = 0, n - 1\n    if (dpl(0)%get(i) .and. dpr(n - 1)%get(i)) j = j + 1\n  end do\n  write(*,'(i0)') j\nend program random_tournament"
  },
  {
    "language": "Fortran",
    "code": "module mod_bitset\n  implicit none\n  integer, private, parameter :: address_bits_per_word = 6\n  integer, private, parameter :: bits_per_word = lshift(1, address_bits_per_word)\n  integer, private, parameter :: bit_index_mask = bits_per_word - 1\n  integer(8), private, parameter :: word_mask = -1\n\n  type t_bitset\n    integer(8), private, allocatable :: words(:) ! 0-indexed, [start, end)\n    integer, private :: words_in_use = 0\n  contains\n    procedure, private :: flip0\n    procedure, private :: flip1\n    generic :: flip => flip0, flip1\n    procedure, private :: set0\n    procedure, private :: set1\n    procedure, private :: setval0\n    procedure, private :: setval1\n    generic :: set => set0, set1, setval0, setval1\n    procedure, private :: clear0\n    procedure, private :: clear1\n    procedure, private :: clear2\n    generic :: clear => clear0, clear1, clear2\n    procedure, private :: get0\n    procedure, private :: get1\n    generic :: get => get0, get1\n    procedure :: next_set_bit => next_set_bit\n    procedure :: next_clear_bit => next_clear_bit\n    procedure :: previous_set_bit => previous_set_bit\n    procedure :: previous_clear_bit => previous_clear_bit\n    procedure :: length => length\n    procedure :: is_empty => is_empty\n    procedure :: is_not_empty => is_not_empty\n    procedure :: intersects => intersects\n    procedure :: cardinality => cardinality\n    procedure :: and => and0\n    procedure :: or => or0\n    procedure :: xor => xor0\n    procedure :: and_not => and_not0\n    procedure :: size => size0\n  end type\n\n  interface bitset\n    module procedure :: newb0, newb3\n  end interface bitset\n\n  interface slshift\n    module procedure :: slshift0, slshift1\n  end interface slshift\n\n  interface urshift\n    module procedure :: urshift0, urshift1\n  end interface urshift\n\ncontains\n\n  integer function slshift0(i, n) result(res)\n    integer, intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 31)\n    res = lshift(i, m)\n  end\n\n  integer(8) function slshift1(i, n) result(res)\n    integer(8), intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 63)\n    res = lshift(i, m)\n  end\n\n  integer function urshift0(i, n) result(res)\n    integer, intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 31)\n    if (m == 0) then\n      res = i\n    else\n      res = rshift(ibclr(rshift(i, 1), 31), m - 1)\n    end if\n  end\n\n  integer(8) function urshift1(i, n) result(res)\n    integer(8), intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 63)\n    if (m == 0) then\n      res = i\n    else\n      res = rshift(ibclr(rshift(i, 1), 63), m - 1)\n    end if\n  end\n\n  integer function number_of_leading_zeros(i) result(res)\n    integer(8), intent(in) :: i\n    integer :: x\n    if (i == 0) then\n      res = 64\n      return\n    end if\n    res = 1\n    x = int(urshift(i, 32))\n    if (x == 0) then\n      res = res + 32\n      x = int(i)\n    end if\n    if (urshift(x, 16) == 0) then\n      res = res + 16\n      x = lshift(x, 16)\n    end if\n    if (urshift(x, 24) == 0) then\n      res = res + 8\n      x = lshift(x, 8)\n    end if\n    if (urshift(x, 28) == 0) then\n      res = res + 4\n      x = lshift(x, 4)\n    end if\n    if (urshift(x, 30) == 0) then\n      res = res + 2\n      x = lshift(x, 2)\n    end if\n    res = res - urshift(x, 31)\n  end\n\n  integer function number_of_trailing_zeros(i) result(res)\n    integer(8), intent(in) :: i\n    integer :: x, y\n    if (i == 0) then\n      res = 64\n      return\n    end if\n    res = 63\n    y = int(i)\n    if (y /= 0) then\n      res = res - 32\n      x = y\n    else\n      x = int(urshift(i, 32))\n    end if\n    y = lshift(x, 16)\n    if (y /= 0) then\n      res = res - 16\n      x = y\n    end if\n    if (y /= 0) then\n      res = res - 8\n      x = y\n    end if\n    if (y /= 0) then\n      res = res - 4\n      x = y\n    end if\n    if (y /= 0) then\n      res = res - 2\n      x = y\n    end if\n    res = res - urshift(lshift(x, 1), 31)\n  end\n\n  integer function words_index(bit_index) result(res)\n    integer, intent(in) :: bit_index\n    res = rshift(bit_index, address_bits_per_word)\n  end\n\n  subroutine assert(flag, message)\n    logical, intent(in) :: flag\n    character(*), intent(in), optional :: message\n    if (flag) return\n    write(*,*) \"*** Error occurred ***\"\n    if (present(message)) write(*,'(a)') message\n    stop\n  end\n\n  subroutine check_invariants(this)\n    type(t_bitset), intent(in) :: this\n    integer :: u, n\n    u = this%words_in_use\n    n = size(this%words)\n    if (u /= 0) call assert(this%words(u - 1) /= 0, \"At check_invariants() (1)\")\n    call assert(u >= 0 .and. u <= n, \"At check_invariants() (2)\")\n    if (u /= n) call assert(this%words(u) == 0, \"At check_invariants() (3)\")\n  end\n\n  subroutine recalculate_words_in_use(this)\n    type(t_bitset), intent(inout) :: this\n    integer :: i\n    do i = this%words_in_use - 1, 0, -1\n      if (this%words(i) /= 0) then\n        this%words_in_use = i + 1\n        return\n      end if\n    end do\n    this%words_in_use = 0\n  end\n\n  subroutine init_words(this, nbits)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: nbits\n    if (allocated(this%words)) deallocate(this%words)\n    allocate(this%words(0:words_index(nbits - 1)))\n    this%words = 0\n  end\n\n  type(t_bitset) function newb0() result(res)\n    call init_words(res, bits_per_word)\n  end\n\n  type(t_bitset) function newb1(nbits) result(res)\n    integer, intent(in) :: nbits\n    call assert(nbits >= 0, \"nbits < 0 at newb1()\")\n    call init_words(res, nbits)\n  end\n\n  type(t_bitset) function newb2(words) result(res)\n    integer(8), intent(in) :: words(:)\n    allocate(res%words(0:size(words) - 1))\n    res%words = words\n    res%words_in_use = size(words)\n    call check_invariants(res)\n  end\n\n  type(t_bitset) function newb3(longs) result(res)\n    integer(8), intent(in) :: longs(:)\n    integer :: i\n    do i = size(longs), 1, -1\n      if (longs(i) /= 0) then\n        res = newb2(longs(1:i))\n        return\n      end if\n    end do\n    res = newb0()\n  end\n\n  subroutine ensure_capacity(this, words_required)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: words_required\n    integer :: request\n    integer(8), allocatable :: copy(:)\n    request = max(2 * size(this%words), words_required)\n    allocate(copy(size(this%words)))\n    copy = this%words\n    deallocate(this%words)\n    allocate(this%words(0:request - 1))\n    this%words = 0\n    this%words(0:size(copy) - 1) = copy\n  end\n\n  subroutine expand_to(this, word_index)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: word_index\n    integer :: words_required\n    words_required = word_index + 1\n    if (this%words_in_use < words_required) then\n      call ensure_capacity(this, words_required)\n      this%words_in_use = words_required\n    end if\n  end\n\n  subroutine check_range(from_index, to_index)\n    integer, intent(in) :: from_index, to_index\n    call assert(0 <= from_index .and. from_index <= to_index, \"At check_range()\")\n  end\n\n  subroutine flip0(this, bit_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at flip0()\")\n    word_index = words_index(bit_index)\n    call expand_to(this, word_index)\n    this%words(word_index) = xor(this%words(word_index), lshift(1_8, bit_index))\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine flip1(this, from_index, to_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index\n    integer :: start_word_index, end_word_index, idx\n    integer(8) :: first_word_mask, last_word_mask\n\n    call check_range(from_index, to_index)\n    if (from_index == to_index) return\n\n    start_word_index = words_index(from_index)\n    end_word_index = words_index(to_index - 1)\n    call expand_to(this, end_word_index)\n\n    first_word_mask = lshift(word_mask, from_index)\n    last_word_mask = urshift(word_mask, -to_index)\n    if (start_word_index == end_word_index) then\n      idx = start_word_index\n      this%words(idx) = xor(this%words(idx), and(first_word_mask, last_word_mask))\n    else\n      idx = start_word_index\n      this%words(idx) = xor(this%words(idx), first_word_mask)\n\n      do idx = start_word_index + 1, end_word_index - 1\n        this%words(idx) = xor(this%words(idx), word_mask)\n      end do\n\n      idx = end_word_index\n      this%words(idx) = xor(this%words(idx), last_word_mask)\n    end if\n\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine set0(this, bit_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at set0()\")\n    word_index = words_index(bit_index)\n    call expand_to(this, word_index)\n    this%words(word_index) = or(this%words(word_index), lshift(1_8, bit_index))\n    call check_invariants(this)\n  end\n\n  subroutine clear0(this, bit_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at clear0()\")\n    word_index = words_index(bit_index)\n    if (word_index >= this%words_in_use) return\n    this%words(word_index) = and(this%words(word_index), not(lshift(1_8, bit_index)))\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine setval0(this, bit_index, val)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    logical, intent(in) :: val\n    if (val) then\n      call set0(this, bit_index)\n    else\n      call clear0(this, bit_index)\n    end if\n  end\n\n  subroutine set1(this, from_index, to_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index\n    integer :: start_word_index, end_word_index, idx\n    integer(8) :: first_word_mask, last_word_mask\n\n    call check_range(from_index, to_index)\n    if (from_index == to_index) return\n\n    start_word_index = words_index(from_index)\n    end_word_index = words_index(to_index - 1)\n    call expand_to(this, end_word_index)\n\n    first_word_mask = lshift(word_mask, from_index)\n    last_word_mask = urshift(word_mask, -to_index)\n    if (start_word_index == end_word_index) then\n      idx = start_word_index\n      this%words(idx) = or(this%words(idx), and(first_word_mask, last_word_mask))\n    else\n      idx = start_word_index\n      this%words(idx) = or(this%words(idx), first_word_mask)\n\n      do idx = start_word_index + 1, end_word_index - 1\n        this%words(idx) = word_mask\n      end do\n\n      idx = end_word_index\n      this%words(idx) = or(this%words(idx), last_word_mask)\n    end if\n\n    call check_invariants(this)\n  end\n\n  subroutine clear1(this, from_index, to_index_)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index_\n    integer :: to_index\n    integer :: start_word_index, end_word_index, idx\n    integer(8) :: first_word_mask, last_word_mask\n    to_index = to_index_\n\n    call check_range(from_index, to_index)\n    if (from_index == to_index) return\n\n    start_word_index = words_index(from_index)\n    if (start_word_index >= this%words_in_use) return\n\n    end_word_index = words_index(to_index - 1)\n    if (end_word_index >= this%words_in_use) then\n      to_index = length(this)\n      end_word_index = this%words_in_use - 1\n    end if\n\n    first_word_mask = lshift(word_mask, from_index)\n    last_word_mask = urshift(word_mask, -to_index)\n    if (start_word_index == end_word_index) then\n      idx = start_word_index\n      this%words(idx) = and(this%words(idx), not(and(first_word_mask, last_word_mask)))\n    else\n      idx = start_word_index\n      this%words(idx) = and(this%words(idx), not(first_word_mask))\n\n      do idx = start_word_index + 1, end_word_index - 1\n        this%words(idx) = 0\n      end do\n\n      idx = end_word_index\n      this%words(idx) = and(this%words(idx), not(last_word_mask))\n    end if\n\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine setval1(this, from_index, to_index, val)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index\n    logical, intent(in) :: val\n    if (val) then\n      call set1(this, from_index, to_index)\n    else\n      call clear1(this, from_index, to_index)\n    end if\n  end\n\n  subroutine clear2(this)\n    class(t_bitset), intent(out) :: this\n    this%words(0:this%words_in_use - 1) = 0\n    this%words_in_use = 0\n  end\n\n  logical function get0(this, bit_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at get0()\")\n    call check_invariants(this)\n    word_index = words_index(bit_index)\n    if (word_index >= this%words_in_use) then\n      res = .false.\n      return\n    end if\n    res = and(this%words(word_index), lshift(1_8, bit_index)) /= 0\n  end\n\n  type(t_bitset) function get1(this, from_index, to_index_) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index, to_index_\n    integer :: to_index, len\n    integer :: target_words, source_index, idx\n    logical :: word_aligned\n    integer(8) :: last_word_mask\n    to_index = to_index_\n\n    call check_range(from_index, to_index)\n    call check_invariants(this)\n    len = length(this)\n    if (len <= from_index .or. from_index == to_index) then\n      res = newb0()\n      return\n    end if\n\n    if (to_index > len) to_index = len\n    res = newb1(to_index - from_index)\n    target_words = words_index(to_index - from_index - 1) + 1\n    source_index = words_index(from_index)\n    word_aligned = and(from_index, bit_index_mask) == 0\n\n    do idx = 0, target_words - 2\n      if (word_aligned) then\n        res%words(idx) = this%words(source_index)\n      else\n        res%words(idx) = or(urshift(this%words(source_index), from_index), slshift(this%words(source_index + 1), -from_index))\n      end if\n      source_index = source_index + 1\n    end do\n\n    last_word_mask = urshift(word_mask, -to_index)\n    if (and(to_index - 1, bit_index_mask) < and(from_index, bit_index_mask)) then\n      res%words(target_words - 1) = or(urshift(this%words(source_index), from_index), &\n        slshift(and(this%words(source_index + 1), last_word_mask), -from_index))\n    else\n      res%words(target_words - 1) = urshift(and(this%words(source_index), last_word_mask), from_index)\n    end if\n\n    res%words_in_use = target_words\n    call recalculate_words_in_use(res)\n    call check_invariants(res)\n  end\n\n  integer function next_set_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    call assert(from_index >= 0, \"from_index < 0 at next_set_bit()\")\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = -1\n      return\n    end if\n    word = and(this%words(u), lshift(word_mask, from_index))\n    do\n      if (word /= 0) then\n        res = (u * bits_per_word) + number_of_trailing_zeros(word)\n        return\n      end if\n      u = u + 1\n      if (u == this%words_in_use) then\n        res = -1\n        return\n      end if\n      word = this%words(u)\n    end do\n  end\n\n  integer function next_clear_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    call assert(from_index >= 0, \"from_index < 0 at next_clear_bit()\")\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = from_index\n      return\n    end if\n    word = and(not(this%words(u)), lshift(word_mask, from_index))\n    do\n      if (word /= 0) then\n        res = (u * bits_per_word) + number_of_trailing_zeros(word)\n        return\n      end if\n      u = u + 1\n      if (u == this%words_in_use) then\n        res = this%words_in_use * bits_per_word\n        return\n      end if\n      word = not(this%words(u))\n    end do\n  end\n\n  integer function previous_set_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    if (from_index < 0) then\n      call assert(from_index == -1, \"from_index < -1 at previous_set_bit()\")\n      res = -1\n      return\n    end if\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = length(this) - 1\n      return\n    end if\n    word = and(this%words(u), urshift(word_mask, -(from_index + 1)))\n    do\n      if (word /= 0) then\n        res = (u + 1) * bits_per_word - 1 - number_of_leading_zeros(word)\n        return\n      end if\n      if (u == 0) then\n        res = -1\n        return\n      end if\n      u = u - 1\n      word = this%words(u)\n    end do\n  end\n\n  integer function previous_clear_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    if (from_index < 0) then\n      call assert(from_index == -1, \"from_index < -1 at previous_clear_bit()\")\n      res = -1\n      return\n    end if\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = from_index\n      return\n    end if\n    word = and(not(this%words(u)), urshift(word_mask, -(from_index + 1)))\n    do\n      if (word /= 0) then\n        res = (u + 1) * bits_per_word - 1 - number_of_leading_zeros(word)\n        return\n      end if\n      if (u == 0) then\n        res = -1\n        return\n      end if\n      u = u - 1\n      word = not(this%words(u))\n    end do\n  end\n\n  integer function length(this) result(res)\n    class(t_bitset), intent(in) :: this\n    integer :: u, n\n    u = this%words_in_use\n    if (u == 0) then\n      res = 0\n    else\n      n = number_of_leading_zeros(this%words(u - 1))\n      res = bits_per_word * (u - 1) + (bits_per_word - n)\n    end if\n  end\n\n  logical function is_empty(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = this%words_in_use == 0\n  end\n\n  logical function is_not_empty(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = this%words_in_use > 0\n  end\n\n  logical function intersects(this, other) result(res)\n    class(t_bitset), intent(in) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: m, i\n    m = min(this%words_in_use, other%words_in_use)\n    do i = m, 0, -1\n      if (and(this%words(i), other%words(i)) /= 0) then\n        res = .true.\n      end if\n    end do\n    res = .false.\n  end\n\n  integer function cardinality(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = sum(popcnt(this%words(0:this%words_in_use - 1)))\n  end\n\n  subroutine and0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: i\n    do while (this%words_in_use > other%words_in_use)\n      this%words_in_use = this%words_in_use - 1\n      this%words(this%words_in_use) = 0\n    end do\n    do i = 0, this%words_in_use - 1\n      this%words(i) = and(this%words(i), other%words(i))\n    end do\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine or0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: u, i\n    u = min(this%words_in_use, other%words_in_use)\n    do i = 0, u - 1\n      this%words(i) = or(this%words(i), other%words(i))\n    end do\n    if (u < other%words_in_use) then\n      call ensure_capacity(this, other%words_in_use)\n      this%words_in_use = other%words_in_use\n      this%words(u:this%words_in_use - 1) = other%words(u:other%words_in_use - 1)\n    end if\n    call check_invariants(this)\n  end\n\n  subroutine xor0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: u, i\n    u = min(this%words_in_use, other%words_in_use)\n    do i = 0, u - 1\n      this%words(i) = xor(this%words(i), other%words(i))\n    end do\n    if (u < other%words_in_use) then\n      call ensure_capacity(this, other%words_in_use)\n      this%words_in_use = other%words_in_use\n      this%words(u:this%words_in_use - 1) = other%words(u:other%words_in_use - 1)\n    end if\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine and_not0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: u, i\n    u = min(this%words_in_use, other%words_in_use)\n    do i = 0, u - 1\n      this%words(i) = and(this%words(i), not(other%words(i)))\n    end do\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  integer function size0(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = size(this%words) * bits_per_word\n  end\n\nend module mod_bitset\nprogram random_tournament\n  use mod_bitset\n  implicit none\n  type(t_bitset) :: a(0:2000), dpl(0:2000), dpr(0:2000), tmp\n  integer :: n, i, j, l, r\n  character(2000) :: s\n  read(*,*) n\n  do i = 0, n - 1\n    a(i) = bitset()\n    dpl(i) = bitset()\n    dpr(i) = bitset()\n    call dpl(i)%set(i)\n    call dpr(i)%set(i)\n    if (i == 0) cycle\n    read(*,*) s\n    do j = 0, i - 1\n      call a(i)%set(j, s(j + 1:j + 1) == '1')\n      call a(j)%set(i, s(j + 1:j + 1) == '0')\n    end do\n  end do\n  do i = 1, n - 1\n    do l = 0, n - i - 1\n      r = l + i\n      tmp = a(r)%get(0, n)\n      call tmp%and(dpl(l))\n      call tmp%and(dpr(r - 1))\n      tmp = tmp%get(l, r)\n      call dpl(l)%set(r, tmp%is_not_empty())\n      tmp = a(l)%get(0, n)\n      call tmp%and(dpl(l + 1))\n      call tmp%and(dpr(r))\n      tmp = tmp%get(l + 1, r + 1)\n      call dpr(r)%set(l, tmp%is_not_empty())\n    end do\n  end do\n  j = 0\n  do i = 0, n - 1\n    if (dpl(0)%get(i) .and. dpr(n - 1)%get(i)) j = j + 1\n  end do\n  write(*,'(i0)') j\nend program random_tournament"
  },
  {
    "language": "Fortran",
    "code": "module mod_bitset\n  implicit none\n\n  integer, parameter :: ADDRESS_BITS_PER_WORD = 6\n  integer, parameter :: BITS_PER_WORD = lshift(1,ADDRESS_BITS_PER_WORD)\n  integer, parameter :: BIT_INDEX_MASK = BITS_PER_WORD-1\n  integer(8), parameter :: WORD_MASK = -1_8\n\n  type t_bitset\n    private\n    integer(8), pointer :: words(:) => null()\n    integer :: wiu = 0\n    logical :: sticky = .false.\n  contains\n    procedure :: to_long_array => to_long_array\n    procedure :: flip => flip\n    procedure :: set => set\n    procedure :: clear => clear\n    procedure :: get => get1\n    procedure :: subset => get2\n    procedure :: next_set_bit => next_set_bit\n    procedure :: next_clear_bit => next_clear_bit\n    procedure :: prev_set_bit => prev_set_bit\n    procedure :: prev_clear_bit => prev_clear_bit\n    procedure :: length => length\n    procedure :: is_empty => is_empty\n    procedure :: intersects => intersects\n    procedure :: cardinality => cardinality\n    procedure :: and => bitset_and\n    procedure :: or => bitset_or\n    procedure :: xor => bitset_xor\n    procedure :: and_not => bitset_and_not\n    procedure :: hashcode => bitset_hashcode\n    procedure :: size => size_of\n  end type\n\n  interface bitset\n    module procedure :: new_bitset0, new_bitset1, value_of1\n  end interface bitset\n\ncontains\n\n  integer function word_index(idx)\n    integer, intent(in) :: idx\n    word_index = rshift(idx,ADDRESS_BITS_PER_WORD)\n  end\n\n  subroutine check_invariants(this)\n    type(t_bitset), intent(in) :: this\n    if (this%wiu == 0 .and. .not.associated(this%words)) return\n    if (this%wiu > 1 .and. this%words(this%wiu-1) == 0_8) then\n      write(*,'(a)') \"Error: Internal error (1) at check_invariants\"\n    end if\n    if (this%wiu < 0 .or. this%wiu > size(this%words,1)) then\n      write(*,'(a)') \"Error: Internal error (2) at check_invariants\"\n    end if\n    if (this%wiu < size(this%words,1) .and. this%words(this%wiu) /= 0_8) then\n      write(*,'(a)') \"Error: Internal error (3) at check_invariants\"\n    end if\n  end\n\n  subroutine recalculate_wiu(this)\n    type(t_bitset), intent(inout) :: this\n    integer :: i\n    i = this%wiu-1\n    do while (i >= 0)\n      if (this%words(i) /= 0_8) exit\n      i = i-1\n    end do\n    this%wiu = i+1\n  end\n\n  function new_bitset0() result(ret)\n    type(t_bitset) :: ret\n    call init_words(ret,BITS_PER_WORD)\n    ret%sticky = .false.\n  end\n\n  function new_bitset1(n) result(ret)\n    integer, intent(in) :: n\n    type(t_bitset) :: ret\n    if (n < 0) then\n      write(*,'(a)') \"Error: Negative array size (n < 0) at init_bitset\"\n      stop\n    end if\n    call init_words(ret,n)\n    ret%sticky = .true.\n  end\n\n  subroutine init_words(this,n)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: n\n    if (associated(this%words)) deallocate(this%words)\n    allocate(this%words(0:word_index(n-1)))\n    this%words = 0_8\n  end\n\n  function new_bitset2(words) result(ret)\n    integer(8), intent(in) :: words(:)\n    integer :: n\n    type(t_bitset) :: ret\n    n = size(words,1)\n    allocate(ret%words(0:n-1))\n    ret%words(0:n-1) = words(1:n)\n    ret%wiu = n\n    call check_invariants(ret)\n  end\n\n  function value_of1(arr) result(ret)\n    integer(8), intent(in) :: arr(:)\n    integer :: n\n    type(t_bitset) :: ret\n    n = size(arr)\n    do while (n > 0 .and. arr(n) == 0_8)\n      n = n-1\n    end do\n    if (n == 0) return\n    ret = new_bitset2(arr(1:n))\n  end\n\n  function to_long_array(this) result(ret)\n    class(t_bitset), intent(inout) :: this\n    integer(8) :: ret(0:this%wiu-1)\n    ret(0:this%wiu-1) = this%words(0:this%wiu-1)\n  end\n\n  subroutine ensure_capacity(this,require)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: require\n    integer :: n, request\n    integer, allocatable :: tmp(:)\n    if (.not.associated(this%words)) then\n      allocate(this%words(0:require-1))\n      this%sticky = .false.\n      return\n    end if\n    n = size(this%words,1)\n    if (n >= require) return\n    request = max(2*n,require)\n    allocate(tmp(n))\n    tmp(1:n) = this%words(0:n-1)\n    deallocate(this%words)\n    allocate(this%words(0:request-1))\n    this%words = 0_8\n    this%words(0:n-1) = tmp(1:n)\n    this%sticky = .false.\n  end\n\n  subroutine expand_to(this,widx)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: widx\n    integer :: require\n    require = widx+1\n    if (this%wiu < require) then\n      call ensure_capacity(this,require)\n      this%wiu = require\n    end if\n  end\n\n  subroutine check_range(fidx,tidx)\n    integer, intent(in) :: fidx, tidx\n    if (fidx < 0) then\n      write(*,'(a)') \"Error: Index out of bounds (fidx < 0) at check_range\"\n    end if\n    if (tidx < 0) then\n      write(*,'(a)') \"Error: Index out of bounds (fidx < 0) at check_range\"\n    end if\n    if (fidx > tidx) then\n      write(*,'(a)') \"Error: Index out of bounds (fidx > tidx) at check_range\"\n    end if\n  end\n\n  subroutine flip(this,fidx,tidx)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: fidx\n    integer, optional :: tidx\n    if (present(tidx)) then\n      call flip2(this,fidx,tidx)\n    else\n      call flip1(this,fidx)\n    end if\n  end\n\n  subroutine flip1(this,idx)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: idx\n    integer :: widx\n    if (idx < 0) then\n      write(*,'(a)') \"Error: Index out of bounds (idx < 0) at flip1\"\n    end if\n    widx = word_index(idx)\n    call expand_to(this,widx)\n    this%words(widx) = xor(this%words(widx),lshift(1_8,idx))\n    call recalculate_wiu(this)\n    call check_invariants(this)\n  end\n\n  subroutine flip2(this,fidx,tidx)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: fidx, tidx\n    integer :: sidx, eidx, i\n    integer(8) :: fmask, lmask\n    call check_range(fidx,tidx)\n    if (fidx == tidx) return\n    sidx = word_index(fidx)\n    eidx = word_index(tidx-1)\n    call expand_to(this,eidx)\n    fmask = lshift(WORD_MASK,fidx)\n    lmask = not(lshift(WORD_MASK,-tidx))\n    if (sidx == eidx) then\n      this%words(sidx) = xor(this%words(sidx),and(fmask,lmask))\n    else\n      this%words(sidx) = xor(this%words(sidx),fmask)\n      do i = sidx+1, eidx-1\n        this%words(i) = xor(this%words(i),WORD_MASK)\n      end do\n      this%words(eidx) = xor(this%words(eidx),lmask)\n    end if\n    call recalculate_wiu(this)\n    call check_invariants(this)\n  end\n\n  subroutine set(this,fidx,tidx,val)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: fidx\n    integer, optional :: tidx\n    logical, optional :: val\n    if (present(val)) then\n      if (present(tidx)) then\n        call set2a(this,fidx,tidx,val)\n      else\n        call set1a(this,fidx,val)\n      end if\n    else\n      if (present(tidx)) then\n        call set2(this,fidx,tidx)\n      else\n        call set1(this,fidx)\n      end if\n    end if\n  end\n\n  subroutine set1(this,idx)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: idx\n    integer :: widx\n    if (idx < 0) then\n      write(*,'(a)') \"Error: Index out of bounds (idx < 0) at set1\"\n    end if\n    widx = word_index(idx)\n    call expand_to(this,widx)\n    this%words(widx) = ibset(this%words(widx),idx)\n    call check_invariants(this)\n  end\n\n  subroutine set1a(this,idx,val)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: idx\n    logical, intent(in) :: val\n    if (val) then\n      call set1(this,idx)\n    else\n      call clear1(this,idx)\n    end if\n  end\n\n  subroutine set2(this,fidx,tidx)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: fidx, tidx\n    integer :: sidx, eidx, i\n    integer(8) :: fmask, lmask\n    call check_range(fidx,tidx)\n    if (fidx == tidx) return\n    sidx = word_index(fidx)\n    eidx = word_index(tidx-1)\n    call expand_to(this,eidx)\n    fmask = lshift(WORD_MASK,fidx)\n    lmask = not(lshift(WORD_MASK,-tidx))\n    if (sidx == eidx) then\n      this%words(sidx) = or(this%words(sidx),and(fmask,lmask))\n    else\n      this%words(sidx) = or(this%words(sidx),fmask)\n      do i = sidx+1, eidx-1\n        this%words(i) = WORD_MASK\n      end do\n      this%words(eidx) = or(this%words(eidx),lmask)\n    end if\n    call check_invariants(this)\n  end\n\n  subroutine set2a(this,fidx,tidx,val)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: fidx, tidx\n    logical, intent(in) :: val\n    if (val) then\n      call set2(this,fidx,tidx)\n    else\n      call clear2(this,fidx,tidx)\n    end if\n  end\n\n  subroutine clear(this,fidx,tidx)\n    class(t_bitset), intent(inout) :: this\n    integer, optional :: fidx, tidx\n    if (present(fidx)) then\n      if (present(tidx)) then\n        call clear2(this,fidx,tidx)\n      else\n        call clear1(this,fidx)\n      end if\n    else\n      call clear3(this)\n    end if\n  end\n\n  subroutine clear1(this,idx)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: idx\n    integer :: widx\n    if (idx < 0) then\n      write(*,'(a)') \"Error: Index out of bounds (idx < 0) at clear1\"\n    end if\n    widx = word_index(idx)\n    if (widx >= this%wiu) return\n    this%words(widx) = ibclr(this%words(widx),idx)\n    call recalculate_wiu(this)\n    call check_invariants(this)\n  end\n\n  subroutine clear2(this,fidx,toidx)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: fidx, toidx\n    integer :: sidx, eidx, i, tidx\n    integer(8) :: fmask, lmask\n    tidx = toidx\n    call check_range(fidx,tidx)\n    if (fidx == tidx) return\n    sidx = word_index(fidx)\n    if (sidx >= this%wiu) return\n    eidx = word_index(tidx-1)\n    if (eidx >= this%wiu) then\n      tidx = length(this)\n      eidx = this%wiu-1\n    end if\n    fmask = lshift(WORD_MASK,fidx)\n    lmask = not(lshift(WORD_MASK,-tidx))\n    if (sidx == eidx) then\n      this%words(sidx) = and(this%words(sidx),not(and(fmask,lmask)))\n    else\n      this%words(sidx) = and(this%words(sidx),not(fmask))\n      do i = sidx+1, eidx-1\n        this%words(i) = 0_8\n      end do\n      this%words(eidx) = and(this%words(eidx),not(lmask))\n    end if\n    call recalculate_wiu(this)\n    call check_invariants(this)\n  end\n\n  subroutine clear3(this)\n    type(t_bitset), intent(inout) :: this\n    this%words(0:this%wiu-1) = 0_8\n  end\n\n  function get1(this,idx) result(ret)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: idx\n    integer :: widx\n    logical :: ret\n    if (idx < 0) then\n      write(*,'(a)') \"Error: Index out of bounds (idx < 0) at get1\"\n    end if\n    call check_invariants(this)\n    widx = word_index(idx)\n    ret = widx < this%wiu .and. btest(this%words(widx),idx)\n  end\n\n  function get2(this,fidx,toidx) result(ret)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: fidx, toidx\n    integer :: tar, src, i, tidx, l\n    integer(8) :: lmask, tmp\n    type(t_bitset) :: ret\n    logical :: align\n    tidx = toidx\n    call check_range(fidx,tidx)\n    call check_invariants(this)\n    l = length(this)\n    if (l <= fidx .or. fidx == tidx) return\n    if (tidx > l) tidx = l\n    ret = new_bitset1(tidx-fidx)\n    tar = word_index(tidx-fidx-1)+1\n    src = word_index(fidx)\n    if (and(fidx,BIT_INDEX_MASK) == 0) then\n      do i = 0, tar-2\n        ret%words(i) = this%words(src)\n        src = src+1\n      end do\n    else\n      do i = 0, tar-2\n        tmp = rshift(this%words(src),fidx)\n        if (this%words(src) < 0_8) tmp = not(lshift(WORD_MASK,-fidx))\n        ret%words(i) = or(tmp,lshift(this%words(src+1),fidx))\n        src = src+1\n      end do\n    end if\n    lmask = WORD_MASK\n    if (tidx /= 0) lmask = not(lshift(WORD_MASK,-tidx))\n    if (and(tidx-1,BIT_INDEX_MASK) < and(fidx,BIT_INDEX_MASK)) then\n      tmp = rshift(this%words(src),fidx)\n      if (this%words(src) < 0_8) tmp = not(lshift(WORD_MASK,-fidx))\n      ret%words(tar-1) = or(tmp,lshift(and(this%words(src+1),lmask),-fidx))\n    else\n      tmp = and(this%words(src),lmask)\n      if (tmp < 0_8) then\n        tmp = not(lshift(WORD_MASK,-fidx))\n      else\n        tmp = rshift(tmp,fidx)\n      end if\n      ret%words(tar-1) = and(tmp,lmask)\n    end if\n    ret%wiu = tar\n    call recalculate_wiu(ret)\n    call check_invariants(ret)\n  end\n\n  function num_of_trailing_zeros(n) result(ret)\n    integer(8), intent(in) :: n\n    integer :: ret, x, y\n    ret = 64\n    if (n == 0_8) return\n    ret = 63\n    y = int(n,4)\n    if (y /= 0) then\n      ret = ret-32\n      x = y\n    else\n      x = int(rshift(n,32),4)\n    end if\n    y = lshift(x,16)\n    if (y /= 0) then\n      ret = ret-16\n      x = y\n    end if\n    y = lshift(x,8)\n    if (y /= 0) then\n      ret = ret-8\n      x = y\n    end if\n    y = lshift(x,4)\n    if (y /= 0) then\n      ret = ret-4\n      x = y\n    end if\n    y = lshift(x,2)\n    if (y /= 0) then\n      ret = ret-2\n      x = y\n    end if\n    ret = ret-rshift(lshift(x,1),31)\n  end\n\n  function num_of_leading_zeros(n) result(ret)\n    integer(8), intent(in) :: n\n    integer :: ret, x\n    ret = 64\n    if (n == 0_8) return\n    ret = 1\n    x = int(rshift(n,32),4)\n    if (x == 0) then\n      ret = ret+32\n      x = int(n,4)\n    end if\n    if (rshift(x,16) == 0) then\n      ret = ret+16\n      x = lshift(x,16)\n    end if\n    if (rshift(x,24) == 0) then\n      ret = ret+8\n      x = lshift(x,8)\n    end if\n    if (rshift(x,28) == 0) then\n      ret = ret+4\n      x = lshift(x,4)\n    end if\n    if (rshift(x,30) == 0) then\n      ret = ret+2\n      x = lshift(x,2)\n    end if\n    ret = ret-rshift(x,31)\n  end\n\n  function next_set_bit(this,idx) result(ret)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: idx\n    integer :: ret, u\n    integer(8) :: word\n    ret = -1\n    if (idx < 0) then\n      write(*,'(a)') \"Error: Index out of bounds (idx < 0) at next_set_bit\"\n    end if\n    call check_invariants(this)\n    u = word_index(idx)\n    if (u >= this%wiu) return\n    word = and(this%words(u),lshift(WORD_MASK,idx))\n    do\n      if (word /= 0_8) then\n        ret = u*BITS_PER_WORD+num_of_trailing_zeros(word)\n        return\n      end if\n      u = u+1\n      if (u == this%wiu) return\n      word = this%words(u)\n    end do\n  end\n\n  function next_clear_bit(this,idx) result(ret)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: idx\n    integer :: ret, u\n    integer(8) :: word\n    ret = idx\n    if (idx < 0) then\n      write(*,'(a)') \"Error: Index out of bounds (idx < 0) at next_set_bit\"\n    end if\n    call check_invariants(this)\n    u = word_index(idx)\n    if (u >= this%wiu) return\n    word = and(not(this%words(u)),lshift(WORD_MASK,idx))\n    do\n      if (word /= 0_8) then\n        ret = u*BITS_PER_WORD+num_of_trailing_zeros(word)\n        return\n      end if\n      u = u+1\n      if (u == this%wiu) then\n        ret = this%wiu*BITS_PER_WORD\n        return\n      end if\n      word = this%words(u)\n    end do\n  end\n\n  function prev_set_bit(this,idx) result(ret)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: idx\n    integer :: ret, u\n    integer(8) :: word\n    ret = -1\n    if (idx < 0) then\n      if (idx /= -1) write(*,'(a)') \"Error: Index out of bounds (idx < 0) at next_set_bit\"\n      return\n    end if\n    call check_invariants(this)\n    u = word_index(idx)\n    if (u >= this%wiu) then\n      ret = length(this)-1\n      return\n    end if\n    word = and(this%words(u),not(lshift(WORD_MASK,-(idx+1))))\n    do\n      if (word /= 0_8) then\n        ret = (u+1)*BITS_PER_WORD-1-num_of_leading_zeros(word)\n        return\n      end if\n      if (u == 0) return\n      u = u-1\n      word = this%words(u)\n    end do\n  end\n\n  function prev_clear_bit(this,idx) result(ret)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: idx\n    integer :: ret, u\n    integer(8) :: word\n    ret = -1\n    if (idx < 0) then\n      if (idx /= -1) write(*,'(a)') \"Error: Index out of bounds (idx < 0) at next_set_bit\"\n      return\n    end if\n    call check_invariants(this)\n    u = word_index(idx)\n    if (u >= this%wiu) then\n      ret = idx\n      return\n    end if\n    word = and(not(this%words(u)),not(lshift(WORD_MASK,-(idx+1))))\n    do\n      if (word /= 0_8) then\n        ret = (u+1)*BITS_PER_WORD-1-num_of_leading_zeros(word)\n        return\n      end if\n      if (u == 0) return\n      u = u-1\n      word = not(this%words(u))\n    end do\n  end\n\n  integer function length(this)\n    class(t_bitset), intent(in) :: this\n    length = 0\n    if (this%wiu == 0) return\n    length = BITS_PER_WORD*(this%wiu-1)+BITS_PER_WORD-num_of_leading_zeros(this%words(this%wiu-1))\n  end\n\n  logical function is_empty(this)\n    class(t_bitset), intent(in) :: this\n    is_empty = this%wiu == 0\n  end\n\n  function intersects(this,other) result(ret)\n    class(t_bitset), intent(in) :: this\n    type(t_bitset), intent(in) :: other\n    logical :: ret\n    integer :: i\n    ret = .false.\n    do i = min(this%wiu,other%wiu)-1, 0, -1\n      if (and(this%words(i),other%words(i)) /= 0_8) then\n        ret = .true.\n      end if\n    end do\n  end\n\n  integer function cardinality(this)\n    class(t_bitset), intent(in) :: this\n    integer :: i\n    cardinality = 0\n    do i = 0, this%wiu-1\n      cardinality = cardinality+popcnt(this%words(i))\n    end do\n  end\n\n  function bitset_eq(this,other) result(ret)\n    class(t_bitset), intent(in) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: i\n    logical :: ret\n    ret = .false.\n    if (this%wiu /= other%wiu) return\n    do i = 0, this%wiu-1\n      if (this%words(i) /= other%words(i)) return\n    end do\n    ret = .true.\n  end\n\n  subroutine bitset_and(this,other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: i\n    if (bitset_eq(this,other)) return\n    do while (this%wiu > other%wiu)\n      this%wiu = this%wiu-1\n      this%words(this%wiu) = 0_8\n    end do\n    do i = 0, this%wiu-1\n      this%words(i) = and(this%words(i),other%words(i))\n    end do\n    call recalculate_wiu(this)\n    call check_invariants(this)\n  end\n\n  subroutine bitset_or(this,other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: i, same\n    if (bitset_eq(this,other)) return\n    same = min(this%wiu,other%wiu)\n    if (this%wiu < other%wiu) then\n      call ensure_capacity(this,other%wiu)\n      this%wiu = other%wiu\n    end if\n    do i = 0, same-1\n      this%words(i) = or(this%words(i),other%words(i))\n    end do\n    if (same < other%wiu) then\n      this%words(same:other%wiu-1) = other%words(same:other%wiu-1)\n    end if\n    call check_invariants(this)\n  end\n\n  subroutine bitset_xor(this,other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: i, same\n    same = min(this%wiu,other%wiu)\n    if (this%wiu < other%wiu) then\n      call ensure_capacity(this,other%wiu)\n      this%wiu = other%wiu\n    end if\n    do i = 0, same-1\n      this%words(i) = xor(this%words(i),other%words(i))\n    end do\n    if (same < other%wiu) then\n      this%words(same:other%wiu-1) = other%words(same:other%wiu-1)\n    end if\n    call recalculate_wiu(this)\n    call check_invariants(this)\n  end\n\n  subroutine bitset_and_not(this,other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: i\n    do i = min(this%wiu,other%wiu)-1, 0, -1\n      this%words(i) = and(this%words(i),not(other%words(i)))\n    end do\n    call recalculate_wiu(this)\n    call check_invariants(this)\n  end\n\n  function bitset_hashcode(this) result(ret)\n    class(t_bitset), intent(in) :: this\n    integer(8) :: h\n    integer :: ret, i\n    h = 1234_8\n    do i = this%wiu-1, 0, -1\n      h = xor(h,this%words(i)*int(i+1,8))\n    end do\n    ret = int(xor(lshift(h,32),h),4)\n  end\n\n  integer function size_of(this)\n    class(t_bitset), intent(in) :: this\n    size_of = size(this%words,1)*BITS_PER_WORD\n  end\nend module mod_bitset\n\nprogram random_tournament\n  use mod_bitset\n  implicit none\n  type(t_bitset) :: a(0:2000), dpl(0:2000), dpr(0:2000), tmp\n  integer :: n, i, j, l, r\n  character(2000) :: s\n  read(*,*) n\n  do i = 0, n-1\n    call dpl(i)%set(i)\n    call dpr(i)%set(i)\n    if (i == 0) cycle\n    read(*,*) s\n    do j = 0, i-1\n      call a(i)%set(j,val=s(j+1:j+1) == \"1\")\n      call a(j)%set(i,val=s(j+1:j+1) == \"0\")\n    end do\n  end do\n  do i = 1, n-1\n    do l = 0, n-1-i\n      r = l+i\n      tmp = a(r)%subset(0,n)\n      call tmp%and(dpl(l))\n      call tmp%and(dpr(r-1))\n      tmp = tmp%subset(l,r)\n      call dpl(l)%set(r,val=.not.tmp%is_empty())\n      tmp = a(l)%subset(0,n)\n      call tmp%and(dpl(l+1))\n      call tmp%and(dpr(r))\n      tmp = tmp%subset(l+1,r+1)\n      call dpr(r)%set(l,val=.not.tmp%is_empty())\n    end do\n  end do\n  j = 0\n  do i = 0, n-1\n    if (dpl(0)%get(i) .and. dpr(n-1)%get(i)) j = j+1\n  end do\n  write(*,'(i0)') j\nend program random_tournament"
  },
  {
    "language": "Fortran",
    "code": "module mod_bitset\n  implicit none\n  integer, private, parameter :: address_bits_per_word = 6\n  integer, private, parameter :: bits_per_word = lshift(1, address_bits_per_word)\n  integer, private, parameter :: bit_index_mask = bits_per_word - 1\n  integer(8), private, parameter :: word_mask = -1\n\n  type t_bitset\n    integer(8), private, allocatable :: words(:) ! 0-indexed, [start, end)\n    integer, private :: words_in_use = 0\n  contains\n    procedure, private :: flip0\n    procedure, private :: flip1\n    generic :: flip => flip0, flip1\n    procedure, private :: set0\n    procedure, private :: set1\n    procedure, private :: setval0\n    procedure, private :: setval1\n    generic :: set => set0, set1, setval0, setval1\n    procedure, private :: clear0\n    procedure, private :: clear1\n    procedure, private :: clear2\n    generic :: clear => clear0, clear1, clear2\n    procedure, private :: get0\n    procedure, private :: get1\n    generic :: get => get0, get1\n    procedure :: next_set_bit => next_set_bit\n    procedure :: next_clear_bit => next_clear_bit\n    procedure :: previous_set_bit => previous_set_bit\n    procedure :: previous_clear_bit => previous_clear_bit\n    procedure :: length => length\n    procedure :: is_empty => is_empty\n    procedure :: is_not_empty => is_not_empty\n    procedure :: intersects => intersects\n    procedure :: cardinality => cardinality\n    procedure :: and => and0\n    procedure :: or => or0\n    procedure :: xor => xor0\n    procedure :: and_not => and_not0\n    procedure :: size => size0\n  end type\n\n  interface bitset\n    module procedure :: newb0, newb3\n  end interface bitset\n\n  interface slshift\n    module procedure :: slshift0, slshift1\n  end interface slshift\n\n  interface urshift\n    module procedure :: urshift0, urshift1\n  end interface urshift\n\ncontains\n\n  integer function slshift0(i, n) result(res)\n    integer, intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 31)\n    res = lshift(i, m)\n  end\n\n  integer(8) function slshift1(i, n) result(res)\n    integer(8), intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 63)\n    res = lshift(i, m)\n  end\n\n  integer function urshift0(i, n) result(res)\n    integer, intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 31)\n    if (m == 0) then\n      res = i\n    else\n      res = rshift(ibclr(rshift(i, 1), 31), m - 1)\n    end if\n  end\n\n  integer(8) function urshift1(i, n) result(res)\n    integer(8), intent(in) :: i\n    integer, intent(in) :: n\n    integer :: m\n    m = and(n, 63)\n    if (m == 0) then\n      res = i\n    else\n      res = rshift(ibclr(rshift(i, 1), 63), m - 1)\n    end if\n  end\n\n  integer function number_of_leading_zeros(i) result(res)\n    integer(8), intent(in) :: i\n    integer :: x\n    if (i == 0) then\n      res = 64\n      return\n    end if\n    res = 1\n    x = int(urshift(i, 32))\n    if (x == 0) then\n      res = res + 32\n      x = int(i)\n    end if\n    if (urshift(x, 16) == 0) then\n      res = res + 16\n      x = lshift(x, 16)\n    end if\n    if (urshift(x, 24) == 0) then\n      res = res + 8\n      x = lshift(x, 8)\n    end if\n    if (urshift(x, 28) == 0) then\n      res = res + 4\n      x = lshift(x, 4)\n    end if\n    if (urshift(x, 30) == 0) then\n      res = res + 2\n      x = lshift(x, 2)\n    end if\n    res = res - urshift(x, 31)\n  end\n\n  integer function number_of_trailing_zeros(i) result(res)\n    integer(8), intent(in) :: i\n    integer :: x, y\n    if (i == 0) then\n      res = 64\n      return\n    end if\n    res = 63\n    y = int(i)\n    if (y /= 0) then\n      res = res - 32\n      x = y\n    else\n      x = int(urshift(i, 32))\n    end if\n    y = lshift(x, 16)\n    if (y /= 0) then\n      res = res - 16\n      x = y\n    end if\n    if (y /= 0) then\n      res = res - 8\n      x = y\n    end if\n    if (y /= 0) then\n      res = res - 4\n      x = y\n    end if\n    if (y /= 0) then\n      res = res - 2\n      x = y\n    end if\n    res = res - urshift(lshift(x, 1), 31)\n  end\n\n  integer function words_index(bit_index) result(res)\n    integer, intent(in) :: bit_index\n    res = rshift(bit_index, address_bits_per_word)\n  end\n\n  subroutine assert(flag, message)\n    logical, intent(in) :: flag\n    character(*), intent(in), optional :: message\n    if (flag) return\n    write(*,*) \"*** Error occurred ***\"\n    if (present(message)) write(*,'(a)') message\n    stop\n  end\n\n  subroutine check_invariants(this)\n    type(t_bitset), intent(in) :: this\n    integer :: u, n\n    u = this%words_in_use\n    n = size(this%words)\n    if (u /= 0) call assert(this%words(u - 1) /= 0, \"At check_invariants() (1)\")\n    call assert(u >= 0 .and. u <= n, \"At check_invariants() (2)\")\n    if (u /= n) call assert(this%words(u) == 0, \"At check_invariants() (3)\")\n  end\n\n  subroutine recalculate_words_in_use(this)\n    type(t_bitset), intent(inout) :: this\n    integer :: i\n    do i = this%words_in_use - 1, 0, -1\n      if (this%words(i) /= 0) then\n        this%words_in_use = i + 1\n        return\n      end if\n    end do\n    this%words_in_use = 0\n  end\n\n  subroutine init_words(this, nbits)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: nbits\n    if (allocated(this%words)) deallocate(this%words)\n    allocate(this%words(0:words_index(nbits - 1)))\n    this%words = 0\n  end\n\n  type(t_bitset) function newb0() result(res)\n    call init_words(res, bits_per_word)\n  end\n\n  type(t_bitset) function newb1(nbits) result(res)\n    integer, intent(in) :: nbits\n    call assert(nbits >= 0, \"nbits < 0 at newb1()\")\n    call init_words(res, nbits)\n  end\n\n  type(t_bitset) function newb2(words) result(res)\n    integer(8), intent(in) :: words(:)\n    allocate(res%words(0:size(words) - 1))\n    res%words = words\n    res%words_in_use = size(words)\n    call check_invariants(res)\n  end\n\n  type(t_bitset) function newb3(longs) result(res)\n    integer(8), intent(in) :: longs(:)\n    integer :: i\n    do i = size(longs), 1, -1\n      if (longs(i) /= 0) then\n        res = newb2(longs(1:i))\n        return\n      end if\n    end do\n    res = newb0()\n  end\n\n  subroutine ensure_capacity(this, words_required)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: words_required\n    integer :: request\n    integer(8), allocatable :: copy(:)\n    if (size(this%words) >= words_required) return\n    request = max(2 * size(this%words), words_required)\n    allocate(copy(size(this%words)))\n    copy = this%words\n    deallocate(this%words)\n    allocate(this%words(0:request - 1))\n    this%words = 0\n    this%words(0:size(copy) - 1) = copy\n  end\n\n  subroutine expand_to(this, word_index)\n    type(t_bitset), intent(inout) :: this\n    integer, intent(in) :: word_index\n    integer :: words_required\n    words_required = word_index + 1\n    if (this%words_in_use < words_required) then\n      call ensure_capacity(this, words_required)\n      this%words_in_use = words_required\n    end if\n  end\n\n  subroutine check_range(from_index, to_index)\n    integer, intent(in) :: from_index, to_index\n    call assert(0 <= from_index .and. from_index <= to_index, \"At check_range()\")\n  end\n\n  subroutine flip0(this, bit_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at flip0()\")\n    word_index = words_index(bit_index)\n    call expand_to(this, word_index)\n    this%words(word_index) = xor(this%words(word_index), slshift(1_8, bit_index))\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine flip1(this, from_index, to_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index\n    integer :: start_word_index, end_word_index, idx\n    integer(8) :: first_word_mask, last_word_mask\n\n    call check_range(from_index, to_index)\n    if (from_index == to_index) return\n\n    start_word_index = words_index(from_index)\n    end_word_index = words_index(to_index - 1)\n    call expand_to(this, end_word_index)\n\n    first_word_mask = slshift(word_mask, from_index)\n    last_word_mask = urshift(word_mask, -to_index)\n    if (start_word_index == end_word_index) then\n      idx = start_word_index\n      this%words(idx) = xor(this%words(idx), and(first_word_mask, last_word_mask))\n    else\n      idx = start_word_index\n      this%words(idx) = xor(this%words(idx), first_word_mask)\n\n      do idx = start_word_index + 1, end_word_index - 1\n        this%words(idx) = xor(this%words(idx), word_mask)\n      end do\n\n      idx = end_word_index\n      this%words(idx) = xor(this%words(idx), last_word_mask)\n    end if\n\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine set0(this, bit_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at set0()\")\n    word_index = words_index(bit_index)\n    call expand_to(this, word_index)\n    this%words(word_index) = or(this%words(word_index), slshift(1_8, bit_index))\n    call check_invariants(this)\n  end\n\n  subroutine clear0(this, bit_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at clear0()\")\n    word_index = words_index(bit_index)\n    if (word_index >= this%words_in_use) return\n    this%words(word_index) = and(this%words(word_index), not(slshift(1_8, bit_index)))\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine setval0(this, bit_index, val)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: bit_index\n    logical, intent(in) :: val\n    if (val) then\n      call set0(this, bit_index)\n    else\n      call clear0(this, bit_index)\n    end if\n  end\n\n  subroutine set1(this, from_index, to_index)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index\n    integer :: start_word_index, end_word_index, idx\n    integer(8) :: first_word_mask, last_word_mask\n\n    call check_range(from_index, to_index)\n    if (from_index == to_index) return\n\n    start_word_index = words_index(from_index)\n    end_word_index = words_index(to_index - 1)\n    call expand_to(this, end_word_index)\n\n    first_word_mask = slshift(word_mask, from_index)\n    last_word_mask = urshift(word_mask, -to_index)\n    if (start_word_index == end_word_index) then\n      idx = start_word_index\n      this%words(idx) = or(this%words(idx), and(first_word_mask, last_word_mask))\n    else\n      idx = start_word_index\n      this%words(idx) = or(this%words(idx), first_word_mask)\n\n      do idx = start_word_index + 1, end_word_index - 1\n        this%words(idx) = word_mask\n      end do\n\n      idx = end_word_index\n      this%words(idx) = or(this%words(idx), last_word_mask)\n    end if\n\n    call check_invariants(this)\n  end\n\n  subroutine clear1(this, from_index, to_index_)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index_\n    integer :: to_index\n    integer :: start_word_index, end_word_index, idx\n    integer(8) :: first_word_mask, last_word_mask\n    to_index = to_index_\n\n    call check_range(from_index, to_index)\n    if (from_index == to_index) return\n\n    start_word_index = words_index(from_index)\n    if (start_word_index >= this%words_in_use) return\n\n    end_word_index = words_index(to_index - 1)\n    if (end_word_index >= this%words_in_use) then\n      to_index = length(this)\n      end_word_index = this%words_in_use - 1\n    end if\n\n    first_word_mask = slshift(word_mask, from_index)\n    last_word_mask = urshift(word_mask, -to_index)\n    if (start_word_index == end_word_index) then\n      idx = start_word_index\n      this%words(idx) = and(this%words(idx), not(and(first_word_mask, last_word_mask)))\n    else\n      idx = start_word_index\n      this%words(idx) = and(this%words(idx), not(first_word_mask))\n\n      do idx = start_word_index + 1, end_word_index - 1\n        this%words(idx) = 0\n      end do\n\n      idx = end_word_index\n      this%words(idx) = and(this%words(idx), not(last_word_mask))\n    end if\n\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine setval1(this, from_index, to_index, val)\n    class(t_bitset), intent(inout) :: this\n    integer, intent(in) :: from_index, to_index\n    logical, intent(in) :: val\n    if (val) then\n      call set1(this, from_index, to_index)\n    else\n      call clear1(this, from_index, to_index)\n    end if\n  end\n\n  subroutine clear2(this)\n    class(t_bitset), intent(out) :: this\n    this%words(0:this%words_in_use - 1) = 0\n    this%words_in_use = 0\n  end\n\n  logical function get0(this, bit_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: bit_index\n    integer :: word_index\n    call assert(bit_index >= 0, \"bit_index < 0 at get0()\")\n    call check_invariants(this)\n    word_index = words_index(bit_index)\n    if (word_index >= this%words_in_use) then\n      res = .false.\n      return\n    end if\n    res = and(this%words(word_index), slshift(1_8, bit_index)) /= 0\n  end\n\n  type(t_bitset) function get1(this, from_index, to_index_) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index, to_index_\n    integer :: to_index, len\n    integer :: target_words, source_index, idx\n    logical :: word_aligned\n    integer(8) :: last_word_mask\n    to_index = to_index_\n\n    call check_range(from_index, to_index)\n    call check_invariants(this)\n    len = length(this)\n    if (len <= from_index .or. from_index == to_index) then\n      res = newb0()\n      return\n    end if\n\n    if (to_index > len) to_index = len\n    res = newb1(to_index - from_index)\n    target_words = words_index(to_index - from_index - 1) + 1\n    source_index = words_index(from_index)\n    word_aligned = and(from_index, bit_index_mask) == 0\n\n    do idx = 0, target_words - 2\n      if (word_aligned) then\n        res%words(idx) = this%words(source_index)\n      else\n        res%words(idx) = or(urshift(this%words(source_index), from_index), slshift(this%words(source_index + 1), -from_index))\n      end if\n      source_index = source_index + 1\n    end do\n\n    last_word_mask = urshift(word_mask, -to_index)\n    if (and(to_index - 1, bit_index_mask) < and(from_index, bit_index_mask)) then\n      res%words(target_words - 1) = or(urshift(this%words(source_index), from_index), &\n        slshift(and(this%words(source_index + 1), last_word_mask), -from_index))\n    else\n      res%words(target_words - 1) = urshift(and(this%words(source_index), last_word_mask), from_index)\n    end if\n\n    res%words_in_use = target_words\n    call recalculate_words_in_use(res)\n    call check_invariants(res)\n  end\n\n  integer function next_set_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    call assert(from_index >= 0, \"from_index < 0 at next_set_bit()\")\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = -1\n      return\n    end if\n    word = and(this%words(u), slshift(word_mask, from_index))\n    do\n      if (word /= 0) then\n        res = (u * bits_per_word) + number_of_trailing_zeros(word)\n        return\n      end if\n      u = u + 1\n      if (u == this%words_in_use) then\n        res = -1\n        return\n      end if\n      word = this%words(u)\n    end do\n  end\n\n  integer function next_clear_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    call assert(from_index >= 0, \"from_index < 0 at next_clear_bit()\")\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = from_index\n      return\n    end if\n    word = and(not(this%words(u)), slshift(word_mask, from_index))\n    do\n      if (word /= 0) then\n        res = (u * bits_per_word) + number_of_trailing_zeros(word)\n        return\n      end if\n      u = u + 1\n      if (u == this%words_in_use) then\n        res = this%words_in_use * bits_per_word\n        return\n      end if\n      word = not(this%words(u))\n    end do\n  end\n\n  integer function previous_set_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    if (from_index < 0) then\n      call assert(from_index == -1, \"from_index < -1 at previous_set_bit()\")\n      res = -1\n      return\n    end if\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = length(this) - 1\n      return\n    end if\n    word = and(this%words(u), urshift(word_mask, -(from_index + 1)))\n    do\n      if (word /= 0) then\n        res = (u + 1) * bits_per_word - 1 - number_of_leading_zeros(word)\n        return\n      end if\n      if (u == 0) then\n        res = -1\n        return\n      end if\n      u = u - 1\n      word = this%words(u)\n    end do\n  end\n\n  integer function previous_clear_bit(this, from_index) result(res)\n    class(t_bitset), intent(in) :: this\n    integer, intent(in) :: from_index\n    integer :: u\n    integer(8) :: word\n    if (from_index < 0) then\n      call assert(from_index == -1, \"from_index < -1 at previous_clear_bit()\")\n      res = -1\n      return\n    end if\n    call check_invariants(this)\n    u = words_index(from_index)\n    if (u >= this%words_in_use) then\n      res = from_index\n      return\n    end if\n    word = and(not(this%words(u)), urshift(word_mask, -(from_index + 1)))\n    do\n      if (word /= 0) then\n        res = (u + 1) * bits_per_word - 1 - number_of_leading_zeros(word)\n        return\n      end if\n      if (u == 0) then\n        res = -1\n        return\n      end if\n      u = u - 1\n      word = not(this%words(u))\n    end do\n  end\n\n  integer function length(this) result(res)\n    class(t_bitset), intent(in) :: this\n    integer :: u, n\n    u = this%words_in_use\n    if (u == 0) then\n      res = 0\n    else\n      n = number_of_leading_zeros(this%words(u - 1))\n      res = bits_per_word * (u - 1) + (bits_per_word - n)\n    end if\n  end\n\n  logical function is_empty(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = this%words_in_use == 0\n  end\n\n  logical function is_not_empty(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = this%words_in_use > 0\n  end\n\n  logical function intersects(this, other) result(res)\n    class(t_bitset), intent(in) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: m, i\n    m = min(this%words_in_use, other%words_in_use)\n    do i = m, 0, -1\n      if (and(this%words(i), other%words(i)) /= 0) then\n        res = .true.\n      end if\n    end do\n    res = .false.\n  end\n\n  integer function cardinality(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = sum(popcnt(this%words(0:this%words_in_use - 1)))\n  end\n\n  subroutine and0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: i\n    do while (this%words_in_use > other%words_in_use)\n      this%words_in_use = this%words_in_use - 1\n      this%words(this%words_in_use) = 0\n    end do\n    do i = 0, this%words_in_use - 1\n      this%words(i) = and(this%words(i), other%words(i))\n    end do\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine or0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: u, i\n    u = min(this%words_in_use, other%words_in_use)\n    do i = 0, u - 1\n      this%words(i) = or(this%words(i), other%words(i))\n    end do\n    if (u < other%words_in_use) then\n      call ensure_capacity(this, other%words_in_use)\n      this%words_in_use = other%words_in_use\n      this%words(u:this%words_in_use - 1) = other%words(u:other%words_in_use - 1)\n    end if\n    call check_invariants(this)\n  end\n\n  subroutine xor0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: u, i\n    u = min(this%words_in_use, other%words_in_use)\n    do i = 0, u - 1\n      this%words(i) = xor(this%words(i), other%words(i))\n    end do\n    if (u < other%words_in_use) then\n      call ensure_capacity(this, other%words_in_use)\n      this%words_in_use = other%words_in_use\n      this%words(u:this%words_in_use - 1) = other%words(u:other%words_in_use - 1)\n    end if\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  subroutine and_not0(this, other)\n    class(t_bitset), intent(inout) :: this\n    type(t_bitset), intent(in) :: other\n    integer :: u, i\n    u = min(this%words_in_use, other%words_in_use)\n    do i = 0, u - 1\n      this%words(i) = and(this%words(i), not(other%words(i)))\n    end do\n    call recalculate_words_in_use(this)\n    call check_invariants(this)\n  end\n\n  integer function size0(this) result(res)\n    class(t_bitset), intent(in) :: this\n    res = size(this%words) * bits_per_word\n  end\n\nend module mod_bitset\nprogram random_tournament\n  use mod_bitset\n  implicit none\n  type(t_bitset) :: a(0:2000), dpl(0:2000), dpr(0:2000), tmp\n  integer :: n, i, j, l, r\n  character(2000) :: s\n  read(*,*) n\n  do i = 0, n - 1\n    a(i) = bitset()\n    dpl(i) = bitset()\n    dpr(i) = bitset()\n    call dpl(i)%set(i)\n    call dpr(i)%set(i)\n  end do\n  do i = 1, n - 1\n    read(*,'(a)') s\n    do j = 0, i - 1\n      call a(i)%set(j, s(j + 1:j + 1) == '1')\n      call a(j)%set(i, s(j + 1:j + 1) == '0')\n    end do\n  end do\n  do i = 1, n - 1\n    do l = 0, n - i - 1\n      r = l + i\n      tmp = a(r)%get(0, n)\n      call tmp%and(dpl(l))\n      call tmp%and(dpr(r - 1))\n      tmp = tmp%get(l, r)\n      call dpl(l)%set(r, tmp%is_not_empty())\n      tmp = a(l)%get(0, n)\n      call tmp%and(dpl(l + 1))\n      call tmp%and(dpr(r))\n      tmp = tmp%get(l + 1, r + 1)\n      call dpr(r)%set(l, tmp%is_not_empty())\n    end do\n  end do\n  j = 0\n  do i = 0, n - 1\n    if (dpl(0)%get(i) .and. dpr(n - 1)%get(i)) j = j + 1\n  end do\n  write(*,'(i0)') j\nend program random_tournament"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        string t;\n        cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            A[i][j] = t[j]!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<bool>> L(N, vector<bool>(N));\n    vector<vector<bool>> R(N, vector<bool>(N));\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<N; j++)\n                    b |= a[j] && l[j] && r[j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=0; j<i; j++)\n                    b |= a[j] && l[j] && r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            scanf(\" %c\",&c);\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            bool j1=false;\n            for(int k=j+1;k<=R && !j1;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            bool j1=false;\n            for(int k=R;k<j && !j1;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar ch[2010][2010];\n\nint n;\n\nbitset <2010> B[2010], C[2010];\n\nbitset <2010> Ans[2010];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 2; i <= n; i++) scanf(\"%s\", ch[i] + 1);\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; j < i; j++)\n\t\t\t(B[i][j] = ch[i][j] - '0'), B[j][i] = !B[i][j];\n\tfor(int i = 1; i <= n; i++) Ans[i][i] = 1;\n\tfor(int i = 1; i < n; i++) {\n\t\tC[i][i + 1] = B[i][i + 1];\n\t\tC[i + 1][i] = B[i + 1][i];\n\t\tif(B[i][i + 1]) Ans[i + 1][i] = 1; else Ans[i][i + 1] = 1;\n\t}\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; i + j <= n; j++) {\n\t\t\tint l = j, r = i + j;\n\t\t\tC[l][r] = B[l][r];\n\t\t\tC[r][l] = B[r][l];\n\t\t\tbitset <2010> tmp = C[l] & Ans[l + 1] & Ans[r];\n\t\t\tAns[r][l] = !!tmp.count();\n\t\t\ttmp = C[r] & Ans[l] & Ans[r - 1];\n\t\t\tAns[l][r] = !!tmp.count();\n\t\t}\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i++) tot += Ans[1][i] && Ans[n][i];\n\tprintf(\"%d\\n\", tot);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <mutex>\n#include <cmath>\n#define lli long long int\n#define ll long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nint main(){\n  int N;\n  int f = 0;\n  cin >> N;\n  int a[N][N-1];\n  for(int i = 0; i < N - 1; i++){\n    for(int j = 0; j <= i; j++){\n      cin >> a[i][j];\n      if(a[i][j] == '1'){\n        f++;\n      }\n    }\n  }\n  if(f%2 == 1){\n    cout << N/2 +1;\n  }\n  else{\n    cout << N/2;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=2005;\nint n;\nint a[N][N];\nbool fl[N][N],fr[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t\tscanf(\"%1d\",&a[i][j]),a[j][i]=a[i][j]^1;\n\tfor(int i=1;i<=n;i++)\n\t\tfl[i][i]=fr[i][i]=true;\n\tfor(int len=2;len<=n;len++)\n\t\tfor(int i=1;i+len-1<=n;i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tfor(int k=i+1;k<=j;k++)\n\t\t\t\tif(a[i][k]) fl[i][j]|=fl[i][k-1]&fl[k][j];\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tfor(int u=i+1;u<=j;u++)\n\t\t\t\t\tfl[i][j]|=fl[i][u-1]&fr[u][j];\n\t\t\t}\n//\t\t\tfl[i][j]|=fl[i][j-1]&a[i][j];\n\t\t\tfor(int k=i;k+1<=j;k++)\n\t\t\t\tif(a[j][k]) fr[i][j]|=fr[i][k]&fr[k+1][j];\n\t\t\tif(a[j][i])\n\t\t\t{\n\t\t\t\tfor(int u=i;u<=j-1;u++)\n\t\t\t\t\tfr[i][j]|=fl[i][u]&fr[u+1][j];\n\t\t\t}\n//\t\t\tcerr<<\"now\"<<i<<\" \"<<j<<\" \"<<fl[i][j]<<\" \"<<fr[i][j]<<\"\\n\";\n//\t\t\tfr[i][j]|=fr[i+1][j]&a[j][i];\n\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(fr[1][i]&&fl[i][n]) ans++;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, res;\nchar c;\nset<int>st[2000];\nmap<pair<int, pair<int, int>>, int>mp;\n\nbool f(int x, int l, int r) {\n\tif (mp.find(mkp(x, mkp(l, r))) != mp.end())return mp[mkp(x, mkp(l, r))];\n\tmp[mkp(x, mkp(l, r))] = 1;\n\tif (x == l&&x == r)return true;\n\tif (x == l) {\n\t\tauto it = st[x].find(x);\n\t\t++it;\n\t\twhile (*it <= r) {\n\t\t\tif (f(*it, x + 1, r))return true;\n\t\t\t++it;\n\t\t}\n\t}\n\telse if (x == r) {\n\t\tauto it = st[x].find(x);\n\t\t--it;\n\t\twhile (*it >= l) {\n\t\t\tif (f(*it, l, x - 1))return true;\n\t\t\t--it;\n\t\t}\n\t}\n\telse {\n\t\tauto it = st[x].find(x);\n\t\tbool F = false;\n\t\t++it;\n\t\twhile (*it <= r) {\n\t\t\tif (f(*it, x + 1, r)) {\n\t\t\t\tF = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++it;\n\t\t}\n\t\tif (F) {\n\t\t\tit = st[x].find(x);\n\t\t\t--it;\n\t\t\twhile (*it >= l) {\n\t\t\t\tif (f(*it, l, x - 1))return true;\n\t\t\t\t--it;\n\t\t\t}\n\t\t}\n\t}\n\tmp[mkp(x, mkp(l, r))] = 0;\n\treturn false;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tcin >> c;\n\t\t\tif (c == '1') {\n\t\t\t\tst[i].insert(j);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst[j].insert(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tst[i].insert(-1);\n\t\tst[i].insert(i);\n\t\tst[i].insert(N);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tres += f(i, 0, N - 1);\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    bool A[2020][2020];\n    for (int n = 1; n < N; ++n) {\n        string s;\n        cin >> s;\n        for (int m = 0; m < n; ++m) {\n            A[n][m] = s[m] == '1';\n        }\n    }\n    \n    bool DP[2020][2020];\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = true;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            bool b = false;\n            for (int k = i+1; k <= i+d; ++k) {\n                b |= !A[k][i] & DP[k][i+1] & DP[k][i+d];\n            }\n            DP[i][i+d] = b;\n            \n            b = false;\n            for (int k = i; k < i+d; ++k) {\n                b |= A[i+d][k] & DP[k][i] & DP[k][i+d-1];\n            }\n            DP[i+d][i] = b;\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[n][0] & DP[n][N-1]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  auto a = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a[i][j] = k;\n    a[j][i] = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);a#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  auto a = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a[i][j] = k;\n    a[j][i] = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  for (size_t i = 0; i <= n; i++) dp[i][i + 1] = true;\n  for (size_t d = 2; d <= n + 1; d++) {\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      for (size_t k = i + 1; k < j; k++) {\n        dp[i][j] |= dp[i][k] && dp[k][j] && (a[i][k] || a[j][k]);\n      }\n    }\n  }\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp[0][i] && dp[i][n + 1]) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  for (size_t i = 0; i <= n; i++) dp[i][i + 1] = true;\n  auto renew = [&] (size_t d) {\n    assert(2 <= d && d <= n + 1);\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      for (size_t k = i + 1; k < j; k++) {\n        dp[i][j] |= dp[i][k] && dp[k][j] && (a[i][k] || a[j][k]);\n      }\n    }\n  };\n  for (size_t d = 2; d <= n + 1; d++) renew(d);\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp[0][i] && dp[i][n + 1]) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 2020;\nbool a[MAX][MAX]={};\nusing BS = bitset<MAX>;\nBS st[MAX],dpL[MAX],dpR[MAX];\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(a[i][j]) st[i].set(j);\n      \n  for(int i=0;i<n;i++){\n    dpL[i].set(i);\n    dpR[i].set(i);\n  }\n\n  for(int w=2;w<=n;w++){\n    for(int i=0;i+w<=n;i++){\n      int l=i,r=i+w-1;\n      {\n        BS x=dpR[l+1]&dpL[r]&st[l];      \n        if((((x>>(r+1))<<(r+1))^((x>>(l+1))<<(l+1))).any()) dpL[r].set(l);\n      }\n      { \n        BS x=dpR[l]&dpL[r-1]&st[r];\n        if((((x>>r)<<r)^((x>>l)<<l)).any()) dpR[l].set(r);        \n      }\n    }\n  }\n  \n  cout<<(dpR[0]&dpL[n-1]).count()<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 2010;\nint n;\nbitset<N>a[N],b[N],L[N],R[N];\nchar s[N];\n\nint main(){\n\tn=read();\n\tFor(i,2,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFOR(j,1,i){\n\t\t\tif (s[j]=='0') a[j][i]=1,b[i][j]=1;\n\t\t\t\telse b[j][i]=1,a[i][j]=1;\n\t\t}\n\t}\n\tFor(i,1,n) L[i][i]=R[i][i]=1;\n\tFor(len,2,n){\n\t\tFor(l,1,n-len+1){\n\t\t\tint r=l+len-1;\n\t\t\tif (R[l+1][r]&&a[l][r]) L[r][l]=1;\n\t\t\tif ((R[l+1]&L[r]&a[l]).any()) L[r][l]=1;\n\t\t\tif (L[r-1][l]&&a[r][l]) R[l][r]=1;\n\t\t\tif ((R[l]&L[r-1]&a[r]).any()) R[l][r]=1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(R[1]&L[n]).count());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nbitset<2020> A[2020];\nbitset<2020> winL[2020],winR[2020],winRL[2020],winRR[2020];\nbitset<2020> dp[2020];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(j=1;j<N;j++) {\n\t\tcin>>s;\n\t\tFOR(i,j) {\n\t\t\tA[j][i]=s[i]=='1';\n\t\t\tA[i][j]=s[i]=='0';\n\t\t}\n\t}\n\t\n\tFOR(x,N) winL[x][x]=winR[x][x]=winRL[x][x]=winRR[x][x]=1;\n\tfor(l=2;l<=N;l++) {\n\t\tfor(x=0;x+l<=N;x++) {\n\t\t\ty=x+l-1;\n\t\t\tauto bs=winL[x] & (winR[y]>>1);\n\t\t\tif(bs.count()) dp[x][y]=dp[y][x]=1;\n\t\t\tbs=A[x] & dp[x] & winRL[y];\n\t\t\tif(bs.count()) winL[x][y]=winRL[y][x]=1;\n\t\t\tbs=A[y] & dp[y] & winRR[x];\n\t\t\tif(bs.count()) winR[y][x]=winRR[x][y]=1;\n\t\t}\n\t}\n\tint ret=0;\n\tFOR(i,N) ret+=winR[i][0]&winL[i][N-1];\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1000003;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nconst int MAX_N = 2000;\n\ndouble winL[MAX_N][MAX_N];\ndouble winR[MAX_N][MAX_N];\ndouble sumP[MAX_N][MAX_N];\n\n\nint main() {\n  int N;\n  cin >> N;\n  auto mat = make_v< int >(N, N);\n  for(int i = 1; i < N; i++) {\n    string s;\n    cin >> s;\n    for(int j = 0; j < i; j++) {\n      int x = (int) s[j] - '0';\n      mat[i][j] = x;\n      mat[j][i] = 1 - x;\n    }\n  }\n\n  for(int i = N - 1; i >= 0; i--) {\n    winL[i][i] = winR[i][i] = 1;\n    for(int j = i + 1; j < N; j++) {\n      sumP[i][j] = 0;\n      for(int p = i; p < j; p++) {\n        sumP[i][j] += winL[i][p] * winR[p + 1][j];\n      }\n      winL[i][j] = winR[i][j] = 0;\n      {  // winL\n        for(int k = i + 1; k <= j; k++) {\n          double prob = mat[i][k];\n          winL[i][j] += prob * winL[k][j] * sumP[i][k];\n        }\n      }\n      {  // winR\n        for(int k = i; k < j; k++) {\n          double prob = mat[j][k];\n          winR[i][j] += prob * winR[i][k] * sumP[k][j];\n        }\n      }\n      winL[i][j] /= (j - i);\n      winR[i][j] /= (j - i);\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    double ans = winR[0][i] * winL[i][N - 1];\n    ret += ans > 0;\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst ll MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            char c;\n            cin>>c;\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;j+i<n;j++){\n            for(int k=j+1;k<=j+i;k++){\n                if(A[j][k] && dp[k][j+1] && dp[k][j+i]){dp[j][j+i]=true; break;}\n            }\n        }\n        for(int j=i;j<n;j++){\n            for(int k=j-i;k<j;k++){\n                if(A[j][k] && dp[k][j-1] && dp[k][j-i]){dp[j][j-i]=true; break;}\n            }\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[i][0] && dp[i][n-1]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <set>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <stack>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef unsigned long long uLL;\n\n#define ls rt<<1\n#define rs rt<<1|1\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define bug printf(\"*********\\n\")\n#define FIN freopen(\"input.txt\",\"r\",stdin);\n#define FON freopen(\"output.txt\",\"w+\",stdout);\n#define IO ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define fi first\n#define se second\n\nconst ll mod=1e9+7;\n\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n//head\n\nint n;\nstring s;\nint a[2005][2005];  //a[i][j]=0: jwin\n\nbool f[2005],g[2005];\nint main(){\n\tIO;\n\tcin>>n;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tcin>>s;\n\t\tfor (int j=0;j<s.length();j++)\n\t\t{\n\t\t\tif (s[j]=='0')\n\t\t\t{\n\t\t\t\ta[i][j+1]=0;\n\t\t\t\ta[j+1][i]=1;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\ta[i][j+1]=1;\n\t\t\t\ta[j+1][i]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tf[1]=1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<i;j++)\n\t\t{\n\t\t\tif (f[j] && a[j][i]==0) \n\t\t\t{\n\t\t\t\tf[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tg[n]=1;\n\tfor (int i=n-1;i>=1;i--)\n\t{\n\t\tfor (int j=n;j>i;j--)\n\t\t{\n\t\t\tif (g[j] && a[j][i]==0) \n\t\t\t{\n\t\t\t\tg[i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (f[i] && g[i]) ans++;\n\t}\n\tcout<<ans<<\"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\n#include <bitset>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_N   (2000)\nchar szInput[MAX_N + 1];\nstatic bitset<MAX_N + 1> s_abitMatchTbl[MAX_N + 1];\n\nint main(void)\n{\n    SDWORD lInput_n = inputSDWORD();\n    for (SDWORD lIdxI = 2; lIdxI <= lInput_n; lIdxI++) {\n        inputString(szInput);\n        for (SDWORD lIdxJ = 1; lIdxJ < lIdxI; lIdxJ++) {\n            if ('0' == szInput[lIdxJ - 1]) {\n                s_abitMatchTbl[lIdxJ][lIdxI] = true;\n            }\n        }\n    }\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalMatchTbl[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    static bitset<MAX_N + 1> s_absDpL[MAX_N+1];\n    static bitset<MAX_N + 1> s_absDpR[MAX_N+1];\n\n    for (SDWORD lUpdateWidth = 0; lUpdateWidth <= lInput_n; lUpdateWidth++) {\n        for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n - lUpdateWidth; lUpdIdxL++) {\n            SDWORD lUpdIdxR = lUpdIdxL + lUpdateWidth;\n            if (lUpdIdxL == lUpdIdxR) {\n                s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n            } else {\n                bool bCondLR = false;\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A1: [%d, <%d> %d], %d %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalMatchTbl[lUpdIdxL][lUpdIdxR],\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM+1][lUpdIdxR]);\n#endif\n\n                    if ((s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (s_absDpR[lUpdIdxM+1][lUpdIdxR])) {\n                        bCondLR = true;\n                    }\n                }\n                if (bCondLR) {\n                    if (s_abitMatchTbl[lUpdIdxL][lUpdIdxR]) {\n                        s_absDpL[lUpdIdxL][lUpdIdxR] = true;\n                    } else {\n                        s_absDpR[lUpdIdxL][lUpdIdxR] = true;\n                    }\n                }\n\n                bool bCondLL = false;\n                bool bCondRR = false;\n                for (SDWORD lUpdIdxM = lUpdIdxL + 1; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A2: [%d, <%d> %d], %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpL[lUpdIdxM][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpL[lUpdIdxM][lUpdIdxR])) {\n                        bCondLL = true;\n                    }\n                    if ((1 == s_absDpR[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpR[lUpdIdxM][lUpdIdxR])) {\n                        bCondRR = true;\n                    }\n                }\n                if (bCondLL) {\n                    s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                }\n                if (bCondRR) {\n                    s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                }\n            }\n        }\n    }\n\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpL[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpR[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    /* count winners */\n    SDWORD lAns = 0;\n    for (SDWORD lMid = 1; lMid <= lInput_n; lMid++) {\n        if (s_absDpR[1][lMid] && s_absDpL[lMid][lInput_n]) {\n            lAns++;\n        }\n    }\n\n    printf(\"%d\\n\", lAns);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 2010\nusing namespace std;\nbitset<N> dpl[N],dpr[N],a[N];\nint n,x,ansn;\nchar ch;\nint main(){\n\tcin>>n;\n\tfor (int i=2;i<=n;i++){\n\t\tfor (int j=1;j<i;j++){\n\t\t\tcin>>ch;x=ch-'0';\n\t\t\ta[i][j]=x;a[j][i]=1-x;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)dpl[i][i]=dpr[i][i]=1;\n\tfor (int l=2;l<=n;l++){\n\t\tfor (int i=1;i+l-1<=n;i++){\n\t\t\tif ((a[i]&dpl[i+l-1]&dpr[i+1]).any())dpl[i+l-1][i]=1;\n\t\t\tif ((a[i+l-1]&dpl[i+l-2]&dpr[i]).any())dpr[i][i+l-1]=1;\n\t\t}\n\t}\n\tcout<<((dpr[1]&dpl[n]).count())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbool win[2001][2001];\nbool dp[2][2001][2001];\nsigned main() {\n    int N; cin >> N;\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[0][i][i] = dp[1][i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            bool f1 = false, f2 = false;\n            for(int k=i+1; k<=j; k++) {\n                f1 |= win[i][k] and dp[0][j][k] and dp[1][i+1][k];\n            }\n            for(int k=i; k<j; k++) {\n                f2 |= win[j][k] and dp[1][i][k] and dp[0][j-1][k];\n            }\n            dp[0][j][i] = f1, dp[1][i][j] = f2;\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dp[0][N-1][i] and dp[1][0][i]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ], st[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind;\n\tind = st[l][l];\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = st[r][l];\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\tint start = clock();\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(wn[i].begin(), wn[i].end());\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint curInd = wn[i].size();\n\t\tfor (int j = n + 1; j >= 0; j--) {\n\t\t\tif (curInd != 0 && wn[i][curInd - 1] > j) curInd--;\n\t\t\tst[i][j] = curInd;\n\t\t}\n\t}\n\n\tll ans = 0;\n\t\n\tvector<ll> perm;\n\tfor (int i = 1; i <= n; i++) perm.push_back(i);\n\n\trandom_shuffle(perm.begin(), perm.end());\n\tfor (int i2 = 1; i2 <= n; i2++) {\n\t\tint end = clock();\n\t\tint t = (end - start);\n\t\tif (t >= 100000) break;\n\t\tint i = perm[i2];\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing _loop_int = int;\n#define REP(i,n) for(_loop_int i=0; i<(_loop_int)(n); i++)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a); i<(_loop_int)(b); i++)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1; i>=(_loop_int)(a); i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n#define ALL(v) (v).begin(),(v).end()\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define DEBUG_VEC(v) cerr<<#v<<\": \";REP(__i,(v).size())cerr<<((v)[__i])<<\", \";cerr<<endl\n\nconst ll MOD = 1000000007ll;\n\nint n;\nchar s[2521][2521];\nbool win[2521][2521];\nint nxt[2521][2521];\nbool yusho[2][2521][2521];\n\nint main(){\n    scanf(\"%d\",&n);\n    REP(i,n-1)scanf(\"%s\",s[i+1]);\n    REP(i,n)REP(j,i){\n        win[i][j] = s[i][j]=='1';\n        win[j][i] = !win[i][j];\n    }\n    REP(i,n){\n        nxt[i][n] = n;\n        FORR(j,0,n){\n            nxt[i][j] = win[i][j] ? j : nxt[i][j+1];\n        }\n    }\n    REP(k,2)REP(i,n+1)yusho[k][i][i] = true;\n    FOR(len,1,n)REP(l,n){\n        int r = l+len;\n        if(r>n)break;\n        REP(k,2){\n            int p = k==0 ? l-1 : r;\n            if(p>=n || p<0)continue;\n            FOR(to,l,r){\n                if(win[p][to] && yusho[1][l][to] && yusho[0][r][to+1]){\n                    (k==1 ? yusho[k][l][r] : yusho[k][r][l]) = true;\n                    break;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    REP(i,n){\n        bool ok = yusho[1][0][i] && yusho[0][n][i+1];\n        if(ok)ans++;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _dbg(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _dbg(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_dbg(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\nconst int N=2001;\nusing bt=bitset<N>;\nbool a[N][N];\nbool win[N][N];\nint32_t main() {\n    int n;\n    cin>>n;\n    forn(i,n){\n        forn(j,i){\n            char c;\n            cin>>c;\n            a[i][j]=c-'0';\n            a[j][i]=a[i][j]^1;\n        }\n        win[i][i]=1;\n        // stolb[i][i]=1;\n    }\n    for(int len=2;len<=n;++len){\n        for(int i=0;i+len-1<n;++i){\n            int r=i+len-1;\n            if(a[i][r]){\n                for(int k=i;k<r;++k){\n                    if(win[i][k]&win[r][k+1]){\n                        win[i][r]=1;\n                        // stolb[r][i]=1;                        \n                    }\n                }\n            }\n            for(int k=i;k<r;++k){\n                if(a[i][k+1]&win[i][k]&win[k+1][r]){\n                    win[i][r]=1;\n                    // stolb[r][i]=1;                                    \n                }\n            }\n        }\n        for(int i=len-1;i<n;++i){\n            int l=i-len+1;\n            if(a[i][l]){\n                for(int k=i;k>l;--k){\n                    if(win[l][k-1]&win[i][k]){\n                        win[i][l]=1;\n                        // stolb[l][i]=1;                        \n                    }\n                }\n            }\n            for(int k=i;k>l;--k){\n                if(a[i][k-1]&win[i][k]&win[k-1][l]){\n                    win[i][l]=1;\n                    // stolb[l][i]=1;                                    \n                }\n            }\n        }\n    }\n    int ans=0;\n    forn(i,n){\n        ans+=(win[i][0]&win[i][n-1]);\n    }\n    cout<<ans<<'\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, A[2009][2009], L[2009], R[2009];\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tA[i][j] = (c - '0'); A[j][i] = (A[i][j] ^ 1);\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) { L[i] = i; R[i] = i; }\n\tfor (int i = 0; i < 180; i++) {\n\t\tfor (int j = 1; j < N; j++) {\n\t\t\tfor (int k = 1; k <= N - j; k++) {\n\t\t\t\tint l = k + j;\n\t\t\t\tif (R[k] + 1 >= L[l]) {\n\t\t\t\t\tif (A[k][l] == 1) R[k] = R[l];\n\t\t\t\t\tif (A[k][l] == 0) L[l] = L[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (L[i] == 1 && R[i] == N) cnt++;\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define N 2020\n\nbitset<N> l[N], r[N], a[N];\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tchar s[N];\n\tfor (int i = 2; i <= n; i ++) {\n\t\tscanf(\"%s\", s + 1);\n\t\tfor (int j = 1; j < i; j ++) {\n\t\t\ta[i][j] = s[j] - '0';\n\t\t\ta[j][i] = !a[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i ++) {\n\t\tl[i][i] = r[i][i] = a[i][i] = 1;\n\t}\n\tfor (int len = 1; len < n; len ++) {\n\t\tfor (int y = 1; y + len <= n; y ++) {\n\t\t\tint x = len + y;\n\t\t\tif ((a[x]&l[y]&r[x-1]).any()) l[y][x] = 1;\n\t\t\tif ((a[y]&l[y+1]&r[x]).any()) r[x][y] = 1;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tif (l[1][i] && r[n][i]) ans ++;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000003;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nbool b[2000][2000];\n\nbool le[2000][2000], ri[2000][2000];\nvoid solve() {\n\tint n; cin >> n;\n\trep1(i, n - 1) {\n\t\trep(j, i) {\n\t\t\tchar t; cin >> t;\n\t\t\tif (t == '1') {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n)le[i][i] = ri[i][i] = true;\n\n\tint ans = 0;\n\tRep1(i, 2, n) {\n\t\trep(j, n - i + 1) {\n\t\t\tint l = j;\n\t\t\tint r = j + i - 1;\n\t\t\tbool fl = false, fr = false;\n\t\t\tRep1(k, l + 1, r) {\n\t\t\t\tfl |= b[l][k] & ri[l + 1][k] & le[r][k];\n\t\t\t}\n\t\t\tRep(k, l, r) {\n\t\t\t\tfr |= b[r][k] & ri[l][k] & le[r - 1][k];\n\t\t\t}\n\t\t\tle[r][l] = fl, ri[l][r] = fr;\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (ri[0][i] && le[n - 1][i])ans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target (\"avx\")\n\n#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cerr << *i << \" \"; cerr << endl; }\ntemplate <class T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <class T> void chmax(T &t, const T &f) { if (t < f) t = f; }\n\n// (a | b) & c & d\ntemplate <size_t N> bool bitsetOpAny(bitset<N> &a, bitset<N> &b, bitset<N> &c, bitset<N> &d) {\n  constexpr size_t nw = (N + 64 - 1) / 64;\n  auto a_ = (uint64_t *)&a;\n  auto b_ = (uint64_t *)&b;\n  auto c_ = (uint64_t *)&c;\n  auto d_ = (uint64_t *)&d;\n  for (size_t i = 0; i < nw; ++i) {\n    if ((a_[i] | b_[i]) & c_[i] & d_[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nconstexpr int MAX_N = 2005;\n\nint N;\nchar A[MAX_N][MAX_N];\n\n// bool B[MAX_N][MAX_N];\nbitset<MAX_N> B[MAX_N];\n\n// bool dp[MAX_N][MAX_N];\nbitset<MAX_N> dp[MAX_N], DP[MAX_N];\n\nint main() {\n  for (; ~scanf(\"%d\", &N); ) {\n    for (int i = 2; i <= N; ++i) {\n      scanf(\"%s\", A[i] + 1);\n    }\n    for (int i = 0; i <= N + 1; ++i) {\n      B[i].reset();\n    }\n    B[0][N + 1] = true;\n    B[N + 1][0] = false;\n    for (int i = 1; i <= N; ++i) {\n      B[0][i] = false;\n      B[i][0] = true;\n      B[N + 1][i] = false;\n      B[i][N + 1] = true;\n    }\n    for (int i = 1; i <= N; ++i) for (int j = 1; j < i; ++j) {\n      B[i][j] = (A[i][j] == '1');\n      B[j][i] = (A[i][j] == '0');\n    }\n    // memset(dp, 0, sizeof(dp));\n    for (int i = 0; i <= N + 1; ++i) {\n      dp[i].reset();\n      DP[i].reset();\n    }\n    for (int i = 0; i <= N; ++i) {\n      dp[i][i + 1] = true;\n      DP[i + 1][i] = true;\n    }\n    for (int w = 2; w <= N + 1; ++w) {\n      for (int i = 0; i <= N + 1 - w; ++i) {\n        const int j = i + w;\n        // for (int k = i + 1; k < j; ++k) {\n          // if ((B[i][k] || B[j][k]) && dp[i][k] && dp[k][j]) {\n            // dp[i][j] = true;\n            // break;\n          // }\n        // }\n        // dp[i][j] = DP[j][i] = ((B[i] | B[j]) & dp[i] & DP[j]).any();\n        dp[i][j] = DP[j][i] = bitsetOpAny(B[i], B[j], dp[i], DP[j]);\n      }\n    }\n// for(int i=0;i<=N+1;++i){for(int j=0;j<=N+1;++j){cout<<dp[i][j];}cout<<endl;}\n    int ans = 0;\n    for (int i = 1; i <= N; ++i) {\n      if (dp[0][i] && dp[i][N + 1]) {\n        ++ans;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 2048;\n\nbitset<N> f[N], frev[N], dp0[N], dp1[N], dp0rev[N], dp1rev[N];\nbitset<N> win[N];\nchar s[N];\nint main(){\n\tint n; sd(n);\n\tfor(int i = 2; i <= n; i++){\n\t\tscanf(\"%s\", s);\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tint x = s[j - 1] - '0';\n\t\t\tif(x) win[i][j] = 1, win[j][i] = 0;\n\t\t\telse win[j][i] = 1, win[i][j] = 0;\n\t\t}\n\t}\n\n\n\tfor(int i = 1; i <= n; i++) dp0[i][i] = dp1[i][i] = dp0rev[i][i] = dp1rev[i][i] = 1;\n\n\tfor(int i = n; i >= 1; i--){\n\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\tf[i][j] = ((dp0[i] << 1) & dp1[j]).any();\n\t\t\tfrev[j][i] = f[i][j];\n\t\t\tdp0[i][j] = (win[i] & f[i] & dp0rev[j]).any();\n\t\t\tdp1[j][i] = (win[j] & frev[j] & dp1rev[i]).any();\n\n\t\t\tdp0rev[j][i] = dp0[i][j];\n\t\t\tdp1rev[i][j] = dp1[j][i];\n\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(dp1[i][1] && dp0[i][n]){\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        string t;\n        cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            A[i][j] = t[j]!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<char>> L(N, vector<char>(N));\n    vector<vector<char>> R(N, vector<char>(N));\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<N && !b; j++)\n                    if (a[j] && l[j] && r[j])\n                        b = true;\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=0; j<i && !b; j++)\n                    if (a[j] && l[j] && r[j])\n                        b = true;\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2010;\nint n;\nchar s[N][N];\nbitset<N>a[N],dp[N],tmp;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++){\n\t\tscanf(\"%s\",s[i]+1);\n\t\tfor(int j=1;j<i;j++){\n\t\t\tint t=s[i][j]-'0';\n\t\t\ta[i][j]=t;\n\t\t\ta[j][i]=a[i][j]^1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)dp[i][i]=1;\n\tfor(int k=2;k<=n;k++)\n\t\tfor(int i=1;i+k-1<=n;i++){\n\t\t\tint j=i+k-1;\n\t\t\ttmp=a[i]&dp[j]&dp[i+1];\n\t\t\tdp[j][i]=(tmp._Find_next(i)<=j);\n\t\t\ttmp=a[j]&dp[j-1]&dp[i];\n\t\t\tdp[i][j]=(tmp._Find_next(i-1)<j);\n\t\t}\n\tprintf(\"%d\\n\",(dp[1]&dp[n]).count());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    //vector<vector<bool>> A(N, vector<bool>(N));\n    static bool A[2048][2048];\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\" %c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    //vector<vector<bool>> L(N, vector<bool>(N));\n    //vector<vector<bool>> R(N, vector<bool>(N));\n    static bool L[2048][2048];\n    static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<N; j++)\n                    b |= a[j] & l[j] & r[j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=0; j<i; j++)\n                    b |= a[j] & l[j] & r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 1000003;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nint main() {\n  int n;\n  cin >> n;\n  vii a(n, vi(n, -1));\n  rep1 (i, n - 1) {\n    for (int j = 0; j < i; j++) {\n      char c;\n      cin >> c;\n      a[i][j] = c - '0';\n      a[j][i] = 1 - a[i][j];\n    }\n  }\n  \n  vi can_left(1, 0);\n  rep1 (i, n - 1) {\n    bool flag = false;\n    rep (j, can_left.size()) {\n      int x = can_left[j];\n      if (a[i][x]) {\n        flag = true;\n        break;\n      }\n    }\n    if (flag) {\n      can_left.push_back(i);\n    }\n  }\n\n  vi can_right(1, n - 1);\n  for (int i = n - 2; i >= 0; i--) {\n    bool flag = false;\n    rep (j, can_right.size()) {\n      int x = can_right[j];\n      if (a[i][x]) {\n        flag = true;\n        break;\n      }\n    }\n    if (flag) {\n      can_right.push_back(i);\n    }\n  }\n\n  set<int> ari;\n  rep (i, can_left.size()) {\n    ari.insert(can_left[i]);\n  }\n  int cnt = 0;\n  rep (j, can_right.size()) {\n    int x = can_right[j];\n    if (ari.count(x)) cnt++;\n  }\n  cout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 11);\n\nint n;\nbitset<MAXN> A[MAXN];\n\nvoid read()\n{\n\tcin >> n;\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 1; j < i; j++)\n\t\t{\n\t\t\tint x = s[j - 1] - '0';\n\t\t\tA[j][i] = x ^ 1;\n\t\t\tA[i][j] = x;\n\t\t}\n\t}\n}\n\nbitset<MAXN> lft[MAXN];\nbitset<MAXN> rgh[MAXN];\nbitset<MAXN> winners[MAXN], emp;\n\nvoid solve()\n{\n\tfor(int i = 1; i <= n; i++)\n\t\tlft[i][i] = 1, rgh[i][i] = 1, winners[i][i] = 1;\n\n\tfor(int len = 2; len <= n; len++)\n\t{\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint r = i + len - 1;\n\t\t\tif(r > n) continue;\n\t\t\tif((A[i] & winners[i + 1]).count()) lft[r][i] = 1;\n\t\t}\n\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint l = i - len + 1;\n\t\t\tif(l <= 0) continue;\n\t\t\tif((A[i] & winners[l]).count()) rgh[l][i] = 1;\n\t\t}\n\n\t\tfor(int l = 1; l <= n; l++)\n\t\t{\n\t\t\tint r = l + len - 1;\n\t\t\tif(r > n) continue;\n\t\t\twinners[l] = rgh[l] & lft[r];\n\t\t}\n\t}\n\n\tcout << winners[1].count() << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e3 + 5;\n\nint N;\nbitset <MAXN> beats[MAXN];\nbitset <MAXN> lft[MAXN], rig[MAXN];\n\nvoid load() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 2; i <= N; i++)\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tchar x;\n\t\t\tscanf(\" %c\", &x);\n\t\t\tif (x == '1')\n\t\t\t\tbeats[i].set(j);\n\t\t\telse\n\t\t\t\tbeats[j].set(i);\n\t\t}\n}\n\nint solve() {\n\tfor (int i = 1; i <= N; i++) {\n\t\tlft[i].set(i);\n\t\trig[i].set(i);\n\t}\n\t\n\tfor (int i = 2; i <= N; i++) {\n\t\tvector <bool> can_right(N + 1, false), can_left(N + 1, false);\n\t\tfor (int j = 1; j + i - 1 <= N; j++) {\n\t\t\tcan_right[j] = (lft[j + 1] & rig[j + i - 1] & beats[j]).any();\n\t\t\tcan_left[j + i - 1] = (lft[j] & rig[j + i - 2] & beats[j + i - 1]).any(); \n\t\t}\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (can_right[j])\n\t\t\t\trig[j + i - 1].set(j);\n\t\t\tif (can_left[j])\n\t\t\t\tlft[j - i + 1].set(j);\n\t\t}\n\t}\n\t\t\n\tint sol = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tsol += lft[1].test(i) && rig[N].test(i);\n\t\n\treturn sol;\n}\n\nint main() {\n\tload();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n\ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\nint a[2005][2005];\nll  dp[2005][2005][40];\n\nint main(int argc, char* argv[])\n{\n    int n;\n    scanf(\"%d\", &n);\n\n    int i,j;\n    for(i=1; i<n; i++) {\n        char str[2005];\n        scanf(\"%s\", str);\n        for(j=0; j<i; j++) {\n            a[i][j]=(str[j]=='1'? 1: 0);\n            a[j][i]=1-a[i][j];\n        }\n    }\n\n    \n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2010\nusing namespace std;\nbitset<maxn> g[2][maxn], mp[maxn], now, pre, suf;\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= i - 1; j++)\n\t\t{\n\t\t\tchar c = getchar();\n\t\t\twhile (c != '0' && c != '1') c = getchar();\n\t\t\tmp[i][j] = c - '0';\n\t\t\tmp[j][i] = 1 - mp[i][j];\n\t\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t\tg[0][i][i + 1] = g[1][i + 1][i] = 1;\n\tfor (int len = 3; len <= n; len++)\n\t\tfor (int i = 1; i <= n - len + 1; i++)\n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tnow = g[0][i] & g[1][j] & (mp[i] | mp[j]);\n\t\t\tif (now.count()) g[0][i][j] = g[1][j][i] = 1;\n\t\t}\n\tpre[1] = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tfor (int j = 1; j <= i - 1; j++)\n\t\t\tif (pre[j] & g[0][j][i] & mp[i][j]) pre[i] = 1;\n\tsuf[n] = 1;\n\tfor (int i = n - 1; i >= 1; i--)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tif (suf[j] & g[0][i][j] & mp[i][j]) suf[i] = 1;\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (pre[i] & suf[i]) res++;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n; cin>>n;\n    if(n==1){\n        cout<<1<<endl; return 0;\n    }\n    string a[2002];\n    for(int i=1; i<n; i++) cin>>a[i];\n    bool dp[2][2002][2002];\n    for(int i=0; i<n-1; i++){\n        if(a[i+1][i]=='0'){\n            dp[0][i][i+1]=1;\n            dp[1][i][i+1]=0;\n        }else{\n            dp[0][i][i+1]=0;\n            dp[1][i][i+1]=1;\n        }\n    }\n    for(int d=2; d<n; d++){\n        for(int i=0; i<n-d; i++){\n            if(dp[0][i+1][i+d] && a[i+1][i]=='0'){\n                dp[0][i][i+d]=1;\n            }else if(dp[1][i+1][i+d] && a[i+d][i]=='0'){\n                dp[0][i][i+d]=1;\n            }else{\n                dp[0][i][i+d]=0;\n                for(int j=i+2; j<i+d; j++){\n                    if(dp[1][i+1][j] && dp[0][j][i+d] && a[j][i]=='0'){\n                        dp[0][i][i+d]=1;\n                        break;\n                    }\n                }\n            }\n            if(dp[1][i][i+d-1] && a[i+d][i+d-1]=='1'){\n                dp[1][i][i+d]=1;\n            }else if(dp[0][i][i+d-1] && a[i+d][i]=='1'){\n                dp[1][i][i+d]=1;\n            }else{\n                dp[1][i][i+d]=0;\n                for(int j=i+1; j<i+d-1; j++){\n                    if(dp[1][i][j] && dp[0][j][i+d-1] && a[j][i]=='1'){\n                        dp[1][i][i+d]=1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    int ans=0;\n    if(dp[0][0][n-1]) ans++;\n    if(dp[1][0][n-1]) ans++;\n    for(int i=1; i<n-1; i++){\n        if(dp[1][0][i] && dp[0][i][n-1]) ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e6+3)\n\nll N,A[2222][2222];\nchar a[2222];\nll btrR[2222][2222], btrL[2222][2222];\nlist<ll> rlst[2222];\nll i, j, k, ans;\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        scanf(\"%s\", a);\n        fornum(j,0,i){\n            A[i + 1][j + 1] = a[j]=='1';\n            A[j + 1][i + 1] = a[j]=='0';\n        }\n    }\n    btrR[N][N] = 1;\n    for (i = N; i > 0;i--){\n        for (j = i + 1; j <= N;j++){\n            if(btrR[i+1][j]){\n                if(A[i][j]){\n                    btrR[i][i] = 1;\n                }else{\n                    btrR[i][j] = 1;\n                }\n            }\n        }\n        ll ii = i;\n        for (j = i + 1; j <= N;j++){\n            if(A[j][ii]){\n                if(btrR[j][j]){\n                    btrR[i][j] = 1;\n                }else{\n                    ii = j;\n                }\n            }\n        }\n    }\n    btrL[1][1] = 1;\n    for (i = 1; i <= N;i++){\n        for (j = 1; j <i ;j++){\n            if(btrL[i-1][j]){\n                if(A[i][j]){\n                    btrL[i][i] = 1;\n                }else{\n                    btrL[i][j] = 1;\n                }\n            }\n        }\n        ll ii = i;\n        for (j =i-1; j >=1;j--){\n            if(A[j][ii]){\n                if(btrL[j][j]){\n                    btrL[i][j] = 1;\n                }else{\n                    ii = j;\n                }\n            }\n        }\n    }\n    /*\n    fornum(i,1,N+1){\n        fornum(j,1,N+1){\n            printf(\"%lld:%lld \", btrL[i][j], btrR[i][j]);\n        }\n        printf(\"\\n\");\n    }*/\n    fornum(i,1,N+1){\n        ll aa = 0, bb = 0;\n        if(btrL[i][i]*btrR[i][i]==1)\n            ans++;\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N;\nbitset<2000> win[2000];\nbitset<2000> dp[2000];\n\nint main() {\n\tsetIO(); re(N);\n\tFOR(i,1,N) F0R(j,i) {\n\t    char c; re(c);\n\t    if (c == '0') win[j][i] = 1;\n\t    else win[i][j] = 1;\n\t}\n\tF0R(i,N) dp[i][i] = 1;\n\tFOR(len,1,N) F0R(l,N-len) {\n\t    int r = l+len;\n        bitset<2000> tmp = dp[l+1]&dp[r]&win[l];\n        dp[r][l] = (tmp._Find_next(l) <= r);\n        tmp = dp[l]&dp[r-1]&win[r];\n        dp[l][r] = (tmp._Find_next(l-1) < r);\n\t}\n\tps((dp[0]&dp[N-1]).count());\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) FOR(i,0,b)\n#define ROF(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) ROF(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define reach cerr<<\"reached\"<<endl\nvoid dmpr(decltype(cerr)&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(decltype(cerr)&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp(...) dmpr(cerr,##__VA_ARGS__)\n#define zero(x) memset(x,0,sizeof(x))\n#define one(x) memset(x,-1,sizeof(x))\n#define fs first\n#define sc second\n#define bg begin()\n#define ed end()\n\ntemplate<class T> using V=vector<T>;\ntemplate<class T> using VV=V<V<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\trep(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> uni(const vector<T>&vv){\n\tauto v(vv);\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid mkuni(vector<T>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n}\n\n//ayasii\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\nconst int Nmax=2010;\n\nbitset<Nmax> l[Nmax],r[Nmax],l2[Nmax],r2[Nmax];\nbool win[Nmax][Nmax];\n\nsigned main(){\n\tint n=read();\n\tFOR(i,1,n){\n\t\tstring s=readString();\n\t\trep(j,i){\n\t\t\twin[i][j]=s[j]-'0';\n\t\t\twin[j][i]=!win[i][j];\n\t\t}\n\t}\n\trep(i,n+1)\n\t\tl[i][i]=1;\n\trep(w,n+1){\n\t\trep(i,n-w+1){\n\t\t\tbool x=l[i][i+w]||r[i+w][i];\n\t\t\tr[i+w][i]=x;\n\t\t\tl[i][i+w]=x;\n\t\t}\n\t\tFOR(i,1,n-w)if(l[i][i+w]){\n\t\t\tif(!win[i-1][i+w]){\n\t\t\t\tl2[i-1][i+w]=1;\n\t\t\t\tr[i+w]|=r[i-1];\n\t\t\t}else{\n\t\t\t\tr2[i+w+1][i]=1;\n\t\t\t\tl[i]|=l[i+w+1];\n\t\t\t}\n\t\t}\n\t\trep(i,n-w+1)if(l[i][i+w]){\n\t\t\tl[i]|=l2[i+w];\n\t\t\tr[i+w]|=r2[i];\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,n)\n\t\tif(l[0][i]&&l[i+1][n])\n\t\t\tans++;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=2000;\n\nint n;\nbool win[MAXN][MAXN];\n\nbool canfst[MAXN][MAXN];\nbool canlst[MAXN][MAXN];\nbool canfinal[MAXN][MAXN];\n\nbitset<MAXN> bwin[MAXN]; // win[i][k]\nbitset<MAXN> bfst[MAXN]; // canfst[k][i]\nbitset<MAXN> blst[MAXN]; // canlst[i][k]\nbitset<MAXN> bfst2[MAXN]; // canfst[i][k]\nbitset<MAXN> blst2[MAXN]; // canlst[k+1][j]\nbitset<MAXN> bfin1[MAXN]; // canfinal[i][k]\nbitset<MAXN> bfin2[MAXN]; // canfinal[k][i]\n\nint solve() {\n\t//REP(i,n) { printf(\"win%d: \",i); REP(j,n) printf(\"%c\",win[i][j]?'v':'.'); puts(\"\"); }\n\tREP(i,n) REP(j,n) canfst[i][j]=canlst[i][j]=canfinal[i][j]=false;\n\tREP(i,n) canfst[i][i]=canlst[i][i]=true;\n\tREP(i,n) bwin[i].reset(),bfst[i].reset(),blst[i].reset(),bfin1[i].reset(),bfin2[i].reset(),bfst2[i].reset(),blst2[i].reset();\n\tREP(i,n) REP(j,n) if(win[i][j]) bwin[i][j]=true;\n\tREP(i,n) bfst[i][i]=blst[i][i]=bfst2[i][i]=blst2[i][i]=true;\n\tFORE(len,2,n) REPE(i,n-len) {\n\t\tint j=i+len-1;\n\t\t\n\t\tif((bfst2[i]&(blst2[j]>>1)).any()) canfinal[i][j]=true;\n\t\tif(canfinal[i][j]) bfin1[i][j]=bfin2[j][i]=true;\n\t\t//bool chk1=false; FORE(k,i,j-1) if(canfst[i][k]&&canlst[k+1][j]) chk1=true; assert(chk1==canfinal[i][j]);\n\n\t\t//FORE(k,i+1,j) if(win[i][k]&&canfst[k][j]&&canfinal[i][k]) canfst[i][j]=true;\n\t\tif((bwin[i]&bfst[j]&bfin1[i]).any()) canfst[i][j]=true;\n\t\tif(canfst[i][j]) bfst[j][i]=bfst2[i][j]=true;\n\n\t\t//FORE(k,i,j-1) if(win[j][k]&&canlst[i][k]&&canfinal[k][j]) canlst[i][j]=true;\n\t\tif((bwin[j]&blst[i]&bfin2[j]).any()) canlst[i][j]=true;\n\t\tif(canlst[i][j]) blst[i][j]=blst2[j][i]=true;\n\n\t\t//printf(\"%d..%d: fst=%c lst=%c final=%c\\n\",i,j,canfst[i][j]?'v':'.',canlst[i][j]?'v':'.',canfinal[i][j]?'v':'.');\n\t}\n\tint ret=0; REP(i,n) if(canlst[0][i]&&canfst[i][n-1]) ++ret; return ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) win[i][i]=false;\n\tFOR(i,1,n) { string s; cin>>s; REP(j,i) win[i][j]=s[j]=='1',win[j][i]=!win[i][j]; }\n\tprintf(\"%d\\n\",solve());\n}\n\nvoid stress() {\n\tREP(rep,100) {\n\t\tn=100;\n\t\tREP(i,n) win[i][i]=false;\n\t\tREP(i,n) REP(j,i) win[i][j]=rand()%2==0,win[j][i]=!win[i][j];\n\t\tsolve();\n\t}\n}\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst long long int MOD = 1000003;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass XorShift {\n\tunsigned int x, y, z, w, t;\npublic:\n\tXorShift() {\n\t\tx = 133553533;\n\t\ty = 314867339;\n\t\tz = 664298413;\n\t\tw = 999999937;\n\t\tt = 0;\n\t}\n\tunsigned int rand() {\n\t\tt = x ^ (x << 11);\n\t\tx = y;\n\t\ty = z;\n\t\tz = w;\n\t\tw = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n\t\treturn w & 0x7fffffff;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>v(N, vector<int>(N));\n\tfor (int i = 1; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (s[j] == '1')v[i][j] = 1;\n\t\t\tv[j][i] = v[i][j] ^ 1;\n\t\t}\n\t}\n\tset<int>cand;\n\tXorShift xs;\n\tfor (int i = 0; i < 5000; i++) {\n\t//\tcout << i << endl;\n\t\tvector<int>w(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tw[j] = j;\n\t\t}\n\t\twhile (w.size() > 1) {\n\t\t\tint nx = xs.rand() % (w.size() - 1);\n\t\t\tif (v[w[nx]][w[nx + 1]])w.erase(w.begin() + nx + 1);\n\t\t\telse w.erase(w.begin() + nx);\n\t\t}\n\t\tcand.insert(w.front());\n\t}\n\t//for (auto i : cand)cout << i << endl;\n\tvector<int>w(N);\n\tqueue<int>Q;\n\tfor (auto i : cand) {\n\t\tw[i] = 1;\n\t\tQ.push(i);\n\t}\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < cn; i++) {\n\t\t\tif (w[i])continue;\n\t\t\tif (v[i][cn]) {\n\t\t\t\tbool flag = false;\n\t\t\t\tif (!i)flag = true;\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (v[i][j] && w[j])flag = true;\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tw[i] = 1;\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = cn + 1; i < N; i++) {\n\t\t\tif (w[i])continue;\n\t\t\tif (v[i][cn]) {\n\t\t\t\tbool flag = false;\n\t\t\t\tif (i==N-1)flag = true;\n\t\t\t\tfor (int j = i+1; j < N; j++) {\n\t\t\t\t\tif (v[i][j] && w[j])flag = true;\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tw[i] = 1;\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << accumulate(w.begin(), w.end(),0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\n#include <bitset>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_N   (2000)\nchar szInput[MAX_N + 1];\nstatic bitset<MAX_N + 1> s_abitMatchTbl[MAX_N + 1];\n\nint main(void)\n{\n    SDWORD lInput_n = inputSDWORD();\n    for (SDWORD lIdxI = 2; lIdxI <= lInput_n; lIdxI++) {\n        inputString(szInput);\n        for (SDWORD lIdxJ = 1; lIdxJ < lIdxI; lIdxJ++) {\n            if ('0' == szInput[lIdxJ - 1]) {\n                s_abitMatchTbl[lIdxJ][lIdxI] = true;\n            }\n        }\n    }\n\n    static bitset<MAX_N + 1> s_absDpL[MAX_N+1];\n    static bitset<MAX_N + 1> s_absDpR[MAX_N+1];\n\n    for (SDWORD lPos = 1; lPos <= lInput_n; lPos++) {\n        s_absDpL[lPos][lPos] = 1;\n        s_absDpR[lPos][lPos] = 1;\n    }\n    for (SDWORD lUpdateWidth = 1; lUpdateWidth <= lInput_n; lUpdateWidth++) {\n        for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n - lUpdateWidth; lUpdIdxL++) {\n            SDWORD lUpdIdxR = lUpdIdxL + lUpdateWidth;\n            /* LR */\n            bool bCondLR = false;\n            bool bCondLL = false;\n            bool bCondRR = false;\n            for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n                bool bDpL  = s_absDpL[lUpdIdxL][lUpdIdxM];\n                bool bDpML = s_absDpL[lUpdIdxM][lUpdIdxR];\n                bool bDpR  = s_absDpR[lUpdIdxL][lUpdIdxM];\n                bool bDpMR = s_absDpR[lUpdIdxM][lUpdIdxR];\n                bool bDp1R = s_absDpR[lUpdIdxM+1][lUpdIdxR];\n                if (bDpL && bDp1R) {\n                    bCondLR = true;\n                }\n                if (lUpdIdxM != lUpdIdxL) {\n                    if (bDpL && bDpML) {\n                        bCondLL = true;\n                    }\n                    if (bDpR && bDpMR) {\n                        bCondRR = true;\n                    }\n                }\n            }\n            if (bCondLR) {\n                if (s_abitMatchTbl[lUpdIdxL][lUpdIdxR]) {\n                    s_absDpL[lUpdIdxL].set(lUpdIdxR, true);\n                } else {\n                    s_absDpR[lUpdIdxL].set(lUpdIdxR, true);\n                }\n            }\n            if (bCondLL) {\n                s_absDpL[lUpdIdxL].set(lUpdIdxR, true);\n            }\n            if (bCondRR) {\n                s_absDpR[lUpdIdxL].set(lUpdIdxR, true);\n            }\n        }\n    }\n\n    /* count winners */\n    SDWORD lAns = 0;\n    for (SDWORD lMid = 1; lMid <= lInput_n; lMid++) {\n        if (s_absDpR[1][lMid] && s_absDpL[lMid][lInput_n]) {\n            lAns++;\n        }\n    }\n\n    printf(\"%d\\n\", lAns);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint kati[2002][2020]={};\nint dp[2020][2020]={};\n\nvector<int> ve[2020];\n\nbool solve(int x,int y){\n\n\tbool bo=0;\n\tif(x<y){\n\t\tint  it=lower_bound(ve[x].begin(),ve[x].end(),x+1)-ve[x].begin();\n\t\tfor(;;it++){\n\t\t\tif(ve[x][it]>y) break;\n\t\t\tif(dp[ve[x][it]][x+1]&& dp[ve[x][it]][y] ){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse{\n\t\tint  it=lower_bound(ve[x].begin(),ve[x].end(),y)-ve[x].begin();\n\t\tfor(;;it++){\n\t\t\tif(ve[x][it]>x-1) break;\n\t\t//for(int i=x-1;i>=y;i--){\n\t\t\tif(dp[ve[x][it]][x-1]&& dp[ve[x][it]][y] ){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdp[x][y]=bo;\n//\tcout<<x<<\" \"<<y<<\" \"<<bo<<endl;\n\treturn bo;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n int n;\n \tcin>>n;\n \tfor(int i=0;i<n;i++)dp[i][i]=1,kati[i][i]=1;\n \t\n \tfor(int i=1;i<n;i++){\n \t\tstring s;\n \t\tcin>>s;\n \t\t\n \t\tfor(int j=0;j<i;j++){\n \t\t\tif(s[j]=='1'){\n \t\t\t//\tif(rand()%2){\t\n \t\t\t\tkati[i][j]=1;\n \t\t\t}\n \t\t\telse kati[j][i]=1;\n \t\t}\n \t}\n \t\n \t\tfor(int i=0;i<n;i++){\n \t\t\tve[i].pb(-inf);\n \t\t\tfor(int j=0;j<n;j++){\n \t\t\t\tif(kati[i][j])ve[i].pb(j);\n \t\t\t}\n \t\t\tve[i].pb(inf);\n \t\t}\n \t\n \tint ans=0;\n \t\tfor(int d=1;d<n;d++)for(int i=0;i+d<n;i++){\n \t\t\tsolve(i,i+d);\n \t\t\tsolve(i+d,i);\n \t\t}\n \t\t\n \tfor(int i=0;i<n;i++)ans+=(dp[i][0]&& dp[i][n-1]);\n \tcout<<ans<<endl;\n \t\n \treturn 0;\n\n  }\n  \n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nbitset<2005> st[MAX_N];\nbitset<2005> up[MAX_N];\nbitset<2005> down[MAX_N];\n// i が j に勝つ\nbool win[MAX_N][MAX_N];\nint made[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    srep(i,1,n){\n        string s;\n        cin >> s;\n        rep(j,i){\n            win[i][j] = (s[j] == '1');\n            win[j][i] = !win[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            if(j == i) continue;\n            if(win[i][j]) down[i][j] = 1;\n            else up[i][j] = 1;\n        }\n    }\n    rep(i,n){\n        made[i] = i;\n        do {\n            if(!win[i][made[i]-1]){\n                break;\n            }\n        }while(--made[i] > 0);\n    }\n    st[0][0] = 1;\n    srep(i,1,n){\n        int lf = INF;\n        rrep(j,i){\n            if((st[j] & down[i]).count()) st[i][i] = 1;\n            if(win[i][j]){\n                cmn(lf, made[j]);\n                st[i] |= (st[j] & up[i]);\n            }else{\n                st[i] |= st[j];\n                if(lf > j){\n                    break;\n                }else{\n                    cmn(lf, made[j]);\n                }\n            }\n        }\n    }\n    cout << (int)st[n-1].count() << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 2022, inf = 1000111222;\n\nchar buf[max_n], a[max_n][max_n], dp[max_n][max_n][3];\n\nint n;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        scanf(\"%s\", buf);\n        for (int j = 0; j < i; ++j) {\n            a[i][j] = buf[j] - '0';\n            a[j][i] = 1 ^ a[i][j];\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        dp[i][i][0] = 1;\n        dp[i][i][1] = 1;\n        dp[i][i][2] = 1;\n    }\n    for (int len = 2; len <= n; ++len) {\n        for (int l = 0; l + len <= n; ++l) {\n            int r = l + len - 1;\n            if (len == 2) {\n                dp[l][r][2] = 1;\n            } else {\n                for (int i = l + 1; i < r && !dp[l][r][2]; ++i) {\n                    dp[l][r][2] |= dp[l][i][2] & dp[i][r][2];\n                }\n            }\n            if (a[l][r] && dp[l][r][2]) {\n                dp[l][r][0] = 1;\n            }\n            for (int i = l + 1; i < r && !dp[l][r][0]; ++i) {\n                if (a[l][i] && dp[l][i][0] && dp[i][r][0]) {\n                    dp[l][r][0] = 1;\n                }\n            }\n            if (a[r][l] && dp[l][r][2]) {\n                dp[l][r][1] = 1;\n            }\n            for (int i = l + 1; i < r && !dp[l][r][1]; ++i) {\n                if (a[r][i] && dp[l][i][1] && dp[i][r][1]) {\n                    dp[l][r][1] = 1;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        bool ok = dp[0][i][1] & dp[i][n - 1][0];\n        ans += ok;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbitset<2000> win[2001];\nbitset<2000> dp[2001][2001];\nsigned main() {\n    int N; cin >> N;\n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            int p = c - '0';\n            win[i][j] = p;\n            win[j][i] = 1 - p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[i][i][i] = true;\n    for(int d=0; d<N-1; d++) {\n        for(int l=0; l<N-d; l++) {\n            int r = l + d;\n            for(int k=0; k<N; k++) {\n                if(l > 0) {\n                    if(win[k][l-1]) dp[l-1][r][k] = dp[l-1][r][k] or dp[l][r][k];\n                    else dp[l-1][r][l-1] = dp[l-1][r][l-1] or dp[l][r][k];\n                }\n                if(r+1 < N) {\n                    if(win[k][r+1]) dp[l][r+1][k] = dp[l][r+1][k] or dp[l][r][k];\n                    else dp[l][r+1][r+1] = dp[l][r+1][r+1] or dp[l][r][k];\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += dp[0][N-1][i];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst long long int MOD = 1000003;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass XorShift {\n\tunsigned int x, y, z, w, t;\npublic:\n\tXorShift() {\n\t\tx = 133553533;\n\t\ty = 314867339;\n\t\tz = 664298413;\n\t\tw = 999999937;\n\t\tt = 0;\n\t}\n\tunsigned int rand() {\n\t\tt = x ^ (x << 11);\n\t\tx = y;\n\t\ty = z;\n\t\tz = w;\n\t\tw = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n\t\treturn w & 0x7fffffff;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>v(N, vector<int>(N));\n\tfor (int i = 1; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (s[j] == '1')v[i][j] = 1;\n\t\t\tv[j][i] = v[i][j] ^ 1;\n\t\t}\n\t}\n\tset<int>cand;\n\tXorShift xs;\n\tfor (int i = 0; i < 10000; i++) {\n\t//\tcout << i << endl;\n\t\tvector<int>w(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tw[j] = j;\n\t\t}\n\t\twhile (w.size() > 1) {\n\t\t\tint nx = xs.rand() % (w.size() - 1);\n\t\t\tif (v[w[nx]][w[nx + 1]])w.erase(w.begin() + nx + 1);\n\t\t\telse w.erase(w.begin() + nx);\n\t\t}\n\t\tcand.insert(w.front());\n\t}\n\t//for (auto i : cand)cout << i << endl;\n\tvector<int>w(N);\n\tqueue<int>Q;\n\tfor (auto i : cand) {\n\t\tw[i] = 1;\n\t\tQ.push(i);\n\t}\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < cn; i++) {\n\t\t\tif (w[i])continue;\n\t\t\tif (v[i][cn]) {\n\t\t\t\tbool flag = false;\n\t\t\t\tif (!i)flag = true;\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (v[i][j] && w[j])flag = true;\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tw[i] = 1;\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = cn + 1; i < N; i++) {\n\t\t\tif (w[i])continue;\n\t\t\tif (v[i][cn]) {\n\t\t\t\tbool flag = false;\n\t\t\t\tif (i==N-1)flag = true;\n\t\t\t\tfor (int j = i+1; j < N; j++) {\n\t\t\t\t\tif (v[i][j] && w[j])flag = true;\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tw[i] = 1;\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << accumulate(w.begin(), w.end(),0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    int n;\n    cin >> n;\n    vs a(n-1);\n    rep(i, n-1) cin >> a[i];\n    vector<vector<bool>> win(n, vector<bool>(n));\n    rep1(i, n-1) rep(j, i) {\n        win[i][j] = (a[i-1][j] == '1');\n        win[j][i] = !(a[i-1][j] == '1');\n    }\n    vector<bitset<2000>> dpl(n), dpr(n);\n    dpl[0][0] = dpr[0][0] = true;\n    rep1(i, n-1) dpl[i] = dpr[i] = (dpl[i-1] << 1);\n    rep1(i, n-1) rep(a, n-i) {\n        int b = a + i;\n        bool lok = false;\n        rep1(c, i-1) if (dpl[a][a+c] && dpl[a+c][b]) {\n            lok = true;\n            break;\n        }\n        if (!lok && win[a][b]) {\n            rep(c, i) if (dpl[a][a+c] && dpr[a+c+1][b]) {\n                lok = true;\n                break;\n            }\n        }\n        dpl[a][b] = lok;\n        bool rok = false;\n        rep1(c, i-1) if (dpr[b-c][b] && dpr[a][b-c]) {\n            rok = true;\n            break;\n        }\n        if (!rok && win[b][a]) {\n            rep(c, i) if (dpr[b-c][b] && dpl[a][b-c-1]) {\n                rok = true;\n                break;\n            }\n        }\n        dpr[a][b] = rok;\n    }\n    int ans = 0;\n    rep(i, n) if (dpr[0][i] && dpl[i][n-1]) ++ans;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst ll MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            char c;\n            cin>>c;\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;j+i<n;j++){\n            for(int k=j+1;k<=j+i;k++){\n                dp[j][j+i]|=A[j][k] & dp[k][j+1] & dp[k][j+i];\n            }\n        }\n        for(int j=i;j<n;j++){\n            for(int k=j-i;k<j;k++){\n                dp[j][j-i]|=A[j][k] & dp[k][j-1] & dp[k][j-i];\n            }\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[i][0] && dp[i][n-1]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint kati[2002][2020]={};\nint dp[2020][2020]={};\n\nset<int> se[2020];\n\nbool solve(int x,int y){\n\t\n\tbool bo=0;\n\t//vector<int> dame;\n\tif(x<y){\n\t\tauto  it=se[x].lower_bound(x+1);\n\t\tfor(;;it++){\n\t\t\tif(*it>y) break;\n\t\t\tif( dp[*it][y] ){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\telse{\n\t\t//int  it=lower_bound(ve[x].begin(),ve[x].end(),y)-ve[x].begin();\n\t\tauto  it=se[x].lower_bound(y);\n\t\tfor(;;it++){\n\t\t\tif(*it>x-1) break;\n\t\t//for(int i=x-1;i>=y;i--){\n\t\t\tif(dp[*it][y] ){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\t\n\t\tif(x+1<y){\n\t\t\tif(bo==0){\n\t\t\t\tse[y-1].erase(x);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if(y+1<x){\n\t\t\tif(bo==0){\n\t\t\t\tse[y+1].erase(x);\n\t\t\t}\n\t\t}\n\tdp[x][y]=bo;\n//\tcout<<x<<\" \"<<y<<\" \"<<bo<<endl;\n\treturn bo;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n int n;\n \tcin>>n;\n \tfor(int i=0;i<n;i++)dp[i][i]=1,kati[i][i]=1;\n \t\n \tfor(int i=1;i<n;i++){\n \t\tstring s;\n \t\tcin>>s;\n \t\t\n \t\tfor(int j=0;j<i;j++){\n \t\t\tif(s[j]=='1'){\n \t\t\t//\tif(rand()%2){\t\n \t\t\t\tkati[i][j]=1;\n \t\t\t}\n \t\t\telse kati[j][i]=1;\n \t\t}\n \t}\n \t\n \t\tfor(int i=0;i<n;i++){\n \t\t\tse[i].insert(-inf);\n \t\t\tfor(int j=0;j<n;j++){\n \t\t\t\tif(kati[i][j])se[i].insert(j);\n \t\t\t}\n \t\t\tse[i].insert(inf);\n \t\t}\n \t\n \tint ans=0;\n \t\tfor(int d=1;d<n;d++)for(int i=0;i+d<n;i++){\n \t\t\tsolve(i,i+d);\n \t\t\tsolve(i+d,i);\n \t\t}\n \t\t\n \tfor(int i=0;i<n;i++)ans+=(dp[i][0]&& dp[i][n-1]);\n \tcout<<ans<<endl;\n \t\n \treturn 0;\n\n  }\n  \n\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n    ost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n    ost<<\"{\";\n    for(int i=0;i<v.size();i++){\n        if(i)ost<<\",\";\n        ost<<v[i];\n    }\n    ost<<\"}\";\n    return ost;\n}\n\nusing bs=bitset<2000>;\n\nint N;\n// r l            l r\nbs leftwin[2000],rightwin[2000];\nbs G[2000];\nsigned main(){\n    cin>>N;\n    for(int i=1;i<N;i++){\n        string s;cin>>s;\n        for(int j=0;j<i;j++){\n            if(s[j]=='1')G[i][j]=1;\n            else G[j][i]=1;\n        }\n    }\n\n\n    for(int i=0;i<N;i++)leftwin[i][i]=rightwin[i][i]=1;\n    for(int len=2;len<=N;len++){\n        for(int i=0;i+len<=N;i++){\n            int j=i+len-1;\n\n            if((rightwin[i+1]&leftwin[j]&G[i]).count())leftwin[j][i]=1;\n            if((rightwin[i]&leftwin[j-1]&G[j]).count())rightwin[i][j]=1;\n        }\n    }\n\n    cout<<(rightwin[0]&leftwin[N-1]).count()<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef bitset<2001> b100;\n\nb100 a[2222];\nint win[2222][2222];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0); \n\tint n; cin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tstring s; cin>>s;\n\t\tfor(int j=0;j<s.length();j++)\n\t\t{\n\t\t\tif(s[j]=='1')\n\t\t\t{\n\t\t\t\twin[i][j]=1; win[j][i]=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twin[j][i]=1; win[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\ta[0].set(0,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\t//can i win?\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tif(win[i][j]&&a[i-1][j]) a[i].set(i,1);\n\t\t}\n\t\t//can others win?\n\t\tb100 cur; cur.set(i,1);\n\t\tint idx=-1;\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t{\n\t\t\tif(win[j][i])\n\t\t\t{\n\t\t\t\tidx=j; break;\n\t\t\t}\n\t\t}\n\t\tif(idx==-1)\n\t\t{\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=idx;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(a[idx][j]) a[i].set(j,1);\n\t\t\t}\n\t\t\tfor(int j=i-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(a[j][j]&&win[j][i]) a[i].set(j,1);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tcerr<<a[i][j];\n\t\t}\n\t\tcerr<<'\\n';\n\t\t*/\n\t}\n\tcout<<a[n-1].count()<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n[m-solutions2019] F - Random Tournament\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n\nconst int MAX_N = 2000;\n\nint N;\nbool A[MAX_N][MAX_N];\n\nbool dpl[MAX_N][MAX_N], dpr[MAX_N][MAX_N];\n\nll solve() {\n    for (int i = 0; i < N; i++) {\n        dpl[i][i] = dpr[i][i] = true;\n    }\n    for (int l = 1; l < N; l++) {\n        for (int i = 0; i + l < N; i++) {\n            int j = i + l;\n            for (int k = i + 1; k <= j; k++) {\n                dpl[i][j] =\n                    dpl[i][j] || (A[i][k] && dpl[k][j] && dpr[i + 1][k]);\n            }\n        }\n        for (int j = l; j < N; j++) {\n            int i = j - l;\n            for (int k = i; k < j; k++) {\n                dpr[i][j] =\n                    dpr[i][j] || (A[j][k] && dpr[i][k] && dpl[k][j - 1]);\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < N; i++) {\n        if (dpr[0][i] && dpl[i][N - 1]) {\n            ans++;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cin >> N;\n    for (int i = 1; i < N; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < i; j++) {\n            A[i][j] = s[j] == '1';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<int,ii>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 1000000005\n#define MOD 1000000007 \n#define N 2005\n#define M 1000003\n#define LOG 19\n#define KOK 250\n#define EPS 0.0000001\nusing namespace std;\n\nint n;\nchar s[N];\nbool re[N][N],rb[N][N],vb[N][N],ve[N][N];\nvector<int> v[N];\n\nbool beg(int bas,int son);\nbool en(int bas,int son);\n\nbool en(int bas,int son) {\n\n\tif(bas==son) return 1;\n\n\tif(bas>son) return 0;\n\n\tif(ve[bas][son]) return re[bas][son];\n\n\tve[bas][son]=1;\n\n\tfor(int i:v[son]) {\n\n\t\tif(en(bas,i) && beg(i,son-1)) {\n\t\t\n\t\t\tre[bas][son]=1;\n\n\t\t\tbreak ;\n\t\t\n\t\t}\n\n\t}\n\n\treturn re[bas][son];\n\n}\n\nbool beg(int bas,int son) {\n\n\tif(bas==son) return 1;\n\n\tif(bas>son) return 0;\n\n\tif(vb[bas][son]) return rb[bas][son];\n\n\tvb[bas][son]=1;\n\n\tfor(int i:v[bas]) {\n\n\t\tif(en(bas+1,i) && beg(i,son)) {\n\t\t\n\t\t\trb[bas][son]=1;\n\n\t\t\tbreak ;\n\t\t\n\t\t}\n\n\t}\n\n\treturn rb[bas][son];\n\n}\n\nint main() {\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i=2;i<=n;i++) {\n\n\t\tscanf(\"%s\",s+1);\n\n\t\tfor(int j=1;j<=i-1;j++) {\n\n\t\t\tif(s[j]=='1') {\n\n\t\t\t\tv[i].pb(j);\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tv[j].pb(i);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint ans=0;\n\n\tfor(int i=1;i<=n;i++) {\n\n\t\tif(beg(i,n) && en(1,i)) ans++;\n\n\t}\n\n\tprintf(\"%d\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1000003;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nconst int MAX_N = 2000;\n\nbool winL[MAX_N][MAX_N];\nbool winR[MAX_N][MAX_N];\nbool sumP[MAX_N][MAX_N];\n\n\nint main() {\n  int N;\n  cin >> N;\n  auto mat = make_v< int >(N, N);\n  for(int i = 1; i < N; i++) {\n    string s;\n    cin >> s;\n    for(int j = 0; j < i; j++) {\n      int x = (int) s[j] - '0';\n      mat[i][j] = x;\n      mat[j][i] = 1 - x;\n    }\n  }\n\n  for(int i = N - 1; i >= 0; i--) {\n    winL[i][i] = winR[i][i] = 1;\n    for(int j = i + 1; j < N; j++) {\n      sumP[i][j] = 0;\n      for(int p = i; p < j; p++) {\n        sumP[i][j] += winL[i][p] * winR[p + 1][j];\n        if(sumP[i][j]) break;\n      }\n      winL[i][j] = winR[i][j] = 0;\n      {  // winL\n        for(int k = i + 1; k <= j; k++) {\n          bool prob = mat[i][k];\n          winL[i][j] += prob * winL[k][j] * sumP[i][k];\n          if(winL[i][j]) break;\n        }\n      }\n      {  // winR\n        for(int k = i; k < j; k++) {\n          bool prob = mat[j][k];\n          winR[i][j] += prob * winR[i][k] * sumP[k][j];\n          if(winR[i][j]) break;\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    bool ans = winR[0][i] * winL[i][N - 1];\n    ret += ans > 0;\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr int Nmax = 2002;\nint main()\n{\n    int N;\n    cin >> N;\n    vector<bitset<Nmax>> A(N + 2, bitset<Nmax>());\n    FOR(i, 1, N)\n    {\n        string S;\n        cin >> S;\n        REP(j, i)\n        {\n            A[i + 1][j + 1] = S[j] - '0';\n            A[j + 1][i + 1] = !A[i + 1][j + 1];\n        }\n    }\n\n    vector<bitset<Nmax>> dp(N + 2, bitset<Nmax>()); // (l, r)\n    REP(i, N + 1) dp[i][i + 1] = 1;\n\n    FOR(d, 2, N + 1) REP(l, N + 2 - d)\n    {\n        FOR(c, l + 1, l + d) if (dp[l][c] and dp[c][l + d] and (A[l][c] or A[l + d][c]))\n        {\n            dp[l][l + d] = 1;\n            break;\n        }\n    }\n\n    int ret = 0;\n    // dbg(dp);\n    FOR(i, 1, N + 1) ret += (dp[0][i] and dp[i][N + 1]);\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\n#include <bitset>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_N   (2000)\nchar szInput[MAX_N + 1];\nstatic bitset<MAX_N + 1> s_abitMatchTbl[MAX_N + 1];\n\nint main(void)\n{\n    SDWORD lInput_n = inputSDWORD();\n    for (SDWORD lIdxI = 2; lIdxI <= lInput_n; lIdxI++) {\n        inputString(szInput);\n        for (SDWORD lIdxJ = 1; lIdxJ < lIdxI; lIdxJ++) {\n            if ('0' == szInput[lIdxJ - 1]) {\n                s_abitMatchTbl[lIdxJ][lIdxI] = true;\n            }\n        }\n    }\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalMatchTbl[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    static bitset<MAX_N + 1> s_absDpL[MAX_N+1];\n    static bitset<MAX_N + 1> s_absDpR[MAX_N+1];\n\n    for (SDWORD lUpdateWidth = 0; lUpdateWidth <= lInput_n; lUpdateWidth++) {\n        for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n - lUpdateWidth; lUpdIdxL++) {\n            SDWORD lUpdIdxR = lUpdIdxL + lUpdateWidth;\n            if (lUpdIdxL == lUpdIdxR) {\n                s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n            } else {\n                /* LR */\n                bool bCondLR = false;\n                bool bCondLL = false;\n                bool bCondRR = false;\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n                    if ((s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (s_absDpR[lUpdIdxM+1][lUpdIdxR])) {\n                        bCondLR = true;\n                    }\n                    if (lUpdIdxM != lUpdIdxL) {\n                        if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                            && (1 == s_absDpL[lUpdIdxM][lUpdIdxR])) {\n                            bCondLL = true;\n                        }\n                        if ((1 == s_absDpR[lUpdIdxL][lUpdIdxM])\n                            && (1 == s_absDpR[lUpdIdxM][lUpdIdxR])) {\n                            bCondRR = true;\n                        }\n                    }\n                }\n\n                if (bCondLR) {\n                    if (s_abitMatchTbl[lUpdIdxL][lUpdIdxR]) {\n                        s_absDpL[lUpdIdxL][lUpdIdxR] = true;\n                    } else {\n                        s_absDpR[lUpdIdxL][lUpdIdxR] = true;\n                    }\n                }\n                if (bCondLL) {\n                    s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                }\n                if (bCondRR) {\n                    s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                }\n            }\n        }\n    }\n\n    /* count winners */\n    SDWORD lAns = 0;\n    for (SDWORD lMid = 1; lMid <= lInput_n; lMid++) {\n        if (s_absDpR[1][lMid] && s_absDpL[lMid][lInput_n]) {\n            lAns++;\n        }\n    }\n\n    printf(\"%d\\n\", lAns);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// // TLE版.\n// // C++ (GCC 9.2.1)\n// // 解き直し.\n// // https://img.atcoder.jp/m-solutions2019/editorial.pdf\n// #include <bits/stdc++.h>\n// using namespace std;\n// #define repex(i, a, b, c) for(int i = a; i < b; i += c)\n// #define repx(i, a, b) repex(i, a, b, 1)\n// #define rep(i, n) repx(i, 0, n)\n// #define repr(i, a, b) for(int i = a; i >= b; i--)\n// bool dpl[2020][2020], dpr[2020][2020];\n// int A[2020][2020];\n// \n// int main(){\n//     \n//     // 1. 入力情報.\n//     int N, a;\n//     scanf(\"%d\", &N);\n//     repx(i, 2, N + 1){\n//         char c[2020];\n//         scanf(\"%s\", c);\n//         int l = strlen(c);\n//         repx(j, 1, l + 1){\n//             A[i][j] = c[j - 1] - '0';\n//             A[j][i] = 1 - A[i][j];\n//         }\n//     }\n//     \n//     // 2. 初期化.\n//     rep(i, 2020) dpl[i][i] = true, dpr[i][i] = true;\n//     \n//     // 3. dp更新(解説通り).\n//     // -> テストケース(073.txt) の N = 2000 だと, 4205[ms] かかったので, 高速化が必要.\n//     repx(d, 1, N){\n//         repx(i, 1, N){\n//             // 2-1. (i, j) の ペア を 抽出.\n//             int j = i + d;\n//             if(j > N) break;\n//             \n//             // 2-2. dpl更新.\n//             repx(k, i + 1, j + 1){\n//                 if(A[i][k] && dpl[k][j] && dpr[k][i + 1]){\n//                     dpl[i][j] = true;\n//                     break;\n//                 }\n//             }\n//             \n//             // 2-3. dpr更新.\n//             // ※ 解説上 の A[k][i] から, A[j][k] に 訂正.\n//             repx(k, i, j){\n//                 if(A[j][k] && dpl[k][j - 1] && dpr[k][i]){\n//                     dpr[j][i] = true;\n//                     break;\n//                 }\n//             }\n//         }\n//     }\n//     // repx(i, 1, N + 1){\n//     //     repx(j, 1, N + 1) printf(\"%d \", A[i][j]);\n//     //     puts(\"\");\n//     // }\n//     // repx(i, 1, N + 1){\n//     //     repx(j, 1, N + 1) printf(\"%d \", dpl[i][j]);\n//     //     puts(\"\");\n//     // }\n//     // repx(i, 1, N + 1){\n//     //     repx(j, 1, N + 1) printf(\"%d \", dpr[i][j]);\n//     //     puts(\"\");\n//     // }\n//     \n//     // 4. 優勝する可能性がある人の人数は？\n//     int ans = 0;\n//     repx(i, 1, N + 1) if(dpl[i][N] && dpr[i][1]) ans++;\n//     \n//     // 5. 出力.\n//     printf(\"%d\\n\", ans);\n//     return 0;\n//     \n// }\n// ※※※ 解答不能 ※※※\n// I9992147氏.\n// https://atcoder.jp/contests/m-solutions2019/submissions/9888159\n#include <bits/stdc++.h>\nusing namespace std;\n#define repex(i, a, b, c) for(int i = a; i < b; i += c)\n#define repx(i, a, b) repex(i, a, b, 1)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\n\nint main(){\n    \n    // 1. 入力情報.\n    int N;\n    scanf(\"%d\", &N);\n    vector<bitset<2020>> v(N);\n    repx(i, 1, N){\n        char c[2020];\n        scanf(\"%s\", c);\n        rep(j, i){\n            if(c[j] == '1') v[i][j] = 1;\n            else            v[j][i] = 1;\n        }\n    }\n    \n    // 2. dp更新.\n    vector<bitset<2020>> l(N), r(N);\n    rep(i, N) l[i][i] = r[i][i] = 1;\n    repx(i, 1, N){\n        rep(j, N - i){\n            l[i + j][j] = (l[i + j] & r[j + 1]     & v[j]).any();\n            r[j][i + j] = (r[j]     & l[i + j - 1] & v[i + j]).any();\n        }\n    }\n    \n    // 3. 出力.\n    printf(\"%d\\n\", (r[0] & l[N - 1]).count());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cmath>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define debug(x) cerr<<#x<<'='<<x<<endl\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();int f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\n\nint n;\n\nbitset<2020> L[2020],R[2020],C[2020];\nchar def[2020][2020];\n\nint main() {\n\tread(n);\n\tfor(int i=2;i<=n;i++){\n\t\tcin>>(def[i]+1);\n\t\tfor(int j=1;j<i;j++){\n\t\t\tif(def[i][j] == '0'){\n\t\t\t\tC[j][i] = 1;\n\t\t\t}else{\n\t\t\t\tC[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tfor(int i=1;i<=n;i++)L[i][i] = R[i][i] = 1;\n\n\tfor(int len = 1;len<n;len++){\n\t\tfor(int l = 1;l+len-1<=n;l++){\n\t\t\tint r = l+len-1;\n\t\t\tif(l>1){\n\t\t\t\t\n\t\t\t\tint c = (L[r]&R[l]&C[l-1])._Find_next(0);\n\t\t\t\tif(c<=2010) L[r][l-1] = 1;\n\t\t\t}\n\t\t\tif(r<n){\n\t\t\t\tint c = (L[r]&R[l]&C[r+1])._Find_next(0);\n\t\t\t\tif(c<=2010) R[l][r+1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(L[n][i] && R[1][i]){\n\t\t\tans+=1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\n\nstruct P\n{\n\tint A, B;\n\tP(int a, int b) : A(a), B(b) {}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<bool> m(N * N);\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor (int j = 0; j < i; j++) m[N * j + i] = !(m[N * i + j] = S[j] == '1');\n\t}\n\tdeque<bool> dp(N * N, false);\n\tfor (int i = 0; i < N - 1; i++) dp[N * i + i + 1] = true;\n\tfor (int l = 2; l < N; l++)\n\t\tfor (int i = 0; i + l < N; i++)\n\t\t{\n\t\t\tint p = N * i + i + l;\n\t\t\tfor (int k = i + 1, q = N * i + k, r = N * (i + l) + k, s = N * k + i + l; k < i + l; k++, q++, r++, s += N)\n\t\t\t\tif (dp[p] |= dp[q] & (m[q] | m[r]) & dp[s]) break;\n\t\t}\n\tdeque<bool> dpL(N, false);\n\tdpL[N - 1] = true;\n\tfor (int i = N - 2; i >= 0; i--)\n\t\tfor (int j = i + 1; j < N; j++) dpL[i] |= m[N * i + j] & dpL[j] & dp[N * i + j];\n\tdeque<bool> dpR(N, false);\n\tdpR[0] = true;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 0; j < i; j++) dpR[i] |= m[N * i + j] & dpR[j] & dp[N * j + i];\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tif (dpL[i] & dpR[i]) ans++;\n\tcout << ans << endl;\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing _loop_int = int;\n#define REP(i,n) for(_loop_int i=0; i<(_loop_int)(n); i++)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a); i<(_loop_int)(b); i++)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1; i>=(_loop_int)(a); i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n#define ALL(v) (v).begin(),(v).end()\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define DEBUG_VEC(v) cerr<<#v<<\": \";REP(__i,(v).size())cerr<<((v)[__i])<<\", \";cerr<<endl\n\nconst ll MOD = 1000003ll;\n\n// ? https://en.wikipedia.org/wiki/Arithmetic_progression#Product\n\nll fact[MOD];\nll ifact[MOD];\nll modpow(ll a,ll b){\n    ll r=1;\n    while(b){\n        if(b&1)r=r*a%MOD;\n        a=a*a%MOD;\n        b>>=1;\n    }\n    return r;\n}\nll modinv(ll a){\n    return modpow(a,MOD-2);\n}\n\nint main(){\n    int q;\n    scanf(\"%d\",&q);\n    // precalc\n    fact[0] = 1;\n    FOR(i,1,MOD)fact[i]=fact[i-1]*i%MOD;\n    ifact[MOD-1] = modinv(fact[MOD-1]);\n    FORR(i,1,MOD)ifact[i-1]=ifact[i]*i%MOD;\n    // query\n    while(q--){\n        ll n,a,d;\n        scanf(\"%lld%lld%lld\",&a,&d,&n);\n        ll iv = a*modinv(d)%MOD;\n        if(d==0){\n            printf(\"%lld\\n\",modpow(a,n));\n            continue;\n        }else if(a==0 || iv+n-1>=MOD){\n            puts(\"0\");\n            continue;\n        }\n        // calc\n        ll ans = modpow(d,n) * fact[iv+n-1] % MOD * ifact[iv-1] % MOD;\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\"%c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    //vector<vector<bool>> L(N, vector<bool>(N));\n    //vector<vector<bool>> R(N, vector<bool>(N));\n    static bool L[2048][2048];\n    static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<N; j++)\n                    b |= a[j] & l[j] & r[j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=0; j<i; j++)\n                    b |= a[j] & l[j] & r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint kati[2002][2020]={};\nint dp[2020][2020]={};\n\nset<int> se[2020];\n\nbool solve(int x,int y){\n\n\tbool bo=0;\n\tvector<int> dame;\n\tif(x<y){\n\t\tauto  it=se[x].lower_bound(x+1);\n\t\tfor(;;it++){\n\t\t\tif(*it>y) break;\n\t\t\tif( dp[*it][y] ){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdame.pb(*it);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse{\n\t\t//int  it=lower_bound(ve[x].begin(),ve[x].end(),y)-ve[x].begin();\n\t\tauto  it=se[x].lower_bound(y);\n\t\tfor(;;it++){\n\t\t\tif(*it>x-1) break;\n\t\t//for(int i=x-1;i>=y;i--){\n\t\t\tif(dp[*it][y] ){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdame.pb(*it);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\tif(!bo){\n\t\t\n\t\t\tfor(auto v:dame){\n\t\t\t\tse[x].erase(v);\n\t\t\t}\n\t\t}\n\tdp[x][y]=bo;\n//\tcout<<x<<\" \"<<y<<\" \"<<bo<<endl;\n\treturn bo;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n int n;\n \tcin>>n;\n \tfor(int i=0;i<n;i++)dp[i][i]=1,kati[i][i]=1;\n \t\n \tfor(int i=1;i<n;i++){\n \t\tstring s;\n \t\tcin>>s;\n \t\t\n \t\tfor(int j=0;j<i;j++){\n \t\t\tif(s[j]=='1'){\n \t\t\t//\tif(rand()%2){\t\n \t\t\t\tkati[i][j]=1;\n \t\t\t}\n \t\t\telse kati[j][i]=1;\n \t\t}\n \t}\n \t\n \t\tfor(int i=0;i<n;i++){\n \t\t\tse[i].insert(-inf);\n \t\t\tfor(int j=0;j<n;j++){\n \t\t\t\tif(kati[i][j])se[i].insert(j);\n \t\t\t}\n \t\t\tse[i].insert(inf);\n \t\t}\n \t\n \tint ans=0;\n \t\tfor(int d=1;d<n;d++)for(int i=0;i+d<n;i++){\n \t\t\tsolve(i,i+d);\n \t\t\tsolve(i+d,i);\n \t\t}\n \t\t\n \tfor(int i=0;i<n;i++)ans+=(dp[i][0]&& dp[i][n-1]);\n \tcout<<ans<<endl;\n \t\n \treturn 0;\n\n  }\n  \n\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2345;\n\nint n;\nbitset<N> beat[N], ll[N], rr[N];\nbool dp_l[N][N], dp_r[N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 2; i <= n; ++i) {\n    string s;\n    cin >> s;\n    for (int j = 1; j < i; ++j) {\n      if (s[j - 1] == '1') {\n        beat[i][j] = true;\n      } else {\n        beat[j][i] = true;\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    dp_l[i][i] = dp_r[i][i] = ll[i][i] = rr[i][i] = true;\n  }\n  for (int i = 2; i <= n; ++i) {\n    bitset<N> seg;\n    for (int j = 0; j < i; ++j) {\n      seg[j] = true;\n    }\n    for (int j = 1; j + i - 1 <= n; ++j) {\n      int x = j, y = j + i - 1;\n      seg[x - 1] = false;\n      seg[y] = true;\n      bitset<N> result = beat[x] & rr[x + 1] & ll[y] & seg;\n      if (result.count()) {\n        dp_l[x][y] = ll[y][x] = true;\n      }\n      result = beat[y] & ll[y - 1] & rr[x] & seg;\n      if (result.count()) {\n        dp_r[x][y] = rr[x][y] = true;\n      }\n    }\n  }\n  int answer = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (dp_r[1][i] && dp_l[i][n]) {\n      ++answer;\n    }\n  }\n  cout << answer << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 2005;\n\nint n;\nchar tmp[N];\nint a[N][N];\nbool f[N][N], g[N][N];\n\nint main() {\n\tread(n);\n\tfor (int i = 2; i <= n; ++i) {\n\t\treadStr(tmp + 1);\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\ta[i][j] = tmp[j] ^ '0';\n\t\t\ta[j][i] = a[i][j] ^ 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tf[i][i] = g[i][i] = 1;\n\t}\n\tfor (int len = 2; len <= n; ++len) {\n\t\tfor (int l = 1; l <= n - len + 1; ++l) {\n\t\t\tint r = l + len - 1;\n\t\t\tf[l][r] = 0;\n\t\t\tfor (int k = l + 1; k <= r; ++k) {\n\t\t\t\tf[l][r] |= g[l + 1][k] & f[k][r] & a[l][k];\n\t\t\t}\n\t\t\tg[l][r] = 0;\n\t\t\tfor (int k = l; k < r; ++k) {\n\t\t\t\tg[l][r] |= g[l][k] & f[k][r - 1] & a[r][k];\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans += g[1][i] & f[i][n];\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e3+10;\n\nint a[MAXN][MAXN];\nint dpl[MAXN][MAXN],dpr[MAXN][MAXN];\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i = 2;i<=n;i++)\n    {\n        getchar();\n        for (int j = 1;j<i;j++)\n        {\n            a[j][i] = !(a[i][j] = getchar() - 48);\n        }\n        dpl[i][i] = dpr[i][i] = 1;\n    }\n    dpr[1][1] = dpl[1][1] = 1;\n    // for (int i = 1;i<=n-1;i++)  dpl[i][i+1] = a[i][i+1];\n    // for (int i = n;i>=2;i--)    dpr[i][i-1] = a[i][i-1];\n    for (int k = 1;k<=n-1;k++)\n    {\n        for (int i = 1;i<=n-k;i++)\n        {\n            for (int j = i;j<=i+k;j++)\n            {\n                if (j != i && a[i][j] && dpl[j][i + k] && dpr[j][i+1])\n                    dpl[i][i+k] = 1;\n                if (j != i + k && a[i+k][j] && dpl[j][i+k-1] && dpr[j][i])\n                    dpr[i+k][i] = 1;\n            }\n        }\n    }\n    int ans = 0;\n    if (dpl[1][n]) ans++;\n    if (dpr[n][1]) ans++;\n    for (int i = 2;i<=n-1;i++)\n    if (dpl[i][n] && dpr[i][1]) ans++;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nbitset<2020> A[2020];\nbitset<2020> winL[2020],winR[2020];\nbitset<2020> dp[2020];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(j=1;j<N;j++) {\n\t\tcin>>s;\n\t\tFOR(i,j) {\n\t\t\tA[j][i]=s[i]=='1';\n\t\t\tA[i][j]=s[i]=='0';\n\t\t}\n\t}\n\t\n\tFOR(x,N) winL[x][x]=winR[x][x]=1;\n\tfor(l=2;l<=N;l++) {\n\t\tfor(x=0;x+l<=N;x++) {\n\t\t\ty=x+l-1;\n\t\t\tfor(i=x;i<y && dp[x][y]==0;i++) if(winL[x][i]&winR[y][i+1]) dp[x][y]=1;\n\t\t\tdp[y][x]=dp[x][y];\n\t\t\tfor(i=x+1;i<=y && winL[x][y]==0;i++) if(A[x][i] & dp[x][i] & winL[i][y]) winL[x][y]=1;\n\t\t\tfor(i=x;i<=y-1 && winR[y][x]==0;i++) if(A[y][i] & dp[y][i] & winR[i][x]) winR[y][x]=1;\n\t\t}\n\t}\n\tint ret=0;\n\tFOR(i,N) ret+=winR[i][0]&winL[i][N-1];\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\nconst int MAX = 2e3 + 41;\n//const int MAX = 10;\n\nint n;\nbitset<MAX> pref[MAX], suf[MAX], win[MAX], can[MAX];\nint a[MAX][MAX];\n\nvoid solve () {\n\tfi(0, n - 1) {\n\t\tfj(0, n - 1) {\n\t\t\tif (a[i][j]) win[i].set(j);\n\t\t}\n\t}\n//\tfi(0, n - 1) dbg(win[i]);\n//\tdbg(win[0]);\n\tfi(0, n - 1) {\n\t\tpref[i].set(i);\n\t\tsuf[i].set(i);\n\t\tcan[i].set(i);\n\t\tfdj(i - 1, 0) {\n\t\t\tif (a[i][j]) {\t\t\t\t\n\t\t\t\tif ( ( (suf[j] << 1) & pref[i]).any() ) {\n\t\t\t\t\tpref[i] |= pref[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfdj(i - 1, 0) {\n\t\t\tif ( (pref[i] & (suf[j] << 1)).any() ) {\n\t\t\t\tcan[j].set(i);\n\t\t\t}\n\t\t}\n\t\tbitset<MAX> sufwin;\n\t\tsufwin.reset();\n\t\tsufwin.set(i);\n\t\tfdj(i - 1, 0) {\n\t\t\tif ( (sufwin & win[j] & can[j]).any() ) {\n\t\t\t\tsufwin.set(j);\n\t\t\t\tsuf[j].set(i);\n\t\t\t}\n\t\t}\n/*\n\t\tfj(0, i) {\n\t\t\tdbg(pref[j]);\n\t\t\tdbg(suf[j]);\n\t\t}\n\t\terr(\"after i = %d\\n\", i);\n*/\n\t}\n\tvi answer;\n\tfi(0, n - 1) {\n\t\tif (pref[i].test(0) && suf[i].test(n - 1)) {\n\t\t\tanswer.pb(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sz(answer));\n//\tdbg(answer);\t\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\t\n\tscanf(\"%d\", &n);\n\tfi(1, n - 1) {\n\t\tchar str[MAX];\n\t\tscanf(\"%s\", str);\t\t\n\t\tfj(0, i - 1) {\t\t\t\n\t\t\ta[i][j] = str[j] - '0';\n\t\t\ta[j][i] = 1 - a[i][j];\n\t\t}\n\t}\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 2010;\nbool wl[maxn][maxn], wr[maxn][maxn];\nbitset<maxn> bwl[maxn], bwr[maxn];\nbitset<maxn> can[maxn];\nbool e[maxn][maxn];\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 1; i < N; ++i) {\n\t\tstring s; cin >> s;\n\t\trep(j, i) {\n\t\t\te[i][j] = (s[j] == '1');\n\t\t\te[j][i] = !e[i][j];\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\trep(j, N) if (e[i][j]) {\n\t\t\tcan[i].set(j);\n\t\t}\n\t}\n\n\tfor (int l = N-1; l >= 0; --l) {\n\t\twl[l][l] = wr[l][l] = 1;\n\t\tbwl[l].set(l, 1);\n\t\tbwr[l].set(l, 1);\n\n\t\tfor (int r = l+1; r < N; ++r) {\n\t\t\tbitset<maxn> u = can[r] & bwr[l] & bwl[r-1];\n\t\t\t/*\n\t\t\tif (u.any()) {\n\t\t\t\tputs(\"wo\");\n\n\t\t\t\tcout << l << \" \" << r << endl;\n\t\t\t\tcout << u << endl;\n\t\t\t}*/\n\n\t\t\tu >>= l;\n\t\t\tu <<= l;\n\t\t\tu <<= (maxn-r);\n\t\t\tif (u.any()) {\n\t\t\t\twr[l][r] = 1;\n\t\t\t\tbwr[l].set(r);\n\t\t\t}\n\n\t\t\tbitset<maxn> v = can[l] & bwr[l+1] & bwl[r];\n\t\t\t/*\n\t\t\tbool f = 0;\n\t\t\tif (v.any()) {\n\t\t\t\tputs(\"wo2\");\n\t\t\t\tf = 1;\n\t\t\t\tcout << l << \" \" << r << endl;\n\t\t\t\tcout << v << endl;\n\t\t\t}*/\n\t\t\tv >>= (l+1);\n\t\t\tv <<= (l+1);\n\t\t\tv <<= (maxn-r-1);\n\n\t\t\tif (v.any()) {\n\t\t\t\twl[l][r] = 1;\n\t\t\t\tbwl[r].set(l);\n\t\t\t}\n\t\t\t/*\n\n\t\t\tfor (int m = l; m < r; ++m) {\n\t\t\t\t\n\t\t\t\tif (e[r][m] && wr[l][m] && wl[m][r-1]) {\n\t\t\t\t\twr[l][r] = 1;\n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = l+1; m <= r; ++m) {\n\n\t\t\t\tif (e[l][m] && wr[l+1][m] && wl[m][r]) {\n\t\t\t\t\twl[l][r] = 1;\n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t}*/\t\t\n\t\t}\n\t}\n/*\n\tputs(\"l\");\n\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tcout << wl[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tputs(\"r\");\n\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tcout << wr[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\n\tint ans = 0;\n\trep(i, N) if (wl[i][N-1] && wr[0][i]) {\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst long long int MOD = 1000003;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass XorShift {\n\tunsigned int x, y, z, w, t;\npublic:\n\tXorShift() {\n\t\tx = 133553533;\n\t\ty = 314867339;\n\t\tz = 664298413;\n\t\tw = 999999937;\n\t\tt = 0;\n\t}\n\tunsigned int rand() {\n\t\tt = x ^ (x << 11);\n\t\tx = y;\n\t\ty = z;\n\t\tz = w;\n\t\tw = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n\t\treturn w & 0x7fffffff;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>v(N, vector<int>(N));\n\tfor (int i = 1; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (s[j] == '1')v[i][j] = 1;\n\t\t\tv[j][i] = v[i][j] ^ 1;\n\t\t}\n\t}\n\tset<int>cand;\n\tXorShift xs;\n\tfor (int i = 0; i < 8000; i++) {\n\t//\tcout << i << endl;\n\t\tvector<int>w(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tw[j] = j;\n\t\t}\n\t\twhile (w.size() > 1) {\n\t\t\tint nx = xs.rand() % (w.size() - 1);\n\t\t\tif (v[w[nx]][w[nx + 1]])w.erase(w.begin() + nx + 1);\n\t\t\telse w.erase(w.begin() + nx);\n\t\t}\n\t\tcand.insert(w.front());\n\t}\n\t//for (auto i : cand)cout << i << endl;\n\tvector<int>w(N);\n\tqueue<int>Q;\n\tfor (auto i : cand) {\n\t\tw[i] = 1;\n\t\tQ.push(i);\n\t}\n\t//while (!Q.empty()) {\n\t//\tint cn = Q.front();\n\t//\tQ.pop();\n\t//\tfor (int i = 0; i < cn; i++) {\n\t//\t\tif()\n\t//\t}\n\t//}\n\tcout << accumulate(w.begin(), w.end(),0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nint main()\n{\n    vector<set<int>> nar_l, nar_r;\n\n    int N;\n    cin >> N;\n    vector<vector<int>> A(N + 2, vector<int>(N + 2));\n    FOR(i, 1, N)\n    {\n        string S;\n        cin >> S;\n        REP(j, i)\n        {\n            A[i + 1][j + 1] = S[j] - '0';\n            A[j + 1][i + 1] = !A[i + 1][j + 1];\n        }\n    }\n\n    vector<vector<bool>> dp(N + 2, vector<bool>(N + 2)); // (l, r)\n    REP(i, N + 1) dp[i][i + 1] = 1;\n\n    FOR(d, 2, N + 1) REP(l, N + 2 - d)\n    {\n        FOR(c, l + 1, l + d) if (dp[l][c] and dp[c][l + d] and (A[l][c] or A[l + d][c]))\n        {\n            dp[l][l + d] = 1;\n            break;\n        }\n    }\n\n    int ret = 0;\n    // dbg(dp);\n    FOR(i, 1, N + 1) ret += (dp[0][i] and dp[i][N + 1]);\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = std::pair<int, int>;\n\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define pb push_back\n\nconst int mn = 2000;\n\nbitset<mn> g[mn], dpl[mn], dpr[mn];\n\nint n;\nchar s[mn + 5];\n\nint main() {\n#ifdef trote\n    freopen(\"../1.txt\", \"r\", stdin);\n#endif\n\n    scanf(\"%d\", &n);\n    if (n == 1) {\n        puts(\"1\");\n        exit(0);\n    }\n    for (int i = 1; i < n; i++) {\n        scanf(\"%s\", s);\n        for (int j = 0; j < i; j++) {\n            if (s[j] == '1') {\n                g[i][j] = 1;\n                g[j][i] = 0;\n            } else {\n                g[i][j] = 0;\n                g[j][i] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) dpl[i][i] = dpr[i][i] = true;\n    for (int len = 1; len < n; len++) {\n        for (int i = 0; i + len < n; i++) {\n            int j = i + len;\n            // dpl[i][j] iff g[i][k] && exist k let dpl[k][j] && dpr[k][i+1]\n            dpl[j][i] = (g[i] & dpl[j] & dpr[i + 1]).any();\n\n            // dpr[j][i] iff g[j][k] && dpl[k][j-1] && dpr[k][i]\n            dpr[i][j] = (g[j] & dpl[j - 1] & dpr[i]).any();\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (dpl[n - 1][i] && dpr[0][i]) ans++;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbitset<SZ> grid[SZ], msk[SZ];\nbitset<SZ> sv[SZ], sv2[SZ];\nvector<ll> wn[SZ];\nbitset<SZ> cur;\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tsv[i - 1][i] = 1;\n\t\tsv2[i][i - 1] = 1;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n + 3; i++) {\n\t\tcur = 0;\n\t\tfor (int j = 0; j < i; j++) cur[j] = 1;\n\t\tmsk[i] = cur;\n\t}\n\tfor (int i = 2; i <= n + 1; i++) {\n\t\tfor (int j = 0; j <= n + 1; j++) {\n\t\t\tll lft = j, rt = j + i;\n\t\t\tif (rt <= n + 1) {\n\t\t\t\tif ((((sv[lft] & grid[lft]) >> lft) & msk[i]) != 0 || (((sv2[rt] & grid[rt]) >> lft) & msk[i]) != 0) {\n\t\t\t\t\tsv[lft][rt] = 1;\n\t\t\t\t\tsv2[rt][lft] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (sv[0][i] && sv[i][n + 1]) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bitset>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nchar buf[2011];\n\nconst int SIZE = 2048;\nusing Bits = bitset<SIZE>;\nBits A[2011];\nBits L[2011], R[2011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    for (int i=1; i<N; i++) {\n\tscanf(\"%s\", buf);\n\tREP (j, i) {\n\t    if (buf[j] == '1') A[i].set(j);\n\t    else A[j].set(i);\n\t}\n    }\n\n    REP (i, N) {\n\tL[i].set(i);\n\tR[i].set(i);\n    }\n    for (int add=1; add<N; add++) {\n\tfor (int i=N-1; i>=0; i--) {\n\t    int k = i+add;\n\t    if (k >= N) continue;\n\n\t    // L[i][k] = R[i+1][j] && L[j][k] && A[i][j];\n\t    L[k].set(i, (R[i+1] & L[k] & A[i]).any());\n\n\t    // R[i][k] = R[i][j] && L[j][k-1] && A[k][j];\n\t    R[i].set(k, (R[i] & L[k-1] & A[k]).any());\n\t}\n    }\n\n    int ans = (R[0] & L[N-1]).count();;\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <mutex>\n#include <cmath>\n#define lli long long int\n#define ll long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nint main(){\n  int N;\n  int f = 0;\n  cin >> N;\n  int a[N][N-1];\n  for(int i = 0; i < N - 1; i++){\n    for(int j = 0; j <= i; j++){\n      cin >> a[i][j];\n      if(a[i][j] == 1){\n        f++;\n      }\n    }\n  }\n  if(f%2 == 1){\n    cout << N/2 +1;\n  }\n  else{\n    cout << N/2;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint kati[2002][2020]={};\nint dp[2020][2020]={};\n\nset<int> se[2020];\n\nbool solve(int x,int y){\n\t\n\tbool bo=0;\n\t//vector<int> dame;\n\tif(x<y){\n\t\tauto  it=se[x].lower_bound(x+1);\n\t\tfor(;;it++){\n\t\t\tif(*it>y) break;\n\t\t\tif( dp[*it][y] ){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\telse{\n\t\t//int  it=lower_bound(ve[x].begin(),ve[x].end(),y)-ve[x].begin();\n\t\tauto  it=se[x].lower_bound(y);\n\t\tfor(;;it++){\n\t\t\tif(*it>x-1) break;\n\t\t//for(int i=x-1;i>=y;i--){\n\t\t\tif(dp[*it][y] ){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\t\n\t\tif(x<y){\n\t\t\tif(bo==0){\n\t\t\t\tse[y-1].erase(x);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\tif(bo==0){\n\t\t\t\tse[y+1].erase(x);\n\t\t\t}\n\t\t}\n\tdp[x][y]=bo;\n//\tcout<<x<<\" \"<<y<<\" \"<<bo<<endl;\n\treturn bo;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n int n;\n \tcin>>n;\n \tfor(int i=0;i<n;i++)dp[i][i]=1,kati[i][i]=1;\n \t\n \tfor(int i=1;i<n;i++){\n \t\tstring s;\n \t\tcin>>s;\n \t\t\n \t\tfor(int j=0;j<i;j++){\n \t\t\tif(s[j]=='1'){\n \t\t\t//\tif(rand()%2){\t\n \t\t\t\tkati[i][j]=1;\n \t\t\t}\n \t\t\telse kati[j][i]=1;\n \t\t}\n \t}\n \t\n \t\tfor(int i=0;i<n;i++){\n \t\t\tse[i].insert(-inf);\n \t\t\tfor(int j=0;j<n;j++){\n \t\t\t\tif(kati[i][j])se[i].insert(j);\n \t\t\t}\n \t\t\tse[i].insert(inf);\n \t\t}\n \t\n \tint ans=0;\n \t\tfor(int d=1;d<n;d++)for(int i=0;i+d<n;i++){\n \t\t\tsolve(i,i+d);\n \t\t\tsolve(i+d,i);\n \t\t}\n \t\t\n \tfor(int i=0;i<n;i++)ans+=(dp[i][0]&& dp[i][n-1]);\n \tcout<<ans<<endl;\n \t\n \treturn 0;\n\n  }\n  \n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    int n;\n    cin >> n;\n    vs a(n-1);\n    rep(i, n-1) cin >> a[i];\n    vector<vector<bool>> win(n, vector<bool>(n));\n    rep1(i, n-1) rep(j, i) {\n        win[i][j] = (a[i-1][j] == '1');\n        win[j][i] = !(a[i-1][j] == '1');\n    }\n    vector<bitset<2005>> dpfl(n), dpfr(n), dpbl(n), dpbr(n);\n    rep(i, n) dpfl[i][i] = dpfr[i][i] = dpbl[i][i] = dpbr[i][i] = true;\n    rep1(i, n-1) rep(a, n-i) {\n        int b = a + i;\n        bool lok = false;\n        auto &nfl = dpfl[b], &nbl = dpbl[a], &nfr = dpfr[b], &nbr = dpbr[a];\n        rep1(c, i-1) if (nbl[a+c] && nfl[a+c]) {\n            lok = true;\n            break;\n        }\n        if (!lok && win[a][b]) {\n            rep(c, i) if (nbl[a+c] && nfr[a+c+1]) {\n                lok = true;\n                break;\n            }\n        }\n        nfl[a] = nbl[b] = lok;\n        bool rok = false;\n        rep1(c, i-1) if (nfr[b-c] && nbr[b-c]) {\n            rok = true;\n            break;\n        }\n        if (!rok && win[b][a]) {\n            rep(c, i) if (nfr[b-c] && nbl[b-c-1]) {\n                rok = true;\n                break;\n            }\n        }\n        nfr[a] = nbr[b] = rok;\n    }\n    int ans = 0;\n    rep(i, n) if (dpbr[0][i] && dpfl[n-1][i]) ++ans;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define rdp ldp\nconstexpr int Nmax = 2002;\nint main()\n{\n    int N;\n    cin >> N;\n    vector<bitset<Nmax>> A(N + 2, bitset<Nmax>());\n    FOR(i, 1, N)\n    {\n        string S;\n        cin >> S;\n        REP(j, i)\n        {\n            A[i + 1][j + 1] = S[j] - '0';\n            A[j + 1][i + 1] = !A[i + 1][j + 1];\n        }\n    }\n\n    vector<bitset<Nmax>> ldp(N + 2, bitset<Nmax>())/*, rdp(N + 2, bitset<Nmax>())*/;\n    REP(i, N + 1) ldp[i][i + 1] = rdp[i + 1][i] = 1;\n\n    FOR(d, 2, N + 1) REP(l, N + 2 - d)\n    {\n        if ((ldp[l] & rdp[l + d] & (A[l] | A[l + d])).any()) ldp[l][l + d] = rdp[l + d][l] = 1;\n    }\n\n    int ret = (ldp[0] & rdp[N + 1]).count();\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N;\nint A[2005][2005];\nint before[2005][2005];\nint subbefore[2005];\nint after[2005][2005];\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    for(int i = 2; i <= N; i++) {\n        string S;\n        cin >> S;\n        for(int j = 0; j < S.size(); j++) {\n            A[i][j+1] = S[j] - '0';\n            A[j+1][i] = 1 - A[i][j+1];\n            //cerr << i << \" \" << j + 1 << \" \" << A[i][j+1] << endl;\n        }\n    }\n    for(int i = 1; i <= N; i++) {\n        before[i][i] = i;\n        after[i][i] = i;\n        subbefore[i] = i;\n        for(int j = i - 1; j >= 1; j--) {\n            before[i][j] = before[i-1][j];\n            if(before[i][i] <= j) {\n                chmin(before[i][i], before[i-1][j]);\n            } else if(after[i-1][j] + 1 >= subbefore[after[i-1][j]+1]) {\n                if(A[i][j] == 1) chmin(before[i][i], before[i-1][j]);\n            }\n            subbefore[j] = before[i][i];\n        }\n        int minimum = i;\n        for(int j = i - 1; j >= 1; j--) {\n            after[i][j] = after[i-1][j];\n            if(after[minimum][j] >= minimum) {\n                chmax(after[i][j], i);\n            } else if(after[i][j] + 1 >= before[i][i]) {\n                if(A[j][i] == 1) chmax(after[i][j], i);\n            }\n            if(after[i][j] == i) minimum = j;\n        }\n    }\n    for(int TIME = 1; TIME <= N; TIME++) {\n        //cerr << \"----\" << TIME << \"----\" << endl;\n        for(int i = 1; i <= TIME; i++) {\n            //cerr << i << \" \" << before[TIME][i] << \" \" << after[TIME][i] << endl;\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= N; i++) {\n        if(before[N][i] == 1 && after[N][i] == N) ans++;\n        //cerr << before[N][i] <<  \" \" << after[N][i] << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(v) ;\n#define eprintf(...) if(0) fprintf(stderr, \"...\")\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst int maxN = 2000 + 5;\nint n;\nshort G[maxN][maxN];\nbool bleft[maxN], bright[maxN];\n\nbool vis[maxN];\nint cnt = 0;\nint lim;\nvoid dfsL(int u) {\n\tcnt++; vis[u] = true;\n\tfor(int i = 1; i <= lim; ++i) if(G[u][i] && !vis[i])\n\t\tdfsL(i);\n}\nvoid dfsR(int u) {\n\tcnt++; vis[u] = true;\n\tfor(int i = lim; i <= n; ++i) if(G[u][i] && !vis[i])\n\t\tdfsR(i);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tmemset(G, 0, sizeof(G));\n\tfor(int i = 2; i <= n; ++i) {\n\t\tstring s; cin >> s;\n\t\tfor(int j = 0; j < i; ++j) if(s[j] == '1')\n\t\t\tG[i][j + 1] = 1;\n\t\telse\n\t\t\tG[j + 1][i] = 1;\n\t}\n\tfor(int u = 1; u <= n; ++u) {\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tlim = u; cnt = 0;\n\t\tdfsL(u);\n//\t\teprintf(\"left %d = %d\\n\", u, cnt);\n\t\tbleft[u] = (cnt == lim);\n\t}\n\tfor(int u = 1; u <= n; ++u) {\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tlim = u; cnt = 0;\n\t\tdfsR(u);\n//\t\teprintf(\"right %d = %d\\n\", u, cnt);\n\t\tbright[u] = (cnt == n - u + 1); \n\t}\n\tint qwq = 0;\n\tfor(int i = 1; i <= n; ++i) qwq += (bleft[i] && bright[i]);\n\tcout << qwq << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbool win[2001][2001];\nbool dpl[2001][2001], dpr[2001][2001];\nsigned main() {\n    int N; cin >> N;\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dpl[i][i] = dpr[i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            for(int k=i; k<=j; k++) {\n                if(k > i and win[i][k] and dpl[j][k] and dpr[i+1][k]) dpl[j][i] = true;\n                if(k < j and win[j][k] and dpr[i][k] and dpl[j-1][k]) dpr[i][j] = true;\n                \n            }\n            // fprintf(stderr, \"dpl[%lld][%lld] = %lld, dpr[%lld][%lld] = %lld\\n\", i, j, dpl[i][j], j, i, dpr[j][i]);\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dpl[N-1][i] and dpr[0][i]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V< bitset<2000> > a(n);\n  for (int i = 1; i < n; ++i) {\n    string s; cin >> s;\n    for (int j = 0; j < i; ++j) {\n      a[i][j] = s[j] == '1';\n      a[j][i] = s[j] == '0';\n    }\n  }\n  V< bitset<2000> > dp(n);\n  for (int i = 0; i < n; ++i) {\n    dp[i][i] = true;\n    if (i) dp[i - 1][i] = a[i][i - 1];\n    if (i + 1 < n) dp[i + 1][i] = a[i][i + 1];\n  }\n  for (int w = 2; w < n; ++w) {\n    for (int i = 0; i < n; ++i) {\n      int j = i + w;\n      if (j < n) {\n        dp[j][i] = (a[i] & dp[i + 1] & dp[j])._Find_next(i) <= j;\n      }\n      j = i - w;\n      if (j >= 0) {\n        dp[j][i] = (a[i] & dp[i - 1] & dp[j])._Find_next(j - 1) <= i - 1;\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n; ++i) res += dp[0][i] and dp[n - 1][i];\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<string> A(N);\n    for (int n = 1; n < N; ++n) {\n        cin >> A[n];\n    }\n    \n    vector<vector<int>> DP(N, vector<int>(N));\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = 1;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            for (int k = i+1; k <= i+d; ++k) {\n                DP[i][i+d] |= A[k][i] == '0' && DP[k][i+1] && DP[k][i+d];\n            }\n            for (int k = i; k < i+d; ++k) {\n                DP[i+d][i] |= A[i+d][k] == '1' && DP[k][i] && DP[k][i+d-1];\n            }\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[n][0] && DP[n][N-1]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbitset <2005> pre[2005], suf[2005];\nbitset <2005> preA[2005], sufA[2005];\n\nint dp[2005][2005];\nint a[2005][2005];\nint n;\nchar txt[2005];\n\nint delP[2005], delS[2005];\n\nint main(int argc, char const *argv[])\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\ta[i][i] = 1;\n\t}\n\tfor(int i = 2; i <= n; i++) {\n\t\tscanf(\"%s\", txt);\n\t\tfor(int j = 1; j < i; j++) {\n\t\t\tint c = txt[j - 1] - '0';\n\t\t\ta[i][j] = c;\n\t\t\ta[j][i] = c ^ 1;\n\t\t}\n\t}\n\tfor(int len = 1; len < n; len++) {\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tint j = i + len;\n\t\t\tif(j > n) break;\n\t\t\tif(len == 1) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tbitset <2005> xx = preA[i] & suf[j];\n\t\t\t\txx |= pre[i] & sufA[j];\n\t\t\t\tif(xx.count() > 0) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[i][j]) {\n\t\t\t\tpreA[i][j] = 1;\n\t\t\t\tsufA[j][i] = 1;\n\t\t\t\tif(a[j][i]) {\n\t\t\t\t\tsuf[j][i] = 1;\n\t\t\t\t}\n\t\t\t\tif(a[i][j]) {\n\t\t\t\t\tpre[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdelP[1] = 1;\n\tfor(int i = 2; i <= n; i++) {\n\t\tfor(int j = 1; j < i; j++) {\n\t\t\tif(a[i][j] && dp[j][i]) {\n\t\t\t\tdelP[i] |= delP[j];\n\t\t\t}\n\t\t}\n\t}\n\tdelS[n] = 1;\n\tfor(int i = n - 1; i >= 1; i--) {\n\t\tfor(int j = i + 1; j <= n; j++) {\n\t\t\tif(a[i][j] && dp[i][j]) {\n\t\t\t\tdelS[i] |= delS[j];\n\t\t\t} \n\t\t}\n\t}\n\tint cnt = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(delP[i] && delS[i]) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000003;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\ntypedef bitset<2000> bt;\n\nbt b[2000];\n\nbt le[2000], ri[2000];\nvoid solve() {\n\tint n; cin >> n;\n\trep1(i, n - 1) {\n\t\trep(j, i) {\n\t\t\tchar t; cin >> t;\n\t\t\tif (t == '1') {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n)le[i][i] = ri[i][i] = true;\n\n\tint ans = 0;\n\tRep1(i, 2, n) {\n\t\trep(j, n - i + 1) {\n\t\t\tint l = j;\n\t\t\tint r = j + i - 1;\n\t\t\tle[r][l] = (b[l] & ri[l + 1] & le[r]).count();\n\t\t\tri[l][r] = (b[r] & ri[l] & le[r - 1]).count();\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (ri[0][i] && le[n-1][i])ans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nint A[2145][2145];\nbool used[2145];\nvector<int> es[2145];\n//bitset<2000> mat[2000];\n\nbool check(int v, int l, int r) {\n  //cout << v << \", \" << l << \", \" << r <<endl;\n  used[v] = true;\n  auto itr = lower_bound(all(es[v]), l);\n  auto endi = lower_bound(all(es[v]), r);\n  while (itr != endi) {\n    int u = *itr;\n    if (used[u]) {\n      itr++;\n      continue;\n    }\n    if (u < v) check(u, l, v);\n    else check(u, v+1, r);\n    itr++;\n  }\n}\n\nsigned main(){\n  //ios_base::sync_with_stdio(false);\n  //cout<<fixed<<setprecision(0);\n\n  scanf(\"%d\", &N);\n  //cin >> N;\n  reps(i, 1, N) {\n    rep(j, i) {\n      int w;\n      scanf(\"%01d\", &w);\n      //cin >> w;\n      A[i][j] = w;\n      A[j][i] = !w;\n      //mat[i][j] = 1;\n    }\n  }\n\n  rep(v, N) {\n    rep(u, N) {\n      if (u == v) continue;\n      if (A[v][u]) es[v].eb(u);\n    }\n  }\n\n  int ans = 0;\n  rep(v, N) {\n    fill(used, used+N, false);\n    check(v, 0, N);\n    bool fail = false;\n    rep(u, N) {\n      if (!used[u]) fail = true;\n    }\n    if (!fail) ans++;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/dynamic_bitset.hpp>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  auto a = std::vector<boost::dynamic_bitset<>>(n + 2, boost::dynamic_bitset<>(n + 2));\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a[i][j] = k;\n    a[j][i] = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<boost::dynamic_bitset<>>(n + 2, boost::dynamic_bitset<>(n + 2));\n  for (size_t i = 0; i <= n; i++) dp[i][i + 1] = dp[i + 1][i] = true;\n  for (size_t d = 2; d <= n + 1; d++) {\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      dp[j][i] = dp[i][j] = (dp[i] & dp[j] & (a[i] | a[j])).any();\n    }\n  }\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp[0][i] & dp[i][n + 1]) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cerr << *i << \" \"; cerr << endl; }\ntemplate <class T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <class T> void chmax(T &t, const T &f) { if (t < f) t = f; }\n\nconstexpr int MAX_N = 2005;\n\nint N;\nchar A[MAX_N][MAX_N];\nbool B[MAX_N][MAX_N];\n\nbool dp[MAX_N][MAX_N];\n\nint main() {\n  for (; ~scanf(\"%d\", &N); ) {\n    for (int i = 2; i <= N; ++i) {\n      scanf(\"%s\", A[i] + 1);\n    }\n    B[0][N + 1] = true;\n    B[N + 1][0] = false;\n    for (int i = 1; i <= N; ++i) {\n      B[0][i] = false;\n      B[i][0] = true;\n      B[N + 1][i] = false;\n      B[i][N + 1] = true;\n    }\n    for (int i = 1; i <= N; ++i) for (int j = 1; j < i; ++j) {\n      B[i][j] = (A[i][j] == '1');\n      B[j][i] = (A[i][j] == '0');\n    }\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i <= N; ++i) {\n      dp[i][i + 1] = true;\n    }\n    for (int w = 2; w <= N + 1; ++w) {\n      for (int i = 0; i <= N + 1 - w; ++i) {\n        const int j = i + w;\n        for (int k = i + 1; k < j; ++k) {\n          if ((B[i][k] || B[j][k]) && dp[i][k] && dp[k][j]) {\n            dp[i][j] = true;\n            break;\n          }\n        }\n      }\n    }\n// for(int i=0;i<=N+1;++i)pv(dp[i],dp[i]+N+1+1);\n    int ans = 0;\n    for (int i = 1; i <= N; ++i) {\n      if (dp[0][i] && dp[i][N + 1]) {\n        ++ans;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2019;\nint n,ans;\nbitset<N>L[N],R[N],a[N];\nchar str[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",str+1);\n\t\tfor(int j=1;j<i;j++)a[i][j]=str[j]-'0',a[j][i]='1'-str[j];\n\t}\n\tfor(int i=1;i<=n;i++)L[i][i]=R[i][i]=1;\n\tfor(int l=2;l<=n;l++)\n\tfor(int i=1,j;i+l-1<=n;i++)\n\t{\n\t\tj=i+l-1;\n\t\tL[j][i]=(R[i+1]&L[j]&a[i]).count()!=0;\n\t\tR[i][j]=(L[j-1]&R[i]&a[j]).count()!=0;\n\t}\n\tfor(int i=1;i<=n;i++)ans+=R[1][i]&&L[n][i];\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#define PII pair<int,int>\n#define MP make_pair\n#define fir first\n#define sec second\n#define PB push_back\n#define db long double\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2010;\nchar str[N];\nint n;\nbitset<2010> fl[N],fr[N],A[N];\nint main() {\n\trd(n);\n\tfor(int i=2;i<=n;++i) {\n\t\tscanf(\"%s\",str+1);\n\t\tfor(int j=1;j<i;++j) {\n\t\t\tA[i][j]=str[j]-'0';\n\t\t\tA[j][i]=(str[j]-'0')^1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) fl[i][i]=fr[i][i]=1;\n\tfor(int l=2;l<=n;l++)\n\t\tfor(int i=1;i+l-1<=n;++i) {\n\t\t\tint j=i+l-1;\n\t\t\tfl[j][i]=(fr[i+1]&fl[j]&A[i]).count()!=0;\n\t\t\tfr[i][j]=(fl[j-1]&fr[i]&A[j]).count()!=0;\n\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tans+=fr[1][i]!=0&&fl[n][i]!=0;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define TR(X) ({ if(1) cerr << \"TR: \" << (#X) << \" = \" << (X) << endl; })\n\ntypedef bitset<2005> bits;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tll n; cin >> n;\n\tvector<bits> win(n+2);\n\tFOR(i,0,n) FOR(j,0,i) {\n\t\tchar c; cin >> c;\n\t\tif (c == '1') win[i+1][j+1] = 1; else win[j+1][i+1] = 1;\n\t}\n\tFOR(i,0,n) win[i+1][0] = win[i+1][n+1] = 1;\n\tn += 2;\n\t\n\tvector<bits> dwL(n), dwR(n);\n\tFOR(i,1,n)   dwL[i][i-1] = 1;\n\tFOR(i,0,n-1) dwR[i][i+1] = 1;\n\t\n\tFOR(len,2,n) FOR(i,0,n) {\n\t\tll j = i+len;\n\t\tif (j >= n) break;\n\n\t\tbool cur = (dwR[i] & dwL[j] & (win[i] | win[j])).any();\n\t\tif (cur) dwR[i][j] = dwL[j][i] = 1;\n\t}\n\t\n\tll res = 0;\n\tFOR(i,1,n-1) if (dwL[i][0] && dwR[i][n-1]) res++;\n\tcout << res << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <stack>\n#include <climits>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#define INF INT_MAX>>1 //要climits#includ\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main(void){\n\tint N;\n\tcin >> N;\n\n\tbool flag[2005];\n\tfill(flag, flag+2005, false);\n\tfor(int i=0; i<N-1; i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tint len = str.length();\n\t\tfor(int j=0; j<len; j++){\n\t\t\tif(str[j] == '0'){\n\t\t\t\tflag[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=0; i<N; i++){\n\t\tif(flag[i] == true) ans++;\n\t}\n\tcout << ans << endl;\n}\n\n\n\n/*\nint main(void){\n\tstring str;\n\tcin >> str;\n\tint count = 0;\n\tint len = str.length();\n\tfor(int i=0; i<len; i++){\n\t\tif(str[i] == 'o') count++;\n\t}\n\tcount += 15-len;\n\tif(count >=8) cout << \"YES\" << endl;\n\telse cout << \"NO\" << endl;\n}\n*/\n\n/*\nint main(void){\n\tint N;\n\tcin >> N;\n\tcout << 180*(N-2) << endl;\n\treturn 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <ios>     // std::left, std::right\n#include <iomanip> // std::setw(int), std::setfill(char)\nusing namespace std;\n\n\nint main(){\nint N;\ncin>>N;\nlong long a;\n//A[a][b]aがbに勝つか\nint A[2000][2000]={};\nfor(int i=1;i<=N;++i){\n  cin>>a;\n  for(int j=0;j<i;++j){\n    A[i][i-1-j]=a%10;\n    A[i-1-j][i]=1-a%10;\n    a/=10;\n  }\n}\nint ans=0;\nfor(int i=0;i<N;++i){\n  queue<int> q;\n  int used[N]={};\n  int counter=0;\n  used[i]=1;\n  q.push(i);\n  counter+=1;\n  int num=i;\n  while(q.size()){\n    num=q.front();\n    q.pop();\n    for(int j=0;j<N;++j){\n      if(used[j]==1){\n        continue;\n      }\n      if(A[num][j]==1){\n        q.push(j);\n        used[j]=1;\n        counter+=1;\n      }\n    }\n    if(counter==N){\n      ans+=1;\n      break;\n    }\n  }\n}\ncout<<ans-1<<\"\\n\";\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\n\tint ind = lower_bound(wn[r].begin(), wn[r].end(), l) - wn[r].begin();\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = upper_bound(wn[l].begin(), wn[l].end(), r) - wn[l].begin();\n\tind--;\n\twhile (ind >= 0 && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind--;\n\t}\n\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define sz(a) (int)a.size()\n#define x first\n#define y second\n#define debug(...) cout << \"[\" << #__VA_ARGS__ << \": \" << __VA_ARGS__ << \"]\\n\"\n#define rd() abs((int)rng())\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int>pii;\nconst int maxn = 2e3 + 100;\nconst int mod = 1e9 + 7;\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\nint n;\nbitset<maxn>dpl[maxn], dpr[maxn], wins[maxn];\nint main()\n{\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 1; j <= sz(s); j++)\n\t\t{\n\t\t\tif(s[j - 1] == '0')\n\t\t\t{\n\t\t\t\twins[i][j] = 0;\n\t\t\t\twins[j][i] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twins[i][j] = 1;\n\t\t\t\twins[j][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tdpl[i][i] = dpr[i][i] = 1;\n\tfor(int len = 2; len <= n; len++)\n\t{\n\t\tfor(int i = len; i <= n; i++)\n\t\t{\n\t\t\tif((dpr[i - 1] & dpl[i - len + 1] & wins[i]).any())\n\t\t\t\tdpl[i - len + 1][i] = 1;\n\t\t}\n\t\tfor(int i = n - len + 1; i >= 1; i--)\n\t\t{\n\t\t\tif((dpl[i + 1] & dpr[i + len - 1] & wins[i]).any())\n\t\t\t\tdpr[i + len - 1][i] = 1;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(dpl[1][i] && dpr[n][i])\n\t\t\t++ans;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 2010;\nint n;\nchar s[N];\nbitset<N> canBeat[N];\nbitset<N> lft[N], rgt[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (s[j] == '0')\n\t\t\t\tcanBeat[j][i] = 1;\n\t\t\telse\n\t\t\t\tcanBeat[i][j] = 1;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tlft[i][i] = 1;\n\t\trgt[i][i] = 1;\n\t}\n\tfor (int len = 2; len <= n; len++) {\n\t\tfor (int l = 0; l + len <= n; l++) {\n\t\t\tint r = l + len - 1;\n\t\t\tif ((lft[l + 1] & rgt[r] & canBeat[l]).any())\n\t\t\t\trgt[r][l] = 1;\n\t\t\tif ((lft[l] & rgt[r - 1] & canBeat[r]).any())\n\t\t\t\tlft[l][r] = 1;\n\t\t}\n\t}\n/*\n\tbitset<N> w = lft[0] & rgt[n - 1];\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d\", (int)w[i]);\n\tprintf(\"\\n\");\n*/\n\tprintf(\"%d\\n\", (int)((lft[0] & rgt[n - 1]).count()));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\nint N, ans = 0; char str[2005];\nbitset<2005> A[2005], L[2005], R[2005];\n\nint main(){\n\tgetint(N);\n\tfor(register int i = 2; i <= N; i++){\n\t\tscanf(\"%s\", str + 1);\n\t\tfor(register int j = 1; j < i; j++)\n\t\t\tA[i][j] = str[j] &= 1, A[j][i] = str[j] ^ 1;\n\t}\n\tfor(register int i = 1; i <= N; i++) L[i][i] = R[i][i] = 1;\n\tfor(register int gap = 1; gap < N; gap++)\n\t\tfor(register int i = 1, j; (j = i + gap) <= N; i++){\n\t\t\tL[j][i] = (R[i + 1] & L[j] & A[i]).count() > 0;\n\t\t\tR[i][j] = (L[j - 1] & R[i] & A[j]).count() > 0;\n\t\t}\n\treturn printf(\"%d\\n\", (int)(R[1] & L[N]).count()), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n/////////////\t\tグラフを扱うクラス\n\nclass edgeClass {// 辺のクラス\npublic:\n\tedgeClass() {\n\t\tx = 0, y = 0, weight = 1;\n\t}\n\tvoid swap() {\n\t\tint c = x;\n\t\tx = y;\n\t\ty = c;\n\t}\n\tint x, y, weight;\n};\nbool edgeClass_compare(const edgeClass& a, const edgeClass& b) {// keyを見比べる\n\tint x = b.x - a.x;\n\tif (x > 0) { return true; }\n\tx = b.y - a.y;\n\treturn x > 0;\n}\nclass graphClass {// グラフ入力を受け取る\npublic:\n\tgraphClass() {\n\t\tN = 0;\n\t\tM = 0;\n\t\tnext = NULL;\n\t\tedge.clear();\n\t\tweight = NULL;\n\t\tdirectedFlag = false;\n\t}\n\n\tvoid activate(int n, bool directed = false) {// 頂点数nのグラフを初期化する。\n\t\tdirectedFlag = directed;\n\t\tN = n;\n\t\tM = 0;\n\t\tedge.clear();\n\t\tif (next != NULL) { delete[] next; }\n\t\tif (weight != NULL) { delete[] weight; }\n\t\tnext = new vector<edgeClass>[N];\n\t\tweight = new int[N];\n\t\tfor (int i = 0; i < N; i++) { weight[i] = 1; }\n\t}\n\tvoid setNodeWeight(int n, int weight) {// n番のノードの重みをweightに設定\n\t\tthis->weight[n] = weight;\n\t}\n\tvoid addEdge(int x, int y, int weight = 1) {// エッジ追加\n\t\tedgeClass e;\n\t\te.x = x;\n\t\te.y = y;\n\t\te.weight = weight;\n\n\t\tif (e.x < 0 || e.x >= N) { return; }\n\n\t\tedge.push_back(e); M++;\n\t\tnext[e.x].push_back(e);\n\n\t\tif (directedFlag == false) {\n\t\t\te.swap();\n\t\t\tnext[e.x].push_back(e);\n\t\t}\n\n\t}\n\tvoid sortEdge() {// 各ノードについて、接続先の番号を昇順ソート\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (next[i].size() > 1) {\n\t\t\t\tsort(next[i].begin(), next[i].end(), edgeClass_compare);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool isTree() {// 木になっているかどうか幅優先探索で調べる\n\t\tif (N <= 0 || M != N - 1) { return false; }\n\n\t\tbool* visited = new bool[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvisited[i] = (i == 0);\n\t\t}\n\n\t\tqueue<int> q; q.push(0);\n\n\t\twhile (q.size() > 0) {\n\t\t\tint n = q.front(); q.pop();\n\t\t\tvisited[n] = true;\n\n\t\t\tfor (auto itr = next[n].begin(); itr != next[n].end(); itr++) {\n\t\t\t\tif (visited[itr->y] == false) {\n\t\t\t\t\tq.push(itr->y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (visited[i] == false) { delete[] visited; return false; }\n\t\t}\n\n\t\tdelete[] visited;\n\t\treturn true;\n\t}\n\n\tlong* getDistanceFrom(int n) {// ダイクストラ法で始点nからの最短距離を得る\n\t\tif (n < 0 || n >= N) { return NULL; }\n\n\t\tlong* buf = new long[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tbuf[i] = 1000000000;\n\t\t}\n\n\t\t// 昇順に出力\n\t\t// pair<重み, 番号>を並べておく\n\t\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\t\tbuf[n] = 0;\n\t\tq.push(pair<int, int>(0, n));\n\n\t\twhile (q.empty() == false) {\n\t\t\tpair<int, int> p = q.top(); q.pop();\n\t\t\tint k = p.second;\n\t\t\tif (p.first <= buf[k]) {\n\t\t\t\tfor (auto itr = next[k].begin(); itr != next[k].end(); itr++) {\n\t\t\t\t\tif (buf[itr->y] > buf[k] + itr->weight) {\n\t\t\t\t\t\tbuf[itr->y] = buf[k] + itr->weight;\n\t\t\t\t\t\tq.push(pair<int, int>(buf[itr->y], itr->y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn buf;\n\t}\n\n\tvoid debugCout() {// デバッグ出力用\n\t\tcout << endl;\n\t\tcout << \"ノードの個数 = \" << N << \"個\" << endl;\n\t\tcout << \"エッジの本数 = \" << M << \"本\" << endl;\n\t\tcout << endl;\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << \"i = \" << i << \" (weight = \" << weight[i] << \"), 接続先 = \";\n\t\t\tif (next[i].size() == 0) { cout << \"なし\" << endl; continue; }\n\t\t\tauto itr = next[i].begin();\n\t\t\tcout << itr->y << \"(weight = \" << itr->weight << \")\";\n\t\t\titr++;\n\n\t\t\tfor (; itr != next[i].end(); itr++) {\n\t\t\t\tcout << \", \" << itr->y << \"(weight = \" << itr->weight << \")\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tbool directedFlag;// 有向グラフかどうか\n\tint N, M;\n\tint* weight;// ノードの重み\n\tvector<edgeClass>* next;// 各ノードにおける辺\n\tvector<edgeClass> edge;// エッジ\n};\n\n\n\nvoid bfs(graphClass& G, int root) {// 幅優先探索\n\tint N = G.N;\n\tbool* visited = new bool[N];\n\tfor (int i = 0; i < N; i++) {\n\t\tvisited[i] = (i == root);\n\t}\n\n\tqueue<int> q; q.push(root);\n\n\twhile (q.size() > 0) {\n\t\tint n = q.front(); q.pop();\n\t\tvisited[n] = true;\n\n\t\t// ここに各ノードで行う処理を書く\n\n\t\tfor (auto itr = G.next[n].begin(); itr != G.next[n].end(); itr++) {\n\n\t\t\t// ここに各エッジで行う処理を書く\n\n\t\t\tif (visited[itr->y] == false) {// まだ訪れていなかったら\n\t\t\t\tq.push(itr->y);\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete[] visited;\n}\nint dfs_count;\nbool* dfs_visited = NULL;\nvoid dfs_process_main(graphClass & G, int n, int k) {// 深さ優先探索\n\tdfs_visited[n] = true;\n\n\t// ここに各ノードで行う処理を書く\n\tdfs_count++;\n\n\tfor (auto itr = G.next[n].begin(); itr != G.next[n].end(); itr++) {\n\n\t\tif (n < k) {\n\t\t\tif (itr->y < k && dfs_visited[itr->y] == false) {// まだ訪れていなかったら\n\t\t\t\tdfs_process_main(G, itr->y, k);\n\t\t\t}\n\t\t}\n\t\telse if (n > k) {\n\t\t\tif (itr->y > k && dfs_visited[itr->y] == false) {// まだ訪れていなかったら\n\t\t\t\tdfs_process_main(G, itr->y, k);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (dfs_visited[itr->y] == false) {// まだ訪れていなかったら\n\t\t\t\tdfs_process_main(G, itr->y, k);\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(graphClass & G, int root) {// 深さ優先探索\n\tdfs_count = 0;\n\n\tint N = G.N;\n\tdfs_visited = new bool[N];\n\tfor (int i = 0; i < N; i++) { dfs_visited[i] = false; }\n\tdfs_process_main(G, root, root);\n\n\tdelete[] dfs_visited;\n\tdfs_visited = NULL;\n\n\tif (dfs_count == G.N) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint N; cin >> N;\n\tgraphClass G; G.activate(N, true);\n\n\tfor (int i = 2; i <= N; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tchar a; cin >> a;\n\t\t\tif (a == '1') {\n\t\t\t\tG.addEdge(i - 1, j - 1);\n\t\t\t}\n\t\t\telse if(a=='0'){\n\t\t\t\tG.addEdge(j - 1, i - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t//G.debugCout();\n\n\tint c = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dfs(G, i)) { c++; }\n\t}\n\n\tcout << c << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n//*\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconstexpr ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\ninline bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\ninline bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\nconstexpr int N = 400;\nint dp1[N][N]; // left win\nint dp2[N][N]; // right win\nbool A[N][N];\nint n;\n\nint rec2(int a, int b);\n\n// left win\nint rec1(int a, int b){\n  if(dp1[a][b] != -1) return dp1[a][b];\n  repr(i, a+1, b+1){\n    if(A[a][i] & rec1(i, b)){\n      repr(j, a, i){\n        if(rec1(a, j) & rec2(j+1, i)){\n          return dp1[a][b] = 1;\n        }\n      }\n    }\n  }\n  return dp1[a][b] = 0;\n}\n\n// right win\nint rec2(int a, int b){\n  if(dp2[a][b] != -1) return dp2[a][b];\n  repr(i, a, b){\n    if(A[b][i] & rec2(a, i)){\n      repr(j, i, b){\n        if(rec1(i, j) & rec2(j+1, b)){\n          return dp2[a][b] = 1;\n        }\n      }\n    }\n  }\n  return dp2[a][b] = 0;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  cin >> n;\n  assert(n <= N);\n  char ch;\n  repr(i, 1, n)rep(j, i){\n    cin >> ch;\n    A[i][j] = ch == '1';\n    A[j][i] = !A[i][j];\n  }\n  memset(dp1, -1, sizeof(int) * N*N);\n  memset(dp2, -1, sizeof(int) * N*N);\n  rep(i, N) dp1[i][i] = 1;\n  rep(i, N) dp2[i][i] = 1;\n  \n  int ans = 0;\n  rep(i, n){\n    ans += rec1(i, n-1) & rec2(0, i);\n  }\n  print(ans);\n  /*\n  rep(i, n){\n    rep(j, n){\n      cout << setw(3) << right << dp1[i][j];\n    }\n    cout << \"\\n\";\n  }\n  cout << \"\\n\";\n  rep(i, n){\n    rep(j, n){\n      cout << setw(3) << right << dp2[i][j];\n    }\n    cout << \"\\n\";\n  }\n  */\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n\nusing namespace std;\n\nint n;\nbitset<2005> a[2005], dp[2005];\nbitset<2005> mask[2005], mask2[2005];\n\nint main(void)\n{\n\tcin >> n;\n\tchar c;\n\tfor(int i = 2; i <= n; i++){\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tcin >> c;\n\t\t\ta[i][j] = c-'0';\n\t\t\ta[j][i] = !a[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++) dp[i][i] = 1;\n\tfor(int len = 2; len <= n; len++){\n\t\tfor(int l = 1; l <= n; l++){\n\t\t\tint r = l + len - 1;\n\t\t\tif(r > n) continue;\n\t\t\tmask[l][r-1] = 1;\n\t\t\tdp[l][r] = (a[r] & dp[l] & dp[r-1] & mask[l]).any();\n\t\t\tmask2[r][l+1] = 1;\n\t\t\tdp[r][l] = (a[l] & dp[l+1] & dp[r] & mask2[r]).any();\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(dp[1][i] && dp[n][i]) ans++;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[2020][2020];\n\nint win[2020][2020][2];\nint dp[2020][2020];\n\nint hoge(int L,int R,int side) ;\nint top(int L,int R) {\n\tif(dp[L][R]>=0) return dp[L][R];\n\tif(L==R) return dp[L][R]=1;\n\tint x;\n\tfor(x=L;x<R;x++) if(hoge(L,x,0)&&hoge(x+1,R,1)) return dp[L][R]=1;\n\treturn dp[L][R]=0;\n}\n\nint hoge(int L,int R,int side) {\n\tif(L==R) return 1;\n\tif(win[L][R][side]>=0) return win[L][R][side];\n\twin[L][R][side]=0;\n\tif(side==0) {\n\t\tfor(int x=L+1;x<=R;x++) if(A[L][x]&&top(L,x)&&hoge(x,R,0)) return win[L][R][side]=1;\n\t}\n\telse {\n\t\tfor(int x=L;x<R;x++) if(A[R][x]&&top(x,R)&&hoge(L,x,1)) return win[L][R][side]=1;\n\t}\n\treturn 0;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(j=1;j<N;j++) {\n\t\tcin>>s;\n\t\tFOR(i,j) {\n\t\t\tA[j][i]=s[i]=='1';\n\t\t\tA[i][j]=s[i]=='0';\n\t\t}\n\t}\n\t\n\tMINUS(win);\n\tMINUS(dp);\n\tint ret=0;\n\tFOR(i,N) if(hoge(0,i,1)&&hoge(i,N-1,0)) ret++;\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  constexpr size_t max = 2002;\n  auto a = std::vector<std::bitset<max>>(n + 2);\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a[i][j] = k;\n    a[j][i] = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::bitset<max>>(n + 2);\n  for (size_t i = 0; i <= n; i++) dp[i][i + 1] = dp[i + 1][i] = true;\n  for (size_t d = 2; d <= n + 1; d++) {\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      bool tmp = false;\n      for (size_t k = i + 1; k < j; k++) {\n        tmp |= dp[i][k] & dp[j][k] & (a[i][k] | a[j][k]);\n      }\n      dp[j][i] = dp[i][j] = tmp;\n    }\n  }\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp[0][i] & dp[i][n + 1]) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\nusing namespace std;\n#define vel vector<long long>\n#define vvel vector<vel>\n#define int long long\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\nlong long p = 1000003;\nvel kai(1000007, 1);\nvel ink(1000007, 1);\ntemplate<typename T>\nV<T> uni(V<T> &list) {\n\tif (list.size() == 0) { return list; }\n\tsort(list.begin(), list.end());\n\tV<T> ql(1, list[0]);\n\trep(i, list.size() - 1) {\n\t\tif (list[i] != list[i + 1]) { ql.push_back(list[i + 1]); }\n\t}\n\treturn ql;\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; ans %= p; }\n\treturn ans;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, 1000006) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, 1000007) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p;\n\treturn ans;\n}\nsigned main() {\n\tint n; cin >> n;\n\tvvel way(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s; cin >> s;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tway[j].push_back(i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, n) {\n\t\tqueue<int> q;\n\t\tq.push(i);\n\t\tint num = 0;\n\t\tV<bool> seen(n, false); seen[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint st = q.front(); q.pop();\n\t\t\tnum++;\n\t\t\trep(i, way[st].size()) {\n\t\t\t\tint to = way[st][i];\n\t\t\t\tif (!seen[to]) {\n\t\t\t\t\tseen[to] = true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num == n) { ans++; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\n\nstruct P\n{\n\tint A, B;\n\tP(int a, int b) : A(a), B(b) {}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<bool> m(N * N);\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor (int j = 0; j < i; j++) m[N * j + i] = !(m[N * i + j] = S[j] == '1');\n\t}\n\tdeque<bool> dp(N * N, false);\n\tfor (int i = 0; i < N - 1; i++) dp[N * i + i + 1] = true;\n\tfor (int l = 2; l < N; l++)\n\t\tfor (int i = 0; i + l < N; i++)\n\t\t{\n\t\t\tint p = N * i + i + l;\n\t\t\tfor (int k = i + 1, q = N * i + k, r = N * (i + l) + k, s = N * k + i + l; k < i + l; k++, q++, r++, s += N)\n\t\t\t\tif (dp[p] |= dp[q] & (m[q] | m[r]) & dp[s]) break;\n\t\t}\n\tdeque<bool> dpL(N, false);\n\tdpL[N - 1] = true;\n\tfor (int i = N - 2; i >= 0; i--)\n\t\tfor (int j = i + 1; j < N; j++) dpL[i] |= m[N * i + j] & dpL[j] & dp[N * i + j];\n\tdeque<bool> dpR(N, false);\n\tdpR[0] = true;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 0; j < i; j++) dpR[i] |= m[N * i + j] & dpR[j] & dp[N * j + i];\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tif (dpL[i] & dpR[i]) ans++;\n\tcout << ans << endl;\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=2005;\nint n;\nint a[N][N];\nbool fl[N][N],fr[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t\tscanf(\"%1d\",&a[i][j]),a[j][i]=a[i][j]^1;\n\tfor(int i=1;i<=n;i++)\n\t\tfl[i][i]=fr[i][i]=true;\n\tfor(int len=2;len<=n;len++)\n\t\tfor(int i=1;i+len-1<=n;i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tfor(int k=i+1;k<=j;k++)\n\t\t\t\tif(a[i][k])\n\t\t\t\t{\n\t\t\t\t\tfl[i][j]|=fr[i+1][k]&fl[k][j];\n\t\t\t\t\tif(fl[i][j]) break;\n\t\t\t\t}\n\t\t\tfor(int k=i;k<=j-1;k++)\n\t\t\t\tif(a[j][k])\n\t\t\t\t{\n\t\t\t\t\tfr[i][j]|=fr[i][k]&fl[k][j-1];\n\t\t\t\t\tif(fr[i][j]) break;\n\t\t\t\t}\n\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(fr[1][i]&&fl[i][n]) ans++;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// はは〜ん！！この問題Pythonで解かせる気無いな〜\n// 無知だからC++のコンパイラのインストールから初めて大変だったんだぞ〜\n\n#include <iostream>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\nconst int SIZE = 2000;\nbitset<SIZE> A[SIZE];\nbitset<SIZE> dpl[SIZE];\nbitset<SIZE> dpr[SIZE];\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        dpl[i][i] = 1;\n        dpr[i][i] = 1;\n    }\n\n    for (int i = 1; i < N; i++) {\n        string a;\n        cin >> a;\n        for (int j = 0; j < i; j++) {\n            if (a[j] == '1') {\n                A[i][j] = 1;\n            } else {\n                A[j][i] = 1;\n            }\n        }\n    }\n\n    for (int dist = 1; dist < N; dist++) {\n        for (int i = 0; i < N - dist; i++) {\n            int j = i + dist;\n            if ((A[i] & dpl[i+1] & dpr[j]).any()) {\n                dpr[j][i] = 1;\n            }\n            if ((A[j] & dpl[i] & dpr[j-1]).any()) {\n                dpl[i][j] = 1;\n            }\n        }\n    }\n\n    int ret = (dpl[0] & dpr[N-1]).count();\n    cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr int Nmax = 2002;\nint main()\n{\n    int N;\n    cin >> N;\n    vector<bitset<Nmax>> A(N + 2, bitset<Nmax>());\n    FOR(i, 1, N)\n    {\n        string S;\n        cin >> S;\n        REP(j, i)\n        {\n            A[i + 1][j + 1] = S[j] - '0';\n            A[j + 1][i + 1] = !A[i + 1][j + 1];\n        }\n    }\n\n    vector<bitset<Nmax>> ldp(N + 2, bitset<Nmax>()), rdp(N + 2, bitset<Nmax>());\n    REP(i, N + 1) ldp[i][i + 1] = rdp[i + 1][i] = 1;\n\n    FOR(d, 2, N + 1) REP(l, N + 2 - d)\n    {\n        if ((ldp[l] & A[l] & rdp[l + d]).any()) ldp[l][l + d] = rdp[l + d][l] = 1;\n        if ((ldp[l] & rdp[l + d] & A[l + d]).any()) rdp[l + d][l] = ldp[l][l + d] = 1;\n    }\n\n    int ret = (ldp[0] & rdp[N + 1]).count();\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2020;\nusing bset = bitset<maxn>;\nbool dpl[maxn][maxn], dpr[maxn][maxn];\nbset beat[maxn], beatl[maxn], beatr[maxn], pl[maxn];\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tchar c; cin >> c;\n\t\t\tif(c == '1') beat[i][j] = 1;\n\t\t\telse beat[j][i] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tpl[i] = pl[i - 1];\n\t\tpl[i].set(i - 1);\n\t}\n\tfor(int i = 0; i < n; i++) dpl[i][i] = 1, dpr[i][i] = 1, beatl[i][i] = 1, beatr[i][i] = 1;\n\tfor(int i = 2; i <= n; i++){\n\t\tfor(int j = 0; j + i - 1 < n; j++){\n\t\t\tint from = j, to = j + i - 1;\n\t\t\tbset fr = beatr[from + 1];\n\t\t\tbset bk = beatl[to];\n\t\t\tbset now = beat[from];\n\t\t\tnow &= fr;\n\t\t\tnow &= bk;\n\t\t\tnow >>= from + 1;\n\t\t\tnow &= pl[i - 1];\n\t\t\tif(now.any()){\n\t\t\t\tdpl[from][to] = 1;\n\t\t\t\tbeatl[to][from] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int j = n - 1; j - i + 1 >= 0; j--){\n\t\t\tint from = j, to = j - i + 1;\n\t\t\tbset fr = beatr[to];\n\t\t\tbset bk = beatl[from - 1];\n\t\t\tbset now = beat[from];\n\t\t\tnow &= bk;\n\t\t\tnow &= fr;\n\t\t\tnow >>= to;\n\t\t\tnow &= pl[i - 1];\n\t\t\tif(now.any()){\t\t\n\t\t\t\tdpr[from][to] = 1;\n\t\t\t\tbeatr[to][from] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++) if(dpr[i][0] && dpl[i][n - 1]) ans++;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\nbool dp2[MX][MX]={};\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    for(int i=0;i<n;i++){\n        dp[i][i]=dp2[i][i]=true;\n        for(int j=0;j<i;j++){\n            scanf(\" %c\",&c);\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            for(int k=j+1;k<=R;k++){\n                dp2[R][j]|=A[j][k] & dp[l][k] & dp2[R][k];\n            }\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            for(int k=R;k<j;k++){\n                dp[R][j]|=A[j][k] & dp2[l][k] & dp[R][k];\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] & dp2[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\ntypedef long long ll;\n\nbool g[2005][2005];\nbool dp1[2005][2005]; // dp1[i][j]: [i,j]でjが勝てる\nbool dp2[2005][2005]; // dp2[j][i]: [i,j]でiが勝てる\n\nchar buf[3000];\nint main(void) {\n  int n = 2000;\n  scanf(\"%d\", &n);\n  REP(i, n-1) {\n    scanf(\"%s\", buf);\n    REP(j, i+1) {\n      bool b;\n      b = buf[j] == '1';\n      g[i+1][j] = b;\n      g[j][i+1] = !b;\n    }\n  }\n  REP(i, n) {\n    g[i][i] = true;\n    dp1[i][i] = true;\n    dp2[i][i] = true;\n  }\n  for(int d = 1; d < n; ++d) {\n    REP(i, n-d) {\n      int j = i + d;\n      bool f1 = false;\n      bool f2 = false;\n      for(int k = i; k < j; ++k) {\n        f1 |= g[j][k] & dp1[i][k] & dp2[j-1][k];\n      }\n      for(int k = i+1; k <= j; ++k) {\n        f2 |= g[i][k] & dp1[i+1][k] & dp2[j][k];\n      }\n      dp1[i][j] = f1;\n      dp2[j][i] = f2;\n    }\n  }\n  int res = 0;\n  REP(i, n) {\n    if(dp1[0][i] & dp2[n-1][i]) {\n      ++res;\n    }\n  }\n  \n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, A[2009][2009], L[2009], R[2009];\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tA[i][j] = (c - '0'); A[j][i] = (A[i][j] ^ 1);\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) { L[i] = i; R[i] = i; }\n\tfor (int i = 0; i < 200; i++) {\n\t\tfor (int j = 1; j < N; j++) {\n\t\t\tfor (int k = 1; k <= N - j; k++) {\n\t\t\t\tint l = k + j;\n\t\t\t\tif (R[k] + 1 >= L[l]) {\n\t\t\t\t\tif (A[k][l] == 1) R[k] = max(R[k], R[l]);\n\t\t\t\t\tif (A[k][l] == 0) L[l] = min(L[l], L[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (L[i] == 1 && R[i] == N) cnt++;\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool m[2020][2020];\nbool dp[2][2020][2020];\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tchar z;\n\t\t\tscanf(\" %c\", &z);\n\t\t\tbool t = z - '0';\n\t\t\tm[i][j] = t, m[j][i] = !t;\n\t\t}\n\t}\n\tfor (int i = 0; i < num; i++)dp[0][i][i] = dp[1][i][i] = true;\n\tfor (int k = 1; k < num; k++)\n\t{\n\t\tfor (int i = 0; i < num - k; i++)\n\t\t{\n\t\t\tint j = i + k;\n\t\t\tbool f1 = false, f2 = false;\n\t\t\tfor (int l = i; l < j; l++)f1 |= dp[1][i][l] & dp[0][j - 1][l] & m[j][l];\n\t\t\tfor (int l = i + 1; l <= j; l++)f2 |= dp[1][i + 1][l] & dp[0][j][l] & m[i][l];\n\t\t\tdp[0][j][i] = f2, dp[1][i][j] = f1;\n\t\t}\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < num; i++)c += dp[1][0][i] & dp[0][num - 1][i];\n\tprintf(\"%d\\n\", c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MAXN = 2048;\nusing func = bitset<MAXN>;\nusing vf = vector<func>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    vf beat(N + 1);\n    for (int j = 2; j <= N; j++) {\n        string str;\n        cin >> str;\n        for (int i = 1; i < j; i++) {\n            beat[j][i] = str[i - 1] == '1';\n            beat[i][j] = str[i - 1] == '0';\n        }\n    }\n    //WATCHC(beat);\n\n    vf meet_ij(N + 1), meet_ji(N + 1);\n    vf lwin_ij(N + 1), lwin_ji(N + 1);\n    vf rwin_ij(N + 1), rwin_ji(N + 1);\n\n    for (int i = 1; i <= N; i++) {\n        lwin_ij[i][i] = lwin_ji[i][i] = true;\n        rwin_ij[i][i] = rwin_ji[i][i-1] = true;\n    }\n\n    for (int len = 2; len <= N; len++) {\n        for (int i = 1; i + len - 1 <= N; i++) {\n            int j = i + len - 1;\n\n            meet_ij[i][j] = (lwin_ij[i] & rwin_ji[j]).count();\n            meet_ji[j][i] = meet_ij[i][j];\n\n            lwin_ij[i][j] = (beat[i] & meet_ij[i] & lwin_ji[j]).count();\n            lwin_ji[j][i] = lwin_ij[i][j];\n\n            rwin_ij[i][j] = (beat[j] & meet_ji[j] & rwin_ij[i]).count();\n            rwin_ji[j][i-1] = rwin_ij[i][j];\n\n            /*cout << \"Processed interval [\" << i << \", \" << j << \"]\\n\";\n            WATCH(meet_ij[i][j]);\n            WATCH(lwin_ij[i][j]);\n            WATCH(rwin_ij[i][j]);*/\n        }\n    }\n\n    int ans = 0;\n    for (int ch = 1; ch <= N; ch++) {\n        if (rwin_ji[ch][0] && lwin_ij[ch][N])\n            ans++;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst int N=1005;\nbool a[N][N],f[N][N],g[N][N];\nint ans,n;\n\nsigned main(){\n\tread(n);\n\tfor(int i=2;i<=n;i++) for(int j=1;j<i;j++) scanf(\"%1d\",&a[i][j]),a[j][i]=!a[i][j];\n\tfor(int i=1;i<=n;i++) f[i][i]=g[i][i]=1;\n\tfor(int len=2;len<=n;len++) for(int l=1,r=len;r<=n;l++,r++){\n\t\tfor(int k=l+1;k<=r;k++) f[l][r]|=g[l+1][k]&f[k][r]&a[l][k];\n\t\tfor(int k=l;k<r;k++) g[l][r]|=g[l][k]&f[k][r-1]&a[r][k];\n\t}\n\tfor(int i=1;i<=n;i++) ans+=g[1][i]&f[i][n];\n\twrite(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst long long int MOD = 1000003;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass XorShift {\n\tunsigned int x, y, z, w, t;\npublic:\n\tXorShift() {\n\t\tx = 133553533;\n\t\ty = 314867339;\n\t\tz = 664298413;\n\t\tw = 999999937;\n\t\tt = 0;\n\t}\n\tunsigned int rand() {\n\t\tt = x ^ (x << 11);\n\t\tx = y;\n\t\ty = z;\n\t\tz = w;\n\t\tw = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n\t\treturn w & 0x7fffffff;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>v(N, vector<int>(N));\n\tfor (int i = 1; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (s[j] == '1')v[i][j] = 1;\n\t\t\tv[j][i] = v[i][j] ^ 1;\n\t\t}\n\t}\n\tset<int>cand;\n\tXorShift xs;\n\tfor (int i = 0; i < 1000; i++) {\n\t//\tcout << i << endl;\n\t\tvector<int>w(N);\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tw[j] = j;\n\t\t}\n\t\twhile (w.size() > 1) {\n\t\t\tint nx = xs.rand() % (w.size() - 1);\n\t\t\tif (v[w[nx]][w[nx + 1]])w.erase(w.begin() + nx + 1);\n\t\t\telse w.erase(w.begin() + nx);\n\t\t}\n\t\tcand.insert(w.front());\n\t}\n\t//for (auto i : cand)cout << i << endl;\n\tvector<int>w(N);\n\tfor (auto i : cand)w[i] = 1;\n\tcout << cand.size() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : F2.cpp\n * Author  : Kazune Takahashi\n * Created : 2019-6-2 00:47:04\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\nbool dp_L[2010][2010];\nbool dp_R[2010][2010];\nbool W[2010][2010];\n\nint main()\n{\n  int N;\n  cin >> N;\n  for (auto i = 1; i < N; i++)\n  {\n    string S;\n    cin >> S;\n    for (auto j = 0; j < i; j++)\n    {\n      if (S[j] == '1')\n      {\n        W[i][j] = true;\n        W[j][i] = false;\n      }\n      else\n      {\n        W[i][j] = false;\n        W[j][i] = true;\n      }\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    dp_L[i][i] = true;\n    dp_R[i][i] = true;\n  }\n  for (auto n = 1; n < N; n++)\n  {\n    for (auto a = 0; a + n < N; a++)\n    {\n      int b = a + n;\n      dp_L[a][b] = false;\n      for (auto c = a + 1; c < b; c++)\n      {\n        if (dp_L[a][c] && dp_L[c][b])\n        {\n          dp_L[a][b] = true;\n          break;\n        }\n      }\n      if (!dp_L[a][b] && W[a][b])\n      {\n        for (auto c = a; c < b; c++)\n        {\n          if (dp_L[a][c] && dp_R[c + 1][b])\n          {\n            dp_L[a][b] = true;\n            break;\n          }\n        }\n      }\n      dp_R[a][b] = false;\n      for (auto c = a + 1; c < b; c++)\n      {\n        if (dp_R[a][c] && dp_R[c][b])\n        {\n          dp_R[a][b] = true;\n          break;\n        }\n      }\n      if (!dp_R[a][b] && W[b][a])\n      {\n        for (auto c = a; c < b; c++)\n        {\n          if (dp_L[a][c] && dp_R[c + 1][b])\n          {\n            dp_R[a][b] = true;\n            break;\n          }\n        }\n      }\n#if DEBUG == 1\n      cerr << \"dp_L[\" << a << \"][\" << b << \"] = \" << dp_L[a][b] << endl;\n      cerr << \"dp_R[\" << a << \"][\" << b << \"] = \" << dp_R[a][b] << endl;\n#endif\n    }\n  }\n  int ans = 0;\n  for (auto i = 0; i < N; i++)\n  {\n    if (dp_R[0][i] && dp_L[i][N - 1])\n    {\n      ans++;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[2020][2020];\n\nbool win[2020][2020][2];\nbool dp[2020][2020];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(j=1;j<N;j++) {\n\t\tcin>>s;\n\t\tFOR(i,j) {\n\t\t\tA[j][i]=s[i]=='1';\n\t\t\tA[i][j]=s[i]=='0';\n\t\t}\n\t}\n\t\n\tFOR(x,N) win[x][x][0]=win[x][x][1]=1;\n\tfor(l=2;l<=N;l++) {\n\t\tfor(x=0;x+l<=N;x++) {\n\t\t\ty=x+l-1;\n\t\t\tfor(i=x;i<y && dp[x][y]==0;i++) dp[x][y] |= win[x][i][0]&win[i+1][y][1];\n\t\t\tfor(i=x+1;i<=y && win[x][y][0]==0;i++) win[x][y][0] |= A[x][i] & dp[x][i] & win[i][y][0];\n\t\t\tfor(i=x;i<=y-1 && win[x][y][1]==0;i++) win[x][y][1] |= A[y][i] & dp[i][y] & win[x][i][1];\n\t\t}\n\t}\n\tint ret=0;\n\tFOR(i,N) {\n\t\tret+=win[0][i][1]&win[i][N-1][0];\n\t}\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define MAX_N 2003\nint A[MAX_N][MAX_N];\nbitset<MAX_N> dpR[MAX_N], dpL[MAX_N];\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 2; i <= N; ++i) {\n        for (int j = 1; j < i; ++j) {\n            char c;\n            cin >> c;\n            A[i][j] = c - '0';\n            A[j][i] = A[i][j] ^ 1;\n        }\n    }\n\n\n    for (int i = 1; i <= N; ++i) {\n        dpR[i][i] = dpL[i][i] = 1;\n        for (int j = 1; j < i; ++j) {\n            /*\n             * 先にdpRを更新, 以下を bitset で\n            for (int k = 1; k <= j; ++k) {\n                if(dpR[j][k] && dpL[i-1][j] && A[i][j]) dpR[i][k] = 1;\n            }\n             */\n            if (dpL[i-1][j] && A[i][j]) dpR[i] |= dpR[j];\n        }\n        for (int j = 1; j < i; ++j) {\n            /*\n            for (int k = 1; k <= j; ++k) {\n                if(dpR[i][j+1] && dpL[j][k] && A[j][i]) dpL[i][k] = 1;\n            }\n             */\n            if (dpR[i][j+1] && A[j][i]) dpL[i] |= dpL[j];\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 1; i <= N; ++i) {\n        ans += dpR[i][1] && dpL[N][i];\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=2005;\nint n;\nint a[N][N];\nbool fl[N][N],fr[N][N];\nvector<int>pos[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t\tscanf(\"%1d\",&a[i][j]),a[j][i]=a[i][j]^1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i][j]) pos[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t\tfl[i][i]=fr[i][i]=true;\n\tfor(int len=2;len<=n;len++)\n\t\tfor(int i=1;i+len-1<=n;i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tint l=lower_bound(pos[i].begin(),pos[i].end(),i+1)-pos[i].begin(),r=upper_bound(pos[i].begin(),pos[i].end(),j)-pos[i].begin()-1;\n\t\t\tfor(int p=l;p<=r;p++)\n\t\t\t{\n\t\t\t\tint k=pos[i][p];\n\t\t\t\tfl[i][j]|=fr[i+1][k]&fl[k][j];\n\t\t\t\tif(fl[i][j]) break;\n\t\t\t}\n\t\t\tl=lower_bound(pos[j].begin(),pos[j].end(),i)-pos[j].begin(),r=upper_bound(pos[j].begin(),pos[j].end(),j-1)-pos[j].begin()-1;\n\t\t\tfor(int p=l;p<=r;p++)\n\t\t\t{\n\t\t\t\tint k=pos[j][p];\n\t\t\t\tfr[i][j]|=fr[i][k]&fl[k][j-1];\n\t\t\t\tif(fr[i][j]) break;\n\t\t\t}\n\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(fr[1][i]&&fl[i][n]) ans++;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000003;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tint n,i,j,k;cin>>n;\n\tvector<bitset<2000>>towin(n);\n\tfor(i=1;i<n;i++){\n\t\tstring str;cin>>str;\n\t\tfor(j=0;j<i;j++){\n\t\t\tif(str[j]=='1'){towin[i][j]=1;}\n\t\t\telse{towin[j][i]=1;}\n\t\t}\n\t}\n\tvector<bitset<2001>>Lwin(n);//どこまで勝てるか 自分より小さい側\n\tvector<bitset<2001>>Rwin(n);//どこまで勝てるか 自分より大きい側\n\tfor(i=0;i<n;i++){\n\t\tLwin[i][i]=1;\n\t\tRwin[i][i+1]=1;\n\t\tbitset<2001>cha;\n\t\tfor(j=i-1;j>=0;j--){\n\t\t\tif(towin[i][j]&&((Lwin[i]&Rwin[j]).any()))\n\t\t\t\t{Lwin[i]|=Lwin[j];}\n\t\t\tif(((cha&Rwin[j]).any())||(towin[j][i]&&((Lwin[i]&Rwin[j]).any())))\n\t\t\t\t{Rwin[j][i+1]=1;cha[j+1]=1;}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(i=0;i<n;i++){\n\t\t/*for(j=0;j<=n;j++){\n\t\t\tif(Lwin[i][j]||Rwin[i][j]){cerr<<'1';}\n\t\t\telse{cerr<<'0';}\n\t\t}\n\t\tcerr<<endl;*/\n\t\tif(Lwin[i][0]&&Rwin[i][n]){ans++;}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000003;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nvector<int> G[2000];\nbool b[2000];\nvoid solve() {\n\tint n; cin >> n;\n\trep1(i, n - 1) {\n\t\trep(j, i) {\n\t\t\tchar t; cin >> t;\n\t\t\tif (t == '1') {\n\t\t\t\tG[i].push_back(j);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, n) {\n\t\t//left\n\t\tif (i > 0) {\n\t\t\tint cnt = 0;\n\t\t\tfill(b, b + n, false);\n\t\t\tqueue<int> q; q.push(i);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint id = q.front(); q.pop();\n\t\t\t\trep(j, G[id].size()) {\n\t\t\t\t\tint to = G[id][j];\n\t\t\t\t\tif (to >= i)break;\n\t\t\t\t\tif (b[to])continue;\n\t\t\t\t\tb[to] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << cnt << endl;\n\t\t\tif (cnt != i)continue;\n\t\t}\n\t\t//right\n\t\tif (i < n - 1) {\n\t\t\tint cnt = 0;\n\t\t\tfill(b, b + n, false);\n\t\t\tqueue<int> q; q.push(i);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint id = q.front(); q.pop();\n\t\t\t\tper(j, (int)G[id].size()) {\n\t\t\t\t\tint to = G[id][j];\n\t\t\t\t\tif (to <= i)break;\n\t\t\t\t\tif (b[to])continue;\n\t\t\t\t\tb[to] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << cnt << endl;\n\t\t\tif (cnt != n-1-i)continue;\n\t\t}\n\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1000000000000037 ;\nconst ll base = 127;\nusing ld=bool;\n\nld prob[2020][2020];\nint dpl[2020],dpr[2020];\ninline bool chmax(int& x,int y){\n    if(x<y){\n        x=y;return true;\n    }\n    return false;\n}\ninline bool chmin(int& x,int y){\n    if(x>y){\n        x=y;return true;\n    }\n    return false;\n}\nint main(){\n    int n;\n    cin>>n;\n    string s[n-1];\n    rep(i,n-1){\n        cin>>s[i];\n        rep(j,i+1){\n            if(s[i][j]=='1')prob[i+1][j]=1,prob[j][i+1]=0;\n            else prob[i+1][j]=0,prob[j][i+1]=1;\n        }\n    }\n    rep(i,n)prob[i][i]=1;\n    rep(i,n)dpl[i]=dpr[i]=i;\n    while(1){\n        bool update=false;\n        for(int i=n-1;i>=0;--i){\n            for(int j=i+1;j<n;j++){\n                if(prob[i][j]&&dpr[i]+1>=dpl[j]){\n                    update|=chmax(dpr[i],dpr[j]);\n                }\n            }\n        }\n        for(int i=0;i<n;++i){\n            for(int j=i-1;j>=0;--j){\n                if(prob[i][j]&&dpl[i]<=dpr[j]+1){\n                    update|=chmin(dpl[i],dpl[j]);\n                }\n            }\n        }\n        for(int i=n-1;i>=0;--i){\n            for(int j=i+1;j<n;j++){\n                if(prob[i][j]&&dpr[i]+1>=dpl[j]){\n                    update|=chmax(dpr[i],dpr[j]);\n                }\n            }\n        }\n        for(int i=0;i<n;++i){\n            for(int j=i-1;j>=0;--j){\n                if(prob[i][j]&&dpl[i]<=dpr[j]+1){\n                    update|=chmin(dpl[i],dpl[j]);\n                }\n            }\n        }\n        if(!update)break;\n    }\n    int ans=0;\n    rep(i,n)ans+=(dpl[i]==0&&dpr[i]==n-1);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 2020;\nbool a[MAX][MAX]={};\nbool dpL[MAX][MAX]={};\nbool dpR[MAX][MAX]={};\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    dpL[i][i]=dpR[i][i]=1; \n\n  for(int w=2;w<=n;w++){\n    {\n      int l=0,r=w-1;\n      for(int k=l;k<r;k++)\n        dpR[l][r]|=dpR[l][k]&dpL[r-1][k]&a[r][k];    \n    }    \n    for(int i=1;i+w<=n+1;i++){\n      int l=i,r=i+w-1;\n      for(int k=l;k<r;k++){\n        dpL[r-1][l-1]|=dpR[l][k]&dpL[r-1][k]&a[l-1][k];        \n        dpR[l][r]|=dpR[l][k]&dpL[r-1][k]&a[r][k];\n      }\n    }\n  }\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    if(dpR[0][i]&dpL[n-1][i]) ans++;  \n  cout<<ans<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,a[2005][2005];\nbitset<2005>win[2005];\nbitset<2005>dp[2][2005];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\ta[j][i] = 1-a[i][j];\n\t\t}\n\t}\n\trepn(i,n) repn(j,n) win[i][j] = a[i][j];\n\trepn(i,n){\n\t\tdp[0][i][i] = 1;\n\t\tdp[1][i][i] = 1;\n\t}\n\tfor(int L=2;L<=n;L++){\n\t\tfor(int i=1;i+L-1<=n;i++){\n\t\t\t//dp[0][i][i+L-1]\n\t\t\tbool f = !!(win[i]&dp[1][i+1]&dp[0][i+L-1]).count();\n\t\t\tif(f) dp[0][i+L-1][i] = 1;\n\t\t\t//dp[1][i][i+L-1]\n\t\t\tf = !!(win[i+L-1]&dp[1][i]&dp[0][i+L-2]).count();\n\t\t\tif(f) dp[1][i][i+L-1] = 1;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(dp[1][1][i] && dp[0][n][i]) ans++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _dbg(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _dbg(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_dbg(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\nconst int N=2001;\nusing bt=bitset<N>;\nbt a[N],win[N],sto[N];\nint32_t main() {\n    int n;\n    cin>>n;\n    forn(i,n){\n        forn(j,i){\n            char c;\n            cin>>c;\n            a[i][j]=c-'0';\n            a[j][i]=a[i][j]^1;\n        }\n        win[i].set(i);\n        sto[i].set(i);\n    }\n    for(int len=2;len<=n;++len){\n        for(int i=0;i+len-1<n;++i){\n            int r=i+len-1;\n            if(a[i][r]){\n                if((win[i]&(win[r]>>1)).any()){\n                    win[i].set(r);\n                    sto[r].set(i);\n                }\n            }\n            if((a[i]&win[i]&sto[r]).any()){\n                win[i].set(r);\n                sto[r].set(i);\n            }\n        }\n        for(int i=len-1;i<n;++i){\n            int l=i-len+1;\n            if(a[i][l]){\n                if((win[i]&(win[l]<<1)).any()){\n                    win[i].set(l);\n                    sto[l].set(i);\n                }\n            }\n            if((a[i]&win[i]&sto[l]).any()){\n                win[i].set(l);\n                sto[l].set(i);                \n            }\n        }\n    }\n    int ans=0;\n    forn(i,n){\n        ans+=(win[i][0]&win[i][n-1]);\n    }\n    cout<<ans<<'\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool m[2020][2020];\nbool dp[2][2020][2020];\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tchar z;\n\t\t\tscanf(\" %c\", &z);\n\t\t\tbool t = z - '0';\n\t\t\tm[i][j] = t, m[j][i] = !t;\n\t\t}\n\t}\n\tfor (int i = 0; i < num; i++)dp[0][i][i] = dp[1][i][i] = true;\n\tfor (int k = 1; k < num; k++)\n\t{\n\t\tfor (int i = 0; i < num - k; i++)\n\t\t{\n\t\t\tint j = i + k;\n\t\t\tbool f1 = false, f2 = false;\n\t\t\tfor (int l = i; l < j; l++)f1 |= dp[1][i][l] & dp[0][j - 1][l] & m[j][l];\n\t\t\tfor (int l = i + 1; l <= j; l++)f2 |= dp[1][i + 1][l] & dp[0][j][l] & m[i][l];\n\t\t\tdp[0][j][i] = f2, dp[1][i][j] = f1;\n\t\t}\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < num; i++)c += dp[1][0][i] & dp[0][num - 1][i];\n\tprintf(\"%d\\n\", c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\n\tint ind = lower_bound(wn[r].begin(), wn[r].end(), l) - wn[r].begin();\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = lower_bound(wn[l].begin(), wn[l].end(), l) - wn[l].begin();\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long maxN = 2000;\n    unsigned long N;\n    cin >> N;\n    vector<vector<bitset<maxN>>> dp(N);\n    vector<bitset<maxN>> tapi(N);\n    for(unsigned long i = 1; i < N; ++i){\n        string s;\n        cin >> s;\n        for(unsigned long j = 0; j < i; ++j){\n            tapi[i][j] = (s[j] == '1');\n            tapi[j][i] = (s[j] == '0');\n        }\n    }\n    for(unsigned long i = 0; i < N; ++i){\n        dp[i] = vector<bitset<maxN>>(N - i);\n        dp[i][0][i] = true;\n    }\n    for(unsigned long i = 1; i < N; ++i)for(unsigned long j = 0; j + i < N; ++j){\n        if((dp[j + 1][i - 1] & tapi[j]).any())dp[j][i][j] = true;\n        if((dp[j][i - 1] & tapi[j + i]).any())dp[j][i][j + i] = true;\n        dp[j][i] |= dp[j + 1][i - 1] & ~tapi[j];\n        dp[j][i] |= dp[j][i - 1] & ~tapi[j + i];\n    }\n    cout << dp[0].back().count() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  auto a = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a.at(i).at(j) = k;\n    a.at(j).at(i) = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  for (size_t i = 0; i <= n; i++) dp.at(i).at(i + 1) = true;\n  auto renew = [&] (size_t d) {\n    assert(2 <= d && d <= n + 1);\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      for (size_t k = i + 1; k < j; k++) {\n        dp.at(i).at(j) |= dp.at(i).at(k) && dp.at(k).at(j) && (a.at(i).at(k) || a.at(j).at(k));\n      }\n    }\n  };\n  for (size_t d = 2; d <= n + 1; d++) renew(d);\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp.at(0).at(i) && dp.at(i).at(n + 1)) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\ntypedef long long ll;\n\nbool g[2005][2005];\nbool dp1[2005][2005]; // dp1[i][j]: [i,j]でjが勝てる\nbool dp2[2005][2005]; // dp2[j][i]: [i,j]でiが勝てる\n\nchar buf[3000];\nint main(void) {\n  int n = 2000;\n  scanf(\"%d\", &n);\n  REP(i, n-1) {\n    scanf(\"%s\", buf);\n    REP(j, i+1) {\n      bool b;\n      b = buf[j] == '1';\n      g[i+1][j] = b;\n      g[j][i+1] = !b;\n    }\n  }\n  REP(i, n) {\n    g[i][i] = true;\n    dp1[i][i] = true;\n    dp2[i][i] = true;\n  }\n  for(int d = 1; d < n; ++d) {\n    REP(i, n-d) {\n      int j = i + d;\n      bool &f1 = dp1[i][j];\n      bool &f2 = dp2[j][i];\n      for(int k = i; k < j; ++k) {\n        f1 |= g[j][k] & dp1[i][k] & dp2[j-1][k];\n      }\n      for(int k = i+1; k <= j; ++k) {\n        f2 |= g[i][k] & dp1[i+1][k] & dp2[j][k];\n      }\n    }\n  }\n  int res = 0;\n  REP(i, n) {\n    if(dp1[0][i] & dp2[n-1][i]) {\n      ++res;\n    }\n  }\n  \n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nbitset<2048> A[2010];\n\nbitset<2048> L[2010]; //left i is reachable from where\nbitset<2048> R[2010]; //right i\nbitset<2048> W[2010]; //i can win where\nint LW[2010][2010]; //left i can win\nint RW[2010][2010];\n\nbitset<2048> range(bitset<2048> bit, int l, int r) {\n\tbit >> l;\n\tbit << l;\n\tbit << (2048 - r - 1);\n\tbit >> (2048 - r - 1);\n\treturn bit;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 1, N) {\n\t\tstring str; cin >> str;\n\t\trep(j, 0, i) {\n\t\t\tA[i][j] = (str[j] == '1');\n\t\t\tA[j][i] = A[i][j] ^ 1;\n\t\t}\n\t}\n\tvector<int> vec;\n\trep(i, 0, N - 1) vec.pb(i);\n\t// set<int> S;\n\t// do {\n\t// \tvector<int> tmp;\n\t// \trep(i, 0, N) tmp.pb(i);\n\t// \tvector<vi> omo;\n\t// \tomo.pb(tmp);\n\t// \trep(i, 0, N - 1) {\n\t// \t\tint a = tmp[vec[i]];\n\t// \t\tint b = tmp[vec[i] + 1];\n\t// \t\tif(A[a][b] == 0) swap(a, b);\n\t// \t\trep(j, 0, N) {\n\t// \t\t\tif(tmp[j] == b) tmp[j] = a;\n\t// \t\t}\n\t// \t\tomo.pb(tmp);\n\t// \t}\n\t// \tif(tmp.front() == 0) {\n\t// \t\tdebug(vec);\n\t// \t\tdebug(omo);\n\t// \t}\n\t// \tS.insert(tmp.front());\n\t// } while(next_permutation(all(vec)));\n\t// cout << sz(S) << \"\\n\";\n\t// debug(vi(all(S)));\n\n\trep(i, 0, N) {\n\t\tLW[i][i] = 1;\n\t\tRW[i][i] = 1;\n\t\tL[i][i] = 1;\n\t\tR[i][i] = 1;\n\t}\n\tbitset<2048> mask;\n\trep(i, 0, N) mask[i] = 1;\n\n\trep(l, 2, N + 1) {\n\t\trep(i, 0, N - l + 1) {\n\t\t\tint j = i + l - 1;\n\n\t\t\t// LW\n\t\t\tauto w = range(A[i], i, j);\n\t\t\tif((w & L[i + 1] & R[j]).any()) LW[i][j] = 1;\n\n\t\t\t// RW\n\t\t\tw = range(A[j], i, j);\n\t\t\tif((w & L[i] & R[j - 1]).any()) RW[i][j] = 1;\n\t\t\t\n\t\t\t// debug(i, j, LW[i][j], RW[i][j]);\n\t\t}\n\t\trep(i, 0, N - l + 1) {\n\t\t\tint j = i + l - 1;\n\t\t\tif(RW[i][j]) L[i][j] = 1;\n\t\t\tif(LW[i][j]) R[j][i] = 1;\n\t\t}\n\t}\n\tint res = 0;\n\trep(i, 0, N) {\n\t\tif(RW[0][i] & LW[i][N - 1]) {\n\t\t\t// debug(i);\n\t\t\tres++;\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=2000;\nint n,res=0;\nbitset<M> dpl[M],dpr[M],L[M],R[M];\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++) for(int j=0;j<i;j++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c=='1') L[i-j][j]=1;\n\t\telse R[i-j][i]=1;\n\t}\n\tfor(int i=0;i<n;i++) dpl[0][i]=dpr[0][i]=1;\n\tfor(int i=1;i<n;i++) for(int j=0;j<i;j++){\n\t\tdpl[i]|=(dpl[j]&dpr[i-j-1]&L[i-j])<<(i-j);\n\t\tdpr[i]|=(dpl[j]&dpr[i-j-1]&R[j+1])>>(j+1);\n\t}\n\tfor(int i=0;i<n;i++) if(dpl[i][i]&&dpr[n-i-1][i]) res++;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst int N=2005;\nbitset<N> a[N],f[N],g[N];\nint ans,n;\n\nsigned main(){\n\tread(n);\n\tfor(int i=2,x;i<=n;i++) for(int j=1;j<i;j++) scanf(\"%1d\",&x),a[i][j]=x,a[j][i]=!x;\n\tfor(int i=1;i<=n;i++) f[i][i]=g[i][i]=1;\n\tfor(int len=2;len<=n;len++) for(int l=1,r=len;r<=n;l++,r++){\n\t\tf[r][l]=(g[l+1]&f[r]&a[l]).count()>0;\n\t\tg[l][r]=(g[l]&f[r-1]&a[r]).count()>0;\n\t}\n\twrite((g[1]&f[n]).count());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\ntypedef long long ll;\n\nbool g[2005][2005];\nint solve1(int bg, int ed);\nint solve2(int bg, int ed);\n\nint memo1[2005][2005];\nint solve1(int bg, int ed) { // この範囲でbgが優勝\n  int& res = memo1[bg][ed];\n  if(res < 0) {\n    if(bg+1 >= ed) {\n      // cerr << \"solve1(\" << bg << \", \" << ed << \") = 1\" << endl;\n      res = 1;\n    } else {\n      res = 0;\n      for(int i = bg+1; i < ed; ++i) {\n        if(g[bg][i] && solve2(bg+1, i+1) == 1 && solve1(i, ed) == 1) {\n          // cerr << \"solve1(\" << bg << \", \" << ed << \") = 1 because \" << i << \" is strong\" << endl;\n          res = 1;\n          break;\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint memo2[2005][2005];\nint solve2(int bg, int ed) { // この範囲でed-1が優勝\n  int& res = memo2[bg][ed];\n  if(res < 0) {\n    if(bg+1 >= ed) {\n      // cerr << \"solve2(\" << bg << \", \" << ed << \") = 1\" << endl;\n      res = 1;\n    } else {\n      res = 0;\n      for(int i = bg; i < ed-1; ++i) {\n        if(g[ed-1][i] && solve2(bg, i+1) == 1 && solve1(i, ed-1) == 1) {\n          res = 1;\n          // cerr << \"solve2(\" << bg << \", \" << ed << \") = 1 because \" << i << \" is strong\" << endl;\n          break;\n        }\n      }\n    }\n  }\n  return res;\n}\n\nchar buf[3000];\nint main(void) {\n  int n;\n  scanf(\"%d\", &n);\n  REP(i, n-1) {\n    scanf(\"%s\", buf);\n    REP(j, i+1) {\n      g[i+1][j] = buf[j] == '1';\n      g[j][i+1] = !g[i+1][j];\n    }\n  }\n  memset(memo1, -1, sizeof memo1);\n  memset(memo2, -1, sizeof memo2);\n  // REP(i, n) {\n  //   REP(j, n) {\n  //     cerr << (g[i][j] ? '1' : '0');\n  //   }\n  //   cerr << endl;\n  // }\n  int res = 0;\n  REP(i, n) {\n    if(solve1(i, n) == 1 && solve2(0, i+1) == 1) {\n      ++res;\n    }\n  }\n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 2005\n\nint n,ans;\nbitset<N> a[N],f[N],g[N];\nchar s[N][N];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=2;i<=n;++i){\n\t\tscanf(\"%s\",s[i]+1);\n\t\tfor (int j=1;j<i;++j){\n\t\t\ta[i][j]=s[i][j]-'0';\n\t\t\ta[j][i]=a[i][j]^1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tf[i][i]=g[i][i]=1;\n\t\tfor (int j=1;j<i;++j)\n\t\t\tif (g[i-1][j]&&a[i][j]) f[i]|=f[j];\n\t\tfor (int j=1;j<i;++j)\n\t\t\tif (f[i][j+1]&&a[j][i]) g[i]|=g[j];\n\t}\n\tfor (int i=1;i<=n;++i) ans+=f[i][1]&&g[n][i];\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=2000;\n\nint n;\nchar s[N+9];\nbitset<N+9>a[N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=2;i<=n;++i){\n\tscanf(\"%s\",s+1);\n\tfor (int j=1;j<i;++j) a[j][i]=(a[i][j]=s[j]-'0')^1;\n  }\n}\n\nbitset<N+9>dp[2][N+9];\n\nvoid Get_dp(){\n  for (int i=1;i<=n;++i) dp[0][i][i]=dp[1][i][i]=1;\n  for (int len=2;len<=n;++len)\n\tfor (int l=1;l+len-1<=n;++l){\n\t  int r=l+len-1;\n\t  if ((a[l]&dp[1][l+1]&dp[0][r]).count()) dp[0][r][l]=1;\n\t  if ((a[r]&dp[1][l]&dp[0][r-1]).count()) dp[1][l][r]=1;\n\t}\n}\n\nvoid work(){\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",(dp[0][n]&dp[1][1]).count());\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbitset<2005> dpl[2005],dpr[2005],g[2005],s[2005];\nint n,i,j,a,l,ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=2;i<=n;++i)\n\t\tfor(j=1;j<i;++j)\n\t\t{\n\t\t\tscanf(\"%1d\",&a);\n\t\t\tg[i][j]=a;\n\t\t\tg[j][i]=a^1;\n\t\t}\n\tfor(i=1;i<=n;++i)\n\t{\n\t\ts[i]=s[i-1];\n\t\ts[i][i]=1;\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tdpl[i][i]=dpr[i][i]=1;\n\tfor(l=1;l<n;++l)\n\t{\n\t\tfor(i=l+1;i<=n;++i)\n\t\t\tdpr[i-l][i]=(dpr[i-l]&dpl[i-1]&(s[i-1]^s[i-l-1])&g[i]).count();\n\t\tfor(i=1;i<=n-l;++i)\n\t\t\tdpl[i+l][i]=(dpl[i+l]&dpr[i+1]&(s[i+l]^s[i])&g[i]).count();\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tif(dpl[n][i]&dpr[1][i])\n\t\t\t++ans;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, res;\nchar c;\nset<int>st[2000];\nset<int>::iterator IT[2000];\n\nbool f(int x, int l, int r) {\n\tif (x == l&&x == r)return true;\n\telse if (x == l) {\n\t\tauto it = IT[x];\n\t\t++it;\n\t\twhile (*it <= r) {\n\t\t\tif (f(*it, x + 1, r))return true;\n\t\t\t++it;\n\t\t}\n\t}\n\telse if (x == r) {\n\t\tauto it = IT[x];\n\t\t--it;\n\t\twhile (*it >= l) {\n\t\t\tif (f(*it, l, x - 1))return true;\n\t\t\t--it;\n\t\t}\n\t}\n\telse {\n\t\tauto it = IT[x];\n\t\tbool F = false;\n\t\t++it;\n\t\twhile (*it <= r) {\n\t\t\tif (f(*it, x + 1, r)) {\n\t\t\t\tF = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++it;\n\t\t}\n\t\tif (F) {\n\t\t\tit = IT[x];\n\t\t\t--it;\n\t\t\twhile (*it >= l) {\n\t\t\t\tif (f(*it, l, x - 1))return true;\n\t\t\t\t--it;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tcin >> c;\n\t\t\tif (c == '1') {\n\t\t\t\tst[i].insert(j);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst[j].insert(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tst[i].insert(-1);\n\t\tIT[i] = st[i].insert(i).first;\n\t\tst[i].insert(N);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tres += f(i, 0, N - 1);\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\n\nstruct P\n{\n\tint A, B;\n\tP(int a, int b) : A(a), B(b) {}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<bool> m(N * N);\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor (int j = 0; j < i; j++) m[N * j + i] = !(m[N * i + j] = S[j] == '1');\n\t}\n\tvector<int> strong, weak, normal;\n\tvector<bool> isnormal(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tint c = 0;\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (m[N * i + j]) c++;\n\t\tif (c == N - 1)\n\t\t\tstrong.push_back(i);\n\t\telse if (c == 0)\n\t\t\tweak.push_back(i);\n\t\telse\n\t\t\tnormal.push_back(i);\n\t\tisnormal[i] = c > 0;\n\t}\n\tif (strong.size())\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tint M = normal.size();\n\tvector<bool> newm(M * M);\n\tfor (int i = 0; i < M; i++)\n\t\tfor (int j = 0; j < M; j++) newm[M * i + j] = m[N * normal[i] + normal[j]];\n\tN = M;\n\tm = newm;\n\tdeque<bool> dp(N * N, false);\n\tfor (int i = 0; i < N - 1; i++) dp[N * i + i + 1] = true;\n\tfor (int l = 2; l < N; l++)\n\t\tfor (int i = 0; i + l < N; i++)\n\t\t{\n\t\t\tint p = N * i + i + l;\n\t\t\tfor (int k = i + 1, q = N * i + k, r = N * (i + l) + k, s = N * k + i + l; k < i + l; k++, q++, r++, s += N)\n\t\t\t\tif (dp[p] |= dp[q] & (m[q] | m[r]) & dp[s]) break;\n\t\t}\n\tdeque<bool> dpL(N, false);\n\tdpL[N - 1] = true;\n\tfor (int i = N - 2; i >= 0; i--)\n\t\tfor (int j = i + 1; j < N; j++) dpL[i] |= m[N * i + j] & dpL[j] & dp[N * i + j];\n\tdeque<bool> dpR(N, false);\n\tdpR[0] = true;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 0; j < i; j++) dpR[i] |= m[N * i + j] & dpR[j] & dp[N * j + i];\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tif (dpL[i] & dpR[i]) ans++;\n\tcout << ans << endl;\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V< bitset<2000> > a(n);\n  for (int i = 1; i < n; ++i) {\n    string s; cin >> s;\n    for (int j = 0; j < i; ++j) {\n      a[i][j] = s[j] == '1';\n      a[j][i] = s[j] == '0';\n    }\n  }\n  V< bitset<2000> > dp(n);\n  for (int i = 0; i < n; ++i) {\n    dp[i][i] = true;\n    if (i) dp[i - 1][i] = a[i][i - 1];\n    if (i + 1 < n) dp[i + 1][i] = a[i][i + 1];\n  }\n  for (int w = 2; w < n; ++w) {\n    for (int i = 0; i < n; ++i) {\n      int j = i + w;\n      if (j < n) {\n        for (int k = i + 1; k <= j; ++k) if (a[i][k] and dp[i + 1][k] and dp[j][k]) {\n          dp[j][i] = true;\n          break;\n        }\n      }\n      j = i - w;\n      if (j >= 0) {\n        for (int k = i - 1; k >= j; --k) if (a[i][k] and dp[i - 1][k] and dp[j][k]) {\n          dp[j][i] = true;\n          break;\n        }\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n; ++i) res += dp[0][i] and dp[n - 1][i];\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    int n;\n    cin >> n;\n    vs a(n-1);\n    rep(i, n-1) cin >> a[i];\n    vector<vector<bool>> win(n, vector<bool>(n));\n    rep1(i, n-1) rep(j, i) {\n        win[i][j] = (a[i-1][j] == '1');\n        win[j][i] = !(a[i-1][j] == '1');\n    }\n    vector<bitset<2000>> dpl(n), dpr(n);\n    dpl[0][0] = dpr[0][0] = true;\n    rep1(i, n-1) dpl[i] = dpr[i] = (dpl[i-1] << 1);\n    rep1(i, n-1) rep(a, n-i) {\n        int b = a + i;\n        bool lok = false;\n        rep1(c, i-1) if (dpl[a].test(a+c) && dpl[a+c].test(b)) lok = true;\n        if (!lok && win[a][b]) {\n            rep(c, i) if (dpl[a].test(a+c) && dpr[a+c+1].test(b)) lok = true;\n        }\n        dpl[a][b] = lok;\n        bool rok = false;\n        rep1(c, i-1) if (dpr[b-c].test(b) && dpr[a].test(b-c)) rok = true;\n        if (!rok && win[b][a]) {\n            rep(c, i) if (dpr[b-c].test(b) && dpl[a].test(b-c-1)) rok = true;\n        }\n        dpr[a][b] = rok;\n    }\n    int ans = 0;\n    rep(i, n) if (dpr[0][i] && dpl[i][n-1]) ++ans;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1000000000000037 ;\nconst ll base = 127;\nusing ld=bool;\n\nld prob[2020][2020];\nint dpl[2020],dpr[2020];\ninline bool chmax(int& x,int y){\n    if(x<y){\n        x=y;return true;\n    }\n    return false;\n}\ninline bool chmin(int& x,int y){\n    if(x>y){\n        x=y;return true;\n    }\n    return false;\n}\nint main(){\n    int n;\n    cin>>n;\n    string s[n-1];\n    rep(i,n-1){\n        cin>>s[i];\n        rep(j,i+1){\n            if(s[i][j]=='1')prob[i+1][j]=1,prob[j][i+1]=0;\n            else prob[i+1][j]=0,prob[j][i+1]=1;\n        }\n    }\n    rep(i,n)prob[i][i]=1;\n    rep(i,n)dpl[i]=dpr[i]=i;\n    while(1){\n        bool update=false;\n        for(int i=n-1;i>=0;--i){\n            for(int j=i+1;j<n;j++){\n                if(prob[i][j]&&dpr[i]+1>=dpl[j]){\n                    update|=chmax(dpr[i],dpr[j]);\n                }\n            }\n        }\n        for(int i=0;i<n;++i){\n            for(int j=i-1;j>=0;--j){\n                if(prob[i][j]&&dpl[i]<=dpr[j]+1){\n                    update|=chmin(dpl[i],dpl[j]);\n                }\n            }\n        }\n        if(!update)break;\n    }\n    int ans=0;\n    rep(i,n)ans+=(dpl[i]==0&&dpr[i]==n-1);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <time.h>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    vector<vector<char>> A(N, vector<char>(N));\n    //static bool A[2048][2048];\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\" %c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<char>> L(N, vector<char>(N));\n    vector<vector<char>> R(N, vector<char>(N));\n    //static bool L[2048][2048];\n    //static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                bool b = false;\n                for (int j=i+1; j<=i+d; j++)\n                    b |= A[i][j] & L[i+d][j] & R[i+1][j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                bool b = false;\n                for (int j=i-d; j<i; j++)\n                    b |= A[i][j] & L[i-1][j] & R[i-d][j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n    cout<<ans<<endl;\n\n    cerr<<(double)clock()/CLOCKS_PER_SEC<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\n#include <bitset>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_N   (2000)\nchar szInput[MAX_N + 1];\nstatic bitset<MAX_N + 1> s_abitMatchTbl[MAX_N + 1];\n\nint main(void)\n{\n    SDWORD lInput_n = inputSDWORD();\n    for (SDWORD lIdxI = 2; lIdxI <= lInput_n; lIdxI++) {\n        inputString(szInput);\n        for (SDWORD lIdxJ = 1; lIdxJ < lIdxI; lIdxJ++) {\n            if ('0' == szInput[lIdxJ - 1]) {\n                s_abitMatchTbl[lIdxJ][lIdxI] = true;\n            }\n        }\n    }\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalMatchTbl[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    static bitset<MAX_N + 1> s_absDpL[MAX_N+1];\n    static bitset<MAX_N + 1> s_absDpR[MAX_N+1];\n\n    for (SDWORD lUpdateWidth = 0; lUpdateWidth <= lInput_n; lUpdateWidth++) {\n        for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n - lUpdateWidth; lUpdIdxL++) {\n            SDWORD lUpdIdxR = lUpdIdxL + lUpdateWidth;\n            if (lUpdIdxL == lUpdIdxR) {\n                s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n            } else {\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A1: [%d, <%d> %d], %d %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalMatchTbl[lUpdIdxL][lUpdIdxR],\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM+1][lUpdIdxR]);\n#endif\n\n                    if (1 == s_abitMatchTbl[lUpdIdxL][lUpdIdxR]) {\n                        if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                            && (1 == s_absDpR[lUpdIdxM+1][lUpdIdxR])) {\n                            s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                        }\n                    } else {\n                        if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                            && (1 == s_absDpR[lUpdIdxM+1][lUpdIdxR])) {\n                            s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                        }\n                    }\n                }\n                for (SDWORD lUpdIdxM = lUpdIdxL + 1; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A2: [%d, <%d> %d], %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpL[lUpdIdxM][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpL[lUpdIdxM][lUpdIdxR])) {\n                        s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                    if ((1 == s_absDpR[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpR[lUpdIdxM][lUpdIdxR])) {\n                        s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpL[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpR[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    /* count winners */\n    SDWORD lAns = 0;\n    for (SDWORD lMid = 1; lMid <= lInput_n; lMid++) {\n        if (s_absDpR[1][lMid] && s_absDpL[lMid][lInput_n]) {\n            lAns++;\n        }\n    }\n\n    printf(\"%d\\n\", lAns);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n[m-solutions2019] F - Random Tournament\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n\nconst int MAX_N = 2000;\n\nint N;\nbitset<MAX_N> A[MAX_N];\n\nbitset<MAX_N> dpl[MAX_N], dpr[MAX_N];\n\nll solve() {\n    for (int i = 0; i < N; i++) {\n        dpl[i][i] = dpr[i][i] = true;\n    }\n    for (int l = 1; l < N; l++) {\n        for (int i = 0; i + l < N; i++) {\n            int j = i + l;\n            dpl[j][i] = (A[i] & dpl[j] & dpr[i + 1]).any();\n        }\n        for (int j = l; j < N; j++) {\n            int i = j - l;\n            dpr[i][j] = (A[j] & dpr[i] & dpl[j - 1]).any();\n        }\n    }\n\n    int ans = (dpr[0] & dpl[N - 1]).count();\n    return ans;\n}\n\nint main() {\n    cin >> N;\n    for (int i = 1; i < N; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < i; j++) {\n            A[i][j] = s[j] == '1';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nbitset<N> L[N], R[N], A[N];\nint n;\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> A[i][j];\n\tfor (int i = 1; i <= n; i++) for (int j = i; j <= n; j++){\n\t\tLR[i][j] = LR[i][j - 1];\n\t\tLR[i][j] = 1;\n\t}\n\t\n\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint win[2001][2001];\nint dpl[2001][2001], dpr[2001][2001];\nsigned main() {\n    int N; cin >> N;\n    if(N > 600) return 1;\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            int p = c - '0';\n            win[i][j] = p;\n            win[j][i] = 1 - p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dpl[i][i] = dpr[i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            for(int k=i; k<=j; k++) {\n                if(k > i and win[i][k] and dpl[k][j] and dpr[k][i+1]) dpl[i][j] = true;\n                if(k < j and win[j][k] and dpr[k][i] and dpl[k][j-1]) dpr[j][i] = true;\n                \n            }\n            // fprintf(stderr, \"dpl[%lld][%lld] = %lld, dpr[%lld][%lld] = %lld\\n\", i, j, dpl[i][j], j, i, dpr[j][i]);\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dpl[i][N-1] and dpr[i][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <array>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000003;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 2000, M = 32;\n\nchar b[N];\nuint64_t db[N][M], eb[N][M], a[N][M], foo[M];\n\ninline void Set(uint64_t A[], int i) {\n\tA[i >> 6] |= 1LL << (i & 63);\n}\nint Get(uint64_t A[], int i) {\n\treturn A[i >> 6] & 1LL << (i & 63);\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n; ni(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%s\", b);\n\t\tF(j, i) {\n\t\t\tif (b[j] == '1')Set(a[i], j);\n\t\t\telse Set(a[j], i);\n\t\t}\n\t}\n\tfor (int i = n; i--;) for (int j = i; j < n; j++) {\n\t\tif (i == j) {\n\t\t\tSet(db[i], i);\n\t\t\tSet(eb[i], i);\n\t\t\tcontinue;\n\t\t}\n\t\tbool good = false;\n\t\tF(k, M) {\n\t\t\tif (a[i][k] & db[j][k] & eb[i + 1][k]) {\n\t\t\t\tgood = true; break;\n\t\t\t}\n\t\t}\n\t\tif (good)Set(db[j], i);\n\t\tgood = false;\n\t\tF(k, M) {\n\t\t\tif (a[j][k] & db[j - 1][k] & eb[i][k]) {\n\t\t\t\tgood = true; break;\n\t\t\t}\n\t\t}\n\t\tif (good)Set(eb[i], j);\n\t}\n\tint ans = 0;\n  \tF(i, M) {\n     \tans += __builtin_popcountll(eb[0][i] & db[n-1][i]); \n    }\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n设F[l][r][0 / 1]表示只考虑区间[l, r]中的人，l / r能否最终活下来\n如果x可以获得最终的胜利，那么可以发现1 ~ x和x ~ N中的战斗是独立互不干扰的，所以只要F[1][x][1] = F[x][N][0] = 1即可\n考虑转移。以F[l][r][1]为例，即r最后获胜的情况。假设最后一次发生的战斗是x和r之间的，分情况讨论：\n(1)x = l。这时候需要有A[r][l] = 1，同时一定存在一个l <= mid <= r - 1，使得F[l][mid][0] = F[mid + 1][r][1] = 1\n(2)l + 1 <= x <= r - 1，那么同样可以分成两个过程。这样需要有F[l][x][0] = F[x][r][1] = 1\n   （事实上，这是最后一次发生战斗是x和r之间同时合法的必要不充分条件。但是只要满足该条件，F[l][r][1]一定为1，就可以不管了）\n这个区间dp可以用压位加速 \n*/\n#include <bitset>\n#include <cstdio>\n\nusing namespace std;\nconst int Max_N(2050);\n\nint N, A[Max_N][Max_N], F[Max_N][Max_N][2];\nbitset<Max_N> LG[2][Max_N], RG[2][Max_N];\nchar input[Max_N];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 2;i <= N;++i)\n\t{\n\t\tscanf(\"%s\", input + 1);\n\t\tfor (int j = 1;j <= i - 1;++j)\n\t\t\tA[j][i] = 1 - (A[i][j] = input[j] - '0');\n\t}\n\tfor (int i = 1;i <= N;++i)\n\t\tF[i][i][0] = F[i][i][1] = 1, LG[0][i].set(i), LG[1][i].set(i), RG[0][i].set(i), RG[1][i].set(i);\n\tfor (int i = 1;i <= N - 1;++i)\n\t\tF[i][i + 1][A[i + 1][i]] = 1, LG[A[i + 1][i]][i].set(i + 1), RG[A[i + 1][i]][i + 1].set(i);\n\tfor (int len = 3;len <= N;++len)\n\t{\n\t\tfor (int l = 1, r = len;r <= N;++l, ++r)\n\t\t{\n\t\t\tif ((LG[1][l] & RG[1][r]).any())\n\t\t\t\tF[l][r][1] = 1;\n\t\t\telse\n\t\t\t\tif (A[r][l] && (LG[0][l] & (RG[1][r] >> 1)).any())\n\t\t\t\t\tF[l][r][1] = 1;\n\t\t\tif ((RG[0][r] & LG[0][l]).any())\n\t\t\t\tF[l][r][0] = 1;\n\t\t\telse\n\t\t\t\tif (A[l][r] && (RG[1][r] & (LG[0][l] << 1)).any())\n\t\t\t\t\tF[l][r][0] = 1;\n\t\t}\n\t\tfor (int l = 1, r = len;r <= N;++l, ++r)\n\t\t{\n\t\t\tif (F[l][r][0])\n\t\t\t\tLG[0][l].set(r), RG[0][r].set(l);\n\t\t\tif (F[l][r][1])\n\t\t\t\tLG[1][l].set(r), RG[1][r].set(l);\n\t\t}\n\t}\n\tint Ans(0);\n\tfor (int x = 1;x <= N;++x)\n\t\tAns += (F[1][x][1] & F[x][N][0]);\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1000003;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact;\n\n  Combination(int sz) : _fact(sz + 1), _rfact(sz + 1) {\n    _fact[0] = _rfact[sz] = 1;\n    for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n  }\n\n  inline T fact(int k) const { return _fact[k]; }\n\n  inline T rfact(int k) const { return _rfact[k]; }\n\n  T P(int n, int r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(int p, int q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\nint main() {\n  int Q;\n  cin >> Q;\n  Combination< modint > uku(mod - 1);\n  while(Q--) {\n    modint X, D;\n    int64 N;\n    cin >> X >> D >> N;\n    if(D == 0) {\n      cout << X * N << endl;\n    } else {\n      modint st = X / D;\n      int64 ed = st.x + N - 1;\n      if(mod <= ed) {\n        cout << 0 << endl;\n      } else {\n        cout << uku.fact(ed) * uku.rfact(st.x - 1) * modint(D).pow(N) << endl;\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n#ifdef LOCAL\n#define show(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n\nconst int MN = 2020; //6;\nusing B = bitset<MN>;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int n;\n    cin >> n;\n    V<B> win(n); \n    for (int j = 1; j < n; j++) {\n        string s;\n        cin >> s;\n        for (int i = 0; i < j; i++) {\n            if (s[i] == '0') {\n                // i -> j\n                win[i].set(j);\n            } else {\n                // j -> i\n                win[j].set(i);\n            }\n        }\n    }\n\n    V<B> okL(n), okR(n);\n    for (int i = 0; i < n; i++) {\n        okL[i][i] = true;\n        okR[i][i] = true;\n    }\n    for (int di = 1; di <= n; di++) {\n        for (int l = 0; l + di <= n - 1; l++) {\n            int r = l + di;\n\n            okL[r][l] = (okR[l + 1] & okL[r] & win[l]).any();\n            okR[l][r] = (okR[l] & okL[r - 1] & win[r]).any();\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (okR[0][i] && okL[n - 1][i]) {\n            show(i);\n            ans++;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2020;\nint n;\nbitset<N>A[N],l[N],r[N],lt[N],rt[N],dp[N],dpt[N];\nint main() {\n\tread(n);rep(i,2,n){\n\t\tchar S[N];scanf(\"%s\",S+1);\n\t\trep(j,1,i-1){\n\t\t\tint x=S[j]=='1';A[i][j]=x;A[j][i]=x^1;\n\t\t}\n\t}\n\tper(i,n,1)rep(j,i,n){\n\t\tif(j==i){l[i][j]=r[i][j]=1;continue;}\n\t\tl[j][i]=(A[i]&r[i+1]&l[j]).any();\n\t\tr[i][j]=(A[j]&r[i]&l[j-1]).any();\n\t}\n\t/*rep(i,1,n){\n\t\trep(j,1,n)printf(\"%d \",(int)A[i][j]);puts(\"\");\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n)printf(\"%d \",(int)l[i][j]);puts(\"\");\n\t}*/\n\tint res=0;rep(i,1,n)res+=l[n][i]&r[1][i];\n\tcout<<res;return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  auto a = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a[i][j] = k;\n    a[j][i] = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  for (size_t i = 0; i <= n; i++) dp[i][i + 1] = true;\n  for (size_t d = 2; d <= n + 1; d++) {\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      for (size_t k = i + 1; k < j; k++) {\n        dp[i][j] |= dp[i][k] && dp[k][j] && (a[i][k] || a[j][k]);\n      }\n    }\n  }\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp[0][i] && dp[i][n + 1]) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <time.h>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    //vector<vector<bool>> A(N, vector<bool>(N));\n    static bool A[2048][2048];\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\" %c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    //vector<vector<bool>> L(N, vector<bool>(N));\n    //vector<vector<bool>> R(N, vector<bool>(N));\n    static bool L[2048][2048];\n    static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<=i+d; j++)\n                    b |= a[j] & l[j] & r[j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i-d; j<i; j++)\n                    b |= a[j] & l[j] & r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n    cout<<ans<<endl;\n\n    cerr<<(double)clock()/CLOCKS_PER_SEC<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nbool A[2000][2000];\nbitset<2001> L[2000];\nbitset<2001> R[2000];\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tREP(j, 0, i) {\n\t\t\tbool ok = Next<char>() - '0';\n\t\t\tA[i][j] = ok;\n\t\t\tA[j][i] = 1 - ok;\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tL[i][i] = true;\n\t\tR[i][i + 1] = true;\n \t}\n\n\tREP(z, 0, 400) {\n\t\tREP(i, 0, N) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tREP(k, i + 1, j + 1) {\n\t\t\t\t\tif (R[i][k] && L[j][k]) {\n\t\t\t\t\t\tR[i] |= R[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tREP(k, j + 1, i + 1) {\n\t\t\t\t\tif (L[i][k] && R[j][k]) {\n\t\t\t\t\t\tL[i] |= L[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tREP(i, 0, N) {\n\t\tif (L[i][0] && R[i][N]) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 2005;\nbitset<N> b[N], rb[N];\nint w[N][N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < i; j++) {\n            w[i + 1][j + 1] = s[j] - '0';\n            w[j + 1][i + 1] = 1 - w[i + 1][j + 1];\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        w[0][i] = 0;\n        w[i][0] = 1;\n        w[n + 1][i] = 0;\n        w[i][n + 1] = 1;\n    }\n\n    n += 2;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (abs(j - i) == 1) {\n                rb[j][i] = w[i][j];\n                b[i][j] = w[i][j];\n            }\n        }\n    }\n\n    for (int i = 2; i < n; i++) {\n        for (int l = 0, r = i; r < n; l++, r++) {\n            if ((b[l] & b[r]).count() ||\n                (rb[l] & b[r]).count() ||\n                (rb[r] & b[l]).count()) {\n                if (w[l][r]) {\n                    rb[r][l] = 1;\n                    b[l][r] = 1;\n                }\n                else {\n                    rb[l][r] = 1;\n                    b[r][l] = 1;\n                }\n            }\n        }\n    }\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) {\n    //         cout << b[i][j];\n    //     }\n    //     cout << \"\\n\";\n    // }\n    // cout << \"\\n\";\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) {\n    //         cout << rb[i][j];\n    //     }\n    //     cout << \"\\n\";\n    // }\n    // cout << \"\\n\";\n\n    int ans = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (b[i][0] && b[i][n - 1]) {\n            ans++;\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int N;\n    const int M = 2000;\n    bitset<M> A[M];\n    cin >> N;\n    for(int i=1; i<N; i++){\n        string s;\n        cin >> s;\n        for(int j=0; j<i; j++){\n            A[i][j] = s[j] - '0';\n            A[j][i] = 1 - A[i][j];\n        }\n    }\n\n    bitset<M> dpl[M], dpr[M];\n    for(int i=0; i<N; i++) dpl[i][i] = dpr[i][i] = 1;\n\n    for(int d=1; d<N; d++){\n        bitset<M> resl, resr;\n        bitset<M> maskl, maskr;\n        for(int k=0; k<N; k++){\n            if(k-1 >= 0) maskl[k-1] = 1;\n            if(k+d < N) maskr[k+d] = 1;\n\n            bitset<M> l = ~A[k];\n            l &= maskl;\n            l &= dpr[k] >> 1;\n            l &= dpl[k] >> d;\n            resl |= l;\n\n            bitset<M> r = ~A[k];\n            r &= maskr;\n            r &= dpl[k] << 1;\n            r &= dpr[k] << d;\n            resr |= r;\n\n            if(k-d >= 0) maskl[k-d] = 0;\n            if(k+1 < N) maskr[k+1] = 0;\n        }\n        for(int i=0; i<N; i++){\n            if(i+d < N) dpl[i][i+d] = resl[i];\n            if(i-d >= 0) dpr[i][i-d] = resr[i];\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) if(dpl[i][N-1] && dpr[i][0]) ans++;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e3+10;\n\nint a[MAXN][MAXN];\nint dpl[MAXN][MAXN],dpr[MAXN][MAXN];\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i = 2;i<=n;i++)\n    {\n        getchar();\n        for (int j = 1;j<i;j++)\n        {\n            a[j][i] = !(a[i][j] = getchar() - 48);\n        }\n        dpl[i][i] = dpr[i][i] = 1;\n    }\n    dpr[1][1] = dpl[1][1] = 1;\n    for (int k = 1;k<=n-1;k++)\n    {\n        for (int i = 1;i<=n-k;i++)\n        {\n            for (int j = i;j<=i+k;j++)\n            {\n                if (j != i && a[i][j] && dpl[j][i + k] && dpr[j][i+1])\n                    dpl[i][i+k] = 1;\n                if (j != i + k && a[i+k][j] && dpl[j][i+k-1] && dpr[j][i])\n                    dpr[i+k][i] = 1;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1;i<=n;i++)\n    if (dpl[i][n] && dpr[i][1]) ans++;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define repd(i, a, b) for (ll i = (a); i < (b); i++)\n#define rep(i, n) repd(i, 0, n)\ntypedef long long ll;\n\nusing namespace std;\n\ntemplate <typename T> void output(T, int);\nint gcd(int a, int b);\n\nint main() {\n    // source\n    int n;\n    cin >> n;\n    string s;\n    vector<vector<int>> vec(n + 1);\n    repd(i, 2, n + 1) {\n        cin >> s;\n        rep(l0, s.size()) {\n            if (s[l0] == '1') {\n                vec[i].push_back(l0 + 1);\n            } else {\n                vec[l0 + 1].push_back(i);\n            }\n        }\n    }\n\n    // judge\n\n    int judge[n + 1] = {};\n    int count = 0;\n    int ans = 0;\n\n    repd(i, 1, n + 1) {\n        rep(l0, n + 1) { judge[l0] = 0; }\n        queue<int> q;\n        count = 0;\n\n        judge[i] = 1;\n        count++;\n        rep(l0, vec[i].size()) { q.push(vec[i][l0]); }\n        while (!q.empty()) {\n            int f = q.front();\n            rep(l0, vec[f].size()) {\n                if (judge[vec[f][l0]] == 0) {\n                    q.push(vec[f][l0]);\n                    count++;\n                }\n            }\n        }\n        if (count == n) {\n            ans++;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\ntemplate <typename T> void output(T a, int precision) {\n    if (precision > 0) {\n        cout << setprecision(precision) << a << \"\\n\";\n    } else {\n        cout << a << \"\\n\";\n    }\n}\n\ntemplate <typename T> T min(T a, T b) {\n\n    if (a < b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nint gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=2000;\n\nint n;\nbool win[MAXN][MAXN];\n\nbool canfst[MAXN][MAXN];\nbool canlst[MAXN][MAXN];\nbool canfinal[MAXN][MAXN];\n\nint solve() {\n\t//REP(i,n) { printf(\"win%d: \",i); REP(j,n) printf(\"%c\",win[i][j]?'v':'.'); puts(\"\"); }\n\tREP(i,n) REP(j,n) canfst[i][j]=canlst[i][j]=canfinal[i][j]=false;\n\tREP(i,n) canfst[i][i]=canlst[i][i]=true;\n\tFORE(len,2,n) REPE(i,n-len) {\n\t\tint j=i+len-1;\n\t\tFORE(k,i,j-1) if(canfst[i][k]&&canlst[k+1][j]) canfinal[i][j]=true;\n\t\tFORE(k,i+1,j) if(win[i][k]&&canfst[k][j]&&canfinal[i][k]) canfst[i][j]=true;\n\t\tFORE(k,i,j-1) if(win[j][k]&&canlst[i][k]&&canfinal[k][j]) canlst[i][j]=true;\n\t\t//printf(\"%d..%d: fst=%c lst=%c final=%c\\n\",i,j,canfst[i][j]?'v':'.',canlst[i][j]?'v':'.',canfinal[i][j]?'v':'.');\n\t}\n\tint ret=0; REP(i,n) if(canlst[0][i]&&canfst[i][n-1]) ++ret; return ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) win[i][i]=false;\n\tFOR(i,1,n) { string s; cin>>s; REP(j,i) win[i][j]=s[j]=='1',win[j][i]=!win[i][j]; }\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n#define coc g[node][i]\n#define mod 1000000007\n#define N 1000005\nusing namespace std;\n\ntypedef long long ll;\n\nint n, say, ans, u[N];\nvector < int > g[N];\nchar ch;\n\nvoid dfs(int node, int par){\n\tu[node]++;\n\tsay += u[node] == 1;\n\tfor(int i = 0; i < g[node].size(); i++)\n\t\tif(!u[coc]){\n\t\t\tif(par < node and coc < par)\n\t\t\t\tcontinue;\n\t\t\tif(par > node and coc > par)\n\t\t\t\tcontinue;\n\t\t\tdfs(coc, node);\n\t\t}\n}\n\nint main() {\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i = 2; i <= n; i++){\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tscanf(\" %c\",&ch);\n\t\t\tif(ch == '1'){\n\t\t\t\tg[i].pb(j);\n\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg[j].pb(i);\n\t\t\t\t// cout << j << \" \" << i << endl;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tu[i] = 0;\n\t\tsay = 0;\n\t\tdfs(i, 0);\n\t\tans += say == n;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 2005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\ntypedef bitset<2000> bs;\nint n;\nbs win[MAXN],twin[MAXN];\nint a[MAXN][MAXN];\nbs dpl[MAXN],dpr[MAXN],tdpl[MAXN],tdpr[MAXN];\nstring str;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        cin>>str;\n        for(int j=0;j<i;j++)\n        {\n            int x=str[j]-'0';\n            if(x) \n            {\n                win[i].set(j);\n                twin[j].set(i);\n            }\n            else \n            {\n                win[j].set(i);\n                twin[i].set(j);\n            }\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        dpl[i].set(i); dpr[i].set(i);\n        tdpl[i].set(i); tdpr[i].set(i);\n    }\n    for(int len=2;len<=n;len++)\n    {\n        for(int i=0;i+len-1<n;i++)\n        {\n            int j=i+len-1;\n            if((dpr[i+1]&tdpl[j]&win[i]).count())\n            {\n                dpl[i].set(j);\n                tdpl[j].set(i);\n            }\n            if((dpr[i]&tdpl[j-1]&win[j]).count())\n            {\n                dpr[i].set(j);\n                tdpr[j].set(i);\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++) if(dpl[i].test(n-1)&&dpr[0].test(i)) ans++;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\nconst int MAX = 2e3 + 41;\n//const int MAX = 10;\n\nint n;\nbitset<MAX> pref[MAX], suf[MAX], win[MAX], can[MAX];\nint a[MAX][MAX];\n\nvoid solve () {\n\tfi(0, n - 1) {\n\t\tfj(0, n - 1) {\n\t\t\tif (a[i][j]) win[i].set(j);\n\t\t}\n\t}\n//\tfi(0, n - 1) dbg(win[i]);\n//\tdbg(win[0]);\n\tfi(0, n - 1) {\n\t\tpref[i].set(i);\n\t\tsuf[i].set(i);\n\t\tcan[i].set(i);\n\t\tfdj(i - 1, 0) {\n\t\t\tif (a[i][j]) {\t\t\t\t\n\t\t\t\tif ( ( (suf[j] << 1) & pref[i]).count() ) {\n\t\t\t\t\tpref[i] |= pref[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfdj(i - 1, 0) {\n\t\t\tif ( (pref[i] & (suf[j] << 1)).count() ) {\n\t\t\t\tcan[j].set(i);\n\t\t\t}\n\t\t}\n\t\tbitset<MAX> sufwin;\n\t\tsufwin.reset();\n\t\tsufwin.set(i);\n\t\tfdj(i - 1, 0) {\n\t\t\tif ( (sufwin & win[j] & can[j]).count() ) {\n\t\t\t\tsufwin.set(j);\n\t\t\t\tsuf[j].set(i);\n\t\t\t}\n\t\t}\n/*\n\t\tfj(0, i) {\n\t\t\tdbg(pref[j]);\n\t\t\tdbg(suf[j]);\n\t\t}\n\t\terr(\"after i = %d\\n\", i);\n*/\n\t}\n\tvi answer;\n\tfi(0, n - 1) {\n\t\tif (pref[i].test(0) && suf[i].test(n - 1)) {\n\t\t\tanswer.pb(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sz(answer));\n//\tdbg(answer);\t\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\t\n\tscanf(\"%d\", &n);\n\tfi(1, n - 1) {\n\t\tchar str[MAX];\n\t\tscanf(\"%s\", str);\t\t\n\t\tfj(0, i - 1) {\t\t\t\n\t\t\ta[i][j] = str[j] - '0';\n\t\t\ta[j][i] = 1 - a[i][j];\n\t\t}\n\t}\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconstexpr unsigned long maxN = 2000;\n\nvoid tape(long r, long l, vector<vector<bitset<maxN>>>& memo, vector<bitset<maxN>>& tapi){\n    if(l < r || memo[r][l - r].any())return;\n    for(unsigned long i = r; i <= l; ++i){\n        tape(r, i - 1, memo, tapi), tape(i, l, memo, tapi);\n        memo[r][l - r][i] = ((memo[r][i - 1 - r] | memo[i][l - i]) & tapi[i]).any();\n    }\n}\n\nint main(){\n    unsigned long N;\n    cin >> N;\n    vector<vector<bitset<maxN>>> dp(N);\n    vector<bitset<maxN>> tapi(N);\n    for(unsigned long i = 1; i < N; ++i){\n        string s;\n        cin >> s;\n        for(unsigned long j = 0; j < i; ++j){\n            tapi[i][j] = (s[j] == '1');\n            tapi[j][i] = (s[j] == '0');\n        }\n    }\n    for(unsigned long i = 0; i < N; ++i){\n        dp[i] = vector<bitset<maxN>>(N - i);\n        dp[i][0][i] = true;\n    }\n    /*for(unsigned long i = 1; i < N; ++i)for(unsigned long j = 0; j + i < N; ++j){\n        if((dp[j + 1][i - 1] & tapi[j]).any())dp[j][i][j] = true;\n        if((dp[j][i - 1] & tapi[j + i]).any())dp[j][i][j + i] = true;\n        dp[j][i] |= dp[j + 1][i - 1] & ~tapi[j];\n        dp[j][i] |= dp[j][i - 1] & ~tapi[j + i];\n    }*/\n    for(const auto& i : dp){\n        for(const auto& j : i)cout << j << \" \";\n        cout << endl;\n    }\n    tape(0, N, dp, tapi);\n    cout << dp[0].back().count() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N;\nint A[2005][2005];\nint before[2005][2005];\nint subbefore[2005];\nint after[2005][2005];\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    for(int i = 2; i <= N; i++) {\n        string S;\n        cin >> S;\n        for(int j = 0; j < S.size(); j++) {\n            A[i][j+1] = S[j] - '0';\n            A[j+1][i] = 1 - A[i][j+1];\n            //cerr << i << \" \" << j + 1 << \" \" << A[i][j+1] << endl;\n        }\n    }\n    for(int i = 1; i <= N; i++) {\n        before[i][i] = i;\n        after[i][i] = i;\n        subbefore[i] = i;\n        for(int j = i - 1; j >= 1; j--) {\n            before[i][j] = before[i-1][j];\n            if(before[i][i] <= after[i-1][j]) {\n                chmin(before[i][i], before[i-1][j]);\n            } else if(after[i-1][j] + 1 >= subbefore[after[i-1][j]+1]) {\n                if(A[i][j] == 1) chmin(before[i][i], before[i-1][j]);\n            }\n            subbefore[j] = before[i][i];\n        }\n        int minimum = i;\n        for(int j = i - 1; j >= 1; j--) {\n            after[i][j] = after[i-1][j];\n            if(after[minimum][j] >= minimum) {\n                chmax(after[i][j], i);\n            } else if(after[i][j] + 1 >= before[i][i]) {\n                if(A[j][i] == 1) chmax(after[i][j], i);\n            }\n            if(after[i][j] == i) minimum = j;\n        }\n    }\n    for(int TIME = 1; TIME <= N; TIME++) {\n        //cerr << \"----\" << TIME << \"----\" << endl;\n        for(int i = 1; i <= TIME; i++) {\n            //cerr << i << \" \" << before[TIME][i] << \" \" << after[TIME][i] << endl;\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= N; i++) {\n        if(before[N][i] == 1 && after[N][i] == N) ans++;\n        //cerr << before[N][i] <<  \" \" << after[N][i] << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nbitset<2000> a[2000];\nint nx[2000][2001];\nbitset<2000> e[2001000], f[2001000];\nbitset<2000> *d[2000][2000], *vis[2000][2000];\nchar s[2222];\nbitset<2000> pref[2001];\nint win[2000][2000];\n\nint solve(int from, int to, int ind) {\n    if (win[from][to] != -1) {\n        if (win[from][to] == ind) {\n            d[from][to]->set(ind - from);\n            return 1;\n        }\n        return 0;\n    }\n    vis[from][to]->set(ind - from);\n    if (ind > from) {\n        bool ok = false;\n        if (((a[ind] >> from) & (*d[from][ind - 1])).any()) {\n            ok = true;\n        }\n        if (!ok) {\n            for (int i = nx[ind][from]; i < ind; i = nx[ind][i + 1]) {\n                if (!vis[from][ind - 1]->test(i - from) && solve(from, ind - 1, i)) {\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            return 0;\n        }\n    }\n    if (ind < to) {\n        bool ok = false;\n        if (((a[ind] >> (ind + 1)) & (*d[ind + 1][to])).any()) {\n            ok = true;\n        }\n        if (!ok) {\n            for (int i = nx[ind][ind + 1]; i <= to; i = nx[ind][i + 1]) {\n                if (!vis[ind + 1][to]->test(i - ind - 1) && solve(ind + 1, to, i)) {\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            return 0;\n        }\n    }\n    d[from][to]->set(ind - from);\n    return 1;\n}\n\nmt19937 mt(time(0));\n\nint main() {\n//    n = 2000;\n//    for (int i = 1; i < n; ++i) {\n//        forn(j, i) {\n//            if (i % 2 == 1) {\n//                a[i].set(j);\n//            } else {\n//                a[j].set(i);\n//            }\n//        }\n//    }\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        scanf(\"%s\", s);\n        forn(j, i) {\n            if (s[j] == '1') {\n                a[i].set(j);\n            } else {\n                a[j].set(i);\n            }\n        }\n    }\n\n    forn(i, n) {\n        nx[i][n] = n;\n        for (int j = n - 1; j >= 0; --j) {\n            nx[i][j] = nx[i][j + 1];\n            if (a[i].test(j)) {\n                nx[i][j] = j;\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        pref[i] = pref[i - 1];\n        pref[i].set(i - 1);\n    }\n    int ind = 0;\n    forn(i, n) for (int j = i; j < n; ++j) {\n        d[i][j] = e + ind;\n        vis[i][j] = f + ind;\n        ind++;\n    }\n    forn(i, n) {\n        d[i][i]->set(0);\n    }\n    memset(win, -1, sizeof win);\n    forn(i, n) {\n        int le = i;\n        while (le > 0 && a[i].test(le - 1)) {\n            --le;\n        }\n        int ri = i;\n        while (ri < n - 1 && a[i].test(ri + 1)) {\n            ++ri;\n        }\n        for (int from = le; from <= i; ++from) {\n            for (int to = i; to <= ri; ++to) {\n                win[from][to] = i;\n            }\n        }\n    }\n    int ans = 0;\n    forn(i, n) {\n        ans += solve(0, n - 1, i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 2022, inf = 1000111222;\n\nchar buf[max_n], a[max_n][max_n], dp[max_n][max_n][3];\n\nint n;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        scanf(\"%s\", buf);\n        for (int j = 0; j < i; ++j) {\n            a[i][j] = buf[j] - '0';\n            a[j][i] = 1 ^ a[i][j];\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        dp[i][i][0] = 1;\n        dp[i][i][1] = 1;\n        dp[i][i][2] = 1;\n    }\n    for (int len = 2; len <= n; ++len) {\n        for (int l = 0; l + len <= n; ++l) {\n            int r = l + len - 1;\n            if (len == 2) {\n                dp[l][r][2] = 1;\n            } else {\n                for (int i = l + 1; i < r && !dp[l][r][2]; ++i) {\n                    dp[l][r][2] |= dp[l][i][2] & dp[i][r][2] & (a[l][i] | a[r][i]);\n                }\n            }\n\n            if (a[l][r] && dp[l][r][2]) {\n                dp[l][r][0] = 1;\n            }\n            for (int i = l + 1; i < r && !dp[l][r][0]; ++i) {\n                if (a[l][i] && dp[l][i][0] && dp[i][r][0]) {\n                    dp[l][r][0] = 1;\n                }\n            }\n\n            if (a[r][l] && dp[l][r][2]) {\n                dp[l][r][1] = 1;\n            }\n            for (int i = l + 1; i < r && !dp[l][r][1]; ++i) {\n                if (a[r][i] && dp[l][i][1] && dp[i][r][1]) {\n                    dp[l][r][1] = 1;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        bool ok = dp[0][i][1] & dp[i][n - 1][0];\n        ans += ok;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind = lower_bound(wn[l].begin(), wn[l].end(), l) - wn[l].begin();\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = lower_bound(wn[r].begin(), wn[r].end(), l) - wn[r].begin();\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(wn[i].begin(), wn[i].end());\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n;\nbitset<2000> table[2000];\nbitset<2000> dpl[2000];\nbitset<2000> dpr[2000];\n\nint main() {\n    cin >> n;\n    rep(i,n-1) {\n        rep(j,i+1) {\n            char c; cin >> c;\n            if (c == '1') table[i+1].set(j);\n            else table[j].set(i+1);\n        }\n    }\n    rep(i,n) {\n        dpl[i].set(i);\n        dpr[i].set(i);\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n-i; j++) {\n            if ((((table[j]&dpr[j+i]&dpl[j+1])<<(n-j-i))>>(n-i-1)).any()) {\n                dpr[j+i].set(j);\n            }\n            if ((((table[j+i]&dpr[j+i-1]&dpl[j])<<(n-j-i))>>(n-i-1)).any()) {\n                dpl[j].set(j+i);\n            }\n            if (table[j][j+i] && dpl[j+1][j+i]) dpr[j+i].set(j);\n            if (table[j+i][j] && dpr[j+i-1][j]) dpl[j].set(j+i);\n        }\n    }\n    int ans = 0;\n    rep(i,n) {\n        if (dpl[0][i] && dpr[n-1][i]) ans++;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbool win[2020][2020];\nbool dp[2][2020][2020];\nsigned main() {\n    int N; scanf(\"%d\", &N);\n    \n    for(int i=0; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; scanf(\" %c\", &c);\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[0][i][i] = dp[1][i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            bool f1 = false, f2 = false;\n            for(int k=i; k<j; k++) {\n                f2 |= dp[1][i][k] and dp[0][j-1][k] and win[j][k];\n            }\n            for(int k=i+1; k<=j; k++) {\n                f1 |= dp[0][j][k] and dp[1][i+1][k] and win[i][k];\n            }\n            dp[0][j][i] = f1, dp[1][i][j] = f2;\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dp[0][N-1][i] and dp[1][0][i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\n\nstruct P\n{\n\tint A, B;\n\tP(int a, int b) : A(a), B(b) {}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<bool> m(N * N);\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor (int j = 0; j < i; j++) m[N * j + i] = !(m[N * i + j] = S[j] == '1');\n\t}\n\tvector<int> strong, weak, normal;\n\tvector<bool> isnormal(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tint c = 0;\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (m[N * i + j]) c++;\n\t\tif (c == N - 1)\n\t\t\tstrong.push_back(i);\n\t\telse if (c == 0)\n\t\t\tweak.push_back(i);\n\t\telse\n\t\t\tnormal.push_back(i);\n\t\tisnormal[i] = c > 0;\n\t}\n\tif (strong.size())\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tint M = normal.size();\n\tvector<bool> newm(M * M);\n\tfor (int i = 0; i < M; i++)\n\t\tfor (int j = 0; j < M; j++) newm[M * i + j] = m[N * normal[i] + normal[j]];\n\tN = M;\n\tm = newm;\n\tdeque<bool> dp(N * N, false);\n\tfor (int i = 0; i < N - 1; i++) dp[N * i + i + 1] = true;\n\tfor (int l = 2; l < N; l++)\n\t\tfor (int i = 0; i + l < N; i++)\n\t\t{\n\t\t\tint p = N * i + i + l;\n\t\t\tfor (int k = i + 1, q = N * i + k, r = N * (i + l) + k, s = N * k + i + l; k < i + l; k++, q++, r++, s += N)\n\t\t\t\tif (dp[p] |= dp[q] & (m[q] | m[r]) & dp[s]) break;\n\t\t}\n\tdeque<bool> dpL(N, false);\n\tdpL[N - 1] = true;\n\tfor (int i = N - 2; i >= 0; i--)\n\t\tfor (int j = i + 1; j < N; j++) dpL[i] |= m[N * i + j] & dpL[j] & dp[N * i + j];\n\tdeque<bool> dpR(N, false);\n\tdpR[0] = true;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 0; j < i; j++) dpR[i] |= m[N * i + j] & dpR[j] & dp[N * j + i];\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tif (dpL[i] & dpR[i]) ans++;\n\tcout << ans << endl;\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 2005\n\nbitset <N> win[N], r[N], l[N];\n\nint n;\n\nchar s[N];\n\nint main() {\n\tscanf(\"%d\", &n);\n    for (int i = 2; i <= n; i ++) {\n        scanf(\"%s\", s+1);\n        for (int j = 1; j < i; j ++) {\n            if (s[j] == '1') win[i].set(j);\n            else win[j].set(i);\n        }\n    }\n    for (int i = 1; i <= n; i ++) r[i].set(i), l[i].set(i);\n    for (int d = 2; d <= n; d ++) {\n        int up = n - d + 1;\n        for (int i = 1; i <= up; i ++) {\n            int t = i + d - 1;\n            if ((win[t]&r[i]&l[t-1]).any()) r[i].set(t);\n            if ((win[i]&r[i+1]&l[t]).any()) l[t].set(i);\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i ++) if (r[1][i] && l[n][i]) ans ++;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst int MX=2000;\n\nbitset<MX> A[MX];\nbitset<MX> dp[MX];\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            scanf(\" %c\",&c);\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            dp[R][j]=(A[j]&dp[l]&dp[R]).any();\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            dp[R][j]=(A[j]&dp[l]&dp[R]).any();\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 2010\nint n,i,j,x,y,ans=0;\nbitset <maxn> f[maxn],g[maxn],a[maxn];\nint getnum()\n{\n\tchar c=getchar();\n\tfor (;!isdigit(c);c=getchar());\n\treturn c-'0';\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (i=2;i<=n;i++)\n\t\tfor (j=1;j<i;j++)\n\t\t{\n\t\t\tx=getnum();\n\t\t\tif (x) a[i][j]=1;\n\t\t\t\telse a[j][i]=1;\n\t\t}\n\tfor (i=1;i<=n;i++)\n\t\tf[i][i]=g[i][i]=1;\n\tfor (i=1;i<n;i++)\n\t\tfor (j=1;j+i<=n;j++)\n\t\t{\n\t\t\tx=j;\n\t\t\ty=j+i;\n\t\t\tf[x][y]=((f[x]&g[y-1]&a[y]).count()>0);\n\t\t\tg[y][x]=((f[x+1]&g[y]&a[x]).count()>0);\n\t\t}\n\tfor (i=1;i<=n;i++)\n\t\tans+=(f[1][i]&g[n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _dbg(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _dbg(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_dbg(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\nconst int N=2001;\nusing bt=bitset<N>;\nbt a[N];\nbt win[N];\nbt ones[N];\n// bt stolb[N];\nbool any(bt bs, int l,int r){\n    return ((bs>>l)&ones[r-l+1]).any();\n}\nint32_t main() {\n    forn(i,N){forn(j,i)ones[i].set(j);}\n    int n;\n    cin>>n;\n    forn(i,n){\n        forn(j,i){\n            char c;\n            cin>>c;\n            a[i][j]=c-'0';\n            a[j][i]=a[i][j]^1;\n        }\n        win[i].set(i);\n        // stolb[i].set(i);\n    }\n    for(int len=2;len<=n;++len){\n        for(int i=0;i+len-1<n;++i){\n            int r=i+len-1;\n            if(a[i][r]){\n                for(int k=i;k<r;++k){\n                    if(win[i][k]&win[r][k+1]){\n                        win[i].set(r);\n                        // stolb[r].set(i);                        \n                    }\n                }\n            }\n            for(int k=i;k<r;++k){\n                if(a[i][k+1]&win[i][k]&win[k+1][r]){\n                    win[i].set(r);\n                    // stolb[r].set(i);                                    \n                }\n            }\n        }\n        for(int i=len-1;i<n;++i){\n            int l=i-len+1;\n            if(a[i][l]){\n                for(int k=i;k>l;--k){\n                    if(win[l][k-1]&win[i][k]){\n                        win[i].set(l);\n                        // stolb[l].set(i);                        \n                    }\n                }\n            }\n            for(int k=i;k>l;--k){\n                if(a[i][k-1]&win[i][k]&win[k-1][l]){\n                    win[i].set(l);\n                    // stolb[l].set(i);                                    \n                }\n            }\n        }\n    }\n    int ans=0;\n    forn(i,n){\n        ans+=(win[i][0]&win[i][n-1]);\n    }\n    cout<<ans<<'\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst int MX=2000;\n\nbitset<MX> A[MX];\nbitset<MX> dp[MX];\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            scanf(\" %c\",&c);\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            dp[R][j]=(A[j]&dp[l]&dp[R]).any();\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            dp[R][j]=(A[j]&dp[l]&dp[R]).any();\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbitset<SZ> grid[SZ];\nbitset<SZ> sv[SZ], sv2[SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind = lower_bound(wn[l].begin(), wn[l].end(), l) - wn[l].begin();\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = lower_bound(wn[r].begin(), wn[r].end(), l) - wn[r].begin();\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tsv[i - 1][i] = 1;\n\t\tsv2[i][i - 1] = 1;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 2; i <= n + 1; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tll lft = j, rt = j + i;\n\t\t\tif (rt <= n + 1) {\n\t\t\t\tif ((sv[lft] & grid[lft]) != 0 || (sv2[rt] & grid[rt]) != 0) {\n\t\t\t\t\tsv[lft][rt] = 1;\n\t\t\t\t\tsv2[rt][lft] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (sv[0][i] && sv[i][n + 1]) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\n//const int MOD = (int) 1e9 + 7;\nconst int MOD = (int) 1e6 + 3;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nvoid chemthan() {\n    int n; cin >> n;\n    vector<string> vs(n - 1);\n    FOR(i, 0, n - 1) cin >> vs[i];\n    vector<vi> a(n, vi(n));\n    FOR(i, 0, n - 1) {\n        FOR(j, 0, i + 1) {\n            a[i + 1][j] = vs[i][j] - '0';\n            a[j][i + 1] = a[i + 1][j] ^ 1;\n        }\n    }\n    vi f(n), g(n);\n    f[0] = 1;\n    FOR(i, 1, n) {\n        FOR(j, 0, i) if (f[j] && a[i][j]) {\n            f[i] = 1;\n        }\n    }\n    g[n - 1] = 1;\n    FORd(i, n - 1, 0) {\n        FOR(j, i + 1, n) if (g[j] && a[i][j]) {\n            g[i] = 1;\n        }\n    }\n    int res = 0;\n    FOR(i, 0, n) res += f[i] && g[i];\n    cout << res << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <bitset>\n\nusing namespace std;\n\n#define rg register int\n\nconst int N = 2005;\n\ninline bool getc()\n{\n    char c = getchar();\n    while(!isdigit(c))c = getchar();\n    return c == '1';\n}\n\nbitset<N> f[N], g[N], a[N];\n\nint n;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (rg i = 2; i <= n; i++)\n        for (rg j = 1; j < i; j++)\n            a[i][j] = getc(), a[j][i] = !a[i][j];\n  //  for (rg i = 1; i <= n; i++, putchar(10))\n  //      for (rg j = 1; j <= n; j++)\n //           cerr << a[i][j] << \" \";\n    for (rg i = 1; i <= n; i++)\n        f[i][i] = g[i][i] = 1;\n    for (rg len = 2; len <= n; len++)\n        for (rg l = 1;  l + len - 1 <= n; l++) \n        {\n            int r = l + len - 1;\n            if((g[l] & f[r - 1] & a[r]).any())\n                g[l][r] = 1;\n            if((g[l + 1] & f[r] & a[l]).any())\n                f[r][l] = 1;\n        }\n    printf(\"%d\\n\", (g[1] & f[n]).count());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[2020][2020];\n\nint win[2020][2020][2];\nint dp[2020][2020];\n\nint hoge(int L,int R,int side) ;\nint top(int L,int R) {\n\tif(dp[L][R]>=0) return dp[L][R]>=0;\n\tif(L==R) return dp[L][R]=1;\n\tint x;\n\tfor(x=L;x<R;x++) if(hoge(L,x,0)&&hoge(x+1,R,1)) return dp[L][R]=1;\n\treturn dp[L][R]=0;\n}\n\nint hoge(int L,int R,int side) {\n\tif(L==R) return 1;\n\tif(win[L][R][side]>=0) return win[L][R][side];\n\twin[L][R][side]=0;\n\tif(side==0) {\n\t\tfor(int x=L+1;x<=R;x++) if(A[L][x]&&top(L,x)&&hoge(x,R,0)) return win[L][R][side]=1;\n\t}\n\telse {\n\t\tfor(int x=L;x<R;x++) if(A[R][x]&&top(x,R)&&hoge(L,x,1)) return win[L][R][side]=1;\n\t}\n\treturn 0;\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(j=1;j<N;j++) {\n\t\tcin>>s;\n\t\tFOR(i,j) {\n\t\t\tA[j][i]=s[i]=='1';\n\t\t\tA[i][j]=s[i]=='0';\n\t\t}\n\t}\n\tMINUS(win);\n\tMINUS(dp);\n\tint ret=0;\n\tFOR(i,N) if(hoge(0,i,1)&&hoge(i,N-1,0)) ret++;\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nint N;\nbool A[2010][2010];\nbool L[2010][2010];\nbool R[2010][2010];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tcin >> N;\n\t{\n\t\tV<string> s(N);\n\t\trep1(i,N-1) cin >> s[i];\n\t\trep(i,N) rep(j,N){\n\t\t\tif(i>j) A[i][j] = s[i][j]=='1';\n\t\t\tif(j>i) A[i][j] = s[j][i]=='0'; \n\t\t}\n\t}\n\tif(false){\n\t\trep(i,N){\n\t\t\trep(j,N) cout << A[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tfor(int d=1;d<=N;d++){\n\t\tfor(int l=0;l+d-1<N;l++){\n\t\t\tint r = l+d-1;\n\t\t\tif(d == 1){\n\t\t\t\tL[l][r] = true;\n\t\t\t\tR[l][r] = true;\n\t\t\t}else{\n\t\t\t\t{\t//L\n\t\t\t\t\tfor(int x=l+1;x<=r;x++){\n\t\t\t\t\t\tif(A[l][x] && R[l+1][x] && L[x][r]){\n\t\t\t\t\t\t\tL[l][r] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\t//R\n\t\t\t\t\tfor(int x=l;x<r;x++){\n\t\t\t\t\t\tif(A[r][x] && L[x][r-1] && R[l][x]){\n\t\t\t\t\t\t\tR[l][r] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i,N) if(R[0][i] && L[i][N-1]){\n\t\tans++;\n\t\tshow(i);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    bool A[2020][2020];\n    for (int n = 1; n < N; ++n) {\n        string s;\n        cin >> s;\n        for (int m = 0; m < n; ++m) {\n            A[n][m] = s[m] == '1';\n        }\n    }\n    \n    bool DP[2020][2020];\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = true;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            bool b = false;\n            for (int k = i+1; k <= i+d; ++k) {\n                b |= !A[k][i] & DP[k][i+1] & DP[k][i+d];\n                if (b) {\n                    break;\n                }\n            }\n            DP[i][i+d] = b;\n            \n            b = false;\n            for (int k = i; k < i+d; ++k) {\n                b |= A[i+d][k] & DP[k][i] & DP[k][i+d-1];\n                if (b) {\n                    break;\n                }\n            }\n            DP[i+d][i] = b;\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[n][0] && DP[n][N-1]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target (\"avx\")\n\n#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cerr << *i << \" \"; cerr << endl; }\ntemplate <class T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <class T> void chmax(T &t, const T &f) { if (t < f) t = f; }\n\n// (a | b) & c & d\ntemplate <size_t N> bool bitsetOpAny(const bitset<N> &a, const bitset<N> &b, const bitset<N> &c, const bitset<N> &d) {\n  constexpr size_t nw = (N + 64 - 1) / 64;\n  auto a_ = (const uint64_t *)&a;\n  auto b_ = (const uint64_t *)&b;\n  auto c_ = (const uint64_t *)&c;\n  auto d_ = (const uint64_t *)&d;\n  for (size_t i = 0; i < nw; ++i) {\n    if ((a_[i] | b_[i]) & c_[i] & d_[i]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nconstexpr int MAX_N = 2005;\n\nint N;\nchar A[MAX_N][MAX_N];\n\n// bool B[MAX_N][MAX_N];\nbitset<MAX_N> B[MAX_N];\n\n// bool dp[MAX_N][MAX_N];\nbitset<MAX_N> dp[MAX_N], DP[MAX_N];\n\nint main() {\n  for (; ~scanf(\"%d\", &N); ) {\n    for (int i = 2; i <= N; ++i) {\n      scanf(\"%s\", A[i] + 1);\n    }\n    for (int i = 0; i <= N + 1; ++i) {\n      B[i].reset();\n    }\n    B[0][N + 1] = true;\n    B[N + 1][0] = false;\n    for (int i = 1; i <= N; ++i) {\n      B[0][i] = false;\n      B[i][0] = true;\n      B[N + 1][i] = false;\n      B[i][N + 1] = true;\n    }\n    for (int i = 1; i <= N; ++i) for (int j = 1; j < i; ++j) {\n      B[i][j] = (A[i][j] == '1');\n      B[j][i] = (A[i][j] == '0');\n    }\n    // memset(dp, 0, sizeof(dp));\n    for (int i = 0; i <= N + 1; ++i) {\n      dp[i].reset();\n      DP[i].reset();\n    }\n    for (int i = 0; i <= N; ++i) {\n      dp[i][i + 1] = true;\n      DP[i + 1][i] = true;\n    }\n    for (int w = 2; w <= N + 1; ++w) {\n      for (int i = 0; i <= N + 1 - w; ++i) {\n        const int j = i + w;\n        // for (int k = i + 1; k < j; ++k) {\n          // if ((B[i][k] || B[j][k]) && dp[i][k] && dp[k][j]) {\n            // dp[i][j] = true;\n            // break;\n          // }\n        // }\n        // dp[i][j] = DP[j][i] = ((B[i] | B[j]) & dp[i] & DP[j]).any();\n        dp[i][j] = DP[j][i] = bitsetOpAny(B[i], B[j], dp[i], DP[j]);\n      }\n    }\n// for(int i=0;i<=N+1;++i){for(int j=0;j<=N+1;++j){cout<<dp[i][j];}cout<<endl;}\n    int ans = 0;\n    for (int i = 1; i <= N; ++i) {\n      if (dp[0][i] && dp[i][N + 1]) {\n        ++ans;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bitset>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nchar buf[2011];\n\nconst int SIZE = 2048;\nusing Bits = bitset<SIZE>;\nBits A[2011];\nBits L[2011], R[2011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    for (int i=1; i<N; i++) {\n\tscanf(\"%s\", buf);\n\tREP (j, i) {\n\t    if (buf[j] == '1') A[i].set(j);\n\t    else A[j].set(i);\n\t}\n    }\n//    REP (i, N) {\n//\tREP (j, N) eprintf(\"%d\", A[i].test(j));\n//\teprintf(\"\\n\");\n//    }\n\n    L[1].set(0);\n    for (int i=1; i<N; i++) {\n\tBits &has = L[i+1];\n\tif ((L[i] & A[i]).any()) {\n\t    has.set(i);\n\t    for (int j=i-1; j--;) {\n\t\tif ((A[j]&has).any()) has.set(j);\n\t    }\n\t} else {\n\t    has = L[i];\n\t}\n    }\n\n    R[N-1].set(N-1);\n    for (int i=N-2; i>=0; i--) {\n\tBits &has = R[i];\n\tif ((R[i+1] & A[i]).any()) {\n\t    has.set(i);\n\t    for (int j=i+1; j<N; j++) {\n\t\tif ((A[j]&has).any()) has.set(j);\n\t    }\n\t} else {\n\t    has = R[i+1];\n\t}\n    }\n\n    int ans = 0;\n    REP (i, N) if (L[i+1].test(i) && R[i].test(i)) ans++;\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1000003;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nconst int MAX_N = 2000;\n\nbool winL[MAX_N][MAX_N];\nbool winR[MAX_N][MAX_N];\nbool sumP[MAX_N][MAX_N];\n\n\nint main() {\n  int N;\n  cin >> N;\n  auto mat = make_v< int >(N, N);\n  for(int i = 1; i < N; i++) {\n    string s;\n    cin >> s;\n    for(int j = 0; j < i; j++) {\n      int x = (int) s[j] - '0';\n      mat[i][j] = x;\n      mat[j][i] = 1 - x;\n    }\n  }\n\n  for(int i = N - 1; i >= 0; i--) {\n    winL[i][i] = winR[i][i] = 1;\n    for(int j = i + 1; j < N; j++) {\n      sumP[i][j] = 0;\n      for(int p = i; p < j; p++) {\n        sumP[i][j] += winL[p][i] * winR[j][p + 1];\n        if(sumP[i][j]) break;\n      }\n      winL[i][j] = winR[i][j] = 0;\n      {  // winL\n        for(int k = i + 1; k <= j; k++) {\n          winL[j][i] += mat[i][k] & winL[j][k] & sumP[i][k];\n          if(winL[j][i]) break;\n        }\n      }\n      {  // winR\n        for(int k = i; k < j; k++) {\n          winR[j][i] += mat[j][k] & winR[k][i] & sumP[k][j];\n          if(winR[j][i]) break;\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    bool ans = winR[i][0] * winL[N - 1][i];\n    ret += ans > 0;\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    int n;\n    cin >> n;\n    vs a(n-1);\n    rep(i, n-1) cin >> a[i];\n    vector<vector<bool>> win(n, vector<bool>(n));\n    rep1(i, n-1) rep(j, i) {\n        win[i][j] = (a[i-1][j] == '1');\n        win[j][i] = !(a[i-1][j] == '1');\n    }\n    vector<bitset<2000>> dpl(n), dpr(n);\n    rep(i, n) dpl[i][i] = true;\n    rep(i, n) dpr[i][i] = true;\n    rep1(i, n-1) rep(a, n-i) {\n        int b = a + i;\n        bool lok = false;\n        rep1(c, i-1) if (dpl[a][a+c] && dpl[a+c][b]) lok = true;\n        if (!lok && win[a][b]) {\n            rep(c, i) if (dpl[a][a+c] && dpr[a+c+1][b]) lok = true;\n        }\n        dpl[a][b] = lok;\n        bool rok = false;\n        rep1(c, i-1) if (dpr[b-c][b] && dpr[a][b-c]) rok = true;\n        if (!rok && win[b][a]) {\n            rep(c, i) if (dpr[b-c][b] && dpl[a][b-c-1]) rok = true;\n        }\n        dpr[a][b] = rok;\n    }\n    int ans = 0;\n    rep(i, n) if (dpr[0][i] && dpl[i][n-1]) ++ans;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = std::pair<int, int>;\n\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define pb push_back\n\nconst int mn = 2000;\n\nbitset<mn> t[mn][mn], g[mn];\n\nint n;\nchar s[mn + 5];\n\nbitset<mn> dp(int l, int r) {\n    bitset<mn> &ans = t[l][r];\n    if (ans.any()) return ans;\n    if (l == r) {\n        ans[l] = true;\n        return ans;\n    }\n    for (int j = l; j <= r; j++) {\n        if (j == l) {\n            ans[j] = (dp(l + 1, r) & g[j]).any();\n        } else if (j == r) {\n            ans[j] = (dp(l, r - 1) & g[j]).any();\n        } else ans[j] = (dp(l, j - 1) & g[j]).any()&&(dp(j+1, r) & g[j]).any();\n    }\n    //printf(\"%d %d %d%d%d%d%d%d\\n\",l,r,(int)ans[0],(int)ans[1],(int)ans[2],(int)ans[3],(int)ans[4],(int)ans[5]);\n    return ans;\n}\n\nint main() {\n#ifdef trote\n    freopen(\"../1.txt\", \"r\", stdin);\n#endif\n\n    scanf(\"%d\", &n);\n    if (n == 1) {\n        puts(\"1\");\n        exit(0);\n    }\n    for (int i = 1; i < n; i++) {\n        scanf(\"%s\", s);\n        for (int j = 0; j < i; j++) {\n            if (s[j] == '1') {\n                g[i][j] = 1;\n                g[j][i] = 0;\n            } else {\n                g[i][j] = 0;\n                g[j][i] = 1;\n            }\n        }\n    }\n    //cout<<g[3]<<\"\\n\";\n    printf(\"%d\\n\", dp(0, n - 1).count());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<time.h>\n#include <set>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef unsigned long long uLL;\n\n#define ls rt<<1\n#define rs rt<<1|1\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define bug printf(\"*********\\n\")\n#define FIN freopen(\"input.txt\",\"r\",stdin);\n#define FON freopen(\"output.txt\",\"w+\",stdout);\n#define IO ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\n#define SZ(x) ((int)(x).size())\n\n#define readi read<int>()\n#define readll read<ll>()\n\n\nconst ll mod=998244353;\n\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n\ntemplate <typename T>\ninline T read() {  //ÉùÃ÷ template Àà,ÒªÇóÌá¹©ÊäÈëµÄÀàÐÍT,²¢ÒÔ´ËÀàÐÍ¶¨ÒåÄÚÁªº¯Êý read()\n  T sum = 0, fl = 1;  //½« sum,fl ºÍ ch ÒÔÊäÈëµÄÀàÐÍ¶¨Òå\n  int ch = getchar();\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') fl = -1;\n  for (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';\n  return sum * fl;\n}\n\n//head\n\nconst int N=2000+7;\nbitset<N> fl[N],fr[N],a[N],tmp;\n\n\nint n;\nint main()\n{\n\tIO;\n\tcin>>n;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor (int j=0;j<s.length();j++)\n\t\t{\n\t\t\tif (s[j]=='1') a[i][j+1]=1;\n\t\t\t\n\t\t\ta[j+1][i]=1-a[i][j+1];\n\t\t\t//cin>>a[i][j];\n\t\t\t//a[j][i]=1-a[i][j]; \n\t\t}\n\t}\n\t\n\tfor (int i=1;i<=n;i++) fl[i][i]=1,fr[i][i]=1; \n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif (j+i-1>n) break;\n\t\t\tif ((fr[j] & fl[j + i - 1 - 1] & a[j + i - 1]).count()>0)\n\t\t\t{\n\t\t\t\tfr[j][j + i - 1]=1;\n\t\t\t}\n\t\t\t\n\t\t\tif ((fr[j+1] & fl[j + i - 1 ] & a[j]).count()>0)\n\t\t\t{\n\t\t\t\tfl[j + i - 1][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans=(fr[1] & fl[n]).count();\n\t\n\tcout<<ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 2020;\nInt a[MAX][MAX]={};\nInt dpL[MAX][MAX]={};\nInt dpR[MAX][MAX]={};\nusing BS = bitset<MAX>;\nBS win[MAX][MAX];\nBS st[MAX];\nsigned main(){\n  Int n;\n  cin>>n;\n  for(Int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(Int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      if(a[i][j]) st[i].set(j);\n  \n  for(Int i=0;i<n;i++){\n    dpL[i][i]=dpR[i][i]=1;\n    win[i][i].set(i);\n  }\n\n  for(Int w=2;w<=n;w++){\n    for(Int i=0;i+w<=n;i++){\n      Int l=i,r=i+w-1;\n      for(Int k=l;k<r;k++)\n        dpL[l][r]|=dpL[l][k]&&(win[k+1][r]&st[l]).any();\n      \n      for(Int k=l+1;k<=r;k++)\n        dpR[l][r]|=dpR[k][r]&&(win[l][k-1]&st[r]).any();   \n\n      for(Int k=l;k<=r;k++)\n        if(dpR[l][k]&&dpL[k][r]) win[l][r].set(k);         \n    }\n  }\n\n  cout<<win[0][n-1].count()<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define pb push_back\n#define mp make_pair\n#define fir first\n#define sec second\n#define mid ((l+r)>>1)\n#define MAXN 2050\n#define MAXM \n#define mod\n#define inf (1<<30)\n#define eps (1e-6)\n#define alpha 0.75\n#define rep(i, x, y) for(register int i = x; i <= y; ++i)\n#define repd(i, x, y) for(register int i = x; i >= y; --i)\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".my\", \"w\", stdout)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntemplate <typename T> il bool chkmin(T &x, T y) {return x > y ? x = y, 1 : 0;}\ntemplate <typename T> il bool chkmax(T &x, T y) {return x < y ? x = y, 1 : 0;}\ntemplate <typename T> il void read(T &x) {\n\tchar ch = getchar(); int f = 1; x = 0;\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n\tx *= f;\n}\ntemplate <typename T, typename... Args> il void read(T &x, Args &...args) {\n\tread(x), read(args...);\n}\nint n;\nbitset <MAXN> a[MAXN], l[MAXN], r[MAXN];\nchar s[MAXN];\nint main() {\n\tread(n);\n\trep(i, 2, n) {\n\t\tscanf(\"%s\", s+1);\n\t\trep(j, 1, i-1) \n\t\t\tif(s[j] == '1') a[i][j] = 1, a[j][i] = 0;\n\t\t\telse a[j][i] = 1, a[i][j] = 0;\n\t}\n\trep(i, 1, n) l[i][i] = r[i][i] = 1;\n\t// rep(i, 1, n) cout << a[i] << endl;\n\t// cout << a[3] << endl << \"QWQ \" << a[3][1] << endl;\n\trep(d, 2, n)\n\t\trep(i, 1, n - d + 1) {\n\t\t\tint x = i, y = x + d - 1;\n\t\t\tr[x][y] = (r[x] & l[y-1] & a[y]).any();\n\t\t\tl[y][x] = (l[y] & r[x+1] & a[x]).any();\n\t\t\t// cout << x << ' ' << y << ' ' << l[x][y] << ' ' << r[x][y] << endl;\n\t\t}\n\tcout << (r[1] & l[n]).count() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))\nusing namespace std;\n\nconstexpr int MAX_N = 2000;\nint solve(int n, const vector<bitset<MAX_N> > & wins) {\n    vector<bitset<MAX_N> > dpl(n);\n    vector<bitset<MAX_N> > dpr(n);\n    REP_R (l, n) REP3 (r, l, n) {\n        if (l == r) {\n            dpl[r][l] = true;\n            dpr[l][r] = true;\n        } else {\n            dpl[r][l] = (wins[l] & dpr[l + 1] & dpl[r]).any();\n            dpr[l][r] = (wins[r] & dpr[l] & dpl[r - 1]).any();\n        }\n    }\n    return (dpr[0] & dpl[n - 1]).count();\n}\n\nint main() {\n    int n; cin >> n;\n    assert (n <= MAX_N);\n    vector<bitset<MAX_N> > wins(n);\n    REP (i, n) {\n        REP (j, i) {\n            char c; cin >> c;\n            wins[i][j] = c - '0';\n            wins[j][i] = not wins[i][j];\n        }\n    }\n    cout << solve(n, wins) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 2020;\nInt a[MAX][MAX]={};\nInt dpL[MAX][MAX]={};\nInt dpR[MAX][MAX]={};\nusing BS = bitset<MAX>;\nBS win[MAX][MAX];\nBS st[MAX];\nsigned main(){\n  Int n;\n  cin>>n;\n  for(Int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(Int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      if(a[i][j]) st[i].set(j);\n  \n  for(Int i=0;i<n;i++){\n    dpL[i][i]=dpR[i][i]=1;\n    win[i][i].set(i);\n  }\n\n  for(Int w=2;w<=n;w++){\n    for(Int i=0;i+w<=n;i++){\n      Int l=i,r=i+w-1;\n      for(Int k=l;k<r&&!dpL[l][r];k++)\n        dpL[l][r]|=dpL[l][k]&&(win[k+1][r]&st[l]).any();\n      \n      for(Int k=l+1;k<=r&&!dpR[l][r];k++)\n        dpR[l][r]|=dpR[k][r]&&(win[l][k-1]&st[r]).any();   \n\n      for(Int k=l;k<=r;k++)\n        if(dpR[l][k]&&dpL[k][r]) win[l][r].set(k);         \n    }\n  }\n\n  cout<<win[0][n-1].count()<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nbitset<2000> a[2000];\nint nx[2000][2001];\nbitset<2000> e[2001000];\nbitset<2000> *d[2000][2000];\nchar s[2222];\nbitset<2000> pref[2001];\nint win[2000][2000];\n\nint solve(int from, int to, int ind) {\n    if (win[from][to] != -1) {\n        if (win[from][to] == ind) {\n            d[from][to]->set(ind - from);\n            return 1;\n        }\n        return 0;\n    }\n    if (ind > from) {\n        bool ok = false;\n        if (((a[ind] >> from) & (*d[from][ind - 1])).any()) {\n            ok = true;\n        }\n        if (!ok) {\n            for (int i = nx[ind][from]; i < ind; i = nx[ind][i + 1]) {\n                if (solve(from, ind - 1, i)) {\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            return 0;\n        }\n    }\n    if (ind < to) {\n        bool ok = false;\n        if (((a[ind] >> (ind + 1)) & (*d[ind + 1][to])).any()) {\n            ok = true;\n        }\n        if (!ok) {\n            for (int i = nx[ind][ind + 1]; i <= to; i = nx[ind][i + 1]) {\n                if (solve(ind + 1, to, i)) {\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            return 0;\n        }\n    }\n    d[from][to]->set(ind - from);\n    return 1;\n}\n\nmt19937 mt(time(0));\n\nint main() {\n//    n = 2000;\n//    for (int i = 1; i < n; ++i) {\n//        forn(j, i) {\n//            if (i % 2 == 1) {\n//                a[i].set(j);\n//            } else {\n//                a[j].set(i);\n//            }\n//        }\n//    }\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        scanf(\"%s\", s);\n        forn(j, i) {\n            if (s[j] == '1') {\n                a[i].set(j);\n            } else {\n                a[j].set(i);\n            }\n        }\n    }\n\n    forn(i, n) {\n        nx[i][n] = n;\n        for (int j = n - 1; j >= 0; --j) {\n            nx[i][j] = nx[i][j + 1];\n            if (a[i].test(j)) {\n                nx[i][j] = j;\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        pref[i] = pref[i - 1];\n        pref[i].set(i - 1);\n    }\n    int ind = 0;\n    forn(i, n) for (int j = i; j < n; ++j) {\n        d[i][j] = e + ind;\n        ind++;\n    }\n    forn(i, n) {\n        d[i][i]->set(0);\n    }\n    memset(win, -1, sizeof win);\n    forn(i, n) {\n        int le = i;\n        while (le > 0 && a[i].test(le - 1)) {\n            --le;\n        }\n        int ri = i;\n        while (ri < n - 1 && a[i].test(ri + 1)) {\n            ++ri;\n        }\n        for (int from = le; from <= i; ++from) {\n            for (int to = i; to <= ri; ++to) {\n                win[from][to] = i;\n            }\n        }\n    }\n    int ans = 0;\n    forn(i, n) {\n        ans += solve(0, n - 1, i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e3+10;\n\nbool a[MAXN][MAXN];\nbool dpl[MAXN][MAXN],dpr[MAXN][MAXN];\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i = 2;i<=n;i++)\n    {\n        getchar();\n        for (int j = 1;j<i;j++)\n        {\n            a[j][i] = !(a[i][j] = getchar() - 48);\n        }\n        dpl[i][i] = dpr[i][i] = 1;\n    }\n    dpr[1][1] = dpl[1][1] = 1;\n    for (int k = 1;k<=n-1;k++)\n    {\n        for (int i = 1;i<=n-k;i++)\n        {\n            int flag = 0;\n            for (int j = i;j<=i+k;j++)\n            {\n                if (!dpl[i][i+k] && j != i && a[i][j] && dpl[j][i + k] && dpr[j][i+1])\n                {\n                    dpl[i][i+k] = 1;\n                    flag++;\n                }\n                if (!dpr[i+k][i] && j != i + k && a[i+k][j] && dpl[j][i+k-1] && dpr[j][i])\n                {\n                    dpr[i+k][i] = 1;\n                    flag++;\n                }\n                if (flag == 2) break;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1;i<=n;i++)\n    if (dpl[i][n] && dpr[i][1]) ans++;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <time.h>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    vector<vector<char>> A(N, vector<char>(N));\n    //static bool A[2048][2048];\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\" %c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<char>> L(N, vector<char>(N));\n    vector<vector<char>> R(N, vector<char>(N));\n    //static bool L[2048][2048];\n    //static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<=i+d; j++)\n                    b |= a[j] & l[j] & r[j];\n                L[i+d][i] = b;\n            }\n \n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i-d; j<i; j++)\n                    b |= a[j] & l[j] & r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n    cout<<ans<<endl;\n\n    cerr<<(double)clock()/CLOCKS_PER_SEC<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint main(){\n    int N;\n    cin>>N;\n    vector<string> S(N);\n    vector<vector<int>> to(N);\n    for(int i=1;i<N;i++){\n            cin>>S[i];\n            for(int j=0;j<i;j++){\n                if(S[i][j]=='1') to[i].push_back(j);\n                if(S[i][j]=='0') to[j].push_back(i);\n            }\n    }\n    int ans=0;\n    for(int i=0;i<N;i++){\n        vector<bool> d(N,false);\n        queue<int> que;\n        que.push(i);\n        d[i]=true;\n        bool kateru=false;\n        for(int j=0;j<to[i].size();j++){\n                int v=to[i][j];\n                if(d[v]) continue;\n                d[v]=true;\n                que.push(v);\n            }\n        while(!que.empty()){\n            int p=que.front();que.pop();\n            for(int j=0;j<to[p].size();j++){\n                int v=to[p][j];\n                if(d[v]) continue;\n                d[v]=true;\n                que.push(v);\n                if(abs(v-p)==1){\n                    kateru=true;\n                }\n            }\n            if(kateru){\n                ans++;\n                break;\n            }\n        }\n    }\n    cout<< ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e3+10;\n\nbool a[MAXN][MAXN];\nbool dp[MAXN][MAXN];\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i = 2;i<=n;i++)\n    {\n        getchar();\n        for (int j = 1;j<i;j++)\n        {\n            a[j][i] = !(a[i][j] = getchar() - 48);\n        }\n        dp[i][i] = dp[i][i] = 1;\n    }\n    dp[1][1] = dp[1][1] = 1;\n    for (int k = 1;k<=n-1;k++)\n    {\n        for (int i = 1;i<=n-k;i++)\n        {\n            int flag = 0;\n            for (int j = i;j<=i+k;j++)\n            {\n                if (!dp[i][i+k] && j != i && a[i][j] && dp[j][i + k] && dp[j][i+1])\n                {\n                    dp[i][i+k] = 1;\n                    flag++;\n                }\n                if (!dp[i+k][i] && j != i + k && a[i+k][j] && dp[j][i+k-1] && dp[j][i])\n                {\n                    dp[i+k][i] = 1;\n                    flag++;\n                }\n                if (flag == 2) break;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1;i<=n;i++)\n    if (dp[i][n] && dp[i][1]) ans++;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  auto a = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a[i][j] = k;\n    a[j][i] = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  for (size_t i = 0; i <= n; i++) dp[i][i + 1] = true;\n  auto renew = [&] (size_t d) {\n    assert(2 <= d && d <= n + 1);\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      for (size_t k = i + 1; k < j; k++) {\n        dp[i][j] |= dp[i][k] && dp[k][j] && (a[i][k] || a[j][k]);\n      }\n    }\n  };\n  for (size_t d = 2; d <= n + 1; d++) renew(d);\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp[0][i] && dp[i][n + 1]) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define ran 2022\n\nint n;\nchar s[ran];\nbool f[ran][ran];\nint lef[ran], rig[ran];\n\nint need_upd[ran][ran];\nint cnu[ran];\n\nint q[ran*ran], l, r;\nbool inq[ran];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i=2;i<=n;i++) {\n\t\tscanf(\"%s\", s);\n\t\tfor(int j=1;j<i;j++) {\n\t\t\tint x = s[j-1]-'0';\n\t\t\tif (x) need_upd[j][cnu[j]++] = i;\n\t\t\telse need_upd[i][cnu[i]++] = j;\n\t\t\tf[i][j] = x; f[j][i] = 1-x;\n\t\t}\n\t}\n\t\t\n\tl=r=0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(i>1&&f[i][i-1]) lef[i] = i-1;\n\t\telse lef[i] = i;\n\t\tif(i<n&&f[i][i+1]) rig[i] = i+1;\n\t\telse rig[i] = i;\n\t\t\n\t\tq[r++] = i;\n\t\tinq[i] = true;\n\t}\n\t\n\tint lim = ran*ran-11;\n\twhile(l!=r) {\n\t\tint cur = q[l++]; // cur = 1 [1,2]; nxt = 3 [3,3];\n\t\tif(l==lim) l=0;\n\t\tfor(int i=0;i<cnu[cur];i++) {\n\t\t\tint nxt = need_upd[cur][i];\n\t\t\tbool upd = false;\n\t\t\tif(nxt<cur && rig[nxt] >= lef[cur]-1 && rig[nxt] < rig[cur]) {\n\t\t\t\trig[nxt] = rig[cur];\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t\tif(cur<nxt && rig[cur] >= lef[nxt]-1 && lef[nxt] > lef[cur]) {\n\t\t\t\tlef[nxt] = lef[cur];\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t\tif(upd && !inq[nxt]) {\n\t\t\t\tq[r++] = nxt;\n\t\t\t\tif(r==lim) r=0;\n\t\t\t\tinq[nxt] = true;\n\t\t\t}\n\t\t}\n\t\tinq[cur] = false;\n\t}\n\t\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(lef[i]==1 && rig[i]==n) {\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\tans++;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1LL<<60)\n#define DEKAI 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define int long long\n\nsigned main(){\n  int n;\n  cin>>n;\n  vector<vector<int>> v(n+1);\n  lp(i,n){\n    if(i==0) continue;\n    for(int j=0;j<i;j++){\n      char c;\n      cin>>c;\n      if(c=='0'){\n        v[j].push_back(i);\n      }\n      else{\n        v[i].push_back(j);\n      }\n    }\n  }\n  int ans=0;\n  lp(z,n){\n    set<int> s;\n    s.insert(z);\n    queue<int> q;\n    q.push(z);\n    while(!q.empty()){\n      int now=q.front();\n      q.pop();\n      lp(i,v[now].size()){\n        int next=v[now][i];\n        \n        if(s.find(next)!=s.end()) continue;\n        if(z>next&&z<now) continue;\n        if(z<next&&z>now) continue;\n        s.insert(next);\n        q.push(next);\n      }\n    }\n    if(s.size()==n)ans++;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing Event = pair<int, pii>;\n\nint N;\nint A[2145][2145];\nbool used[2145];\nvector<int> es[2145];\nvector<Event> fs;\nbool dp[2145][2][2145];\nint mx[2145][2];\n\n//bitset<2000> mat[2000];\n\n\nsigned main(){\n  //ios_base::sync_with_stdio(false);\n  //cout<<fixed<<setprecision(0);\n\n  scanf(\"%d\", &N);\n  //cin >> N;\n  reps(i, 1, N) {\n    rep(j, i) {\n      int w;\n      scanf(\"%01d\", &w);\n      //cin >> w;\n      if (w) {\n        fs.eb(Event(i-j, pii(i, j)));\n      } else {\n        fs.eb(Event(i-j, pii(j, i)));\n      }\n      //A[i][j] = w;\n      //A[j][i] = !w;\n      //mat[i][j] = 1;\n    }\n  }\n  sort(all(fs));\n\n  rep(v, N) {\n    rep(i, 2) {\n      dp[v][i][0] = true;\n    }\n  }\n\n  rep(g, 1) {\n    for (auto &e : fs) {\n      int l = e.X;\n      int u = e.Y.X;\n      int v = e.Y.Y;\n      if (u < v) {\n        if (mx[u][1]+mx[v][0]+1 >= l) {\n          dp[u][1][l] = true;\n          MX(mx[u][1], l);\n          dp[u][1][l+mx[v][1]] = true;\n          MX(mx[u][1], l+mx[v][1]);\n        } \n\n\n        if (dp[v][0][l-1] || dp[u][1][l-1]) {\n          dp[u][1][l] = true;\n          MX(mx[u][1], l);\n          dp[u][1][l+mx[v][1]] = true;\n          MX(mx[u][1], l+mx[v][1]);\n        }\n      } else {\n        if (mx[u][0]+mx[v][1]+1 >= l) {\n          dp[u][0][l] = true;\n          MX(mx[u][0], l);\n          dp[u][0][l+mx[v][0]] = true;\n          MX(mx[u][0], l+mx[v][0]);\n        }\n\n        if (dp[v][1][l-1] || dp[u][0][l-1]) {\n          dp[u][0][l] = true;\n          MX(mx[u][0], l);\n          dp[u][0][l+mx[v][0]] = true;\n          MX(mx[u][0], l+mx[v][0]);\n        }\n      }\n    }\n  }\n\n\n  int ans = 0;\n  rep(v, N) {\n    if (dp[v][0][v] && dp[v][1][N-1-v]) ans++;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nconst int MAX = 2020;\nbool a[MAX][MAX]={};\nusing BS = bitset<MAX>;\nBS st[MAX],dpL[MAX],dpR[MAX];\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(a[i][j]) st[i].set(j);\n      \n  for(int i=0;i<n;i++){\n    dpL[i].set(i);\n    dpR[i].set(i);\n  }\n\n  for(int w=2;w<=n;w++){\n    for(int i=0;i+w<=n;i++){\n      int l=i,r=i+w-1;\n      {\n        BS x=dpR[l+1]&dpL[r]&st[l];      \n        if((int)x._Find_next(l)<=r) dpL[r].set(l);\n      }\n      { \n        BS x=dpR[l]&dpL[r-1]&st[r];\n        if((int)x._Find_next(l-1)<r) dpR[l].set(r);        \n      }\n    }\n  }\n  \n  cout<<(dpR[0]&dpL[n-1]).count()<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nbool A[1000][1000];\nint L[1000];\nint R[1000];\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tREP(j, 0, i) {\n\t\t\tbool ok = Next<char>() - '0';\n\t\t\tA[i][j] = ok;\n\t\t\tA[j][i] = 1 - ok;\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tL[i] = i;\n\t\tR[i] = i + 1;\n \t}\n\n\tREP(z, 0, 30) {\n\t\tREP(i, 0, N) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tif (L[j] <= R[i]) {\n\t\t\t\t\tR[i] = max(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tif (R[j] >= L[i]) {\n\t\t\t\t\tL[i] = min(L[i], L[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tREP(i, 0, N) {\n\t\tif (L[i] == 0 && R[i] == N) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2048; \nusing V=bitset<N>;\nV a[N], L[N], R[N];\n\nvoid solve() {\n    int n; cin >> n;\n    for (int i = 1; i < n; i++) {\n        string s; cin >> s;\n        for (int j = 0; j < i; j++) {\n            int x = s[j]-'0';\n            a[i][j] = x;\n            a[j][i] = x^1;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        L[i][i] = R[i][i] = 1;\n    }\n    for (int d = 1; d < n; d++) {\n        for (int l = 0, r; (r=l+d) < n; l++) {\n            if ((L[l] & R[r-1] & a[r]).count()) L[l][r] = 1;\n            if ((L[l+1] & R[r] & a[l]).count()) R[r][l] = 1;\n        }\n    }\n    int res = (L[0] & R[n-1]).count();\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\nusing bs = bitset<2000>;\n\nsigned main(){\n\n    int N; cin >> N;\n    vector<string> A(N);\n    A[0] = \"\";\n    FOR(i, 1, N) cin >> A[i];\n    vector<bs> W(N);\n    REP(i, N) REP(j, i){\n        if(A[i][j] == '1') W[i][j] = 1;\n        else W[j][i] = 1;\n    }\n    \n    vector<bs> dpl(N), dpr(N);\n    REP(i, N){\n        dpl[i][i] = 1;\n        dpr[i][i] = 1;\n    }\n\n    FOR(d, 1, N){\n        REP(i, N - d){\n            int j = i + d;\n            if((dpr[i] & dpl[j - 1] & W[j]).any()) dpr[i][j] = 1;\n            if((dpr[i + 1] & dpl[j] & W[i]).any()) dpl[j][i] = 1;\n        }\n    }\n    int ans = (dpr[0] & dpl[N - 1]).count();\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _dbg(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _dbg(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_dbg(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\nconst int N=2001;\nusing bt=bitset<N>;\nbool a[N][N];\nbool win[N][N];\nint32_t main() {\n    int n;\n    cin>>n;\n    forn(i,n){\n        forn(j,i){\n            char c;\n            cin>>c;\n            a[i][j]=c-'0';\n            a[j][i]=a[i][j]^1;\n        }\n        win[i][i]=1;\n        // stolb[i][i]=1;\n    }\n    for(int len=2;len<=n;++len){\n        for(int i=0;i+len-1<n;++i){\n            int r=i+len-1;\n            if(a[i][r]){\n                for(int k=i;k<r;++k){\n                    if(win[i][k]&win[r][k+1]){\n                        win[i][r]=1;\n                        // stolb[r][i]=1;                        \n                    }\n                }\n            }\n            for(int k=i+1;k<=r;++k){\n                if(a[i][k]&win[i][k]&win[k][r]){\n                    win[i][r]=1;\n                    // stolb[r][i]=1;                                    \n                }\n            }\n        }\n        for(int i=len-1;i<n;++i){\n            int l=i-len+1;\n            if(a[i][l]){\n                for(int k=i;k>l;--k){\n                    if(win[l][k-1]&win[i][k]){\n                        win[i][l]=1;\n                        // stolb[l][i]=1;                        \n                    }\n                }\n            }\n            for(int k=i-1;k>=l;--k){\n                if(a[i][k]&win[i][k]&win[k][l]){\n                    win[i][l]=1;\n                    // stolb[l][i]=1;                                    \n                }\n            }\n        }\n    }\n    int ans=0;\n    forn(i,n){\n        ans+=(win[i][0]&win[i][n-1]);\n    }\n    cout<<ans<<'\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst ll MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            scanf(\" %c\",&c);\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            bool j1=false;\n            for(int k=j+1;k<=R && !j1;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            bool j1=false;\n            for(int k=R;k<j && !j1;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 2005;\n\nint n;\nchar tmp[N];\nstd::bitset<N> a[N], f[N], g[N];\n\nint main() {\n\tread(n);\n\tfor (int i = 2; i <= n; ++i) {\n\t\treadStr(tmp + 1);\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\ta[i][j] = tmp[j] ^ '0';\n\t\t\ta[j][i] = a[i][j] ^ 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tf[i][i] = g[i][i] = 1;\n\t}\n\tfor (int len = 2; len <= n; ++len) {\n\t\tfor (int l = 1; l <= n - len + 1; ++l) {\n\t\t\tint r = l + len - 1;\n\t\t\tif ((g[l + 1] & f[r] & a[l]).count()) {\n\t\t\t\tf[r][l] = 1;\n\t\t\t}\n\t\t\tif ((g[l] & f[r - 1] & a[r]).count()) {\n\t\t\t\tg[l][r] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = (g[1] & f[n]).count();\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ], st[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind;\n\tind = st[l][l];\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = st[r][l];\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\tint start = clock();\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(wn[i].begin(), wn[i].end());\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint curInd = wn[i].size();\n\t\tfor (int j = n + 1; j >= 0; j--) {\n\t\t\tif (curInd != 0 && wn[i][curInd - 1] > j) curInd--;\n\t\t\tst[i][j] = curInd;\n\t\t}\n\t}\n\n\tll ans = 0;\n\t\n\tvector<ll> perm;\n\tfor (int i = 1; i <= n; i++) perm.push_back(i);\n\n\trandom_shuffle(perm.begin(), perm.end());\n\tfor (int i2 = 1; i2 <= n; i2++) {\n\t\tint i = perm[i2];\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\ntemplate<typename T> vector<T> make_vector(size_t sz){\n\treturn vector<T>(sz);\n}\n\ntemplate<typename T,typename... Ts> \nauto make_vector(size_t sz, Ts... ts){\n\treturn vector<decltype(make_vector<T>(ts...))>(sz, make_vector<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V> \ntypename enable_if<is_same<T, U>::value!=0>::type \nfill_value(U &u, const V... v){\n\tu=U(v...);\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_value(U &u, const V... v){\n\tfor(auto &e:u){\n\t\tfill_value<T>(e,v...);\n\t}\n}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nusing B = bitset<2010>;\n\n\nint A[2010][2010];\nB dpl[2][2010];\nB dpr[2][2010];\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(j, 1, n){\n\t\tstring a;\n\t\tcin >> a;\n\t\trep(i, j){\n\t\t\tA[j][i] = (a[i] == '1');\n\t\t\tA[i][j] = 1 - A[j][i];\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tdpl[0][i].set(i);\n\t\tdpl[1][i].set(i);\n\t\tdpr[0][i].set(i);\n\t\tdpr[1][i].set(i);\n\t}\n\n\trep(d, 1, n + 1)rep(l, n){\n\t\tconst int r = l + d;\n\t\tif(r >= n) continue;\n\n\t\t{\n\t\t\tauto res = dpl[0][l] & dpl[1][r];\n\t\t\tif(res.any()){\n\t\t\t\tdpl[0][l].set(r);\n\t\t\t\tdpl[1][r].set(l);\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tauto res = dpr[0][l] & dpr[1][r];\n\t\t\tif(res.any()){\n\t\t\t\tdpr[0][l].set(r);\n\t\t\t\tdpr[1][r].set(l);\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tauto res = dpl[0][l] & (dpr[1][r] >> 1);\n\t\t\tif(res.any()){\n\t\t\t\tif(A[l][r]){\n\t\t\t\t\tdpl[0][l].set(r);\n\t\t\t\t\tdpl[1][r].set(l);\n\t\t\t\t} else {\n\t\t\t\t\tdpr[0][l].set(r);\n\t\t\t\t\tdpr[1][r].set(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tint ans = 0;\n\trep(i, n){\n\t\tif(dpl[0][i][n - 1] & dpr[1][i][0]){\n\t\t\tans++;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool m[2020][2020];\nbool dp[2][2020][2020];\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tchar z;\n\t\t\tscanf(\" %c\", &z);\n\t\t\tbool t = z - '0';\n\t\t\tm[i][j] = t, m[j][i] = !t;\n\t\t}\n\t}\n\tfor (int i = 0; i < num; i++)dp[0][i][i] = dp[1][i][i] = true;\n\tfor (int k = 1; k < num; k++)\n\t{\n\t\tfor (int i = 0; i < num - k; i++)\n\t\t{\n\t\t\tint j = i + k;\n\t\t\tbool f1 = false, f2 = false;\n\t\t\tfor (int l = i; l < j; l++)f1 |= dp[1][i][l] & dp[0][j - 1][l] & m[j][l];\n\t\t\tfor (int l = i + 1; l <= j; l++)f2 |= dp[1][i + 1][l] & dp[0][j][l] & m[i][l];\n\t\t\tdp[0][j][i] = f2, dp[1][i][j] = f1;\n\t\t}\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < num; i++)c += dp[1][0][i] & dp[0][num - 1][i];\n\tprintf(\"%d\\n\", c);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 2010;\nint n;\nbitset<N>a[N],b[N],f[N][N];\nchar s[N];\n\nint main(){\n\tn=read();\n\tFor(i,2,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFOR(j,1,i){\n\t\t\tif (s[j]=='0') a[j][i]=1,b[i][j]=1;\n\t\t\t\telse b[j][i]=1,a[i][j]=1;\n\t\t}\n\t}\n\tFor(i,1,n) f[i][i][i]=1;\n\tFOR(len,1,n){\n\t\tFor(l,1,n-len+1){\n\t\t\tint r=l+len-1;\n\t\t\tif (r+1<=n){\n\t\t\t\tif ((f[l][r]&a[r+1]).any()) f[l][r+1][r+1]=1;\n\t\t\t\tf[l][r+1]|=(f[l][r]&b[r+1]);\n\t\t\t}\n\t\t\tif (l-1>=1){\n\t\t\t\tif ((f[l][r]&a[l-1]).any()) f[l-1][r][l-1]=1;\n\t\t\t\tf[l-1][r]|=(f[l][r]&b[l-1]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[1][n].count());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\n#define SIZE 2010\nbool A[SIZE][SIZE];\nbitset<SIZE> l[SIZE];\nbitset<SIZE> r[SIZE];\n\n\nint main() {\n  ll N;\n  cin >> N;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < i; ++j) {\n      char a;\n      cin >> a;\n      A[i][j] = a == '1';\n      A[j][i] = !A[i][j];\n    }\n  }\n\n  for (int i = N - 1; i >= 0; --i) {\n    l[i][i] = true;\n    r[i][i + 1] = true;\n    bitset<SIZE> X;\n    for (int j = i + 1; j < N; ++j) {\n      if ((l[j] & r[i]).any()) {\n        if (A[i][j])\n          r[i] |= r[j];\n        else {\n          l[j][i] = true;\n          X[j] = true;\n        }\n      }\n      if ((X & l[j]).any()) {\n        l[j][i] = true;\n        X[j] = true;\n      }\n    }\n  }\n\n  ll ret=0;\n  for(int i=0;i<N;i++)\n  {\n    if(l[i][0]&&r[i][N])\n    {\n      ret++;\n    }\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define ran 2022\n\nint n;\nchar s[ran];\nbool f[ran][ran];\nint lef[ran], rig[ran];\n\nint need_pull[ran][ran];\nint cnp[ran];\n\nint need_upd[ran][ran];\nint cnu[ran];\n\nint q[ran*ran], l, r;\nbool inq[ran];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i=2;i<=n;i++) {\n\t\tscanf(\"%s\", s);\n\t\tfor(int j=1;j<i;j++) {\n\t\t\tint x = s[j-1]-'0';\n\t\t\tif (x) {\n\t\t\t\tneed_pull[i][cnp[i]++] = j;\n\t\t\t\tneed_upd[j][cnu[j]++] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tneed_pull[j][cnp[i]++] = i;\n\t\t\t\tneed_upd[i][cnu[i]++] = j;\n\t\t\t}\n\t\t\tf[i][j] = x; f[j][i] = 1-x;\n\t\t}\n\t}\n\t\t\n\tl=r=0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(i>1&&f[i][i-1]) lef[i] = i-1;\n\t\telse lef[i] = i;\n\t\tif(i<n&&f[i][i+1]) rig[i] = i+1;\n\t\telse rig[i] = i;\n\t\t\n\t\tq[r++] = i;\n\t\tinq[i] = true;\n\t}\n\t\n\tint lim = ran*ran-11;\n\twhile(l!=r) {\n\t\tint cur = q[l++]; // cur = 1 [1,2]; nxt = 3 [3,3];\n\t\tif(l==lim) l=0;\n\t\t/*for(int i=0;i<cnp[cur];i++) {\n\t\t\tint nxt = need_pull[cur][i];\n\t\t\t\n\t\t\tif (nxt<cur && rig[nxt]>=lef[cur]-1) lef[cur] = min(lef[cur], lef[nxt]);\n\t\t\tif (cur<nxt && rig[cur]>=lef[nxt]-1) rig[cur] = max(rig[cur], rig[nxt]);\n\t\t}*/\n\t\tfor(int i=0;i<cnu[cur];i++) {\n\t\t\tint nxt = need_upd[cur][i];\n\t\t\tbool upd = false;\n\t\t\tif(nxt<cur && rig[nxt] >= lef[cur]-1 && rig[nxt] < rig[cur]) {\n\t\t\t\trig[nxt] = rig[cur];\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t\tif(cur<nxt && rig[cur] >= lef[nxt]-1 && lef[nxt] > lef[cur]) {\n\t\t\t\tlef[nxt] = lef[cur];\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t\tif(upd && !inq[nxt]) {\n\t\t\t\tq[r++] = nxt;\n\t\t\t\tif(r==lim) r=0;\n\t\t\t\tinq[nxt] = true;\n\t\t\t}\n\t\t}\n\t\tinq[cur] = false;\n\t}\n\t\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) {\n\t\t//printf(\"%d %d\\n\", lef[i], rig[i]);\n\t\tif(lef[i]<=1 && rig[i]>=n) {\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nbitset<N> LR[N][N], L[N], R[N], A[N];\nint n;\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++){\n\t\tint x;\n\t\tcin >> x;\n\t\tA[i][j] = x;\n\t}\n\tfor (int i = 1; i <= n; i++) for (int j = i; j <= n; j++){\n\t\tLR[i][j] = LR[i][j - 1];\n\t\tLR[i][j] = 1;\n\t}\n\t\n\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e6+3)\n\nll N,A[2222][2222];\nchar a[2222];\nll btrR[2222][2222], btrL[2222][2222];\nlist<ll> rlst[2222];\nll i, j, k, ans;\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        scanf(\"%s\", a);\n        fornum(j,0,i){\n            A[i + 1][j + 1] = a[j]=='1';\n            A[j + 1][i + 1] = a[j]=='0';\n        }\n    }\n    btrR[N][N] = 1;\n    for (i = N; i > 0;i--){\n        for (j = i + 1; j <= N;j++){\n            if(btrR[i+1][j]){\n                if(A[i][j]){\n                    btrR[i][i] = 1;\n                }else{\n                    btrR[i][j] = 1;\n                }\n            }\n        }\n        ll ii = i;\n        for (j = i + 1; j <= N;j++){\n            if(A[j][ii]){\n                if(btrR[j][j]){\n                    btrR[i][j] = 1;\n                break;\n                }else{\n                    \n                    ii = j;\n                }\n            }\n        }\n    }\n    btrL[1][1] = 1;\n    for (i = 1; i <= N;i++){\n        for (j = 1; j <i ;j++){\n            if(btrL[i-1][j]){\n                if(A[i][j]){\n                    btrL[i][i] = 1;\n                }else{\n                    btrL[i][j] = 1;\n                }\n            }\n        }\n        ll ii = i;\n        for (j =i-1; j >=1;j--){\n            if(A[j][ii]){\n                if(btrL[j][j]){\n                    btrL[i][j] = 1;\n                    break;\n                }else{\n                    ii = j;\n                }\n            }\n        }\n    }\n    /*\n    fornum(i,1,N+1){\n        fornum(j,1,N+1){\n            printf(\"%lld:%lld \", btrL[i][j], btrR[i][j]);\n        }\n        printf(\"\\n\");\n    }*/\n    fornum(i,1,N+1){\n        ll aa = 0, bb = 0;\n        if(btrL[i][i]*btrR[i][i]==1)\n            ans++;\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e3+10;\n\nbitset<MAXN> a[MAXN],dpl[MAXN],dpr[MAXN];\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i = 2;i<=n;i++)\n    {\n        getchar();\n        for (int j = 1;j<i;j++)\n        {\n            a[j][i] = !(a[i][j] = getchar() - 48);\n        }\n        dpl[i][i] = dpr[i][i] = 1;\n    }\n    dpr[1][1] = dpl[1][1] = 1;\n    for (int k = 1;k<=n-1;k++)\n    {\n        for (int i = 1;i<=n-k;i++)\n        {\n            int j = i + k;\n            dpl[j][i] = (a[i] & dpl[j] & dpr[i+1]).any();\n            dpr[i][j] = (a[j] & dpl[j-1] & dpr[i]).any();\n        }\n    }\n    int ans = 0;\n    for (int i = 1;i<=n;i++)\n    if (dpl[n][i] && dpr[1][i]) ans++;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\nusing namespace std;\nconst int Max_N(2050);\n\nint N, A[Max_N][Max_N], F[Max_N][Max_N][2];\nchar input[Max_N];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 2;i <= N;++i)\n\t{\n\t\tscanf(\"%s\", input + 1);\n\t\tfor (int j = 1;j <= i - 1;++j)\n\t\t\tA[j][i] = 1 - (A[i][j] = input[j] - '0');\n\t}\n\tfor (int i = 1;i <= N;++i)\n\t\tF[i][i][0] = F[i][i][1] = 1;\n\tfor (int i = 1;i <= N - 1;++i)\n\t\tF[i][i + 1][A[i + 1][i]] = 1;\n\tfor (int len = 3;len <= N;++len)\n\t\tfor (int l = 1, r = len;r <= N;++l, ++r)\n\t\t{\n\t\t\tfor (int x = l + 1;x <= r;++x)\n\t\t\t\tF[l][r][1] |= (F[l][x][1] & F[x][r][1]);\n\t\t\tif (A[r][l])\n\t\t\t\tfor (int mid = l;mid <= r - 1;++mid)\n\t\t\t\t\tF[l][r][1] |= (F[l][mid][0] & F[mid + 1][r][1]);\n\t\t\tfor (int x = l;x <= r - 1;++x)\n\t\t\t\tF[l][r][0] |= (F[x][r][0] & F[l][x][0]);\n\t\t\tif (A[l][r])\n\t\t\t\tfor (int mid = l + 1;mid <= r;++mid)\n\t\t\t\t\tF[l][r][0] |= (F[mid][r][1] & F[l][mid - 1][0]);\n\t\t}\n\tint Ans(0);\n\tfor (int x = 1;x <= N;++x)\n\t\tAns += (F[1][x][1] & F[x][N][0]);\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nbool A[1000][1000];\nint L[1000];\nint R[1000];\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tREP(j, 0, i) {\n\t\t\tbool ok = Next<char>() - '0';\n\t\t\tA[i][j] = ok;\n\t\t\tA[j][i] = 1 - ok;\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tL[i] = i;\n\t\tR[i] = i + 1;\n \t}\n\n\tREP(z, 0, 500) {\n\t\tREP(i, 0, N) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tif (L[j] <= R[i]) {\n\t\t\t\t\tR[i] = max(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tif (R[j] >= L[i]) {\n\t\t\t\t\tL[i] = min(L[i], L[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tREP(i, 0, N) {\n\t\tif (L[i] == 0 && R[i] == N) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\nconst int N = 2000;\nbitset<N> a[N];\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  REP(i, 1, n) {\n    string s;\n    cin >> s;\n    REP(j, 0, i) {\n      a[i][j] = s[j] == '1';\n      a[j][i] = s[j] == '0';\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n) {\n      cerr << \"a[\" << i << \"]\";\n      REP(j, 0, n) {\n        cerr << a[i][j];\n      }\n      cerr << endl;\n    }\n  }\n  int ans = 0;\n  REP(i, 0, n) {\n    bitset<N> cur = a[i];\n    int arch = -1;\n    REP(j, i + 1, n) {\n      if (arch < 0) {\n        if (cur[j]) {\n          cur |= a[j];\n        } else {\n          arch = j;\n        }\n      } else {\n        if (a[arch][j]) {\n          // do nothing\n        } else {\n          if (cur[j]) {\n            cur |= a[j];\n            arch = -1;\n          } else {\n            arch = j;\n          }\n        }\n      }\n    }\n    bool rwin = arch < 0;\n    arch = -1;\n    cur = a[i];\n    for (int j = i - 1; j >= 0; --j) {\n      if (arch < 0) {\n        if (cur[j]) {\n          cur |= a[j];\n        } else {\n          arch = j;\n        }\n      } else {\n        if (a[arch][j]) {\n          // do nothing\n        } else {\n          if (cur[j]) {\n            cur |= a[j];\n            arch = -1;\n          } else {\n            arch = j;\n          }\n        }\n      }\n    }\n    bool lwin = arch < 0;\n    ans += lwin && rwin ? 1 : 0;\n    if (DEBUG) {\n      cerr << \"i = \" << i << \" lwin = \" << lwin << \" rwin = \" << rwin << endl;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef bitset<2005> bs;\n\nbool f[2005][2005],e[2005][2005];\nbs g[2005],h[2005];\n\nchar str[2005];\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=2;i<=n;i++) {\n  \tscanf(\"%s\",str+1);\n  \tfor(int j=1;j<i;j++)\n  \t  if (str[j]=='1') e[i][j]=1; else e[j][i]=1;\n  }\n  for(int i=1;i<=n;i++) {\n  \tf[i][i]=1;\n  \th[i].flip(i);\n  }\n  for(int j=2;j<=n;j++) {\n    for(int i=j;i<=n;i++) {\n    \tint l=i-j+1;\n    \tif (e[i][l]&&f[l][i-1]) g[i].flip(l);\n    \tif ((g[i]&h[l]).any()) {\n    \t\tf[i][l]=1;\n    \t\th[l].flip(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n-j+1;i++) {\n\t\tint r=i+j-1;\n\t\tif (e[i][r]&&f[r][i+1]) g[i].flip(r);\n\t\tif ((g[i]&h[r]).any()) {\n\t\t\tf[i][r]=1;\n\t\t\th[r].flip(i);\n\t\t}\n\t}\n  }\n  int ans=0;\n  for(int i=1;i<=n;i++) ans+=(f[i][1]&&f[i][n]);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <time.h>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    vector<vector<bool>> A(N, vector<bool>(N));\n    //static bool A[2048][2048];\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\" %c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<bool>> L(N, vector<bool>(N));\n    vector<vector<bool>> R(N, vector<bool>(N));\n    //static bool L[2048][2048];\n    //static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                bool b = false;\n                for (int j=i+1; j<=i+d; j++)\n                    b |= A[i][j] & L[i+d][j] & R[i+1][j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                bool b = false;\n                for (int j=i-d; j<i; j++)\n                    b |= A[i][j] & L[i-1][j] & R[i-d][j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n    cout<<ans<<endl;\n\n    cerr<<(double)clock()/CLOCKS_PER_SEC<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing _loop_int = int;\n#define REP(i,n) for(_loop_int i=0; i<(_loop_int)(n); i++)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a); i<(_loop_int)(b); i++)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1; i>=(_loop_int)(a); i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n#define ALL(v) (v).begin(),(v).end()\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define DEBUG_VEC(v) cerr<<#v<<\": \";REP(__i,(v).size())cerr<<((v)[__i])<<\", \";cerr<<endl\n\nconst ll MOD = 1000000007ll;\n\nint n;\nchar s[2521][2521];\nbool win[2521][2521];\nint nxt[2521][2521];\nshort yusho[2521][2521][2];\n\nint main(){\n    scanf(\"%d\",&n);\n    REP(i,n-1)scanf(\"%s\",s[i+1]);\n    REP(i,n)REP(j,i){\n        win[i][j] = s[i][j]=='1';\n        win[j][i] = !win[i][j];\n    }\n    REP(i,n){\n        nxt[i][n] = n;\n        FORR(j,0,n){\n            nxt[i][j] = win[i][j] ? j : nxt[i][j+1];\n        }\n    }\n    REP(k,2)REP(i,n+1)yusho[i][i][k] = 1;\n    FOR(len,1,n)REP(k,2)REP(l,n){\n        int r = l+len;\n        int p = k==0 ? l-1 : r;\n        if(r>n || p>=n)break;\n        if(p<0)continue;\n        int to = nxt[p][l];\n        while(to<r){\n            bool ok = yusho[l][to][1] && yusho[to+1][r][0];\n            if(ok){\n                yusho[l][r][k] = 1;\n                break;\n            }\n            to = nxt[p][to+1];\n        }\n    }\n    int ans = 0;\n    REP(i,n){\n        bool ok = yusho[0][i][1] && yusho[i+1][n][0];\n        if(ok)ans++;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbool win[2020][2020];\nbool dp[2][2020][2020];\nsigned main() {\n    int N; scanf(\"%d\", &N);\n    \n    for(int i=0; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; scanf(\" %c\", &c);\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[0][i][i] = dp[1][i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            bool f1 = false, f2 = false;\n            for(int k=i; k<j; k++) {\n                f2 |= dp[1][i][k] & dp[0][j-1][k] & win[j][k];\n            }\n            for(int k=i+1; k<=j; k++) {\n                f1 |= dp[0][j][k] & dp[1][i+1][k] & win[i][k];\n            }\n            dp[0][j][i] = f1, dp[1][i][j] = f2;\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dp[0][N-1][i] & dp[1][0][i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst ll MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            char c;\n            cin>>c;\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            for(int k=j+1;k<=j+i;k++){\n                dp[R][j]|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            for(int k=j-i;k<j;k++){\n                dp[R][j]|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst ll MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            char c;\n            cin>>c;\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;j+i<n;j++){\n            for(int k=j+1;k<=j+i;k++){\n                dp[j][j+i]|=A[j][k] & dp[k][j+1] & dp[k][j+i];\n            }\n        }\n        for(int j=i;j<n;j++){\n            for(int k=j-i;k<j;k++){\n                dp[j][j-i]|=A[j][k] & dp[k][j-1] & dp[k][j-i];\n            }\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[i][0] && dp[i][n-1]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing ull = unsigned long long;\n\null dpL[2002][32]; // dp[i][*]\null dpR[2002][32]; // dp[*][j]\null A[2002][32];\n\nvoid set(ull *a, int k) {\n  a[k >> 6] |= 1ULL << (k & 0x3f);\n}\n\nbool test(ull *a, int k) {\n  return a[k >> 6] >> (k & 0x3f) & 1;\n}\n\nbool exists(ull *a, int l, int r) {\n  while (l < r) {\n    if (l % 64 == 0 && l + 64 <= r) {\n      if (a[l / 64]) return true;\n      l += 64;\n    } else {\n      if (test(a, l++)) return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int N;\n  cin >> N;\n  for (int i = 2; i <= N; i++) {\n    string s;\n    cin >> s;\n    for (int j = 1; j <= i - 1; j++) {\n      if (s[j-1] == '1') {\n        set(A[i], j);\n      } else {\n        set(A[j], i);\n      }\n    }\n  }\n  for (int i = 0; i+1 <= N+1; i++) {\n    set(dpL[i], i + 1);\n    set(dpR[i + 1], i);\n  }\n  for (int d = 2; d <= N; d++) {\n    for (int i = 0; i + d <= N+1; i++) {\n      int j = i + d;\n      ull tmp[32] = {};\n      for (int k = 0; k < 32; k++) {\n        tmp[k] = A[i][k] | A[j][k];\n      }\n      for (int k = 0; k < 32; k++) {\n        tmp[k] &= dpL[i][k] & dpR[j][k];\n      }\n      // i < k < j\n      if (exists(tmp, i + 1, j)) {\n        set(dpL[i], j);\n        set(dpR[j], i);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= N; i++) {\n    if (test(dpL[0], i) && test(dpL[i], N+1)) {\n      ans++;\n    }\n  }\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint m[2020][2020];\nbool dp[2][2020][2020];\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tchar z;\n\t\t\tscanf(\" %c\", &z);\n\t\t\tbool t = z - '0';\n\t\t\tm[i][j] = t, m[j][i] = !t;\n\t\t}\n\t}\n\tfor (int i = 0; i < num; i++)dp[0][i][i] = dp[1][i][i] = true;\n\tfor (int k = 1; k < num; k++)\n\t{\n\t\tfor (int i = 0; i < num - k; i++)\n\t\t{\n\t\t\tint j = i + k;\n\t\t\tbool f1 = false, f2 = false;\n\t\t\tfor (int l = i; l < j; l++)f1 |= dp[1][i][l] & dp[0][j - 1][l] & m[j][l];\n\t\t\tfor (int l = i + 1; l <= j; l++)f2 |= dp[1][i + 1][l] & dp[0][j][l] & m[i][l];\n\t\t\tdp[0][j][i] = f2, dp[1][i][j] = f1;\n\t\t}\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < num; i++)c += dp[1][0][i] & dp[0][num - 1][i];\n\tprintf(\"%d\\n\", c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define sz(a) (int)a.size()\n#define x first\n#define y second\n#define debug(...) cout << \"[\" << #__VA_ARGS__ << \": \" << __VA_ARGS__ << \"]\\n\"\n#define rd() abs((int)rng())\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int>pii;\nconst int maxn = 2e3 + 100;\nconst int mod = 1e9 + 7;\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\nint n;\nbitset<maxn>dpl[maxn], dpr[maxn], wins[maxn];\nint main()\n{\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 1; j <= sz(s); j++)\n\t\t{\n\t\t\tif(s[j - 1] == '0')\n\t\t\t{\n\t\t\t\twins[i][j] = 0;\n\t\t\t\twins[j][i] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twins[i][j] = 1;\n\t\t\t\twins[j][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tdpl[i][i] = dpr[i][i] = 1;\n\tfor(int len = 2; len <= n; len++)\n\t{\n\t\tfor(int i = len; i <= n; i++)\n\t\t{\n\t\t\tif((dpr[i - 1] & dpl[i - len + 1] & wins[i]).any())\n\t\t\t\tdpl[i - len + 1][i] = 1;\n\t\t}\n\t\tfor(int i = n - len + 1; i >= 1; i--)\n\t\t{\n\t\t\tif((dpl[i + 1] & dpr[i + len - 1] & wins[i]).any())\n\t\t\t\tdpr[i + len - 1][i] = 1;\n\t\t}\n\t}\n\tcout << (dpl[1] & dpr[n]).count() << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=2005;\nint n;\nint a[N][N];\nbool fl[N][N],fr[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t\tscanf(\"%1d\",&a[i][j]),a[j][i]=a[i][j]^1;\n\tfor(int i=1;i<=n;i++)\n\t\tfl[i][i]=fr[i][i]=true;\n\tfor(int len=2;len<=n;len++)\n\t\tfor(int i=1;i+len-1<=n;i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tfor(int k=i+1;k<=j;k++)\n\t\t\t\tif(a[i][k]) fl[i][j]|=fr[i+1][k]&fl[k][j];\n\t\t\tfor(int k=i;k<=j-1;k++)\n\t\t\t\tif(a[j][k]) fr[i][j]|=fr[i][k]&fl[k][j-1];\n\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(fr[1][i]&&fl[i][n]) ans++;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  constexpr size_t max = 2002;\n  auto a = std::vector<std::bitset<max>>(n + 2);\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a[i][j] = k;\n    a[j][i] = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::bitset<max>>(n + 2);\n  for (size_t i = 0; i <= n; i++) dp[i][i + 1] = dp[i + 1][i] = true;\n  for (size_t d = 2; d <= n + 1; d++) {\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      dp[j][i] = dp[i][j] = (dp[i] & dp[j] & (a[i] | a[j])).any();\n    }\n  }\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp[0][i] & dp[i][n + 1]) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nconst int MAX = 2020;\nbool a[MAX][MAX]={};\nbool dpL[MAX][MAX]={};\nbool dpR[MAX][MAX]={};\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    dpL[i][i]=dpR[i][i]=1; \n\n  for(int w=2;w<=n;w++){\n    {\n      int l=0,r=w-1;\n      for(int k=l;k<r;k++)\n        dpR[l][r]|=dpR[l][k]&dpL[r-1][k]&a[r][k];    \n    }    \n    for(int i=1;i+w<=n+1;i++){\n      int l=i,r=i+w-1;\n      for(int k=l;k<r;k++){\n        dpL[r-1][l-1]|=dpR[l][k]&dpL[r-1][k]&a[l-1][k];        \n        dpR[l][r]|=dpR[l][k]&dpL[r-1][k]&a[r][k];\n      }\n    }\n  }\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    if(dpR[0][i]&dpL[n-1][i]) ans++;  \n  cout<<ans<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n;\nbool dpl[2000][2000];\nbool dpr[2000][2000];\nbool table[2000][2000];\n\nint main() {\n    cin >> n;\n    rep(i,n-1) {\n        rep(j,i+1) {\n            char c; cin >> c;\n            if (c == '1') table[i+1][j] = true;\n            else table[j][i+1] = true;\n        }\n    }\n    rep(i,n) {\n        dpl[i][i] = true;\n        dpr[i][i] = true;\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n-i; j++) {\n            for (int k = j+1; k < j+i; k++) {\n                dpr[j+i][j] |= (table[j][k] && dpr[j+i][k] && dpl[j+1][k]);\n                dpl[j][j+i] |= (table[j+i][k] && dpr[j+i-1][k] && dpl[j][k]);\n            }\n            dpr[j+i][j] |= (table[j][j+i] && dpl[j+1][j+i]);\n            dpl[j][j+i] |= (table[j+i][j] && dpr[j+i-1][j]);\n        }\n    }\n    int ans = 0;\n    rep(i,n) {\n        if (dpl[0][i] && dpr[n-1][i]) ans++;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string s;\n    int n, ans = 0;\n    cin >> n;\n    int a[n] = {0};\n    for(int i = 0; i < n-1; ++i) {\n        cin >> s;\n        for(int j = 0; j < s.size(); ++j) {\n            if(s[j] == '0') a[j] = 1;\n        }\n    }\n    for(int i = 0; i < n-1; ++i) {\n        ans += a[i];\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _dbg(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _dbg(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_dbg(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\nconst int N=2000;\nusing bt=bitset<N>;\nbt a[N],win[N],sto[N];\nint32_t main() {\n    int n;\n    cin>>n;\n    forn(i,n){\n        forn(j,i){\n            char c;\n            cin>>c;\n            a[i][j]=c-'0';\n            a[j][i]=a[i][j]^1;\n        }\n        win[i].set(i);\n        sto[i].set(i);\n    }\n    for(int len=2;len<=n;++len){\n        for(int i=0;i+len-1<n;++i){\n            int r=i+len-1;\n            if(a[i][r]){\n                if((win[i]&(win[r]>>1)).any()){\n                    win[i].set(r);\n                    sto[r].set(i);\n                }\n            }\n            if((a[i]&win[i]&sto[r]).any()){\n                win[i].set(r);\n                sto[r].set(i);\n            }\n        }\n        for(int i=len-1;i<n;++i){\n            int l=i-len+1;\n            if(a[i][l]){\n                if((win[i]&(win[l]<<1)).any()){\n                    win[i].set(l);\n                    sto[l].set(i);\n                }\n            }\n            if((a[i]&win[i]&sto[l]).any()){\n                win[i].set(l);\n                sto[l].set(i);                \n            }\n        }\n    }\n    int ans=0;\n    forn(i,n){\n        ans+=(win[i][0]&win[i][n-1]);\n    }\n    cout<<ans<<'\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <bitset>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nusing bits = bitset<2001>;\n// using bits = bitset<10>;\n\n// vector<vector<bits>> dp;\n// vector<vector<int>> calc;\n// bits& rec(vector<bits>& a, int l, int r){\n//   if(calc[l][r]) return dp[l][r];\n//   if(r-l == 0){\n//     dp[l][r].set(l, 1);\n//     calc[l][r] = 1;\n//     return dp[l][r];\n//   }\n//   if(r-l == 1){\n//     dp[l][r].set(l, 1);\n//     calc[l][r] = 1;\n//     return dp[l][r];\n//   }\n//   if(r-l == 2){\n//     if(a[l][l+1]){\n//       dp[l][r].set(l, 1);\n//     }else{\n//       dp[l][r].set(l+1, 1);\n//     }\n//     calc[l][r] = 1;\n//     return dp[l][r];\n//   }\n//   for(int i=l; i<r; i++){\n//     bool bl = true;\n//     bool br = true;\n//     if(i > l){\n//       if((rec(a, l, i) & a[i]).count() == 0){\n//         bl = false;\n//       }\n//     }\n//     if(i+1 < r){\n//       if((rec(a, i+1, r) & a[i]).count() == 0){\n//         br = false;\n//       }\n//     }\n//     if(bl && br){\n//       dp[l][r].set(i, 1);\n//     }\n//   }\n//   calc[l][r] = 1;\n//   return dp[l][r];\n// }\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<bits> a(n);\n  vector<vector<int>> b(n, vector<int>(n));\n  for(int i=1, j=1; i<n; i++, j++){\n    string s;\n    cin >> s;\n\n    for(int k=0; k<j; k++){\n      b[i][k] = s[k] == '1' ? 1 : 0;\n      b[k][i] = !b[i][k];\n    }\n  }\n\n  for(int i=0; i<n; i++){\n    // a[i].set(i);\n    for(int j=0; j<n; j++){\n      if(b[i][j]){\n        a[i].set(j);\n      }\n    }\n  }\n\n  // dp = vector<vector<bits>>(n+1, vector<bits>(n+1));\n  // calc = vector<vector<int>>(n+1, vector<int>(n+1));\n\n  // auto& v = rec(a, 0, n);\n  // int ans = v.count();\n  // println(ans);\n\n  vector<bits> dpl(n+1), dpr(n+1);\n  for(int i=0; i<n; i++){\n    dpl[i].set(i);\n    dpr[i].set(i);\n  }\n\n  for(int len=2; len<=n; len++){\n    // vector<pair<int,int>> nwl, nwr;\n    for(int l=0; l+len<=n; l++){\n      int r = l+len-1;\n      if((dpl[l+1] & dpr[l+len-1] & a[l]).count()){\n        dpr[l+len-1].set(l, 1);\n        // nwr.emplace_back(l+len-1, l);\n      }\n      if((dpr[r-1] & dpl[l] & a[r]).count()){\n        dpl[l].set(r, 1);\n        // nwl.emplace_back(l, r);\n      }\n    }\n    // for(auto p: nwl){\n    //   dpl[p.first].set(p.second);\n    // }\n    // for(auto p: nwr){\n    //   dpr[p.first].set(p.second);\n    // }\n  }\n\n  int ans = (dpl[0] & dpr[n-1]).count();\n  println(ans);\n\n  // for(int i=0; i<n; i++){\n  //   eprint(dpl[0][i]);\n  // }\n  // eprintln(\"\");\n\n  // for(int i=0; i<n; i++){\n  //   eprint(dpr[n-1][i]);\n  // }\n  // eprintln(\"\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n#include <bits/stdc++.h>\n\n\nusing namespace std;\ntemplate<class T1, class T2> inline void chkmin(T1 &x, const T2 &y) {if (x > y) x = y;}\ntemplate<class T1, class T2> inline void chkmax(T1 &x, const T2 &y) {if (x < y) x = y;}\n#define all(c) (c).begin(), (c).end()\n#define sz(c) (int)(c).size()\n#define mp make_pair\n#define pb push_back\n#define read(FILENAME) freopen((string(FILENAME) + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((string(FILENAME) + \".out\").c_str(), \"w\", stdout);\nconst int MAXN = 2003;\n\n\nint n;\nbitset<2001> w[MAXN];\nbitset<2001> dp[MAXN];\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//read(\"input\");\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (s[j] == '0') {\n\t\t\t\tw[j][i] = 1;\n\t\t\t} else {\n\t\t\t\tw[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i][i] = 1;\n\t}\n\tfor (int len = 1; len < n; len++) {\n\t\tfor (int i = 0; i <= n - len; i++) {\n\t\t\tint j = i + len;\n\t\t\tbitset<2001> tmp = dp[i + 1] & dp[j] & w[i];\n       \t\tdp[j][i] = (tmp._Find_next(i) <= j);\n        \ttmp = dp[i] & dp[j - 1] & w[j];\n        \tdp[i][j] = (tmp._Find_next(i - 1) < j);\n\t\t}\n\t}\n\tcout << (dp[0] & dp[n - 1]).count() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2009;\nchar ch[N];\nint n;\nbitset<N>dp[2][N],a[N];\n//int dp[2][N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",ch+1);\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\ta[i][j]=ch[j]-48,a[j][i]=!a[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)dp[0][i][i]=dp[1][i][i]=1;\n\tfor(int len=2;len<=n;len++)\n\t{\n\t\tfor(int i=1;i<=(n-len+1);i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tif((dp[0][j]&dp[1][i+1]&a[i]).any())dp[0][j][i]=1;\n\t\t\tif((dp[1][i]&dp[0][j-1]&a[j]).any())dp[1][i][j]=1;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(dp[0][n][i]&&dp[1][1][i])ans++;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar ch[2010][2010];\n\nint n;\n\nbool B[2010][2010];\n\nint Ans[2010][2010][2];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 2; i <= n; i++) scanf(\"%s\", ch[i] + 1);\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; j < i; j++)\n\t\t\t(B[i][j] = ch[i][j] - '0'), B[j][i] = !B[i][j];\n\tfor(int i = 1; i <= n; i++) Ans[i][i][0] = (Ans[i][i][1] = 1);\n\tfor(int i = 1; i < n; i++)\n\t\tif(B[i][i + 1]) Ans[i][i + 1][0] = 1; else Ans[i][i + 1][1] = 1;\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; i + j <= n; j++) {\n\t\t\tint l = j, r = i + j;\n\t\t\tfor(int k = l + 1; k <= r; k++) if(B[l][k] && Ans[l + 1][k][1] && Ans[k][r][0]) {Ans[l][r][0] = 1; break;}\n\t\t\tfor(int k = l; k < r; k++) if(B[r][k] && Ans[l][k][1] && Ans[k][r - 1][0]) {Ans[l][r][1] = 1; break;}\n\t\t}\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i++) tot += Ans[1][i][1] && Ans[i][n][0];\n\tprintf(\"%d\\n\", tot);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n;\nbool dpl[2000][2000];\nbool dpr[2000][2000];\nbool table[2000][2000];\n\nint main() {\n    cin >> n;\n    rep(i,n-1) {\n        rep(j,i+1) {\n            char c; cin >> c;\n            if (c == '1') table[i+1][j] = true;\n            else table[j][i+1] = true;\n        }\n    }\n    rep(i,n) {\n        dpl[i][i] = true;\n        dpr[i][i] = true;\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n-i; j++) {\n            for (int k = j+1; k < j+i; k++) {\n                dpr[j][j+i] |= (table[j][k] && dpr[k][j+i] && dpl[j+1][k]);\n                if (dpr[j][j+i]) break;\n            }\n            for (int k = j+1; k < j+i; k++) {\n                dpl[j][j+i] |= (table[j+i][k] && dpr[k][j+i-1] && dpl[j][k]);\n                if (dpl[j][j+i]) break;\n            }\n            dpr[j][j+i] |= (table[j][j+i] && dpl[j+1][j+i]);\n            dpl[j][j+i] |= (table[j+i][j] && dpr[j][j+i-1]);\n        }\n    }\n    int ans = 0;\n    rep(i,n) {\n        if (dpl[0][i] && dpr[i][n-1]) ans++;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N;\nint A[2005][2005];\nint before[2005][2005];\nint subbefore[2005];\nint after[2005][2005];\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    for(int i = 2; i <= N; i++) {\n        string S;\n        cin >> S;\n        for(int j = 0; j < S.size(); j++) {\n            A[i][j+1] = S[j] - '0';\n            A[j+1][i] = 1 - A[i][j+1];\n            //cerr << i << \" \" << j + 1 << \" \" << A[i][j+1] << endl;\n        }\n    }\n    for(int i = 1; i <= N; i++) {\n        before[i][i] = i;\n        after[i][i] = i;\n        subbefore[i] = i;\n        for(int j = i - 1; j >= 1; j--) {\n            before[i][j] = before[i-1][j];\n            if(before[i][i] <= j) {\n                chmin(before[i][i], before[i-1][j]);\n            } else if(after[i-1][j] + 1 >= subbefore[after[i-1][j]+1]) {\n                if(A[i][j] == 1) chmin(before[i][i], before[i-1][j]);\n            }\n            subbefore[j] = before[i][i];\n        }\n        int minimum = i;\n        for(int j = i - 1; j >= 1; j--) {\n            after[i][j] = after[i-1][j];\n            if(after[minimum][j] >= minimum) {\n                chmax(after[i][j], i);\n            } else if(after[i][j] + 1 >= before[i][i]) {\n                if(A[j][i] == 1) chmax(after[i][j], i);\n            }\n            if(after[i][j] == i) minimum = j;\n        }\n    }\n    for(int TIME = 1; TIME <= N; TIME++) {\n        //cerr << \"----\" << TIME << \"----\" << endl;\n        for(int i = 1; i <= TIME; i++) {\n            //cerr << i << \" \" << before[TIME][i] << \" \" << after[TIME][i] << endl;\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= N; i++) {\n        if(before[N][i] == 1 && after[N][i] == N) ans++;\n        //cerr << before[N][i] <<  \" \" << after[N][i] << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint main(){\n    int N;\n    cin>>N;\n    vector<string> S(N);\n    vector<vector<int>> to(N);\n    for(int i=1;i<N;i++){\n            cin>>S[i];\n            for(int j=0;j<i;j++){\n                if(S[i][j]=='1') to[i].push_back(j);\n                if(S[i][j]=='0') to[j].push_back(i);\n            }\n    }\n    int ans=0;\n    for(int i=0;i<N;i++){\n        vector<bool> d(N,false);\n        queue<int> que;\n        que.push(i);\n        d[i]=true;\n        bool kateru=false;\n        for(int j=0;j<to[i].size();j++){\n                int v=to[i][j];\n                if(d[v]) continue;\n                d[v]=true;\n                que.push(v);\n            }\n        while(!que.empty()){\n            int p=que.front();que.pop();\n            for(int j=0;j<to[p].size();j++){\n                int v=to[p][j];\n                if(d[v]) continue;\n                d[v]=true;\n                que.push(v);\n                if(abs(v-p)==1){\n                    kateru=true;\n                }\n            }\n            if(kateru){\n                ans++;\n                break;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    cout<< ans;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbitset<2000> win[2001];\nbitset<2000> dp[2001][2001];\nsigned main() {\n    int N; cin >> N;\n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            int p = c - '0';\n            win[i][j] = p;\n            win[j][i] = 1 - p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[i][i][i] = true;\n    for(int d=0; d<N-1; d++) {\n        for(int l=0; l<N-d; l++) {\n            int r = l + d;\n            for(int k=0; k<N; k++) {\n                if(l > 0) {\n                    if(win[k][l-1]) dp[l-1][r][k] |= dp[l][r][k];\n                    else dp[l-1][r][l-1] |= dp[l][r][k];\n                }\n                if(r+1 < N) {\n                    if(win[k][r+1]) dp[l][r+1][k] |= dp[l][r][k];\n                    else dp[l][r+1][r+1] |= dp[l][r][k];\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += dp[0][N-1][i];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\n\nstruct P\n{\n\tint A, B;\n\tP(int a, int b) : A(a), B(b) {}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<bool> m(N * N);\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor (int j = 0; j < i; j++) m[N * j + i] = !(m[N * i + j] = S[j] == '1');\n\t}\n\tdeque<bool> dp(N * N, false);\n\tfor (int i = 0; i < N - 1; i++) dp[N * i + i + 1] = true;\n\tfor (int l = 2; l < N; l++)\n\t\tfor (int i = 0; i + l < N; i++)\n\t\t{\n\t\t\tint p = N * i + i + l;\n\t\t\tfor (int k = i + 1, q = N * i + k, r = N * (i + l) + k, s = N * k + i + l; k < i + l; k++, q++, r++, s += N)\n\t\t\t\tif (dp[p] |= dp[q] & (m[q] | m[r]) & dp[s]) break;\n\t\t}\n\tdeque<bool> dpL(N, false);\n\tdpL[N - 1] = true;\n\tfor (int i = N - 2; i >= 0; i--)\n\t\tfor (int j = i + 1; j < N; j++) dpL[i] |= m[N * i + j] & dpL[j] & dp[N * i + j];\n\tdeque<bool> dpR(N, false);\n\tdpR[0] = true;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 0; j < i; j++) dpR[i] |= m[N * i + j] & dpR[j] & dp[N * j + i];\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tif (dpL[i] & dpR[i]) ans++;\n\tcout << ans << endl;\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<bitset<2000> > win(n);\n    for(int i=1; i<n; ++i){\n        string s;\n        cin >> s;\n        for(int j=0; j<i; ++j){\n            if(s[j] == '1')\n                win[i][j] = true;\n            else\n                win[j][i] = true;\n        }\n    }\n\n    vector<bitset<2000> > dpl(n), dpr(n);\n    for(int i=0; i<n; ++i)\n        dpl[i][i] = dpr[i][i] = true;\n    for(int len=1; len<n; ++len){\n        for(int i=len; i<n; ++i)\n            dpr[i-len][i] = (dpr[i-len] & dpl[i-1] & win[i]).any();\n        for(int i=0; i+len<n; ++i)\n            dpl[i+len][i] = (dpl[i+len] & dpr[i+1] & win[i]).any();\n    }\n\n    bitset<2000> ans = dpl[n-1] & dpr[0];\n    cout << ans.count() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\nconst int N = 2000;\nbitset<N> a[N];\nbitset<N> dp[N];\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  REP(i, 1, n) {\n    string s;\n    cin >> s;\n    REP(j, 0, i) {\n      a[i][j] = s[j] == '1';\n      a[j][i] = s[j] == '0';\n    }\n  }\n  if (DEBUG) {\n    REP(i, 0, n) {\n      cerr << \"a[\" << i << \"]\";\n      REP(j, 0, n) {\n        cerr << a[i][j];\n      }\n      cerr << endl;\n    }\n  }\n  REP(i, 0, n) {\n    dp[i][i] = true;\n  }\n  REP(s, 1, n) {\n    REP(i, 0, n - s) {\n      int j = i + s;\n      bool res = ((dp[i] & dp[j - 1]) & a[j]).any();\n      dp[i][j] =res;\n      res = ((dp[i + 1] & dp[j]) & a[i]).any();\n      dp[j][i] = res;\n    }\n  }\n  int ans = 0;\n  if (DEBUG) {\n    REP(i, 0, n) {\n      cerr << \"dp[\" << i << \"]\";\n      REP(j, 0, n) {\n        cerr << dp[i][j];\n      }\n      cerr << endl;\n    }\n  }\n  REP(i, 0, n) {\n    ans += dp[0][i] && dp[n - 1][i] ? 1 : 0;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod;\n#define N 2010\nll n;\nbool a[N][N];\nll sl[N],sr[N];\nvector<ll> g[N];\nbool ok;\nP dfs(ll x,ll from){\n    vector<P> v;\n    for(auto y:g[x])if(y!=from){\n\tv.push_back(dfs(y,x));\n    }\n    if(v.size()==0)return make_pair(x,x);\n    sort(v.begin(),v.end());\n    for(int i=0;i<v.size()-1;i++){\n\tif(v[i].second>v[i+1].first)ok=0;\n    }\n    return make_pair(v[0].first,v.back().second);\n}\nbool used[N];\nbool solve(ll s){\n    for(int i=0;i<n;i++){\n\tg[i].clear();\n\tused[i]=0;\n    }\n    for(int i=s-1;i>=0;i--){\n\tif(used[i])continue;\n\tll p=i,bef=-1;\n\twhile(1){\n\t    used[p]=1;\n\t    if(~bef)g[p].push_back(bef);\n\t    bef=p;\n\t    if(a[s][p]){\n\t\tg[s].push_back(p);\n\t\tbreak;\n\t    }\n\t    if(sl[p]==-1)return 0;\n\t    p=sl[p];\n\t}\n    }\n    for(int i=s+1;i<n;i++){\n\tif(used[i])continue;\n\tll p=i,bef=-1;\n\twhile(1){\n\t    used[p]=1;\n\t    if(~bef)g[p].push_back(bef);\n\t    bef=p;\n\t    if(a[s][p]){\n\t\tg[s].push_back(p);\n\t\tbreak;\n\t    }\n\t    if(sr[p]==-1)return 0;\n\t    p=sr[p];\n\t}\n    }\n    ok=1;\n    dfs(s,-1);\n    return ok;\n}\nint main(){\n  cin>>n;\n  for(int i=1;i<n;i++){\n      for(int j=0;j<i;j++){\n\t  char z;cin>>z;\n\t  a[i][j]=z-'0';\n\t  a[j][i]=a[i][j]^1;\n      }\n  }\n  for(int i=0;i<n;i++){\n      sl[i]=-1;\n      for(int j=i-1;j>=0;j--){\n\t  if(a[i][j]==0){\n\t      sl[i]=j;\n\t      break;\n\t  }\n      }\n      sr[i]=-1;\n      for(int j=i+1;j<n;j++){\n\t  if(a[i][j]==0){\n\t      sr[i]=j;\n\t      break;\n\t  }\n      }\n  }\n  ll ans=0;\n  for(int i=0;i<n;i++){\n      ans+=solve(i);\n      //cout<<i<<\":\"<<solve(i)<<endl;\n      //cout<<sl[i]<<\" \"<<sr[i]<<endl;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5;\n\nbitset<MAXN> a[MAXN],dpl[MAXN],dpr[MAXN];\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for (int i = 2;i<=n;i++)\n    {\n        getchar();\n        for (int j = 1;j<i;j++)\n        {\n            a[j][i] = !(a[i][j] = getchar() - 48);\n        }\n        dpl[i][i] = dpr[i][i] = 1;\n    }\n    dpr[1][1] = dpl[1][1] = 1;\n    for (int k = 1;k<=n-1;k++)\n    {\n        for (int i = 1;i<=n-k;i++)\n        {\n            int j = i + k;\n            dpl[j][i] = (a[i] & dpl[j] & dpr[i+1]).any();\n            dpr[i][j] = (a[j] & dpl[j-1] & dpr[i]).any();\n        }\n    }\n    int ans = 0;\n    for (int i = 1;i<=n;i++)\n    if (dpl[n][i] && dpr[1][i])\n    {\n        // cout<<i<<'\\n';\n        ans++;\n    }\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst ll MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            char c;\n            scanf(\" %c\",&c);\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            bool j1=false;\n            for(int k=j+1;k<=j+i && !j1;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            bool j1=false;\n            for(int k=j-i;k<j && !j1;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst int MX=2000;\n\nbitset<MX> A[MX];\nbitset<MX> dp[MX];\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            cin>>c;\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            dp[R][j]=(A[j]&dp[l]&dp[R]).any();\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            dp[R][j]=(A[j]&dp[l]&dp[R]).any();\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <queue>\n#define MOD (1000000007l)\n#define rep(i, n) for(long i = 0; i < n; i++)\n\nusing namespace std;\n\nbool result[2010][2010];\n\nmap<pair<long, long>, unordered_set<long>> winners;\nmap<pair<long, long>, bool> calculated;\n\nvoid calc(long from, long to) {\n  pair<long, long> query = make_pair(from, to);\n  if (calculated[query]) return;\n  calculated[query] = true;\n  if (from + 1 == to) {\n    winners[query].insert(from);\n    return;\n  }\n  for (long i = 1; i < to - from; i++) {\n    calc(from, from + i);\n    calc(from + i, to);\n    // cout << \"------------\" << from << \" - \" << from + i << \" - \" << to << endl;\n    auto set_foo = winners[make_pair(from, from + i)];\n    auto set_bar = winners[make_pair(from + i, to)];\n    for (auto foo: set_foo) for (auto bar: set_bar) {\n      // cout << foo << \" vs \" << bar << endl;\n      if (result[foo][bar]) winners[query].insert(foo);\n      else winners[query].insert(bar);\n    }\n  }\n}\n\nint main(void) {\n  cout.precision(12);\n\n  long N;\n  cin >> N;\n\n\n  for (long i = 2; i <= N; i++) {\n    string s;\n    cin >> s;\n    for (long j = 0; j < i-1; j++) {\n      result[i-1][j] = s[j] == '1';\n      result[j][i-1] = s[j] == '0';\n    }\n  }\n\n  calc(0, N);\n  /*\n  for (auto it: winners) {\n    cout << \"(\" << it.first.first << \", \" << it.first.second << \"): \";\n    for (auto it2: it.second) cout << it2 << \" \";\n    cout << endl;\n  }\n  */\n  cout << winners[make_pair(0, N)].size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n#include<bits/stdc++.h>\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nbitset<2005> l[2005],r[2005],a[2005];//r[i]表示i作为右端点时那些左端点可行\nint n;\nchar s[2005];\nint main()\n{\n\tre(n);\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tscanf(\"%s\",s+1);\n\t\tfor(int j=1;j<i;++j)\n\t\t{\n\t\t\tif(s[j]=='1')a[i][j]=1;\n\t\t\telse a[j][i]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)l[i][i]=r[i][i]=1;\n\tfor(int len=1;len<n;++len)\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tif(i+len<=n && (r[i+len]&l[i+1]&a[i]).any())r[i+len][i]=1;\n\t\t\tif(i-len>=1 && (l[i-len]&r[i-1]&a[i]).any())l[i-len][i]=1;\n\t\t}\n\tprintf(\"%d\\n\",(l[1]&r[n]).count());\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nbitset<N> Int[N][N], L[N][N], R[N][N], A[N][N];\nint n;\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> A[i][j];\n\tfor (int i = 1; i <= n; i++) for (int j = i; j <= n; j++){\n\t\tInt[i][j] = Int[i][j - 1];\n\t\tInt[i][j] = 1;\n\t}\n\t\n\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tfor (int i = r - 1; i >= l + 1; i--) {\n\t\tif ((l > 0 && grid[l - 1][i - 1]) || grid[r - 1][i - 1]) {\n\t\t\tbool fl1 = find(l, i);\n\t\t\tif (fl1) {\n\t\t\t\tif (find(i, r)) {\n\t\t\t\t\tsv[l][r] = 1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = std::pair<int, int>;\n\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define pb push_back\n\nconst int mn = 2000;\n\nbitset<mn> g[mn], dpl[mn], dpr[mn];\n\nint n;\nchar s[mn + 5];\n\nint main() {\n#ifdef trote\n    freopen(\"../1.txt\", \"r\", stdin);\n#endif\n\n    scanf(\"%d\", &n);\n    if (n == 1) {\n        puts(\"1\");\n        exit(0);\n    }\n    for (int i = 1; i < n; i++) {\n        scanf(\"%s\", s);\n        for (int j = 0; j < i; j++) {\n            if (s[j] == '1') {\n                g[i][j] = 1;\n                g[j][i] = 0;\n            } else {\n                g[i][j] = 0;\n                g[j][i] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) dpl[i][i] = dpr[i][i] = true;\n    for (int len = 1; len < n; len++) {\n        for (int i = 0; i + len < n; i++) {\n            int j = i + len;\n            // dpl[i][j] iff g[i][k] && exist k let dpl[k][j] && dpr[k][i+1]\n            dpl[j][i] = (g[i] & dpl[j] & dpr[i + 1]).any();\n\n            // dpr[j][i] iff g[j][k] && dpl[k][j-1] && dpr[k][i]\n            dpr[i][j] = (g[j] & dpl[j - 1] & dpr[i]).any();\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (dpl[n - 1][i] && dpr[0][i]) ans++;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e6+3)\n\nll N,A[2222][2222];\nchar a[2222];\nll btrR[2222][2222], btrL[2222][2222];\nlist<ll> rlst[2222];\nll i, j, k, ans;\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        scanf(\"%s\", a);\n        fornum(j,0,i){\n            A[i + 1][j + 1] = a[j]=='1';\n            A[j + 1][i + 1] = a[j]=='0';\n        }\n    }\n    btrR[N][N] = 1;\n    for (i = N; i > 0;i--){\n        for (j = i + 1; j <= N;j++){\n            if(btrR[i+1][j]){\n                if(A[i][j]){\n                    btrR[i][i] = 1;\n                }else{\n                    btrR[i][j] = 1;\n                }\n            }\n        }\n        for (j = i + 1; j <= N;j++){\n            if(A[j][i]){\n                if(btrR[j][j])\n                    btrR[i][j] = 1;\n                break;\n            }\n        }\n    }\n    btrL[1][1] = 1;\n    for (i = 1; i <= N;i++){\n        for (j = 1; j <i ;j++){\n            if(btrL[i-1][j]){\n                if(A[i][j]){\n                    btrL[i][i] = 1;\n                }else{\n                    btrL[i][j] = 1;\n                }\n            }\n        }\n        for (j =i-1; j >=1;j--){\n            if(A[j][i]){\n                if(btrL[j][j])\n                btrL[i][j] = 1;\n                break;\n            }\n        }\n    }\n    /*\n    fornum(i,1,N+1){\n        fornum(j,1,N+1){\n            printf(\"%lld:%lld \", btrL[i][j], btrR[i][j]);\n        }\n        printf(\"\\n\");\n    }*/\n    fornum(i,1,N+1){\n        ll aa = 0, bb = 0;\n        if(btrL[i][i]*btrR[i][i]==1)\n            ans++;\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nchar in[2100][2100];\nbitset<2100>dp[2][2100];\nbitset<2100>g[2][2100];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=1;i<a;i++){\n\t\tscanf(\"%s\",in[i]);\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\tif(i<j)in[i][j]='0'+('1'-in[j][i]);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(in[i][j]=='1'){\n\t\t\t\tg[0][i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tdp[0][i][i]=dp[1][i][i]=1;\n\t}\n\tfor(int I=1;I<a;I++){\n\t\tfor(int i=0;i+I<a;i++){\n\t\t\tif((g[0][i]&dp[1][i+1]&dp[0][i+I]).count())dp[0][i+I][i]=1;\n\t\t\tif((g[0][i+I]&dp[1][i]&dp[0][i+I-1]).count())dp[1][i][i+I]=1;\n\t\t//\tif(dp[0][i][i+I])printf(\"%d %d %d\\n\",0,i,i+I);\n\t\t//\tif(dp[1][i+I][i])printf(\"%d %d %d\\n\",1,i+I,i);\n\t\t//\tprintf(\"%d %d %d\\n\",g[0][i][1],dp[1][1][1],dp[0][2][1]);\n\t\t}\n\t}\n\n\tint ret=(dp[1][0]&dp[0][a-1]).count();\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,unsafe-math-optimizations\")\n#pragma GCC target(\"avx\")\n//ここまでごり押し時に必要なおまじない\ninline int read_char() {\n    static char buf[1 << 16], *ptr = buf, *end_ptr = buf;\n    if (ptr == end_ptr) {\n        int len = fread(buf, 1, sizeof(buf), stdin);\n        if (len <= 0) return EOF;\n        ptr = buf;\n        end_ptr = buf + len;\n    }\n    return *ptr++;\n}\ninline int readint(){\n    int t=0;\n    char c;\n    bool negative=false;\n    c=read_char();\n    while(c<'0'&&c>'9'){\n        if(c=='-')\n            negative=true;\n        c=read_char();\n    }\n    while(c>='0'&&c<='9'){\n        t=(t<<3)+(t<<1)+c-'0';\n        c=read_char();\n    }\n    if(negative)\n        t=~(t-1); //negative\n    return t;\n}\n\n\nll* dp[32][2005];\nint n;\nbool a[2005][2005];\nll ok[32][2005];\nint wh[2005],pos[2005];\nchar w[2005];\nint main(){\n\tscanf(\"%d\",&n);//n = 2000; //scanf(\"%d\",&n);\n  \n\tfor(int i=2;i<=n;i++){\n     // for(int i=0;i<2005;i++) w[i] = '0';\n     scanf(\"%s\",&w);\n\t\tfor(int j=1;j<i;j++){\n\t\t\ta[i][j] = w[j-1]-'0';\n          \ta[j][i] = 1-a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<2005;i++){\n\t\twh[i] = i/64;\n\t\tpos[i] = i%64;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!a[i][j]) continue;\n\t\t\tint x = j/64;\n\t\t\tok[wh[j]][i] |= 1LL<<pos[j];\n\t\t}\n\t}\n\tfor(int i=0;i<32;i++) for(int j=0;j<2005;j++) dp[i][j] = new ll [2005-j];\n\tfor(int i=1;i<=n;i++) dp[wh[i]][i][1] |= 1LL<<pos[i];\n\tfor(int k=2;k<=n;k++){\n\t\tfor(int i=1;i+k-1<=n;i++){\n\t\t\t//i\n\t\t\tfor(int j=0;j<32;j++) if(dp[j][i+1][k-1]&ok[j][i]) {dp[wh[i]][i][k] |= 1LL<<pos[i];break;}\n\t\t\t//i+k-1\n\t\t\tfor(int j=0;j<32;j++) if(dp[j][i][k-1]&ok[j][i+k-1]) {dp[wh[i+k-1]][i][k] |= 1LL<<pos[i+k-1];break;}\n          \tif(n>800){if(k%6!=0||i%6!=0) {rep(kk,32) dp[kk][i][k]=dp[kk][i][k-1];continue;}}\n\t\t\tfor(int j=i+1;j<i+k-1;j++){\n\t\t\t\tdp[wh[j]][i][k] |= (ll)(((dp[wh[j]][i][j-i+1]&dp[wh[j]][j][i+k-j])>>pos[j])&1)<<pos[j];\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=0;i<32;i++) ans += __builtin_popcount(dp[i][1][n]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nconst int MAX = 2020;\nbool a[MAX][MAX]={};\nusing BS = bitset<MAX>;\nBS st[MAX],dpL[MAX],dpR[MAX];\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(a[i][j]) st[i].set(j);\n      \n  for(int i=0;i<n;i++){\n    dpL[i].set(i);\n    dpR[i].set(i);\n  }\n\n  for(int w=2;w<=n;w++){\n    for(int i=0;i+w<=n;i++){\n      int l=i,r=i+w-1;\n      {\n        BS x=dpR[l+1]&dpL[r]&st[l];      \n        if((((x>>(r+1))<<(r+1))^((x>>(l+1))<<(l+1))).any()) dpL[r].set(l);\n      }\n      { \n        BS x=dpR[l]&dpL[r-1]&st[r];\n        if((((x>>r)<<r)^((x>>l)<<l)).any()) dpR[l].set(r);        \n      }\n    }\n  }\n  \n  cout<<(dpR[0]&dpL[n-1]).count()<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <array>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000003;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 2000, M = 32;\n\nchar b[N];\nuint64_t db[N][M], eb[N][M], a[N][M], foo[M];\n\ninline void Set(uint64_t A[], int i) {\n\tA[i >> 6] |= 1LL << (i & 63);\n}\nint Get(uint64_t A[], int i) {\n\treturn A[i >> 6] & 1LL << (i & 63);\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n; ni(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%s\", b);\n\t\tF(j, i) {\n\t\t\tif (b[j] == '1')Set(a[i], j);\n\t\t\telse Set(a[j], i);\n\t\t}\n\t}\n\tfor (int i = n; i--;) for (int j = i; j < n; j++) {\n\t\tif (i == j) {\n\t\t\tSet(db[i], i);\n\t\t\tSet(eb[i], i);\n\t\t\tcontinue;\n\t\t}\n\t\tbool good = false;\n\t\tF(k, M) {\n\t\t\tif (a[i][k] & db[j][k] & eb[i + 1][k]) {\n\t\t\t\tgood = true; break;\n\t\t\t}\n\t\t}\n\t\tif (good)Set(db[j], i);\n\t\tgood = false;\n\t\tF(k, M) {\n\t\t\tif (a[j][k] & db[j - 1][k] & eb[i][k]) {\n\t\t\t\tgood = true; break;\n\t\t\t}\n\t\t}\n\t\tif (good)Set(eb[i], j);\n\t}\n\tint ans = 0;\n\tF(i, n) {\n\t\tif (Get(eb[0], i) && Get(db[n - 1], i))ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst ll MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            char c;\n            cin>>c;\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            for(int k=j+1;k<=j+i;k++){\n                dp[R][j]|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n        }\n        for(int j=i;j<n;j++){\n            for(int k=j-i;k<j;k++){\n                int R=j-i;\n                int l=j-1;\n                dp[R][j]|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\n\nstruct P\n{\n\tint A, B;\n\tP(int a, int b) : A(a), B(b) {}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<bool> m(N * N);\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor (int j = 0; j < i; j++) m[N * j + i] = !(m[N * i + j] = S[j] == '1');\n\t}\n\tdeque<bool> dp(N * N, false);\n\tfor (int i = 0; i < N - 1; i++) dp[N * i + i + 1] = true;\n\tfor (int l = 2; l < N; l++)\n\t\tfor (int i = 0; i + l < N; i++)\n\t\t\tfor (int k = i + 1; k < i + l; k++)\n\t\t\t\tif (dp[N * i + i + l] |= dp[N * i + k] & (m[N * i + k] | m[N * (i + l) + k]) & dp[N * k + i + l]) break;\n\tdeque<bool> dpL(N, false);\n\tdpL[N - 1] = true;\n\tfor (int i = N - 2; i >= 0; i--)\n\t\tfor (int j = i + 1; j < N; j++) dpL[i] |= m[N * i + j] & dpL[j] & dp[N * i + j];\n\tdeque<bool> dpR(N, false);\n\tdpR[0] = true;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 0; j < i; j++) dpR[i] |= m[N * i + j] & dpR[j] & dp[N * j + i];\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tif (dpL[i] & dpR[i]) ans++;\n\tcout << ans << endl;\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nconst ll MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    ll n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            char c;\n            cin>>c;\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            bool j1=false;\n            for(int k=j+1;k<=j+i;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            bool j1=false;\n            for(int k=j-i;k<j;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbitset<2000> dpl[2000],dpr[2000],g[2000];\nstring s;\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tcin>>s;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tg[i][j]=s[j]-'0';\n\t\t\tg[j][i]=g[i][j]^1;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tdpl[i][i]=dpr[i][i]=true;\n\tfor(int len=2;len<=n;len++){\n\t\tfor(int l=0;l+len-1<n;l++){\n\t\t\tint r=l+len-1;\n\t\t\tif((g[l]&dpl[r]&dpr[l+1]).any())\tdpl[r][l]=true;\n\t\t\tif((g[r]&dpl[r-1]&dpr[l]).any())\tdpr[l][r]=true;\n\t\t}\n\t}\n\tcout<<(dpl[n-1]&dpr[0]).count()<<endl;\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,a[2005][2005];\nbitset<2005>win[2005];\nbitset<2005>dp[2][2005];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++){\n\t    char s[2005]; scanf(\"%s\",&s);\n\t\tfor(int j=1;j<i;j++){\n\t\t\ta[i][j] = s[j-1]-'0';\n\t\t\ta[j][i] = 1-a[i][j];\n\t\t}\n\t}\n\trepn(i,n) repn(j,n) win[i][j] = a[i][j];\n\trepn(i,n){\n\t\tdp[0][i][i] = 1;\n\t\tdp[1][i][i] = 1;\n\t}\n\tfor(int L=2;L<=n;L++){\n\t\tfor(int i=1;i+L-1<=n;i++){\n\t\t\t//dp[0][i][i+L-1]\n\t\t\tbool f = (win[i]&dp[1][i+1]&dp[0][i+L-1]).any();\n\t\t\tif(f) dp[0][i+L-1][i] = 1;\n\t\t\t//dp[1][i][i+L-1]\n\t\t\tf = (win[i+L-1]&dp[1][i]&dp[0][i+L-2]).any();\n\t\t\tif(f) dp[1][i][i+L-1] = 1;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(dp[1][1][i] && dp[0][n][i]) ans++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<int,ii>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 1000000005\n#define MOD 1000000007 \n#define N 2005\n#define M 1000003\n#define LOG 19\n#define KOK 250\n#define EPS 0.0000001\nusing namespace std;\n\nint n;\nchar s[N]; \nbitset<2005> okb[N],oks[N];\nbitset<2005> v[N];\n\nint main() {\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i=1;i<=n;i++) v[i][i]=1;\n\n\tfor(int i=2;i<=n;i++) {\n\n\t\tscanf(\"%s\",s+1);\n\n\t\tfor(int j=1;j<=i-1;j++) {\n\n\t\t\tif(s[j]=='1') {\n\n\t\t\t\tv[i][j]=1;\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tv[j][i]=1;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint ans=0;\n\n\tfor(int i=1;i<=n;i++) oks[i][i]=okb[i][i]=1;\n\n\tfor(int i=1;i<n;i++) {\n\n\t\tif(v[i][i+1]) {\n\n\t\t\tokb[i+1][i]=1;\n\n\t\t}\n\t\telse {\n\n\t\t\toks[i][i+1]=1;\n\n\t\t}\n\n\t}\n\n\tfor(int l=3;l<=n;l++) {\n\n\t\tfor(int s=l;s<=n;s++) {\n\n\t\t\tbitset<2005> res=v[s]&oks[s-l+1]&okb[s-1];\n\n\t\t\tif(res.count()) oks[s-l+1][s]=1;\n\n\t\t}\n\n\t\tfor(int b=1;b+l-1<=n;b++) {\n\n\t\t\tbitset<2005> res=v[b]&oks[b+1]&okb[b+l-1];\n\n\t\t\tif(res.count()) okb[b+l-1][b]=1;\n\n\t\t}\n\n\t}\n\n/*\tfor(int i=1;i<=n;i++) {\n\n\t\tfor(int j=i;j<=n;j++) {\n\n\t\t\tprintf(\"%d %d bas %d son %d\\n\",i,j,(int)okb[j][i],(int)oks[i][j]);\t\n\n\t\t}\n\n\t}*/\n\n\tfor(int i=1;i<=n;i++) {\n\n\t\tif(okb[n][i] && oks[1][i]) ans++;\n\n\t}\n\n\tprintf(\"%d\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nint A[2145][2145];\nbool used[2145];\nvector<int> es[2145];\n//bitset<2000> mat[2000];\n\nbool check(int v, int l, int r) {\n  //cout << v << \", \" << l << \", \" << r <<endl;\n  used[v] = true;\n  auto itr = lower_bound(all(es[v]), l);\n  auto endi = lower_bound(all(es[v]), r);\n  while (itr != endi) {\n    int u = *itr;\n    //if (used[u]) {\n    //  itr++;\n    //  continue;\n    //}\n    if (u < v) check(u, l, v);\n    else check(u, v+1, r);\n    itr++;\n  }\n}\n\nsigned main(){\n  //ios_base::sync_with_stdio(false);\n  //cout<<fixed<<setprecision(0);\n\n  scanf(\"%d\", &N);\n  //cin >> N;\n  reps(i, 1, N) {\n    rep(j, i) {\n      int w;\n      scanf(\"%01d\", &w);\n      //cin >> w;\n      A[i][j] = w;\n      A[j][i] = !w;\n      //mat[i][j] = 1;\n    }\n  }\n\n  rep(v, N) {\n    rep(u, N) {\n      if (u == v) continue;\n      if (A[v][u]) es[v].eb(u);\n    }\n  }\n\n  int ans = 0;\n  rep(v, N) {\n    fill(used, used+N, false);\n    check(v, 0, N);\n    bool fail = false;\n    rep(u, N) {\n      if (!used[u]) fail = true;\n    }\n    if (!fail) ans++;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nbitset<2020> A[2020];\nbitset<2020> winL[2020],winR[2020],winRL[2020],winRR[2020];\nbitset<2020> dp[2020];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tfor(j=1;j<N;j++) {\n\t\tcin>>s;\n\t\tFOR(i,j) {\n\t\t\tA[j][i]=s[i]=='1';\n\t\t\tA[i][j]=s[i]=='0';\n\t\t}\n\t}\n\t\n\tFOR(x,N) winL[x][x]=winR[x][x]=winRL[x][x]=winRR[x][x]=1;\n\tfor(l=2;l<=N;l++) {\n\t\tfor(x=0;x+l<=N;x++) {\n\t\t\ty=x+l-1;\n\t\t\tfor(i=x;i<y && dp[x][y]==0;i++) if(winL[x][i]&winR[y][i+1]) dp[x][y]=1;\n\t\t\tdp[y][x]=dp[x][y];\n\t\t\tauto bs=A[x] & dp[x] & winRL[y];\n\t\t\tif(bs.count()) winL[x][y]=winRL[y][x]=1;\n\t\t\tbs=A[y] & dp[y] & winRR[x];\n\t\t\tif(bs.count()) winR[y][x]=winRR[x][y]=1;\n\t\t}\n\t}\n\tint ret=0;\n\tFOR(i,N) ret+=winR[i][0]&winL[i][N-1];\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 2020;\nint a[MAX][MAX]={};\nint dpL[MAX][MAX]={};\nint dpR[MAX][MAX]={};\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    dpL[i][i]=dpR[i][i]=1; \n\n  for(int w=2;w<=n;w++){\n    for(int i=0;i+w<=n;i++){\n      int l=i,r=i+w-1;\n      for(int k=l+1;k<=r;k++)\n        dpL[l][r]|=dpR[l+1][k]&dpL[k][r]&a[l][k];\n\n      for(int k=l;k<r;k++)\n        dpR[l][r]|=dpR[l][k]&dpL[k][r-1]&a[r][k];      \n    }\n  }\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    if(dpR[0][i]&dpL[i][n-1]) ans++;  \n  cout<<ans<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return false;}\nconst int MOD = 1000000007;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<bool> w(n, false);\n    string s;\n    REP(i, n - 1) {\n        cin >> s;\n        REP(j, i + 1) {\n            if (s[j] == '0') {\n                w[j] = true;\n            }\n        }\n    }\n    int c = 0;\n    REP(i, n) {\n        if (w[i]) {\n            c++;\n        }\n    }\n    cout << c << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define ran 2022\n\nint n;\nchar s[ran];\nbool f[ran][ran];\nint lef[ran], rig[ran];\n\nint need_pull[ran][ran];\nint cnp[ran];\n\nint need_upd[ran][ran];\nint cnu[ran];\n\nint q[ran*ran], l, r;\nbool inq[ran];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i=2;i<=n;i++) {\n\t\tscanf(\"%s\", s);\n\t\tfor(int j=1;j<i;j++) {\n\t\t\tint x = s[j-1]-'0';\n\t\t\tif (x) {\n\t\t\t\tneed_pull[i][cnp[i]++] = j;\n\t\t\t\tneed_upd[j][cnu[j]++] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tneed_pull[j][cnp[j]++] = i;\n\t\t\t\tneed_upd[i][cnu[i]++] = j;\n\t\t\t}\n\t\t\tf[i][j] = x; f[j][i] = 1-x;\n\t\t}\n\t}\n\t\t\n\tl=r=0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(i>1&&f[i][i-1]) lef[i] = i-1;\n\t\telse lef[i] = i;\n\t\tif(i<n&&f[i][i+1]) rig[i] = i+1;\n\t\telse rig[i] = i;\n\t\t\n\t\tq[r++] = i;\n\t\tinq[i] = true;\n\t}\n\t\n\tint lim = ran*ran-11;\n\twhile(l!=r) {\n\t\tint cur = q[l++]; // cur = 1 [1,2]; nxt = 3 [3,3];\n\t\tif(l==lim) l=0;\n\t\tfor(int i=0;i<cnp[cur];i++) {\n\t\t\tint nxt = need_pull[cur][i];\n\t\t\t//printf(\"%d %d\\n\", cur, nxt);\n\t\t\t\n\t\t\tif (nxt<cur && rig[nxt]>=lef[cur]-1) lef[cur] = min(lef[cur], lef[nxt]);\n\t\t\tif (cur<nxt && rig[cur]>=lef[nxt]-1) rig[cur] = max(rig[cur], rig[nxt]);\n\t\t}\n\t\tfor(int i=0;i<cnu[cur];i++) {\n\t\t\tint nxt = need_upd[cur][i];\n\t\t\tbool upd = false;\n\t\t\tif(nxt<cur && rig[nxt] >= lef[cur]-1 && rig[nxt] < rig[cur]) {\n\t\t\t\trig[nxt] = rig[cur];\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t\tif(cur<nxt && rig[cur] >= lef[nxt]-1 && lef[nxt] > lef[cur]) {\n\t\t\t\tlef[nxt] = lef[cur];\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t\tif(upd && !inq[nxt]) {\n\t\t\t\tq[r++] = nxt;\n\t\t\t\tif(r==lim) r=0;\n\t\t\t\tinq[nxt] = true;\n\t\t\t}\n\t\t}\n\t\tinq[cur] = false;\n\t}\n\t\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) {\n\t\t//printf(\"%d %d\\n\", lef[i], rig[i]);\n\t\tif(lef[i]==1 && rig[i]==n) {\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n//*\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconstexpr ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\ninline bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\ninline bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\nconstexpr int N = 2000;\nint dp1[N][N]; // left win\nint dp2[N][N]; // right win\nbool A[N][N];\nint n;\n\nint rec2(int a, int b);\n\n// left win\nint rec1(int a, int b){\n  if(dp1[a][b] != -1) return dp1[a][b];\n  repr(i, a+1, b+1){\n    if(A[a][i] & rec1(i, b)){\n      repr(j, a, i){\n        if(rec1(a, j) & rec2(j+1, i)){\n          return dp1[a][b] = 1;\n        }\n      }\n    }\n  }\n  return dp1[a][b] = 0;\n}\n\n// right win\nint rec2(int a, int b){\n  if(dp2[a][b] != -1) return dp2[a][b];\n  repr(i, a, b){\n    if(A[b][i] & rec2(a, i)){\n      repr(j, i, b){\n        if(rec1(i, j) & rec2(j+1, b)){\n          return dp2[a][b] = 1;\n        }\n      }\n    }\n  }\n  return dp2[a][b] = 0;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  cin >> n;\n  assert(n <= N);\n  char ch;\n  repr(i, 1, n)rep(j, i){\n    cin >> ch;\n    A[i][j] = ch == '1';\n    A[j][i] = !A[i][j];\n  }\n  memset(dp1, -1, sizeof(int) * N*N);\n  memset(dp2, -1, sizeof(int) * N*N);\n  rep(i, N) dp1[i][i] = 1;\n  rep(i, N) dp2[i][i] = 1;\n  \n  int ans = 0;\n  rep(i, n){\n    ans += rec1(i, n-1) & rec2(0, i);\n  }\n  print(ans);\n  /*\n  rep(i, n){\n    rep(j, n){\n      cout << setw(3) << right << dp1[i][j];\n    }\n    cout << \"\\n\";\n  }\n  cout << \"\\n\";\n  rep(i, n){\n    rep(j, n){\n      cout << setw(3) << right << dp2[i][j];\n    }\n    cout << \"\\n\";\n  }\n  */\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nbool A[2000][2000];\nbitset<2001> L[2000];\nbitset<2001> R[2000];\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tREP(j, 0, i) {\n\t\t\tbool ok = Next<char>() - '0';\n\t\t\tA[i][j] = ok;\n\t\t\tA[j][i] = 1 - ok;\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tL[i][i] = true;\n\t\tR[i][i + 1] = true;\n \t}\n\n\tREP(z, 0, 12) {\n\t\tREP(i, 0, N) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tif ((R[i] & L[j]).any()) {\n\t\t\t\t\tR[i] |= R[j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tif ((L[i] & R[j]).any()) {\n\t\t\t\t\tL[i] |= L[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tREP(i, 0, N) {\n\t\tif (L[i][0] && R[i][N]) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/m-solutions2019/tasks/m_solutions2019_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\n// ===\n\n\n#[derive(Clone, Debug)]\nstruct BitVector {\n    n: usize,\n    size: usize,\n    data: Vec<u64>\n}\n\nimpl BitVector {\n    fn new(n: usize) -> Self {\n        let size = (n+63)/64;\n        BitVector {\n            n: n,\n            size: size,\n            data: vec![0; size]\n        }\n    }\n\n    fn get(&self, i: usize) -> bool {\n        self.data[i/64]>>(i%64) & 1 != 0\n    }\n\n    fn set(&mut self, i: usize) {\n        self.data[i/64] |= 1<<(i%64);\n    }\n\n    fn count(&self) -> usize {\n        let mut cnt = 0;\n        for i in 0..self.size {\n            cnt += self.data[i].count_ones();\n        }\n        cnt as usize\n    }\n}\n\nimpl<'a> std::ops::Shl<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shl(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n\n        let diff = amount / 64;\n        let diff_mod = amount % 64;\n        if diff_mod == 0 {\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<(64-diff_mod))-1;\n            let upper_mask = ((1<<diff_mod)-1)<<(64-diff_mod);\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] |= (self.data[i] & lower_mask)<<diff_mod;\n                if i+diff+1 < self.size {\n                    new_vector.data[i+diff+1] |= (self.data[i] & upper_mask)>>(64-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\n\nimpl<'a> std::ops::Shr<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shr(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n\n        let diff = amount / 64;\n        let diff_mod = amount % 64;\n        if diff_mod == 0 {\n            for i in diff..self.size {\n                new_vector.data[i-diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<diff_mod)-1;\n            let upper_mask = ((1<<(64-diff_mod))-1)<<diff_mod;\n            for i in diff..self.size {\n                new_vector.data[i-diff] |= (self.data[i] & upper_mask)>>diff_mod;\n                if i > diff {\n                    new_vector.data[i-diff-1] |= (self.data[i] & lower_mask)<<(64-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\nimpl<'a> std::ops::BitAnd for &'a BitVector {\n    type Output = BitVector;\n\n    fn bitand(self, other: Self) -> Self::Output {\n        let mut output = BitVector::new(self.n);\n        for i in 0..self.size {\n            output.data[i] = self.data[i] & other.data[i];\n        }\n        output\n    }\n}\n\nimpl std::ops::BitAndAssign for BitVector {\n    fn bitand_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] &= rhs.data[i];\n        }\n    }\n}\n\nimpl<'a> std::ops::BitOr for &'a BitVector {\n    type Output = BitVector;\n\n    fn bitor(self, other: Self) -> Self::Output {\n        let mut output = BitVector::new(self.n);\n        for i in 0..self.size {\n            output.data[i] = self.data[i] | other.data[i];\n        }\n        output\n    }\n}\n\nimpl std::ops::BitOrAssign for BitVector {\n    fn bitor_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] |= rhs.data[i];\n        }\n    }\n}\n\nimpl std::ops::BitXorAssign for BitVector {\n    fn bitxor_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] ^= rhs.data[i];\n        }\n    }\n}\n\n//===\n\nfn main() {\n    input! {\n        n: usize,\n        table: [chars; n-1]\n    };\n\n    // 1 to n, 0 and n+1 are sentinels\n    let mut wintable = vec![BitVector::new(2048); n+2];\n    for i in 2..n+1 {\n        for j in 1..i {\n            if table[i-2][j-1] == '1' {\n                // i wins j\n                wintable[i].set(j);\n            } else {\n                wintable[j].set(i);\n            }\n        }\n    }\n\n    let mut dp_left = vec![BitVector::new(2048); n+2];\n    let mut dp_right = vec![BitVector::new(2048); n+2];\n\n    let mut dp_left_rev = vec![BitVector::new(2048); n+2];\n    let mut dp_right_rev = vec![BitVector::new(2048); n+2];\n\n    for i in 1..n+1 {\n        dp_left[i].set(i);\n        dp_right[i].set(i);\n        dp_left_rev[i].set(i);\n        dp_right_rev[i].set(i);\n    }\n    for l in 1..n {\n        for i in 1..n+1 {\n            if i > l {\n                let lj = i-l;\n                let mut ok = false;\n                ok |= (&(&(&dp_left[i]>>1) & &dp_left_rev[lj]) & &wintable[i]).count() >= 1;\n                ok |= wintable[i].get(lj) && (&dp_left[i] & &(&dp_right[lj]<<1)).count() >= 1;\n                if ok {\n                    dp_left[i].set(lj);\n                    dp_left_rev[lj].set(i);\n                }\n                // debug!(i, lj, ok);\n            }\n            if i+l <= n {\n                let rj = i+l;\n                let mut ok1 = false;\n                let mut ok2 = false;\n                ok1 |= (&(&(&dp_right[i]<<1) & &dp_right_rev[rj]) & &wintable[i]).count() >= 1;\n                ok2 |= wintable[i].get(rj) && (&dp_right[i] & &(&dp_left[rj]>>1)).count() >= 1;\n                let ok = ok1 | ok2;\n                if ok {\n                    dp_right[i].set(rj);\n                    dp_right_rev[rj].set(i);\n                }\n                // debug!(i, rj, ok1, ok2);\n            }\n        }\n    }\n\n\n    let mut count = 0;\n    for i in 1..n+1 {\n        if dp_left[i].get(1) && dp_right[i].get(n) {\n            count += 1;\n            // debug!(i);\n        }\n    }\n    println!(\"{}\", count);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <queue>\n#define MOD (1000000007l)\n#define rep(i, n) for(long i = 0; i < n; i++)\n\nusing namespace std;\n\nbool result[2010][2010];\n\nmap<pair<long, long>, unordered_set<long>> winners;\nmap<pair<long, long>, bool> calculated;\n\nvoid calc(long from, long to) {\n  pair<long, long> query = make_pair(from, to);\n  if (calculated[query]) return;\n  calculated[query] = true;\n  if (from + 1 == to) {\n    winners[query].insert(from);\n    return;\n  }\n  for (long i = 1; i < to - from; i++) {\n    calc(from, from + i);\n    calc(from + i, to);\n    auto set_foo = winners[make_pair(from, from + i)];\n    auto set_bar = winners[make_pair(from + i, to)];\n    for (auto foo: set_foo) for (auto bar: set_bar) {\n      if (result[foo][bar]) winners[query].insert(foo);\n      winners[query].insert(bar);\n    }\n  }\n}\n\nint main(void) {\n  cout.precision(12);\n\n  long N;\n  cin >> N;\n\n\n  for (long i = 2; i <= N; i++) {\n    string s;\n    cin >> s;\n    for (long j = 0; j < i-1; j++) {\n      result[i-1][j] = s[j] == '1';\n      result[j][i-1] = s[j] == '0';\n    }\n  }\n\n  calc(0, N);\n  for (auto it: winners) {\n    cout << \"(\" << it.first.first << \", \" << it.first.second << \"): \";\n    for (auto it2: it.second) cout << it2 << \" \";\n    cout << endl;\n  }\n  cout << winners[make_pair(0, N)].size() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=2005;\nint n;\nint a[N][N];\nbool fl[N][N],fr[N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t\tscanf(\"%1d\",&a[i][j]),a[j][i]=a[i][j]^1;\n\tfor(int i=1;i<=n;i++)\n\t\tfl[i][i]=fr[i][i]=true;\n\tfor(int len=2;len<=n;len++)\n\t\tfor(int i=1;i+len-1<=n;i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tfor(int k=i+1;k<=j;k++)\n\t\t\t\tif(a[i][k]) fl[i][j]|=fr[i+1][k]&fl[k][j];\n\t\t\tfor(int k=i;k+1<=j;k++)\n\t\t\t\tif(a[j][k]) fr[i][j]|=fr[i][k]&fl[k][j-1];\n\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(fr[1][i]&&fl[i][n]) ans++;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2020;\nint n;\nbitset<N>A[N],l[N],r[N],lt[N],rt[N],dp[N],dpt[N];\nint main() {\n\tread(n);rep(i,2,n){\n\t\tchar S[N];scanf(\"%s\",S+1);\n\t\trep(j,1,i-1){\n\t\t\tint x=S[j]=='1';A[i][j]=x;A[j][i]=x^1;\n\t\t}\n\t}\n\tper(i,n,1)rep(j,i,n){\n\t\tif(j==i){l[i][j]=lt[j][i]=r[i][j]=rt[j][i]=1;continue;}\n\t\tdp[i][j]=dpt[j][i]=(l[i]&(rt[j]>>1)).any();\n\t\tint y=(A[i]&lt[j]&dp[i]).any();\n\t\tint z=(A[j]&r[i]&dpt[j]).any();\n\t\tl[i][j]=lt[j][i]=y;r[i][j]=rt[j][i]=z;\n\t}\n\t/*rep(i,1,n){\n\t\trep(j,1,n)printf(\"%d \",(int)A[i][j]);puts(\"\");\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n)printf(\"%d \",(int)l[i][j]);puts(\"\");\n\t}*/\n\tint res=0;rep(i,1,n)res+=l[i][n]&r[1][i];\n\tcout<<res;return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ], st[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind;\n\tind = st[l][l];\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = st[r][l];\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\tint start = clock();\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(wn[i].begin(), wn[i].end());\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint curInd = wn[i].size();\n\t\tfor (int j = n + 1; j >= 0; j--) {\n\t\t\tif (curInd != 0 && wn[i][curInd - 1] > j) curInd--;\n\t\t\tst[i][j] = curInd;\n\t\t}\n\t}\n\n\tll ans = 0;\n\t\n\tvector<ll> perm;\n\tfor (int i = 1; i <= n; i++) perm.push_back(i);\n\n\trandom_shuffle(perm.begin(), perm.end());\n\tfor (int i2 = 1; i2 <= n; i2++) {\n\t\tint end = clock();\n\t\tint t = (end - start);\n\t\tif (t >= 10000) break;\n\t\tint i = perm[i2];\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,a[2005][2005];\nbitset<2005>win[2005];\nbitset<2005>dp[2][2005];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++){\n\t    char s[2005]; scanf(\"%s\",&s);\n\t\tfor(int j=1;j<i;j++){\n\t\t\ta[i][j] = s[j-1]-'0';\n\t\t\ta[j][i] = 1-a[i][j];\n\t\t}\n\t}\n\trepn(i,n) repn(j,n) win[i][j] = a[i][j];\n\trepn(i,n){\n\t\tdp[0][i][i] = 1;\n\t\tdp[1][i][i] = 1;\n\t}\n\tfor(int L=2;L<=n;L++){\n\t\tfor(int i=1;i+L-1<=n;i++){\n\t\t\t//dp[0][i][i+L-1]\n\t\t\tbool f = !!(win[i]&dp[1][i+1]&dp[0][i+L-1]).count();\n\t\t\tif(f) dp[0][i+L-1][i] = 1;\n\t\t\t//dp[1][i][i+L-1]\n\t\t\tf = !!(win[i+L-1]&dp[1][i]&dp[0][i+L-2]).count();\n\t\t\tif(f) dp[1][i][i+L-1] = 1;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(dp[1][1][i] && dp[0][n][i]) ans++;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int DEBUG = 1;\nconst int mxn = 2e3;\nint n;\nbitset<mxn> a[mxn]; \nbitset<mxn> dp[mxn],dpr[mxn]; \n\n#define f(i,a,b) for (int i = a; i < b; i++)\n\n// NOT MINE LOL ... See Um_nik's first\n\nint main() {\n\n#ifdef LOCAL\n\tif (DEBUG) freopen(\"input.txt\", \"r\", stdin);\n\tif (DEBUG) freopen(\"output.txt\", \"w\", stdout);\n\tclock_t start = clock();\n#endif\n\n\tcin>>n;\n\n\tf(i,1,n) {\n\t\tstring s;\n\t\tcin>>s;\n\t\tf(j,0,i) a[i][j] = s[j] == '1', a[j][i] = !a[i][j];\n\t}\t\n\tf(i,0,n) dp[i][i] = dpr[i][i] = 1;\n\n\tf(len,1,n) f(l,0,n-len) {\n\t\tint r = l+len;\t\n\t\tif ((a[l]&dpr[l+1]&dp[r]).any())\n\t\t\tdp[r][l]=1;\n\t\tif ((a[r]&dpr[l]&dp[r-1]).any())\n\t\t\tdpr[l][r]=1;\n\t} \n\n\tcout << (dpr[0]&dp[n-1]).count() << endl;\n\n#ifdef LOCAL\n\tcout << setprecision(12) << (long double)(clock()-start) / CLOCKS_PER_SEC << endl;\n#endif\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast,unroll-loops\")\n#pragma GCC target (\"avx\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V< bitset<2000> > a(n);\n  for (int i = 1; i < n; ++i) {\n    string s; cin >> s;\n    for (int j = 0; j < i; ++j) {\n      a[i][j] = s[j] == '1';\n      a[j][i] = s[j] == '0';\n    }\n  }\n  V< bitset<2000> > dp(n);\n  for (int i = 0; i < n; ++i) {\n    dp[i][i] = true;\n    if (i) dp[i - 1][i] = a[i][i - 1];\n    if (i + 1 < n) dp[i + 1][i] = a[i][i + 1];\n  }\n  for (int w = 2; w < n; ++w) {\n    for (int i = 0; i < n; ++i) {\n      int j = i + w;\n      if (j < n) {\n        for (int k = i + 1; k <= j; ++k) if (a[i][k] and dp[i + 1][k] and dp[j][k]) {\n          dp[j][i] = true;\n          break;\n        }\n      }\n      j = i - w;\n      if (j >= 0) {\n        for (int k = i - 1; k >= j; --k) if (a[i][k] and dp[i - 1][k] and dp[j][k]) {\n          dp[j][i] = true;\n          break;\n        }\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n; ++i) res += dp[0][i] and dp[n - 1][i];\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    bitset<2020> A[2020];\n    for (int n = 1; n < N; ++n) {\n        string S;\n        cin >> S;\n        for (int m = 0; m < n; ++m) {\n            A[n][m] = S[m]-'0';\n            A[m][n] = 1-A[n][m];\n        }\n    }\n    \n    bitset<2020> DP[2020];\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = 1;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            int j = i+d;\n            DP[j][i] = (A[i] & DP[i+1] & DP[j]).any();\n            DP[i][j] = (A[j] & DP[i] & DP[j-1]).any();\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[0][n] & DP[N-1][n]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbool win[2001][2001];\nbool dpl[2001][2001], dpr[2001][2001];\nsigned main() {\n    int N; cin >> N;\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dpl[i][i] = dpr[i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            for(int k=i; k<=j; k++) {\n                if(k > i and win[i][k] and dpl[j][k] and dpr[i+1][k]) dpl[j][i] = true;\n                if(k < j and win[j][k] and dpr[i][k] and dpl[j-1][k]) dpr[i][j] = true;\n                \n            }\n            // fprintf(stderr, \"dpl[%lld][%lld] = %lld, dpr[%lld][%lld] = %lld\\n\", i, j, dpl[i][j], j, i, dpr[j][i]);\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dpl[N-1][i] and dpr[0][i]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing Event = pair<int, pii>;\n\nint N;\nint A[2145][2145];\nbool used[2145];\nvector<int> es[2145];\nvector<Event> fs;\nbool dp[2145][2][2145];\nint mx[2145][2];\n\n//bitset<2000> mat[2000];\n\n\nsigned main(){\n  //ios_base::sync_with_stdio(false);\n  //cout<<fixed<<setprecision(0);\n\n  scanf(\"%d\", &N);\n  //cin >> N;\n  reps(i, 1, N) {\n    rep(j, i) {\n      int w;\n      scanf(\"%01d\", &w);\n      //cin >> w;\n      if (w) {\n        fs.eb(Event(i-j, pii(i, j)));\n      } else {\n        fs.eb(Event(i-j, pii(j, i)));\n      }\n      //A[i][j] = w;\n      //A[j][i] = !w;\n      //mat[i][j] = 1;\n    }\n  }\n  sort(all(fs));\n\n  rep(v, N) {\n    rep(i, 2) {\n      dp[v][i][0] = true;\n    }\n  }\n\n  rep(g, 25) {\n    for (auto &e : fs) {\n      int l = e.X;\n      int u = e.Y.X;\n      int v = e.Y.Y;\n      if (u < v) {\n        if (mx[u][1]+mx[v][0]+1 >= l) {\n          dp[u][1][l] = true;\n          MX(mx[u][1], l);\n          dp[u][1][l+mx[v][1]] = true;\n          MX(mx[u][1], l+mx[v][1]);\n        } \n\n\n        if (dp[v][0][l-1] || dp[u][1][l-1]) {\n          dp[u][1][l] = true;\n          MX(mx[u][1], l);\n          dp[u][1][l+mx[v][1]] = true;\n          MX(mx[u][1], l+mx[v][1]);\n        }\n      } else {\n        if (mx[u][0]+mx[v][1]+1 >= l) {\n          dp[u][0][l] = true;\n          MX(mx[u][0], l);\n          dp[u][0][l+mx[v][0]] = true;\n          MX(mx[u][0], l+mx[v][0]);\n        }\n\n        if (dp[v][1][l-1] || dp[u][0][l-1]) {\n          dp[u][0][l] = true;\n          MX(mx[u][0], l);\n          dp[u][0][l+mx[v][0]] = true;\n          MX(mx[u][0], l+mx[v][0]);\n        }\n      }\n    }\n  }\n\n\n  int ans = 0;\n  rep(v, N) {\n    if (dp[v][0][v] && dp[v][1][N-1-v]) ans++;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 2010;\nbool wl[maxn][maxn], wr[maxn][maxn];\nbool e[maxn][maxn];\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 1; i < N; ++i) {\n\t\tstring s; cin >> s;\n\t\trep(j, i) {\n\t\t\te[i][j] = (s[j] == '1');\n\t\t\te[j][i] = !e[i][j];\n\t\t}\n\t}\n\n\tfor (int l = N-1; l >= 0; --l) {\n\t\twl[l][l] = wr[l][l] = 1;\n\t\tfor (int r = l+1; r < N; ++r) {\n\t\t\tfor (int m = l; m < r; ++m) {\n\t\t\t\tif (e[r][m] && wr[l][m] && wl[m][r-1]) {\n\t\t\t\t\twr[l][r] = 1;\n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = l+1; m <= r; ++m) {\n\t\t\t\tif (e[l][m] && wr[l+1][m] && wl[m][r]) {\n\t\t\t\t\twl[l][r] = 1;\n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\n\tint ans = 0;\n\trep(i, N) if (wl[i][N-1] && wr[0][i]) {\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nint main() {\n    int n;\n    cin >> n;\n    VVI a(n, VI(n));\n    FOR(i,1,n-1){\n        string s;\n        cin >> s;\n        REP(j,i){\n            if (s[j] == '1'){\n                a[i][j] = 1;\n            }else{\n                a[j][i] = 1;\n            }\n        }\n    }\n\n    VI le(n), ri(n);\n    REP(i,n){\n        le[i] = i;\n        ri[i] = i;\n    }\n    FOR(len,1,n-1){\n        REP(x,30){\n            REP(l,n+1-len){\n                int r = l + len;\n                if (ri[l] < le[r] - 1) continue;\n                if (a[l][r]) ri[l] = ri[r];\n                else le[r] = le[l];\n            }\n        }\n    }\n\n    int ans = 0;\n    REP(i,n){\n        if (le[i] == 0 && ri[i] == n - 1) ans++;\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 1000003\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n \n \nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n\n\nlong long int extgcd(long long int a,long long int b,long long int &x,long long int &y){\n\tlong long int d=a;\n\tif(b!=0){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}\n\telse{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\nlong long int modinverse(long long int a,long long int b){   //aの逆元を求める(mod b)\n\tlong long int x,y;\n\tlong long int d=extgcd(a,b,x,y);\n\treturn (x%b+b)%b;\n}\n\n#define MAX 2002\nint n;\n\nbitset<MAX> dpl[MAX];\nbitset<MAX> dpr[MAX];\n\nbitset<MAX> win[MAX];\n\nchar buf[MAX];\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tint a=buf[j]-'0';\n\t\t\tif(a==1){\n\t\t\t\twin[i].set(j,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\twin[j].set(i,1);\n\t\t\t\t//cerr<<j<<\" \"<<i<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdpl[i].set(i,1);\n\t\tdpr[i].set(i,1);\n\t}\n\tfor(int interval=1;interval<n;interval++){\n\t\tfor(int lef=0;lef+interval<n;lef++){\n\t\t\tint rig=lef+interval;\n\t\t\tif((dpl[rig]&dpr[lef+1]&win[lef]).any()){\n\t\t\t\tdpl[rig].set(lef,1);\n\t\t\t\t//cerr<<\"OK\"<<\" \"<<lef<<\" \"<<rig<<endl;\n\t\t\t}\n\t\t}\n\t\tfor(int rig=n-1;rig-interval>=0;rig--){\n\t\t\tint lef=rig-interval;\n\t\t\tif((dpl[rig-1]&dpr[lef]&win[rig]).any()){\n\t\t\t\tdpr[lef].set(rig,1);\n\t\t\t\t//cerr<<\"ok2\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(dpl[n-1]&dpr[0]).count()<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\n//const int MAX = 2e3 + 41;\nconst int MAX = 10;\n\nint n;\nbitset<MAX> pref[MAX], suf[MAX], win[MAX];\nint a[MAX][MAX];\n\nvoid solve () {\n\tfi(0, n - 1) {\n\t\tfj(0, n - 1) {\n\t\t\tif (a[i][j]) win[i].set(j);\n\t\t}\n\t}\n\tfi(0, n - 1) {\n\t\tpref[i].set(i);\n\t\tsuf[i].set(i);\t\t\t\t\t\t\n\t\tfdj(i - 1, 0) {\n\t\t\tif (a[i][j]) {\t\t\t\t\n\t\t\t\tif ( ( (suf[j] << 1) & pref[i]).count() ) {\n\t\t\t\t\tpref[i] |= pref[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbitset<MAX> sufwin;\n\t\tsufwin.reset();\n\t\tsufwin.set(i);\n\t\tfdj(i - 1, 0) {\n\t\t\tif ( ((suf[j] << 1) & sufwin).count() ) {\n\t\t\t\tsufwin.set(j);\n\t\t\t\tsuf[j].set(i);\n\t\t\t}\n\t\t}\n/*\n\t\tfj(0, i) {\n\t\t\tdbg(pref[j]);\n\t\t\tdbg(suf[j]);\n\t\t}\n\t\terr(\"after i = %d\\n\", i);\n*/\n\t}\n\tvi answer;\n\tfi(0, n - 1) {\n\t\tif (pref[i].test(0) && suf[i].test(n - 1)) {\n\t\t\tanswer.pb(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sz(answer));\n//\tdbg(answer);\t\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\t\n\tscanf(\"%d\", &n);\n\tfi(0, n - 1) {\n\t\tfj(0, i - 1) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\ta[j][i] = a[i][j];\n\t\t}\n\t}\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\nint n;\nbitset <2100> dpl[2100] , dpr[2100] , a[2100];\nchar z[2100];\nint ans , cnt;\nvoid work () {\n\tint i , j , k;\n\tscanf ( \"%d\" , &n );\n\tfor ( i = 2 ; i <= n ; i++ ) {\n\t\tscanf ( \"%s\" , z + 1 );\n\t\tfor ( j = 1 ; j < i ; j++ ) {\n\t\t\tif ( z[j] == '1' ) a[i][j] = 1;\n\t\t\telse a[j][i] = 1;\n\t\t}\n\t}\n\tfor ( i = 1 ; i <= n ; i++ ) {\n\t\tdpl[i][i] = dpr[i][i] = 1;\n\t}\n\tfor ( k = 2 ; k <= n ; k++ ) {\n\t\tfor ( i = 1 ; i + k - 1 <= n ; i++ ) {\n\t\t\tj = i + k - 1;\n\t\t\tif ( (a[i]&dpr[i+1]&dpl[j]) != 0 ) dpl[j][i] = 1;\n\t\t\tif ( (a[j]&dpr[i]&dpl[j-1]) != 0 ) dpr[i][j] = 1;\n\t\t}\n\t}\n\tans = 0;\n\tfor ( i = 1 ; i <= n ; i++ ) {\n\t\tcnt = 0;\n\t\tif ( i == 1 || dpr[1][i] == 1 ) cnt++;\n\t\tif ( i == n || dpl[n][i] == 1 ) cnt++;\n\t\tif ( cnt == 2 ) ans++;\n\t}\n\tprintf ( \"%d\\n\" , ans );\n}\nint main () {\n\twork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\ntypedef long long ll;\n\nbool g[2005][2005];\nint solve1(int bg, int ed);\nint solve2(int bg, int ed);\n\nint memo1[2005][2005];\nint solve1(int bg, int ed) { // この範囲でbgが優勝\n  int& res = memo1[bg][ed];\n  if(res < 0) {\n    if(bg+1 >= ed) {\n      // cerr << \"solve1(\" << bg << \", \" << ed << \") = 1\" << endl;\n      res = 1;\n    } else {\n      res = 0;\n      for(int i = bg+1; i < ed; ++i) {\n        if(g[bg][i] && solve2(bg+1, i+1) == 1 && solve1(i, ed) == 1) {\n          // cerr << \"solve1(\" << bg << \", \" << ed << \") = 1 because \" << i << \" is strong\" << endl;\n          res = 1;\n          break;\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint memo2[2005][2005];\nint solve2(int bg, int ed) { // この範囲でed-1が優勝\n  int& res = memo2[ed][bg];\n  if(res < 0) {\n    if(bg+1 >= ed) {\n      // cerr << \"solve2(\" << bg << \", \" << ed << \") = 1\" << endl;\n      res = 1;\n    } else {\n      res = 0;\n      for(int i = bg; i < ed-1; ++i) {\n        if(g[ed-1][i] && solve2(bg, i+1) == 1 && solve1(i, ed-1) == 1) {\n          res = 1;\n          // cerr << \"solve2(\" << bg << \", \" << ed << \") = 1 because \" << i << \" is strong\" << endl;\n          break;\n        }\n      }\n    }\n  }\n  return res;\n}\n\nchar buf[3000];\nint main(void) {\n  int n;\n  scanf(\"%d\", &n);\n  REP(i, n-1) {\n    scanf(\"%s\", buf);\n    REP(j, i+1) {\n      g[i+1][j] = buf[j] == '1';\n      g[j][i+1] = !g[i+1][j];\n    }\n  }\n  memset(memo1, -1, sizeof memo1);\n  memset(memo2, -1, sizeof memo2);\n  // REP(i, n) {\n  //   REP(j, n) {\n  //     cerr << (g[i][j] ? '1' : '0');\n  //   }\n  //   cerr << endl;\n  // }\n  int res = 0;\n  REP(i, n) {\n    if(solve1(i, n) == 1 && solve2(0, i+1) == 1) {\n      ++res;\n    }\n  }\n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nbool A[2010][2010];\nll dp[2010][2010];\nll dpr[2010][2010];\n\n\n\nint main() {\n  ll N;\n  cin >> N;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < i; ++j) {\n      char a;\n      cin >> a;\n      A[i][j] = a == '1';\n      A[j][i] = !A[i][j];\n    }\n  }\n\n  for (int i = 0; i < N; i++){\n    dp[i][i] = true;\n    dpr[i][i] = true;\n  }\n\n  for (int k = 1; k < N; k++)\n  {\n    for (int i = 0; i < N - k; i++)\n    {\n      int j = i + k;\n      bool f1 = false, f2 = false;\n      for (int l = i; l < j; l++)\n        f1 |= dpr[i][l] & dp[j - 1][l] & A[j][l];\n      for (int l = i + 1; l <= j; l++)\n        f2 |= dpr[i + 1][l] & dp[j][l] & A[i][l];\n      dp[j][i] = f2;\n      dpr[i][j] = f1;\n    }\n  }\n  int c = 0;\n  for (int i = 0; i < N; i++)\n    c += dpr[0][i] & dp[N - 1][i];\n  cout << c << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nbitset<N> LR[N][N], L[N][N], R[N][N], A[N][N];\nint n;\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> A[i][j];\n\tfor (int i = 1; i <= n; i++) for (int j = i; j <= n; j++){\n\t\tLR[i][j] = LR[i][j - 1];\n\t\tLR[i][j] = 1;\n\t}\n\t\n\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tconst int mod=1e9+7;\n\tauto add = [&mod](int a, int b) -> int {a += b; return a >= mod? a - mod: a;};\n\tauto sub = [&mod](int a, int b) -> int {a -= b; return a < 0? a + mod: a;};\n\tauto mul = [&mod](int a, int b) -> int {return 1LL * a * b % mod;};\n\tauto qpow = [&](int64_t t,int64_t p) -> int {\n\t\tint64_t ans = 1;\n\t\twhile (p) {\n\t\t\tif(p & 1) ans = ans * t %mod;\n\t\t\tt = t * t % mod;\n\t\t\tp >>=1;\n\t\t}\n\t\treturn ans;\n \t};\n\tint n, a, b, c;\n\tcin >> n >> a >> b >> c;\n\tvector<int> pre(2 * n + 1), inv(2 * n + 1);\n\tpre[0] = 1;\n\tfor(int i = 1; i <= 2 * n; ++i) {\n\t\tpre[i] = mul(pre[i - 1], i);\n\t\tinv[i] = qpow(pre[i], mod-2);\n\t}\n\tauto C = [&](int n, int m) {\n\t\treturn mul(pre[n], mul(inv[m], inv[n-m]));\n\t};\n\tint ans = 0;\n\tint tmp = qpow(qpow(sub(1, c), mod - 2), n);\n\tfor (int i = 0; i <= n; ++i) {\n\t\tint tt = mul(C(i + n - 1, n - 1), qpow(b, i));\n\t\ttt = mul(tt, qpow(a, n));\n\t\tans = add(ans, mul(tt, tmp));\n\t}\n\tfor (int i = 0; i <= n; ++i) {\n\t\tint tt = mul(C(i + n - 1, n - 1), qpow(a, i));\n\t\ttt = mul(tt, qpow(b, n));\n\t\tans = add(ans, mul(tt, tmp));\n\t}\n\tcout << ans <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <bitset>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n// using bits = bitset<2001>;\nusing bits = bitset<10>;\n\n// vector<vector<bits>> dp;\n// vector<vector<int>> calc;\n// bits& rec(vector<bits>& a, int l, int r){\n//   if(calc[l][r]) return dp[l][r];\n//   if(r-l == 0){\n//     dp[l][r].set(l, 1);\n//     calc[l][r] = 1;\n//     return dp[l][r];\n//   }\n//   if(r-l == 1){\n//     dp[l][r].set(l, 1);\n//     calc[l][r] = 1;\n//     return dp[l][r];\n//   }\n//   if(r-l == 2){\n//     if(a[l][l+1]){\n//       dp[l][r].set(l, 1);\n//     }else{\n//       dp[l][r].set(l+1, 1);\n//     }\n//     calc[l][r] = 1;\n//     return dp[l][r];\n//   }\n//   for(int i=l; i<r; i++){\n//     bool bl = true;\n//     bool br = true;\n//     if(i > l){\n//       if((rec(a, l, i) & a[i]).count() == 0){\n//         bl = false;\n//       }\n//     }\n//     if(i+1 < r){\n//       if((rec(a, i+1, r) & a[i]).count() == 0){\n//         br = false;\n//       }\n//     }\n//     if(bl && br){\n//       dp[l][r].set(i, 1);\n//     }\n//   }\n//   calc[l][r] = 1;\n//   return dp[l][r];\n// }\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<bits> a(n);\n  vector<vector<int>> b(n, vector<int>(n));\n  for(int i=1, j=1; i<n; i++, j++){\n    string s;\n    cin >> s;\n\n    for(int k=0; k<j; k++){\n      b[i][k] = s[k] == '1' ? 1 : 0;\n      b[k][i] = !b[i][k];\n    }\n  }\n\n  for(int i=0; i<n; i++){\n    // a[i].set(i);\n    for(int j=0; j<n; j++){\n      if(b[i][j]){\n        a[i].set(j);\n      }\n    }\n  }\n\n  // dp = vector<vector<bits>>(n+1, vector<bits>(n+1));\n  // calc = vector<vector<int>>(n+1, vector<int>(n+1));\n\n  // auto& v = rec(a, 0, n);\n  // int ans = v.count();\n  // println(ans);\n\n  vector<bits> dpl(n+1), dpr(n+1);\n  for(int i=0; i<n; i++){\n    dpl[i].set(i);\n    dpr[i].set(i);\n  }\n\n  for(int len=2; len<=n; len++){\n    // vector<pair<int,int>> nwl, nwr;\n    for(int l=0; l+len<=n; l++){\n      int r = l+len-1;\n      if((dpl[l+1] & dpr[l+len-1] & a[l]).count()){\n        dpr[l+len-1].set(l, 1);\n        // nwr.emplace_back(l+len-1, l);\n      }\n      if((dpr[r-1] & dpl[l] & a[r]).count()){\n        dpl[l].set(r, 1);\n        // nwl.emplace_back(l, r);\n      }\n    }\n    // for(auto p: nwl){\n    //   dpl[p.first].set(p.second);\n    // }\n    // for(auto p: nwr){\n    //   dpr[p.first].set(p.second);\n    // }\n  }\n\n  int ans = (dpl[0] & dpr[n-1]).count();\n  println(ans);\n\n  for(int i=0; i<n; i++){\n    eprint(dpl[0][i]);\n  }\n  eprintln(\"\");\n\n  for(int i=0; i<n; i++){\n    eprint(dpr[n-1][i]);\n  }\n  eprintln(\"\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing lint = long long;\nusing namespace std;\nconst int MAXN = 2005;\n\nint n, k;\nchar str[MAXN][MAXN];\nbitset<MAXN> L[MAXN], R[MAXN], out[MAXN];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tscanf(\"%s\", str[i + 1] + 1);\n\t}\n\tR[1].set(0);\n\tL[0].set(1);\n\tfor(int i=1; i<=n; i++){\n\t\tL[i].set(i+1);\n\t\tR[i+1].set(i);\n\t\tstr[i][i] = '0';\n\t\tfor(int j=1; j<i; j++){\n\t\t\tstr[j][i] = str[i][j] ^ 1;\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tif(str[i][j] == '1') out[i].set(j);\n\t\t}\n\t}\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=1; j+i<=n; j++){\n\t\t\tint s = j, e = j + i;\n\t\t\tauto mas = (R[s] << 1) & (L[e] >> 1);\n\t\t\tif((mas & out[s - 1]).any()) L[e].set(s);\n\t\t\tif((mas & out[e + 1]).any()) R[s].set(e);\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i=1; i<=n; i++){\n\t\tbool ok = true;\n\t\tif(!R[1][i - 1]) ok = false;\n\t\tif(!L[n][i + 1]) ok = false;\n\t\tif(ok) ret++;\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx\")\n//#undef LOCAL\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n#ifdef LOCAL\n#define show(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n\nconst int MN = 2020; //6;\nusing B = bitset<MN>;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int n;\n    cin >> n;\n    V<B> win(n); \n    for (int j = 1; j < n; j++) {\n        string s;\n        cin >> s;\n        for (int i = 0; i < j; i++) {\n            if (s[i] == '0') {\n                // i -> j\n                win[i].set(j);\n            } else {\n                // j -> i\n                win[j].set(i);\n            }\n        }\n    }\n\n    V<B> okL(n), okR(n);\n    for (int i = 0; i < n; i++) {\n        okL[i][i] = true;\n        okR[i][i] = true;\n    }\n    for (int di = 1; di <= n; di++) {\n        for (int l = 0; l + di <= n - 1; l++) {\n            int r = l + di;\n\n            okL[r][l] = (okR[l + 1] & okL[r] & win[l]).any();\n            okR[l][r] = (okR[l] & okL[r - 1] & win[r]).any();\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (okR[0][i] && okL[n - 1][i]) {\n            show(i);\n            ans++;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\ntypedef long long ll;\n\nbool g[2005][2005];\nbool dp1[2005][2005]; // dp1[i][j]: [i,j]でjが勝てる\nbool dp2[2005][2005]; // dp2[j][i]: [i,j]でiが勝てる\n\nchar buf[3000];\nint main(void) {\n  int n = 2000;\n  scanf(\"%d\", &n);\n  REP(i, n-1) {\n    scanf(\"%s\", buf);\n    REP(j, i+1) {\n      bool b;\n      b = buf[j] == '1';\n      g[i+1][j] = b;\n      g[j][i+1] = !b;\n    }\n  }\n  REP(i, n) {\n    g[i][i] = true;\n    dp1[i][i] = true;\n    dp2[i][i] = true;\n  }\n  for(int d = 1; d < n; ++d) {\n    REP(i, n-d) {\n      int j = i + d;\n      for(int k = i; k < j; ++k) {\n        dp1[i][j] |= g[j][k] & dp1[i][k] & dp2[j-1][k];\n      }\n      for(int k = i+1; k <= j; ++k) {\n        dp2[j][i] |= g[i][k] & dp1[i+1][k] & dp2[j][k];\n      }\n    }\n  }\n  int res = 0;\n  REP(i, n) {\n    if(dp1[0][i] & dp2[n-1][i]) {\n      ++res;\n    }\n  }\n  \n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define ran 2022\n\nint n;\nchar s[ran];\nbool f[ran][ran];\nint lef[ran], rig[ran];\n\nint need_pull[ran][ran];\nint cnp[ran];\n\nint need_upd[ran][ran];\nint cnu[ran];\n\nint q[ran*ran], l, r;\nbool inq[ran];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i=2;i<=n;i++) {\n\t\tscanf(\"%s\", s);\n\t\tfor(int j=1;j<i;j++) {\n\t\t\tint x = s[j-1]-'0';\n\t\t\tif (x) {\n\t\t\t\tneed_pull[i][cnp[i]++] = j;\n\t\t\t\tneed_upd[j][cnu[j]++] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tneed_pull[j][cnp[i]++] = i;\n\t\t\t\tneed_upd[i][cnu[i]++] = j;\n\t\t\t}\n\t\t\tf[i][j] = x; f[j][i] = 1-x;\n\t\t}\n\t}\n\t\t\n\tl=r=0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(i>1&&f[i][i-1]) lef[i] = i-1;\n\t\telse lef[i] = i;\n\t\tif(i<n&&f[i][i+1]) rig[i] = i+1;\n\t\telse rig[i] = i;\n\t\t\n\t\tq[r++] = i;\n\t\tinq[i] = true;\n\t}\n\t\n\tint lim = ran*ran-11;\n\twhile(l!=r) {\n\t\tint cur = q[l++]; // cur = 1 [1,2]; nxt = 3 [3,3];\n\t\tif(l==lim) l=0;\n\t\t/*for(int i=0;i<cnp[cur];i++) {\n\t\t\tint nxt = need_pull[cur][i];\n\t\t\t\n\t\t\tif (nxt<cur && rig[nxt]>=lef[cur]-1) lef[cur] = min(lef[cur], lef[nxt]);\n\t\t\tif (cur<nxt && rig[cur]>=lef[nxt]-1) rig[cur] = max(rig[cur], rig[nxt]);\n\t\t}*/\n\t\tfor(int i=0;i<cnu[cur];i++) {\n\t\t\tint nxt = need_upd[cur][i];\n\t\t\tbool upd = false;\n\t\t\tif(nxt<cur && rig[nxt] >= lef[cur]-1 && rig[nxt] < rig[cur]) {\n\t\t\t\trig[nxt] = rig[cur];\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t\tif(cur<nxt && rig[cur] >= lef[nxt]-1 && lef[nxt] > lef[cur]) {\n\t\t\t\tlef[nxt] = lef[cur];\n\t\t\t\tupd = true;\n\t\t\t}\n\t\t\tif(upd && !inq[nxt]) {\n\t\t\t\tq[r++] = nxt;\n\t\t\t\tif(r==lim) r=0;\n\t\t\t\tinq[nxt] = true;\n\t\t\t}\n\t\t}\n\t\tinq[cur] = false;\n\t}\n\t\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) {\n\t\t//printf(\"%d %d\\n\", lef[i], rig[i]);\n\t\tif(lef[i]<=1 && rig[i]>=n) {\n\t\t\t//printf(\"%d\\n\", i);\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nbool A[2000][2000];\nbitset<2001> L[2000];\nbitset<2001> R[2000];\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tREP(j, 0, i) {\n\t\t\tbool ok = Next<char>() - '0';\n\t\t\tA[i][j] = ok;\n\t\t\tA[j][i] = 1 - ok;\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tL[i][i] = true;\n\t\tR[i][i + 1] = true;\n \t}\n\n\tREP(z, 0, 30) {\n\t\tREP(i, 0, N) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tREP(k, i + 1, j + 1) {\n\t\t\t\t\tif (R[i][k] && L[j][k]) {\n\t\t\t\t\t\tR[i] |= R[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tREP(k, j + 1, i + 1) {\n\t\t\t\t\tif (L[i][k] && R[j][k]) {\n\t\t\t\t\t\tL[i] |= L[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tREP(i, 0, N) {\n\t\tif (L[i][0] && R[i][N]) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\n#include <bitset>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_N   (2000)\nchar szInput[MAX_N + 1];\nstatic bitset<MAX_N + 1> s_abitMatchTbl[MAX_N + 1];\n\nint main(void)\n{\n    SDWORD lInput_n = inputSDWORD();\n    for (SDWORD lIdxI = 2; lIdxI <= lInput_n; lIdxI++) {\n        inputString(szInput);\n        for (SDWORD lIdxJ = 1; lIdxJ < lIdxI; lIdxJ++) {\n            if ('1' == szInput[lIdxJ - 1]) {\n                s_abitMatchTbl[lIdxI][lIdxJ] = true;\n            } else {\n                s_abitMatchTbl[lIdxJ][lIdxI] = true;\n            }\n        }\n    }\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalMatchTbl[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    static bitset<MAX_N + 1> s_absDpL[MAX_N+1];\n    static bitset<MAX_N + 1> s_absDpR[MAX_N+1];\n\n    for (SDWORD lUpdateWidth = 0; lUpdateWidth <= lInput_n; lUpdateWidth++) {\n        for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n - lUpdateWidth; lUpdIdxL++) {\n            SDWORD lUpdIdxR = lUpdIdxL + lUpdateWidth;\n            if (lUpdIdxL == lUpdIdxR) {\n                s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n            } else {\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A1: [%d, <%d> %d], %d %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalMatchTbl[lUpdIdxL][lUpdIdxR],\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM+1][lUpdIdxR]);\n#endif\n\n                    if (1 == s_abitMatchTbl[lUpdIdxL][lUpdIdxR]) {\n                        if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                            && (1 == s_absDpR[lUpdIdxM+1][lUpdIdxR])) {\n                            s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                        }\n                    } else {\n                        if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                            && (1 == s_absDpR[lUpdIdxM+1][lUpdIdxR])) {\n                            s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                        }\n                    }\n                }\n                for (SDWORD lUpdIdxM = lUpdIdxL + 1; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A2: [%d, <%d> %d], %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpL[lUpdIdxM][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpL[lUpdIdxM][lUpdIdxR])) {\n                        s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                    if ((1 == s_absDpR[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpR[lUpdIdxM][lUpdIdxR])) {\n                        s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpL[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpR[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    /* count winners */\n    SDWORD lAns = 0;\n    for (SDWORD lMid = 1; lMid <= lInput_n; lMid++) {\n        if (s_absDpR[1][lMid] && s_absDpL[lMid][lInput_n]) {\n            lAns++;\n        }\n    }\n\n    printf(\"%d\\n\", lAns);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\nusing namespace std;\n\nbitset<2000> win[2000],dpL[2000],dpR[2000];\nbitset<2000> dpLL[2000],dpLR[2000],dpRL[2000],dpRR[2000];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // cout << fixed << setprecision(20);\n    int n;cin >> n;\n    win[0][0] = 1;\n    for(int i = 1;i < n;i++){\n        win[i][i] = 1;\n        string s;cin >> s;\n        REP(j,i){\n            win[i][j] = (s[j] == '1');\n            win[j][i] = !win[i][j];\n        }\n    }\n    for(int i = 0;i < n;i++){\n        dpL[i][i] = dpR[i][i] = true;\n        dpLL[i][i] = dpRL[i][i] = true;\n    }\n    for(int d = 1;d < n;d++){\n        for(int i = 0;i + d < n;i++){\n            bitset<2000> merged = (win[i] & dpLL[i+d] & dpRL[i+1]);//これの[i+1,i+d]にあるか？\n            if(merged.count() == 0)continue; \n            dpL[i][i+d] = true;\n            dpLL[i+d][i] = true;\n        }\n        for(int i = n-1;i - d >= 0;i--){\n            bitset<2000> merged = (win[i] & dpRL[i-d] & dpLL[i-1]);//これの[i-d,i-1]にあるか？\n            if(merged.count() == 0)continue;\n            dpR[i][i-d] = true;\n            dpRL[i-d][i] = true;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0;i < n;i++){\n       // cout << dpR[i] << '\\n';\n        if(dpR[i][0] & dpL[i][n-1])ans++;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 11);\n\nint n;\nbitset<MAXN> A[MAXN];\n\nvoid read()\n{\n\tcin >> n;\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 1; j < i; j++)\n\t\t{\n\t\t\tint x = s[j - 1] - '0';\n\t\t\tA[j][i] = x ^ 1;\n\t\t\tA[i][j] = x;\n\t\t}\n\t}\n}\n\nbitset<MAXN> lft[MAXN];\nbitset<MAXN> rgh[MAXN];\nbitset<MAXN> winners[MAXN][MAXN];\n\nvoid solve()\n{\n\tfor(int i = 1; i <= n; i++)\n\t\tlft[i][i] = 1, rgh[i][i] = 1, winners[i][i][i] = 1;\n\n\tfor(int len = 2; len <= n; len++)\n\t{\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint r = i + len - 1;\n\t\t\tif(r > n) continue;\n\t\t\tbitset<MAXN> qq = A[i] & winners[i + 1][r];\n\t\t\tif(qq.count()) lft[r][i] = 1;\n\t\t}\n\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint l = i - len + 1;\n\t\t\tif(l <= 0) continue;\n\t\t\tbitset<MAXN> qq = A[i] & winners[l][i - 1];\n\t\t\tif(qq.count()) rgh[l][i] = 1;\n\t\t}\n\n\t\tfor(int l = 1; l <= n; l++)\n\t\t{\n\t\t\tint r = l + len - 1;\n\t\t\tif(r > n) continue;;\n\t\t\twinners[l][r] = rgh[l] & lft[r];\n\t\t}\n\t}\n\n\tcout << winners[1][n].count() << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbool win[2001][2001];\nbool dp[2][2001][2001];\nsigned main() {\n    int N; cin >> N;\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[0][i][i] = dp[1][i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            bool f1 = false, f2 = false;\n            for(int k=i+1; k<=j; k++) {\n                dp[0][j][i] |= win[i][k] and dp[0][j][k] and dp[1][i+1][k];\n            }\n            for(int k=i; k<j; k++) {\n                dp[1][i][j] |= win[j][k] and dp[1][i][k] and dp[0][j-1][k];\n            }\n            // fprintf(stderr, \"dp[0][%lld][%lld] = %lld, dp[1][%lld][%lld] = %lld\\n\", i, j, dp[0][i][j], j, i, dp[1][j][i]);\n            dp[0][j][i] = f1, dp[1][i][j] = f2;\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dp[0][N-1][i] and dp[1][0][i]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    for(int i=0;i<n;i++){\n        dp[i][i]=true;\n        for(int j=0;j<i;j++){\n            scanf(\" %c\",&c);\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            bool j1=false;\n            for(int k=j+1;k<=R && !j1;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            bool j1=false;\n            for(int k=R;k<j && !j1;k++){\n                j1|=A[j][k] & dp[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <iostream>\n#include <bitset>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 2000;\nbitset<N> left_wins[N];\nbitset<N> right_wins[N];\nbitset<N> wins[N];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (str[j] == '1') wins[i][j] = 1;\n\t\t\telse wins[j][i] = 1;\n\t\t}\n\t}\n\tfor (int b = 0; b < n; ++b) {\n\t\tright_wins[b][b] = 1;\n\t\tleft_wins[b][b] = 1;\n\t\tfor (int a = b-1; a >= 0; --a) {\n\t\t\tbitset<N> mask;\n\n\t\t\tmask = wins[b] & left_wins[a] & right_wins[b-1];\n\t\t\tif (mask.count() > 0) left_wins[a][b] = 1;\n\t\t\t// cerr << \"b win [\" << a << \", \" << b << \"] = \" << mask.count() << '\\n';\n\n\t\t\tmask = wins[a] & left_wins[a+1] & right_wins[b];\n\t\t\tif (mask.count() > 0) right_wins[b][a] = 1;\n\t\t\t// cerr << \"a win [\" << a << \", \" << b << \"] = \" << mask.count() << '\\n';\n\n\t\t\t/*\n\t\t\tcerr << \"Int bits:\\n\\t\";\n\t\t\tfor (int j = a; j <= b; ++j) cerr << left_wins[a][j]; cerr << \"\\n\\t\";\n\t\t\tfor (int j = a; j <= b; ++j) cerr << right_wins[b][j]; cerr << '\\n';\n\t\t\t*/\n\t\t}\n\t}\n\n\tbitset<N> res = left_wins[0] & right_wins[n-1];\n\tcout << res.count() << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\nusing namespace std;\n\nint win[2000][2000];\nbitset<2000> dpL[2000],dpR[2000];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // cout << fixed << setprecision(20);\n    int n;cin >> n;\n    win[0][0] = 1;\n    for(int i = 1;i < n;i++){\n        win[i][i] = 1;\n        string s;cin >> s;\n        REP(j,i){\n            win[i][j] = (s[j] == '1');\n            win[j][i] = !win[i][j];\n        }\n    }\n    //REP(i,n){\n    //    REP(j,n)cout << win[i][j] << ' ';\n    //    cout << '\\n';\n    //}\n    for(int i = 0;i < n;i++){\n        dpL[i][i] = dpR[i][i] = true;\n    }\n    for(int d = 1;d < n;d++){\n        for(int i = 0;i + d < n;i++){\n            for(int j = i+1;j <= i+d;j++){\n                dpL[i][i+d] = dpL[i][i+d] | (win[i][j] & dpL[j][i+d] & dpR[j][i+1]);\n            }\n        }\n        for(int i = n-1;i - d >= 0;i--){\n            for(int j = i-1;j >= i-d;j--){\n                dpR[i][i-d] = dpR[i][i-d] | (win[i][j] & dpR[j][i-d] & dpL[j][i-1]);\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0;i < n;i++){\n       // cout << dpR[i] << '\\n';\n        if(dpR[i][0] & dpL[i][n-1])ans++;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nint N;\nbool A[2010][2010];\nbool L[2010][2010];\nbool R[2010][2010];\n\nusing BS = bitset<2010>;\nV<BS> Rix(2010);\nV<BS> Lxi(2010);\nV<BS> Aix(2010);\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tcin >> N;\n\t{\n\t\tV<string> s(N);\n\t\trep1(i,N-1) cin >> s[i];\n\t\trep(i,N) rep(j,N){\n\t\t\tif(i>j) A[i][j] = s[i][j]=='1';\n\t\t\tif(j>i) A[i][j] = s[j][i]=='0'; \n\t\t}\n\t}\n\tif(false){\n\t\trep(i,N){\n\t\t\trep(j,N) cout << A[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n\trep(i,N){\n\t\trep(j,N) if(A[i][j]) Aix[i].set(j);\n\t}\n\n\tfor(int d=1;d<=N;d++){\n\t\tfor(int l=0;l+d-1<N;l++){\n\t\t\tint r = l+d-1;\n\t\t\tif(d == 1){\n\t\t\t\tLxi[r].set(l);\n\t\t\t\tRix[l].set(r);\n\t\t\t\tL[l][r] = true;\n\t\t\t\tR[l][r] = true;\n\t\t\t}else{\n\t\t\t\t{\t//L\n\t\t\t\t\t// for(int x=l+1;x<=r;x++){\n\t\t\t\t\t// \tif(A[l][x] && R[l+1][x] && L[x][r]){\n\t\t\t\t\t// \t\tL[l][r] = true;\n\t\t\t\t\t// \t\tbreak;\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\tauto tmp = Aix[l] & Rix[l+1] & Lxi[r];\n\t\t\t\t\tif(tmp.any()) Lxi[r].set(l);\n\t\t\t\t}\n\t\t\t\t{\t//R\n\t\t\t\t\t// for(int x=l;x<r;x++){\n\t\t\t\t\t// \tif(A[r][x] && L[x][r-1] && R[l][x]){\n\t\t\t\t\t// \t\tR[l][r] = true;\n\t\t\t\t\t// \t\tbreak;\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\tauto tmp = Aix[r] & Rix[l] & Lxi[r-1];\n\t\t\t\t\tif(tmp.any()) Rix[l].set(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i,N) if(Rix[0][i] && Lxi[N-1][i]){\n\t\tans++;\n\t\tshow(i);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000003;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nbool b[2000][2000];\n\nbool le[2000][2000], ri[2000][2000];\nvoid solve() {\n\tint n; cin >> n;\n\trep1(i, n - 1) {\n\t\trep(j, i) {\n\t\t\tchar t; cin >> t;\n\t\t\tif (t == '1') {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n)le[i][i] = ri[i][i] = true;\n\n\tint ans = 0;\n\tRep1(i, 2, n) {\n\t\trep(j, n - i + 1) {\n\t\t\tint l = j;\n\t\t\tint r = j + i - 1;\n\t\t\tRep1(k, l + 1, r) {\n\t\t\t\tif (b[l][k] && ri[l + 1][k] && le[r][k]) {\n\t\t\t\t\tle[r][l] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRep(k, l, r) {\n\t\t\t\tif (b[r][k] && ri[l][k] && le[r - 1][k]) {\n\t\t\t\t\tri[l][r] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (ri[0][i] && le[n - 1][i])ans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbool win[2001][2001];\nbool dp[2][2001][2001];\nsigned main() {\n    int N; scanf(\"%lld\", &N);\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; scanf(\" %c\", &c);\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[0][i][i] = dp[1][i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            bool f1 = false, f2 = false;\n            for(int k=i; k<j; k++) {\n                f2 |= win[j][k] and dp[1][i][k] and dp[0][j-1][k];\n            }\n            for(int k=i+1; k<=j; k++) {\n                f1 |= win[i][k] and dp[0][j][k] and dp[1][i+1][k];\n            }\n            dp[0][j][i] = f1, dp[1][i][j] = f2;\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dp[0][N-1][i] and dp[1][0][i]);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nbitset<N>a[N],dp1[N],dp2[N];\nint n;\nchar s[N];\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=2;i<=n;i++)\n    {\n        scanf(\"%s\",s+1);\n        for(int j=1;j<i;j++)\n            if(s[j]=='1')\n            a[i].set(j,1),a[j].set(i,0);\n            else a[j].set(i,1),a[i].set(j,0);\n    }\n    for(int i=1;i<=n;i++) dp1[i].set(i),dp2[i].set(i);\n    for(int i=2;i<=n;i++)\n        for(int l=1;l+i-1<=n;l++)\n    {\n        int r=l+i-1;\n        if((dp1[r]&dp2[l+1]&a[l]).count()) dp1[r].set(l,1);\n        if((dp1[r-1]&dp2[l]&a[r]).count()) dp2[l].set(r,1);\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)\n        if(dp1[n][i]&dp2[1][i]) ans++;\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <mutex>\n#include <cmath>\n#define lli long long int\n#define ll long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nint main(){\n  int N;\n  int f = 0;\n  cin >> N;\n  int a[N][N-1];\n  for(int i = 0; i < N - 1; i++){\n    for(int j = 0; j <= i; j++){\n      cin >> a[i][j];\n      if(a[i][j] == '1'){\n        f++;\n      }\n    }\n  }\n  if(f%2 == 1){\n    cout << N/2 +1;\n  }\n  else{\n    cout << N/2;\n  }\n  cout << f;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 2020;\nint a[MAX][MAX]={};\nint dpL[MAX][MAX]={};\nint dpR[MAX][MAX]={};\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    dpL[i][i]=dpR[i][i]=1; \n\n  for(int w=2;w<=n;w++){\n    for(int i=0;i+w<=n;i++){\n      int l=i,r=i+w-1;\n      for(int k=l+1;k<=r;k++)\n        dpL[r][l]|=dpR[l+1][k]&dpL[r][k]&a[l][k];\n\n      for(int k=l;k<r;k++)\n        dpR[l][r]|=dpR[l][k]&dpL[r-1][k]&a[r][k];      \n    }\n  }\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    if(dpR[0][i]&dpL[n-1][i]) ans++;  \n  cout<<ans<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\" %c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    //vector<vector<bool>> L(N, vector<bool>(N));\n    //vector<vector<bool>> R(N, vector<bool>(N));\n    static bool L[2048][2048];\n    static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<N; j++)\n                    b |= a[j] & l[j] & r[j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=0; j<i; j++)\n                    b |= a[j] & l[j] & r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst int N = 2010;\nbitset<N> dp[N], wx[N], wy[N];\n\nint main() {\n    int n;\n    cin >> n;\n    FOR(i,1,n-1){\n        string s;\n        cin >> s;\n        REP(j,i){\n            if (s[j] == '1'){\n                wx[i].set(j);\n                wy[j].set(i);\n            }else{\n                wx[j].set(i);\n                wy[i].set(j);\n            }\n        }\n    }\n\n    REP(i,n){\n        dp[i].set(i);\n    }\n\n    FOR(len,1,n-1){\n        REP(l,n+1-len){\n            int r = l + len - 1;\n            if (l > 0){\n                if ((wx[l - 1] & dp[l] & dp[r]).any()) dp[r].set(l - 1);\n            }\n            if (r < n - 1){\n                if ((wx[r + 1] & dp[l] & dp[r]).any()) dp[l].set(r + 1);\n            }\n        }\n    }\n    cout << (dp[0] & dp[n - 1]).count() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\ntypedef long long ll;\n\nbool g[2005][2005];\nbool dp1[2005][2005]; // dp1[i][j]: [i,j]でjが勝てる\nbool dp2[2005][2005]; // dp2[j][i]: [i,j]でiが勝てる\n\nchar buf[3000];\nint main(void) {\n  int n = 2000;\n  scanf(\"%d\", &n);\n  REP(i, n-1) {\n    scanf(\"%s\", buf);\n    REP(j, i+1) {\n      bool b;\n      b = buf[j] == '1';\n      g[i+1][j] = b;\n      g[j][i+1] = !b;\n    }\n  }\n  REP(i, n) {\n    g[i][i] = true;\n    dp1[i][i] = true;\n    dp2[i][i] = true;\n  }\n  for(int d = 1; d < n; ++d) {\n    REP(i, n-d) {\n      int j = i + d;\n      bool f1 = false;\n      bool f2 = false;\n      for(int k = i; k < j; ++k) {\n        f1 |= g[j][k] & dp1[i][k] & dp2[j-1][k];\n      }\n      for(int k = i+1; k <= j; ++k) {\n        f2 |= g[i][k] & dp1[i+1][k] & dp2[j][k];\n      }\n      dp1[i][j] = f1;\n      dp2[j][i] = f2;\n    }\n  }\n  int res = 0;\n  REP(i, n) {\n    if(dp1[0][i] & dp2[n-1][i]) {\n      ++res;\n    }\n  }\n  \n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\n#include <bitset>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_N   (2000)\nchar szInput[MAX_N + 1];\nstatic bitset<MAX_N + 1> s_abitMatchTbl[MAX_N + 1];\n\nint main(void)\n{\n    SDWORD lInput_n = inputSDWORD();\n    for (SDWORD lIdxI = 2; lIdxI <= lInput_n; lIdxI++) {\n        inputString(szInput);\n        for (SDWORD lIdxJ = 1; lIdxJ < lIdxI; lIdxJ++) {\n            if ('0' == szInput[lIdxJ - 1]) {\n                s_abitMatchTbl[lIdxJ][lIdxI] = true;\n            }\n        }\n    }\n\n    static bitset<MAX_N + 1> s_absDpL[MAX_N+1];\n    static bitset<MAX_N + 1> s_absDpR[MAX_N+1];\n\n    for (SDWORD lUpdateWidth = 0; lUpdateWidth <= lInput_n; lUpdateWidth++) {\n        for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n - lUpdateWidth; lUpdIdxL++) {\n            SDWORD lUpdIdxR = lUpdIdxL + lUpdateWidth;\n            if (lUpdIdxL == lUpdIdxR) {\n                s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n            } else {\n                /* LR */\n                bool bCondLR = false;\n                bool bCondLL = false;\n                bool bCondRR = false;\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n                    bool bDpL  = s_absDpL[lUpdIdxL][lUpdIdxM];\n                    bool bDpML = s_absDpL[lUpdIdxM][lUpdIdxR];\n                    bool bDpR  = s_absDpR[lUpdIdxL][lUpdIdxM];\n                    bool bDpMR = s_absDpR[lUpdIdxM][lUpdIdxR];\n                    bool bDp1R = s_absDpR[lUpdIdxM+1][lUpdIdxR];\n                    if (bDpL && bDp1R) {\n                        bCondLR = true;\n                    }\n                    if (lUpdIdxM != lUpdIdxL) {\n                        if (bDpL && bDpML) {\n                            bCondLL = true;\n                        }\n                        if (bDpR && bDpMR) {\n                            bCondRR = true;\n                        }\n                    }\n                }\n\n                if (bCondLR) {\n                    if (s_abitMatchTbl[lUpdIdxL][lUpdIdxR]) {\n                        s_absDpL[lUpdIdxL][lUpdIdxR] = true;\n                    } else {\n                        s_absDpR[lUpdIdxL][lUpdIdxR] = true;\n                    }\n                }\n                if (bCondLL) {\n                    s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                }\n                if (bCondRR) {\n                    s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                }\n            }\n        }\n    }\n\n    /* count winners */\n    SDWORD lAns = 0;\n    for (SDWORD lMid = 1; lMid <= lInput_n; lMid++) {\n        if (s_absDpR[1][lMid] && s_absDpL[lMid][lInput_n]) {\n            lAns++;\n        }\n    }\n\n    printf(\"%d\\n\", lAns);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        string t;\n        cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            A[i][j] = t[j]!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<bool>> L(N, vector<bool>(N));\n    vector<vector<bool>> R(N, vector<bool>(N));\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<N && !b; j++)\n                    if (a[j] && l[j] && r[j])\n                        b = true;\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=0; j<i && !b; j++)\n                    if (a[j] && l[j] && r[j])\n                        b = true;\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\nint n, a[N][N], c[N];\nbitset<N> pb[N], sb[N];\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 2; i <= n; i++){\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tscanf(\"%1d\", a[i] + j);\n\t\t\ta[j][i] = !a[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++)\n\t\tif(a[i][j]){ pb[i].flip(j); sb[i].flip(j); }\n\tfor(int i = 1; i <= n; i++) pb[i].flip(i);\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(pb[i][k]) pb[i] |= pb[k];\n\t\t}\n\t\tint t = 1;\n\t\tfor(int i = 1; i < k; i++) t &= pb[k][i];\n\t\tc[k] += t;\n\t}\n\tfor(int i = 1; i <= n; i++) sb[i].flip(i);\n\tfor(int k = n; k >= 1; k--){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(sb[i][k]) sb[i] |= sb[k];\n\t\t}\n\t\tint t = 1;\n\t\tfor(int i = n; i > k; i--) t &= sb[k][i];\n\t\tc[k] += t;\n\t}\n\tprintf(\"%d\\n\", count(c, c + N, 2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 10005\n#define ba 47\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nbitset<2005> a[2005],dpr[2005],dpl[2005],tmp;\nint N;\nchar s[2005][2005];\nvoid Solve() {\n    read(N);\n    for(int i = 2 ; i <= N ; ++i) {\n        scanf(\"%s\",s[i] + 1);\n        for(int j = 1 ; j < i ; ++j) {\n            if(s[i][j] == '1') a[i][j] = 1;\n            else a[j][i] = 1;\n        }\n    }\n    for(int i = 1 ; i <= N ; ++i) dpr[i][i] = 1,dpl[i][i] = 1;\n    for(int d = 2 ; d <= N ; ++d) {\n        for(int l = 1 ; l <= N ; ++l) {\n            int r = l + d - 1;\n            if(r > N) break;\n            if((dpr[l] & dpl[r - 1] & a[r]).any()) {\n                dpr[l][r] = 1;\n            }\n            if((dpl[r] & dpr[l + 1] & a[l]).any()) {\n                dpl[r][l] = 1;\n            }\n        }\n    }\n    out((dpr[1] & dpl[N]).count());enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr int Nmax = 2002;\nint main()\n{\n    int N;\n    cin >> N;\n    vector<bitset<Nmax>> A(N + 2, bitset<Nmax>());\n    FOR(i, 1, N)\n    {\n        string S;\n        cin >> S;\n        REP(j, i)\n        {\n            A[i + 1][j + 1] = S[j] - '0';\n            A[j + 1][i + 1] = !A[i + 1][j + 1];\n        }\n    }\n\n    vector<bitset<Nmax>> ldp(N + 2, bitset<Nmax>()), rdp(N + 2, bitset<Nmax>());\n    REP(i, N + 1) ldp[i][i + 1] = rdp[i + 1][i] = 1;\n\n    FOR(d, 2, N + 1) REP(l, N + 2 - d)\n    {\n        if ((ldp[l] & rdp[l + d] & (A[l] | A[l + d])).any()) ldp[l][l + d] = rdp[l + d][l] = 1;\n    }\n\n    int ret = (ldp[0] & rdp[N + 1]).count();\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint win[2001][2001];\nint dpl[2001][2001], dpr[2001][2001];\nsigned main() {\n    int N; cin >> N;\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            int p = c - '0';\n            win[i][j] = p;\n            win[j][i] = 1 - p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dpl[i][i] = dpr[i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            for(int k=i; k<=j; k++) {\n                if(k > i and win[i][k] and dpl[k][j] and dpr[k][i+1]) dpl[i][j] = true;\n                if(k < j and win[j][k] and dpr[k][i] and dpl[k][j-1]) dpr[j][i] = true;\n                \n            }\n            // fprintf(stderr, \"dpl[%lld][%lld] = %lld, dpr[%lld][%lld] = %lld\\n\", i, j, dpl[i][j], j, i, dpr[j][i]);\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dpl[i][N-1] and dpr[i][0]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbitset<SZ> grid[SZ], msk[SZ];\nbitset<SZ> sv[SZ], sv2[SZ];\nvector<ll> wn[SZ];\nbitset<SZ> cur;\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tsv[i - 1][i] = 1;\n\t\tsv2[i][i - 1] = 1;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i + 1][j + 1] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j + 1][i + 1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n + 3; i++) {\n\t\tcur = 0;\n\t\tfor (int j = 0; j < i; j++) cur[j] = 1;\n\t\tmsk[i] = cur;\n\t}\n\tfor (int i = 2; i <= n + 1; i++) {\n\t\tfor (int j = 0; j <= n + 1; j++) {\n\t\t\tll lft = j, rt = j + i;\n\t\t\tif (lft == 2 && rt == 4) {\n\t\t\t\tcout << \"\";\n\t\t\t}\n\t\t\tif (rt <= n + 1) {\n\t\t\t\tif ((((sv[lft] & grid[lft] & sv2[rt]) >> lft) & msk[i + 1]) != 0 || (((sv2[rt] & grid[rt] & sv[lft]) >> lft) & msk[i + 1]) != 0) {\n\t\t\t\t\tsv[lft][rt] = 1;\n\t\t\t\t\tsv2[rt][lft] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (sv[0][i] && sv[i][n + 1]) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <iostream>\n\n#define MAX_N 2000\n\nusing namespace std;\n\nbitset<MAX_N> dpl[MAX_N];\nbitset<MAX_N> dpr[MAX_N];\n\nbitset<MAX_N> A[MAX_N];\n\nint main( int argc, char **argv )\n{\n    // input\n    int N;\n    cin >> N;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        string S;\n        cin >> S;\n\n        for ( int j = 0; j < i; j++ )\n        {\n            if ( S[j] == '1' )\n                A[i][j] = true;\n            else\n                A[j][i] = true;\n        }\n    }\n\n    for ( int i = 0; i < N; i++ ) dpl[i][i] = dpr[i][i] = true;\n\n    // solve\n    for ( int d = 0; d < N; d++ )\n    {\n        for ( int i = 0; i + d < N; i++ )\n        {\n            int j = i + d;\n            if ( ( dpl[j - 1] & dpr[i] & A[j] ).any() ) dpr[i][j] = 1;\n            if ( ( dpl[j] & dpr[i + 1] & A[i] ).any() ) dpl[j][i] = 1;\n        }\n    }\n\n    int ans = ( dpl[N - 1] & dpr[0] ).count();\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        string t;\n        cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            A[i][j] = t[j]!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<bool>> L(N, vector<bool>(N));\n    vector<vector<bool>> R(N, vector<bool>(N));\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_N   (2000)\nchar szInput[MAX_N + 1];\nint main(void)\n{\n    SDWORD lInput_n = inputSDWORD();\n    static SDWORD s_aalMatchTbl[MAX_N+1][MAX_N+1];\n\n    for (SDWORD lIdxI = 2; lIdxI <= lInput_n; lIdxI++) {\n        inputString(szInput);\n        for (SDWORD lIdxJ = 1; lIdxJ < lIdxI; lIdxJ++) {\n            if ('1' == szInput[lIdxJ - 1]) {\n                s_aalMatchTbl[lIdxI][lIdxJ] = 1;\n                s_aalMatchTbl[lIdxJ][lIdxI] = 0;\n            } else {\n                s_aalMatchTbl[lIdxI][lIdxJ] = 0;\n                s_aalMatchTbl[lIdxJ][lIdxI] = 1;\n            }\n        }\n    }\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalMatchTbl[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    static SDWORD s_aalDpL[MAX_N+1][MAX_N+1];\n    static SDWORD s_aalDpR[MAX_N+1][MAX_N+1];\n\n    for (SDWORD lUpdateWidth = 0; lUpdateWidth <= lInput_n; lUpdateWidth++) {\n        for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n - lUpdateWidth; lUpdIdxL++) {\n            SDWORD lUpdIdxR = lUpdIdxL + lUpdateWidth;\n            if (lUpdIdxL == lUpdIdxR) {\n                s_aalDpL[lUpdIdxL][lUpdIdxR] = 1;\n                s_aalDpR[lUpdIdxL][lUpdIdxR] = 1;\n            } else {\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A1: [%d, <%d> %d], %d %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalMatchTbl[lUpdIdxL][lUpdIdxR],\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM+1][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_aalMatchTbl[lUpdIdxL][lUpdIdxR])\n                        && (1 == s_aalDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_aalDpR[lUpdIdxM+1][lUpdIdxR])) {\n                        s_aalDpL[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n                for (SDWORD lUpdIdxM = lUpdIdxL + 1; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A2: [%d, <%d> %d], %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpL[lUpdIdxM][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_aalDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_aalDpL[lUpdIdxM][lUpdIdxR])) {\n                        s_aalDpL[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update B1: [%d, <%d> %d], %d %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalMatchTbl[lUpdIdxR][lUpdIdxL],\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM+1][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_aalMatchTbl[lUpdIdxR][lUpdIdxL])\n                        && (1 == s_aalDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_aalDpR[lUpdIdxM+1][lUpdIdxR])) {\n                        s_aalDpR[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n                for (SDWORD lUpdIdxM = lUpdIdxL + 1; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update B2: [%d, <%d> %d], %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalDpR[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_aalDpR[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_aalDpR[lUpdIdxM][lUpdIdxR])) {\n                        s_aalDpR[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpL[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpR[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    /* count winners */\n    SDWORD lAns = 0;\n    for (SDWORD lMid = 1; lMid <= lInput_n; lMid++) {\n        if (s_aalDpR[1][lMid] && s_aalDpL[lMid][lInput_n]) {\n            lAns++;\n        }\n    }\n\n    printf(\"%d\\n\", lAns);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nbitset<2000> dp[2020];\nbitset<2000> kati[2020];\n\n\n \nbool solve(int x,int y){\n\t\n\tbool bo=0;\n\tif(x<y){\n\t\n\t\t\n\t\t\t\n\t\t\tbitset<2000> hoge= dp[x+1]&dp[y]&kati[x];\n\t\thoge>>=(x+1);\n\t\thoge<<=(2000-(y-x));\n\t\t\tbo=hoge.any();\n\t\t\t/*\n\t\t\tif(dfs(i,x+1)&& dfs(i,y) && kati[x][i]){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*/\n\t\t\n\t\t\n\t}\n\telse{\n\t\t\n\t\t\tbitset<2000> hoge= dp[x-1]&dp[y]&kati[x];\n\t\t\thoge>>=y;\n\t\thoge<<=(2000-(x-y));\n\t\t\tbo=hoge.any();\n\t\t\t/*\n\t\t\tif(dfs(i,x-1)&& dfs(i,y) && kati[x][i]){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*/\n\t\t\n\t}\n\tif(bo) dp[y].set(x);\n\t//cout<<x<<\" \"<<y<<\" \"<<bo<<endl;\n\n\treturn bo;\n}\n \n signed main(){\n \t\n \n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n int n;\n \tcin>>n;\n \tfor(int i=0;i<n;i++)dp[i].set(i),kati[i].set(i);\n \t\n \tfor(int i=1;i<n;i++){\n \t\tstring s;\n \t\tcin>>s;\n \t\t\n \t\tfor(int j=0;j<i;j++){\n \t\t\tif(s[j]=='1'){\n \t\t\t\tkati[i].set(j);\n //\t\t\t\tkati2[i][j]=1;\n \t\t\t}\n \t\t\t\telse kati[j].set(i);\n \t\t}\n \t}\n \t\t\n \t\n \tint ans=0;\n \t\tfor(int d=1;d<n;d++)for(int i=0;i+d<n;i++){\n \t\t\tsolve(i,i+d);\n// \t\t\tdfs(i,i+d);\n \t\t\tsolve(i+d,i);\n //\t\t\tdfs(i+d,i);\n \t\t}\n \t\t\n \tfor(int i=0;i<n;i++)ans+=(dp[0][i]&& dp[n-1][i]);\n \tcout<<ans<<endl;\n\n \t\n \treturn 0;\n \n  }\n  \n  \n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\nbool dp2[MX][MX]={};\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    for(int i=0;i<n;i++){\n        dp[i][i]=dp2[i][i]=true;\n        for(int j=0;j<i;j++){\n            scanf(\" %c\",&c);\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            for(int k=j+1;k<=R && !dp2[R][j];k++){\n                dp2[R][j]|=dp[l][k] & dp2[R][k] & A[j][k];\n            }\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            for(int k=R;k<j && !dp[R][j];k++){\n                dp[R][j]|=dp2[l][k] & dp[R][k] & A[j][k];\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] & dp2[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst int N = 2010;\nbitset<N> dp[N][N], wx[N], wy[N];\n\nint main() {\n    int n;\n    cin >> n;\n    FOR(i,1,n-1){\n        string s;\n        cin >> s;\n        REP(j,i){\n            if (s[j] == '1'){\n                wx[i].set(j);\n                wy[j].set(i);\n            }else{\n                wx[j].set(i);\n                wy[i].set(j);\n            }\n        }\n    }\n\n    REP(i,n){\n        dp[i][i + 1].set(i);\n    }\n\n    FOR(len,1,n-1){\n        REP(l,n+1-len){\n            int r = l + len;\n            if (l > 0){\n                dp[l - 1][r] |= (dp[l][r] & wy[l - 1]);\n                if ((dp[l][r] & wx[l - 1]).any()) dp[l - 1][r].set(l - 1);\n            }\n            if (r < n){\n                dp[l][r + 1] |= (dp[l][r] & wy[r]);\n                if ((dp[l][r] & wx[r]).any()) dp[l][r + 1].set(r);\n            }\n        }\n    }\n    cout << dp[0][n].count() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long maxN = 2000;\n    unsigned long N;\n    cin >> N;\n    vector<vector<bitset<maxN>>> dp(N);\n    vector<bitset<maxN>> tapi(N);\n    for(unsigned long i = 1; i < N; ++i){\n        string s;\n        cin >> s;\n        for(unsigned long j = 0; j < i; ++j){\n            tapi[i][j] = (s[j] == '1');\n            tapi[j][i] = (s[j] == '0');\n        }\n    }\n    for(unsigned long i = 0; i < N; ++i){\n        dp[i] = vector<bitset<maxN>>(N - i);\n        dp[i][0][i] = true;\n    }\n    for(unsigned long i = 1; i < N; ++i){\n        for(unsigned long j = 0; j + i < N; ++j){\n            if((dp[j + 1][i - 1] & tapi[j]).any())dp[j][i][j] = true;\n            if((dp[j][i - 1] & tapi[j + i]).any())dp[j][i][j + i] = true;\n            if((dp[j + 1][i - 1] & ~tapi[j]).any())dp[j][i] |= dp[j + 1][i - 1];\n            if((dp[j][i - 1] & ~tapi[j + i]).any())dp[j][i] |= dp[j][i - 1];\n        }\n    }\n    cout << dp[0].back().count() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _dbg(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _dbg(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_dbg(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\n#ifndef LOCAL\nconst int N=2001;\n#else\nconst int N=7;\n#endif\nusing bt=bitset<N>;\nbt a[N];\nbt win[N];\nbt ones[N];\nbt stolb[N];\nbool any(bt bs, int l,int r){\n    return ((bs>>l)&ones[r-l+1]).any();\n}\nint32_t main() {\n    forn(i,N){forn(j,i)ones[i].set(j);dbg(i,ones[i]);}\n    int n;\n    cin>>n;\n    forn(i,n){\n        forn(j,i){\n            char c;\n            cin>>c;\n            a[i][j]=c-'0';\n            a[j][i]=a[i][j]^1;\n        }\n        win[i].set(i);\n        stolb[i].set(i);\n    }\n    for(int len=2;len<=n;++len){\n        for(int i=0;i+len-1<n;++i){\n            int r=i+len-1;\n            if(a[i][r]){\n                dbg(len,i,r);\n                dbg(win[i]);\n                dbg(win[r]);\n                if(any(win[i]&(win[r]>>1),i,r-1)){\n                    win[i].set(r);\n                    stolb[r].set(i);\n                }\n                dbg(win[i]);\n            }\n            if(any((a[i]>>1)&win[i]&(stolb[r]>>1),i,r-1)){\n                win[i].set(r);\n                stolb[r].set(i);                \n            }\n        }\n        for(int i=len-1;i<n;++i){\n            int l=i-len+1;\n            if(a[i][l]){\n                dbg(len,l,i);\n                if(any((win[l]<<1)&win[i],l+1,i)){\n                    win[i].set(l);\n                    stolb[l].set(i);\n                }\n                dbg(win[i]);\n            }\n            if(any((a[i]<<1)&win[i]&(stolb[l]<<1),l+1,i)){\n                win[i].set(l);\n                stolb[l].set(i);                \n            }\n        }\n    }\n    int ans=0;\n    forn(i,n){\n        ans+=(win[i][0]&win[i][n-1]);\n    }\n    cout<<ans<<'\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        string t;\n        cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            A[i][j] = t[j]!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<bool>> L(N, vector<bool>(N));\n    vector<vector<bool>> R(N, vector<bool>(N));\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<N; j++)\n                    b |= a[j] & l[j] & r[j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=0; j<i; j++)\n                    b |= a[j] & l[j] & r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=2005;\nint n;bitset<MAXN> pre[MAXN],suf[MAXN],flg[MAXN];\nbitset<MAXN> now;\nchar ch[MAXN];\nint main()\n{\n\tn=read();\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",ch+1);\n\t\tfor(int j=1;j<i;j++)flg[i][j]=(ch[j]-'0'),flg[j][i]=flg[i][j]^1;\n\t}\n\tfor(int i=1;i<=n;i++)pre[i][i-1]=suf[i][i+1]=1;\n\tfor(int i=1;i<=n;i++)for(int x=1;x+i-1<=n;x++)\n\t{\n\t\tint y=x+i-1;\n\t\tnow=flg[x-1]|flg[y+1];\n\t\tnow=now&((pre[x]<<1)&(suf[y]>>1));\n\t\tif(now.any())pre[x][y]=suf[y][x]=1;\n\t}int ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(pre[1][i-1]&&suf[n][i+1])\n\t\t\t++ans;\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\n#include <bitset>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_N   (2000)\nchar szInput[MAX_N + 1];\nstatic bitset<MAX_N + 1> s_abitMatchTbl[MAX_N + 1];\n\nint main(void)\n{\n    SDWORD lInput_n = inputSDWORD();\n    for (SDWORD lIdxI = 2; lIdxI <= lInput_n; lIdxI++) {\n        inputString(szInput);\n        for (SDWORD lIdxJ = 1; lIdxJ < lIdxI; lIdxJ++) {\n            if ('0' == szInput[lIdxJ - 1]) {\n                s_abitMatchTbl[lIdxJ][lIdxI] = true;\n            }\n        }\n    }\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalMatchTbl[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    static bitset<MAX_N + 1> s_absDpL[MAX_N+1];\n    static bitset<MAX_N + 1> s_absDpR[MAX_N+1];\n\n    for (SDWORD lUpdateWidth = 0; lUpdateWidth <= lInput_n; lUpdateWidth++) {\n        for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n - lUpdateWidth; lUpdIdxL++) {\n            SDWORD lUpdIdxR = lUpdIdxL + lUpdateWidth;\n            if (lUpdIdxL == lUpdIdxR) {\n                s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n            } else {\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A1: [%d, <%d> %d], %d %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalMatchTbl[lUpdIdxL][lUpdIdxR],\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM+1][lUpdIdxR]);\n#endif\n\n                    if ((s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (s_absDpR[lUpdIdxM+1][lUpdIdxR])) {\n                        if (s_abitMatchTbl[lUpdIdxL][lUpdIdxR]) {\n                            s_absDpL[lUpdIdxL][lUpdIdxR] = true;\n                        } else {\n                            s_absDpR[lUpdIdxL][lUpdIdxR] = true;\n                        }\n                    }\n                }\n                for (SDWORD lUpdIdxM = lUpdIdxL + 1; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A2: [%d, <%d> %d], %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpL[lUpdIdxM][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpL[lUpdIdxM][lUpdIdxR])) {\n                        s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                    if ((1 == s_absDpR[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpR[lUpdIdxM][lUpdIdxR])) {\n                        s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpL[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpR[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    /* count winners */\n    SDWORD lAns = 0;\n    for (SDWORD lMid = 1; lMid <= lInput_n; lMid++) {\n        if (s_absDpR[1][lMid] && s_absDpL[lMid][lInput_n]) {\n            lAns++;\n        }\n    }\n\n    printf(\"%d\\n\", lAns);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\nconst int N = 2003;\nbitset<N> beat[N], dpl[N], dpr[N];\nint n, ans;\nchar s[N];\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(Rint i = 2;i <= n;i ++){\n\t\tscanf(\"%s\", s + 1);\n\t\tfor(Rint j = 1;j < i;j ++)\n\t\t\tif(s[j] != '0') beat[i].set(j);\n\t\t\telse beat[j].set(i);\n\t}\n\tfor(Rint i = 1;i <= n;i ++) dpl[i][i] = dpr[i][i] = 1;\n\tfor(Rint len = 1;len < n;len ++)\n\t\tfor(Rint i = 1;i <= n - len;i ++){\n\t\t\tint j = i + len;\n\t\t\tif((dpl[j] & dpr[i + 1] & beat[i]).any()) dpl[j].set(i);\n\t\t\tif((dpl[j - 1] & dpr[i] & beat[j]).any()) dpr[i].set(j);\n\t\t}\n\tfor(Rint i = 1;i <= n;i ++) if(dpr[1][i] && dpl[n][i]) ++ ans;\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        string t;\n        cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            A[i][j] = t[j]!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<bool>> L(N, vector<bool>(N));\n    vector<vector<bool>> R(N, vector<bool>(N));\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N && L[i+d][i]; j++)\n                    if (A[i][j] && L[i+d][j] && R[i+1][j])\n                        L[i+d][i] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i && R[i-d][i]; j++)\n                    if (A[i][j] && L[i-1][j] && R[i-d][j])\n                        R[i-d][i] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n; cin>>n;\n    if(n==1){\n        cout<<1<<endl; return 0;\n    }\n    string a[2002];\n    for(int i=1; i<n; i++) cin>>a[i];\n    bool dp[2][2002][2002];\n    for(int i=0; i<n-1; i++){\n        if(a[i+1][i]=='0'){\n            dp[0][i][i+1]=1;\n            dp[1][i][i+1]=0;\n        }else{\n            dp[0][i][i+1]=0;\n            dp[1][i][i+1]=1;\n        }\n    }\n    for(int d=2; d<n; d++){\n        for(int i=0; i<n-d; i++){\n            if(dp[1][i+1][i+d] && a[i+d][i]=='0'){\n                dp[0][i][i+d]=1;\n            }else{\n                dp[0][i][i+d]=0;\n                for(int j=i+1; j<i+d; j++){\n                    if(dp[0][i][j] && dp[0][j][i+d]){\n                        dp[0][i][i+d]=1;\n                        break;\n                    }\n                }\n            }\n            if(dp[0][i][i+d-1] && a[i+d][i]=='1'){\n                dp[1][i][i+d]=1;\n            }else{\n                dp[1][i][i+d]=0;\n                for(int j=i+1; j<i+d; j++){\n                    if(dp[1][i][j] && dp[1][j][i+d]){\n                        dp[1][i][i+d]=1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    int ans=0;\n    if(dp[0][0][n-1]) ans++;\n    if(dp[1][0][n-1]) ans++;\n    for(int i=1; i<n-1; i++){\n        if(dp[1][0][i] && dp[0][i][n-1]) ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n#include<bits/stdc++.h>\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nbitset<2005> l[2005],r[2005],a[2005];//r[i]表示i作为右端点时那些左端点可行\nint n;\nchar s[2005];\nint main()\n{\n\tre(n);\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tscanf(\"%s\",s+1);\n\t\tfor(int j=1;j<i;++j)\n\t\t{\n\t\t\tif(s[j]=='1')a[i][j]=1;\n\t\t\telse a[j][i]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)l[i][i]=r[i][i]=1;\n\tfor(int len=1;len<n;++len)\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tif(i+len<=n && (r[i+len]&l[i+1]&a[i]).count())r[i+len][i]=1;\n\t\t\tif(i-len>=1 && (l[i-len]&r[i-1]&a[i]).count())l[i-len][i]=1;\n\t\t}\n\tprintf(\"%d\\n\",(l[1]&r[n]).count());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    int n;\n    cin >> n;\n    vs a(n-1);\n    rep(i, n-1) cin >> a[i];\n    vector<vector<bool>> win(n, vector<bool>(n));\n    rep1(i, n-1) rep(j, i) {\n        win[i][j] = (a[i-1][j] == '1');\n        win[j][i] = !(a[i-1][j] == '1');\n    }\n    vector<bitset<2005>> dpl(n), dpr(n);\n    dpl[0][0] = dpr[0][0] = true;\n    rep1(i, n-1) dpl[i] = dpr[i] = (dpl[i-1] << 1);\n    rep1(i, n-1) rep(a, n-i) {\n        int b = a + i;\n        bool lok = false;\n        rep1(c, i-1) if (dpl[a][a+c] && dpl[a+c][b]) {\n            lok = true;\n            break;\n        }\n        if (!lok && win[a][b]) {\n            rep(c, i) if (dpl[a][a+c] && dpr[a+c+1][b]) {\n                lok = true;\n                break;\n            }\n        }\n        dpl[a][b] = lok;\n        bool rok = false;\n        rep1(c, i-1) if (dpr[b-c][b] && dpr[a][b-c]) {\n            rok = true;\n            break;\n        }\n        if (!rok && win[b][a]) {\n            rep(c, i) if (dpr[b-c][b] && dpl[a][b-c-1]) {\n                rok = true;\n                break;\n            }\n        }\n        dpr[a][b] = rok;\n    }\n    int ans = 0;\n    rep(i, n) if (dpr[0][i] && dpl[i][n-1]) ++ans;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\nusing namespace std;\nint n, i, j, k, lg, nr;\nbitset<2005> a[2005], ds[2005], dd[2005], aux;\nchar x;\nint main(){\n    cin>> n;\n    for(i = 2; i <= n; i++){\n        for(j = 1; j < i; j++){\n            cin>> x;\n            a[i][j] = x - '0';\n            a[j][i] = 1 - a[i][j];\n        }\n    }\n    for(i = 1; i <= n; i++){\n        ds[i][i] = dd[i][i] = 1;\n    }\n    for(lg = 2; lg <= n; lg++){\n        for(i = 1; i <= n - lg + 1; i++){\n            j = i + lg - 1;\n            aux = (a[i] & dd[i + 1] & ds[j]);\n            ds[j][i] = aux.any();\n            aux = (a[j] & dd[i] & ds[j - 1]);\n            dd[i][j] = aux.any();\n        }\n    }\n    for(i = 1; i <= n; i++){\n        if(dd[1][i] == 1 && ds[n][i] == 1){\n            nr++;\n        }\n    }\n    cout<< nr;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nint kati[2002][2020]={};\nint dp[2020][2020]={};\n\nbool sumi[2002][2020]={};\n\nbool dfs(int x,int y){\n\tif(sumi[x][y]) return dp[x][y];\n\tbool bo=0;\n\tif(x<y){\n\t\n\t\tfor(int i=x+1;i<=y;i++){\n\t\t\tif(dfs(i,x+1)&& dfs(i,y) && kati[x][i]){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\telse{\n\t\tfor(int i=x-1;i>=y;i--){\n\t\t\tif(dfs(i,x-1)&& dfs(i,y) && kati[x][i]){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsumi[x][y]=1;\n\tdp[x][y]=bo;\n//\tcout<<x<<\" \"<<y<<\" \"<<bo<<endl;\n\treturn bo;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n int n;\n \tcin>>n;\n \tfor(int i=0;i<n;i++)dp[i][i]=1,sumi[i][i]=1,kati[i][i]=1;\n \t\n \tfor(int i=1;i<n;i++){\n \t\tstring s;\n \t\tcin>>s;\n \t\t\n \t\tfor(int j=0;j<i;j++){\n \t\t\tif(s[j]=='1'){\n \t\t\t//\tif(rand()%2){\t\n \t\t\t\tkati[i][j]=1;\n \t\t\t}\n \t\t\telse kati[j][i]=1;\n \t\t}\n \t}\n \t\t\n \t\n \tint ans=0;\n \tfor(int i=0;i<n;i++)ans+=(dfs(i,0)&& dfs(i,n-1));\n \tcout<<ans<<endl;\n \t\n \treturn 0;\n\n  }\n  \n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing _loop_int = int;\n#define REP(i,n) for(_loop_int i=0; i<(_loop_int)(n); i++)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a); i<(_loop_int)(b); i++)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1; i>=(_loop_int)(a); i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n#define ALL(v) (v).begin(),(v).end()\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define DEBUG_VEC(v) cerr<<#v<<\": \";REP(__i,(v).size())cerr<<((v)[__i])<<\", \";cerr<<endl\n\nconst ll MOD = 1000000007ll;\n\nint n;\nchar s[2521][2521];\nbool win[2521][2521];\nint nxt[2521][2521];\n\nshort yusho[2521][2521][2];\n\nbool calc(int l, int r, int k){\n    if(l>r)return true;\n    if(yusho[l][r][k] != -1){\n        return yusho[l][r][k]==1;\n    }\n    int p = k==0 ? l-1 : r+1;\n    int to = nxt[p][l];\n    while(to <= r){\n        bool ok = true;\n        if(to>l)ok = ok && calc(l,to-1,1);\n        if(to<r)ok = ok && calc(to+1,r,0);\n        if(ok){\n            return yusho[l][r][k] = 1;\n        }\n        to = nxt[p][to+1];\n    }\n    return yusho[l][r][k] = 0;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    REP(i,n-1)scanf(\"%s\",s[i+1]);\n    REP(i,n)REP(j,i){\n        win[i][j] = s[i][j]=='1';\n        win[j][i] = !win[i][j];\n    }\n    REP(i,n){\n        nxt[i][n] = n;\n        FORR(j,0,n){\n            nxt[i][j] = win[i][j] ? j : nxt[i][j+1];\n        }\n    }\n    REP(i,n)REP(j,n)REP(k,2)yusho[i][j][k] = -1;\n    int ans = 0;\n    REP(i,n){\n        bool ok = true;\n        if(i>0)ok = ok && calc(0,i-1,1);\n        if(i<n-1)ok=ok && calc(i+1,n-1,0);\n        if(ok)ans++;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2020;\nusing bset = bitset<maxn>;\nbool dpl[maxn][maxn], dpr[maxn][maxn];\nbset beat[maxn], beatl[maxn], beatr[maxn], pl[maxn];\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tchar c; cin >> c;\n\t\t\tif(c == '1') beat[i][j] = 1;\n\t\t\telse beat[j][i] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tpl[i] = pl[i - 1];\n\t\tpl[i].set(i - 1);\n\t}\n\tfor(int i = 0; i < n; i++) dpl[i][i] = 1, dpr[i][i] = 1, beatl[i][i] = 1, beatr[i][i] = 1;\n\tfor(int i = 2; i <= n; i++){\n\t\tfor(int j = 0; j + i - 1 < n; j++){\n\t\t\tint from = j, to = j + i - 1;\n\t\t\tbset fr = beatr[from + 1];\n\t\t\tbset bk = beatl[to];\n\t\t\tbset now = beat[from];\n\t\t\tnow &= fr;\n\t\t\tnow &= bk;\n\t\t\tif(now.any()){\n\t\t\t\tdpl[from][to] = 1;\n\t\t\t\tbeatl[to][from] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int j = n - 1; j - i + 1 >= 0; j--){\n\t\t\tint from = j, to = j - i + 1;\n\t\t\tbset fr = beatr[to];\n\t\t\tbset bk = beatl[from - 1];\n\t\t\tbset now = beat[from];\n\t\t\tnow &= bk;\n\t\t\tnow &= fr;\n\t\t\tif(now.any()){\t\t\n\t\t\t\tdpr[from][to] = 1;\n\t\t\t\tbeatr[to][from] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++) if(dpr[i][0] && dpl[i][n - 1]) ans++;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <time.h>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    //vector<vector<bool>> A(N, vector<bool>(N));\n    static bool A[2048][2048];\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\" %c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    //vector<vector<bool>> L(N, vector<bool>(N));\n    //vector<vector<bool>> R(N, vector<bool>(N));\n    static bool L[2048][2048];\n    static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                bool b = false;\n                for (int j=i+1; j<=i+d; j++)\n                    b |= A[i][j] & L[i+d][j] & R[i+1][j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                bool b = false;\n                for (int j=i-d; j<i; j++)\n                    b |= A[i][j] & L[i-1][j] & R[i-d][j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n    cout<<ans<<endl;\n\n    cerr<<(double)clock()/CLOCKS_PER_SEC<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target (\"avx\")\n\n#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cerr << *i << \" \"; cerr << endl; }\ntemplate <class T> void chmin(T &t, const T &f) { if (t > f) t = f; }\ntemplate <class T> void chmax(T &t, const T &f) { if (t < f) t = f; }\n\nconstexpr int MAX_N = 2005;\n\nint N;\nchar A[MAX_N][MAX_N];\n\n// bool B[MAX_N][MAX_N];\nbitset<MAX_N> B[MAX_N];\n\n// bool dp[MAX_N][MAX_N];\nbitset<MAX_N> dp[MAX_N], DP[MAX_N];\n\nint main() {\n  for (; ~scanf(\"%d\", &N); ) {\n    for (int i = 2; i <= N; ++i) {\n      scanf(\"%s\", A[i] + 1);\n    }\n    for (int i = 0; i <= N + 1; ++i) {\n      B[i].reset();\n    }\n    B[0][N + 1] = true;\n    B[N + 1][0] = false;\n    for (int i = 1; i <= N; ++i) {\n      B[0][i] = false;\n      B[i][0] = true;\n      B[N + 1][i] = false;\n      B[i][N + 1] = true;\n    }\n    for (int i = 1; i <= N; ++i) for (int j = 1; j < i; ++j) {\n      B[i][j] = (A[i][j] == '1');\n      B[j][i] = (A[i][j] == '0');\n    }\n    // memset(dp, 0, sizeof(dp));\n    for (int i = 0; i <= N + 1; ++i) {\n      dp[i].reset();\n      DP[i].reset();\n    }\n    for (int i = 0; i <= N; ++i) {\n      dp[i][i + 1] = true;\n      DP[i + 1][i] = true;\n    }\n    for (int w = 2; w <= N + 1; ++w) {\n      for (int i = 0; i <= N + 1 - w; ++i) {\n        const int j = i + w;\n        // for (int k = i + 1; k < j; ++k) {\n          // if ((B[i][k] || B[j][k]) && dp[i][k] && dp[k][j]) {\n            // dp[i][j] = true;\n            // break;\n          // }\n        // }\n        dp[i][j] = DP[j][i] = ((B[i] | B[j]) & dp[i] & DP[j]).any();\n      }\n    }\n// for(int i=0;i<=N+1;++i){for(int j=0;j<=N+1;++j){cout<<dp[i][j];}cout<<endl;}\n    int ans = 0;\n    for (int i = 1; i <= N; ++i) {\n      if (dp[0][i] && dp[i][N + 1]) {\n        ++ans;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        string t;\n        cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            A[i][j] = t[j]!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<bool>> L(N, vector<bool>(N));\n    vector<vector<bool>> R(N, vector<bool>(N));\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[i+d][j] && R[i+1][j])\n                        L[i+d][i] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[i-1][j] && R[i-d][j])\n                        R[i-d][i] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <ctype.h>\nusing namespace std;\n\nconst int MAXN = 2e3+10;\n\nbool a[MAXN][MAXN],dp[MAXN][MAXN];\n\ninline int read() {\n    int num=0, w=0;\n    char ch=0;\n    while (!isdigit(ch)) {\n        w|=ch=='-';\n        ch = getchar();\n    }\n    while (isdigit(ch)) {\n        num = (num<<3) + (num<<1) + (ch^48);\n        ch = getchar();\n    }\n    return w? -num: num;\n}\n\ninline void write(int x)\n{\n    if(x<0) {\n        putchar('-');\n        x = -x;\n    }\n    if(x>9) write(x / 10);\n    putchar(x % 10 + '0');\n}\n\nint main()\n{\n    int n = read();\n    for (int i = 2;i<=n;i++)\n    {\n        getchar();\n        for (int j = 1;j<i;j++)\n        {\n            a[j][i] = !(a[i][j] = getchar() - 48);\n        }\n        dp[i][i] = dp[i][i] = 1;\n    }\n    dp[1][1] = dp[1][1] = 1;\n    for (int k = 1;k<=n-1;k++)\n    {\n        for (int i = 1;i<=n-k;i++)\n        {\n            int flag = 0;\n            for (int j = i;j<=i+k;j++)\n            {\n                if (!dp[i][i+k] && j != i && a[i][j] && dp[j][i + k] && dp[j][i+1])\n                {\n                    dp[i][i+k] = 1;\n                    flag++;\n                }\n                if (!dp[i+k][i] && j != i + k && a[i+k][j] && dp[j][i+k-1] && dp[j][i])\n                {\n                    dp[i+k][i] = 1;\n                    flag++;\n                }\n                if (flag == 2) break;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1;i<=n;i++)\n    if (dp[i][n] && dp[i][1]) ans++;\n    write(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ], st[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind;\n\tind = st[l][l];\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = st[r][l];\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\tint start = clock();\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(wn[i].begin(), wn[i].end());\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint curInd = wn[i].size();\n\t\tfor (int j = n + 1; j >= 0; j--) {\n\t\t\tif (curInd != 0 && wn[i][curInd - 1] > j) curInd--;\n\t\t\tst[i][j] = curInd;\n\t\t}\n\t}\n\n\tll ans = 0;\n\t\n\tvector<ll> perm;\n\tfor (int i = 1; i <= n; i++) perm.push_back(i);\n\n\trandom_shuffle(perm.begin(), perm.end());\n\tfor (int i2 = 1; i2 <= n; i2++) {\n\t\tint end = clock();\n\t\tint t = (end - start);\n\t\tif (t >= 1000000) break;\n\t\tint i = perm[i2 - 1];\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    bitset<2020> A[2020];\n    for (int n = 1; n < N; ++n) {\n        string s;\n        cin >> s;\n        for (int m = 0; m < n; ++m) {\n            A[n][m] = s[m]-'0';\n        }\n    }\n    \n    bitset<2020> DP[2020];\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = 1;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            int j = i+d;\n            bool b = false;\n            for (int k = i+1; k <= j; ++k) {\n                b |= !A[k][i] & DP[k][i+1] & DP[k][j];\n            }\n            DP[i][j] = b;\n            \n            b = false;\n            for (int k = i; k < j; ++k) {\n                b |= A[j][k] & DP[k][i] & DP[k][j-1];\n            }\n            DP[j][i] = b;\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[n][0] & DP[n][N-1]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\nbitset<2005> st[MAX_N];\nbitset<2005> up[MAX_N];\n// i が j に勝つ\nbool win[MAX_N][MAX_N];\nint made[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    srep(i,1,n){\n        string s;\n        cin >> s;\n        rep(j,i){\n            win[i][j] = (s[j] == '1');\n            win[j][i] = !win[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            if(j == i) continue;\n            if(!win[i][j]) up[i][j] = 1;\n        }\n    }\n    rep(i,n){\n        made[i] = i;\n        do {\n            if(!win[i][made[i]-1]){\n                break;\n            }\n        }while(--made[i] > 0);\n    }\n    st[0][0] = 1;\n    srep(i,1,n){\n        bool flag = false;\n        rep(j,i){\n            if(st[i-1][j]){\n                if(win[i][j]){\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        if(flag){\n            st[i][i] = 1;\n        }\n        int lf = INF;\n        rrep(j,i){\n            if(win[i][j]){\n                cmn(lf, made[j]);\n                st[i] |= (st[j] & up[i]);\n            }else{\n                st[i] |= st[j];\n                if(lf > j){\n                    break;\n                }else{\n                    cmn(lf, made[j]);\n                }\n            }\n        }\n    }\n    cout << (int)st[n-1].count() << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar ch[2010][2010];\n\nint n;\n\nbool B[2010][2010];\n\nint Ans[2010][2010];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 2; i <= n; i++) scanf(\"%s\", ch[i] + 1);\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; j < i; j++)\n\t\t\t(B[i][j] = ch[i][j] - '0'), B[j][i] = !B[i][j];\n\tfor(int i = 1; i <= n; i++) Ans[i][i] = 1;\n\tfor(int i = 1; i < n; i++)\n\t\tif(B[i][i + 1]) Ans[i + 1][i] = 1; else Ans[i][i + 1] = 1;\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; i + j <= n; j++) {\n\t\t\tint l = j, r = i + j;\n\t\t\tfor(int k = l + 1; k <= r; k++) if(B[l][k] && Ans[l + 1][k] && Ans[r][k]) {Ans[r][l] = 1; break;}\n\t\t\tfor(int k = l; k < r; k++) if(B[r][k] && Ans[l][k] && Ans[r - 1][k]) {Ans[l][r] = 1; break;}\n\t\t}\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i++) tot += Ans[1][i] && Ans[n][i];\n\tprintf(\"%d\\n\", tot);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<bitset<2010>> v(n);\n    for (int i = 1; i < n; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < i; ++j) {\n            v[i][j] = s[j] == '1';\n            v[j][i] = s[j] == '0';\n        }\n    }\n    vector<bitset<2010>> vl(n);\n    vector<bool> islwin(n);\n    islwin[0] = true;\n    vl[0] = v[0];\n    for (int i = 1; i < n; ++i) {\n        vl[i] = v[i];\n        for (int j = 0; j < i; ++j) {\n            if (vl[i][j]) {\n                vl[i] |= vl[j];\n            }\n        }\n        bool ok = true;\n        for (int j = 0; j < i; ++j) {\n            if (!vl[i][j]) {\n                ok = false;\n            }\n        }\n        islwin[i] = ok;\n        for (int j = 0; j < i; ++j) {\n            if (vl[j][i]) {\n                vl[j] |= vl[i];\n            }\n        }\n    }\n    vector<bitset<2010>> vr(n);\n    vector<bool> isrwin(n);\n    isrwin[n - 1] = true;\n    vr[n - 1] = v[n - 1];\n    for (int i = n - 2; i >= 0; --i) {\n        vr[i] = v[i];\n        for (int j = i + 1; j < n; ++j) {\n            if (vr[i][j]) {\n                vr[i] |= vr[j];\n            }\n        }\n        bool ok = true;\n        for (int j = i + 1; j < n; ++j) {\n            if (!vr[i][j]) {\n                ok = false;\n            }\n        }\n        isrwin[i] = ok;\n        for (int j = i + 1; j < n; ++j) {\n            if (vr[j][i]) {\n                vr[j] |= vr[i];\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (islwin[i] && isrwin[i])  ++ans;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    int n;\n    cin >> n;\n    vs a(n-1);\n    rep(i, n-1) cin >> a[i];\n    vector<vector<bool>> win(n, vector<bool>(n));\n    rep1(i, n-1) rep(j, i) {\n        win[i][j] = (a[i-1][j] == '1');\n        win[j][i] = !(a[i-1][j] == '1');\n    }\n    vector<bitset<2005>> dpfl(n), dpfr(n), dpbl(n), dpbr(n);\n    rep(i, n) dpfl[i][i] = dpfr[i][i] = dpbl[i][i] = dpbr[i][i] = true;\n    rep1(i, n-1) rep(a, n-i) {\n        int b = a + i;\n        bool lok = false;\n        if ((dpfl[b]&dpbl[a]).any()) lok = true;\n        if (!lok && win[a][b]) {\n            if (((dpfr[b]>>1)&dpbl[a]).any()) lok = true;\n        }\n        dpfl[b][a] = dpbl[a][b] = lok;\n        bool rok = false;\n        if ((dpfr[b]&dpbr[a]).any()) rok = true;\n        if (!rok && win[b][a]) {\n            if (((dpfr[b]>>1)&dpbl[a]).any()) rok = true;\n        }\n        dpfr[b][a] = dpbr[a][b] = rok;\n    }\n    int ans = 0;\n    rep(i, n) if (dpbr[0][i] && dpfl[n-1][i]) ++ans;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef NON_SUBMIT\n#define TEST(n) (n)\n#define tout cerr\n#else\n#define TEST(n) ((void)0)\n#define tout cin\n#endif\n\nusing namespace std;\n\nint C[2000][2000], L[2000][2000], R[2000][2000];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\tTEST(freopen(\"input.txt\",\"r\",stdin));\n\tTEST(freopen(\"output.txt\",\"w\",stdout));\n\tTEST(freopen(\"debug.txt\",\"w\",stderr));\n\tint N, ans=0;\n\tcin>>N;\n\tfor(int i=1;i<N;i++) {\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<i;j++) {\n\t\t\tif(s[j]=='1') C[i][j]=1;\n\t\t\telse C[j][i]=1;\n\t\t}\n\t}\n\tL[0][0]=1;\n\tfor(int i=1;i<N;i++) {\n\t\tbool lose=false;\n\t\tfor(int j=0;j<i;j++) if(C[j][i]) lose=true;\n\t\tfor(int j=0;j<i;j++) if(L[i-1][j]) {\n\t\t\tif(lose) L[i][j]=1;\n\t\t\tif(C[j][i]) L[i][j]=1;\n\t\t\telse L[i][i]=1;\n\t\t}\n\t\tif(L[i][i]) for(int j=0;j<i;j++) if(!L[i-1][j] && C[j][i]) L[i][j]=1;\n\t}\n\tR[N-1][N-1]=1;\n\tfor(int i=N-2;i>=0;i--) {\n\t\tbool lose=false;\n\t\tfor(int j=N-1;j>i;j--) if(C[j][i]) lose=true;\n\t\tfor(int j=N-1;j>i;j--) if(R[i+1][j]) {\n\t\t\tif(lose) R[i][j]=1;\n\t\t\tif(C[j][i]) R[i][j]=1;\n\t\t\telse R[i][i]=1;\n\t\t}\n\t\tif(R[i][i]) for(int j=N-1;j>i;j--) if(!R[i+1][j] && C[j][i]) R[i][j]=1;\n\t}\n\tfor(int i=0;i<N;i++) if(L[i][i] && R[i][i]) ans++;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=2005;\nbitset<N> dpl[N],dpr[N],a[N];\nchar ss[N];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int u=2;u<=n;u++)\n\t{\n\t\tscanf(\"%s\",ss+1);\n\t\tfor(int i=1;i<u;i++)\n\t\t{\n            if(ss[i]=='1') a[u][i]=1;\n            else a[i][u]=1;\n        }\n\t}\n    for(int u=1;u<=n;u++) dpr[u][u]=1,dpl[u][u]=1;\n    for (int d=2;d<=n;d++)\n    {\n    \tfor (int l=1;l<=n;l++)\n    \t{\n    \t\tint r=l+d-1;\n    \t\tif (r>n) break;\n    \t\tif ((dpr[l]&a[r]&dpl[r-1]).count()) dpr[l][r]=1;\n    \t\tif ((dpl[r]&a[l]&dpr[l+1]).count()) dpl[r][l]=1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(dpr[1]&dpl[n]).count());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\nusing B = std::bitset<2010>;\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<B> a(n), dpl(n), dpr(n);\n    for (int i = 1; i < n; i++) {\n        std::string in;\n        std::cin >> in;\n        for (int j = 0; j < i; j++) {\n            if (in[j] == '1') a[i][j] = 1;\n            else a[j][i] = 1;\n        }\n    }\n    for (int i = 0; i < n; i++) dpl[i][i] = dpr[i][i] = 1;\n\n    for (int d = 1; d < n; d++) {\n        for (int i = 0; i + d < n; i++) {\n            if ((dpl[i + d] & dpr[i + 1] & a[i]).any()) dpl[i + d][i] = 1;\n            if ((dpl[i + d - 1] & dpr[i] & a[i + d]).any()) dpr[i][i + d] = 1;\n        }\n    }\n\n    std::cout << (dpl.back() & dpr.front()).count() << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2000+5;\nbitset<N> L[N],R[N],a[N];\nsigned main(){\n\tint n;char ch;\n\tcin>>n;\n\tfor(int i=2;i<=n;++i)\n\t\tfor(int j=1;j<i;++j){\n\t\t\tcin>>ch;\n\t\t\ta[i][j]=ch-'0';\n\t\t\ta[j][i]=(ch-'0')^1;\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tL[i][i]=R[i][i]=1;\n\tfor(int len=2;len<=n;++len)\n\t\tfor(int i=1;i+len-1<=n;++i){\n\t\t\tint j=i+len-1;\n\t\t\tL[j][i]=(L[j]&R[i+1]&a[i]).count()!=0;\n\t\t\tR[i][j]=(L[j-1]&R[i]&a[j]).count()!=0;\n\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tans+=(L[n][i] & R[i][n]);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 2005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\ntypedef bitset<2000> bs;\nint n;\nbs win[MAXN],twin[MAXN];\nint a[MAXN][MAXN];\nbs dpl[MAXN],dpr[MAXN],tdpl[MAXN],tdpr[MAXN];\nstring str;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        cin>>str;\n        for(int j=0;j<i;j++)\n        {\n            int x=str[j]-'0';\n            if(x) \n            {\n                win[i].set(j);\n                twin[j].set(i);\n            }\n            else \n            {\n                win[j].set(i);\n                twin[i].set(j);\n            }\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        dpl[i].set(i); dpr[i].set(i);\n        tdpl[i].set(i); tdpr[i].set(i);\n    }\n    for(int len=2;len<=n;len++)\n    {\n        for(int i=0;i<n;i++)\n        {\n            int j=i+len-1;\n            if((dpr[i+1]&tdpl[j]&win[i]).count())\n            {\n                dpl[i].set(j);\n                tdpl[j].set(i);\n            }\n            if((dpr[i]&tdpl[j-1]&win[j]).count())\n            {\n                dpr[i].set(j);\n                tdpr[j].set(i);\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++) if(dpl[i].test(n-1)&&dpr[0].test(i)) ans++;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\",\"unroll-loops\")\n#pragma GCC option(\"arch=native\")\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n \n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n \nint N;\nbool A[2010][2010];\nbool L[2010][2010];\nbool R[2010][2010];\n \nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tcin >> N;\n\t{\n\t\tV<string> s(N);\n\t\trep1(i,N-1) cin >> s[i];\n\t\trep(i,N) rep(j,N){\n\t\t\tif(i>j) A[i][j] = s[i][j]=='1';\n\t\t\tif(j>i) A[i][j] = s[j][i]=='0'; \n\t\t}\n\t}\n\tif(false){\n\t\trep(i,N){\n\t\t\trep(j,N) cout << A[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tfor(int d=1;d<=N;d++){\n\t\tfor(int l=0;l+d-1<N;l++){\n\t\t\tint r = l+d-1;\n\t\t\tif(d == 1){\n\t\t\t\tL[l][r] = true;\n\t\t\t\tR[l][r] = true;\n\t\t\t}else{\n\t\t\t\t{\t//L\n\t\t\t\t\tfor(int x=l+1;x<=r;x++){\n\t\t\t\t\t\tif(A[l][x] && R[l+1][x] && L[x][r]){\n\t\t\t\t\t\t\tL[l][r] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\t//R\n\t\t\t\t\tfor(int x=l;x<r;x++){\n\t\t\t\t\t\tif(A[r][x] && L[x][r-1] && R[l][x]){\n\t\t\t\t\t\t\tR[l][r] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i,N) if(R[0][i] && L[i][N-1]){\n\t\tans++;\n\t\tshow(i);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<bitset>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void write(int x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nbitset<2010>f[2010],g[2010],p[2010];\nchar ss[2010];\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n=read();\n    for(int i=2;i<=n;i++)\n    {\n    \tscanf(\"%s\",ss+1);\n    \tfor(int j=1;j<i;j++)\n    \t{\n    \t\tif(ss[j]=='0')p[j][i]=1;\n    \t\telse p[i][j]=1;\n    \t}\n    }\n    for(int i=1;i<=n;i++)f[i][i]=1,g[i][i]=1;\n    for(int d=2;d<=n;d++)\n    {\n    \tfor(int l=1;l+d-1<=n;l++)\n    \t{\n    \t\tint r=l+d-1;\n    \t\tg[r][l]=(g[r]&f[l+1]&p[l]).any();\n    \t\tf[l][r]=(f[l]&g[r-1]&p[r]).any();\n    \t}\n    }\n    pr2((g[n]&f[1]).count());\n    return 0;\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define sz(a) (int)a.size()\n#define x first\n#define y second\n#define debug(...) cout << \"[\" << #__VA_ARGS__ << \": \" << __VA_ARGS__ << \"]\\n\"\n#define rd() abs((int)rng())\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int>pii;\nconst int maxn = 2e3 + 100;\nconst int mod = 1e9 + 7;\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\nint n, wins[maxn][maxn];\nint dpl[maxn][maxn], dpr[maxn][maxn];\nint main()\n{\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 1; j <= sz(s); j++)\n\t\t{\n\t\t\tif(s[j - 1] == '0')\n\t\t\t{\n\t\t\t\twins[i][j] = 0;\n\t\t\t\twins[j][i] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twins[i][j] = 1;\n\t\t\t\twins[j][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tdpl[i][i] = dpr[i][i] = 1;\n\tfor(int len = 2; len <= n; len++)\n\t{\n\t\tfor(int i = len; i <= n; i++)\n\t\t{\n\t\t\tfor(int k = i - 1; k >= i - len + 1; k--)\n\t\t\t{\n\t\t\t\tif(wins[i][k] && dpl[k][i - len + 1] == 1)\n\t\t\t\t\tdpl[i][i - len + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = n - len + 1; i >= 1; i--)\n\t\t{\n\t\t\tfor(int k = i + 1; k <= i + len - 1; k++)\n\t\t\t{\n\t\t\t\tif(wins[i][k] && dpr[k][i + len - 1] == 1)\n\t\t\t\t\tdpr[i][i + len - 1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(dpl[i][1] && dpr[i][n])\n\t\t\t++ans;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  auto a = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a.at(i).at(j) = k;\n    a.at(j).at(i) = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  for (size_t i = 0; i <= n; i++) dp.at(i).at(i + 1) = dp.at(i + 1).at(i) = true;\n  for (size_t d = 2; d <= n + 1; d++) {\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      bool tmp = false;\n      for (size_t k = i + 1; k < j; k++) {\n        tmp |= dp.at(i).at(k) && dp.at(j).at(k) && (a.at(i).at(k) || a.at(j).at(k));\n      }\n      dp.at(j).at(i) = dp.at(i).at(j) = tmp;\n    }\n  }\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp.at(0).at(i) && dp.at(i).at(n + 1)) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ], st[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind;\n\tind = st[l][l];\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = st[r][l];\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\tint start = clock();\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(wn[i].begin(), wn[i].end());\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint curInd = wn[i].size();\n\t\tfor (int j = n + 1; j >= 0; j--) {\n\t\t\tif (curInd != 0 && wn[i][curInd - 1] > j) curInd--;\n\t\t\tst[i][j] = curInd;\n\t\t}\n\t}\n\n\tll ans = 0;\n\t\n\tvector<ll> perm;\n\tfor (int i = 1; i <= n; i++) perm.push_back(i);\n\n\trandom_shuffle(perm.begin(), perm.end());\n\tfor (int i2 = 1; i2 <= n; i2++) {\n\t\tint end = clock();\n\t\tint t = (end - start);\n\t\tif (t >= 1000000) break;\n\t\tint i = perm[i2];\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n#define coc g[node][i]\n#define mod 1000000007\n#define N 1000005\nusing namespace std;\n\ntypedef long long ll;\n\nint n, say, ans, u[N];\nvector < int > g[N];\nchar ch;\n\nvoid dfs(int node, int par){\n\tu[node] = 1;\n\tsay++;\n\tfor(int i = 0; i < g[node].size(); i++)\n\t\tif(!u[coc]){\n\t\t\tif(par < node and coc < par)\n\t\t\t\tcontinue;\n\t\t\tif(par > node and coc > par)\n\t\t\t\tcontinue;\n\t\t\tdfs(coc, node);\n\t\t}\n}\n\nint main() {\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i = 2; i <= n; i++){\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tscanf(\" %c\",&ch);\n\t\t\tif(ch == '1'){\n\t\t\t\tg[i].pb(j);\n\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg[j].pb(i);\n\t\t\t\t// cout << j << \" \" << i << endl;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tu[i] = 0;\n\t\tsay = 0;\n\t\tdfs(i, 0);\n\t\tans += say == n;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <time.h>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    //vector<vector<bool>> A(N, vector<bool>(N));\n    static bool A[2048][2048];\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\" %c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    //vector<vector<bool>> L(N, vector<bool>(N));\n    //vector<vector<bool>> R(N, vector<bool>(N));\n    static bool L[2048][2048];\n    static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<=i+d; j++)\n                    b |= a[j] & l[j] & r[j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i-d; j<i; j++)\n                    b |= a[j] & l[j] & r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n    cout<<ans<<endl;\n\n    cerr<<(double)clock()/CLOCKS_PER_SEC<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ], st[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind;\n\tind = st[l][l];\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = st[r][l];\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\tint start = clock();\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(wn[i].begin(), wn[i].end());\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint curInd = wn[i].size();\n\t\tfor (int j = n + 1; j >= 0; j--) {\n\t\t\tif (curInd != 0 && wn[i][curInd - 1] > j) curInd--;\n\t\t\tst[i][j] = curInd;\n\t\t}\n\t}\n\n\tll ans = 0;\n\t\n\tvector<ll> perm;\n\tfor (int i = 1; i <= n; i++) perm.push_back(i);\n\n\trandom_shuffle(perm.begin(), perm.end());\n\tfor (int i2 = 1; i2 <= n; i2++) {\n\t\tint end = clock();\n\t\tint t = (end - start);\n\t\tif (t >= 2000000) break;\n\t\tint i = perm[i2 - 1];\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 2000;\nbitset<N> dpl[N], dpr[N], all[N], alr[N], yay[N], win[N];\nchar s[N + 1];\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tf(i, 1, n){\n\t\tscanf(\"%s\", s);\n\t\tf(j, 0, i){\n\t\t\tint t = s[j] == '1';\n\t\t\twin[i][j] = t;\n\t\t\twin[j][i] = !t;\n\t\t}\n\t}\n\tf(i, 0, n)dpl[i][i] = true;\n\tf(i, 0, n)dpr[i][i] = true;\n\tf(i, 0, n)all[i][i] = true;\n\tf(i, 0, n)alr[i][i] = true;\n\tf(ln, 2, n + 1)f(i, 0, n - ln + 1){\n\t\tint j = i + ln - 1;\n\t\tyay[i][j] = yay[j][i] = (dpl[i] & (dpr[j] >> 1)).any();\n\t\tif ((win[i] & yay[i] & all[j]).any())dpl[i][j] = true, all[j][i] = true;\n\t\tif ((win[j] & yay[j] & alr[i]).any())dpr[j][i] = true, alr[i][j] = true;\n\t}\n\tint an = 0;\n\tf(i, 0, n)if (dpl[i][n - 1] && dpr[i][0])++an;\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nint A[2010][2010];\n\nint LW[2010][2010];\nint RW[2010][2010];\nint LK[2010][2010];\nint RK[2010][2010];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 1, N) {\n\t\tstring str; cin >> str;\n\t\trep(j, 0, i) {\n\t\t\tA[i][j] = (str[j] == '1');\n\t\t\tA[j][i] = A[i][j] ^ 1;\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tLW[i][i] = 1;\n\t\tRW[i][i] = 1;\n\t\tLK[i][i] = -1;\n\t\tRK[i][i] = -1;\n\t}\n\trep(l, 2, N + 1) {\n\t\trep(i, 0, N - l + 1) {\n\t\t\tint j = i + l - 1;\n\t\t\t// LK\n\t\t\tif(A[i][j] == 1) {\n\t\t\t\tif(LK[i][j - 1] == -1) LK[i][j] = j;\n\t\t\t\telse LK[i][j] = (A[j][LK[i][j - 1]] ? j : LK[i][j - 1]);\n\t\t\t}\n\t\t\telse LK[i][j] = LK[i][j - 1];\n\n\t\t\t// RK\n\t\t\tif(A[j][i] == 1) {\n\t\t\t\tif(RK[i + 1][j] == -1) RK[i][j] = i;\n\t\t\t\telse RK[i][j] = (A[i][RK[i + 1][j]] ? i : RK[i + 1][j]);\n\t\t\t}\n\t\t\telse RK[i][j] = RK[i + 1][j];\n\n\t\t\t// LW\n\t\t\tif(LK[i][j] != -1) {\n\t\t\t\tint at = LK[i][j];\n\t\t\t\tLW[i][j] = (RW[i + 1][at] & LW[at][j]);\n\t\t\t}\n\n\t\t\t// RW\n\t\t\tif(RK[i][j] != -1) {\n\t\t\t\tint at = RK[i][j];\n\t\t\t\t// debug(\"omo\", i, j, at);\n\t\t\t\tRW[i][j] = (RW[i][at] & LW[at][j - 1]);\n\t\t\t}\n\t\t\t// debug(i, j, LK[i][j], RK[i][j], LW[i][j], RW[i][j]);\n\t\t}\n\t}\n\tint res = 0;\n\trep(i, 0, N) {\n\t\tres += RW[0][i] & LW[i][N - 1];\n\t}\n\tcout << res << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2000;\nbitset<N> left_wins[N];\nbitset<N> right_wins[N];\nbitset<N> wins[N];\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (str[j] == '1') wins[i][j] = 1;\n\t\t\telse wins[j][i] = 1;\n\t\t}\n\t}\n\tfor (int b = 0; b < n; ++b) {\n\t\tright_wins[b][b] = 1;\n\t\tleft_wins[b][b] = 1;\n\t\tfor (int a = b-1; a >= 0; --a) {\n\t\t\tbitset<N> mask;\n\n\t\t\tmask = wins[b] & left_wins[a] & right_wins[b-1];\n\t\t\tif (mask.count() > 0) left_wins[a][b] = 1;\n\t\t\tmask = wins[a] & left_wins[a+1] & right_wins[b];\n\t\t\tif (mask.count() > 0) right_wins[b][a] = 1;\n\t\t}\n\t}\n\n\tbitset<N> res = left_wins[0] & right_wins[n-1];\n\tcout << res.count() << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nint N;\nbool A[2010][2010];\nbool L[2010][2010];\nbool R[2010][2010];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tcin >> N;\n\t{\n\t\tV<string> s(N);\n\t\trep1(i,N-1) cin >> s[i];\n\t\trep(i,N) rep(j,N){\n\t\t\tif(i>j) A[i][j] = s[i][j]=='1';\n\t\t\tif(j>i) A[i][j] = s[j][i]=='0'; \n\t\t}\n\t}\n\tif(false){\n\t\trep(i,N){\n\t\t\trep(j,N) cout << A[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tfor(int d=1;d<=N;d++){\n\t\tfor(int l=0;l+d-1<N;l++){\n\t\t\tint r = l+d-1;\n\t\t\tif(d == 1){\n\t\t\t\tL[l][r] = true;\n\t\t\t\tR[l][r] = true;\n\t\t\t}else{\n\t\t\t\t{\t//L\n\t\t\t\t\tfor(int x=l+1;x<=r;x++){\n\t\t\t\t\t\tif(A[l][x] && R[l+1][x] && L[x][r]){\n\t\t\t\t\t\t\tL[l][r] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\t//R\n\t\t\t\t\tfor(int x=l;x<r;x++){\n\t\t\t\t\t\tif(A[r][x] && L[x][r-1] && R[l][x]){\n\t\t\t\t\t\t\tR[l][r] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i,N) if(R[0][i] && L[i][N-1]){\n\t\tans++;\n\t\tshow(i);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n[m-solutions2019] F - Random Tournament\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n\nconst int MAX_N = 2000;\n\nint N;\nbitset<MAX_N> A[MAX_N];\n\nbitset<MAX_N> dpl[MAX_N], dpr[MAX_N];\n\nll solve() {\n    for (int i = 0; i < N; i++) {\n        dpl[i][i] = dpr[i][i] = true;\n    }\n    for (int l = 1; l < N; l++) {\n        for (int i = 0; i + l < N; i++) {\n            int j = i + l;\n            dpl[j][i] = (A[i] & dpl[j] & dpr[i + 1]).any();\n        }\n        for (int j = l; j < N; j++) {\n            int i = j - l;\n            dpr[i][j] = (A[j] & dpr[i] & dpl[j - 1]).any();\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < N; i++) {\n        if (dpr[0][i] && dpl[N - 1][i]) {\n            ans++;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cin >> N;\n    for (int i = 1; i < N; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < i; j++) {\n            A[i][j] = s[j] == '1';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000003;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nbool b[2000][2000];\n\nbool le[2000][2000], ri[2000][2000];\nvoid solve() {\n\tint n; cin >> n;\n\trep1(i, n - 1) {\n\t\trep(j, i) {\n\t\t\tchar t; cin >> t;\n\t\t\tif (t == '1') {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n)le[i][i] = ri[i][i] = true;\n\n\tint ans = 0;\n\tRep1(i, 2, n) {\n\t\trep(j, n - i + 1) {\n\t\t\tint l = j;\n\t\t\tint r = j + i - 1;\n\t\t\tbool fl = false, fr = false;\n\t\t\tRep1(k, l + 1, r) {\n\t\t\t\tfl |= b[l][k] && ri[l + 1][k] && le[k][r];\n\t\t\t}\n\t\t\tRep(k, l, r) {\n\t\t\t\tfr |= b[r][k] && ri[l][k] && le[k][r - 1];\n\t\t\t}\n\t\t\tle[l][r] = fl, ri[l][r] = fr;\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (ri[0][i] && le[i][n - 1])ans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\nconst int MAX = 2e3 + 41;\n//const int MAX = 10;\n\nint n;\nbitset<MAX> pref[MAX], suf[MAX], win[MAX];\nint a[MAX][MAX];\n\nvoid solve () {\n\tfi(0, n - 1) {\n\t\tfj(0, n - 1) {\n\t\t\tif (a[i][j]) win[i].set(j);\n\t\t}\n\t}\n//\tdbg(win[0]);\n\tfi(0, n - 1) {\n\t\tpref[i].set(i);\n\t\tsuf[i].set(i);\t\t\t\t\t\t\n\t\tfdj(i - 1, 0) {\n\t\t\tif (a[i][j]) {\t\t\t\t\n\t\t\t\tif ( ( (suf[j] << 1) & pref[i]).count() ) {\n\t\t\t\t\tpref[i] |= pref[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbitset<MAX> sufwin;\n\t\tsufwin.reset();\n\t\tsufwin.set(i);\n\t\tfdj(i - 1, 0) {\n\t\t\tif ( ((suf[j] << 1) & sufwin & win[j]).count() ) {\n\t\t\t\tsufwin.set(j);\n\t\t\t\tsuf[j].set(i);\n\t\t\t}\n\t\t}\n/*\n\t\tfj(0, i) {\n\t\t\tdbg(pref[j]);\n\t\t\tdbg(suf[j]);\n\t\t}\n\t\terr(\"after i = %d\\n\", i);\n*/\n\t}\n\tvi answer;\n\tfi(0, n - 1) {\n\t\tif (pref[i].test(0) && suf[i].test(n - 1)) {\n\t\t\tanswer.pb(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sz(answer));\n//\tdbg(answer);\t\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\t\n\tscanf(\"%d\", &n);\n\tfi(0, n - 1) {\n\t\tfj(0, i - 1) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\ta[j][i] = 1 - a[i][j];\n\t\t}\n\t}\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\n\nstruct P\n{\n\tint A, B;\n\tP(int a, int b) : A(a), B(b) {}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<bool> m(N * N);\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor (int j = 0; j < i; j++) m[N * j + i] = !(m[N * i + j] = S[j] == '1');\n\t}\n\tvector<int> strong, weak, normal;\n\tvector<bool> isnormal(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tint c = 0;\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (m[N * i + j]) c++;\n\t\tif (c == N - 1)\n\t\t\tstrong.push_back(i);\n\t\telse if (c == 0)\n\t\t\tweak.push_back(i);\n\t\telse\n\t\t\tnormal.push_back(i);\n\t\tisnormal[i] = c > 0;\n\t}\n\tif (strong.size())\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tint M = normal.size();\n\tvector<bool> newm(M * M);\n\tfor (int i = 0; i < M; i++)\n\t\tfor (int j = 0; j < M; j++) newm[M * i + j] = m[N * normal[i] + normal[j]];\n\tN = M;\n\tm = newm;\n\tdeque<bool> dp(N * N, false);\n\tfor (int i = 0; i < N - 1; i++) dp[N * i + i + 1] = true;\n\tfor (int l = 2; l < N; l++)\n\t\tfor (int i = 0; i + l < N; i++)\n\t\t{\n\t\t\tint p = N * i + i + l;\n\t\t\tfor (int k = i + 1, q = N * i + k, r = N * (i + l) + k, s = N * k + i + l; k < i + l; k++, q++, r++, s += N)\n\t\t\t\tdp[p] |= dp[q] & (m[q] | m[r]) & dp[s];\n\t\t}\n\tdeque<bool> dpL(N, false);\n\tdpL[N - 1] = true;\n\tfor (int i = N - 2; i >= 0; i--)\n\t\tfor (int j = i + 1; j < N; j++) dpL[i] |= m[N * i + j] & dpL[j] & dp[N * i + j];\n\tdeque<bool> dpR(N, false);\n\tdpR[0] = true;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 0; j < i; j++) dpR[i] |= m[N * i + j] & dpR[j] & dp[N * j + i];\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tif (dpL[i] & dpR[i]) ans++;\n\tcout << ans << endl;\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\nconst int MAX = 2e3 + 41;\n//const int MAX = 10;\n\nint n;\nbitset<MAX> pref[MAX], suf[MAX], win[MAX];\nint a[MAX][MAX];\n\nvoid solve () {\n\tfi(0, n - 1) {\n\t\tfj(0, n - 1) {\n\t\t\tif (a[i][j]) win[i].set(j);\n\t\t}\n\t}\n//\tdbg(win[0]);\n\tfi(0, n - 1) {\n\t\tpref[i].set(i);\n\t\tsuf[i].set(i);\t\t\t\t\t\t\n\t\tfdj(i - 1, 0) {\n\t\t\tif (a[i][j]) {\t\t\t\t\n\t\t\t\tif ( ( (suf[j] << 1) & pref[i]).count() ) {\n\t\t\t\t\tpref[i] |= pref[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbitset<MAX> sufwin;\n\t\tsufwin.reset();\n\t\tsufwin.set(i);\n\t\tfdj(i - 1, 0) {\n\t\t\tif ( ((suf[j] << 1) & sufwin & win[j]).count() ) {\n\t\t\t\tsufwin.set(j);\n\t\t\t\tsuf[j].set(i);\n\t\t\t}\n\t\t}\n/*\n\t\tfj(0, i) {\n\t\t\tdbg(pref[j]);\n\t\t\tdbg(suf[j]);\n\t\t}\n\t\terr(\"after i = %d\\n\", i);\n*/\n\t}\n\tvi answer;\n\tfi(0, n - 1) {\n\t\tif (pref[i].test(0) && suf[i].test(n - 1)) {\n\t\t\tanswer.pb(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sz(answer));\n//\tdbg(answer);\t\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\t\n\tscanf(\"%d\", &n);\n\tfi(1, n - 1) {\n\t\tchar str[MAX];\n\t\tscanf(\"%s\", str);\n\t\tfj(0, i - 1) {\t\t\t\n\t\t\ta[i][j] = str[j] - '0';\n\t\t\ta[j][i] = 1 - a[i][j];\n\t\t}\n\t}\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tfor (int i = l + 1; i < r; i++) {\n\t\tif ((l > 0 && grid[l - 1][i - 1]) || grid[r - 1][i - 1]) {\n\t\t\tbool fl1 = find(l, i);\n\t\t\tif (fl1) {\n\t\t\t\tif (find(i, r)) {\n\t\t\t\t\tsv[l][r] = 1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nbitset<2000> a[2000];\nint nx[2000][2001];\nbitset<2000> e[2111000];\nbitset<2000> *d[2000][2000];\nchar s[2222];\nbitset<2000> pref[2001];\n\nint solve(int from, int to, int ind) {\n    if (ind > from) {\n        bool ok = false;\n        if (((a[ind] >> from) & (*d[from][ind - 1])).any()) {\n            ok = true;\n        }\n        if (!ok) {\n            for (int i = nx[ind][from]; i < ind; i = nx[ind][i + 1]) {\n                if (solve(from, ind - 1, i)) {\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            return 0;\n        }\n    }\n    if (ind < to) {\n        bool ok = false;\n        if (((a[ind] >> (ind + 1)) & (*d[ind + 1][to])).any()) {\n            ok = true;\n        }\n        if (!ok) {\n            for (int i = nx[ind][ind + 1]; i <= to; i = nx[ind][i + 1]) {\n                if (solve(ind + 1, to, i)) {\n                    ok = true;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            return 0;\n        }\n    }\n    d[from][to]->set(ind - from);\n    return 1;\n}\n\nint main() {\n//    freopen(\"input.txt\", \"r\", stdin);\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        scanf(\"%s\", s);\n        forn(j, i) {\n            if (s[j] == '1') {\n                a[i].set(j);\n            } else {\n                a[j].set(i);\n            }\n        }\n    }\n    forn(i, n) {\n        nx[i][n] = n;\n        for (int j = n - 1; j >= 0; --j) {\n            nx[i][j] = nx[i][j + 1];\n            if (a[i].test(j)) {\n                nx[i][j] = j;\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        pref[i] = pref[i - 1];\n        pref[i].set(i - 1);\n    }\n    int ind = 0;\n    forn(i, n) for (int j = i; j < n; ++j) {\n        d[i][j] = e + ind;\n        ind++;\n    }\n    forn(i, n) {\n        d[i][i]->set(0);\n    }\n    int ans = 0;\n    forn(i, n) {\n        ans += solve(0, n - 1, i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  auto a = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a[i][j] = k;\n    a[j][i] = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::vector<int>>(n + 2, std::vector<int>(n + 2, false));\n  for (size_t i = 0; i <= n; i++) dp[i][i + 1] = dp[i + 1][i] = true;\n  for (size_t d = 2; d <= n + 1; d++) {\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      bool tmp = false;\n      for (size_t k = i + 1; k < j; k++) {\n        tmp |= dp[i][k] & dp[j][k] & (a[i][k] | a[j][k]);\n      }\n      dp[j][i] = dp[i][j] = tmp;\n    }\n  }\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp[0][i] & dp[i][n + 1]) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main() {\n\tint n;\n\tcin>>n;\n\tfor(int cnt=0; cnt<n; cnt++) {\n\t\tint a[cnt+1][cnt+1];\n\t\tfor(int cnt2=0; cnt2<=cnt; cnt2++)\n\t\t\tcin>>a[cnt][cnt2];\n\t}\n\tcout<<(n+1)/2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    bool A[2020][2020];\n    for (int n = 1; n < N; ++n) {\n        string s;\n        cin >> s;\n        for (int m = 0; m < n; ++m) {\n            A[n][m] = s[m] == '1';\n        }\n    }\n    \n    bool DP[2020][2020];\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = true;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            int j = i+d;\n            bool b = false;\n            for (int k = i+1; k <= j; ++k) {\n                b |= !A[k][i] & DP[k][i+1] & DP[k][j];\n            }\n            DP[i][j] = b;\n            \n            b = false;\n            for (int k = i; k < j; ++k) {\n                b |= A[j][k] & DP[k][i] & DP[k][j-1];\n            }\n            DP[j][i] = b;\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[n][0] & DP[n][N-1]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ninline void rd(int &x)\n{\n\tx=0;char k=getchar();int s=1;\n\twhile(k>'9'||k<'0'){if(k=='-')s=-1;k=getchar();}\n\twhile(k<='9'&&k>='0')x=x*10+k-48,k=getchar();x*=s;\n}\nconst int N=2010,M=300;\nchar ch[N];\nint n,m,a[N][N],ans[N],sy[N];\nint fd(int x)\n{\n\treturn (sy[x]==x)?x:(sy[x]=fd(sy[x]));\n}\nvoid work()\n{set<int>s;s.clear();\n\tint u=n-1;\n\tfor(int i=1;i<=n;i++)s.insert(i);\n\twhile(u--)\n\t{\n\t\tint x=rand()%n+1,y;\n\t\tx=*s.lower_bound(x),y=*s.upper_bound(x);\n\t\tif(x==y){x=*--s.lower_bound(y);}\n\t\tif(a[x][y])s.erase(*s.lower_bound(y));\n\t\telse s.erase(*s.lower_bound(x));}\n\tint x=*s.lower_bound(-1);cout<<x<<endl;\n\tans[x]=1;\n}\nint main()\n{\n\t//srand(time(0));\n\trd(n);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",ch+1);\n\t\tfor(int j=1;j<i;j++)a[i][j]=ch[j]-'0',a[j][i]=a[i][j]^1;\n\t}//for(int i=1;i<=n;i++)a[i][i]=0;\n\t//for(int i=1;i<=n;i++)\n\t//{for(int j=1;j<=n;j++)cout<<a[i][j]<<\" \";cout<<endl;}\n\tm=M;\n\twhile(m--)work();int anss=0;\n\tfor(int i=1;i<=n;i++)anss+=ans[i];//,cout<<ans[i]<<\" \";\n\tcout<<anss;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n//long long int N,M,K,L,R,H,W;\n\n//const long long int MOD=1000000007;\nconst long long int MOD=998244353;\n\nint main(){\n\t\n\tcin>>N;\n\tvector<bitset<2000>>v(N);\n\tfor(int i=1;i<N;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(s[j]=='1')v[i].flip(j);\n\t\t\telse v[j].flip(i);\n\t\t}\n\t}\n\tvector<bitset<2000>>l(N);\n\tvector<bitset<2000>>r(N);\n\tfor(int i=0;i<N;i++){\n\t\tl[i].flip(i);\n\t\tr[i].flip(i);\n\t}\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;i+j<N;j++){\n\t\t\tfor(int k=j+1;k<=i+j;k++){\n\t\t\t\tif(l[k].test(i+j)&&r[j+1].test(k)&&v[j].test(k)){\n\t\t\t\t\tl[j].flip(i+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=j;k<i+j;k++){\n\t\t\t\tif(l[k].test(i+j-1)&&r[j].test(k)&&v[i+j].test(k)){\n\t\t\t\t\tr[j].flip(i+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(r[0].test(i)&&l[i].test(N-1)){\n\t\t\tans++;\n\t\t\tcerr<<i<<endl;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int MAX = 2020;\nbool a[MAX][MAX]={};\nbool dpL[MAX][MAX]={};\nbool dpR[MAX][MAX]={};\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    dpL[i][i]=dpR[i][i]=1; \n\n  for(int w=2;w<=n;w++){\n    for(int i=0;i+w<=n;i++){\n      int l=i,r=i+w-1;\n      for(int k=l+1;k<=r;k++)\n        dpL[r][l]|=dpR[l+1][k]&dpL[r][k]&a[l][k];\n\n      for(int k=l;k<r;k++)\n        dpR[l][r]|=dpR[l][k]&dpL[r-1][k]&a[r][k];      \n    }\n  }\n  \n  int ans=0;\n  for(int i=0;i<n;i++)\n    if(dpR[0][i]&dpL[n-1][i]) ans++;  \n  cout<<ans<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V< bitset<2000> > a(n);\n  for (int i = 1; i < n; ++i) {\n    string s; cin >> s;\n    for (int j = 0; j < i; ++j) {\n      a[i][j] = s[j] == '1';\n      a[j][i] = s[j] == '0';\n    }\n  }\n  V< bitset<2000> > dp(n);\n  for (int i = 0; i < n; ++i) {\n    dp[i][i] = true;\n    if (i) dp[i][i - 1] = a[i][i - 1];\n    if (i + 1 < n) dp[i][i + 1] = a[i][i + 1];\n  }\n  for (int w = 2; w < n; ++w) {\n    for (int i = 0; i < n; ++i) {\n      int j = i + w;\n      if (j < n) {\n        for (int k = i + 1; k <= j; ++k) if (a[i][k] and dp[k][i + 1] and dp[k][j]) {\n          dp[i][j] = true;\n          break;\n        }\n      }\n      j = i - w;\n      if (j >= 0) {\n        for (int k = i - 1; k >= j; --k) if (a[i][k] and dp[k][i - 1] and dp[k][j]) {\n          dp[i][j] = true;\n          break;\n        }\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n; ++i) res += dp[i][0] and dp[i][n - 1];\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1000000000000037 ;\nconst ll base = 127;\nusing ld=bool;\n\nld prob[2020][2020];\nint dpl[2020],dpr[2020];\ninline bool chmax(int& x,int y){\n    if(x<y){\n        x=y;return true;\n    }\n    return false;\n}\ninline bool chmin(int& x,int y){\n    if(x>y){\n        x=y;return true;\n    }\n    return false;\n}\nint main(){\n    int n;\n    cin>>n;\n    string s[n-1];\n    rep(i,n-1){\n        cin>>s[i];\n        rep(j,i+1){\n            if(s[i][j]=='1')prob[i+1][j]=1,prob[j][i+1]=0;\n            else prob[i+1][j]=0,prob[j][i+1]=1;\n        }\n    }\n    rep(i,n)prob[i][i]=1;\n    rep(i,n)dpl[i]=dpr[i]=i;\n    int idx=0;\n    while(1){\n        bool update=false;\n        int ma=1<<idx;\n        for(int i=n-1;i>=0;--i){\n            for(int j=i+1;j<n;j++){\n                if(prob[i][j]&&dpr[i]+1>=dpl[j]){\n                    update|=chmax(dpr[i],dpr[j]);\n                    if(dpr[i]>i+ma)dpr[i]=i+ma;\n                }\n            }\n        }\n        for(int i=0;i<n;++i){\n            for(int j=i-1;j>=0;--j){\n                if(prob[i][j]&&dpl[i]<=dpr[j]+1&&dpr[j]<i){\n                    update|=chmin(dpl[i],dpl[j]);\n                    if(dpl[i]<i-ma)dpl[i]=i-ma;\n                }\n            }\n        }\n        if(!update)break;\n        ++idx;\n    }\n    int ans=0;\n    rep(i,n)ans+=(dpl[i]==0&&dpr[i]==n-1);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <array>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\n#ifndef __GNUG__\nint __builtin_popcount(int n) {\n\tint x = 0;\n\twhile (n)n -= n&(-n), x++;\n\treturn x;\n}\n#endif\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000003;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 2000, M = 32;\n\nchar b[N];\nuint64_t db[N][M], eb[N][M], a[N][M], foo[M];\n\ninline void Set(uint64_t A[], int i) {\n\tA[i >> 6] |= 1LL << (i & 63);\n}\nuint64_t Get(uint64_t A[], int i) {\n\treturn A[i >> 6] & 1LL << (i & 63);\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n; ni(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%s\", b);\n\t\tF(j, i) {\n\t\t\tif (b[j] == '1')Set(a[i], j);\n\t\t\telse Set(a[j], i);\n\t\t}\n\t}\n\tfor (int i = n; i--;) for (int j = i; j < n; j++) {\n\t\tif (i == j) {\n\t\t\tSet(db[i], i);\n\t\t\tSet(eb[i], i);\n\t\t\tcontinue;\n\t\t}\n\t\tbool good = false;\n\t\tF(k, M) {\n\t\t\tif (a[i][k] & db[j][k] & eb[i + 1][k]) {\n\t\t\t\tgood = true; break;\n\t\t\t}\n\t\t}\n\t\tif (good)Set(db[j], i);\n\t\tgood = false;\n\t\tF(k, M) {\n\t\t\tif (a[j][k] & db[j - 1][k] & eb[i][k]) {\n\t\t\t\tgood = true; break;\n\t\t\t}\n\t\t}\n\t\tif (good)Set(eb[i], j);\n\t}\n\tint ans = 0;\n\tF(i, n) {\n\t\tif (Get(eb[0], i) && Get(db[n - 1], i))ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    bool A[2020][2020];\n    for (int n = 1; n < N; ++n) {\n        string s;\n        cin >> s;\n        for (int m = 0; m < n; ++m) {\n            A[n][m] = s[m] == '1';\n        }\n    }\n    \n    bool DP[2020][2020];\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = 1;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            for (int k = i+1; k <= i+d; ++k) {\n                bool b = !A[k][i] && DP[k][i+1] && DP[k][i+d];\n                if (b) {\n                    DP[i][i+d] = true;\n                    break;\n                }\n            }\n            for (int k = i; k < i+d; ++k) {\n                bool b = A[i+d][k] && DP[k][i] && DP[k][i+d-1];\n                if (b) {\n                    DP[i+d][i] = true;\n                    break;\n                }\n            }\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[n][0] && DP[n][N-1]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\nusing namespace std;\n\nint N;\nbitset<2009> A[2009];\nbitset<2009> dp[2009];\nbitset<2009> kl[2009], kr[2009];\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '1') { A[i].set(j); A[j].reset(i); }\n\t\t\telse { A[i].reset(j); A[j].set(i); }\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) { dp[i].set(i); }\n\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 0; j < i; j++) kl[i].set(j);\n\t}\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = i; j < N; j++) kr[i].set(j);\n\t}\n\n\tfor (int i = 1; i < N; i++) {\n\t\tfor (int j = 0; j < N - i; j++) {\n\t\t\tint cl = j, cr = j + i;\n\n\t\t\t// dp[cl][cr]\n\t\t\tbitset<2009> G1 = (dp[cl + 1] & (dp[cr] & (A[cl] & (kr[cl + 1] & kl[cr + 1]))));\n\t\t\tif (G1.count() >= 1) { dp[cr][cl] = 1; }\n\n\t\t\t// dp[cr][cl]\n\t\t\tbitset<2009> G2 = (dp[cl] & (dp[cr - 1] & (A[cr] & (kr[cl] & kl[cr]))));\n\t\t\tif (G2.count() >= 1) { dp[cl][cr] = 1; }\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (dp[0][i] == 1 && dp[N - 1][i] == 1) ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\n#include <bitset>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n#define MAX_N   (2000)\nchar szInput[MAX_N + 1];\nstatic bitset<MAX_N + 1> s_abitMatchTbl[MAX_N + 1];\n\nint main(void)\n{\n    SDWORD lInput_n = inputSDWORD();\n    for (SDWORD lIdxI = 2; lIdxI <= lInput_n; lIdxI++) {\n        inputString(szInput);\n        for (SDWORD lIdxJ = 1; lIdxJ < lIdxI; lIdxJ++) {\n            if ('1' == szInput[lIdxJ - 1]) {\n                s_abitMatchTbl[lIdxI][lIdxJ] = true;\n            } else {\n                s_abitMatchTbl[lIdxJ][lIdxI] = true;\n            }\n        }\n    }\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalMatchTbl[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    static bitset<MAX_N + 1> s_absDpL[MAX_N+1];\n    static bitset<MAX_N + 1> s_absDpR[MAX_N+1];\n\n    for (SDWORD lUpdateWidth = 0; lUpdateWidth <= lInput_n; lUpdateWidth++) {\n        for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n - lUpdateWidth; lUpdIdxL++) {\n            SDWORD lUpdIdxR = lUpdIdxL + lUpdateWidth;\n            if (lUpdIdxL == lUpdIdxR) {\n                s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n            } else {\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A1: [%d, <%d> %d], %d %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalMatchTbl[lUpdIdxL][lUpdIdxR],\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM+1][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_abitMatchTbl[lUpdIdxL][lUpdIdxR])\n                        && (1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpR[lUpdIdxM+1][lUpdIdxR])) {\n                        s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n                for (SDWORD lUpdIdxM = lUpdIdxL + 1; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update A2: [%d, <%d> %d], %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpL[lUpdIdxM][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpL[lUpdIdxM][lUpdIdxR])) {\n                        s_absDpL[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n\n                for (SDWORD lUpdIdxM = lUpdIdxL; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update B1: [%d, <%d> %d], %d %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalMatchTbl[lUpdIdxR][lUpdIdxL],\n                            s_aalDpL[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM+1][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_abitMatchTbl[lUpdIdxR][lUpdIdxL])\n                        && (1 == s_absDpL[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpR[lUpdIdxM+1][lUpdIdxR])) {\n                        s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n                for (SDWORD lUpdIdxM = lUpdIdxL + 1; lUpdIdxM < lUpdIdxR; lUpdIdxM++) {\n#if 0\n                    printf(\"update B2: [%d, <%d> %d], %d %d\\n\", \n                            lUpdIdxL, lUpdIdxM, lUpdIdxR,\n                            s_aalDpR[lUpdIdxL][lUpdIdxM],\n                            s_aalDpR[lUpdIdxM][lUpdIdxR]);\n#endif\n\n                    if ((1 == s_absDpR[lUpdIdxL][lUpdIdxM])\n                        && (1 == s_absDpR[lUpdIdxM][lUpdIdxR])) {\n                        s_absDpR[lUpdIdxL][lUpdIdxR] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n#if 0\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpL[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n    for (SDWORD lUpdIdxL = 1; lUpdIdxL <= lInput_n; lUpdIdxL++) {\n        for (SDWORD lUpdIdxR = 1; lUpdIdxR <= lInput_n; lUpdIdxR++) {\n            printf(\"%d \", s_aalDpR[lUpdIdxL][lUpdIdxR]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    /* count winners */\n    SDWORD lAns = 0;\n    for (SDWORD lMid = 1; lMid <= lInput_n; lMid++) {\n        if (s_absDpR[1][lMid] && s_absDpL[lMid][lInput_n]) {\n            lAns++;\n        }\n    }\n\n    printf(\"%d\\n\", lAns);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MX 2099\n\nusing namespace std;\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n;\nbitset<MX> mat[MX];\nchar str[MX];\nbitset<MX> f[2][MX];\n\nint main()\n{\n\tread(n);\n\tfor(int i=2; i<=n; i++)\n\t{\n\t\tscanf(\"%s\", str+1);\n\t\tfor(int j=1; j<i; j++)\n\t\t{\n\t\t\tmat[i][j] = str[j] - '0';\n\t\t\tmat[j][i] = !(str[j] - '0');\n\t\t}\n\t}\n\tint now = 0;\n\tfor(int i=1; i<=n; i++) f[now][i][i] = 1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tmemset(f[now^1], 0, sizeof(f[now^1]));\n\t\tfor(int l=1; l+i-1<=n; l++)\n\t\t{\n\t\t\tint r = l+i-1;\n\t\t\tif(r+1 <= n)\n\t\t\t{\n\t\t\t\tif((f[now][l] & mat[r+1]).count()) f[now^1][l].set(r+1);\n\t\t\t\tf[now^1][l] |= f[now][l] & (~mat[r+1]);\n\t\t\t}\n\t\t\tif(l-1 >= 1)\n\t\t\t{\n\t\t\t\tif((f[now][l] & mat[l-1]).count()) f[now^1][l-1].set(l-1);\n\t\t\t\tf[now^1][l-1] |= f[now][l] & (~mat[l-1]);\n\t\t\t}\n\t\t}\n\t\tnow ^= 1;\n\t}\n\tprintf(\"%d\\n\", f[now][1].count());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n//long long int N,M,K,L,R,H,W;\n\n//const long long int MOD=1000000007;\nconst long long int MOD=998244353;\n\nint main(){\n\t\n\tcin>>N;\n\tvector<bitset<2000>>v(N);\n\tfor(int i=1;i<N;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(s[j]=='1')v[i].flip(j);\n\t\t\telse v[j].flip(i);\n\t\t}\n\t}\n\tvector<bitset<2000>>l(N);\n\tvector<bitset<2000>>r(N);\n\tfor(int i=0;i<N;i++){\n\t\tl[i].flip(i);\n\t\tr[i].flip(i);\n\t}\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;i+j<N;j++){\n\t\t\tl[i+j][j]=(l[i+j]&r[j+1]&v[j]).any();\n\t\t\tr[j][i+j]=(l[i+j-1]&r[j]&v[i+j]).any();\n\t\t}\n\t}\n\tint ans=(r[0]&l[N-1]).count();\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        string t;\n        cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            A[i][j] = t[j]!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    vector<vector<bool>> L(N, vector<bool>(N));\n    vector<vector<bool>> R(N, vector<bool>(N));\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N && !L[i+d][i]; j++)\n                    if (A[i][j] && L[i+d][j] && R[i+1][j])\n                        L[i+d][i] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i && !R[i-d][i]; j++)\n                    if (A[i][j] && L[i-1][j] && R[i-d][j])\n                        R[i-d][i] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\nusing namespace std;\n#define N 2002\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n;\nchar s[N];\nbitset<N> dpL[N],dpR[N],a[N];\nint main(){\n\tn=read();\n\tfor(int i=2;i<=n;++i){\n\t\tscanf(\"%s\",s+1);\n\t\tfor(int j=1;j<i;++j){\n\t\t\ta[i][j]=s[j]-'0';\n\t\t\ta[j][i]=a[i][j]^1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tdpL[i][i]=dpR[i][i]=1;\n\t}\n\tfor(int len=2;len<=n;++len){\n\t\tfor(int l=1;l+len-1<=n;++l){\n\t\t\tint r=l+len-1;\n\t\t\tif((a[l]&dpR[l+1]&dpL[r]).any())dpL[r][l]=1;\n\t\t\tif((a[r]&dpR[l]&dpL[r-1]).any())dpR[l][r]=1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(int)(dpL[n]&dpR[1]).count());\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\nusing namespace std;\n\nint win[2000][2000];\nbitset<30> dpL[2000],dpR[2000];\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // cout << fixed << setprecision(20);\n    int n;cin >> n;\n    win[0][0] = 1;\n    for(int i = 1;i < n;i++){\n        win[i][i] = 1;\n        string s;cin >> s;\n        REP(j,i){\n            win[i][j] = (s[j] == '1');\n            win[j][i] = !win[i][j];\n        }\n    }\n    //REP(i,n){\n    //    REP(j,n)cout << win[i][j] << ' ';\n    //    cout << '\\n';\n    //}\n    for(int i = 0;i < n;i++){\n        dpL[i][i] = dpR[i][i] = true;\n    }\n    for(int d = 1;d < n;d++){\n        for(int i = 0;i + d < n;i++){\n            for(int j = i+1;j <= i+d;j++){\n                dpL[i][i+d] = dpL[i][i+d] | (win[i][j] & dpL[j][i+d] & dpR[j][i+1]);\n            }\n        }\n        for(int i = n-1;i - d >= 0;i--){\n            for(int j = i-1;j >= i-d;j--){\n                dpR[i][i-d] = dpR[i][i-d] | (win[i][j] & dpR[j][i-d] & dpL[j][i-1]);\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0;i < n;i++){\n       // cout << dpR[i] << '\\n';\n        if(dpR[i][0] & dpL[i][n-1])ans++;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\n\nint n;\nchar p[2000][2000];\nint w[2000][2000], Right[2000], Left[2000], TLeft[2000];\nbitset<2000>B[2000], U, RR[2000];\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%s\", p[i]);\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (p[i][j] == '1') {\n\t\t\t\tw[i][j] = 1;\n\t\t\t}\n\t\t\telse w[j][i] = 1;\n\t\t}\n\t}\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tRR[i][i] = 1;\n\t\tif (i == n - 1) {\n\t\t\tRight[i] = 1;\n\t\t\tLeft[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tLeft[i] = 1;\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (w[i][j] && Right[j] && Left[j]) {\n\t\t\t\tRight[i] = 1;\n\t\t\t}\n\t\t\tif (w[i][j]) {\n\t\t\t\tRR[i] |= RR[j];\n\t\t\t}\n\t\t}\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (RR[i][j - 1] && w[j][i]) B[j][i] = 1;\n\t\t}\n\t\tU.reset();\n\t\tU[i] = 1;\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif ((U & B[j]).count()) {\n\t\t\t\tLeft[j] = 1;\n\t\t\t\tU[j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLeft[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (Right[i] && Left[i])res++;\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 11);\n\nint n;\nbitset<MAXN> A[MAXN];\n\nvoid read()\n{\n\tcin >> n;\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 1; j < i; j++)\n\t\t{\n\t\t\tint x = s[j - 1] - '0';\n\t\t\tA[j][i] = x ^ 1;\n\t\t\tA[i][j] = x;\n\t\t}\n\t}\n}\n\nbitset<MAXN> lft[MAXN];\nbitset<MAXN> rgh[MAXN];\nbitset<MAXN> winners[MAXN][MAXN];\n\nvoid solve()\n{\n\tfor(int i = 1; i <= n; i++)\n\t\tlft[i][i] = 1, rgh[i][i] = 1, winners[i][i][i] = 1;\n\n\tfor(int len = 2; len <= n; len++)\n\t{\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint r = i + len - 1;\n\t\t\tif(r > n) continue;\n\t\t\tbitset<MAXN> qq = A[i] & winners[i + 1][r];\n\t\t\tif(qq.count()) lft[r][i] = 1;\n\t\t}\n\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint l = i - len + 1;\n\t\t\tif(l <= 0) continue;\n\t\t\tbitset<MAXN> qq = A[i] & winners[l][i - 1];\n\t\t\tif(qq.count()) rgh[l][i] = 1;\n\t\t}\n\n\t\tfor(int l = 1; l <= n; l++)\n\t\t{\n\t\t\tint r = l + len - 1;\n\t\t\twinners[l][r] = rgh[l] & lft[r];\n\t\t}\n\t}\n\n\tcout << winners[1][n].count() << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n/*\n\nhttps://atcoder.jp/contests/m-solutions2019/tasks/m_solutions2019_f\n\n人Xが優勝する可能性があるかをO(N)で求めればいい\n人0を優勝させるためには、まず0が勝てない人を全員排除する必要がある\n→stackとかで解けないかな…？\n\n勝ち方向をグラフで表したとき、そこからすべて到達可能ならば優勝可能…？\n→違いそうだし計算量的に不可能\n\n右端から、この区間で勝つ可能性がある人のリストを構築していく\nある人が勝つ可能性がある条件は、それより右にいる優勝者候補の中に勝てる人がいること？\n十分条件ではあるけど…\n→逆に優勝者候補全てに勝てないとする\n→優勝者候補以外ですべての優勝者を倒せる\n\n今までの優勝者候補が優勝者であり続ける or 新たなる優勝者候補が生まれる条件は？\n新規追加の人に誰も勝てなければ全員優勝者候補ではなくなる\n\n優勝者候補の人は、直接勝てれば候補のまま\n直接勝てない場合・・・面倒くさい\n優勝候補じゃない場合、\n→この考え方は無理がありそう\n\n=====解説を見た=====\nbitsetかぁ…\nつまりO(N^3)解を見つければいい\n\nさっき考えてたのがO(N^3)か\ndpL[j][i] = i…jを考えたとき、iが優勝する可能性がある\ndpR[i][j] = i…jを考えたとき、jが優勝する可能性がある\n\n答えは ΣdpL[N-1][i]&dpR[0][i]\ndpL[j][i] = Σ(or)A[i][x] & dpR[i+1][x] & dpL[j][x]\ndpR[i][j] = Σ(or)A[j][x] & dpR[i][x] & dpL[j-1][x]\n\nかぶらないためには、j-iが小さいほうから計算していく\n\n*/\n\n#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n#include <bitset>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = int;\nconst ll mod = 998244353;\n\n\nint main(){\n\n    int N;\n    int tmp;\n    char tmpc = '\\n';\n    bitset<2000> tmpset;\n\n    scanf (\"%d\",&N);\n    vector<bitset<2000>> A(N);\n    rep(i,2,N+1){\n        rep(j,1,i){\n            while (tmpc == '\\n'){\n                scanf (\"%c\",&tmpc);\n            }\n            tmp = tmpc-'0';\n            tmpc = '\\n';\n\n            A[i-1][j-1] = (bool)tmp;\n            A[j-1][i-1] = (bool)(tmp^1);\n        }\n    }\n\n    //cout << A[0] << endl;\n    vector<bitset<2000>> dpL(N);\n    vector<bitset<2000>> dpR(N);\n\n    rep(j_i,0,N){\n        rep(i,0,N-j_i){\n            int j = i+j_i;\n\n            if (i == j){\n                dpL[j][i] = true;\n                dpR[i][j] = true;\n            }else{\n                tmpset = A[i] & dpR[i+1] & dpL[j];\n                bool lans = tmpset.any();\n                tmpset = A[j] & dpR[i] & dpL[j-1];\n                bool rans = tmpset.any();\n                dpL[j][i] = lans;\n                dpR[i][j] = rans;\n            }\n        }\n    }\n\n    tmpset = dpL[N-1]&dpR[0];\n    cout << tmpset.count() << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef bitset<2001> b100;\n\nb100 a[2222];\nb100 win[2222];\nb100 dpl[2222];\nb100 dpr[2222];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0); \n\tint n; cin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tstring s; cin>>s;\n\t\tfor(int j=0;j<s.length();j++)\n\t\t{\n\t\t\tif(s[j]=='1')\n\t\t\t{\n\t\t\t\twin[i].set(j,1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twin[j].set(i,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdpl[i].set(i,1); dpr[i].set(i,1);\n\t}\n\tfor(int len=2;len<=n;len++)\n\t{\n\t\tfor(int i=0;i+len-1<n;i++)\n\t\t{\n\t\t\tint r=i+len-1;\n\t\t\tdpl[i][r]=((win[r]&dpl[i]&dpr[r-1]).count()>0?1:0);\n\t\t\tdpr[r][i]=((win[i]&dpl[i+1]&dpr[r]).count()>0?1:0);\n\t\t}\n\t}\n\tcout<<(dpl[0]&dpr[n-1]).count()<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind = lower_bound(wn[l].begin(), wn[l].end(), l) - wn[l].begin();\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\t\n\tind = lower_bound(wn[r].begin(), wn[r].end(), l) - wn[r].begin();\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\nuniform_int_distribution<> DD(0, 1000000000);\n\nll random(ll r){\n    return (ll(DD(eng))*1000000000 + ll(DD(eng)))%r;\n}\n\nll n,m,T,k,q;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\nconst ll MAXN = 2001;\n\nbool win[MAXN][MAXN] = {0};\n\nbool DPL[MAXN][MAXN] = {0};\nbool DPR[MAXN][MAXN] = {0};\n\nvector<bitset<MAXN> > BR;\nvector<bitset<MAXN> > BL;\nvector<bitset<MAXN> > WINR;\nvector<bitset<MAXN> > WINL;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n   // freopen(\"autput.txt\",\"w\",stdout);\n\n    ll a,b,c,d;\n\n    cin >> n;\n    string s;\n    for(int c1 = 0; c1 < n; c1++){\n        bitset<MAXN> temp1;\n        bitset<MAXN> temp2;\n        bitset<MAXN> temp3;\n        bitset<MAXN> temp4;\n        BR.push_back(temp1);\n        BL.push_back(temp2);\n        WINR.push_back(temp3);\n        WINL.push_back(temp4);\n        if(c1 < n-1)cin >> s;\n        for(int c2 = 0; c2 < c1; c2++){\n          //  cin >> a;\n            a = s[c2]-'a';\n            win[c1][c2] = a;\n            win[c2][c1] = (a^1);\n        }\n    }\n\n    for(int c1 = 0; c1 < n; c1++){\n\n        for(int c2 = c1; c2 < n; c2++){\n            WINR[c1][c2] = win[c1][c2];\n        }\n        for(int c2 = 0; c2 < c1; c2++){\n            WINR[c1][c2] = win[c1][c2];\n        }\n        BR[c1][c1] = 1;\n        BL[c1][c1] = 1;\n        DPL[c1][c1] = 1;\n        DPR[c1][c1] = 1;\n    }\n\n    for(int L = 2; L <= n; L++){\n        bitset<MAXN> LB;\n        for(int c1 = 0; c1 < L; c1++){\n            LB[c1] = 1;\n        }\n        for(int c1 = 0; c1 < n-L; c1++){\n\n            DPL[c1][c1+L-1] = ((WINR[c1] & BL[c1+L-1] & BR[c1]).count() != 0);\n            DPR[c1][c1+L-1]= ((WINL[c1+L-1] & BL[c1+L-1] & BR[c1]).count() != 0);\n            (LB <<= 1);\n        }\n\n        for(int c1 = 0; c1 < n-L; c1++){\n            BR[c1][c1+L-1] = DPR[c1][c1+L-1];\n            BL[c1][c1+L-1] = DPL[c1][c1+L-1];\n        }\n    }\n    ll ans = 0;\n\n    for(int c1 = 0; c1 < n; c1++){\n        if(DPL[c1][n-1]&DPR[0][c1])ans++;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\n#define SIZE 2010\n// 誰に勝てるか（入力）\nbitset<SIZE> A[SIZE];\n// left[i]=iが左端で優勝できる可能性があるか\nbitset<SIZE> left_[SIZE];\n// right[i]=iが右端で優勝できる可能性があるか\nbitset<SIZE> right_[SIZE];\n\n\nint main() {\n  ll N;\n  cin >> N;\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < i; ++j) {\n      char a;\n      cin >> a;\n      A[i][j] = a == '1';\n      A[j][i] = !A[i][j];\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {\n    left_[i][i] = 1;\n    right_[i][i] = 1;\n  }\n  \n  // [i,j]の範囲を徐々に広げながらdp\n  for (int len = 2; len <= N; ++len) {\n    for (int l = 0; l+len <= N; ++l) {\n      int r = l+len -1;\n      if((left_[l+1] & right_[r] & A[l]).any())\n        right_[r][l] = 1;\n      if((left_[l] & right_[r-1] & A[r]).any())\n        left_[l][r] = 1;\n    }\n  }\n\n  cout << (int)((left_[0]&right_[N-1]).count()) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=2000;\n\nint n;\nbool win[MAXN][MAXN];\n\nbool canfst[MAXN][MAXN];\nbool canlst[MAXN][MAXN];\nbool canfinal[MAXN][MAXN];\n\nbitset<MAXN> bwin[MAXN]; // win[i][k]\nbitset<MAXN> bfst[MAXN]; // canfst[k][i]\nbitset<MAXN> blst[MAXN]; // canlst[i][k]\nbitset<MAXN> bfst2[MAXN]; // canfst[i][k]\nbitset<MAXN> blst2[MAXN]; // canlst[k+1][j]\nbitset<MAXN> bfin1[MAXN]; // canfinal[i][k]\nbitset<MAXN> bfin2[MAXN]; // canfinal[k][i]\n\nint solve() {\n\t//REP(i,n) { printf(\"win%d: \",i); REP(j,n) printf(\"%c\",win[i][j]?'v':'.'); puts(\"\"); }\n\tREP(i,n) REP(j,n) canfst[i][j]=canlst[i][j]=canfinal[i][j]=false;\n\tREP(i,n) canfst[i][i]=canlst[i][i]=true;\n\tREP(i,n) bwin[i].reset(),bfst[i].reset(),blst[i].reset(),bfin1[i].reset(),bfin2[i].reset(),bfst2[i].reset(),blst2[i].reset();\n\tREP(i,n) REP(j,n) if(win[i][j]) bwin[i][j]=true;\n\tREP(i,n) { bfst[i][i]=blst[i][i]=bfst2[i][i]=true; if(i+1<n) blst2[i+1][i]=true; }\n\tFORE(len,2,n) REPE(i,n-len) {\n\t\tint j=i+len-1;\n\t\t\n\t\t//FORE(k,i,j-1) if(canfst[i][k]&&canlst[k+1][j]) canfinal[i][j]=true;\n\t\tif((bfst2[i]&blst2[j]).any()) canfinal[i][j]=true;\n\t\tif(canfinal[i][j]) bfin1[i][j]=bfin2[j][i]=true;\n\n\t\t//FORE(k,i+1,j) if(win[i][k]&&canfst[k][j]&&canfinal[i][k]) canfst[i][j]=true;\n\t\tif((bwin[i]&bfst[j]&bfin1[i]).any()) canfst[i][j]=true;\n\t\tif(canfst[i][j]) bfst[j][i]=bfst2[i][j]=true;\n\n\t\t//FORE(k,i,j-1) if(win[j][k]&&canlst[i][k]&&canfinal[k][j]) canlst[i][j]=true;\n\t\tif((bwin[j]&blst[i]&bfin2[j]).any()) canlst[i][j]=true;\n\t\tif(canlst[i][j]) { blst[i][j]=true; if(j+1<n) blst2[j+1][i]=true; }\n\n\t\t//printf(\"%d..%d: fst=%c lst=%c final=%c\\n\",i,j,canfst[i][j]?'v':'.',canlst[i][j]?'v':'.',canfinal[i][j]?'v':'.');\n\t}\n\tint ret=0; REP(i,n) if(canlst[0][i]&&canfst[i][n-1]) ++ret; return ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) win[i][i]=false;\n\tFOR(i,1,n) { string s; cin>>s; REP(j,i) win[i][j]=s[j]=='1',win[j][i]=!win[i][j]; }\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\nconstexpr int MAX_N = 2000;\nint solve(int n, const vector<bitset<MAX_N> > & wins) {\n    vector<vector<bitset<MAX_N> > > dp(n + 1);\n    REP (r, n + 1) {\n        dp[r].resize(r);\n    }\n    REP_R (l, n) REP3 (r, l + 1, n + 1) {\n        if (r - l == 1) {\n            dp[r][l][l] = true;\n        } else {\n            dp[r][l][l] = (dp[r][l + 1] & wins[l]).any();\n            REP3 (m, l + 1, r - 1) {\n                dp[r][l][m] = (dp[m][l] & wins[m]).any() and (dp[r][m + 1] & wins[m]).any();\n            }\n            dp[r][l][r - 1] = (dp[r - 1][l] & wins[r - 1]).any();\n        }\n    }\n    return dp[n][0].count();\n}\n\nint main() {\n    int n; cin >> n;\n    assert (n <= MAX_N);\n    vector<bitset<MAX_N> > wins(n);\n    REP (i, n) {\n        REP (j, i) {\n            char c; cin >> c;\n            wins[i][j] = c - '0';\n            wins[j][i] = not wins[i][j];\n        }\n    }\n    cout << solve(n, wins) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1000003;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nconst int MAX_N = 2000;\n\nbitset< MAX_N > dpl[MAX_N];\nbitset< MAX_N > dpr[MAX_N];\n\nint main() {\n  int N;\n  cin >> N;\n  bitset< MAX_N > mat[MAX_N];\n  for(int i = 1; i < N; i++) {\n    string s;\n    cin >> s;\n    for(int j = 0; j < i; j++) {\n      int x = (int) s[j] - '0';\n      mat[i][j] = x;\n      mat[j][i] = 1 - x;\n    }\n  }\n  for(int i = 0; i < N; i++) {\n    dpl[i][i] = dpr[i][i] = true;\n  }\n  for(int len = 1; len < N; len++) {\n    for(int l = 0; l + len < N; l++) {\n      int r = l + len;\n      dpl[r][l] = (mat[l] & dpl[r] & dpr[l + 1]).any();\n      dpr[l][r] = (mat[r] & dpl[r - 1] & dpr[l]).any();\n    }\n  }\n  cout << (dpl[N - 1] & dpr[0]).count() << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2009;\nchar ch[N];\nint a[N][N],n;\nbitset<N>dp[2][N];\n//int dp[2][N][N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",ch+1);\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\ta[i][j]=ch[j]-48,a[j][i]=!a[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)dp[0][i][i]=dp[1][i][i]=1;\n\tfor(int len=2;len<=n;len++)\n\t{\n\t\tfor(int i=1;i<=(n-len+1);i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tfor(int k=i;k<=j;k++)\n\t\t\tif(dp[0][k][j]&&dp[1][k][i+1]&&a[i][k]){dp[0][i][j]=1;break;}\n\t\t\tfor(int k=i;k<=j;k++)\n\t\t\tif(dp[1][k][i]&&dp[0][k][j-1]&&a[j][k]){dp[1][j][i]=1;break;}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(dp[0][i][n]&&dp[1][i][1])ans++;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\nuniform_int_distribution<> DD(0, 1000000000);\n\nll random(ll r){\n    return (ll(DD(eng))*1000000000 + ll(DD(eng)))%r;\n}\n\nll n,m,T,k,q;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\nconst ll MAXN = 2001;\n\nbool win[MAXN][MAXN] = {0};\n\nbool DPL[MAXN][MAXN] = {0};\nbool DPR[MAXN][MAXN] = {0};\n\nvector<bitset<MAXN> > BR;\nvector<bitset<MAXN> > BL;\nvector<bitset<MAXN> > WINR;\nvector<bitset<MAXN> > WINL;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n   // freopen(\"autput.txt\",\"w\",stdout);\n\n    ll a,b,c,d;\n\n    cin >> n;\n    for(int c1 = 0; c1 < n; c1++){\n        bitset<MAXN> temp1;\n        bitset<MAXN> temp2;\n        bitset<MAXN> temp3;\n        bitset<MAXN> temp4;\n        BR.push_back(temp1);\n        BL.push_back(temp2);\n        WINR.push_back(temp3);\n        WINL.push_back(temp4);\n        for(int c2 = 0; c2 < c1; c2++){\n            cin >> a;\n            win[c1][c2] = a;\n            win[c2][c1] = (a^1);\n        }\n    }\n\n    for(int c1 = 0; c1 < n; c1++){\n\n        for(int c2 = c1; c2 < n; c2++){\n            WINR[c1][c2] = win[c1][c2];\n        }\n        for(int c2 = 0; c2 < c1; c2++){\n            WINR[c1][c2] = win[c1][c2];\n        }\n        BR[c1][c1] = 1;\n        BL[c1][c1] = 1;\n        DPL[c1][c1] = 1;\n        DPR[c1][c1] = 1;\n    }\n\n    for(int L = 2; L <= n; L++){\n        bitset<MAXN> LB;\n        for(int c1 = 0; c1 < L; c1++){\n            LB[c1] = 1;\n        }\n        for(int c1 = 0; c1 < n-L; c1++){\n\n            DPL[c1][c1+L-1] = ((WINR[c1] & BL[c1+L-1] & BR[c1]).count() != 0);\n            DPR[c1][c1+L-1]= ((WINL[c1+L-1] & BL[c1+L-1] & BR[c1]).count() != 0);\n            (LB <<= 1);\n        }\n\n        for(int c1 = 0; c1 < n-L; c1++){\n            BR[c1][c1+L-1] = DPR[c1][c1+L-1];\n            BL[c1][c1+L-1] = DPL[c1][c1+L-1];\n        }\n    }\n    ll ans = 0;\n\n    for(int c1 = 0; c1 < n; c1++){\n        if(DPL[c1][n-1]&DPR[0][c1])ans++;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast,unroll-loops\")\n#pragma GCC target (\"avx\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V< bitset<2000> > a(n);\n  for (int i = 1; i < n; ++i) {\n    string s; cin >> s;\n    for (int j = 0; j < i; ++j) {\n      a[i][j] = s[j] == '1';\n      a[j][i] = s[j] == '0';\n    }\n  }\n  V< bitset<2000> > dp(n);\n  for (int i = 0; i < n; ++i) {\n    dp[i][i] = true;\n    if (i) dp[i][i - 1] = a[i][i - 1];\n    if (i + 1 < n) dp[i][i + 1] = a[i][i + 1];\n  }\n  for (int w = 2; w < n; ++w) {\n    for (int i = 0; i < n; ++i) {\n      int j = i + w;\n      if (j < n) {\n        for (int k = i + 1; k <= j; ++k) if (a[i][k] and dp[k][i + 1] and dp[k][j]) {\n          dp[i][j] = true;\n          break;\n        }\n      }\n      j = i - w;\n      if (j >= 0) {\n        for (int k = i - 1; k >= j; --k) if (a[i][k] and dp[k][i - 1] and dp[k][j]) {\n          dp[i][j] = true;\n          break;\n        }\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n; ++i) res += dp[i][0] and dp[i][n - 1];\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <string>\n#include <bitset>\n#define SIZE 2005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nbitset <SIZE> left[SIZE];\nbitset <SIZE> right[SIZE];\nbool A[SIZE][SIZE];\nchar mp[SIZE][SIZE];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) scanf(\"%s\",&mp[i]);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tint a=mp[i][j]-'0';\n\t\t\tA[i][j]=(a==1);\n\t\t\tA[j][i]=(a==0);\n\t\t}\n\t}/*\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++) printf(\"%d\",A[i][j]);\n\t\tputs(\"\");\n\t}*/\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tleft[i][i]=true;\n\t\tright[i][i+1]=true;\n\t\tbitset <SIZE> X;\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tif((left[j]&right[i]).any())\n\t\t\t{\n\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\tif(A[i][j]) right[i]|=right[j];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleft[j][i]=true;\n\t\t\t\t\tX[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif((X&left[j]).any())\n\t\t\t{\n\t\t\t\tleft[j][i]=true;\n\t\t\t\tX[j]=true;\n\t\t\t}\n\t\t}\n\t}/*\n\tputs(\"\");\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++) printf(\"%d\",left[i][j]?1:0);\n\t\tputs(\"\");\n\t}*/\n\tint ret=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(left[i][0]&&right[i][n])\n\t\t{\n\t\t\tret++;\n\t\t\t//printf(\"%d\\n\",i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2000+5;\nbitset<N> L[N],R[N],a[N];\nsigned main(){\n\tint n;char ch;\n\tcin>>n;\n\tfor(int i=2;i<=n;++i)\n\t\tfor(int j=1;j<i;++j){\n\t\t\tcin>>ch;\n\t\t\ta[i][j]=ch-'0';\n\t\t\ta[j][i]=(ch-'0')^1;\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tL[i][i]=R[i][i]=1;\n\tfor(int len=2;len<=n;++len)\n\t\tfor(int i=1;i+len-1<=n;++i){\n\t\t\tint j=i+len-1;\n\t\t\tL[j][i]=(L[j]&R[i+1]&a[i]).count()!=0;\n\t\t\tR[i][j]=(L[j-1]&R[i]&a[j]).count()!=0;\n\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tans+=(L[n][i] & R[1][i]);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    bitset<2020> A[2020];\n    char acBuf[2020];\n    for (int n = 1; n < N; ++n) {\n        scanf(\"%s\", acBuf);\n        for (int m = 0; m < n; ++m) {\n            A[n][m] = acBuf[m]-'0';\n        }\n    }\n    \n    bitset<2020> DP[2020];\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = 1;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            int j = i+d;\n            bool b = false;\n            for (int k = i+1; k <= j; ++k) {\n                b |= !A[k][i] & DP[k][i+1] & DP[k][j];\n            }\n            DP[i][j] = b;\n            \n            b = false;\n            for (int k = i; k < j; ++k) {\n                b |= A[j][k] & DP[k][i] & DP[k][j-1];\n            }\n            DP[j][i] = b;\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[n][0] & DP[n][N-1]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(int i=(a);i<(n);i++)\n\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI 3.1415926535897932384\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\n\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S acm(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nvoid YN(bool b){cout<<(b?\"YES\":\"NO\")<<\"\\n\";}\nvoid Yn(bool b){cout<<(b?\"Yes\":\"No\")<<\"\\n\";}\nvoid yn(bool b){cout<<(b?\"yes\":\"no\")<<\"\\n\";}\n\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;} return os;}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tchar ch;\n\tcin>>n;\n\tvvb w(n,vb(n,false));\n\trep(i,n)rep(j,i){\n\t\tcin>>ch;\n\t\tif(ch=='1')w[i][j]=true;\n\t\tw[j][i]=!w[i][j];\n\t}\n\tvvi a(n),b(n);\n\trange(i,1,n){\n\t\tif(i==1)a[i].push_back(i-1);\n\t\telse if(!w[i-1][i-2])for(auto x:a[i-1])a[i].push_back(x);\n\t\tbool ok=false;\n\t\tfor(auto x:a[i-1]){\n\t\t\tok|=(w[i-1][x]);\n\t\t}\n\t\tif(ok)a[i].push_back(i-1);\n\t}\n\trange(i,1,n){\n\t\tint j=n-i-1;\n\t\tif(j==n-2)b[j].push_back(j+1);\n\t\telse if(!w[j+1][j+2])for(auto x:b[j+1])b[j].push_back(x);\n\t\tbool ok=false;\n\t\tfor(auto x:b[j+1]){\n\t\t\tok|=(w[j+1][x]);\n\t\t}\n\t\tif(ok)b[j].push_back(j+1);\n\t}\n\tint ans=0;\n\trep(i,n){\n\t\tbool p=a[i].size()==0,q=b[i].size()==0;\n\t\tfor(auto x:a[i])p|=w[i][x];\n\t\tfor(auto x:b[i])q|=w[i][x];\n\t\tif(p&&q)ans++;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nbitset<N> LR[N][N], L[N], R[N], A[N];\nint n;\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 2; i <= n; i++) for (int j = 1; j < i; j++){\n\t\tchar x;\n\t\tcin >> x;\n\t\tA[i][j] = (x == '1');\n\t\tA[j][i] = (x == '0');\n\t}\n\tfor (int i = 1; i <= n; i++) for (int j = i; j <= n; j++){\n\t\tLR[i][j] = LR[i][j - 1];\n\t\tLR[i][j][j] = 1;\n//\t\tcout << i << ' ' << j << '\\n';\n//\t\tfor (int k = 1; k <= n; k++) cout << LR[i][j][k];\n//\t\tcout << '\\n';\n\t}\n\tfor (int i = 1; i <= n; i++) L[i][i] = 1, R[i][i] = 1;\n\tfor (int len = 2; len <= n; len++){\n\t\tfor (int l = 1; l <= n - len + 1; l++){\n\t\t\tint r = len + l - 1;\n\t\t\tbitset<N> bt;\n\t\t\tbt = (R[r] & L[l + 1] & A[l] & LR[l + 1][r]);\n\t\t\tif (bt.count() > 0) R[r][l] = 1;\n\t\t\telse R[r][l] = 0;\n\t\t\tbt = (R[r - 1] & L[l] & A[r] & LR[l][r - 1]);\n\t\t\tif (bt.count() > 0) L[l][r] = 1;\n\t\t\telse L[l][r] = 0;\n//\t\t\tcout << l << ' ' << r << ' ' << L[l][r] << ' ' << R[r][l] << '\\n';\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (L[1][i] == 1 && R[n][i] == 1) ans++;\n\t}\n\tcout << ans;\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define sz(a) (int)a.size()\n#define x first\n#define y second\n#define debug(...) cout << \"[\" << #__VA_ARGS__ << \": \" << __VA_ARGS__ << \"]\\n\"\n#define rd() abs((int)rng())\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int>pii;\nconst int maxn = 2e3 + 100;\nconst int mod = 1e9 + 7;\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\nint n, wins[maxn][maxn];\nint dpl[maxn][maxn], dpr[maxn][maxn];\nint main()\n{\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 1; j <= sz(s); j++)\n\t\t{\n\t\t\tif(s[j - 1] == '0')\n\t\t\t{\n\t\t\t\twins[i][j] = 0;\n\t\t\t\twins[j][i] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twins[i][j] = 1;\n\t\t\t\twins[j][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tdpl[i][i] = dpr[i][i] = 1;\n\tfor(int len = 2; len <= n; len++)\n\t{\n\t\tfor(int i = len; i <= n; i++)\n\t\t{\n\t\t\tfor(int k = i - 1; k >= i - len + 1; k--)\n\t\t\t{\n\t\t\t\tif(wins[i][k] && dpl[k][i - len + 1] == 1 && dpr[k][i - 1] == 1)\n\t\t\t\t\tdpl[i][i - len + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = n - len + 1; i >= 1; i--)\n\t\t{\n\t\t\tfor(int k = i + 1; k <= i + len - 1; k++)\n\t\t\t{\n\t\t\t\tif(wins[i][k] && dpr[k][i + len - 1] == 1 && dpl[k][i + 1] == 1)\n\t\t\t\t\tdpr[i][i + len - 1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(dpl[i][1] && dpr[i][n])\n\t\t\t++ans;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing lint = long long;\nusing namespace std;\nconst int MAXN = 2005;\n\nint n, k;\nchar str[MAXN][MAXN];\nint lwin[MAXN], rwin[MAXN];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tscanf(\"%s\", str[i]);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tstr[i][i] = '0';\n\t\tfor(int j=0; j<i; j++){\n\t\t\tstr[j][i] = str[i][j] ^ 1;\n\t\t}\n\t}\n\tiota(lwin, lwin + n, 0);\n\tiota(rwin, rwin + n, 0);\n\tbool loop = true;\n\twhile(loop){\n\t\tloop = false;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int k=0; k<j; k++){\n\t\t\t\tif(rwin[k] >= j-1 && str[j][k] == '1'){\n\t\t\t\t\tif(lwin[j] > lwin[k]){\n\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\tlwin[j] = lwin[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=j+1; k<n; k++){\n\t\t\t\tif(lwin[k] <= j+1 && str[j][k] == '1'){\n\t\t\t\t\tif(rwin[j] < rwin[k]){\n\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\trwin[j] = rwin[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i=0; i<n; i++){\n\t\tif(lwin[i] == 0 && rwin[i] == n-1) ret++;\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing _loop_int = int;\n#define REP(i,n) for(_loop_int i=0; i<(_loop_int)(n); i++)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a); i<(_loop_int)(b); i++)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1; i>=(_loop_int)(a); i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n#define ALL(v) (v).begin(),(v).end()\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define DEBUG_VEC(v) cerr<<#v<<\": \";REP(__i,(v).size())cerr<<((v)[__i])<<\", \";cerr<<endl\n\nconst ll MOD = 1000000007ll;\n\nint n;\nchar s[2521][2521];\nbool win[2521][2521];\nvi g[2521];\n\nshort yusho[2521][2521][2];\n\nbool calc(int l, int r, int k){\n    if(l>r)return true;\n    if(yusho[l][r][k] != -1){\n        return yusho[l][r][k]==1;\n    }\n    int p = k==0 ? l-1 : r+1;\n    // for(int to : g[p]){\n    FOR(to,l,r+1)if(win[p][to]){\n        bool ok = true;\n        if(to>l)ok = ok && calc(l,to-1,1);\n        if(to<r)ok = ok && calc(to+1,r,0);\n        if(ok){\n            return yusho[l][r][k] = 1;\n        }\n    }\n    return yusho[l][r][k] = 0;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    REP(i,n-1)scanf(\"%s\",s[i+1]);\n    REP(i,n)REP(j,i){\n        win[i][j] = s[i][j]=='1';\n        win[j][i] = !win[i][j];\n    }\n    // REP(i,n)REP(j,n)if(win[i][j])g[i].push_back(j);\n    REP(i,n)REP(j,n)REP(k,2)yusho[i][j][k] = -1;\n    int ans = 0;\n    REP(i,n){\n        bool ok = true;\n        if(i>0)ok = ok && calc(0,i-1,1);\n        if(i<n-1)ok=ok && calc(i+1,n-1,0);\n        if(ok)ans++;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 2010;\n\nint mat[N][N];\nchar s[N];\nbool dpl[N][N], dpr[N][N];\n/*\n * set1: dpl[i]\n * set2: dpl[j]\n * set3: dpr[i]\n * set4: dpr[j]\n */\nstd::bitset <N> set1[N], set2[N], set3[N], set4[N];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        scanf(\"%s\", s);\n        for (int j = 0; j < i; ++j) {\n            mat[i][j] = s[j] - '0';\n            mat[j][i] = 1 - mat[i][j];\n        }\n    }\n    for (int len = 1; len <= n; ++ len){\n        for (int i = 0; i < n; ++ i){\n            int j = i + len - 1;\n            if (j >= n){\n                continue;\n            }\n            if (len == 1){\n                dpl[i][j] = dpr[i][j] = true;\n            } else{\n                if ((set1[i] & set2[j]).any() || ((set1[i] << 1 & set4[j]).any() && mat[i][j])){\n                    dpl[i][j] = true;\n                }\n                if ((set4[j] & set3[i]).any() || ((set4[j] >> 1 & set1[i]).any() && mat[j][i])){\n                    dpr[i][j] = true;\n                }\n            }\n            set1[i][j] = set2[j][i] = dpl[i][j];\n            set3[i][j] = set4[j][i] = dpr[i][j];\n        }\n    }\n    int cnt = 0;\n    for (int i = 0; i < n; ++ i){\n        cnt += dpl[i][n - 1] && dpr[0][i];\n    }\n    printf(\"%d\\n\", cnt);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\nusing bs = bitset<2000>;\nbs dp[2000][2000];\n\nsigned main(){\n\n    int N; cin >> N;\n    vector<string> A(N);\n    A[0] = \"\";\n    FOR(i, 1, N) cin >> A[i];\n    vector<bs> W(N);\n    REP(i, N) REP(j, i){\n        if(A[i][j] == '1') W[i][j] = 1;\n        else W[j][i] = 1;\n    }\n    \n    REP(i, N) dp[i][i][i] = 1;\n    FOR(d, 1, N){\n        REP(i, N - d){\n            int j = i + d;\n            if((W[i] & dp[i + 1][j]).any()) dp[i][j][i] = 1;\n            if((W[j] & dp[i][j - 1]).any()) dp[i][j][j] = 1;\n            FOR(k, i + 1, j){\n                if(dp[i][k][k] && dp[k][j][k]) dp[i][j][k] = 1; \n            }\n        }\n    }\n    Out(dp[0][N - 1].count());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\n\nint n;\nchar p[2100][2100];\nint w[2100][2100], Right[2100], Left[2100], TLeft[2100];\nbitset<2100>B[2100], U, RR[2100];\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%s\", p[i]);\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (p[i][j] == '1') {\n\t\t\t\tw[i][j] = 1;\n\t\t\t}\n\t\t\telse w[j][i] = 1;\n\t\t}\n\t}\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tRR[i][i] = 1;\n\t\tif (i == n - 1) {\n\t\t\tRight[i] = 1;\n\t\t\tLeft[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tLeft[i] = 1;\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (w[i][j] && Right[j] && Left[j]) {\n\t\t\t\tRight[i] = 1;\n\t\t\t}\n\t\t\tif (w[i][j] && Left[j]) {\n\t\t\t\tRR[i] |= RR[j];\n\t\t\t}\n\t\t}\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (RR[i][j - 1] && w[j][i]) B[j][i] = 1;\n\t\t}\n\t\tU.reset();\n\t\tU[i] = 1;\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif ((U & B[j]).count()) {\n\t\t\t\tLeft[j] = 1;\n\t\t\t\tU[j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLeft[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (Right[i] && Left[i])res++;\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\nint n;\nbitset<N> a[N], l[2][N], r[2][N], d[2][N];\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 2; i <= n; i++){\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tint x;\n\t\t\tscanf(\"%1d\", &x);\n\t\t\ta[i][j] = x;\n\t\t\ta[j][i] = !x;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) l[1][i][i] = r[1][i][i] = d[1][i][i] = 1;\n\tfor(int len = 2; len <= n; len++){\n\t\tfor(int st = 1; st + len - 1 <= n; st++){\n\t\t\tl[len & 1][st] = l[~len & 1][st];\n\t\t\tl[len & 1][st][st + len - 1] = ((d[~len & 1][st] & a[st + len - 1]).count() != 0);\n\t\t\tr[len & 1][st] = r[~len & 1][st + 1];\n\t\t\tr[len & 1][st][st] = ((d[~len & 1][st + 1] & a[st]).count() != 0);\n\t\t\td[len & 1][st] = l[len & 1][st] & r[len & 1][st];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", d[n & 1][1].count());\n}"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\n//const int MAX = 2e3 + 41;\nconst int MAX = 10;\n\nint n;\nbitset<MAX> pref[MAX], suf[MAX], win[MAX];\nint a[MAX][MAX];\n\nvoid solve () {\n\tfi(0, n - 1) {\n\t\tfj(0, n - 1) {\n\t\t\tif (a[i][j]) win[i].set(j);\n\t\t}\n\t}\n\tdbg(win[0]);\n\tfi(0, n - 1) {\n\t\tpref[i].set(i);\n\t\tsuf[i].set(i);\t\t\t\t\t\t\n\t\tfdj(i - 1, 0) {\n\t\t\tif (a[i][j]) {\t\t\t\t\n\t\t\t\tif ( ( (suf[j] << 1) & pref[i]).count() ) {\n\t\t\t\t\tpref[i] |= pref[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbitset<MAX> sufwin;\n\t\tsufwin.reset();\n\t\tsufwin.set(i);\n\t\tfdj(i - 1, 0) {\n\t\t\tif ( ((suf[j] << 1) & sufwin & win[j]).count() ) {\n\t\t\t\tsufwin.set(j);\n\t\t\t\tsuf[j].set(i);\n\t\t\t}\n\t\t}\n//\n\t\tfj(0, i) {\n\t\t\tdbg(pref[j]);\n\t\t\tdbg(suf[j]);\n\t\t}\n\t\terr(\"after i = %d\\n\", i);\n//\n\t}\n\tvi answer;\n\tfi(0, n - 1) {\n\t\tif (pref[i].test(0) && suf[i].test(n - 1)) {\n\t\t\tanswer.pb(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sz(answer));\n//\tdbg(answer);\t\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\t\n\tscanf(\"%d\", &n);\n\tfi(0, n - 1) {\n\t\tfj(0, i - 1) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\ta[j][i] = 1 - a[i][j];\n\t\t}\n\t}\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\nuniform_int_distribution<> DD(0, 1000000000);\n\nll random(ll r){\n    return (ll(DD(eng))*1000000000 + ll(DD(eng)))%r;\n}\n\nll n,m,T,k,q;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\nconst ll MAXN = 2001;\n\nbool win[MAXN][MAXN] = {0};\n\nbool DPL[MAXN][MAXN] = {0};\nbool DPR[MAXN][MAXN] = {0};\n\nvector<bitset<MAXN> > BR;\nvector<bitset<MAXN> > BL;\nvector<bitset<MAXN> > WINR;\nvector<bitset<MAXN> > WINL;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n   // freopen(\"autput.txt\",\"w\",stdout);\n\n    ll a,b,c,d;\n\n    cin >> n;\n    string s;\n    for(int c1 = 0; c1 < n; c1++){\n        bitset<MAXN> temp1;\n        bitset<MAXN> temp2;\n        bitset<MAXN> temp3;\n        bitset<MAXN> temp4;\n        BR.push_back(temp1);\n        BL.push_back(temp2);\n        WINR.push_back(temp3);\n        WINL.push_back(temp4);\n        if(c1 < n-1)cin >> s;\n        for(int c2 = 0; c2 < c1; c2++){\n          //  cin >> a;\n            a = s[c2]-'a';\n            win[c1][c2] = a;\n            win[c2][c1] = (a^1);\n        }\n        win[c1][c1] = 1;\n    }\n\n    for(int c1 = 0; c1 < n; c1++){\n\n        for(int c2 = c1; c2 < n; c2++){\n            WINR[c1][c2] = win[c1][c2];\n        }\n        for(int c2 = 0; c2 < c1; c2++){\n            WINR[c1][c2] = win[c1][c2];\n        }\n        BR[c1][c1] = 1;\n        BL[c1][c1] = 1;\n        DPL[c1][c1] = 1;\n        DPR[c1][c1] = 1;\n    }\n\n    for(int L = 2; L <= n; L++){\n        bitset<MAXN> LB;\n        for(int c1 = 0; c1 < L; c1++){\n            LB[c1] = 1;\n        }\n        for(int c1 = 0; c1 < n-L; c1++){\n\n            DPL[c1][c1+L-1] = ((WINR[c1] & BL[c1+L-1] & BR[c1]).count() != 0);\n            DPR[c1][c1+L-1]= ((WINL[c1+L-1] & BL[c1+L-1] & BR[c1]).count() != 0);\n            (LB <<= 1);\n        }\n\n        for(int c1 = 0; c1 < n-L; c1++){\n            BR[c1][c1+L-1] = DPR[c1][c1+L-1];\n            BL[c1][c1+L-1] = DPL[c1][c1+L-1];\n        }\n    }\n    ll ans = 0;\n\n    for(int c1 = 0; c1 < n; c1++){\n        if(DPL[c1][n-1]&DPR[0][c1])ans++;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define vii vector < pii >\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class P , class Q > ostream& operator<<(ostream& stream, pair < P , Q > v){ stream << \"(\" << v.fi << ',' << v.se << \")\"; return stream;}\ntemplate < class T > ostream& operator<<(ostream& stream, const vector<T> v){ stream << \"[ \"; for (int i=0; i<(int)v.size(); i++) stream << v[i] << \" \"; stream << \"]\"; return stream;}\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nbitset < 2048 > ok[2048];\nbitset < 2048 > d[2][2048];\nbitset < 2048 > was[2][2048];\nint nxt1[2048][2048];\nint nxt2[2048][2048];\nint used = 0;\nbool f(int tp,int l,int r) {\n\tif (was[tp][l][r])\n\t\treturn d[tp][l][r];\n\tif (l >= r)\n\t\treturn 1;\n\t++used;\n\twas[tp][l][r] = 1;\n\tbool ans = 0;\n\tif (!tp) {\n\t\tfor (int i = nxt1[l][l];!ans && i <= r;i = nxt1[l][i + 1])\n\t\t\tans |= f(1,l + 1,i) && f(0,i,r);\n\t} else {\n\t\tfor (int i = nxt2[r][r];!ans && i >= l;i = nxt2[r][i - 1])\n\t\t\tans |= f(1,l,i) && f(0,i,r - 1);\n\t}\n\treturn d[tp][l][r] = ans;\n}\nint main(void) {\n//\tsrand(time(0));\n    int n;\n    cin>>n;\n    for (int i = 2;i <= n;++i) {\n    \tstring str;\n//    \tfor (int j = 1;j < i;++j)\n//    \t\tstr += (rand() & 1) + '0';\n    \tcin>>str;\n    \tfor (int j = 1;j < i;++j)\n    \t\tok[i][j] = str[j - 1] == '1',ok[j][i] = str[j - 1] == '0';\n    }\n    for (int i = 1;i <= n;++i) {\n    \tnxt1[i][n + 1] = n + 1;\n    \tfor (int j = n;j;--j) {\n    \t\tnxt1[i][j] = ok[i][j] ? j : nxt1[i][j + 1];\n    \t}\n    \tnxt2[i][0] = 0;\n    \tfor (int j = 1;j <= n;++j) {\n    \t\tnxt2[i][j] = ok[i][j] ? j : nxt2[i][j - 1];\n    \t}\n    }\n    int ans = 0;\n    for (int i = 1;i <= n;++i)\n    \tans += f(1,1,i) && f(0,i,n);\n    cout << ans << '\\n';\n    dbg(used);\n    cerr << fixed << setprecision(7) << (clock() * 1.0 / CLOCKS_PER_SEC) << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include <bits/stdc++.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconstexpr ll MOD = 1000000007;\n\nstruct P\n{\n\tint A, B;\n\tP(int a, int b) : A(a), B(b) {}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<bool> m(N * N);\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tstring S;\n\t\tcin >> S;\n\t\tfor (int j = 0; j < i; j++) m[N * j + i] = !(m[N * i + j] = S[j] == '1');\n\t}\n\tvector<int> strong, weak, normal;\n\tvector<bool> isnormal(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tint c = 0;\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (m[N * i + j]) c++;\n\t\tif (c == N - 1)\n\t\t\tstrong.push_back(i);\n\t\telse if (c == 0)\n\t\t\tweak.push_back(i);\n\t\telse\n\t\t\tnormal.push_back(i);\n\t\tisnormal[i] = c > 0;\n\t}\n\tif (strong.size())\n\t{\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tint M = normal.size();\n\tvector<bool> newm(M * M);\n\tfor (int i = 0; i < M; i++)\n\t\tfor (int j = 0; j < M; j++) newm[M * i + j] = m[N * normal[i] + normal[j]];\n\tN = M;\n\tm = newm;\n\tdeque<bool> dp(N * N, false);\n\tfor (int i = 0; i < N - 1; i++) dp[N * i + i + 1] = true;\n\tfor (int l = 2; l < N; l++)\n\t\tfor (int i = 0; i + l < N; i++)\n\t\t{\n\t\t\tint p = N * i + i + l;\n\t\t\tfor (int k = i + 1, q = N * i + k, r = N * (i + l) + k, s = N * k + i + l; k < i + l; k++, q++, r++, s += N)\n\t\t\t\tdp[p] |= dp[q] & (m[q] | m[r]) & dp[s];\n\t\t}\n\tdeque<bool> dpL(N, false);\n\tdpL[N - 1] = true;\n\tfor (int i = N - 2; i >= 0; i--)\n\t\tfor (int j = i + 1; j < N; j++) dpL[i] |= m[N * i + j] & dpL[j] & dp[N * i + j];\n\tdeque<bool> dpR(N, false);\n\tdpR[0] = true;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 0; j < i; j++) dpR[i] |= m[N * i + j] & dpR[j] & dp[N * j + i];\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tif (dpL[i] & dpR[i]) ans++;\n\tcout << ans << endl;\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nbool A[2000][2000];\nbitset<2001> L[2000];\nbitset<2001> R[2000];\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tREP(j, 0, i) {\n\t\t\tbool ok = Next<char>() - '0';\n\t\t\tA[i][j] = ok;\n\t\t\tA[j][i] = 1 - ok;\n\t\t}\n\t}\n\n\tREP(i, 0, N) {\n\t\tL[i][i] = true;\n\t\tR[i][i + 1] = true;\n \t}\n\n\tREP(z, 0, 12) {\n\t\tREP(i, 0, N) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tREP(k, i + 1, j + 1) {\n\t\t\t\t\tif (R[i][k] && L[j][k]) {\n\t\t\t\t\t\tR[i] |= R[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\t\tif (!A[i][j]) continue;\n\t\t\t\tREP(k, j + 1, i + 1) {\n\t\t\t\t\tif (L[i][k] && R[j][k]) {\n\t\t\t\t\t\tL[i] |= L[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tREP(i, 0, N) {\n\t\tif (L[i][0] && R[i][N]) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bitset>\n\nint n;\nchar ch[2005][2048];\n\n// bs1 is inclusive, bs2 is exclusive\nstd::bitset<2048> bs1[2005],bs2[2005];\n\nvoid stuff(int i,int j)\n{\n    if ((bs2[i]&bs1[j]).any()) {\n        //printf(\"%d %d with %c\\n\",i,j,ch[j][i]);\n        // they overlap\n        if (ch[j][i]=='0') {\n            // i wins, j loses\n            //printf(\"%d wins, %d loses\\n\",i,j);\n            bs2[i]|=bs2[j];\n        }\n        else {\n            // i loses, j wins\n            //printf(\"%d loses, %d wins\\n\",i,j);\n            bs1[j]|=bs1[i];\n        }\n    }\n}\n\nint ans=0;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d\",&n);\n    for (int i=1; i<n; i++) {\n        for (int j=0; j<i; j++) {\n            scanf(\" %c\",&ch[i][j]);\n        }\n    }\n    for (int i=0; i<n; i++) {\n        bs1[i][i]=1;\n        bs2[i][i+1]=1;\n    }\n    // i hope a floyd warshall is happening here\n    for (int d=1; d<n; d++) {\n        for (int i=0; i+d<n; i++) {\n            stuff(i,i+d);\n        }\n    }\n    for (int d=1; d<n; d++) {\n        for (int i=0; i+d<n; i++) {\n            stuff(i,i+d);\n        }\n    }\n    for (int d=1; d<n; d++) {\n        for (int i=0; i+d<n; i++) {\n            stuff(i,i+d);\n        }\n    }\n    for (int i=0; i<n; i++) {\n        if (bs1[i][0] && bs2[i][n]) ans++;\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//By Tushar Gautam\n#pragma GCC optimize (\"-O2\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define memreset(a) memset(a,0,sizeof(a))\n#define testcase(t) int t;cin>>t;while(t--)\n#define forstl(i,v) for(auto &i: v)\n#define forn(i,e) for(int i=0;i<e;++i)\n#define forsn(i,s,e) for(int i=s;i<e;++i)\n#define rforn(i,s) for(int i=s;i>=0;--i)\n#define rforsn(i,s,e) for(int i=s;i>=e;--i)\n#define bitcount(a) __builtin_popcount(a) // set bits (add ll)\n#define ln '\\n'\n#define getcurrtime() cerr<<\"Time = \"<<((double)clock()/CLOCKS_PER_SEC)<<endl\n#define dbgarr(v,s,e) cerr<<#v<<\" = \"; forsn(i,s,e) cerr<<v[i]<<\", \"; cerr<<endl\n#define inputfile freopen(\"input.txt\", \"r\", stdin)\n#define outputfile freopen(\"output.txt\", \"w\", stdout)\n#define dbg(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); \\\nstringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) { cerr<<endl; }\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n\tcerr << *it << \" = \" << a << \"\\t\"; err(++it, args...);\n}\ntemplate<typename T1,typename T2>\nostream& operator <<(ostream& c,pair<T1,T2> &v){\n\tc<<\"(\"<<v.fi<<\",\"<<v.se<<\")\"; return c;\n}\ntemplate <template <class...> class TT, class ...T>\nostream& operator<<(ostream& out,TT<T...>& c){\n    out<<\"{ \";\n    forstl(x,c) out<<x<<\" \";\n    out<<\"}\"; return out;\n}\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> p64;\ntypedef pair<int,int> p32;\ntypedef pair<int,p32> p96;\ntypedef vector<ll> v64;\ntypedef vector<int> v32; \ntypedef vector<v32> vv32;\ntypedef vector<v64> vv64;\ntypedef vector<p32> vp32;\ntypedef vector<p64> vp64;\ntypedef vector<vp32> vvp32;\ntypedef map<int,int> m32;\nconst int LIM=1e5+5,MOD=1e9+7;\nint t,n,m,k,x,y,w;\nint mat[2005][2005];\n//Push-Relabel Algorithm for Flows - Gap Heuristic, Complexity: O(V^3)\n//To obtain the actual flow values, look at all edges with capacity > 0\n//Zero capacity edges are residual edges\nstruct edge{\n\tint from, to, cap, flow, index;\n\tedge(int from, int to, int cap, int flow, int index):\n\t\tfrom(from), to(to), cap(cap), flow(flow), index(index) {}\n};\nstruct PushRelabel{\n\tint n;\n\tvector<vector<edge> > g;\n\tvector<long long> excess;\n\tvector<int> height, active, count;\n\tqueue<int> Q;\n\tPushRelabel(int n):\n\t\tn(n), g(n), excess(n), height(n), active(n), count(2*n) {}\n\tvoid addEdge(int from, int to, int cap){\n\t\tdbg(from,to);\n\t\tg[from].push_back(edge(from, to, cap, 0, g[to].size()));\n\t\tif(from==to)\n\t\t\tg[from].back().index++;\n\t\tg[to].push_back(edge(to, from, 0, 0, g[from].size()-1));\n\t}\n\tvoid enqueue(int v){\n\t\tif(!active[v] && excess[v] > 0)\n\t\t{\n\t\t\tactive[v]=true;\n\t\t\tQ.push(v);\n\t\t}\n\t}\n\tvoid push(edge &e){\n\t\tint amt=(int)min(excess[e.from], (long long)e.cap - e.flow);\n\t\tif(height[e.from]<=height[e.to] || amt==0)\n\t\t\treturn;\n\t\te.flow += amt;\n\t\tg[e.to][e.index].flow -= amt;\n\t\texcess[e.to] += amt;\n\t\texcess[e.from] -= amt;\n\t\tenqueue(e.to);\n\t}\n\tvoid relabel(int v){\n\t\tcount[height[v]]--;\n\t\tint d=2*n;\n\t\tfor(auto &it:g[v]){\n\t\t\tif(it.cap-it.flow>0)\n\t\t\t\td=min(d, height[it.to]+1);\n\t\t}\n\t\theight[v]=d;\n\t\tcount[height[v]]++;\n\t\tenqueue(v);\n\t}\n\tvoid gap(int k){\n\t\tfor(int v=0;v<n;v++){\n\t\t\tif(height[v]<k)\n\t\t\t\tcontinue;\n\t\t\tcount[height[v]]--;\n\t\t\theight[v]=max(height[v], n+1);\n\t\t\tcount[height[v]]++;\n\t\t\tenqueue(v);\n\t\t}\n\t}\n\tvoid discharge(int v){\n\t\tfor(int i=0; excess[v]>0 && i<g[v].size(); i++)\n\t\t\tpush(g[v][i]);\n\t\tif(excess[v]>0){\n\t\t\tif(count[height[v]]==1)\n\t\t\t\tgap(height[v]);\n\t\t\telse\n\t\t\t\trelabel(v);\n\t\t}\n\t}\n\tlong long max_flow(int source, int dest){\n\t\tcount[0] = n-1;\n\t\tcount[n] = 1;\n\t\theight[source] = n;\n\t\tactive[source] = active[dest] = 1;\n\t\tfor(auto &it:g[source]){\n\t\t\texcess[source]+=it.cap;\n\t\t\tpush(it);\n\t\t}\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front();\n\t\t\tQ.pop();\n\t\t\tactive[v]=false;\n\t\t\tdischarge(v);\n\t\t}\n\t\tlong long max_flow=0;\n\t\tfor(auto &e:g[source])\n\t\t\tmax_flow+=e.flow;\n\n\t\treturn max_flow;\n\t}\n};\nbool find(int x){\n\tint s=x,t=n;\n\tPushRelabel f(n+1);\n\tforn(i,n){\n\t\tforn(j,i){\n\t\t\tif(mat[i][j]){\n\t\t\t\t// dbg(i,j);\n\t\t\t\tif(j==x) continue;\n\t\t\t\telse f.addEdge(i,j,2005);\n\t\t\t}else{\n\t\t\t\tif(i==x) continue;\n\t\t\t\telse f.addEdge(j,i,2005);\n\t\t\t}\n\t\t}\n\t\tf.addEdge(i,t,1);\n\t}\n\tauto ans=f.max_flow(s,t);\n\tif(ans==n) return 1;\n\telse return 0;\n}\nsigned main(){\n\tfastio;\n\tcin>>n;\n\tchar ch;\n\tforn(i,n) forn(j,i) cin>>ch,mat[i][j]=ch=='1';\n\tint ans=0;\n\tforn(i,n) if(find(i)) ans++;\n\tcout<<ans<<ln;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1000003;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nconst int MAX_N = 2000;\n\nbool dpl[MAX_N][MAX_N];\nbool dpr[MAX_N][MAX_N];\n\nint main() {\n  int N;\n  cin >> N;\n  auto mat = make_v< int >(N, N);\n  for(int i = 1; i < N; i++) {\n    string s;\n    cin >> s;\n    for(int j = 0; j < i; j++) {\n      int x = (int) s[j] - '0';\n      mat[i][j] = x;\n      mat[j][i] = 1 - x;\n    }\n  }\n  for(int i = 0; i < N; i++) {\n    dpl[i][i] = dpr[i][i] = true;\n  }\n  for(int len = 1; len < N; len++) {\n    for(int l = 0; l + len < N; l++) {\n      int r = l + len;\n      for(int k = l + 1; k <= r; k++) {\n        dpl[r][l] |= mat[l][k] & dpl[r][k] & dpr[l + 1][k];\n        if(dpl[r][l]) break;\n      }\n      for(int k = l; k + 1 <= r; k++) {\n        dpr[l][r] |= mat[r][k] & dpl[r - 1][k] & dpr[l][k];\n        if(dpr[l][r]) break;\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    ret += dpl[N - 1][i] & dpr[0][i];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;\n    vector<vector<bool>> A(N, vector<bool>(N));\n    for (int i=1; i<N; i++)\n    {\n        string t;\n        cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            A[i][j] = t[j]!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    //vector<vector<bool>> L(N, vector<bool>(N));\n    //vector<vector<bool>> R(N, vector<bool>(N));\n    static bool L[2048][2048];\n    static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<N; j++)\n                    b |= a[j] & l[j] & r[j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=0; j<i; j++)\n                    b |= a[j] & l[j] & r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2005;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tcin >> n;\n\tvector<bitset<maxn> > v(n);\n\tfor(int i = 1; i < n; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < i; ++j) {\n\t\t\tif(s[j] == '1') {\n\t\t\t\tv[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tv[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvector<bitset<maxn> > l(n);\n\tvector<bitset<maxn> > r(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tl[i][i] = r[i][i] = 1;\n\t}\n\tfor(int i = 1; i < n; ++i) {\n\t\tfor(int j = 0; i + j < n; ++j) {\n\t\t\tl[i + j][j] = (l[i + j] & r[j + 1] & v[j]).any();\n\t\t\tr[j][i + j] = (r[j] & l[i + j - 1] & v[i + j]).any();\n\t\t}\n\t}\n\tcout << (r[0] & l[n - 1]).count() << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 2020;\nInt a[MAX][MAX]={};\nInt dpL[MAX][MAX]={};\nInt dpR[MAX][MAX]={};\nsigned main(){\n  Int n;\n  cin>>n;\n  for(Int i=1;i<n;i++){\n    string s;\n    cin>>s;\n    for(Int j=0;j<i;j++){\n      a[i][j]=s[j]-'0';      \n      a[j][i]=!a[i][j];\n    }\n  }\n  \n  if(0){\n    for(Int i=0;i<n;i++){\n      for(Int j=0;j<n;j++)\n        cout<<a[i][j];\n      cout<<endl;\n    }\n  }\n  \n  for(Int i=0;i<n;i++)\n    dpL[i][i]=dpR[i][i]=1;\n\n  for(Int w=2;w<=n;w++){\n    for(Int i=0;i+w<=n;i++){\n      Int l=i,r=i+w-1;\n      for(Int x=l+1;x<=r;x++)\n        for(Int k=l;k<x;k++)\n          dpL[l][r]|=dpL[l][k]&&dpR[k+1][x]&&dpL[x][r]&&a[l][x];\n      \n      for(Int x=l;x<r;x++)\n        for(Int k=x+1;k<=r;k++)\n          dpR[l][r]|=dpR[k][r]&&dpR[l][x]&&dpL[x][k-1]&&a[r][x];     \n    }\n  }\n  \n  \n  Int ans=0;\n  for(Int i=0;i<n;i++)\n    if(dpR[0][i]&&dpL[i][n-1]) ans++;\n\n  cout<<ans<<endl;  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n;\nchar a[n][n];\nint func(int num){\n  int b[n];\n  for(int i=0;i<n;i++){\n    if(a[num][i] = 0\n}\n  \nint main(){\n  cin >> n;\n  string str;\n  for(int i=0;i<n;i++){\n    cin >> str;\n    for(int j=0;j<i;j++){\n      a[i][j] = str[j];\n    }\n  }\n  static int b[n];\n  int sum = 0;\n  for(int i=0;i<n;i++){\n    sum += func();\n  }\n  cout << sum;\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nvector<int> win[2010];\nint n;\nbool flag[2010];\n\nvoid calc(int a,int b){\n\t//cout << a << \" \" << b << endl;\n\tif(b - a == 1){\n\t\tif(a != -1) flag[a] = true;\n\t\tif(b != n) flag[b] = true;\n\t\treturn;\n\t}\n\tvector<int> vec;\n\tif(a != -1){\n\t\tint ind = lower_bound(all(win[a]),a) - win[a].begin();\n\t\twhile(ind < win[a].size() && win[a][ind] < b) vec.pb(win[a][ind++]);\n\t}\n\tif(b != n){\n\t\tint ind = lower_bound(all(win[b]),a) - win[b].begin();\n\t\twhile(ind < win[b].size() && win[b][ind] < b) vec.pb(win[b][ind++]);\n\t}\n\tvec.pb(a);\n\tvec.pb(b);\n\tsort(all(vec));\n\tvec.erase(unique(all(vec)),vec.end());\n\tif(vec.size() == 2) return;\n\tfor(int i = 0;i < vec.size() - 1;i++) calc(vec[i],vec[i + 1]);\n}\n\nsigned main(){\n\tint ans = 0;\n\tcin >> n;\n\tfor(int i = 1;i < n;i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0;j < i;j++){\n\t\t\tif(s[j] == '0') win[j].pb(i);\n\t\t\telse win[i].pb(j);\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++) flag[j] = false;\n\t\tcalc(-1,i);\n\t\tcalc(i,n);\n\t\tbool f = true;\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(!flag[j]) f = false;\n\t\t}\n\t\tif(f) ans++;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<functional>\n#include<map>\n#include<deque>\n#include<set>\n#define LL long long\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPA(i,n) for(int i=1;i<(n);++i)\n#define PII pair<int,int>\n#define PLI pair<long long, int>\n#define PLL pair<long long, long long>\n#define MOD ((int)1e9 + 7)\n#define INF ((int)1e9)\n#define INFLL ((LL)1e18)\n#define ALL(x) (x).begin(),(x).end()\n#define ctoi(x) (x - 'a') \n#define CTOI(x) (x - 'A')\n#define BIT(x) (1 << (x))\nusing namespace std;\n\nLL modinv(LL a){\n    LL b = MOD, u = 1, v = 0;\n    while(b){\n        LL t = a / b;\n        a -= t * b;swap(a, b);\n        u -= t * v;swap(u, v);\n    }\n    u%=MOD;\n    if(u < 0) u += MOD;\n    return u;\n\n}\nbool checker(int a, int b, vector<vector<int> > &win){\n    bool flag = a < b;\n    if(a<b)swap(a, b);\n    return flag != win[a][b];\n}\nint main(){\n    int N;\n    cin >> N;\n    //challenger adsf;\n    vector<vector<int> > win(N+3, vector<int>(N+3, 0));\n    vector<int> check(N, -1);\n    REP(i, N-1){\n        REP(j, i+1){\n            char d;\n            cin >> d;\n            win[i+1][j] = d-'0';\n        }\n    }\n    int ans = 0;\n    REP(i, N){\n        int count = 0;\n        queue<int> que;\n        REP(j, N){\n            if(i==j)continue;\n            if(checker(i, j, win)){\n                ++count;\n                check[j]=i;\n                que.push(j);\n            }\n        }\n        while(!que.empty()){\n            int d = que.front();\n            que.pop();\n            REP(j, N){\n                if(j==i)continue;\n                if(check[j]==i)continue;\n                int a = d;\n                int b = j;\n                if(a==b)continue;\n                if(a<b)swap(a, b);\n                if(a > i && i > b)continue;\n                if(checker(d, j, win)){\n                    ++count;\n                    check[j]=i;\n                    que.push(j);\n                }\n            }\n        }\n        if(count + 1==N){\n            ++ans;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MX=2000;\n\nbool A[MX][MX]={};\nbool dp[MX][MX]={};\nbool dp2[MX][MX]={};\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    for(int i=0;i<n;i++){\n        dp[i][i]=dp2[i][i]=true;\n        for(int j=0;j<i;j++){\n            scanf(\" %c\",&c);\n            if(c=='1'){A[i][j]=true;}\n            A[j][i]=!A[i][j];\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;i+j<n;j++){\n            int R=i+j;\n            int l=j+1;\n            bool j1=false;\n            for(int k=j+1;k<=R && !j1;k++){\n                j1|=A[j][k] & dp[l][k] & dp2[R][k];\n            }\n            dp2[R][j]=j1;\n        }\n        for(int j=i;j<n;j++){\n            int R=j-i;\n            int l=j-1;\n            bool j1=false;\n            for(int k=R;k<j && !j1;k++){\n                j1|=A[j][k] & dp2[l][k] & dp[R][k];\n            }\n            dp[R][j]=j1;\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++){\n        if(dp[0][i] && dp2[n-1][i]){ans++;}\n    }\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\nuniform_int_distribution<> DD(0, 1000000000);\n\nll random(ll r){\n    return (ll(DD(eng))*1000000000 + ll(DD(eng)))%r;\n}\n\nll n,m,T,k,q;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\nconst ll MAXN = 10 + 0*2001;\n\nbool win[MAXN][MAXN] = {0};\n\nbool DPL[MAXN][MAXN] = {0};\nbool DPR[MAXN][MAXN] = {0};\n\nvector<bitset<MAXN> > BR;\nvector<bitset<MAXN> > BL;\nvector<bitset<MAXN> > WINR;\nvector<bitset<MAXN> > WINL;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n   // freopen(\"autput.txt\",\"w\",stdout);\n\n    ll a,b,c,d;\n\n    cin >> n;\n    string s;\n    for(int c1 = 0; c1 < n; c1++){\n        bitset<MAXN> temp1;\n        bitset<MAXN> temp2;\n        bitset<MAXN> temp3;\n        bitset<MAXN> temp4;\n        BR.push_back(temp1);\n        BL.push_back(temp2);\n        WINR.push_back(temp3);\n        WINL.push_back(temp4);\n        if(c1 < n-1)cin >> s;\n        for(int c2 = 0; c2 < c1; c2++){\n          //  cin >> a;\n            a = s[c2]-'a';\n            win[c1][c2] = a;\n            win[c2][c1] = (a^1);\n        }\n        //win[c1][c1] = 1;\n    }\n\n    for(int c1 = 0; c1 < n; c1++){\n\n        for(int c2 = c1; c2 < n; c2++){\n            WINR[c1][c2] = win[c1][c2];\n        }\n        for(int c2 = 0; c2 < c1; c2++){\n            WINL[c1][c2] = win[c1][c2];\n        }\n        BR[c1][c1] = 1;\n        BL[c1][c1] = 1;\n        DPL[c1][c1] = 1;\n        DPR[c1][c1] = 1;\n    }\n\n    for(int L = 2; L <= n; L++){\n        bitset<MAXN> LB;\n        for(int c1 = 0; c1 < L; c1++){\n            LB[c1] = 1;\n        }\n        for(int c1 = 0; c1 < n-L+1; c1++){\n\n            DPL[c1][c1+L-1] = ((WINR[c1] & BL[c1+L-1] & BR[c1+1]).count() != 0);\n            DPR[c1][c1+L-1]= ((WINL[c1+L-1] & BL[c1+L-2] & BR[c1]).count() != 0);\n          //  cerr << WINR[c1] << \" \" << BL[c1+L-1] << \" \"<< BR[c1+1] << \"\\n\";\n            (LB <<= 1);\n        }\n\n        for(int c1 = 0; c1 < n-L; c1++){\n            BR[c1][c1+L-1] = DPR[c1][c1+L-1];\n            BL[c1][c1+L-1] = DPL[c1][c1+L-1];\n        }\n\n    }\n/*\n    for(int c1 = 0; c1 < n; c1++){\n        for(int c2 = 0; c2 < n; c2++){\n            cerr << DPR[c1][c2];\n        }cerr << \"\\n\";\n    }\n*/\n    ll ans = 0;\n\n    for(int c1 = 0; c1 < n; c1++){\n        if(DPL[c1][n-1]&DPR[0][c1])ans++;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint main(){\n    int N;\n    cin>>N;\n    vector<string> S(N);\n    vector<vector<int>> to(N);\n    for(int i=1;i<N;i++){\n            cin>>S[i];\n            for(int j=0;j<i;j++){\n                if(S[i][j]=='1') to[i].push_back(j);\n                if(S[i][j]=='0') to[j].push_back(i);\n            }\n    }\n    int ans=0;\n    for(int i=0;i<N;i++){\n        vector<bool> d(N,false);\n        queue<int> que;\n        que.push(i);\n        d[i]=true;\n        bool kateru=false;\n        for(int j=0;j<to[i].size();j++){\n                int v=to[i][j];\n                if(d[v]) continue;\n                d[v]=true;\n                que.push(v);\n            }\n        while(!que.empty()){\n            int p=que.front();que.pop();\n            for(int j=0;j<to[p].size();j++){\n                int v=to[p][j];\n                if(d[v]) continue;\n                d[v]=true;\n                que.push(v);\n                if(abs(v-p)==1){\n                    kateru=true;\n                }\n            }\n            if(kateru){\n                ans++;\n                break;\n            }\n        }\n    }\n    cout<< ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e6+3)\n\nll N,A[2222][2222];\nchar a[2222];\nll btrR[2222][2222], btrL[2222][2222];\nlist<ll> rlst[2222];\nll i, j, k, ans;\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        scanf(\"%s\", a);\n        fornum(j,0,i){\n            A[i + 1][j + 1] = a[j]=='1';\n            A[j + 1][i + 1] = a[j]=='0';\n        }\n    }\n    btrR[N][N] = 1;\n    for (i = N; i > 0;i--){\n        for (j = i + 1; j <= N;j++){\n            if(btrR[i+1][j]){\n                if(A[i][j]){\n                    btrR[i][i] = 1;\n                }else{\n                    btrR[i][j] = 1;\n                }\n            }\n        }\n        ll ii = i;\n        for (j = i + 1; j <= N;j++){\n            if(A[j][ii]){\n                if(btrR[j][j]){\n                    btrR[i][j] = 1;\n                }\n                ii = j;\n            }\n        }\n    }\n    btrL[1][1] = 1;\n    for (i = 1; i <= N;i++){\n        for (j = 1; j <i ;j++){\n            if(btrL[i-1][j]){\n                if(A[i][j]){\n                    btrL[i][i] = 1;\n                }else{\n                    btrL[i][j] = 1;\n                }\n            }\n        }\n        ll ii = i;\n        for (j =i-1; j >=1;j--){\n            if(A[j][ii]){\n                if(btrL[j][j]){\n                    btrL[i][j] = 1;\n                }\n                    ii = j;\n            }\n        }\n    }\n    /*\n    fornum(i,1,N+1){\n        fornum(j,1,N+1){\n            printf(\"%lld:%lld \", btrL[i][j], btrR[i][j]);\n        }\n        printf(\"\\n\");\n    }*/\n    fornum(i,1,N+1){\n        ll aa = 0, bb = 0;\n        if(btrL[i][i]*btrR[i][i]==1)\n            ans++;\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n//*\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconstexpr ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\ninline bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\ninline bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\nconstexpr int N = 2000;\nint dp[N][N]; // left win\nbool A[N][N];\nint n;\n\n// left win\nint rec(int a, int b){\n  if(dp[a][b] != -1) return dp[a][b];\n  if(a < b) for(int i = a + 1; i <= b; i++){\n    if(A[a][i] & rec(i, b)){\n      for(int j = a; j < i; j++){\n        if(rec(a, j) & rec(i, j+1)){\n          return dp[a][b] = 1;\n        }\n      }\n    }\n  }\n  else for(int i = a - 1; i >= b; i--){\n    if(A[a][i] & rec(i, b)){\n      for(int j = a; j > i; j--){\n        if(rec(a, j) & rec(i, j-1)){\n          return dp[a][b] = 1;\n        }\n      }\n    }\n  }\n  return dp[a][b] = 0;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  cin >> n;\n  assert(n <= N);\n  char ch;\n  repr(i, 1, n)rep(j, i){\n    cin >> ch;\n    A[i][j] = ch == '1';\n    A[j][i] = !A[i][j];\n  }\n  memset(dp, -1, sizeof(int) * N*N);\n  rep(i, N) dp[i][i] = 1;\n  \n  int ans = 0;\n  rep(i, n){\n    ans += rec(i, 0) & rec(i, n-1);\n  }\n  print(ans);\n  /*\n  rep(i, n)rep(j, n){\n    rec(i, j);\n  }\n  rep(i, n){\n    rep(j, n){\n      cout << setw(3) << right << A[i][j];\n    }\n    cout << \"\\n\";\n  }\n  cout << \"\\n\";\n  rep(i, n){\n    rep(j, n){\n      cout << setw(3) << right << dp[i][j];\n    }\n    cout << \"\\n\";\n  }\n  cout << \"\\n\";\n  */\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    bool A[2020][2020];\n    for (int n = 1; n < N; ++n) {\n        string s;\n        cin >> s;\n        for (int m = 0; m < n; ++m) {\n            A[n][m] = s[m] == '1';\n        }\n    }\n    \n    bool DP[2020][2020];\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = true;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            for (int k = i+1; k <= i+d; ++k) {\n                bool b = !A[k][i] & DP[k][i+1] & DP[k][i+d];\n                if (b) {\n                    DP[i][i+d] = true;\n                    break;\n                }\n            }\n            for (int k = i; k < i+d; ++k) {\n                bool b = A[i+d][k] & DP[k][i] & DP[k][i+d-1];\n                if (b) {\n                    DP[i+d][i] = true;\n                    break;\n                }\n            }\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[n][0] && DP[n][N-1]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\ntypedef long long ll;\n\nbool g[2005][2005];\nbool dp1[2005][2005]; // dp1[i][j]: [i,j]でjが勝てる\nbool dp2[2005][2005]; // dp2[j][i]: [i,j]でiが勝てる\n\nchar buf[3000];\nint main(void) {\n  int n = 2000;\n  scanf(\"%d\", &n);\n  REP(i, n-1) {\n    scanf(\"%s\", buf);\n    REP(j, i+1) {\n      bool b;\n      b = buf[j] == '1';\n      g[i+1][j] = b;\n      g[j][i+1] = !b;\n    }\n  }\n  REP(i, n) {\n    g[i][i] = true;\n    dp1[i][i] = true;\n    dp2[i][i] = true;\n  }\n  for(int d = 1; d < n; ++d) {\n    REP(i, n-d) {\n      int j = i + d;\n      for(int k = i; k < j; ++k) {\n        dp1[i][j] |= g[j][k] & dp1[i][k] & dp2[j-1][k];\n      }\n      for(int k = i+1; k <= j; ++k) {\n        dp2[j][i] |= g[i][k] & dp1[i+1][k] & dp2[j][k];\n      }\n    }\n  }\n  int res = 0;\n  REP(i, n) {\n    if(dp1[0][i] & dp2[n-1][i]) {\n      ++res;\n    }\n  }\n  \n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint m[2020][2020];\nbool dp[2][2020][2020];\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tchar z;\n\t\t\tscanf(\" %c\", &z);\n\t\t\tint t = z - '0';\n\t\t\tm[i][j] = t, m[j][i] = 1 - t;\n\t\t}\n\t}\n\tfor (int i = 0; i < num; i++)dp[0][i][i] = dp[1][i][i] = true;\n\tfor (int k = 1; k < num; k++)\n\t{\n\t\tfor (int i = 0; i < num - k; i++)\n\t\t{\n\t\t\tint j = i + k;\n\t\t\tbool f1 = false, f2 = false;\n\t\t\tfor (int l = i; l < j; l++)f1 |= dp[1][i][l] & dp[0][l][j - 1] & m[j][l];\n\t\t\tfor (int l = i + 1; l <= j; l++)f2 |= dp[1][i + 1][l] & dp[0][l][j] & m[i][l];\n\t\t\tdp[0][i][j] = f2, dp[1][i][j] = f1;\n\t\t}\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < num; i++)c += dp[1][0][i] & dp[0][i][num - 1];\n\tprintf(\"%d\\n\", c);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e6+3)\n\nll N,A[2222][2222];\nchar a[2222];\nll btrR[2222][2222], btrL[2222][2222];\nlist<ll> rlst[2222];\nll i, j, k, ans;\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,1,N){\n        scanf(\"%s\", a);\n        fornum(j,0,i){\n            A[i + 1][j + 1] = a[j]=='1';\n            A[j + 1][i + 1] = a[j]=='0';\n        }\n    }\n    btrR[N][N] = 1;\n    for (i = N; i > 0;i--){\n        for (j = i + 1; j <= N;j++){\n            if(btrR[i+1][j]){\n                if(A[i][j]){\n                    btrR[i][i] = 1;\n                }else{\n                    btrR[i][j] = 1;\n                }\n            }\n        }\n        ll ii = i;\n        for (j = i + 1; j <= N;j++){\n            if(A[j][ii]){\n                if(btrR[j][j]){\n                    btrR[i][j] = 1;\n                }\n                ii = j;\n            }\n        }\n        btrR[i][ii] = 1;\n    }\n    btrL[1][1] = 1;\n    for (i = 1; i <= N;i++){\n        for (j = 1; j <i ;j++){\n            if(btrL[i-1][j]){\n                if(A[i][j]){\n                    btrL[i][i] = 1;\n                }else{\n                    btrL[i][j] = 1;\n                }\n            }\n        }\n        ll ii = i;\n        for (j =i-1; j >=1;j--){\n            if(A[j][ii]){\n                if(btrL[j][j]){\n                    btrL[i][j] = 1;\n                }\n                    ii = j;\n            }\n        }\n        btrL[i][ii] = 1;\n    }\n    /*\n    fornum(i,1,N+1){\n        fornum(j,1,N+1){\n            printf(\"%lld:%lld \", btrL[i][j], btrR[i][j]);\n        }\n        printf(\"\\n\");\n    }*/\n    fornum(i,1,N+1){\n        ll aa = 0, bb = 0;\n        if(btrL[i][i]*btrR[i][i]==1)\n            ans++;\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    int N;\n    //cin>>N;\n    scanf(\"%d\", &N);\n    //vector<vector<bool>> A(N, vector<bool>(N));\n    static bool A[2048][2048];\n    for (int i=1; i<N; i++)\n    {\n        //string t;\n        //cin>>t;\n        for (int j=0; j<i; j++)\n        {\n            char c;\n            scanf(\" %c\", &c);\n            A[i][j] = c!='0';\n            A[j][i] = !A[i][j];\n        }\n    }\n\n    //vector<vector<bool>> L(N, vector<bool>(N));\n    //vector<vector<bool>> R(N, vector<bool>(N));\n    static bool L[2048][2048];\n    static bool R[2048][2048];\n    for (int i=0; i<N; i++)\n        L[i][i] = R[i][i] = true;\n\n    /*\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n                for (int j=i+1; j<N; j++)\n                    if (A[i][j] && L[j][i+d] && R[j][i+1])\n                        L[i][i+d] = true;\n\n            if (0<=i-d)\n                for (int j=0; j<i; j++)\n                    if (A[i][j] && L[j][i-1] && R[j][i-d])\n                        R[i][i-d] = true;\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[i][N-1] && R[i][0])\n            ans += 1;\n    */\n\n\n    for (int d=1; d<N; d++)\n        for (int i=0; i<N; i++)\n        {\n            if (i+d<N)\n            {\n                auto &l = L[i+d];\n                auto &r = R[i+1];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i+1; j<=i+d; j++)\n                    b |= a[j] & l[j] & r[j];\n                L[i+d][i] = b;\n            }\n\n            if (0<=i-d)\n            {\n                auto &l = L[i-1];\n                auto &r = R[i-d];\n                auto &a = A[i];\n                bool b = false;\n                for (int j=i-d; j<i; j++)\n                    b |= a[j] & l[j] & r[j];\n                R[i-d][i] = b;\n            }\n        }\n\n    int ans = 0;\n    for (int i=0; i<N; i++)\n        if (L[N-1][i] && R[0][i])\n            ans += 1;\n\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n//*\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconstexpr ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\ninline bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\ninline bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\nconstexpr int N = 50;\nint dp[N][N][N];\nbool A[N][N];\nint n;\n\nint rec(int a, int b, int c){\n  if(dp[a][b][c] != -1) return dp[a][b][c];\n  repr(i, a, b){\n    if(A[b][i]){\n      repr(j, i, b){\n        if(rec(a, i, j) & rec(j+1, b, c)){\n          return dp[a][b][c] = 1;\n        }\n      }\n    }\n  }\n  repr(i, b+1, c+1){\n    if(A[b][i]){\n      repr(j, b, i){\n        if(rec(a, b, j) & rec(j+1, i, c)){\n          return dp[a][b][c] = 1;\n        }\n      }\n    }\n  }\n  return dp[a][b][c] = 0;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  cin >> n;\n  assert(n <= N);\n  char ch;\n  repr(i, 1, n)rep(j, i){\n    cin >> ch;\n    A[i][j] = ch == '1';\n    A[j][i] = !A[i][j];\n  }\n  memset(dp, -1, sizeof(int) * N*N*N);\n  rep(i, N) dp[i][i][i] = 1;\n  int ans = 0;\n  rep(i, n){\n    ans += rec(0, i, n-1);\n  }\n  print(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<bitset>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void write(int x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nbitset<2010>f[2010],g[2010],p[2010];\nchar ss[2010];\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n=read();\n    for(int i=2;i<=n;i++)\n    {\n    \tscanf(\"%s\",ss+1);\n    \tfor(int j=1;j<i;j++)\n    \t{\n    \t\tif(ss[j]=='0')p[j][i]=1;\n    \t\telse p[i][j]=1;\n    \t}\n    }\n    for(int i=1;i<=n;i++)f[i][i]=1,g[i][i]=1;\n    for(int d=2;d<=n;d++)\n    {\n    \tfor(int l=1;l+d-1<=n;l++)\n    \t{\n    \t\tint r=l+d-1;\n    \t\tg[r][l]=(g[r]&f[l+1]&p[l]).any();\n    \t\tf[l][r]=(f[l]&g[r-1]&p[r]).any();\n    \t}\n    }\n    pr2((g[n]&f[1]).count());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) begin(x), end(x)\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\n/**\n * Brute DP:\n *\n * dp[i][j][k] is can player i win range [j..k] ?\n * dp[i][i][i] = true\n *\n * dp[i][j][k] = l[i][j] and r[i][k]\n * l[i][j] can player i win against the prefix before him to j?\n * possible if there's some player j <= k < i where l[k][j] and r[k][j - 1]\n *\n * Use bitmasks? O(n^3 / 64)? \n */\n\nusing bs = bitset<2000>;\nconstexpr int MAXN = 2002;\nbs a[MAXN];\nbs l[MAXN], r[MAXN];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        l[i].set(i);\n        r[i].set(i);\n    }\n\n    for (int i = 1; i < n; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < i; ++j) {\n            if (s[j] == '1') {\n                a[i].set(j);\n            } else {\n                a[j].set(i);\n            }\n        }\n    }\n    for (int d = 1; d <= n; ++d) {\n        for (int i = 0; i + d < n; ++i) {\n            int j = i + d;\n            if ((a[j] & l[i] & r[j - 1]).any()) {\n                l[i].set(j);\n            }\n        }\n\n        for (int i = d; i < n; ++i) {\n            int j = i - d;\n            if ((a[j] & l[j + 1] & r[i]).any()) {\n                r[i].set(j);\n            }\n        }\n    }\n\n    int ans = (l[0] & r[n - 1]).count();\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000003;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nbool b[2000][2000];\n\nbool le[2000][2000], ri[2000][2000];\nvoid solve() {\n\tint n; cin >> n;\n\trep1(i, n - 1) {\n\t\trep(j, i) {\n\t\t\tchar t; cin >> t;\n\t\t\tif (t == '1') {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n)le[i][i] = ri[i][i] = true;\n\n\tint ans = 0;\n\tRep1(i, 2, n) {\n\t\trep(j, n - i + 1) {\n\t\t\tint l = j;\n\t\t\tint r = j + i - 1;\n\t\t\tbool fl = false, fr = false;\n\t\t\tRep1(k, l + 1, r) {\n\t\t\t\tfl |= b[l][k] & ri[l + 1][k] & le[r][k];\n\t\t\t}\n\t\t\tRep(k, l, r) {\n\t\t\t\tfr |= b[r][k] & ri[l][k] & le[r - 1][k];\n\t\t\t}\n\t\t\tle[r][l] = fl, ri[l][r] = fr;\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (ri[0][i] && le[n - 1][i])ans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n//*\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconstexpr ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\ninline bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\ninline bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\nconstexpr int N = 400;\nint dp[N][N][N];\nbool A[N][N];\nint n;\n\nint rec(int a, int b, int c){\n  if(dp[a][b][c] != -1) return dp[a][b][c];\n  repr(i, a, b){\n    if(A[b][i]){\n      repr(j, i, b){\n        if(rec(a, i, j) & rec(j+1, b, c)){\n          return dp[a][b][c] = 1;\n        }\n      }\n    }\n  }\n  repr(i, b+1, c+1){\n    if(A[b][i]){\n      repr(j, b, i){\n        if(rec(a, b, j) & rec(j+1, i, c)){\n          return dp[a][b][c] = 1;\n        }\n      }\n    }\n  }\n  return dp[a][b][c] = 0;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  cin >> n;\n  assert(n <= N);\n  char ch;\n  repr(i, 1, n)rep(j, i){\n    cin >> ch;\n    A[i][j] = ch == '1';\n    A[j][i] = !A[i][j];\n  }\n  memset(dp, -1, sizeof(int) * N*N*N);\n  rep(i, N) dp[i][i][i] = 1;\n  int ans = 0;\n  rep(i, n){\n    ans += rec(0, i, n-1);\n  }\n  print(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000003;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nbool b[2000][2000];\n\nbool le[2000][2000], ri[2000][2000];\nvoid solve() {\n\tint n; cin >> n;\n\trep1(i, n - 1) {\n\t\trep(j, i) {\n\t\t\tchar t; cin >> t;\n\t\t\tif (t == '1') {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n)le[i][i] = ri[i][i] = true;\n\n\tint ans = 0;\n\tRep1(i, 2, n) {\n\t\trep(j, n - i + 1) {\n\t\t\tint l = j;\n\t\t\tint r = j + i - 1;\n\t\t\tRep1(k, l + 1, r) {\n\t\t\t\tif (b[l][k] && ri[l + 1][k] && le[r][k]) {\n\t\t\t\t\tle[r][l] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRep(k, l, r) {\n\t\t\t\tif (b[r][k] && ri[l][k] && le[r - 1][k]) {\n\t\t\t\t\tri[l][r] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (ri[0][i] && le[n - 1][i])ans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, res;\nchar c;\nset<int>st[2000];\nset<int>::iterator IT[2000];\nmap<pair<int, pair<int, int>>, int>mp;\n\nbool f(int x, int l, int r) {\n\tif (mp.find(mkp(x, mkp(l, r))) != mp.end())return mp[mkp(x, mkp(l, r))];\n\tmp[mkp(x, mkp(l, r))] = 1;\n\tif (x == l&&x == r)return true;\n\telse if (x == l) {\n\t\tauto it = IT[x];\n\t\t++it;\n\t\twhile (*it <= r) {\n\t\t\tif (f(*it, x + 1, r))return true;\n\t\t\t++it;\n\t\t}\n\t}\n\telse if (x == r) {\n\t\tauto it = IT[x];\n\t\t--it;\n\t\twhile (*it >= l) {\n\t\t\tif (f(*it, l, x - 1))return true;\n\t\t\t--it;\n\t\t}\n\t}\n\telse {\n\t\tauto it = IT[x];\n\t\tbool F = false;\n\t\t++it;\n\t\twhile (*it <= r) {\n\t\t\tif (f(*it, x + 1, r)) {\n\t\t\t\tF = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++it;\n\t\t}\n\t\tif (F) {\n\t\t\tit = IT[x];\n\t\t\t--it;\n\t\t\twhile (*it >= l) {\n\t\t\t\tif (f(*it, l, x - 1))return true;\n\t\t\t\t--it;\n\t\t\t}\n\t\t}\n\t}\n\tmp[mkp(x, mkp(l, r))] = 0;\n\treturn false;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tcin >> c;\n\t\t\tif (c == '1') {\n\t\t\t\tst[i].insert(j);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst[j].insert(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tst[i].insert(-1);\n\t\tIT[i] = st[i].insert(i).first;\n\t\tst[i].insert(N);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tres += f(i, 0, N - 1);\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n, i, j, k, lg, nr;\nchar a[2005][2005];\nint ds[2005][2005], dd[2005][2005];\nint main(){\n    cin>> n;\n    for(i = 2; i <= n; i++){\n        for(j = 1; j < i; j++){\n            cin>> a[i][j];\n            a[i][j] -= '0';\n            a[j][i] = 1 - a[i][j];\n        }\n    }\n    for(i = 1; i <= n; i++){\n        ds[i][i] = dd[i][i] = 1;\n    }\n    for(lg = 2; lg <= n; lg++){\n        for(i = 1; i <= n - lg + 1; i++){\n            j = i + lg - 1;\n            for(k = i + 1; k <= j; k++){\n                if(a[i][k] == 1 && dd[i + 1][k] == 1 && ds[k][j] == 1){\n                    ds[i][j] = 1;\n                    break;\n                }\n            }\n            for(k = i; k < j; k++){\n                if(a[j][k] == 1 && dd[i][k] == 1 && ds[k][j - 1] == 1){\n                    dd[i][j] = 1;\n                    break;\n                }\n            }\n        }\n    }\n    for(i = 1; i <= n; i++){\n        if(dd[1][i] == 1 && ds[i][n] == 1){\n            nr++;\n        }\n    }\n    cout<< nr;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n; std::cin >> n;\n  auto a = std::vector<std::vector<bool>>(n + 2, std::vector<bool>(n + 2, false));\n  auto insert = [&] (size_t i, size_t j, bool k) {\n    a[i][j] = k;\n    a[j][i] = !k;\n  };\n  for (size_t i = 1; i <= n; i++) {\n    insert(i, 0, true);\n    insert(i, n + 1, true);\n  }\n  for (size_t i = 2; i <= n; i++) {\n    for (size_t j = 1; j < i; j++) {\n      char x; std::cin >> x;\n      insert(i, j, x == '1');\n    }\n  }\n  auto dp = std::vector<std::vector<bool>>(n + 2, std::vector<bool>(n + 2, false));\n  for (size_t i = 0; i <= n; i++) dp[i][i + 1] = dp[i + 1][i] = true;\n  for (size_t d = 2; d <= n + 1; d++) {\n    for (size_t i = 0, j = d; j <= n + 1; i++, j++) {\n      bool tmp = false;\n      for (size_t k = i + 1; k < j; k++) {\n        tmp |= dp[i][k] & dp[j][k] & (a[i][k] | a[j][k]);\n      }\n      dp[j][i] = dp[i][j] = tmp;\n    }\n  }\n  int ret = 0;\n  for (size_t i = 1; i <= n; i++) {\n    if (dp[0][i] & dp[i][n + 1]) ret++;\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define go(u) for(int i = head[u], v = e[i].to; i; i=e[i].lst, v=e[i].to)\n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define pb push_back\n#define re(x) memset(x, 0, sizeof x)\ninline int gi() {\n    int x = 0,f = 1;\n    char ch = getchar();\n    while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar();}\n    while(isdigit(ch)) { x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}\n    return x * f;\n}\ntemplate <typename T> inline bool Max(T &a, T b){return a < b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool Min(T &a, T b){return a > b ? a = b, 1 : 0;}\nconst int N = 2007;\nint n, ans;\nbitset<N>defeat[N], R[N], L[N];\nchar s[N];\nint main() {\n#ifdef fwat\n#endif\n\tn = gi();\n\trep(i, 2, n) {\n\t\tscanf(\"%s\", s + 1);\n\t\trep(j, 1, i - 1) {\n\t\t\tint x = s[j] - '0';\n\t\t\tdefeat[i][j] = x;\n\t\t\tdefeat[j][i] = x ^ 1;\n\t\t}\n\t}\n\trep(i, 1, n) R[i][i] = L[i][i] = 1;\n\t\n\trep(len, 2, n) {\n\t\trep(l, 1, n - len + 1) {\n\t\t\tint r = l + len - 1;\n\t\t\tif((R[l + 1] & L[r] & defeat[l]).any()) L[r][l] = 1;\n\t\t\tif((R[l] & L[r - 1] & defeat[r]).any()) R[l][r] = 1;\n\t\t}\n\t}\n\trep(i, 1, n) if(R[1][i] && L[n][i]) ++ans;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbool win[2001][2001];\nbool dp[2][2001][2001];\nsigned main() {\n    int N; cin >> N;\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[0][i][i] = dp[1][i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            for(int k=i+1; k<=j; k++) {\n                dp[0][j][i] |= win[i][k] and dp[0][j][k] and dp[1][i+1][k];\n            }\n            for(int k=i; k<j; k++) {\n                dp[1][i][j] |= win[j][k] and dp[1][i][k] and dp[0][j-1][k];\n            }\n            // fprintf(stderr, \"dp[0][%lld][%lld] = %lld, dp[1][%lld][%lld] = %lld\\n\", i, j, dp[0][i][j], j, i, dp[1][j][i]);\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dp[0][N-1][i] and dp[1][0][i]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : F2.cpp\n * Author  : Kazune Takahashi\n * Created : 2019-6-2 00:47:04\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n\ntypedef long long ll;\n\nbitset<2010> dp_L[2010];\nbitset<2010> dp_R[2010];\nbitset<2010> W[2010];\n\nint main()\n{\n  int N;\n  cin >> N;\n  for (auto i = 1; i < N; i++)\n  {\n    string S;\n    cin >> S;\n    for (auto j = 0; j < i; j++)\n    {\n      if (S[j] == '0')\n      {\n        W[j][i] = 1;\n      }\n      else\n      {\n        W[i][j] = 1;\n      }\n    }\n  }\n  for (auto i = 0; i < N; i++)\n  {\n    dp_L[i][i] = 1;\n    dp_R[i][i] = 1;\n  }\n  for (auto n = 1; n < N; n++)\n  {\n    for (auto a = 0; a + n < N; a++)\n    {\n      int b = a + n;\n      if ((dp_R[a + 1] & dp_L[b] & W[a]).any())\n      {\n        dp_L[b][a] = 1;\n      }\n      if ((dp_R[a] & dp_L[b - 1] & W[b]).any())\n      {\n        dp_R[a][b] = 1;\n      }\n    }\n  }\n  int ans = (dp_R[0] & dp_L[N - 1]).count();\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar ch[2010][2010];\n\nint n;\n\nbool B[2010][2010];\n\nint Ans[2010][2010][2];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 2; i <= n; i++) scanf(\"%s\", ch[i] + 1);\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; j < i; j++)\n\t\t\t(B[i][j] = ch[i][j] - '0'), B[j][i] = !B[i][j];\n\tfor(int i = 1; i <= n; i++) Ans[i][i][0] = (Ans[i][i][1] = 1);\n\tfor(int i = 1; i < n; i++)\n\t\tif(B[i][i + 1]) Ans[i][i + 1][0] = 1, Ans[i + 1][i][1] = 1; else Ans[i][i + 1][1] = 1, Ans[i + 1][i][0] = 1;\n\tfor(int i = 2; i <= n; i++)\n\t\tfor(int j = 1; i + j <= n; j++) {\n\t\t\tint l = j, r = i + j;\n\t\t\tfor(int k = l + 1; k <= r; k++) if(B[l][k] && Ans[l + 1][k][1] && Ans[r][k][0]) {Ans[l][r][0] = 1; break;}\n\t\t\tfor(int k = l; k < r; k++) if(B[r][k] && Ans[l][k][1] && Ans[r - 1][k][0]) {Ans[l][r][1] = 1; break;}\n\t\t\tAns[r][l][0] = Ans[l][r][1];\n\t\t\tAns[r][l][1] = Ans[l][r][0];\n\t\t}\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i++) tot += Ans[1][i][1] && Ans[i][n][0];\n\tprintf(\"%d\\n\", tot);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\ntemplate<typename T> vector<T> make_vector(size_t sz){\n\treturn vector<T>(sz);\n}\n\ntemplate<typename T,typename... Ts> \nauto make_vector(size_t sz, Ts... ts){\n\treturn vector<decltype(make_vector<T>(ts...))>(sz, make_vector<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V> \ntypename enable_if<is_same<T, U>::value!=0>::type \nfill_value(U &u, const V... v){\n\tu=U(v...);\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_value(U &u, const V... v){\n\tfor(auto &e:u){\n\t\tfill_value<T>(e,v...);\n\t}\n}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nint A[2010][2010];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(j, 1, n){\n\t\tstring a;\n\t\tcin >> a;\n\t\trep(i, j){\n\t\t\tA[j][i] = (a[i] == '1');\n\t\t\tA[i][j] = 1 - A[j][i];\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\trep(i, n){\n\t\tbool ok = true;\n\t\t{\n\t\t\tvector<int> chain;\n\t\t\tchain.push_back(i);\n\t\t\tint enemy = -1;\n\n\t\t\trep(j, i + 1, n){\n\t\t\t\tif(enemy == -1 or A[j][enemy]){\n\t\t\t\t\tenemy = j;\n\t\t\t\t}\n\n\t\t\t\tif(A[chain.back()][enemy]){\n\t\t\t\t\tchain.push_back(j);\n\t\t\t\t\tenemy = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(enemy != -1 and chain.size()){\n\t\t\t\tif(A[chain.back()][enemy]){\n\t\t\t\t\tenemy = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchain.pop_back();\n\t\t\t}\n\n\t\t\tif(enemy != -1) ok = false;\n\t\t}\n\n\t\t{\n\t\t\tvector<int> chain;\n\t\t\tchain.push_back(i);\n\t\t\tint enemy = -1;\n\n\t\t\trrep(j, i){\n\t\t\t\tif(enemy == -1 or A[j][enemy]){\n\t\t\t\t\tenemy = j;\n\t\t\t\t}\n\n\t\t\t\tif(A[chain.back()][enemy]){\n\t\t\t\t\tchain.push_back(j);\n\t\t\t\t\tenemy = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(enemy != -1 and chain.size()){\n\t\t\t\tif(A[chain.back()][enemy]){\n\t\t\t\t\tenemy = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchain.pop_back();\n\t\t\t}\n\n\t\t\tif(enemy != -1) ok = false;\n\t\t}\n\n\t\tif(ok) ans++;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 2022, inf = 1000111222;\n\nchar buf[max_n];\nbitset<max_n> a[max_n], dp0[max_n], dp1[max_n], dp2[max_n];\n\nint n;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        scanf(\"%s\", buf);\n        for (int j = 0; j < i; ++j) {\n            a[i][j] = buf[j] - '0';\n            a[j][i] = 1 ^ a[i][j];\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        dp0[i][i] = 1;\n        dp1[i][i] = 1;\n        dp2[i][i] = 1;\n    }\n    for (int len = 2; len <= n; ++len) {\n        for (int l = 0; l + len <= n; ++l) {\n            int r = l + len - 1;\n            if (len == 2) {\n                dp2[l][r] = 1;\n            } else {\n                dp2[l][r] = (dp2[l] & dp2[r] & (a[l] | a[r])).any();\n            }\n            dp2[r][l] = dp2[l][r];\n\n            if (a[l][r] && dp2[l][r]) {\n                dp0[l][r] = 1;\n            } else {\n                dp0[l][r] = (a[l] & dp0[l] & dp0[r]).any();\n            }\n            dp0[r][l] = dp0[l][r];\n\n            if (a[r][l] && dp2[l][r]) {\n                dp1[l][r] = 1;\n            } else {\n                dp1[l][r] = (a[r] & dp1[l] & dp1[r]).any();\n            }\n            dp1[r][l] = dp1[l][r];\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        bool ok = dp1[0][i] & dp0[i][n - 1];\n        ans += ok;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1000003;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nconst int MAX_N = 2000;\n\nbool winL[MAX_N][MAX_N];\nbool winR[MAX_N][MAX_N];\nbool sumP[MAX_N][MAX_N];\n\n\nint main() {\n  int N;\n  cin >> N;\n  auto mat = make_v< int >(N, N);\n  for(int i = 1; i < N; i++) {\n    string s;\n    cin >> s;\n    for(int j = 0; j < i; j++) {\n      int x = (int) s[j] - '0';\n      mat[i][j] = x;\n      mat[j][i] = 1 - x;\n    }\n  }\n\n  for(int i = N - 1; i >= 0; i--) {\n    winL[i][i] = winR[i][i] = 1;\n    for(int j = i + 1; j < N; j++) {\n      sumP[i][j] = 0;\n      for(int p = i; p < j; p++) {\n        sumP[i][j] += winL[i][p] * winR[p + 1][j];\n      }\n      winL[i][j] = winR[i][j] = 0;\n      {  // winL\n        for(int k = i + 1; k <= j; k++) {\n          bool prob = mat[i][k];\n          winL[i][j] += prob * winL[k][j] * sumP[i][k];\n        }\n      }\n      {  // winR\n        for(int k = i; k < j; k++) {\n          bool prob = mat[j][k];\n          winR[i][j] += prob * winR[i][k] * sumP[k][j];\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    bool ans = winR[0][i] * winL[i][N - 1];\n    ret += ans > 0;\n  }\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbitset<2000> win[2001];\nbitset<2000> dp[2001][2001];\nsigned main() {\n    int N; cin >> N;\n    if(N > 600) return 1;\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            int p = c - '0';\n            win[i][j] = p;\n            win[j][i] = 1 - p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[i][i][i] = true;\n    for(int d=0; d<N-1; d++) {\n        for(int l=0; l<N-d; l++) {\n            int r = l + d;\n            for(int k=0; k<N; k++) {\n                if(l > 0 and l-1 != k) {\n                    if(win[k][l-1]) dp[l-1][r][k] = dp[l-1][r][k] or dp[l][r][k];\n                    else dp[l-1][r][l-1] = dp[l-1][r][l-1] or dp[l][r][k];\n                }\n                if(r+1 < N and r+1 != k) {\n                    if(win[k][r+1]) dp[l][r+1][k] = dp[l][r+1][k] or dp[l][r][k];\n                    else dp[l][r+1][r+1] = dp[l][r+1][r+1] or dp[l][r][k];\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += dp[0][N-1][i];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nint N;\nbool A[2010][2010];\nbool L[2010][2010];\nbool R[2010][2010];\n\nusing BS = bitset<2010>;\nV<BS> Rix(2010);\nV<BS> Lxi(2010);\nV<BS> Aix(2010);\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tcin >> N;\n\t{\n\t\tV<string> s(N);\n\t\trep1(i,N-1) cin >> s[i];\n\t\trep(i,N) rep(j,N){\n\t\t\tif(i>j) A[i][j] = s[i][j]=='1';\n\t\t\tif(j>i) A[i][j] = s[j][i]=='0'; \n\t\t}\n\t}\n\tif(false){\n\t\trep(i,N){\n\t\t\trep(j,N) cout << A[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t}\n\trep(i,N){\n\t\trep(j,N) if(A[i][j]) Aix[i].set(j);\n\t}\n\n\tfor(int d=1;d<=N;d++){\n\t\tfor(int l=0;l+d-1<N;l++){\n\t\t\tint r = l+d-1;\n\t\t\tif(d == 1){\n\t\t\t\tLxi[r].set(l);\n\t\t\t\tRix[l].set(r);\n\t\t\t\tL[l][r] = true;\n\t\t\t\tR[l][r] = true;\n\t\t\t}else{\n\t\t\t\t{\t//L\n\t\t\t\t\t// for(int x=l+1;x<=r;x++){\n\t\t\t\t\t// \tif(A[l][x] && R[l+1][x] && L[x][r]){\n\t\t\t\t\t// \t\tL[l][r] = true;\n\t\t\t\t\t// \t\tbreak;\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\tauto tmp = Aix[l] & Rix[l+1] & Lxi[r];\n\t\t\t\t\tif(tmp.any()) Lxi[r].set(l);\n\t\t\t\t}\n\t\t\t\t{\t//R\n\t\t\t\t\tfor(int x=l;x<r;x++){\n\t\t\t\t\t\tif(A[r][x] && L[x][r-1] && R[l][x]){\n\t\t\t\t\t\t\tR[l][r] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tauto tmp = Aix[r] & Rix[l] & Lxi[r-1];\n\t\t\t\t\tif(tmp.any()) Rix[l].set(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i,N) if(Rix[0][i] && Lxi[N-1][i]){\n\t\tans++;\n\t\tshow(i);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <queue>\n#include <map>\n#include <numeric>\n#include <functional>\n#include <math.h>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define INF ((int)1e9)\n#define INFLL ((ll)1e18)\n#define MOD (1000000007LL)\n\n\nint main(int argc, const char * argv[]) {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    bitset<2020> A[2020];\n    for (int n = 1; n < N; ++n) {\n        string s;\n        cin >> s;\n        for (int m = 0; m < n; ++m) {\n            A[n][m] = s[m]-'0';\n        }\n    }\n    \n    bitset<2020> DP[2020];\n    for (int n = 0; n < N; ++n) {\n        DP[n][n] = 1;\n    }\n    for (int d = 1; d <= N-1; ++d) {\n        for (int i = 0; i+d < N; ++i) {\n            int j = i+d;\n            bool b = false;\n            for (int k = i+1; k <= j; ++k) {\n                b |= !A[k][i] & DP[k][i+1] & DP[k][j];\n            }\n            DP[i][j] = b;\n            \n            b = false;\n            for (int k = i; k < j; ++k) {\n                b |= A[j][k] & DP[k][i] & DP[k][j-1];\n            }\n            DP[j][i] = b;\n        }\n    }\n    int Res = 0;\n    for (int n = 0; n < N; ++n) {\n        if (DP[n][0] & DP[n][N-1]) ++Res;\n    }\n    cout << Res << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbool grid[SZ][SZ];\nint sv[SZ][SZ], st[SZ][SZ];\nvector<ll> wn[SZ];\n\nbool find(int l, int r) {\n\tif (l == r - 1) return 1;\n\tif (sv[l][r] != -1) return sv[l][r];\n\n\tint ind;\n\tind = st[l][l];\n\twhile (ind < wn[l].size() && wn[l][ind] < r) {\n\t\tint i = wn[l][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tind = st[r][l];\n\twhile (ind < wn[r].size() && wn[r][ind] < r) {\n\t\tint i = wn[r][ind];\n\t\tbool fl1 = find(l, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, r)) {\n\t\t\t\tsv[l][r] = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\n\tsv[l][r] = 0;\n\treturn 0;\n}\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (int j = 0; j < n + 3; j++) {\n\t\t\tsv[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t\twn[i + 1].push_back(j + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t\twn[j + 1].push_back(i + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tsort(wn[i].begin(), wn[i].end());\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint curInd = wn[i].size();\n\t\tfor (int j = n + 1; j >= 0; j--) {\n\t\t\tif (curInd != 0 && wn[i][curInd - 1] > j) curInd--;\n\t\t\tst[i][j] = curInd;\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool fl1 = find(0, i);\n\t\tif (fl1) {\n\t\t\tif (find(i, n + 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    int n;\n    cin >> n;\n    vector<vector<bool>> a(n, vector<bool>(n));\n    rep1(i, n-1) rep(j, i) {\n        char ai;\n        cin >> ai;\n        a[i][j] = (ai=='1');\n        a[j][i] = !(ai=='1');\n    }\n    vector<bool> l(n), r(n);\n    r[n-1] = true;\n    repr(i, n-1) {\n        bool win = false;\n        for (int j=i+1; j<n; j++) {\n            if (r[j] && a[i][j]) win = true;\n        }\n        r[i] = win;\n    }\n    l[0] = true;\n    rep1(i, n-1) {\n        bool win = false;\n        for (int j=i-1; j>=0; j--) {\n            if (l[j] && a[i][j]) win = true;\n        }\n        l[i] = win;\n    }\n    int ans = 0;\n    rep(i, n) {\n        if (l[i] && r[i]) ++ans;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    int n;\n    cin >> n;\n    vs a(n-1);\n    rep(i, n-1) cin >> a[i];\n    vector<vector<bool>> win(n, vector<bool>(n));\n    rep1(i, n-1) rep(j, i) {\n        win[i][j] = (a[i-1][j] == '1');\n        win[j][i] = !(a[i-1][j] == '1');\n    }\n    vector<bitset<2005>> dpfl(n), dpfr(n), dpbl(n), dpbr(n);\n    rep(i, n) dpfl[i][i] = dpfr[i][i] = dpbl[i][i] = dpbr[i][i] = true;\n    rep1(i, n-1) rep(a, n-i) {\n        int b = a + i;\n        bool lok = false;\n        auto &nfl = dpfl[b], &nbl = dpbl[a], &nfr = dpfr[b], &nbr = dpbr[a];\n        if ((((nfl&nbl)>>(a+1))^((nfl&nbl)>>(a+i)<<(i-1))).any()) lok = true;\n        if (!lok && win[a][b]) {\n            if (((((nfr>>1)&nbl)>>a)^(((nfr>>1)&nbl)>>(a+i)<<i)).any()) lok = true;\n        }\n        nfl[a] = nbl[b] = lok;\n        bool rok = false;\n        if ((((nfr&nbr)>>(b-i+1))^((nfr&nbr)>>b<<(i-1))).any()) rok = true;\n        if (!rok && win[b][a]) {\n            if (((((nfr>>1)&nbl)>>(b-i))^(((nfr>>1)&nbl)>>b<<i)).any()) rok = true;\n        }\n        nfr[a] = nbr[b] = rok;\n    }\n    int ans = 0;\n    rep(i, n) if (dpbr[0][i] && dpfl[n-1][i]) ++ans;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2 vector<vec>\n#define vecll2 vector<vecll>\n#define vec3 vector<vec2d>\n#define vecll3 vector<vecll2d>\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(vector<T> v){for(T e:v)cout<<e<<\" \";cout<<endl;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\nvoid print(vector<vec> v){for(auto e:v){for(auto ee:e)cout<<ee<<\" \";cout<<endl;}}\nvoid print(map<int,int> mp){for(auto e:mp)cout<<e.first<<\" \"<<e.second<<endl;cout<<endl;}\n\n\nmain(){\n    int n=in();\n    vector<vec> g(n,vec(n));\n    rep2(i,1,n-1){\n        rep(j,i){\n            char c;cin>>c;\n            if(c=='0')g[j][i]=1;\n            else g[i][j]=1;\n        }\n    }\n    vector<bool> v(n);\n    vec p(n);\n    int sz=1;\n    v[0]=1;p[0]=0;\n    rep2(i,1,n-1){\n        int l=n,r=-1;\n        rep(j,i){\n            if(g[i][j])chmin(l,p[j]);\n            else chmax(r,p[j]);\n        }\n        if(l==n){\n            p[i]=sz++;\n        }\n        else if(r==-1){\n            rep(j,i)p[j]++;\n            p[i]=0;\n            sz++;\n        }\n        else if(l<=r){\n            rep(j,i){\n                if(l<=p[j] && p[j]<=r)p[j]=l;\n                if(p[j]>r) p[j]=p[j]-r+l;\n                chmax(sz,p[j]);\n            }\n            p[i]=l;\n            sz++;\n        }\n        else{\n            p[i]=l;\n            rep(j,i){\n                if(p[j]>=l)p[j]++;\n            }\n            sz++;\n        }\n        v[i]=(p[i]==0);\n    }\n    p=vec(n);\n    sz=1;\n    p[n-1]=0;\n    rep3(i,n-2,0){\n        int l=n,r=-1;\n        rep3(j,n-1,i+1){\n            if(g[i][j])chmin(l,p[j]);\n            else chmax(r,p[j]);\n        }\n        if(l==n){\n            p[i]=sz++;\n        }\n        else if(r==-1){\n            rep3(j,n-1,i+1)p[j]++;\n            p[i]=0;\n            sz++;\n        }\n        else if(l<=r){\n            rep3(j,n-1,i+1){\n                if(l<=p[j] && p[j]<=r)p[j]=l;\n                if(p[j]>r) p[j]=p[j]-r+l;\n                chmax(sz,p[j]);\n            }\n            p[i]=l;\n            sz++;\n        }\n        else{\n            p[i]=l;\n            rep3(j,n-1,i+1){\n                if(p[j]>=l)p[j]++;\n            }\n            sz++;\n        }\n        v[i]=v[i]&(p[i]==0);\n    }\n    int ans=0;\n    rep(i,n)ans+=v[i];\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bitset>\n\nint n;\nchar ch[2005][2048];\n\n// bs1 is inclusive, bs2 is exclusive\nstd::bitset<2048> bs1[2005],bs2[2005];\n\nvoid stuff(int i,int j)\n{\n    if ((bs2[i]&bs1[j]).any()) {\n        //printf(\"%d %d with %c\\n\",i,j,ch[j][i]);\n        // they overlap\n        if (ch[j][i]=='0') {\n            // i wins, j loses\n            //printf(\"%d wins, %d loses\\n\",i,j);\n            bs2[i]|=bs2[j];\n        }\n        else {\n            // i loses, j wins\n            //printf(\"%d loses, %d wins\\n\",i,j);\n            bs1[j]|=bs1[i];\n        }\n    }\n}\n\nint ans=0;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d\",&n);\n    for (int i=1; i<n; i++) {\n        for (int j=0; j<i; j++) {\n            scanf(\" %c\",&ch[i][j]);\n        }\n    }\n    for (int i=0; i<n; i++) {\n        bs1[i][i]=1;\n        bs2[i][i+1]=1;\n    }\n    // cheese this part\n    for (int i=0; i<11; i++)\n    for (int d=1; d<n; d++) {\n        for (int i=0; i+d<n; i++) {\n            stuff(i,i+d);\n        }\n    }\n    for (int i=0; i<n; i++) {\n        if (bs1[i][0] && bs2[i][n]) ans++;\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\n#define N 2019\nbitset<N> dp[N],d2[N],a[N];\nint main()\n{\n\tint n;string s;\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>s;\n\t\trep(j,i+1){\n\t\t\tif(s[j]=='0') a[j][i+1]=true;else a[i+1][j]=true;\n\t\t}\n\t}\n\t//rep(i,n) rep(j,n) cout<<i<<j<<a[i][j]<<endl;\n\trep(i,n) dp[i][i]=d2[i][i]=true;\n\tREP(j,1,n){\n\t\trep(i,n){\n\t\t\tint k=i+j;if(k>=n) continue;\n\t\t\tif((dp[i]&d2[k-1]&a[k]).any()) dp[i][k]=true;\n\t\t\tif((dp[i+1]&d2[k]&a[i]).any()) d2[k][i]=true;\n\t\t\t//cout<<i<<k<<dp[i][k]<<d2[k][i]<<endl;\n\t\t}\n\t}\n\tint out=0;\n\trep(i,n) if((dp[0][i]&d2[n-1][i])) out++;\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n//long long int N,M,K,L,R,H,W;\n\n//const long long int MOD=1000000007;\nconst long long int MOD=998244353;\n\nint main(){\n\t\n\tcin>>N;\n\tvector<bitset<2000>>v(N);\n\tfor(int i=1;i<N;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(s[j]=='1')v[i].flip(j);\n\t\t\telse v[j].flip(i);\n\t\t}\n\t}\n\tvector<bitset<2000>>l(N);\n\tvector<bitset<2000>>r(N);\n\tfor(int i=0;i<N;i++){\n\t\tl[i].flip(i);\n\t\tr[i].flip(i);\n\t}\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;i+j<N;j++){\n\t\t\tfor(int k=j+1;k<=i+j;k++){\n\t\t\t\tif(l[k][i+j]&&r[j+1][k]&&v[j][k]){\n\t\t\t\t\tl[j].flip(i+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=j;k<i+j;k++){\n\t\t\t\tif(l[k][i+j-1]&&r[j][k]&&v[i+j][k]){\n\t\t\t\t\tr[j].flip(i+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(r[0][i]&&l[i][N-1]){\n\t\t\tans++;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N;\nint A[2005][2005];\nint before[2005][2005];\nint after[2005][2005];\nint main() {\n    //cout.precision(10);\n    cin >> N;\n    for(int i = 2; i <= N; i++) {\n        string S;\n        cin >> S;\n        for(int j = 0; j < S.size(); j++) {\n            A[i][j+1] = S[j] - '0';\n            A[j+1][i] = 1 - A[i][j+1];\n            //cerr << i << \" \" << j + 1 << \" \" << A[i][j+1] << endl;\n        }\n    }\n    for(int i = 1; i <= N; i++) {\n        before[i][i] = i;\n        after[i][i] = i;\n        for(int j = i - 1; j >= 1; j--) {\n            before[i][j] = before[i-1][j];\n            if(before[i][i] <= j) {\n                chmin(before[i][i], before[i-1][j]);\n            } else if(before[i][i] <= after[i-1][j] + 1) {\n                if(A[i][j] == 1) chmin(before[i][i], before[i-1][j]);\n            }\n        }\n        int minimum = i;\n        for(int j = i - 1; j >= 1; j--) {\n            after[i][j] = after[i-1][j];\n            if(after[minimum][j] >= minimum) {\n                chmax(after[i][j], i);\n            } else if(after[i][j] + 1 >= before[i][i]) {\n                if(A[j][i] == 1) chmax(after[i][j], i);\n            }\n            if(after[i][j] == i) minimum = j;\n        }\n    }\n    for(int TIME = 1; TIME <= N; TIME++) {\n        //cerr << \"----\" << TIME << \"----\" << endl;\n        for(int i = 1; i <= TIME; i++) {\n            //cerr << i << \" \" << before[TIME][i] << \" \" << after[TIME][i] << endl;\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= N; i++) {\n        if(before[N][i] == 1 && after[N][i] == N) ans++;\n        cerr << before[N][i] <<  \" \" << after[N][i] << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nbitset<2000> dp[2020];\nbitset<2000> kati[2020];\n\n\n \nbool solve(int x,int y){\n\t\n\tbool bo=0;\n\tif(x<y){\n\t\n\t\t\n\t\t\t\n\t\t\tbitset<2000> hoge= dp[x+1]&dp[y]&kati[x];\n\t\t bo= hoge._Find_next(x)<=y;\n\t\t//\tbo=hoge.any();\n\t\t\t/*\n\t\t\tif(dfs(i,x+1)&& dfs(i,y) && kati[x][i]){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*/\n\t\t\n\t\t\n\t}\n\telse{\n\t\t\n\t\t\tbitset<2000> hoge= dp[x-1]&dp[y]&kati[x];\n\t\t\t bo= hoge._Find_next(y-1)<=x-1;\n\t\t\t/*\n\t\t\tif(dfs(i,x-1)&& dfs(i,y) && kati[x][i]){\n\t\t\t\tbo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*/\n\t\t\n\t}\n\tif(bo) dp[y].set(x);\n\t//cout<<x<<\" \"<<y<<\" \"<<bo<<endl;\n\n\treturn bo;\n}\n \n signed main(){\n \t\n \n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n int n;\n \tcin>>n;\n \tfor(int i=0;i<n;i++)dp[i].set(i),kati[i].set(i);\n \t\n \tfor(int i=1;i<n;i++){\n \t\tstring s;\n \t\tcin>>s;\n \t\t\n \t\tfor(int j=0;j<i;j++){\n \t\t\tif(s[j]=='1'){\n \t\t\t\tkati[i].set(j);\n //\t\t\t\tkati2[i][j]=1;\n \t\t\t}\n \t\t\t\telse kati[j].set(i);\n \t\t}\n \t}\n \t\t\n \t\n \tint ans=0;\n \t\tfor(int d=1;d<n;d++)for(int i=0;i+d<n;i++){\n \t\t\tsolve(i,i+d);\n// \t\t\tdfs(i,i+d);\n \t\t\tsolve(i+d,i);\n //\t\t\tdfs(i+d,i);\n \t\t}\n \t\t\n \tfor(int i=0;i<n;i++)ans+=(dp[0][i]&& dp[n-1][i]);\n \tcout<<ans<<endl;\n\n \t\n \treturn 0;\n \n  }\n  \n  \n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef NON_SUBMIT\n#define TEST(n) (n)\n#define tout cerr\n#else\n#define TEST(n) ((void)0)\n#define tout cin\n#endif\n\nusing namespace std;\n\nint C[2000][2000], L[2000][2000], R[2000][2000];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\tTEST(freopen(\"input.txt\",\"r\",stdin));\n\tTEST(freopen(\"output.txt\",\"w\",stdout));\n\tTEST(freopen(\"debug.txt\",\"w\",stderr));\n\tint N, ans=0;\n\tcin>>N;\n\tfor(int i=1;i<N;i++) {\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<i;j++) {\n\t\t\tif(s[j]=='1') C[i][j]=1;\n\t\t\telse C[j][i]=1;\n\t\t}\n\t}\n\tL[0][0]=1;\n\tfor(int i=1;i<N;i++) {\n\t\tbool lose=false;\n\t\tfor(int j=0;j<i;j++) if(C[j][i]) lose=true;\n\t\tfor(int j=0;j<=i;j++) if(L[i-1][j]) {\n\t\t\tif(lose) L[i][j]=1;\n\t\t\tif(C[j][i]) L[i][j]=1;\n\t\t\telse L[i][i]=1;\n\t\t}\n\t}\n\tR[N-1][N-1]=1;\n\tfor(int i=N-2;i>=0;i--) {\n\t\tbool lose=false;\n\t\tfor(int j=N-1;j>i;j--) if(C[j][i]) lose=true;\n\t\tfor(int j=N-1;j>=i;j--) if(R[i+1][j]) {\n\t\t\tif(lose) R[i][j]=1;\n\t\t\tif(C[j][i]) R[i][j]=1;\n\t\t\telse R[i][i]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++) if(L[i][i] && R[i][i]) ans++;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nint main(){\n    int N;\n    cin>>N;\n    vector<string> S(N);\n    vector<vector<int>> to(N);\n    for(int i=1;i<N;i++){\n            cin>>S[i];\n            for(int j=0;j<i;j++){\n                if(S[i][j]=='1') to[i].push_back(j);\n                if(S[i][j]=='0') to[j].push_back(i);\n            }\n    }\n    int ans=0;\n    for(int i=0;i<N;i++){\n        vector<bool> d(N,false);\n        queue<int> que;\n        que.push(i);\n        d[i]=true;\n        bool kateru=false;\n        for(int j=0;j<to[i].size();j++){\n                int v=to[i][j];\n                if(d[v]) continue;\n                d[v]=true;\n                que.push(v);\n            }\n        while(!que.empty()){\n            int p=que.front();que.pop();\n            for(int j=0;j<to[p].size();j++){\n                int v=to[p][j];\n                if(d[v]) continue;\n                d[v]=true;\n                que.push(v);\n                if(abs(v-p)==1){\n                    kateru=true;\n                }\n            }\n            if(kateru){\n                ans++;\n                break;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    cout<< ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1000003;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nconst int MAX_N = 2000;\n\nbool dpl[MAX_N][MAX_N];\nbool dpr[MAX_N][MAX_N];\n\nint main() {\n  int N;\n  cin >> N;\n  auto mat = make_v< int >(N, N);\n  for(int i = 1; i < N; i++) {\n    string s;\n    cin >> s;\n    for(int j = 0; j < i; j++) {\n      int x = (int) s[j] - '0';\n      mat[i][j] = x;\n      mat[j][i] = 1 - x;\n    }\n  }\n  for(int i = 0; i < N; i++) {\n    dpl[i][i] = dpr[i][i] = true;\n  }\n  for(int len = 1; len < N; len++) {\n    for(int l = 0; l + len < N; l++) {\n      int r = l + len;\n      for(int k = l + 1; k <= r; k++) {\n        dpl[r][l] |= mat[l][k] & dpl[r][k] & dpr[l + 1][k];\n      }\n      for(int k = l; k + 1 <= r; k++) {\n        dpr[l][r] |= mat[r][k] & dpl[r - 1][k] & dpr[l][k];\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    ret += dpl[N - 1][i] & dpr[0][i];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <string>\n#include <bitset>\n#define SIZE 2005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nbitset <SIZE> left[SIZE];\nbitset <SIZE> right[SIZE];\nbool A[SIZE][SIZE];\nchar mp[SIZE][SIZE];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) scanf(\"%s\",&mp[i]);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tint a=mp[i][j]-'0';\n\t\t\tA[i][j]=a;\n\t\t\tA[j][i]=1-a;\n\t\t}\n\t}/*\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++) printf(\"%d\",A[i][j]);\n\t\tputs(\"\");\n\t}*/\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tleft[i][i]=true;\n\t\tright[i][i+1]=true;\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tif((left[j]|right[i]).any())\n\t\t\t{\n\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\tif(A[i][j]) right[i]|=right[j];\n\t\t\t\telse left[j][i]=true;\n\t\t\t}\n\t\t}\n\t}/*\n\tputs(\"\");\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++) printf(\"%d\",left[i][j]?1:0);\n\t\tputs(\"\");\n\t}*/\n\tint ret=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(left[i][0]&&right[i][n]) ret++;\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst int N = 2010;\nbitset<N> dp[N], win[N];\n\nint main() {\n    int n;\n    cin >> n;\n    FOR(i,1,n-1){\n        string s;\n        cin >> s;\n        REP(j,i){\n            if (s[j] == '1'){\n                win[i].set(j);\n            }else{\n                win[j].set(i);\n            }\n        }\n    }\n\n    REP(i,n) dp[i].set(i);\n\n    FOR(len,1,n-1){\n        REP(l,n+1-len){\n            int r = l + len - 1;\n            if (l > 0 && (win[l - 1] & dp[l] & dp[r]).any()) dp[r].set(l - 1);\n            if (r < n - 1 && (win[r + 1] & dp[l] & dp[r]).any()) dp[l].set(r + 1);\n        }\n    }\n    cout << (dp[0] & dp[n - 1]).count() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n;\nbool dpl[2000][2000];\nbool dpr[2000][2000];\nbool table[2000][2000];\n\nint main() {\n    cin >> n;\n    rep(i,n-1) {\n        rep(j,i+1) {\n            char c; cin >> c;\n            if (c == '1') table[i+1][j] = true;\n            else table[j][i+1] = true;\n        }\n    }\n    rep(i,n) {\n        dpl[i][i] = true;\n        dpr[i][i] = true;\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n-i; j++) {\n            for (int k = j+1; k < j+i; k++) {\n                dpr[j][j+i] |= (table[j][k] && dpr[k][j+i] && dpl[j+1][k]);\n                dpl[j][j+i] |= (table[j+i][k] && dpr[k][j+i-1] && dpl[j][k]);\n            }\n            dpr[j][j+i] |= (table[j][j+i] && dpl[j+1][j+i]);\n            dpl[j][j+i] |= (table[j+i][j] && dpr[j][j+i-1]);\n        }\n    }\n    int ans = 0;\n    rep(i,n) {\n        if (dpl[0][i] && dpr[i][n-1]) ans++;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2010\nusing namespace std;\nbitset<maxn> g[2][maxn], mp[maxn], now, pre, suf;\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= i - 1; j++)\n\t\t{\n\t\t\tchar c = getchar();\n\t\t\twhile (c != '0' && c != '1') c = getchar();\n\t\t\tmp[i][j] = c - '0';\n\t\t\tmp[j][i] = 1 - mp[i][j];\n\t\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t\tg[0][i][i + 1] = g[1][i + 1][i] = 1;\n\tfor (int len = 3; len <= n; len++)\n\t\tfor (int i = 1; i <= n - len + 1; i++)\n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tnow = g[0][i] & g[1][j] & (mp[i] | mp[j]);\n\t\t\tif (now.count()) g[0][i][j] = g[1][j][i] = 1;\n\t\t}\n\tpre[1] = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tfor (int j = 1; j <= i - 1; j++)\n\t\t\tif (pre[j] & g[0][j][i] & mp[i][j]) pre[i] = 1;\n\tsuf[n] = 1;\n\tfor (int i = n - 1; i >= 1; i--)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tif (suf[j] & g[0][i][j] & mp[i][j]) suf[i] = 1;\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (pre[i] & suf[i]) res++;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 5\n\nint n,ans;\nbitset<N> a[N],f[N],g[N];\nchar s[N][N];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=2;i<=n;++i){\n\t\tscanf(\"%s\",s[i]+1);\n\t\tfor (int j=1;j<i;++j){\n\t\t\ta[i][j]=s[i][j]-'0';\n\t\t\ta[j][i]=a[i][j]^1;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tf[i][i]=g[i][i]=1;\n\t\tfor (int j=1;j<i;++j)\n\t\t\tif (g[i-1][j]&&a[i][j]) f[i]|=f[j];\n\t\tfor (int j=1;j<i;++j)\n\t\t\tif (f[i][j+1]&&a[j][i]) g[i]|=g[j];\n\t}\n\tfor (int i=1;i<=n;++i) ans+=f[i][1]&&g[n][i];\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1000000000000037 ;\nconst ll base = 127;\nusing ld=bool;\n\nld prob[2020][2020];\nint dpl[2020],dpr[2020];\ninline bool chmax(int& x,int y){\n    if(x<y){\n        x=y;return true;\n    }\n    return false;\n}\ninline bool chmin(int& x,int y){\n    if(x>y){\n        x=y;return true;\n    }\n    return false;\n}\nint main(){\n    int n;\n    cin>>n;\n    string s[n-1];\n    rep(i,n-1){\n        cin>>s[i];\n        rep(j,i+1){\n            if(s[i][j]=='1')prob[i+1][j]=1,prob[j][i+1]=0;\n            else prob[i+1][j]=0,prob[j][i+1]=1;\n        }\n    }\n    rep(i,n)prob[i][i]=1;\n    rep(i,n)dpl[i]=dpr[i]=i;\n    int idx=0;\n    while(1){\n        bool update=false;\n        int ma=1<<idx;\n        for(int i=n-1;i>=0;--i){\n            for(int j=i+1;j<n;j++){\n                if(prob[i][j]&&dpr[i]+1>=dpl[j]){\n                    update|=chmax(dpr[i],dpr[j]);\n                    if(dpr[i]>i+ma)dpr[i]=i+ma;\n                }\n            }\n        }\n        for(int i=0;i<n;++i){\n            for(int j=i-1;j>=0;--j){\n                if(prob[i][j]&&dpl[i]<=dpr[j]+1){\n                    update|=chmin(dpl[i],dpl[j]);\n                    if(dpl[i]<i-ma)dpl[i]=i-ma;\n                }\n            }\n        }\n        if(!update)break;\n        ++idx;\n    }\n    int ans=0;\n    rep(i,n)ans+=(dpl[i]==0&&dpr[i]==n-1);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#include<bitset>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=2005;\nint n,ans;\nbool a[N][N];\nchar s[N];\nbitset <N> f[N],g[N];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,2,n)\n\t{\n\t\tscanf(\"%s\",s+1);\n\t\trep(j,1,i-1)\n\t\t{\n\t\t\tint x=s[j]-'0';\t\n\t\t\ta[i][j]=x,a[j][i]=x^1;\n\t\t}\n\t}\n\trep(i,1,n)\n\t{\n\t\tf[i][i]=g[i][i]=1;\n\t\trep(j,1,i-1)\n\t\t\tif(g[i-1][j] && a[i][j]) f[i]|=f[j];\n\t\trep(j,1,i-1)\n\t\t\tif(f[i][j+1] && a[j][i]) g[i]|=g[j];\n\t}\n\trep(i,1,n) if(f[i][1] && g[n][i]) ++ans;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 2005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\ntypedef bitset<2000> bs;\nint n;\nbs win[MAXN];\nint a[MAXN][MAXN];\nbs pre[MAXN],tmp;\nstring str;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        cin>>str;\n        for(int j=0;j<i;j++)\n        {\n            int x=str[j]-'0';\n            if(x) win[i].set(j); else win[j].set(i);\n        }\n    }\n    pre[0].set(0);\n    for(int i=1;i<n;i++)\n    {\n        bs suf; suf.reset(); suf.set(i);\n        if((win[i]&pre[i-1]).count()) pre[i].set(i);\n        for(int j=i-1;j>=0;j--)\n        {\n            if((win[j]&suf).count())\n            {\n                suf.set(j);\n                if(pre[j].test(j)) pre[i].set(j);\n            }\n        }\n    }\n    printf(\"%d\\n\",(int)pre[n-1].count());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 2010;\n\nll n;\nbitset<SZ> grid[SZ], msk[SZ];\nbitset<SZ> sv[SZ], sv2[SZ];\nvector<ll> wn[SZ];\nbitset<SZ> cur;\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tsv[i - 1][i] = 1;\n\t\tsv2[i][i - 1] = 1;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\t\tgrid[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrid[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n + 3; i++) {\n\t\tcur = 0;\n\t\tfor (int j = 0; j < i; j++) cur[j] = 1;\n\t\tmsk[i] = cur;\n\t}\n\tfor (int i = 2; i <= n + 1; i++) {\n\t\tfor (int j = 0; j <= n + 1; j++) {\n\t\t\tll lft = j, rt = j + i;\n\t\t\tif (rt <= n + 1) {\n\t\t\t\tif ((((sv[lft] & grid[lft]) >> lft) & msk[i + 1]) != 0 || (((sv2[rt] & grid[rt]) >> lft) & msk[i + 1]) != 0) {\n\t\t\t\t\tsv[lft][rt] = 1;\n\t\t\t\t\tsv2[rt][lft] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (sv[0][i] && sv[i][n + 1]) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, res;\nchar c;\nset<int>st[2000];\n\nbool f(int x, int l, int r) {\n\tif (x == l&&x == r)return true;\n\tif (x == l) {\n\t\tauto it = st[x].find(x);\n\t\t++it;\n\t\twhile (*it <= r) {\n\t\t\tif (f(*it, x + 1, r))return true;\n\t\t\t++it;\n\t\t}\n\t}\n\telse if (x == r) {\n\t\tauto it = st[x].find(x);\n\t\t--it;\n\t\twhile (*it >= l) {\n\t\t\tif (f(*it, l, x - 1))return true;\n\t\t\t--it;\n\t\t}\n\t}\n\telse {\n\t\tauto it = st[x].find(x);\n\t\tbool F = false;\n\t\t++it;\n\t\twhile (*it <= r) {\n\t\t\tif (f(*it, x + 1, r)) {\n\t\t\t\tF = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++it;\n\t\t}\n\t\tif (F) {\n\t\t\tit = st[x].find(x);\n\t\t\t--it;\n\t\t\twhile (*it >= l) {\n\t\t\t\tif (f(*it, l, x - 1))return true;\n\t\t\t\t--it;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i < N; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tcin >> c;\n\t\t\tif (c == '1') {\n\t\t\t\tst[i].insert(j);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst[j].insert(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tst[i].insert(-1);\n\t\tst[i].insert(i);\n\t\tst[i].insert(N);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tres += f(i, 0, N - 1);\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbitset<2020> win[2020];\nbitset<2020> dp[2][2020];\nsigned main() {\n    int N; scanf(\"%d\", &N);\n    \n    for(int i=0; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; scanf(\" %c\", &c);\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dp[0][i][i] = dp[1][i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            bool f1 = (dp[0][j] & dp[1][i+1] & win[i])._Find_next(i  ) <= j;\n            bool f2 = (dp[1][i] & dp[0][j-1] & win[j])._Find_next(i-1) <= j-1;\n            dp[0][j][i] = f1, dp[1][i][j] = f2;\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dp[0][N-1][i] & dp[1][0][i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n\ntypedef long long ll;\n\nint n;\nvector<int> edge[2010];\n\nbool done[2010];\n\nvoid dfs(int v)\n{\n\tdone[v]=true;\n\trep(i, edge[v].size())\n\t{\n\t\tint u=edge[v][i];\n\t\tif(!done[u]) dfs(u);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tchar dum;\n\tfor(int i=2; i++; i<=n)\n\t{\n\t\tfor(int j=1; j++; j<i)\n\t\t{\n\t\t\tcin >> dum;\n\t\t\tif(dum=='1') edge[i-1].push_back(j-1);\n\t\t\telse edge[j-1].push_back(i-1);\n\t\t}\n\t}\n\tint answer=0;\n\trep(i, n)\n\t{\n\t\trep(j, n) done[j]=false;\n\t\tdfs(i);\n\t\tbool ans=true;\n\t\trep(j, n) if(!done[j]) ans=false;\n\t\tif(ans) answer++;\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nbool win[2001][2001];\nbool dpl[2001][2001], dpr[2001][2001];\nsigned main() {\n    int N; cin >> N;\n    \n    for(int i=1; i<N; i++) {\n        for(int j=0; j<i; j++) {\n            char c; cin >> c;\n            bool p = c - '0';\n            win[i][j] = p;\n            win[j][i] = !p;\n        }\n    }\n\n    for(int i=0; i<N; i++) dpl[i][i] = dpr[i][i] = true;\n    for(int d=1; d<N; d++) {\n        for(int i=0; i<N-d; i++) {\n            int j = i + d;\n            for(int k=i+1; k<=j; k++) {\n                dpl[j][i] |= win[i][k] and dpl[j][k] and dpr[i+1][k];\n            }\n            for(int k=i; k<j; k++) {\n                dpr[i][j] |= win[j][k] and dpr[i][k] and dpl[j-1][k];\n            }\n            // fprintf(stderr, \"dpl[%lld][%lld] = %lld, dpr[%lld][%lld] = %lld\\n\", i, j, dpl[i][j], j, i, dpr[j][i]);\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) ans += (dpl[N-1][i] and dpr[0][i]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000003;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nbool b[2000][2000];\n\nbool le[2000][2000], ri[2000][2000];\nvoid solve() {\n\tint n; cin >> n;\n\trep1(i, n - 1) {\n\t\trep(j, i) {\n\t\t\tchar t; cin >> t;\n\t\t\tif (t == '1') {\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n)le[i][i] = ri[i][i] = true;\n\n\tint ans = 0;\n\tRep1(i, 2, n) {\n\t\trep(j, n - i + 1) {\n\t\t\tint l = j;\n\t\t\tint r = j + i - 1;\n\t\t\tRep1(k, l + 1, r) {\n\t\t\t\tif (b[l][k] && ri[l + 1][k] && le[k][r]) {\n\t\t\t\t\tle[l][r] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRep(k, l, r) {\n\t\t\t\tif (b[r][k] && ri[l][k] && le[k][r - 1]) {\n\t\t\t\t\tri[l][r] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (ri[0][i] && le[i][n - 1])ans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = std::pair<int, int>;\n\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define pb push_back\n\nconst int mn = 2000;\n\nbitset<mn> g[mn], dpl[mn], dpr[mn];\n\nint n;\nchar s[mn + 5];\n\nint main() {\n#ifdef trote\n    freopen(\"../1.txt\", \"r\", stdin);\n#endif\n\n    scanf(\"%d\", &n);\n    if (n == 1) {\n        puts(\"1\");\n        exit(0);\n    }\n    for (int i = 1; i < n; i++) {\n        scanf(\"%s\", s);\n        for (int j = 0; j < i; j++) {\n            if (s[j] == '1') {\n                g[i][j] = 1;\n                g[j][i] = 0;\n            } else {\n                g[i][j] = 0;\n                g[j][i] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) dpl[i][i] = dpr[i][i] = true;\n    for (int len = 0; len < n; len++) {\n        for (int i = 0; i + len < n; i++) {\n            int j = i + len;\n            // dpl[i][j] iff g[i][k] && exist k let dpl[k][j] && dpr[k][i+1]\n            for (int k = i + 1; k <= j; k++) {\n                dpl[i][j] = g[i][k] && dpl[k][j] && dpr[k][i + 1];\n                if (dpl[i][j]) break;\n            }\n            // dpr[j][i] iff g[j][k] && dpl[k][j-1] && dpr[k][i]\n            for (int k = i; k < j; k++) {\n                dpr[j][i] = g[j][k] && dpl[k][j - 1] && dpr[k][i];\n                if (dpr[j][i]) break;\n            }\n            //printf(\"%d %d %d %d\\n\",i,j,(int)dpl[i][j],(int)dpr[j][i]);\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++){\n        if (dpl[i][n-1]&&dpr[i][0]) ans++;\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<bits/stdc++.h>//////////////////////////////////////////\n#define deb(...)/////////////////////////////////////////////////\n#define DBP(...)/////////////////////////////////////////////////\n#ifdef LOC///////////////////////////////////////////////////////\n#include\"debuglib.h\"/////////////////////////////////////////////\n#endif///////////////////////////////////////////////////////////\n#define x first//////////////////////////////////////////////////\n#define y second/////////////////////////////////////////////////\n#define pb push_back/////////////////////////////////////////////\n#define sz(x)int((x).size())/////////////////////////////////////\n#define each(a,x)for(auto&a:(x))/////////////////////////////////\n#define all(x)(x).begin(),(x).end()//////////////////////////////\n#define rep(i,b,e)for(int i=(b);i<(e);i++)///////////////////////\nusing namespace std;using ll=long long;using Pii=pair<int,int>;//\nusing Vi=vector<int>;void run();int main(){cin.sync_with_stdio///\n(0);cin.tie(0);cout<<fixed<<setprecision(18);run();return 0;}////\n//-------------------------------------------------------------//\n\n#define left left__\n#define right right__\nconstexpr int MAX_N = 2001;\n\nint n;\nbitset<MAX_N> win[MAX_N], left[MAX_N], right[MAX_N];\n\nvoid run() {\n\tcin >> n;\n\n\trep(i, 1, n) {\n\t\tstring s; cin >> s;\n\t\trep(j, 0, i) {\n\t\t\tbool k = (s[j] == '1');\n\t\t\twin[i][j] = k;\n\t\t\twin[j][i] = !k;\n\t\t}\n\t}\n\n\tleft[0][0] = right[0][0] = 1;\n\n\trep(p, 1, n) {\n\t\tleft[p][p] = right[p][p] = 1;\n\n\t\trep(i, 0, p) {\n\t\t\tif (win[p][i] && right[i][p-1]) {\n\t\t\t\tleft[p] |= left[i];\n\t\t\t}\n\t\t}\n\n\t\tbitset<MAX_N> jeb;\n\n\t\tfor (int i = p-1; i >= 0; i--) {\n\t\t\tif (win[i][p] && right[i][p-1]) {\n\t\t\t\tright[i][p] = 1;\n\t\t\t} else {\n\t\t\t\tright[i][p] = (jeb & right[i]).any();\n\t\t\t}\n\n\t\t\tjeb[i] = right[i][p];\n\t\t}\n\t}\n\n\tint ans = 0;\n\trep(i, 0, n) {\n\t\tans += left[i][0] && right[i][n-1];\n\t\tdeb(i, left[i][0], right[i][n-1]);\n\t}\n\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\nusing namespace std;\n\n\nint main(void){\n    int n;cin >> n;\n    vector<bitset<2000> > wins(2000);\n    for(int i = 0;i < n;i++){\n        wins[i][i] = 1;\n        if(i > 0){\n            string s;cin >> s;\n            for(int j = 0;j < i;j++){\n                wins[i][j] = (s[j] == '1');\n                wins[j][i] = !wins[i][j];\n            }\n        }\n    }\n    \n    vector<bitset<2000> > dpr(2000),dpl(2000),dpr2(2000),dpl2(2000);\n    for(int d = 0;d < n;d++){\n        if(d == 0){\n            for(int i = 0;i < n;i++){\n                dpr[i][i] = dpl[i][i] = dpr2[i][i] = dpl2[i][i] = 1;\n            }\n            continue;\n        }\n        \n        for(int i = 0;i + d < n;i++){\n            int j = i + d;\n            bitset<2000> merged;\n            merged = (wins[i] & dpr2[i+1] & dpl2[j]);\n            if(merged.count() > 0){\n                dpl[i][j] = dpl2[j][i] = 1;\n            }\n        }\n\n        for(int i = n-1;i - d >= 0;i--){\n            int j = i - d;\n            bitset<2000> merged = (wins[i] & dpl2[i-1] & dpr2[j]);\n            if(merged.count() > 0){\n                dpr[i][j] = dpr2[j][i] = 1;\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0;i < n;i++){\n        if(dpr[i][0] & dpl[i][n-1])ans++;\n    }\n    cout << ans << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2020;\nint n;\nbitset<N>A[N],l[N],r[N],lt[N],rt[N],dp[N],dpt[N];\nint main() {\n\tread(n);rep(i,2,n){\n\t\tchar S[N];scanf(\"%s\",S+1);\n\t\trep(j,1,i-1){\n\t\t\tint x=S[j]=='1';A[i][j]=x;A[j][i]=x^1;\n\t\t}\n\t}\n\tper(i,n,1)rep(j,i,n){\n\t\tif(j==i){l[i][j]=r[i][j]=1;continue;}\n\t\tl[j][i]=(A[i]&r[i+1]&l[j]).count();\n\t\tr[i][j]=(A[j]&r[i]&l[j-1]).count();\n\t}\n\t/*rep(i,1,n){\n\t\trep(j,1,n)printf(\"%d \",(int)A[i][j]);puts(\"\");\n\t}\n\trep(i,1,n){\n\t\trep(j,1,n)printf(\"%d \",(int)l[i][j]);puts(\"\");\n\t}*/\n\tint res=0;rep(i,1,n)res+=l[n][i]&r[1][i];\n\tcout<<res;return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef uint64_t u64;\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\nvoid set_at (u64 *a, i32 x) {\n  i32 q = x / 64;\n  i32 r = x % 64;\n  a[q] |= (u64)1 << r;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u64 **win = ALLOC (n, u64 *);\n  u64 **dp = ALLOC (n, u64 *);\n  i32 len = (n + 63) / 64;\n  u64 *buf = ALLOC (2 * len * n, u64);\n  for (i32 i = 0; i < n; ++i) {\n    win[i] = buf;\n    buf += len;\n    dp[i] = buf;\n    buf += len;\n    set_at(dp[i], i);\n  }\n  char *s = ALLOC (n + 1, char);\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '1') {\n        set_at(win[i], j);\n      } else {\n        set_at(win[j], i);\n      }\n    }\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l <= n - len; ++l) {\n      i32 r = l + len - 1;\n      i32 s = l / 64;\n      i32 t = r / 64 + 1;\n      for (i32 i = s; i < t; ++i) {\n        if (win[l][i] & dp[l + 1][i] & dp[r][i]) {\n          set_at(dp[r], l);\n          break;\n        }\n      }\n      for (i32 i = s; i < t; ++i) {\n        if (win[r][i] & dp[l][i] & dp[r - 1][i]) {\n          set_at(dp[l], r);\n          break;\n        }\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    i32 q = i / 64;\n    i32 r = i % 64;\n    ans += (dp[n - 1][q] >> r) & (dp[0][q] >> r) & 1;\n  }\n  printf(\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\n#define F 2000\n\nuint8_t win[F][F],dp_l[F][F],dp_r[F][F];\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  char *s = ALLOC (n, char);\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      win[i][j] = s[j] == '1' ? 1 : 0;\n      win[j][i] = win[i][j] ^ 1;\n    }\n  }\n  for (i32 i = 0; i < n; ++i) {\n    dp_l[i][i] = dp_r[i][i] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l <= n - len; ++l) {\n      i32 r = l + len - 1;\n      for (i32 i = l + 1; i <= r; ++i) {\n        dp_l[r][l] |= win[l][i] & dp_r[l + 1][i] & dp_l[r][i];\n      }\n      for (i32 i = l; i < r; ++i) {\n        dp_r[l][r] |= win[r][i] & dp_r[l][i] & dp_l[r - 1][i];\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dp_r[0][i] & dp_l[n - 1][i];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\nuint8_t** allocate (i32 h, i32 w) {\n  uint8_t **a = ALLOC (h, uint8_t *);\n  uint8_t *buf = ALLOC (h * w, uint8_t);\n  for (i32 i = 0; i < h; ++i) {\n    a[i] = buf;\n    buf += w;\n  }\n  return a;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  uint8_t **win = allocate (n, n);\n  char *s = ALLOC (n, char);\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      win[i][j] = s[j] == '1' ? 1 : 0;\n      win[j][i] = win[i][j] ^ 1;\n    }\n  }\n  uint8_t **dp_l = allocate (n, n);\n  uint8_t **dp_r = allocate (n, n);\n  for (i32 i = 0; i < n; ++i) {\n    dp_l[i][i] = dp_r[i][i] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l <= n - len; ++l) {\n      i32 r = l + len - 1;\n      for (i32 i = l + 1; i <= r; ++i) {\n        dp_l[r][l] |= win[l][i] & dp_r[l + 1][i] & dp_l[r][i];\n      }\n      for (i32 i = l; i < r; ++i) {\n        dp_r[l][r] |= win[r][i] & dp_r[l][i] & dp_l[r - 1][i];\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dp_r[0][i] & dp_l[n - 1][i];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint64_t u64;\n\nvoid set_at (u64 *b, i32 k) {\n  b[k >> 6] |= (u64) 1 << (k & 63);\n}\n\ni32 get_at (u64 *b, i32 k) {\n  return (b[k >> 6] >> (k & 63)) & 1;\n}\n\nint func (u64 *a, u64 *b, u64 *c, i32 l, i32 r) {\n  i32 i = l;\n  for (; i <= r && i < l / 64 * 64; ++i) {\n    if (get_at (a, i) && get_at (b, i) && get_at (c, i)) {\n      return 1;\n    }\n  }\n  for (; i + 63 <= r; i += 64) {\n    if ((a[i / 64] & b[i / 64] & c[i / 64]) != 0) {\n      return 1;\n    }\n  }\n  for (; i <= r; ++i) {\n    if (get_at (a, i) && get_at (b, i) && get_at (c, i)) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u64 **win = (u64 **) calloc (n, sizeof (u64 *));\n  for (i32 i = 0; i < n; ++i) {\n    win[i] = (u64 *) calloc (n / 64 + 1, sizeof (u64));\n  }\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n        set_at (win[j], i);\n      } else {\n        set_at (win[i], j);\n      }\n    }\n  }\n  u64 **dpL = (u64 **) calloc (n, sizeof (u64 *));\n  u64 **dpR = (u64 **) calloc (n, sizeof (u64 *));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[i] = (u64 *) calloc (n / 64 + 1, sizeof (u64));\n    set_at (dpL[i], i);\n    dpR[i] = (u64 *) calloc (n / 64 + 1, sizeof (u64));\n    set_at (dpR[i], i);\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      if (func (win[l], dpR[l + 1], dpL[r], l + 1, r)) {\n\tset_at (dpL[r], l);\n      }\n      if (func (win[r], dpR[l], dpL[r - 1], l, r - 1)) {\n\tset_at (dpR[l], r);\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += get_at (dpR[0], i) & get_at (dpL[n - 1], i);\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint8_t u8;\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u8 **win = (u8 **) calloc (n, sizeof (u8 *));\n  for (i32 i = 0; i < n; ++i) {\n    win[i] = (u8 *) calloc (n, sizeof (u8));\n  }\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n\twin[j][i] = 1;\n      } else {\n\twin[i][j] = 1;\n      }\n    }\n  }\n  u8 **dpL = (u8 **) calloc (n, sizeof (u8 *));\n  u8 **dpR = (u8 **) calloc (n, sizeof (u8 *));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[i] = (u8 *) calloc (n, sizeof (u8));\n    dpR[i] = (u8 *) calloc (n, sizeof (u8));\n    dpL[i][i] = dpR[i][i] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      for (i32 k = l + 1; k <= r && !dpL[r][l]; ++k) {\n\tdpL[r][l] = win[l][k] & dpR[l + 1][k] & dpL[r][k];\n      }\n      for (i32 k = l; k <= r - 1 && !dpR[l][r]; ++k) {\n\tdpR[l][r] = win[r][k] & dpR[l][k] & dpL[r - 1][k];\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dpR[0][i] & dpL[n - 1][i];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint8_t u8;\n\n#define POS(i, j) ((i) * n + (j))\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u8 *win = (u8 *) calloc (n * n, sizeof (u8));\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n        win[POS(j, i)] = 1;\n      } else {\n        win[POS(i, j)] = 1;\n      }\n    }\n  }\n  u8 *dpL = (u8 *) calloc (n * n, sizeof (u8));\n  u8 *dpR = (u8 *) calloc (n * n, sizeof (u8));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[POS(i, i)] = dpR[POS(i, i)] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      for (i32 k = l + 1; k <= r; ++k) {\n        if (win[POS(l, k)] && dpR[POS(l + 1, k)] && dpL[POS(k, r)]) {\n          dpL[POS(l, r)] = 1;\n          break;\n        }\n      }\n      for (i32 k = l; k <= r - 1; ++k) {\n        if (win[POS(r, k)] && dpR[POS(l, k)] && dpL[POS(k, r - 1)]) {\n          dpR[POS(l, r)] = 1;\n          break;\n        }\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dpR[POS(0, i)] & dpL[POS(i, n - 1)];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint64_t u64;\n\nvoid set_at (u64 *b, i32 k) {\n  b[k >> 6] |= (u64) 1 << (k & 63);\n}\n\ni32 get_at (u64 *b, i32 k) {\n  return (b[k >> 6] >> (k & 63)) & 1;\n}\n\nu64 func (u64 * restrict a, u64 * restrict b, u64 * restrict c, i32 l, i32 r) {\n  const u64 t = ~(u64)0;\n  if (l / 64 == r / 64) {\n    return ((a[l / 64] & b[l / 64] & c[l / 64]) >> (l & 63)) & (t >> (64 - (r - l + 1)));\n  }\n  i32 k = l / 64;\n  u64 f = 0;\n  f |= (a[k] & b[k] & c[k]) >> (l & 63);\n  k = r / 64;\n  f |= (a[k] & b[k] & c[k]) & (t >> (63 - r));\n  for (i32 i = (l + 64) / 64 * 64; i + 63 <= r; i += 64) {\n    f |= a[i/ 64] & b[i / 64] & c[i / 64];\n  }\n  return f;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  i32 len = (n + 63) / 64;\n  u64 *array = (u64 *) calloc (3 * n * len, sizeof (u64));\n  u64 **win = (u64 **) calloc (n, sizeof (u64 *));\n  for (i32 i = 0; i < n; ++i) {\n    win[i] = array;\n    array += len;\n  }\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n        set_at (win[j], i);\n      } else {\n        set_at (win[i], j);\n      }\n    }\n  }\n  u64 **dpL = (u64 **) calloc (n, sizeof (u64 *));\n  u64 **dpR = (u64 **) calloc (n, sizeof (u64 *));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[i] = array;\n    array += len;\n    set_at (dpL[i], i);\n    dpR[i] = array;\n    array += len;\n    set_at (dpR[i], i);\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      if (func (win[l], dpR[l + 1], dpL[r], l + 1, r)) {\n\tset_at (dpL[r], l);\n      }\n      if (func (win[r], dpR[l], dpL[r - 1], l, r - 1)) {\n\tset_at (dpR[l], r);\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += get_at (dpR[0], i) & get_at (dpL[n - 1], i);\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint8_t u8;\n\n#define POS(i, j) ((i) * n + (j))\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u8 *win = (u8 *) calloc (n * n, sizeof (u8));\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n        win[POS(j, i)] = 1;\n      } else {\n        win[POS(i, j)] = 1;\n      }\n    }\n  }\n  u8 *dpL = (u8 *) calloc (n * n, sizeof (u8));\n  u8 *dpR = (u8 *) calloc (n * n, sizeof (u8));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[POS(i, i)] = dpR[POS(i, i)] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      for (i32 k = l + 1; k <= r && !dpL[POS(r, l)]; ++k) {\n\tdpL[POS(r, l)] = win[POS(l, k)] & dpR[POS(l + 1, k)] & dpL[POS(r, k)];\n      }\n      for (i32 k = l; k <= r - 1 && !dpR[POS(l, r)]; ++k) {\n        dpR[POS(l, r)] = win[POS(r, k)] & dpR[POS(l, k)] & dpL[POS(r - 1, k)];\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dpR[POS(0, i)] & dpL[POS(n - 1, i)];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint64_t u64;\n\nvoid set_at (u64 *b, i32 k) {\n  b[k >> 6] |= (u64) 1 << (k & 63);\n}\n\ni32 get_at (u64 *b, i32 k) {\n  return (b[k >> 6] >> (k & 63)) & 1;\n}\n\nint func (u64 * restrict a, u64 * restrict b, u64 * restrict c, i32 l, i32 r) {\n  const u64 t = ~(u64)0;\n  if (l / 64 == r / 64) {\n    return (((a[l / 64] & b[l / 64] & c[l / 64]) >> (l & 63)) & (t >> (64 - (r - l + 1)))) != 0;\n  }\n  i32 k = l / 64;\n  u64 x = (a[k] & b[k] & c[k]) >> (l & 63);\n  if (x) return 1;\n  k = r / 64;\n  x = (a[k] & b[k] & c[k]) & (t >> (63 - r));\n  if (x) return 1;\n  for (i32 i = (l + 64) / 64 * 64; i + 63 <= r; i += 64) {\n    if ((a[i / 64] & b[i / 64] & c[i / 64]) != 0) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  i32 len = (n + 63) / 64;\n  u64 *array = (u64 *) calloc (3 * n * len, sizeof (u64));\n  u64 **win = (u64 **) calloc (n, sizeof (u64 *));\n  for (i32 i = 0; i < n; ++i) {\n    win[i] = array;\n    array += len;\n  }\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n        set_at (win[j], i);\n      } else {\n        set_at (win[i], j);\n      }\n    }\n  }\n  u64 **dpL = (u64 **) calloc (n, sizeof (u64 *));\n  u64 **dpR = (u64 **) calloc (n, sizeof (u64 *));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[i] = array;\n    array += len;\n    set_at (dpL[i], i);\n    dpR[i] = array;\n    array += len;\n    set_at (dpR[i], i);\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      if (func (win[l], dpR[l + 1], dpL[r], l + 1, r)) {\n\tset_at (dpL[r], l);\n      }\n      if (func (win[r], dpR[l], dpL[r - 1], l, r - 1)) {\n\tset_at (dpR[l], r);\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += get_at (dpR[0], i) & get_at (dpL[n - 1], i);\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint8_t u8;\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u8 **win = (u8 **) calloc (n, sizeof (u8 *));\n  for (i32 i = 0; i < n; ++i) {\n    win[i] = (u8 *) calloc (n, sizeof (u8));\n  }\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n\twin[j][i] = 1;\n      } else {\n\twin[i][j] = 1;\n      }\n    }\n  }\n  u8 **dpL = (u8 **) calloc (n, sizeof (u8 *));\n  u8 **dpR = (u8 **) calloc (n, sizeof (u8 *));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[i] = (u8 *) calloc (n, sizeof (u8));\n    dpR[i] = (u8 *) calloc (n, sizeof (u8));\n    dpL[i][i] = dpR[i][i] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      for (i32 k = l + 1; k <= r && !dpL[r][l]; ++k) {\n\tdpL[r][l] = win[l][k] & dpR[l + 1][k] & dpL[r][k];\n      }\n      for (i32 k = l; k <= r - 1 && !dpR[l][r]; ++k) {\n\tdpR[l][r] = win[r][k] & dpR[l][k] & dpL[r - 1][k];\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dpR[0][i] & dpL[n - 1][i];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint8_t u8;\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u8 **win = (u8 **) calloc (n, sizeof (u8 *));\n  for (i32 i = 0; i < n; ++i) {\n    win[i] = (u8 *) calloc (n, sizeof (u8));\n  }\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n\twin[j][i] = 1;\n      } else {\n\twin[i][j] = 1;\n      }\n    }\n  }\n  u8 **dpL = (u8 **) calloc (n, sizeof (u8 *));\n  u8 **dpR = (u8 **) calloc (n, sizeof (u8 *));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[i] = (u8 *) calloc (n, sizeof (u8));\n    dpR[i] = (u8 *) calloc (n, sizeof (u8));\n    dpL[i][i] = dpR[i][i] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      for (i32 k = l + 1; k <= r && !dpL[r][l]; ++k) {\n\tdpL[r][l] = win[l][k] & dpR[l + 1][k] & dpL[r][k];\n      }\n      for (i32 k = l; k <= r - 1 && !dpR[l][r]; ++k) {\n\tdpR[l][r] = win[r][k] & dpR[l][k] & dpL[r - 1][k];\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dpR[0][i] & dpL[n - 1][i];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint64_t u64;\n\nvoid set_at (u64 *b, i32 k) {\n  b[k >> 6] |= (u64) 1 << (k & 63);\n}\n\ni32 get_at (u64 *b, i32 k) {\n  return (b[k >> 6] >> (k & 63)) & 1;\n}\n\nint func (u64 *a, u64 *b, u64 *c, i32 l, i32 r) {\n  i32 i = l;\n  for (; i <= r && i < (l / 64 + 1) * 64; ++i) {\n    if (get_at (a, i) && get_at (b, i) && get_at (c, i)) {\n      return 1;\n    }\n  }\n  for (; i + 63 <= r; i += 64) {\n    if ((a[i / 64] & b[i / 64] & c[i / 64]) != 0) {\n      return 1;\n    }\n  }\n  for (; i <= r; ++i) {\n    if (get_at (a, i) && get_at (b, i) && get_at (c, i)) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u64 **win = (u64 **) calloc (n, sizeof (u64 *));\n  for (i32 i = 0; i < n; ++i) {\n    win[i] = (u64 *) calloc (n / 64 + 1, sizeof (u64));\n  }\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n        set_at (win[j], i);\n      } else {\n        set_at (win[i], j);\n      }\n    }\n  }\n  u64 **dpL = (u64 **) calloc (n, sizeof (u64 *));\n  u64 **dpR = (u64 **) calloc (n, sizeof (u64 *));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[i] = (u64 *) calloc (n / 64 + 1, sizeof (u64));\n    set_at (dpL[i], i);\n    dpR[i] = (u64 *) calloc (n / 64 + 1, sizeof (u64));\n    set_at (dpR[i], i);\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      if (func (win[l], dpR[l + 1], dpL[r], l + 1, r)) {\n\tset_at (dpL[r], l);\n      }\n      if (func (win[r], dpR[l], dpL[r - 1], l, r - 1)) {\n\tset_at (dpR[l], r);\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += get_at (dpR[0], i) & get_at (dpL[n - 1], i);\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\nuint8_t** allocate (i32 h, i32 w) {\n  uint8_t **a = ALLOC (h, uint8_t *);\n  uint8_t *buf = ALLOC (h * w, uint8_t);\n  for (i32 i = 0; i < h; ++i) {\n    a[i] = buf;\n    buf += w;\n  }\n  return a;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  uint8_t **win = allocate (n, n);\n  char *s = ALLOC (n, char);\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      win[i][j] = s[j] == '1' ? 1 : 0;\n      win[j][i] = win[i][j] ^ 1;\n    }\n  }\n  uint8_t **dp_l = allocate (n, n);\n  uint8_t **dp_r = allocate (n, n);\n  for (i32 i = 0; i < n; ++i) {\n    dp_l[i][i] = dp_r[i][i] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l <= n - len; ++l) {\n      i32 r = l + len - 1;\n      for (i32 i = l + 1; i <= r; ++i) {\n        dp_l[l][r] |= win[l][i] & dp_r[l + 1][i] & dp_l[i][r];\n      }\n      for (i32 i = l; i < r; ++i) {\n        dp_r[l][r] |= win[r][i] & dp_r[l][i] & dp_l[i][r - 1];\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dp_r[0][i] & dp_l[i][n - 1];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\nuint8_t** allocate (i32 h, i32 w) {\n  uint8_t **a = ALLOC (h, uint8_t *);\n  uint8_t *buf = ALLOC (h * w, uint8_t);\n  for (i32 i = 0; i < h; ++i) {\n    a[i] = buf;\n    buf += w;\n  }\n  return a;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  uint8_t **win = allocate (n, n);\n  char *s = ALLOC (n, char);\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      win[i][j] = s[j] == '1' ? 1 : 0;\n      win[j][i] = win[i][j] ^ 1;\n    }\n  }\n  uint8_t **dp_l = allocate (n, n);\n  uint8_t **dp_r = allocate (n, n);\n  for (i32 i = 0; i < n; ++i) {\n    dp_l[i][i] = dp_r[i][i] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l <= n - len; ++l) {\n      i32 r = l + len - 1;\n      for (i32 i = l + 1; i <= r; ++i) {\n        dp_l[r][l] |= win[l][i] & dp_r[l + 1][i] & dp_l[r][i];\n      }\n      for (i32 i = l; i < r; ++i) {\n        dp_r[l][r] |= win[r][i] & dp_r[l][i] & dp_l[r - 1][i];\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dp_r[0][i] & dp_l[i][n - 1];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef uint8_t u8;\n\n#define POS(i, j) ((i) * n + (j))\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u8 *win = (u8 *) calloc (n * n, sizeof (u8));\n  char *s = (char *) calloc (n + 1, sizeof (char));\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '0') {\n        win[POS(j, i)] = 1;\n      } else {\n        win[POS(i, j)] = 1;\n      }\n    }\n  }\n  u8 *dpL = (u8 *) calloc (n * n, sizeof (u8));\n  u8 *dpR = (u8 *) calloc (n * n, sizeof (u8));\n  for (i32 i = 0; i < n; ++i) {\n    dpL[POS(i, i)] = dpR[POS(i, i)] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l + len - 1 < n; ++l) {\n      i32 r = l + len - 1;\n      for (i32 k = l + 1; k <= r; ++k) {\n        if (win[POS(l, k)] && dpR[POS(l + 1, k)] && dpL[POS(r, k)]) {\n          dpL[POS(r, l)] = 1;\n          break;\n        }\n      }\n      for (i32 k = l; k <= r - 1; ++k) {\n        if (win[POS(r, k)] && dpR[POS(l, k)] && dpL[POS(r - 1, k)]) {\n          dpR[POS(l, r)] = 1;\n          break;\n        }\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dpR[POS(0, i)] & dpL[POS(n - 1, i)];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\nuint8_t** allocate (i32 h, i32 w) {\n  uint8_t **a = ALLOC (h, uint8_t *);\n  uint8_t *buf = ALLOC (h * w, uint8_t);\n  for (i32 i = 0; i < h; ++i) {\n    a[i] = buf;\n    buf += w;\n  }\n  return a;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  uint8_t **win = allocate (n, n);\n  char *s = ALLOC (n, char);\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      win[i][j] = s[j] == '1' ? 1 : 0;\n      win[j][i] = win[i][j] ^ 1;\n    }\n  }\n  uint8_t **dp_l = allocate (n, n);\n  uint8_t **dp_r = allocate (n, n);\n  for (i32 i = 0; i < n; ++i) {\n    dp_l[i][i] = dp_r[i][i] = 1;\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l <= n - len; ++l) {\n      i32 r = l + len - 1;\n      for (i32 i = l + 1; i <= r; ++i) {\n        dp_l[r][l] |= win[l][i] & dp_r[l + 1][i] & dp_l[r][i];\n      }\n      for (i32 i = l; i < r; ++i) {\n        dp_r[l][r] |= win[r][i] & dp_r[l][i] & dp_l[r - 1][i];\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    ans += dp_r[0][i] & dp_l[i][n - 1];\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#define max(a, b)\t(((a) > (b)) ? (a) : (b))\t\t/* ２個の値の最大値 */\n#define min(a, b)\t(((a) < (b)) ? (a) : (b))\t\t/* ２個の値の最小値 */\n#define ENTER\t\tprintf(\"\\n\")\t\t\t\t\t/* 改行プリント */\n/********************************************************************************************************************************/\n/* main *************************************************************************************************************************/\n/********************************************************************************************************************************/\nint DEBUG = 0;\t\t\t\t\t\t\t\t\t\t/* デバッグプリント 提出時は0 */\nchar\t*a[2001];\nint calc(int t, int low, int high) {\n\tint ret0=0,ret1=0,i;\n\tif (DEBUG) printf(\"calc t l h : %d %d %d\\n\",t,low,high);\n\tif ((t==low)&&(t==high)) return 1;\n\tif (t==low) ret0 = 1;\n\tfor(i=low; i<t; i++) {\n\t\tif (a[t][i-1]=='1') {\t// tはiに勝ち\n\t\t\tif (calc(i,low,t-1)) ret0 = 1;\n\t\t\tif (ret0) {\n\t\t\t\tif (DEBUG) printf(\"calc t l h : %d %d %d ret:%d\\n\",t,low,high,ret0);\n\t\t\t\t//return ret;\n\t\t\t}\n\t\t}\n\t}\n\tif (t==high) ret1 = 1;\n\tfor(i=t+1; i<=high; i++) {\n\t\tif (a[i][t-1]=='0') { // iはtに負け→tはiに勝ち\n\t\t\tif (calc(i,t+1,high)) ret1 = 1;\n\t\t\tif (ret1) {\n\t\t\t\tif (DEBUG) printf(\"calc t l h : %d %d %d ret:%d\\n\",t,low,high,ret1);\n\t\t\t\t//return ret;\n\t\t\t}\n\t\t}\n\t}\n\tif ((ret0==1)&&(ret1==1)) return 1;\n\telse return 0;\n}\n\nint main()\n{\n\tint\t\ti, n, ans = 0;\n\n\tscanf(\"%d\", &n);\n\tfor(i=2;i<=n;i++) {\n\t\ta[i] = calloc(i, sizeof(char));\n\t\tscanf(\"%s\",a[i]);\n\t}\n\t\n\tfor(i=1;i<=n;i++) {\n\t\tans += calc(i,1,n);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n  int n,cnt = 0;\n  scanf(\"%d\",&n);\n  char s[n];\n  for(int i = 0;i < n - 1;i++){\n    scanf(\"%s\",&s);\n    for(int j = 0;j <= i;j++){\n      if(s[j] == '0')cnt++;\n    }\n  }\n  printf(\"%d\\n\",cnt);\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.function.IntConsumer;\nimport java.io.IOException;\nimport java.util.function.IntPredicate;\nimport java.io.Serializable;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FRandomTournament solver = new FRandomTournament();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FRandomTournament {\n        Debug debug = new Debug(true);\n        BitSet tmp;\n        BitSet[] beats;\n        BitSet[][] L;\n        BitSet[][] R;\n        BitSet[][] G;\n        int[][] LVisited;\n        int[][] RVisited;\n        int[][] GVisited;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            beats = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                beats[i] = new BitSet(n);\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (in.readChar() == '1') {\n                        beats[i].set(j);\n                    } else {\n                        beats[j].set(i);\n                    }\n                }\n            }\n\n            L = new BitSet[2][n];\n            R = new BitSet[2][n];\n            G = new BitSet[2][n];\n            LVisited = new int[2][n];\n            RVisited = new int[2][n];\n            GVisited = new int[2][n];\n\n            for (int i = 0; i < 2; i++) {\n                for (int j = 0; j < n; j++) {\n                    L[i][j] = new BitSet(n);\n                    R[i][j] = new BitSet(n);\n                    G[i][j] = new BitSet(n);\n                    RVisited[i][j] = GVisited[i][j] = LVisited[i][j] = i == 0 ? j - 1 : j + 1;\n                }\n            }\n            tmp = new BitSet(n);\n\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (R(0, i) && L(i, n - 1)) {\n                    debug.debug(\"i\", i);\n                    ans++;\n                }\n            }\n\n            out.println(ans);\n        }\n\n        public void prepareL(int i, int j, int k) {\n            int step = i == 0 ? 1 : -1;\n            int use = i == 0 ? j : k;\n            IntPredicate breakCondition = i == 0 ? x -> x < k : x -> x > j;\n            IntConsumer consumer = i == 0 ? x -> L[0][j].set(x, L(j, x)) : x -> L[1][k].set(x, L(x, k));\n            while (breakCondition.test(LVisited[i][use])) {\n                LVisited[i][use] += step;\n                consumer.accept(LVisited[i][use]);\n            }\n        }\n\n        public void prepareR(int i, int j, int k) {\n            int step = i == 0 ? 1 : -1;\n            int use = i == 0 ? j : k;\n            IntPredicate breakCondition = i == 0 ? x -> x < k : x -> x > j;\n            IntConsumer consumer = i == 0 ? x -> R[0][j].set(x, R(j, x)) : x -> R[1][k].set(x, R(x, k));\n            while (breakCondition.test(RVisited[i][use])) {\n                RVisited[i][use] += step;\n                consumer.accept(RVisited[i][use]);\n            }\n        }\n\n        public void prepareG(int i, int j, int k) {\n            int step = i == 0 ? 1 : -1;\n            int use = i == 0 ? j : k;\n            IntPredicate breakCondition = i == 0 ? x -> x < k : x -> x > j;\n            IntConsumer consumer = i == 0 ? x -> G[0][j].set(x, G(j, x)) : x -> G[1][k].set(x, G(x, k));\n            while (breakCondition.test(GVisited[i][use])) {\n                GVisited[i][use] += step;\n                consumer.accept(GVisited[i][use]);\n            }\n        }\n\n        public boolean L(int l, int r) {\n            if (l == r) {\n                return true;\n            }\n            prepareL(1, l + 1, r);\n            prepareG(0, l, r);\n            tmp.copy(beats[l]);\n            tmp.and(L[1][r]);\n            tmp.and(G[0][l]);\n            return tmp.size(l, r) > 0;\n        }\n\n        public boolean R(int l, int r) {\n            if (l == r) {\n                return true;\n            }\n            prepareR(0, l, r - 1);\n            prepareG(1, l, r);\n            tmp.copy(beats[r]);\n            tmp.and(R[0][l]);\n            tmp.and(G[1][r]);\n            return tmp.size(l, r) > 0;\n        }\n\n        public boolean G(int l, int r) {\n            if (l == r) {\n                return false;\n            }\n            prepareL(0, l, r - 1);\n            prepareR(1, l + 1, r);\n            tmp.copy(R[1][r]);\n            tmp.leftShift(1);\n            tmp.and(L[0][l]);\n            return tmp.size(l, r - 1) > 0;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n    }\n\n    static final class BitSet implements Serializable, Cloneable {\n        private long[] data;\n        private long tailAvailable;\n        private int capacity;\n        private int m;\n        private static final int SHIFT = 6;\n        private static final int LOW = 63;\n        private static final int BITS_FOR_EACH = 64;\n        private static final long ALL_ONE = ~0L;\n        private static final long ALL_ZERO = 0L;\n        private static final int MAX_OFFSET = 63;\n        private static long[] EMPTY_ARRAY = new long[0];\n\n        public BitSet(int n) {\n            capacity = n;\n            this.m = (capacity + 64 - 1) / 64;\n            data = new long[m];\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n        }\n\n        public BitSet(BitSet bs) {\n            this.data = bs.data.clone();\n            this.tailAvailable = bs.tailAvailable;\n            this.capacity = bs.capacity;\n            this.m = bs.m;\n        }\n\n        private BitSet(BitSet bs, int l, int r) {\n            this.data = EMPTY_ARRAY;\n            copyInterval(bs, l, r);\n        }\n\n        public void copyInterval(BitSet bs, int l, int r) {\n            capacity = r - l + 1;\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n            int reqLength = word(r) - word(l) + 1;\n            if (data.length >= word(r) - word(l) + 1) {\n                System.arraycopy(bs.data, word(l), data, 0, reqLength);\n            } else {\n                data = Arrays.copyOfRange(bs.data, word(l), word(r) + 1);\n            }\n            this.m = reqLength;\n            leftShift(offset(l));\n            this.m = (capacity + 64 - 1) / 64;\n            data[m - 1] &= tailAvailable;\n            for (int i = m; i < reqLength; i++) {\n                data[i] = 0;\n            }\n        }\n\n        public void set(int i) {\n            data[word(i)] |= (1L << offset(i));\n        }\n\n        public void set(int i, boolean val) {\n            if (val) {\n                set(i);\n            } else {\n                clear(i);\n            }\n        }\n\n        private static int word(int i) {\n            return i >>> SHIFT;\n        }\n\n        private static int offset(int i) {\n            return i & LOW;\n        }\n\n        private long oneBetween(int l, int r) {\n            if (r < l) {\n                return 0;\n            }\n            long lBegin = 1L << offset(l);\n            long rEnd = 1L << offset(r);\n            return (ALL_ONE ^ (lBegin - 1)) & ((rEnd << 1) - 1);\n        }\n\n        public void clear(int i) {\n            data[word(i)] &= ~(1L << offset(i));\n        }\n\n        public int capacity() {\n            return capacity;\n        }\n\n        public int size(int l, int r) {\n            if (r < l) {\n                return 0;\n            }\n            int ans = 0;\n            int lWord = l >>> SHIFT;\n            int rWord = r >>> SHIFT;\n            for (int i = lWord + 1; i < rWord; i++) {\n                ans += Long.bitCount(data[i]);\n            }\n            //lword\n            if (lWord == rWord) {\n                ans += Long.bitCount(data[lWord] & oneBetween(offset(l), offset(r)));\n            } else {\n                ans += Long.bitCount(data[lWord] & oneBetween(offset(l), MAX_OFFSET));\n                ans += Long.bitCount(data[rWord] & oneBetween(0, offset(r)));\n            }\n            return ans;\n        }\n\n        public void copy(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            System.arraycopy(bs.data, 0, data, 0, n);\n            Arrays.fill(data, n, n, 0);\n        }\n\n        public void and(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            for (int i = 0; i < n; i++) {\n                data[i] &= bs.data[i];\n            }\n        }\n\n        public int nextSetBit(int start) {\n            int offset = offset(start);\n            int w = word(start);\n            if (offset != 0) {\n                long mask = oneBetween(offset, MAX_OFFSET);\n                if ((data[w] & mask) != 0) {\n                    return Long.numberOfTrailingZeros(data[w] & mask) + w * BITS_FOR_EACH;\n                }\n                w++;\n            }\n\n            while (w < m && data[w] == ALL_ZERO) {\n                w++;\n            }\n            if (w >= m) {\n                return capacity();\n            }\n            return Long.numberOfTrailingZeros(data[w]) + w * BITS_FOR_EACH;\n        }\n\n        public void leftShift(int n) {\n            int wordMove = word(n);\n            int offsetMove = offset(n);\n            int rshift = MAX_OFFSET - (offsetMove - 1);\n\n            if (offsetMove != 0) {\n                //slightly\n                for (int i = 0; i < m; i++) {\n                    if (i > 0) {\n                        data[i - 1] |= data[i] << rshift;\n                    }\n                    data[i] >>>= offsetMove;\n                }\n            }\n            if (wordMove > 0) {\n                for (int i = 0; i < m; i++) {\n                    if (i >= wordMove) {\n                        data[i - wordMove] = data[i];\n                    }\n                    data[i] = 0;\n                }\n            }\n        }\n\n        public BitSet clone() {\n            return new BitSet(this);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder(\"{\");\n            for (int i = nextSetBit(0); i < capacity(); i = nextSetBit(i + 1)) {\n                builder.append(i).append(',');\n            }\n            if (builder.length() > 1) {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append(\"}\");\n            return builder.toString();\n        }\n\n        public int hashCode() {\n            int ans = 1;\n            for (int i = 0; i < m; i++) {\n                ans = ans * 31 + Long.hashCode(data[i]);\n            }\n            return ans;\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof BitSet)) {\n                return false;\n            }\n            BitSet other = (BitSet) obj;\n            if (other.capacity != capacity) {\n                return false;\n            }\n            for (int i = 0; i < m; i++) {\n                if (other.data[i] != data[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, int x) {\n            if (offline) {\n                debug(name, \"\" + x);\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(\"%s=%s\", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic int M;\n\tstatic long[][] win;\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tmap[i] = ns().toCharArray();\n\t\t}\n\t\t\n\t\tM = (n>>>6)+1;\n\t\twin = new long[n][M];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < i;j++){\n\t\t\t\tif(map[i][j] == '1'){\n\t\t\t\t\twin[i][j>>>6] |= 1L<<j;\n\t\t\t\t}else{\n\t\t\t\t\twin[j][i>>>6] |= 1L<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ct = 0;\n\t\trcache = new int[n][n];\n\t\tlcache = new int[n][n];\n\t\twcache = new int[n][n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(rwin(0, i) && lwin(i, n-1)){\n\t\t\t\tct++;\n\t\t\t}\n\t\t}\n//\t\tfor(int[] u : rcache){\n//\t\t\ttr(u);\n//\t\t}\n\t\tout.println(ct);\n\t}\n\t\n\tstatic int[][] rcache;\n\tstatic int[][] lcache;\n\tstatic int[][] wcache;\n\tstatic Random gen = new Random();\n\t\n\tstatic boolean wwin(int l, int r)\n\t{\n\t\tif(wcache[l][r] != 0)return wcache[l][r] == 1;\n\t\tif(r-l >= 50){\n\t\t\tfor(int k = 0;k < 50;k++){\n\t\t\t\tint j = l + gen.nextInt(r-l);\n\t\t\t\tif(lwin(l, j) && rwin(j+1, r)){\n\t\t\t\t\twcache[l][r] = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = l;j <= r-1;j++){\n\t\t\t\tif(lwin(l, j) && rwin(j+1, r)){\n\t\t\t\t\twcache[l][r] = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twcache[l][r] = -1;\n\t\treturn false;\n\t}\n\t\n\t// in [0,r] r win?\n\tstatic boolean rwin(int l, int r)\n\t{\n\t\tif(rcache[l][r] != 0)return rcache[l][r] == 1;\n\t\tassert l <= r;\n\t\tif(l == r){\n\t\t\trcache[l][r] = 1;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(r-l >= 50){\n\t\t\tfor(int k = 0;k < 50;k++){\n\t\t\t\tint i = l + gen.nextInt(r-l);\n\t\t\t\tif(win[r][i>>>6]<<~i<0){\n\t\t\t\t\tboolean ret = rwin(l, i) && wwin(i, r);\n\t\t\t\t\tif(ret){\n\t\t\t\t\t\trcache[l][r] = 1;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = r-1;i >= l;i--){\n\t\t\t\tif(win[r][i>>>6]<<~i<0){\n\t\t\t\t\tboolean ret = rwin(l, i) && wwin(i, r);\n\t\t\t\t\tif(ret){\n\t\t\t\t\t\trcache[l][r] = 1;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trcache[l][r] = -1;\n\t\treturn false;\n\t}\n\t\n\tstatic boolean lwin(int l, int r)\n\t{\n\t\tif(lcache[l][r] != 0)return lcache[l][r] == 1;\n\t\tassert l <= r;\n\t\tif(l == r){\n\t\t\tlcache[l][r] = 1;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif(r-l >= 50){\n\t\t\tfor(int k = 0;k < 50;k++){\n\t\t\t\tint i = l+1 + gen.nextInt(r-l);\n\t\t\t\tif(win[l][i>>>6]<<~i<0){\n\t\t\t\t\tboolean ret = lwin(i, r) && wwin(l, i);\n\t\t\t\t\tif(ret){\n\t\t\t\t\t\tlcache[l][r] = 1;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = l+1;i <= r;i++){\n\t\t\t\tif(win[l][i>>>6]<<~i<0){\n\t\t\t\t\tboolean ret = lwin(i, r) && wwin(l, i);\n\t\t\t\t\tif(ret){\n\t\t\t\t\t\tlcache[l][r] = 1;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlcache[l][r] = -1;\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Locale;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tFastIO io = new FastIO();\n\t\t/*\n\t\t * 考察\n\t\t * 連続してるなら使えばいいじゃない\n\t\t * 自分の右側と自分の左側に、自分より弱い人が勝ち残れれば2戦で勝てる\n\t\t * よってこれが可能かだけ考えれば良い\n\t\t * dpl[i][j]は区間[i, j]についてiが優勝する\n\t\t * dpr[i][j]は区間[i, j]についてjが優勝する\n\t\t * これで遷移を組んでみる\n\t\t * まず自明にdpl[i][i]=dpr[i][i]=true、これが初期値\n\t\t * で、次に遷移\n\t\t * ・dpl[i][j] = or[k = i + 1, j](A[i][k] & dpr[i + 1][k] & dpl[k][j])\n\t\t * これはあるkについて、iがkに勝てるときにこの対象が生き残ってくれればいいわけで\n\t\t * それは[i + 1, k]でkが優勝し、[k, j]でkが優勝しているなら[i + 1, j]でkが優勝できるということ\n\t\t * 後はこのkにiが勝って終わり！\n\t\t * 同様に次の遷移も言える\n\t\t * ・dpr[i][j] = or[k = i, j - 1](A[j][k] & dpr[i][k] & dpl[k][j - 1])\n\t\t * これはあるkについて、[i, k]でkが優勝し[k, j - 1]でkが優勝しているという場合\n\t\t * この場合は、[i, j-1]でkが優勝してるので、あとはこのkにjが勝って終わり！\n\t\t * 後は答えに関しては、全区間について見て優勝してれば終わり\n\t\t * さて、これはどう計算できるか？\n\t\t * 区間DPなので、j-iの値を少しずつ大きくしていけば良い\n\t\t * 見れば分かるように区間を1個以上縮めた奴から導出してるからね、そりゃそう\n\t\t * これはO(N^3)だがまぁうん、BitSet高速化を考えていく\n\t\t * 計算式について、どれもindexが連続しているなら一気に計算できるので考える\n\t\t * キャッシュ連続性も考えると、最後にkが持ち込まれるのが理想\n\t\t * dpl[l][r]は[l, r]においてrが勝つ確率\n\t\t * dpr[r][l]は[l, r]においてlが勝つ確率\n\t\t * とする\n\t\t * dpl[l][r] = A[r][k] & dpl[l][k] & dpr[r - 1][k](k=[l, r))という式に変形できる\n\t\t * dpr[r][l] = A[l][k] & dpl[l+1][k] & dpr[r][k](k=(l, r])となり、これで無事に解けた\n\t\t * 勿論答えはdpl[0][i] & dpr[N-1][i]なので\n\t\t *\n\t\t */\n\t\tint N = io.nextInt();\n\t\tBitSet[] A = new BitSet[N];\n\t\tfor (int i = 0;i < N;++ i) A[i] = new BitSet();\n\t\tfor (int i = 1;i < N;++ i) {\n\t\t\tchar[] s = io.next().toCharArray();\n\t\t\tfor (int j = 0;j < i;++ j) {\n\t\t\t\t A[i].set(j, s[j] == '1');\n\t\t\t\t A[j].set(i, !A[i].get(j));\n\t\t\t}\n\t\t}\n\t\tBitSet[] dpl = new BitSet[N], dpr = new BitSet[N];\n\t\tfor (int i = 0;i < N;++ i) {\n\t\t\tdpl[i] = new BitSet(N);\n\t\t\tdpl[i].set(i);\n\t\t\tdpr[i] = new BitSet(N);\n\t\t\tdpr[i].set(i);\n\t\t}\n\t\tfor (int i = 1;i < N;++ i) {\n\t\t\tfor (int r = i;r < N;++ r) {\n\t\t\t\tint l = r - i;\n\t\t\t\tfor (int k = l;k < r;++ k) {\n\t\t\t\t\tif (dpl[l].get(r)) break;\n\t\t\t\t\tdpl[l].set(r, A[r].get(k) && dpl[l].get(k) && dpr[r - 1].get(k));\n\t\t\t\t}\n\t\t\t\tfor (int k = l + 1;k <= r;++ k) {\n\t\t\t\t\tif (dpr[r].get(l)) break;\n\t\t\t\t\tdpr[r].set(l, A[l].get(k) && dpl[l + 1].get(k) && dpr[r].get(k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0;i < N;++ i) if (dpl[0].get(i) && dpr[N - 1].get(i)) ++ ans; // [0, N)でiが勝ったなら勝ち\n\t\tio.print(ans);\n\t\tio.flush();\n\t}\n\n\tpublic class FastIO {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tpublic final PrintWriter out = new PrintWriter(System.out, false);\n\t\tpublic final PrintWriter err = new PrintWriter(System.err, false);\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tread = 0;\n\t\t\t\t\tlength = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[read++] : -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\tif (!hasNextByte())  throw new NoSuchElementException();\n\t\t\treturn (char)readByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b;\n\t\t\twhile (isPrintableChar(b = readByte())) sb.appendCodePoint(b);\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (!isNumber(b)) throw new NumberFormatException();\n\t\t\twhile (true) {\n\t\t\t\tif (isNumber(b)) {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;\n\t\t\t\telse throw new NumberFormatException();\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(boolean b) {\n\t\t\tout.print(b);\n\t\t}\n\n\t\tpublic void print(char c) {\n\t\t\tout.print(c);\n\t\t}\n\n\t\tpublic void print(char[] s) {\n\t\t\tout.print(s);\n\t\t}\n\n\t\tpublic void print(double d) {\n\t\t\tout.print(d);\n\t\t}\n\n\t\tpublic void print(float f) {\n\t\t\tout.print(f);\n\t\t}\n\n\t\tpublic void print(int i) {\n\t\t\tout.print(i);\n\t\t}\n\n\t\tpublic void print(long l) {\n\t\t\tout.print(l);\n\t\t}\n\n\t\tpublic void print(Object obj) {\n\t\t\tout.print(obj);\n\t\t}\n\n\t\tpublic void print(String s) {\n\t\t\tout.print(s);\n\t\t}\n\n\t\tpublic void printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t}\n\n\t\tpublic void printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tout.println();\n\t\t}\n\n\t\tpublic void println(boolean b) {\n\t\t\tout.println(b);\n\t\t}\n\n\t\tpublic void println(char c) {\n\t\t\tout.println(c);\n\t\t}\n\n\t\tpublic void println(char[] s) {\n\t\t\tout.println(s);\n\t\t}\n\n\t\tpublic void println(double d) {\n\t\t\tout.println(d);\n\t\t}\n\n\t\tpublic void println(float f) {\n\t\t\tout.println(f);\n\t\t}\n\n\t\tpublic void println(int i) {\n\t\t\tout.println(i);\n\t\t}\n\n\t\tpublic void println(long l) {\n\t\t\tout.println(l);\n\t\t}\n\n\t\tpublic void println(Object obj) {\n\t\t\tout.println(obj);\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\tout.println(s);\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n    static ArrayList<ArrayList<Integer>> a;\n    static boolean[] used;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        a = new ArrayList<>();\n        for(int i = 0; i < n; i++) a.add(new ArrayList<>());\n        for (int i = 1; i < n; i++) {\n            String s = sc.next();\n            for (int j = 0; j < i; j++) {\n                if(s.charAt(j) == '1') a.get(i).add(j);\n                else a.get(j).add(i);\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            used = new boolean[n];\n            used[i] = true;\n            int cnt = 0;\n            cnt += dfs(i, 0, n-1);\n            if(cnt == n-1) ans++;\n        }\n        System.out.println(ans);\n        sc.close();\n\n    }\n\n    private static int dfs(int i, int l, int r) {\n        int ret = 0;\n        for(int v : a.get(i)){\n            if(used[v]) continue;\n            if(v < l || r < v) continue;\n            ret++;\n            used[v] = true;\n            if(v < i) ret += dfs(v, l, i);\n            else ret += dfs(v, i, r);\n        }\n        return ret;\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.lang.NumberFormatException;\nimport java.util.BitSet;\nimport java.util.NoSuchElementException;\npublic class Main {\n  public static void main(String[] args) {\n    Main m = new Main();\n    m.run();\n  }\n  private void run() {\n    FastScanner fs = new FastScanner();\n    int N = fs.nextInt();\n    BitSet[] A = new BitSet[N];\n    BitSet[] dpl = new BitSet[N];\n    BitSet[] dpr = new BitSet[N];\n    for (int i=0;i<N;i++) {\n      A[i] = new BitSet();\n      dpl[i] = new BitSet();\n      dpr[i] = new BitSet();\n      dpl[i].set(i);\n      dpr[i].set(i);\n    }\n    for (int i=1;i<N;i++) {\n      char[] s = fs.nextString().toCharArray();\n      for (int j=0;j<i;j++) {\n        A[i].set(j,s[j] == '1');\n        A[j].set(i,s[j] == '0');\n      }\n    }\n    for (int i=1;i<N;i++) {\n      for (int l=0;l<N-i;l++) {\n        int r = l+i;\n        BitSet tmp = A[r].get(0,N);\n        tmp.and(dpl[l]);\n        tmp.and(dpr[r-1]);\n        dpl[l].set(r,!tmp.get(l,r).isEmpty());\n        tmp = A[l].get(0,N);\n        tmp.and(dpl[l+1]);\n        tmp.and(dpr[r]);\n        dpr[r].set(l,!tmp.get(l+1,r+1).isEmpty());\n      }\n    }\n    int ans = 0;\n    for (int i=0;i<N;i++) {\n      if (dpl[0].get(i) && dpr[N-1].get(i)) ans++;\n    }\n    System.out.println(ans);\n  }\n}\nclass FastScanner {\n  private final InputStream ins = System.in;\n  private final byte[] buf = new byte[1024];\n  private int ptr = 0;\n  private int len = 0;\n  private boolean hasNextByte() {\n    if (ptr < len) return true;\n    ptr = 0;\n    try {\n      len = ins.read(buf);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    if (len < 1) return false;\n    return true;\n  }\n  private int read() {\n    if (hasNextByte()) return buf[ptr++];\n    return -1;\n  }\n  private static boolean isPrintable(int c) {\n    return 32 < c && c < 127;\n  }\n  private void skipUnprintable() {\n    while (hasNextByte() && !isPrintable(buf[ptr])) ptr++;\n  }\n  public boolean hasNext() {\n    skipUnprintable();\n    return hasNextByte();\n  }\n  public String nextString() {\n    if (!hasNext()) throw new NoSuchElementException();\n    StringBuilder sb = new StringBuilder();\n    for (int b = read();isPrintable(b);b = read()) sb.appendCodePoint(b);\n    return sb.toString();\n  }\n  public int nextInt() {\n    if (!hasNext()) throw new NoSuchElementException();\n    int n = 0;\n    boolean negative = false;\n    int b = read();\n    if (b == '-') {\n      negative = true;\n      b = read();\n    }\n    if (b < '0' || '9' < b) throw new NumberFormatException();\n    while (true) {\n      if (b == -1 || !isPrintable(b)) return negative ? -n : n;\n      if (b < '0' || '9' < b) throw new NumberFormatException();\n      n = 10*n+(b-'0');\n      b = read();\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n \npublic class Main implements Runnable {\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        FastScanner sc = new FastScanner();\n        \n        int n = sc.nextInt();\n        \n        boolean[][] isWin = new boolean[n][n];\n\n        for(int i=1;i<n;i++){\n        \t\n    \t\tchar[] v = sc.next().toCharArray();\n    \t\t\n        \tfor(int j=0;j<i;j++){\n        \t\tif(v[j]=='1'){\n            \t\tisWin[i][j] = false;\n            \t\tisWin[j][i] = true;\n        \t\t}\n        \t\telse{\n            \t\tisWin[i][j] = true;\n            \t\tisWin[j][i] = false;\n        \t\t}\n        \t}\n        }\n        \n        ArrayList<Integer> list = new ArrayList<>(); //[0,i]で勝ちうる人のidxをlistへ格納\n        list.add(0);\n        \n        for(int i=1;i<n;i++){\n        \tint canWinMax = i;\n        \t\n        \tloop:for(int j=i-1;j>=0;j--){\n        \t\tif(isWin[j][i]==true){\n        \t\t\tcanWinMax = j;\n        \t\t\tbreak loop;\n        \t\t}\n        \t}\n        \t\n        \tboolean caniWin = false;\n        \tfor(int win:list){\n        \t\tif(isWin[i][win] = true){\n        \t\t\tcaniWin = true;\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \t\n        \tloop2:for(int idx=0;idx<list.size();idx++){\n        \t\tint win = list.get(idx);\n        \t\tif(win>canWinMax){\n        \t\t\tlist.remove(idx);\n        \t\t}\n        \t}\n        \t\n        \t\n        \tif(caniWin){\n        \t\tlist.add(i);\n        \t}\n        \t\n        \t\n        }\n        \n        System.out.println(list.size());\n        \n    }\n \n}\n \n\n \nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic int M;\n\tstatic long[][] win;\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tmap[i] = ns().toCharArray();\n\t\t}\n\t\t\n\t\tM = (n>>>6)+1;\n\t\twin = new long[n][M];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < i;j++){\n\t\t\t\tif(map[i][j] == '1'){\n\t\t\t\t\twin[i][j>>>6] |= 1L<<j;\n\t\t\t\t}else{\n\t\t\t\t\twin[j][i>>>6] |= 1L<<i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ct = 0;\n\t\trcache = new int[n][n];\n\t\tlcache = new int[n][n];\n\t\twcache = new int[n][n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(rwin(0, i) && lwin(i, n-1)){\n\t\t\t\tct++;\n\t\t\t}\n\t\t}\n//\t\tfor(int[] u : rcache){\n//\t\t\ttr(u);\n//\t\t}\n\t\tout.println(ct);\n\t}\n\t\n\tstatic int[][] rcache;\n\tstatic int[][] lcache;\n\tstatic int[][] wcache;\n\t\n\tstatic boolean wwin(int l, int r)\n\t{\n\t\tif(wcache[l][r] != 0)return wcache[l][r] == 1;\n\t\tfor(int j = l;j <= r-1;j++){\n\t\t\tif(lwin(l, j) && rwin(j+1, r)){\n\t\t\t\twcache[l][r] = 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\twcache[l][r] = -1;\n\t\treturn false;\n\t}\n\t\n\t// in [0,r] r win?\n\tstatic boolean rwin(int l, int r)\n\t{\n\t\tif(rcache[l][r] != 0)return rcache[l][r] == 1;\n\t\tassert l <= r;\n\t\tif(l == r){\n\t\t\trcache[l][r] = 1;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i = r-1;i >= l;i--){\n\t\t\tif(win[r][i>>>6]<<~i<0){\n\t\t\t\tboolean ret = rwin(l, i) && wwin(i, r);\n\t\t\t\tif(ret){\n\t\t\t\t\trcache[l][r] = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trcache[l][r] = -1;\n\t\treturn false;\n\t}\n\t\n\tstatic boolean lwin(int l, int r)\n\t{\n\t\tif(lcache[l][r] != 0)return lcache[l][r] == 1;\n\t\tassert l <= r;\n\t\tif(l == r){\n\t\t\tlcache[l][r] = 1;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i = l+1;i <= r;i++){\n\t\t\tif(win[l][i>>>6]<<~i<0){\n\t\t\t\tboolean ret = lwin(i, r) && wwin(l, i);\n\t\t\t\tif(ret){\n\t\t\t\t\tlcache[l][r] = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlcache[l][r] = -1;\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.function.Supplier;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.io.UncheckedIOException;\nimport java.util.function.Consumer;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FRandomTournament solver = new FRandomTournament();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FRandomTournament {\n        BitSet[] adj;\n        BitSet[] lWinner;\n        BitSet[] rWinner;\n        int[] lWinnerR;\n        int[] rWinnerL;\n        Buffer<BitSet> buffer;\n        int[][] dpL;\n        int[][] dpR;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            adj = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new BitSet(n);\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (in.readChar() == '0') {\n                        adj[j].set(i);\n                    } else {\n                        adj[i].set(j);\n                    }\n                }\n            }\n\n            lWinner = new BitSet[n];\n            rWinner = new BitSet[n];\n            lWinnerR = new int[n];\n            rWinnerL = new int[n];\n            dpL = new int[n][n];\n            dpR = new int[n][n];\n            SequenceUtils.deepFill(dpL, -1);\n            SequenceUtils.deepFill(dpR, -1);\n            for (int i = 0; i < n; i++) {\n                lWinner[i] = new BitSet(n);\n                rWinner[i] = new BitSet(n);\n                lWinner[i].set(i);\n                rWinner[i].set(i);\n                lWinnerR[i] = rWinnerL[i] = i;\n                dpL[i][i] = dpR[i][i] = 1;\n            }\n\n            buffer = new Buffer<>(() -> new BitSet(n));\n\n            for (int i = 0; i < n; i++) {\n                solveLToR(i, n - 1);\n            }\n\n            BitSet possible = winner(0, n - 1);\n            int ans = possible.size();\n            out.println(ans);\n        }\n\n        public BitSet winner(int l, int r) {\n            solveLToR(l, r);\n            solveRToL(l, r);\n            BitSet set = buffer.alloc();\n            set.copy(lWinner[l]);\n            set.and(rWinner[r]);\n            return set;\n        }\n\n        public void solveLToR(int l, int r) {\n            while (lWinnerR[l] < r) {\n                ++lWinnerR[l];\n                if (dpR(l, lWinnerR[l]) == 1) {\n                    lWinner[l].set(lWinnerR[l]);\n                }\n            }\n        }\n\n        public void solveRToL(int l, int r) {\n            while (rWinnerL[r] > l) {\n                --rWinnerL[r];\n                if (dpL(rWinnerL[r], r) == 1) {\n                    rWinner[r].set(rWinnerL[r]);\n                }\n            }\n        }\n\n        public int dpR(int l, int r) {\n            if (dpR[l][r] == -1) {\n                BitSet bs = winner(l, r - 1);\n                bs.and(adj[r]);\n                dpR[l][r] = Integer.signum(bs.size(l, r - 1));\n                buffer.release(bs);\n            }\n            return dpR[l][r];\n        }\n\n        public int dpL(int l, int r) {\n            if (dpL[l][r] == -1) {\n                BitSet bs = winner(l + 1, r);\n                bs.and(adj[l]);\n                dpL[l][r] = Integer.signum(bs.size(l + 1, r));\n                buffer.release(bs);\n            }\n            return dpL[l][r];\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n    }\n\n    static class Buffer<T> {\n        private Deque<T> deque;\n        private Supplier<T> supplier;\n        private Consumer<T> cleaner;\n        private int allocTime;\n        private int releaseTime;\n\n        public Buffer(Supplier<T> supplier) {\n            this(supplier, (x) -> {\n            });\n        }\n\n        public Buffer(Supplier<T> supplier, Consumer<T> cleaner) {\n            this(supplier, cleaner, 0);\n        }\n\n        public Buffer(Supplier<T> supplier, Consumer<T> cleaner, int exp) {\n            this.supplier = supplier;\n            this.cleaner = cleaner;\n            deque = new ArrayDeque<>(exp);\n        }\n\n        public T alloc() {\n            allocTime++;\n            return deque.isEmpty() ? supplier.get() : deque.removeFirst();\n        }\n\n        public void release(T e) {\n            releaseTime++;\n            cleaner.accept(e);\n            deque.addLast(e);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static final class BitSet implements Serializable, Cloneable {\n        private long[] data;\n        private long tailAvailable;\n        private int capacity;\n        private int m;\n        private static final int SHIFT = 6;\n        private static final int LOW = 63;\n        private static final int BITS_FOR_EACH = 64;\n        private static final long ALL_ONE = ~0L;\n        private static final long ALL_ZERO = 0L;\n        private static final int MAX_OFFSET = 63;\n\n        public BitSet(int n) {\n            capacity = n;\n            this.m = (capacity + 64 - 1) / 64;\n            data = new long[m];\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n        }\n\n        public BitSet(BitSet bs) {\n            this.data = bs.data.clone();\n            this.tailAvailable = bs.tailAvailable;\n            this.capacity = bs.capacity;\n            this.m = bs.m;\n        }\n\n        private BitSet(BitSet bs, int l, int r) {\n            capacity = r - l + 1;\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n            data = Arrays.copyOfRange(bs.data, word(l), word(r) + 1);\n            this.m = data.length;\n            leftShift(offset(l));\n            this.m = (capacity + 64 - 1) / 64;\n            data[m - 1] &= tailAvailable;\n            for (int i = m; i < data.length; i++) {\n                data[i] = 0;\n            }\n        }\n\n        public void set(int i) {\n            data[word(i)] |= (1L << offset(i));\n        }\n\n        private static int word(int i) {\n            return i >>> SHIFT;\n        }\n\n        private static int offset(int i) {\n            return i & LOW;\n        }\n\n        private long oneBetween(int l, int r) {\n            if (r < l) {\n                return 0;\n            }\n            long lBegin = 1L << offset(l);\n            long rEnd = 1L << offset(r);\n            return (ALL_ONE ^ (lBegin - 1)) & ((rEnd << 1) - 1);\n        }\n\n        public int capacity() {\n            return capacity;\n        }\n\n        public int size() {\n            int ans = 0;\n            for (long x : data) {\n                ans += Long.bitCount(x);\n            }\n            return ans;\n        }\n\n        public int size(int l, int r) {\n            if (r < l) {\n                return 0;\n            }\n            int ans = 0;\n            int lWord = l >>> SHIFT;\n            int rWord = r >>> SHIFT;\n            for (int i = lWord + 1; i < rWord; i++) {\n                ans += Long.bitCount(data[i]);\n            }\n            //lword\n            if (lWord == rWord) {\n                ans += Long.bitCount(data[lWord] & oneBetween(offset(l), offset(r)));\n            } else {\n                ans += Long.bitCount(data[lWord] & oneBetween(offset(l), MAX_OFFSET));\n                ans += Long.bitCount(data[rWord] & oneBetween(0, offset(r)));\n            }\n            return ans;\n        }\n\n        public void copy(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            System.arraycopy(bs.data, 0, data, 0, n);\n            Arrays.fill(data, n, n, 0);\n        }\n\n        public void and(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            for (int i = 0; i < n; i++) {\n                data[i] &= bs.data[i];\n            }\n        }\n\n        public int nextSetBit(int start) {\n            int offset = offset(start);\n            int w = word(start);\n            if (offset != 0) {\n                long mask = oneBetween(offset, MAX_OFFSET);\n                if ((data[w] & mask) != 0) {\n                    return Long.numberOfTrailingZeros(data[w] & mask) + w * BITS_FOR_EACH;\n                }\n                w++;\n            }\n\n            while (w < m && data[w] == ALL_ZERO) {\n                w++;\n            }\n            if (w >= m) {\n                return capacity();\n            }\n            return Long.numberOfTrailingZeros(data[w]) + w * BITS_FOR_EACH;\n        }\n\n        public void leftShift(int n) {\n            int wordMove = word(n);\n            int offsetMove = offset(n);\n            int rshift = MAX_OFFSET - (offsetMove - 1);\n\n            if (offsetMove != 0) {\n                //slightly\n                for (int i = 0; i < m; i++) {\n                    if (i > 0) {\n                        data[i - 1] |= data[i] << rshift;\n                    }\n                    data[i] >>>= offsetMove;\n                }\n            }\n            if (wordMove > 0) {\n                for (int i = 0; i < m; i++) {\n                    if (i >= wordMove) {\n                        data[i - wordMove] = data[i];\n                    }\n                    data[i] = 0;\n                }\n            }\n        }\n\n        public BitSet clone() {\n            return new BitSet(this);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder(\"{\");\n            for (int i = nextSetBit(0); i < capacity(); i = nextSetBit(i + 1)) {\n                builder.append(i).append(',');\n            }\n            if (builder.length() > 1) {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append(\"}\");\n            return builder.toString();\n        }\n\n        public int hashCode() {\n            int ans = 1;\n            for (int i = 0; i < m; i++) {\n                ans = ans * 31 + Long.hashCode(data[i]);\n            }\n            return ans;\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof BitSet)) {\n                return false;\n            }\n            BitSet other = (BitSet) obj;\n            if (other.capacity != capacity) {\n                return false;\n            }\n            for (int i = 0; i < m; i++) {\n                if (other.data[i] != data[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Locale;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tFastIO io = new FastIO();\n\t\t/*\n\t\t * 考察\n\t\t * 連続してるなら使えばいいじゃない\n\t\t * 自分の右側と自分の左側に、自分より弱い人が勝ち残れれば2戦で勝てる\n\t\t * よってこれが可能かだけ考えれば良い\n\t\t * dpl[i][j]は区間[i, j]についてiが優勝する\n\t\t * dpr[i][j]は区間[i, j]についてjが優勝する\n\t\t * これで遷移を組んでみる\n\t\t * まず自明にdpl[i][i]=dpr[i][i]=true、これが初期値\n\t\t * で、次に遷移\n\t\t * ・dpl[i][j] = or[k = i + 1, j](A[i][k] & dpr[i + 1][k] & dpl[k][j])\n\t\t * これはあるkについて、iがkに勝てるときにこの対象が生き残ってくれればいいわけで\n\t\t * それは[i + 1, k]でkが優勝し、[k, j]でkが優勝しているなら[i + 1, j]でkが優勝できるということ\n\t\t * 後はこのkにiが勝って終わり！\n\t\t * 同様に次の遷移も言える\n\t\t * ・dpr[i][j] = or[k = i, j - 1](A[j][k] & dpr[i][k] & dpl[k][j - 1])\n\t\t * これはあるkについて、[i, k]でkが優勝し[k, j - 1]でkが優勝しているという場合\n\t\t * この場合は、[i, j-1]でkが優勝してるので、あとはこのkにjが勝って終わり！\n\t\t * 後は答えに関しては、全区間について見て優勝してれば終わり\n\t\t * さて、これはどう計算できるか？\n\t\t * 区間DPなので、j-iの値を少しずつ大きくしていけば良い\n\t\t * 見れば分かるように区間を1個以上縮めた奴から導出してるからね、そりゃそう\n\t\t * これはO(N^3)だがまぁうん、BitSet高速化を考えていく\n\t\t * 計算式について、どれもindexが連続しているなら一気に計算できるので考える\n\t\t * キャッシュ連続性も考えると、最後にkが持ち込まれるのが理想\n\t\t * dpl[l][r]は[l, r]においてrが勝つ確率\n\t\t * dpr[r][l]は[l, r]においてlが勝つ確率\n\t\t * とする\n\t\t * dpl[l][r] = A[r][k] & dpl[l][k] & dpr[r - 1][k](k=[l, r))という式に変形できる\n\t\t * dpr[r][l] = A[l][k] & dpl[l+1][k] & dpr[r][k](k=(l, r])となり、これで無事に解けた\n\t\t * 勿論答えはdpl[0][i] & dpr[N-1][i]なので\n\t\t *\n\t\t */\n\t\tint N = io.nextInt();\n\t\tBitSet[] A = new BitSet[N];\n\t\tfor (int i = 0;i < N;++ i) A[i] = new BitSet();\n\t\tfor (int i = 1;i < N;++ i) {\n\t\t\tchar[] s = io.next().toCharArray();\n\t\t\tfor (int j = 0;j < i;++ j) {\n\t\t\t\t A[i].set(j, s[j] == '1');\n\t\t\t\t A[j].set(i, !A[i].get(j));\n\t\t\t}\n\t\t}\n\t\tBitSet[] dpl = new BitSet[N], dpr = new BitSet[N];\n\t\tfor (int i = 0;i < N;++ i) {\n\t\t\tdpl[i] = new BitSet(N);\n\t\t\tdpl[i].set(i);\n\t\t\tdpr[i] = new BitSet(N);\n\t\t\tdpr[i].set(i);\n\t\t}\n\t\tfor (int i = 1;i < N;++ i) {\n\t\t\tfor (int r = i;r < N;++ r) {\n\t\t\t\tint l = r - i;\n\t\t\t\tBitSet tmp = A[r].get(0, N);\n\t\t\t\ttmp.and(dpl[l]);\n\t\t\t\ttmp.and(dpr[r - 1]);\n\t\t\t\tdpl[l].set(r, !tmp.get(l, r).isEmpty());\n\t\t\t\ttmp = A[l].get(0, N);\n\t\t\t\ttmp.and(dpl[l + 1]);\n\t\t\t\ttmp.and(dpr[r]);\n\t\t\t\tdpr[r].set(l, !tmp.get(l + 1, r + 1).isEmpty());\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0;i < N;++ i) if (dpl[0].get(i) && dpr[N - 1].get(i)) ++ ans; // [0, N)でiが勝ったなら勝ち\n\t\tio.print(ans);\n\t\tio.flush();\n\t}\n\n\tpublic class FastIO {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tpublic final PrintWriter out = new PrintWriter(System.out, false);\n\t\tpublic final PrintWriter err = new PrintWriter(System.err, false);\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tread = 0;\n\t\t\t\t\tlength = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[read++] : -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\tif (!hasNextByte())  throw new NoSuchElementException();\n\t\t\treturn (char)readByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b;\n\t\t\twhile (isPrintableChar(b = readByte())) sb.appendCodePoint(b);\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (!isNumber(b)) throw new NumberFormatException();\n\t\t\twhile (true) {\n\t\t\t\tif (isNumber(b)) {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;\n\t\t\t\telse throw new NumberFormatException();\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(boolean b) {\n\t\t\tout.print(b);\n\t\t}\n\n\t\tpublic void print(char c) {\n\t\t\tout.print(c);\n\t\t}\n\n\t\tpublic void print(char[] s) {\n\t\t\tout.print(s);\n\t\t}\n\n\t\tpublic void print(double d) {\n\t\t\tout.print(d);\n\t\t}\n\n\t\tpublic void print(float f) {\n\t\t\tout.print(f);\n\t\t}\n\n\t\tpublic void print(int i) {\n\t\t\tout.print(i);\n\t\t}\n\n\t\tpublic void print(long l) {\n\t\t\tout.print(l);\n\t\t}\n\n\t\tpublic void print(Object obj) {\n\t\t\tout.print(obj);\n\t\t}\n\n\t\tpublic void print(String s) {\n\t\t\tout.print(s);\n\t\t}\n\n\t\tpublic void printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t}\n\n\t\tpublic void printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tout.println();\n\t\t}\n\n\t\tpublic void println(boolean b) {\n\t\t\tout.println(b);\n\t\t}\n\n\t\tpublic void println(char c) {\n\t\t\tout.println(c);\n\t\t}\n\n\t\tpublic void println(char[] s) {\n\t\t\tout.println(s);\n\t\t}\n\n\t\tpublic void println(double d) {\n\t\t\tout.println(d);\n\t\t}\n\n\t\tpublic void println(float f) {\n\t\t\tout.println(f);\n\t\t}\n\n\t\tpublic void println(int i) {\n\t\t\tout.println(i);\n\t\t}\n\n\t\tpublic void println(long l) {\n\t\t\tout.println(l);\n\t\t}\n\n\t\tpublic void println(Object obj) {\n\t\t\tout.println(obj);\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\tout.println(s);\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.function.IntConsumer;\nimport java.io.IOException;\nimport java.util.function.IntPredicate;\nimport java.io.Serializable;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FRandomTournament solver = new FRandomTournament();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FRandomTournament {\n        Debug debug = new Debug(false);\n        BitSet tmp;\n        BitSet[] beats;\n        BitSet[][] L;\n        BitSet[][] R;\n        BitSet[][] G;\n        int[][] LVisited;\n        int[][] RVisited;\n        int[][] GVisited;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            beats = new BitSet[n];\n            for (int i = 0; i < n; i++) {\n                beats[i] = new BitSet(n);\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (in.readChar() == '1') {\n                        beats[i].set(j);\n                    } else {\n                        beats[j].set(i);\n                    }\n                }\n            }\n\n            L = new BitSet[2][n];\n            R = new BitSet[2][n];\n            G = new BitSet[2][n];\n            LVisited = new int[2][n];\n            RVisited = new int[2][n];\n            GVisited = new int[2][n];\n\n            for (int i = 0; i < 2; i++) {\n                for (int j = 0; j < n; j++) {\n                    L[i][j] = new BitSet(n);\n                    R[i][j] = new BitSet(n);\n                    G[i][j] = new BitSet(n);\n                    RVisited[i][j] = GVisited[i][j] = LVisited[i][j] = i == 0 ? j - 1 : j + 1;\n                }\n            }\n            tmp = new BitSet(n);\n\n            for (int i = 0; i < n; i++) {\n                prepareL(0, i, n - 1);\n                prepareR(0, i, n - 1);\n                prepareG(0, i, n - 1);\n                prepareL(1, 0, i);\n                prepareR(1, 0, i);\n                prepareG(1, 0, i);\n            }\n\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (R[0][0].get(i) && L[0][i].get(n - 1)) {\n                    debug.debug(\"i\", i);\n                    ans++;\n                }\n            }\n\n            out.println(ans);\n        }\n\n        public void prepareL(int i, int j, int k) {\n            int step = i == 0 ? 1 : -1;\n            int use = i == 0 ? j : k;\n            IntPredicate breakCondition = i == 0 ? x -> x < k : x -> x > j;\n            IntConsumer consumer = i == 0 ? x -> L[0][j].set(x, L(j, x)) : x -> L[1][k].set(x, L(x, k));\n            while (breakCondition.test(LVisited[i][use])) {\n                LVisited[i][use] += step;\n                consumer.accept(LVisited[i][use]);\n            }\n        }\n\n        public void prepareR(int i, int j, int k) {\n            int step = i == 0 ? 1 : -1;\n            int use = i == 0 ? j : k;\n            IntPredicate breakCondition = i == 0 ? x -> x < k : x -> x > j;\n            IntConsumer consumer = i == 0 ? x -> R[0][j].set(x, R(j, x)) : x -> R[1][k].set(x, R(x, k));\n            while (breakCondition.test(RVisited[i][use])) {\n                RVisited[i][use] += step;\n                consumer.accept(RVisited[i][use]);\n            }\n        }\n\n        public void prepareG(int i, int j, int k) {\n            int step = i == 0 ? 1 : -1;\n            int use = i == 0 ? j : k;\n            IntPredicate breakCondition = i == 0 ? x -> x < k : x -> x > j;\n            IntConsumer consumer = i == 0 ? x -> G[0][j].set(x, G(j, x)) : x -> G[1][k].set(x, G(x, k));\n            while (breakCondition.test(GVisited[i][use])) {\n                GVisited[i][use] += step;\n                consumer.accept(GVisited[i][use]);\n            }\n        }\n\n        public boolean L(int l, int r) {\n            if (l == r) {\n                return true;\n            }\n            prepareL(1, l + 1, r);\n            prepareG(0, l, r);\n            tmp.copy(beats[l]);\n            tmp.and(L[1][r]);\n            tmp.and(G[0][l]);\n            return tmp.size(l, r) > 0;\n        }\n\n        public boolean R(int l, int r) {\n            if (l == r) {\n                return true;\n            }\n            prepareR(0, l, r - 1);\n            prepareG(1, l, r);\n            tmp.copy(beats[r]);\n            tmp.and(R[0][l]);\n            tmp.and(G[1][r]);\n            return tmp.size(l, r) > 0;\n        }\n\n        public boolean G(int l, int r) {\n            if (l == r) {\n                return false;\n            }\n            prepareL(0, l, r - 1);\n            prepareR(1, l + 1, r);\n            tmp.copy(R[1][r]);\n            tmp.leftShift(1);\n            tmp.and(L[0][l]);\n            return tmp.size(l, r - 1) > 0;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n    }\n\n    static final class BitSet implements Serializable, Cloneable {\n        private long[] data;\n        private long tailAvailable;\n        private int capacity;\n        private int m;\n        private static final int SHIFT = 6;\n        private static final int LOW = 63;\n        private static final int BITS_FOR_EACH = 64;\n        private static final long ALL_ONE = ~0L;\n        private static final long ALL_ZERO = 0L;\n        private static final int MAX_OFFSET = 63;\n        private static long[] EMPTY_ARRAY = new long[0];\n\n        public BitSet(int n) {\n            capacity = n;\n            this.m = (capacity + 64 - 1) / 64;\n            data = new long[m];\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n        }\n\n        public BitSet(BitSet bs) {\n            this.data = bs.data.clone();\n            this.tailAvailable = bs.tailAvailable;\n            this.capacity = bs.capacity;\n            this.m = bs.m;\n        }\n\n        private BitSet(BitSet bs, int l, int r) {\n            this.data = EMPTY_ARRAY;\n            copyInterval(bs, l, r);\n        }\n\n        public void copyInterval(BitSet bs, int l, int r) {\n            capacity = r - l + 1;\n            tailAvailable = oneBetween(0, offset(capacity - 1));\n            int reqLength = word(r) - word(l) + 1;\n            if (data.length >= word(r) - word(l) + 1) {\n                System.arraycopy(bs.data, word(l), data, 0, reqLength);\n            } else {\n                data = Arrays.copyOfRange(bs.data, word(l), word(r) + 1);\n            }\n            this.m = reqLength;\n            leftShift(offset(l));\n            this.m = (capacity + 64 - 1) / 64;\n            data[m - 1] &= tailAvailable;\n            for (int i = m; i < reqLength; i++) {\n                data[i] = 0;\n            }\n        }\n\n        public boolean get(int i) {\n            return (data[word(i)] & (1L << offset(i))) != 0;\n        }\n\n        public void set(int i) {\n            data[word(i)] |= (1L << offset(i));\n        }\n\n        public void set(int i, boolean val) {\n            if (val) {\n                set(i);\n            } else {\n                clear(i);\n            }\n        }\n\n        private static int word(int i) {\n            return i >>> SHIFT;\n        }\n\n        private static int offset(int i) {\n            return i & LOW;\n        }\n\n        private long oneBetween(int l, int r) {\n            if (r < l) {\n                return 0;\n            }\n            long lBegin = 1L << offset(l);\n            long rEnd = 1L << offset(r);\n            return (ALL_ONE ^ (lBegin - 1)) & ((rEnd << 1) - 1);\n        }\n\n        public void clear(int i) {\n            data[word(i)] &= ~(1L << offset(i));\n        }\n\n        public int capacity() {\n            return capacity;\n        }\n\n        public int size(int l, int r) {\n            if (r < l) {\n                return 0;\n            }\n            int ans = 0;\n            int lWord = l >>> SHIFT;\n            int rWord = r >>> SHIFT;\n            for (int i = lWord + 1; i < rWord; i++) {\n                ans += Long.bitCount(data[i]);\n            }\n            //lword\n            if (lWord == rWord) {\n                ans += Long.bitCount(data[lWord] & oneBetween(offset(l), offset(r)));\n            } else {\n                ans += Long.bitCount(data[lWord] & oneBetween(offset(l), MAX_OFFSET));\n                ans += Long.bitCount(data[rWord] & oneBetween(0, offset(r)));\n            }\n            return ans;\n        }\n\n        public void copy(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            System.arraycopy(bs.data, 0, data, 0, n);\n            Arrays.fill(data, n, n, 0);\n        }\n\n        public void and(BitSet bs) {\n            int n = Math.min(this.m, bs.m);\n            for (int i = 0; i < n; i++) {\n                data[i] &= bs.data[i];\n            }\n        }\n\n        public int nextSetBit(int start) {\n            int offset = offset(start);\n            int w = word(start);\n            if (offset != 0) {\n                long mask = oneBetween(offset, MAX_OFFSET);\n                if ((data[w] & mask) != 0) {\n                    return Long.numberOfTrailingZeros(data[w] & mask) + w * BITS_FOR_EACH;\n                }\n                w++;\n            }\n\n            while (w < m && data[w] == ALL_ZERO) {\n                w++;\n            }\n            if (w >= m) {\n                return capacity();\n            }\n            return Long.numberOfTrailingZeros(data[w]) + w * BITS_FOR_EACH;\n        }\n\n        public void leftShift(int n) {\n            int wordMove = word(n);\n            int offsetMove = offset(n);\n            int rshift = MAX_OFFSET - (offsetMove - 1);\n\n            if (offsetMove != 0) {\n                //slightly\n                for (int i = 0; i < m; i++) {\n                    if (i > 0) {\n                        data[i - 1] |= data[i] << rshift;\n                    }\n                    data[i] >>>= offsetMove;\n                }\n            }\n            if (wordMove > 0) {\n                for (int i = 0; i < m; i++) {\n                    if (i >= wordMove) {\n                        data[i - wordMove] = data[i];\n                    }\n                    data[i] = 0;\n                }\n            }\n        }\n\n        public BitSet clone() {\n            return new BitSet(this);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder(\"{\");\n            for (int i = nextSetBit(0); i < capacity(); i = nextSetBit(i + 1)) {\n                builder.append(i).append(',');\n            }\n            if (builder.length() > 1) {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append(\"}\");\n            return builder.toString();\n        }\n\n        public int hashCode() {\n            int ans = 1;\n            for (int i = 0; i < m; i++) {\n                ans = ans * 31 + Long.hashCode(data[i]);\n            }\n            return ans;\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof BitSet)) {\n                return false;\n            }\n            BitSet other = (BitSet) obj;\n            if (other.capacity != capacity) {\n                return false;\n            }\n            for (int i = 0; i < m; i++) {\n                if (other.data[i] != data[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, int x) {\n            if (offline) {\n                debug(name, \"\" + x);\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(\"%s=%s\", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Locale;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tFastIO io = new FastIO();\n\t\t/*\n\t\t * 考察\n\t\t * 連続してるなら使えばいいじゃない\n\t\t * 自分の右側と自分の左側に、自分より弱い人が勝ち残れれば2戦で勝てる\n\t\t * よってこれが可能かだけ考えれば良い\n\t\t * dpl[i][j]は区間[i, j]についてiが優勝する\n\t\t * dpr[i][j]は区間[i, j]についてjが優勝する\n\t\t * これで遷移を組んでみる\n\t\t * まず自明にdpl[i][i]=dpr[i][i]=true、これが初期値\n\t\t * で、次に遷移\n\t\t * ・dpl[i][j] = or[k = i + 1, j](A[i][k] & dpr[i + 1][k] & dpl[k][j])\n\t\t * これはあるkについて、iがkに勝てるときにこの対象が生き残ってくれればいいわけで\n\t\t * それは[i + 1, k]でkが優勝し、[k, j]でkが優勝しているなら[i + 1, j]でkが優勝できるということ\n\t\t * 後はこのkにiが勝って終わり！\n\t\t * 同様に次の遷移も言える\n\t\t * ・dpr[i][j] = or[k = i, j - 1](A[j][k] & dpr[i][k] & dpl[k][j - 1])\n\t\t * これはあるkについて、[i, k]でkが優勝し[k, j - 1]でkが優勝しているという場合\n\t\t * この場合は、[i, j-1]でkが優勝してるので、あとはこのkにjが勝って終わり！\n\t\t * 後は答えに関しては、全区間について見て優勝してれば終わり\n\t\t * さて、これはどう計算できるか？\n\t\t * 区間DPなので、j-iの値を少しずつ大きくしていけば良い\n\t\t * 見れば分かるように区間を1個以上縮めた奴から導出してるからね、そりゃそう\n\t\t * これはO(N^3)だがまぁうん\n\t\t */\n\t\tint N = io.nextInt();\n\t\tboolean[][] A = new boolean[N][N];\n\t\tfor (int i = 1;i < N;++ i) {\n\t\t\tchar[] s = io.next().toCharArray();\n\t\t\tfor (int j = 0;j < i;++ j) {\n\t\t\t\tA[i][j] = s[j] == '1';\n\t\t\t\tA[j][i] = !A[i][j];\n\t\t\t}\n\t\t}\n\t\tboolean[][] dpl = new boolean[N][N], dpr = new boolean[N][N];\n\t\tfor (int i = 0;i < N;++ i) dpl[i][i] = dpr[i][i] = true;\n\t\tfor (int i = 1;i < N;++ i) {\n\t\t\tfor (int j = 0;j + i < N;++ j) {\n\t\t\t\tint d = j + i;\n\t\t\t\tdpl[j][d] = dpr[j][d] = false;\n\t\t\t\tfor (int k = j + 1;k <= d;++ k) dpl[j][d] |= A[j][k] && dpr[j + 1][k] && dpl[k][d]; // (j, d]でkが勝ち、jとkでjが勝つ\n\t\t\t\tfor (int k = j;k < d;++ k) dpr[j][d] |= A[d][k] && dpr[j][k] && dpl[k][d - 1]; // [j, d)でkが勝ち、dとkでdが勝つ\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0;i < N;++ i) if (dpr[0][i] && dpl[i][N - 1]) ++ ans; // [0, N)でiが勝ったなら勝ち\n\t\tio.print(ans);\n\t\tio.flush();\n\t}\n\n\tpublic class FastIO {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tpublic final PrintWriter out = new PrintWriter(System.out, false);\n\t\tpublic final PrintWriter err = new PrintWriter(System.err, false);\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tread = 0;\n\t\t\t\t\tlength = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[read++] : -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\tif (!hasNextByte())  throw new NoSuchElementException();\n\t\t\treturn (char)readByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b;\n\t\t\twhile (isPrintableChar(b = readByte())) sb.appendCodePoint(b);\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (!isNumber(b)) throw new NumberFormatException();\n\t\t\twhile (true) {\n\t\t\t\tif (isNumber(b)) {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;\n\t\t\t\telse throw new NumberFormatException();\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(boolean b) {\n\t\t\tout.print(b);\n\t\t}\n\n\t\tpublic void print(char c) {\n\t\t\tout.print(c);\n\t\t}\n\n\t\tpublic void print(char[] s) {\n\t\t\tout.print(s);\n\t\t}\n\n\t\tpublic void print(double d) {\n\t\t\tout.print(d);\n\t\t}\n\n\t\tpublic void print(float f) {\n\t\t\tout.print(f);\n\t\t}\n\n\t\tpublic void print(int i) {\n\t\t\tout.print(i);\n\t\t}\n\n\t\tpublic void print(long l) {\n\t\t\tout.print(l);\n\t\t}\n\n\t\tpublic void print(Object obj) {\n\t\t\tout.print(obj);\n\t\t}\n\n\t\tpublic void print(String s) {\n\t\t\tout.print(s);\n\t\t}\n\n\t\tpublic void printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t}\n\n\t\tpublic void printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tout.println();\n\t\t}\n\n\t\tpublic void println(boolean b) {\n\t\t\tout.println(b);\n\t\t}\n\n\t\tpublic void println(char c) {\n\t\t\tout.println(c);\n\t\t}\n\n\t\tpublic void println(char[] s) {\n\t\t\tout.println(s);\n\t\t}\n\n\t\tpublic void println(double d) {\n\t\t\tout.println(d);\n\t\t}\n\n\t\tpublic void println(float f) {\n\t\t\tout.println(f);\n\t\t}\n\n\t\tpublic void println(int i) {\n\t\t\tout.println(i);\n\t\t}\n\n\t\tpublic void println(long l) {\n\t\t\tout.println(l);\n\t\t}\n\n\t\tpublic void println(Object obj) {\n\t\t\tout.println(obj);\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\tout.println(s);\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nnamespace agc030_a\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var text = Console.ReadLine();\n            var n = int.Parse(text);\n\n            if (n == 1){\n                Console.WriteLine(\"1\");\n                return;\n            }\n\n            int need = 1;\n            if (n <= 2){\n                need = 1;\n            } else if (n < 4){\n                need = 1;\n            } else if (n < 8){\n                need = 2;\n            } else if (n < 16){\n                need = 3;\n            } else if (n < 32){\n                need = 4;\n            } else if (n < 64){\n                need = 5;\n            } else if (n < 128){\n                need = 6;\n            } else if (n < 256){\n                need = 7;\n            } else if (n < 512){\n                need = 8;\n            } else if (n < 1024){\n                need = 9;\n            } else if (n < 2048){\n                need = 10;\n            }\n            \n            var list = new List<int>();\n            for(int i = 0; i < n; i++){\n                list.Add(0);\n            }\n\n            for(int i = 0; i < n - 1; i++)\n            {\n                text = Console.ReadLine();\n                \n                for(int j = 0; j < text.Length; j++){\n                    var item = text.Substring(j, 1);\n                    if (item == \"0\"){\n                        list[j] = list[j] + 1;\n                    }\n\n                    if (i == (n - 2)){\n                        if (item == \"1\"){\n                            list[n - 1] = list[n - 1] + 1;\n                        }\n                    }\n                }\n            }\n\n            for(int i = 0; i < n; i++){\n                if (list[i] == (n - 1)){\n                    Console.WriteLine(\"1\");\n                    return;\n                }\n            }\n            \n            var count = 0;\n            for(int i = 0; i < n; i++){\n                if (list[i] >= need){\n                    count++;\n                }\n            }\n\n            Console.WriteLine(count);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\n\npartial class Solver {\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                dpL[j][i] = (winBit[i].Slice(i + 1, j + 1) & dpL[j].Slice(i + 1, j + 1) & dpR[i + 1].Slice(i + 1, j + 1)).Any();\n                dpR[i][j] = (winBit[j].Slice(i, j) & dpL[j - 1].Slice(i, j) & dpR[i].Slice(i, j)).Any();\n\n                /*\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[j, k] && dpR[i + 1, k]) { dpL[j, i] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[j - 1, k] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }*/\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(Solve(n, win));\n    }\n}\n\n// TODO: はみ出た部分を 0 clear する\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin / 64;\n        var move = begin % 64;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        if (begin == -1) {\n            Array.Copy(_array, bitset._array, arrayLength);\n            lastIndex = arrayLength - 1;\n        } else {\n            for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n                bitset._array[i] = unchecked(\n                    (_array[i + jump] >> move) |\n                    ((move > 0 && i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n                );\n                lastIndex = i;\n            }\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (move > 0 && i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (move > 0 && i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\n\npartial class Solver {\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                var length = winBit[i].LongArray.Count;\n                for (int k = 0; k < length; k++) {\n                    if ((winBit[i].LongArray[k] & dpL[j].LongArray[k] & dpR[i + 1].LongArray[k]) != 0) {\n                        dpL[j][i] = true;\n                        break;\n                    }\n                }\n                for (int k = 0; k < length; k++) {\n                    if ((winBit[j].LongArray[k] & dpL[j-1].LongArray[k] & dpR[i].LongArray[k]) != 0) {\n                        dpR[i][j] = true;\n                        break;\n                    }\n                }\n\n                //dpL[j][i] = (winBit[i] & dpL[j] & dpR[i + 1]).Any();\n                //dpR[i][j] = (winBit[j] & dpL[j - 1] & dpR[i]).Any();\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(Solve(n, win));\n    }\n}\n\n\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public IReadOnlyList<ulong> LongArray { get { return _array; } }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin / 64;\n        var move = begin % 64;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n            bitset._array[i] = unchecked(\n                (_array[i + jump] >> move) |\n                ((move > 0 && i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n            );\n            lastIndex = i;\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (move > 0 && i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (move > 0 && i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n\n        public void Solve() {\n            var n = ri;\n            var a = Enumerate(n + 2, x => new int[n + 2]);\n            for (int i = 0; i < n; i++) {\n                var s = i == 0 ? \"\" : rs;\n                for (int j = 0; j < i; j++) {\n                    a[i + 1][j + 1] = s[j] - '0';\n                    a[j + 1][i + 1] = 1 - a[i + 1][j + 1];\n                }\n            }\n            /*\n            n = 2000;\n            a = Enumerate(n + 2, x => new int[n + 2]);\n            for (int i = 1; i <= n; i++)\n                for (int j = i + 1; j <= n; j++) {\n                    var u = rnd.Next() % 2;\n                    a[i][j] = u; a[j][i] = 1 - u;\n                }\n            */\n            for (int i = 1; i <= n; i++) {\n                a[i][0] = a[i][n + 1] = 1;\n            }\n            var lose = Enumerate(n + 2, x => new bitset());\n            var adj = Enumerate(n + 2, x => new bitset());\n\n            for (int i = 1; i <= n + 1; i++) {\n                adj[i][i - 1] = true;\n                lose[i][i - 1] = a[i][i - 1] == 0;\n                for (int j = i - 1; j >= 1; j--) {\n                    if (!adj[i][j]) continue;\n                    if (a[i][j] == 0) lose[i][j] = true;\n                    for (int k = 0; k < 32; k++) {\n                        if (a[i][j] == 1)\n                            adj[i].a[k] |= adj[j].a[k];\n                        else adj[i].a[k] |= lose[j].a[k];\n                    }\n                }\n            }\n            var ans = 0;\n            for (int i = 1; i <= n; i++)\n                if (adj[i][0] && adj[n + 1][i]) ans++;\n            Console.WriteLine(ans);\n\n        }\n        class bitset {\n            public ulong[] a = new ulong[32];\n            const int B = 64;\n            public bool this[int index] {\n                get { return (a[index / B] >> index & 1) == 1; }\n                set {\n                    if (value)\n                        a[index / B] |= 1ul << index;\n                    else a[index / B] &= ~(1ul << index);\n                }\n            }\n        }\n\n\n\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\n\npartial class Solver {\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                var start = i / 64;\n                var end = j / 64;\n                for (int k = start; k <= end; k++) {\n                    if ((winBit[i].LongArray[k] & dpL[j].LongArray[k] & dpR[i + 1].LongArray[k]) != 0) {\n                        dpL[j][i] = true;\n                        break;\n                    }\n                }\n                for (int k = start; k <= end; k++) {\n                    if ((winBit[j].LongArray[k] & dpL[j - 1].LongArray[k] & dpR[i].LongArray[k]) != 0) {\n                        dpR[i][j] = true;\n                        break;\n                    }\n                }\n\n                //dpL[j][i] = (winBit[i] & dpL[j] & dpR[i + 1]).Any();\n                //dpR[i][j] = (winBit[j] & dpL[j - 1] & dpR[i]).Any();\n            }\n        }\n        int ans = (dpL[n - 1] & dpR[0]).CountBit();\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(Solve(n, win));\n    }\n}\n\n\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public ulong[] LongArray { get { return _array; } }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin / 64;\n        var move = begin % 64;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n            bitset._array[i] = unchecked(\n                (_array[i + jump] >> move) |\n                ((move > 0 && i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n            );\n            lastIndex = i;\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (move > 0 && i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (move > 0 && i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nusing static Func;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tint F => int.Parse(Str);\n\tlong FL => long.Parse(Str);\n\tint[] G => Strs.Select(int.Parse).ToArray();\n\tuint[] GU => Strs.Select(uint.Parse).ToArray();\n\tdecimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tlong[] GL => Strs.Select(long.Parse).ToArray();\n\tstring Str => ReadLine();\n\tstring[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic ulong One(int k) => 1ul << k;\n\tstatic ulong All(int k) => One(k) - 1;\n\tstatic bool Has(ulong s, int k) => (s & One(k)) != 0;\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tvoid Solve()\n\t{\n\t\tvar N = F;\n\t\t// m[i,j] = i > j\n\t\tvar m = new bool[N, N];\n\t\tfor (var i = 1; i < N; i++)\n\t\t{\n\t\t\tvar S = Str;\n\t\t\tfor (var j = 0; j < i; j++) m[j, i] = !(m[i, j] = S[j] == '1');\n\t\t}\n\t\tvar ans = 0;\n\t\tvar dpL = new bool[N];  // dpL[i] = i > (i+1,...,N-1)\n\t\tvar dpR = new bool[N];  // dpR[i] = (0,...,i-1) < i\n\t\tvar dp = new bool[N, N];    // dp[i,j] = i > (i+1,...,j-1) < j\n\t\tdpL[N - 1] = true;\n\t\tdpR[0] = true;\n\t\tfor (var i = 0; i < N - 1; i++) dp[i, i + 1] = true;\n\t\tfor (var l = 2; l < N; l++)\n\t\t\tfor (var i = 0; i + l < N; i++)\n\t\t\t\tfor (var k = i + 1; k < i + l; k++)\n\t\t\t\t\tif (dp[i, i + l] |= dp[i, k] & (m[i, k] | m[i + l, k]) & dp[k, i + l]) break;\n\t\tfor (var i = N - 2; i >= 0; i--) for (var j = i + 1; j < N; j++) dpL[i] |= m[i, j] & dpL[j] & dp[i, j];\n\t\tfor (var i = 1; i < N; i++) for (var j = 0; j < i; j++) dpR[i] |= m[i, j] & dpR[j] & dp[j, i];\n\t\tfor (var i = 0; i < N; i++) if (dpL[i] & dpR[i]) ans++;\n\t\tWriteLine(ans);\n\t}\n}\nstatic class Func\n{\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tstatic T[] Recurse<T>(int n, T a0, Func<int, T, T> f) { var a = new T[n]; a[0] = a0; for (var i = 1; i < n; i++) a[i] = f(i, a[i - 1]); return a; }\n\tstatic T[] Accumulate<T>(IList<T> a, T zero, Func<T, T, T> f) { var s = new T[a.Count + 1]; s[0] = zero; for (var i = 0; i < a.Count; i++) s[i + 1] = f(s[i], a[i]); return s; }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\n\npartial class Solver {\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                var start = i / 64;\n                var end = j / 64;\n                for (int k = start; k <= end; k++) {\n                    if ((winBit[i].LongArray[k] & dpL[j].LongArray[k] & dpR[i + 1].LongArray[k]) != 0) {\n                        dpL[j][i] = true;\n                        break;\n                    }\n                }\n                for (int k = start; k <= end; k++) {\n                    if ((winBit[j].LongArray[k] & dpL[j - 1].LongArray[k] & dpR[i].LongArray[k]) != 0) {\n                        dpR[i][j] = true;\n                        break;\n                    }\n                }\n\n                //dpL[j][i] = (winBit[i] & dpL[j] & dpR[i + 1]).Any();\n                //dpR[i][j] = (winBit[j] & dpL[j - 1] & dpR[i]).Any();\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(Solve(n, win));\n    }\n}\n\n\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public ulong[] LongArray { get { return _array; } }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin / 64;\n        var move = begin % 64;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n            bitset._array[i] = unchecked(\n                (_array[i + jump] >> move) |\n                ((move > 0 && i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n            );\n            lastIndex = i;\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (move > 0 && i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (move > 0 && i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\nusing System.Numerics;\n\npartial class Solver {\n\n    public int SolveNaive(int n, bool[,] win) {\n        var dpL = new bool[n + 1, n + 1];\n        var dpR = new bool[n + 1, n + 1];\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[i][j] = exists k in [i+1,j] where dpL[k][j] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[k][j-1] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i, i] = true;\n            dpR[i, i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[k, j] && dpR[i + 1, k]) { dpL[i, j] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[k, j - 1] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[i, n - 1] && dpR[0, i]) ans++;\n        }\n        return ans;\n    }\n\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                dpL[j][i] = (winBit[i].Slice(i + 1, j + 1) & dpL[j].Slice(i + 1, j + 1) & dpR[i + 1].Slice(i + 1, j + 1)).Any();\n                dpR[i][j] = (winBit[j].Slice(i, j) & dpL[j - 1].Slice(i, j) & dpR[i].Slice(i, j)).Any();\n\n                /*\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[j, k] && dpR[i + 1, k]) { dpL[j, i] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[j - 1, k] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }*/\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n#if false\n        n = 211; win = new bool[n, n];\n        var rand = new Random(win.GetHashCode());\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                win[i, j] = rand.Next(100) <= 50;\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(Solve(n, win));\n#endif\n        cout.WriteLine(Solve(n, win));\n    }\n}\n\n// TODO: はみ出た部分を 0 clear する\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public bool Any() {\n        var aa = Array.FindIndex(_array, a => a != 0UL) >= 0;\n        var bb = ToString().Contains('1');\n        if (aa != bb) throw new Exception();\n        return aa;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin / 64;\n        var move = begin % 64;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        if (begin == -1) {\n            Array.Copy(_array, bitset._array, arrayLength);\n            lastIndex = arrayLength - 1;\n        } else {\n            for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n                bitset._array[i] = unchecked(\n                    (_array[i + jump] >> move) |\n                    ((move > 0 && i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n                );\n                lastIndex = i;\n            }\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        for (int i = 0; i < bitset.BitLength; i++) {\n            if (bitset[i] != this[begin + i]) { Console.WriteLine(\"ERROR \" + begin); break; }\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static void Main(string[] args)\n    {\n        int n = sc.Int;\n        var a = new bool[n][];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = new bool[n];\n        }\n        for (int i = 1; i < n; i++)\n        {\n            var b = sc.Str;\n            for (int j = 0; j < i; j++)\n            {\n                a[i][j] = b[j] == '1';\n                a[j][i] = b[j] == '0';\n            }\n        }\n        var islwin = new bool[n];\n        var lis = new List<int>();\n        lis.Add(0);\n        islwin[0] = true;\n        for (int i = 1; i < n; i++)\n        {\n            int rlose = -1;\n            for (int j = i - 1; j >= 0 ; j--)\n            {\n                if (!a[i][j]) {\n                    rlose = j;\n                    break;\n                }\n            }\n            var nex = new List<int>();\n            var ok = false;\n            foreach (var item in lis)\n            {\n                if (a[i][item]){\n                    ok = true;\n                }\n                if (!a[i][item] || rlose >= item) {\n                    nex.Add(item);\n                }\n            }\n            if (ok) {\n                islwin[i] = true;\n                nex.Add(i);\n            }\n            lis = nex;\n        }\n        var isrwin = new bool[n];\n        lis = new List<int>();\n        lis.Add(n - 1);\n        isrwin[n - 1] = true;\n        for (int i = n - 2; i >= 0; i--)\n        {\n            int llose = n;\n            for (int j = i + 1; j < n; j++)\n            {\n                if (!a[i][j]) {\n                    llose = j;\n                    break;\n                }\n            }\n            var nex = new List<int>();\n            var ok = false;\n            foreach (var item in lis)\n            {\n                if (a[i][item]){\n                    ok = true;\n                }\n                if (!a[i][item] || llose <= item) {\n                    nex.Add(item);\n                }\n            }\n            if (ok) {\n                isrwin[i] = true;\n                nex.Add(i);\n            }\n            lis = nex;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (islwin[i] && isrwin[i]) {\n                ++ans;\n            }\n        }\n        Prt(ans);\n        sw.Flush();\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static pair<P, char>[] adjacents_with_str(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k])).ToArray();\n    public static pair<P, char>[] adjacents_with_str(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k])).Where(p => inside(p.v1.v1, p.v1.v2, h, w)).ToArray();\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\nusing System.Numerics;\n\npartial class Solver {\n\n    public int SolveNaive(int n, bool[,] win) {\n        var dpL = new bool[n + 1, n + 1];\n        var dpR = new bool[n + 1, n + 1];\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[i][j] = exists k in [i+1,j] where dpL[k][j] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[k][j-1] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i, i] = true;\n            dpR[i, i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[k, j] && dpR[i + 1, k]) { dpL[i, j] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[k, j - 1] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[i, n - 1] && dpR[0, i]) ans++;\n        }\n        return ans;\n    }\n\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                dpL[j][i] = (winBit[i].Slice(i + 1, j + 1) & dpL[j].Slice(i + 1, j + 1) & dpR[i + 1].Slice(i + 1, j + 1)).Any();\n                dpR[i][j] = (winBit[j].Slice(i, j) & dpL[j - 1].Slice(i, j) & dpR[i].Slice(i, j)).Any();\n\n                /*\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[j, k] && dpR[i + 1, k]) { dpL[j, i] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[j - 1, k] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }*/\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n#if false\n        n = 232; win = new bool[n, n];\n        var rand = new Random(win.GetHashCode());\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                win[i, j] = rand.Next(2) == 1;\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(SolveNaive(n, win));\n#endif\n        cout.WriteLine(Solve(n, win));\n    }\n}\n\n// TODO: はみ出た部分を 0 clear する\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin >> 6;\n        var move = begin & 63;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        if (begin == 0) {\n            Array.Copy(_array, bitset._array, arrayLength);\n            lastIndex = arrayLength - 1;\n        } else {\n            for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n                bitset._array[i] = unchecked(\n                    (_array[i + jump] >> move) |\n                    ((i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n                );\n                lastIndex = i;\n            }\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\n\npartial class Solver {\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                dpL[j][i] = (winBit[i] & dpL[j] & dpR[i + 1]).Any();\n                dpR[i][j] = (winBit[j] & dpL[j - 1] & dpR[i]).Any();\n\n                /*\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[j, k] && dpR[i + 1, k]) { dpL[j, i] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[j - 1, k] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }*/\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(Solve(n, win));\n    }\n}\n\n// TODO: はみ出た部分を 0 clear する\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin / 64;\n        var move = begin % 64;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        if (begin == -1) {\n            Array.Copy(_array, bitset._array, arrayLength);\n            lastIndex = arrayLength - 1;\n        } else {\n            for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n                bitset._array[i] = unchecked(\n                    (_array[i + jump] >> move) |\n                    ((move > 0 && i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n                );\n                lastIndex = i;\n            }\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (move > 0 && i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (move > 0 && i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\nusing System.Numerics;\n\npartial class Solver {\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n\n#if NAIVE\n        var dpL = new bool[n + 1, n + 1];\n        var dpR = new bool[n + 1, n + 1];\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[i][j] = exists k in [i+1,j] where dpL[k][j] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[k][j-1] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i, i] = true;\n            dpR[i, i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[k, j] && dpR[i + 1, k]) { dpL[i, j] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[k, j - 1] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[i, n - 1] && dpR[0, i]) ans++;\n        }\n        cout.WriteLine(ans);\n#endif\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                dpL[j][i] = (winBit[i].Slice(i + 1, j + 1) & dpL[j].Slice(i + 1, j + 1) & dpR[i + 1].Slice(i + 1, j + 1)).Any();\n                dpR[i][j] = (winBit[j].Slice(i, j) & dpL[j - 1].Slice(i, j) & dpR[i].Slice(i, j)).Any();\n\n                /*\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[j, k] && dpR[i + 1, k]) { dpL[j, i] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[j - 1, k] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }*/\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        cout.WriteLine(ans);\n    }\n}\n\npublic struct BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin >> 6;\n        var move = begin & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (_array[i + jump] >> move) |\n                (i + jump + 1 < arrayLength ? (_array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nnamespace agc030_a\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var text = Console.ReadLine();\n            var n = int.Parse(text);\n\n            if (n == 1){\n                Console.WriteLine(\"1\");\n                return;\n            }\n\n            int need = 1;\n            if (n <= 2){\n                need = 1;\n            } else if (n < 4){\n                need = 1;\n            } else if (n < 8){\n                need = 2;\n            } else if (n < 16){\n                need = 3;\n            } else if (n < 32){\n                need = 4;\n            } else if (n < 64){\n                need = 5;\n            } else if (n < 128){\n                need = 6;\n            } else if (n < 256){\n                need = 7;\n            } else if (n < 512){\n                need = 8;\n            } else if (n < 1024){\n                need = 9;\n            } else if (n < 2048){\n                need = 10;\n            }\n            \n            var list = new List<int>();\n            for(int i = 0; i < n; i++){\n                list.Add(0);\n            }\n\n            for(int i = 0; i < n - 1; i++)\n            {\n                text = Console.ReadLine();\n                \n                for(int j = 0; j < text.Length; j++){\n                    var item = text.Substring(j, 1);\n                    if (item == \"0\"){\n                        list[j] = list[j] + 1;\n                    }\n\n                    if (i == (n - 2)){\n                        if (item == \"1\"){\n                            list[n - 1] = list[n - 1] + 1;\n                        }\n                    }\n                }\n            }\n            \n            for(int i = 0; i < n; i++){\n                if (list[i] == (n - 1)){\n                    Console.WriteLine(\"1\");\n                    return;\n                }\n            }\n            \n            var count = 0;\n            for(int i = 0; i < n; i++){\n                if (list[i] >= need){\n                    count++;\n                }\n            }\n\n            var mod = n % 2;\n\n            count = count - mod;\n\n            Console.WriteLine(count);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\n\npartial class Solver {\n    public bool AndAny(IEnumerable<ulong> a1, IEnumerable<ulong> a2, IEnumerable<ulong> a3) {\n        return a1.Zip(a2, (x, y) => x & y).Zip(a3, (x, y) => x & y).Any(a => a != 0);\n    }\n\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                var length = winBit[i].LongArray.Length;\n                if (AndAny(winBit[i].LongArray, dpL[j].LongArray, dpR[i + 1].LongArray)) {\n                    dpL[j][i] = true;\n                }\n                if (AndAny(winBit[j].LongArray, dpL[j - 1].LongArray, dpR[i].LongArray)) {\n                    dpR[i][j] = true;\n                }\n\n                //dpL[j][i] = (winBit[i] & dpL[j] & dpR[i + 1]).Any();\n                //dpR[i][j] = (winBit[j] & dpL[j - 1] & dpR[i]).Any();\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(Solve(n, win));\n    }\n}\n\n\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public ulong[] LongArray { get { return _array; } }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin / 64;\n        var move = begin % 64;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n            bitset._array[i] = unchecked(\n                (_array[i + jump] >> move) |\n                ((move > 0 && i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n            );\n            lastIndex = i;\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (move > 0 && i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (move > 0 && i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Console;\nusing static System.Math;\nusing static Func;\nclass Z { static void Main() => new K(); }\nclass K\n{\n\tint F => int.Parse(Str);\n\tlong FL => long.Parse(Str);\n\tint[] G => Strs.Select(int.Parse).ToArray();\n\tuint[] GU => Strs.Select(uint.Parse).ToArray();\n\tdecimal[] GD => Strs.Select(decimal.Parse).ToArray();\n\tlong[] GL => Strs.Select(long.Parse).ToArray();\n\tstring Str => ReadLine();\n\tstring[] Strs => Str.Split(new char[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n\tstatic ulong One(int k) => 1ul << k;\n\tstatic ulong All(int k) => One(k) - 1;\n\tstatic bool Has(ulong s, int k) => (s & One(k)) != 0;\n\tconst int MOD = 1000000007;\n\tpublic K()\n\t{\n\t\tSetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n\t\tSolve();\n\t\tOut.Flush();\n\t}\n\tvoid Solve()\n\t{\n\t\tvar N = F;\n\t\t// m[i,j] = i > j\n\t\tvar m = new bool[N, N];\n\t\tfor (var i = 1; i < N; i++)\n\t\t{\n\t\t\tvar S = Str;\n\t\t\tfor (var j = 0; j < i; j++) m[j, i] = !(m[i, j] = S[j] == '1');\n\t\t}\n\t\tvar ans = 0;\n\t\tvar dpL = new bool[N];  // dpL[i] = i > (i+1,...,N-1)\n\t\tvar dpR = new bool[N];  // dpR[i] = (0,...,i-1) < i\n\t\tvar dp = new bool[N, N];    // dp[i,j] = i > (i+1,...,j-1) < j\n\t\tdpL[N - 1] = true;\n\t\tdpR[0] = true;\n\t\tfor (var i = 0; i < N - 1; i++) dp[i, i + 1] = true;\n\t\tfor (var l = 2; l < N; l++)\n\t\t\tfor (var i = 0; i + l < N; i++)\n\t\t\t\tfor (var k = i + 1; k < i + l; k++)\n\t\t\t\t\tdp[i, i + l] |= dp[i, k] && (m[i, k] || m[i + l, k]) && dp[k, i + l];\n\t\tfor (var i = N - 2; i >= 0; i--) for (var j = i + 1; j < N; j++) dpL[i] |= m[i, j] && dpL[j] && dp[i, j];\n\t\tfor (var i = 1; i < N; i++) for (var j = 0; j < i; j++) dpR[i] |= m[i, j] && dpR[j] && dp[j, i];\n\t\tfor (var i = 0; i < N; i++) if (dpL[i] && dpR[i]) ans++;\n\t\tWriteLine(ans);\n\t}\n}\nstatic class Func\n{\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tstatic T[] ConstantArray<T>(int n, T val) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = val; return a; }\n\tstatic T[] MakeArray<T>(int n, Func<int, T> f) { var a = new T[n]; for (var i = 0; i < n; i++) a[i] = f(i); return a; }\n\tstatic T[] Recurse<T>(int n, T a0, Func<int, T, T> f) { var a = new T[n]; a[0] = a0; for (var i = 1; i < n; i++) a[i] = f(i, a[i - 1]); return a; }\n\tstatic T[] Accumulate<T>(IList<T> a, T zero, Func<T, T, T> f) { var s = new T[a.Count + 1]; s[0] = zero; for (var i = 0; i < a.Count; i++) s[i + 1] = f(s[i], a[i]); return s; }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\n\npartial class Solver {\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n        var dpL = new bool[n + 1, n + 1];\n        var dpR = new bool[n + 1, n + 1];\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[i][j] = exists k in [i+1,j] where dpL[k][j] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[k][j-1] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i, i] = true;\n            dpR[i, i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[k, j] && dpR[i + 1, k]) { dpL[i, j] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[k, j - 1] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[i, n - 1] && dpR[0, i]) ans++;\n        }\n        cout.WriteLine(ans);\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\n\npartial class Solver {\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                var length = winBit[i].LongArray.Length;\n                for (int k = 0; k < length; k++) {\n                    if ((winBit[i].LongArray[k] & dpL[j].LongArray[k] & dpR[i + 1].LongArray[k]) != 0) {\n                        dpL[j][i] = true;\n                        break;\n                    }\n                }\n                for (int k = 0; k < length; k++) {\n                    if ((winBit[j].LongArray[k] & dpL[j - 1].LongArray[k] & dpR[i].LongArray[k]) != 0) {\n                        dpR[i][j] = true;\n                        break;\n                    }\n                }\n\n                //dpL[j][i] = (winBit[i] & dpL[j] & dpR[i + 1]).Any();\n                //dpR[i][j] = (winBit[j] & dpL[j - 1] & dpR[i]).Any();\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(Solve(n, win));\n    }\n}\n\n\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public ulong[] LongArray { get { return _array; } }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin / 64;\n        var move = begin % 64;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n            bitset._array[i] = unchecked(\n                (_array[i + jump] >> move) |\n                ((move > 0 && i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n            );\n            lastIndex = i;\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (move > 0 && i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (move > 0 && i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\nusing System.Numerics;\n\npartial class Solver {\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n\n#if NAIVE\n        var dpL = new bool[n + 1, n + 1];\n        var dpR = new bool[n + 1, n + 1];\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[i][j] = exists k in [i+1,j] where dpL[k][j] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[k][j-1] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i, i] = true;\n            dpR[i, i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[k, j] && dpR[i + 1, k]) { dpL[i, j] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[k, j - 1] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[i, n - 1] && dpR[0, i]) ans++;\n        }\n        cout.WriteLine(ans);\n#else\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                dpL[j][i] = (winBit[i].Slice(i + 1, j + 1) & dpL[j].Slice(i + 1, j + 1) & dpR[i + 1].Slice(i + 1, j + 1)).Any();\n                dpR[i][j] = (winBit[j].Slice(i, j) & dpL[j - 1].Slice(i, j) & dpR[i].Slice(i, j)).Any();\n\n                /*\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[j, k] && dpR[i + 1, k]) { dpL[j, i] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[j - 1, k] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }*/\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        cout.WriteLine(ans);\n#endif\n    }\n}\n\n// TODO: はみ出た部分を 0 clear する\npublic struct BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin >> 6;\n        var move = begin & 63;\n        var arrayLength = bitset._array.Length;\n        if (begin == 0) {\n            Array.Copy(_array, bitset._array, arrayLength);\n        } else {\n            for (int i = 0; i + jump < arrayLength; i++) {\n                bitset._array[i] = unchecked(\n                    (_array[i + jump] >> move) |\n                    (i + jump + 1 < arrayLength ? (_array[i + jump + 1] << (64 - move)) : 0)\n                );\n            }\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\nusing System.Numerics;\n\npartial class Solver {\n\n    public int SolveNaive(int n, bool[,] win) {\n        var dpL = new bool[n + 1, n + 1];\n        var dpR = new bool[n + 1, n + 1];\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[i][j] = exists k in [i+1,j] where dpL[k][j] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[k][j-1] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i, i] = true;\n            dpR[i, i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[k, j] && dpR[i + 1, k]) { dpL[i, j] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[k, j - 1] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[i, n - 1] && dpR[0, i]) ans++;\n        }\n        return ans;\n    }\n\n    public int Solve(int n, bool[,] win) {\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                dpL[j][i] = (winBit[i].Slice(i + 1, j + 1) & dpL[j].Slice(i + 1, j + 1) & dpR[i + 1].Slice(i + 1, j + 1)).Any();\n                dpR[i][j] = (winBit[j].Slice(i, j) & dpL[j - 1].Slice(i, j) & dpR[i].Slice(i, j)).Any();\n\n                /*\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[j, k] && dpR[i + 1, k]) { dpL[j, i] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[j - 1, k] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }*/\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        return ans;\n    }\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n#if LOCAL\n        n = 1222; win = new bool[n, n];\n        var rand = new Random(win.GetHashCode());\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                win[i, j] = rand.Next(20) == 1;\n                win[j, i] = !win[i, j];\n            }\n        }\n        cout.WriteLine(SolveNaive(n, win));\n#endif\n        cout.WriteLine(SolveNaive(n, win));\n    }\n}\n\n// TODO: はみ出た部分を 0 clear する\npublic class BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin >> 6;\n        var move = begin & 63;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        if (begin == 0) {\n            Array.Copy(_array, bitset._array, arrayLength);\n            lastIndex = arrayLength - 1;\n        } else {\n            for (int i = 0; i + jump < _array.Length && i < bitset._array.Length; i++) {\n                bitset._array[i] = unchecked(\n                    (_array[i + jump] >> move) |\n                    ((i + jump + 1 < _array.Length) ? (_array[i + jump + 1] << (64 - move)) : 0)\n                );\n                lastIndex = i;\n            }\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\nusing System.Numerics;\n\npartial class Solver {\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n\n#if NAIVE\n        var dpL = new bool[n + 1, n + 1];\n        var dpR = new bool[n + 1, n + 1];\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[i][j] = exists k in [i+1,j] where dpL[k][j] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[k][j-1] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i, i] = true;\n            dpR[i, i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[k, j] && dpR[i + 1, k]) { dpL[i, j] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[k, j - 1] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[i, n - 1] && dpR[0, i]) ans++;\n        }\n        cout.WriteLine(ans);\n#else\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                dpL[j][i] = (winBit[i].Slice(i + 1, j + 1) & dpL[j].Slice(i + 1, j + 1) & dpR[i + 1].Slice(i + 1, j + 1)).Any();\n                dpR[i][j] = (winBit[j].Slice(i, j) & dpL[j - 1].Slice(i, j) & dpR[i].Slice(i, j)).Any();\n\n                /*\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[j, k] && dpR[i + 1, k]) { dpL[j, i] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[j - 1, k] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }*/\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        cout.WriteLine(ans);\n#endif\n    }\n}\n\n// TODO: はみ出た部分を 0 clear する\npublic struct BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 1];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin >> 6;\n        var move = begin & 63;\n        var arrayLength = bitset._array.Length;\n        int lastIndex = 0;\n        if (begin == 0) {\n            Array.Copy(_array, bitset._array, arrayLength);\n            lastIndex = arrayLength - 1;\n        } else {\n            for (int i = 0; i + jump < _array.Length; i++) {\n                bitset._array[i] = unchecked(\n                    (_array[i + jump] >> move) |\n                    (i + jump + 1 < _array.Length ? (_array[i + jump + 1] << (64 - move)) : 0)\n                );\n                lastIndex = i;\n            }\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[lastIndex] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        if (shift == 0) return b;\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        var lastBit = bitset.BitLength & 63;\n        if (lastBit > 0) {\n            bitset._array[bitset._array.Length - 1] &= (1UL << lastBit) - 1;\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\nusing System.Numerics;\n\npartial class Solver {\n    public void Run() {\n        var n = ni();\n        var win = new bool[n, n];\n        for (int i = 1; i < n; i++) {\n            var a = ns();\n            for (int j = 0; j < i; j++) {\n                win[i, j] = (a[j] == '1');\n                win[j, i] = !win[i, j];\n            }\n        }\n\n#if NAIVE\n        var dpL = new bool[n + 1, n + 1];\n        var dpR = new bool[n + 1, n + 1];\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[i][j] = exists k in [i+1,j] where dpL[k][j] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[k][j-1] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i, i] = true;\n            dpR[i, i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[k, j] && dpR[i + 1, k]) { dpL[i, j] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[k, j - 1] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[i, n - 1] && dpR[0, i]) ans++;\n        }\n        cout.WriteLine(ans);\n#else\n        var dpL = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var dpR = E.Range(0, n + 1).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n        var winBit = E.Range(0, n).Select(_ => new BitSet(n + 1)).ToArray(); //new bool[n + 1, n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                winBit[i][j] = win[i, j];\n            }\n        }\n\n        // dpL[i][j] = [i..j] で i が勝ち残る可能性がある\n        // dpR[i][j] = [i..j] で j が勝ち残る可能性がある\n        // dpL[j][i] = exists k in [i+1,j] where dpL[j][k] && dpR[i+1][k] && win[i][k] == 1\n        // dpR[i][j] = exists k in [i,j-1] where dpL[j-1][k] && dpR[i][k] && win[j][k] == 1\n        for (int i = 0; i < n; i++) {\n            dpL[i][i] = true;\n            dpR[i][i] = true;\n        }\n        for (int d = 1; d <= n - 1; d++) {\n            for (int i = 0; i + d < n; i++) {\n                var j = i + d;\n\n                dpL[j][i] = (winBit[i].Slice(i + 1, j + 1) & dpL[j].Slice(i + 1, j + 1) & dpR[i + 1].Slice(i + 1, j + 1)).Any();\n                dpR[i][j] = (winBit[j].Slice(i, j) & dpL[j - 1].Slice(i, j) & dpR[i].Slice(i, j)).Any();\n\n                /*\n                for (int k = i + 1; k <= j; k++) {\n                    if (win[i, k] && dpL[j, k] && dpR[i + 1, k]) { dpL[j, i] = true; break; }\n                }\n                for (int k = i; k <= j - 1; k++) {\n                    if (win[j, k] && dpL[j - 1, k] && dpR[i, k]) { dpR[i, j] = true; break; }\n                }*/\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dpL[n - 1][i] && dpR[0][i]) ans++;\n        }\n        cout.WriteLine(ans);\n#endif\n    }\n}\n\npublic struct BitSet {\n    public readonly ulong[] _array;\n\n    public BitSet(int size) {\n        _array = new ulong[(size - 1) / 64 + 2];\n        BitLength = size;\n    }\n\n    public int BitLength { get; private set; }\n\n    public int CountBit() {\n        int count = 0;\n        foreach (var a in _array) {\n            count += PopCount(a);\n        }\n        return count;\n    }\n\n    public bool Any() {\n        return Array.FindIndex(_array, a => a != 0UL) >= 0;\n    }\n\n    public bool All() {\n        return CountBit() == BitLength;\n    }\n\n    public BitSet Slice(int begin, int end) {\n        var bitset = new BitSet(end - begin);\n        var jump = begin >> 6;\n        var move = begin & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (_array[i + jump] >> move) |\n                (i + jump + 1 < arrayLength ? (_array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator <<(BitSet b, int shift) {\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = jump; i < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i - jump] << move) |\n                (i - jump - 1 >= 0 ? (b._array[i - jump - 1] >> (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n    public static BitSet operator >>(BitSet b, int shift) {\n        var bitset = new BitSet(b.BitLength);\n        var jump = shift >> 6;\n        var move = shift & 63;\n        var arrayLength = bitset._array.Length;\n        for (int i = 0; i + jump < arrayLength; i++) {\n            bitset._array[i] = unchecked(\n                (b._array[i + jump] >> move) |\n                (i + jump + 1 < arrayLength ? (b._array[i + jump + 1] << (64 - move)) : 0)\n            );\n        }\n        return bitset;\n    }\n\n\n    public static BitSet operator &(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] & b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator |(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] | b2._array[i];\n        }\n        return bitset;\n    }\n\n    public static BitSet operator ^(BitSet b1, BitSet b2) {\n        var bitset = new BitSet(b1.BitLength);\n        for (int i = 0; i < bitset._array.Length; i++) {\n            bitset._array[i] = b1._array[i] ^ b2._array[i];\n        }\n        return bitset;\n    }\n\n    private static int PopCount(ulong x) {\n        x = (x & 0x5555555555555555UL) + ((x >> 1) & 0x5555555555555555UL);\n        x = (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);\n        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        return (int)(x & 0x7FLU);\n    }\n\n    public static bool operator ==(BitSet b1, BitSet b2) {\n        return b1.Equals(b2);\n    }\n\n    public static bool operator !=(BitSet b1, BitSet b2) {\n        return !(b1 == b2);\n    }\n\n    public override bool Equals(object obj) {\n        if (obj is BitSet) {\n            return Equals((BitSet)obj);\n        }\n        return false;\n    }\n\n    public bool Equals(BitSet b) {\n        if (BitLength != b.BitLength) return false;\n        for (int i = 0; i < _array.Length; i++) {\n            if (_array[i] != b._array[i]) return false;\n        }\n        return true;\n    }\n\n    public override int GetHashCode() {\n        var hash = BitLength.GetHashCode();\n        foreach (var a in _array) {\n            hash = unchecked(hash * 31) ^ a.GetHashCode();\n        }\n        return hash;\n    }\n\n    public bool this[int index] {\n        get {\n            return (_array[index >> 6] & (1UL << (index & 63))) != 0UL;\n        }\n        set {\n            if (value) {\n                _array[index >> 6] |= 1UL << (index & 63);\n            } else {\n                _array[index >> 6] &= ~(1UL << (index & 63));\n            }\n        }\n    }\n\n    public override string ToString() {\n        var b = new StringBuilder();\n        for (int i = BitLength - 1; i >= 0; i--) {\n            b.Append(this[i] ? '1' : '0');\n        }\n        return b.ToString();\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner {\n    public static void Main(string[] args) {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next() {\n        if (TokenQueue.Count == 0) {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext() {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens() {\n        while (true) {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "// inputに入力データ全体が入る\nfunction Main(input) {\n\tinput = input.split(\"\\n\");\n  \tvar N = parseInt(input[0]);\n      var As = input.slice(1).map(x => x.split(\"\").map(y => parseInt(y)));\n  \tvar wins = new Array(N);\n  wins.fill(0);\n  \tfor(var i=0; i < N-1; i++){\n      for(var j=0; j < As[i].length; j ++){\n        if(As[i][j] == 0){\n          wins[j]++;\n        }else{\n          wins[i]++;\n        }\n      }\n    }\n  var result = wins.filter(x => x > Math.log2(N));\n  console.log(result.length);\n \t\n }\n//*この行以降は編集しないでください（標準入出力から一度に読み込み、Mainを呼び出します）\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "// inputに入力データ全体が入る\nfunction Main(input) {\n\tinput = input.split(\"\\n\");\n  \tvar N = parseInt(input[0]);\n      var As = input.slice(1).map(x => x.split(\"\").map(y => parseInt(y)));\n  \tvar wins = new Array(N);\n  wins.fill(0);\n  \tfor(var i=0; i < N-1; i++){\n      for(var j=0; j < As[i].length; j ++){\n        if(As[i][j] == 0){\n          wins[j]++;\n        }else{\n          wins[i]++;\n        }\n      }\n    }\n  var result = wins.filter(x => x > Math.floor(Math.log2(N)));\n  console.log(result.length);\n \t\n }\n//*この行以降は編集しないでください（標準入出力から一度に読み込み、Mainを呼び出します）\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar n int\n\tfmt.Scan(&n)\n\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Split(bufio.ScanLines)\n\n\twinMap := make(map[int]map[int]bool)\n\tfor i := 1; i <= n; i++ {\n\t\twinMap[i] = make(map[int]bool)\n\t}\n\tfor i := 2; i <= n; i++ {\n\t\tscanner.Scan()\n\t\tstr := scanner.Text()\n\t\tfor j := 1; j < i; j++ {\n\t\t\tif str[j-1] == '1' {\n\t\t\t\twinMap[i][j] = true\n\t\t\t\twinMap[j][i] = false\n\t\t\t} else {\n\t\t\t\twinMap[i][j] = false\n\t\t\t\twinMap[j][i] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tdpl := make([][]bool, n)\n\tdpr := make([][]bool, n)\n\tfor i := 0; i < n; i++ {\n\t\tdpl[i] = make([]bool, n)\n\t\tdpr[i] = make([]bool, n)\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < n-i; j++ {\n\t\t\tif i == 0 {\n\t\t\t\tdpl[j][j+i] = true\n\t\t\t\tdpr[j+i][j] = true\n\t\t\t} else {\n\t\t\t\tfor k := j; k <= j+i; k++ {\n\t\t\t\t\tif k != j && winMap[j+1][k+1] && dpl[k][j+i] && dpr[k][j+1] {\n\t\t\t\t\t\tdpl[j][j+i] = true\n\t\t\t\t\t}\n\t\t\t\t\tif k != j+i && winMap[j+i+1][k+1] && dpl[k][j+i-1] && dpr[k][j] {\n\t\t\t\t\t\tdpr[j+i][j] = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar ret int\n\tfor i := 0; i < n; i++ {\n\t\tif dpl[i][n-1] && dpr[i][0] {\n\t\t\tret++\n\t\t}\n\t}\n\tfmt.Println(ret)\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\nimport \"fmt\"\nfunc main() {\n  var n int\n  fmt.Scan(&n)\n  if n == 1 { fmt.Println(1);return }\n  a := make([][]bool,n)\n  dpl := make([][]bool,n)\n  dpr := make([][]bool,n)\n  for i:=0;i<n;i++ {\n    a[i] = make([]bool,n)\n    dpl[i] = make([]bool,n)\n    dpr[i] = make([]bool,n)\n    dpl[i][i] = true\n    dpr[i][i] = true\n  }\n  for i:=1;i<n;i++ {\n    var s string\n    fmt.Scan(&s)\n    for j:=0;j<i;j++ {\n      a[i][j] = (s[j:j+1] == \"1\")\n      a[j][i] = !a[i][j]\n    }\n  }\n  for l:=1;l<n;l++ {\n    for i,j:=0,l;j<n;i,j=i+1,j+1 {\n      for k:=i+1;k<=j;k++ { dpl[i][j] = dpl[i][j] || ( a[i][k] && dpl[k][j] && dpr[k][i+1]) }\n      for k:=i;k<=j-1;k++ { dpr[j][i] = dpr[j][i] || (!a[k][i] && dpl[k][j-1] && dpr[k][i]) }\n    }\n  }\n  m := 0\n  for i:=0;i<n;i++ {\n    if dpl[i][n-1] && dpr[i][0] { m++ }\n  }\n  fmt.Println(m)\n}"
  },
  {
    "language": "Nim",
    "code": "import sequtils, strutils\n\ntype Bitset = array[32, uint64]\n\nproc `[]`(bs: Bitset, i: Natural): bool =\n  let i = uint64(i)\n  (bs[i div 64] and 1'u64 shl (i mod 64)) == 1\nproc `[]=`(bs: var Bitset, i: Natural, x: bool) =\n  let i = uint64(i)\n  bs[i div 64] = bs[i div 64] or uint64(x) shl (i mod 64)\n\nproc `not`(bs: Bitset): Bitset =\n  for i,b in bs:\n    result[i] = not b\n\nproc `and`(bs, cs: Bitset): Bitset =\n  for i in 0..<len(bs):\n    result[i] = bs[i] and cs[i]\n\nproc `or`(bs, cs: Bitset): Bitset =\n  for i in 0..<len(bs):\n    result[i] = bs[i] or cs[i]\n\nproc `shr`(bs: Bitset, x: Natural): Bitset =\n  let\n    n = uint64(x div 64)\n    m = uint64(x mod 64)\n  for i in n..<len(bs):\n    result[i-n] = result[i] shr m\n  for i in (n+1)..<len(bs):\n    result[i-n-1] = result[i-n-1] or result[i] shl (64'u64-m)\n\nproc `shl`(bs: Bitset, x: Natural): Bitset =\n  let\n    n = uint64(x div 64)\n    m = uint64(x mod 64)\n  for i in n..<len(bs):\n    result[i] = result[i-n] shl m\n  for i in (n+1)..<len(bs):\n    result[i] = result[i] or result[i-n-1] shr (64'u64-m)\n\nproc reset(bs: var Bitset) =\n  for b in bs.mitems:\n    b = 0\n\nproc fill(bs: var Bitset, i,j: Natural, x: bool) =\n  let\n    k = j - i\n    n = k div 64\n    m = uint64(k mod 64)\n  var cs: Bitset\n  for i in 0..<n:\n    cs[i] = not cs[i]\n  cs[n] = 1'u64 shl m - 1'u64\n  cs = cs shl i\n  if x:\n    bs = bs or cs\n  else:\n    bs = bs and not cs\n   \nlet n = stdin.readline.parseInt\nvar bss = newSeq[Bitset](n)\n\nfor i in 1..<n:\n  for j,a in stdin.readline:\n    if a == '1':\n      bss[i][j] = 1\n    else:\n      bss[j][i] = 1\n\nvar dp = newSeq[Bitset](n)\n\nproc any(bs: Bitset, i,j: Natural): Natural =\n  for k in i..j:\n    if bs[k] == 1:\n      return 1 \n  return 0\n\nfor i in 0..<n:\n  dp[i][i] = 1\nfor w in 1..<n:\n  for i in 0..<(n-w):\n    dp[i+w][i] = any(bss[i] and dp[i+1] and dp[i+w], i+1, i+w)\n  for i in w..<n:\n    dp[i-w][i] = any(bss[i] and dp[i-1] and dp[i-w], i-w, i-1)\n\nvar res = 0\nfor k in 0..<n:\n  if (dp[0][k] and dp[n-1][k]) == 1 :\n    inc(res)\n\necho res\n"
  },
  {
    "language": "Nim",
    "code": "import sequtils, strutils\n\ntype\n  barr = array[32, uint64]\n  Bitset = distinct barr\n\nproc `[]`(bs: Bitset, i: Natural): bool =\n  (barr(bs)[i div 64] and 1'u64 shl uint64(i mod 64)) != 0\nproc `[]=`(bs: var Bitset, i: Natural, x: bool) =\n  if x:\n    barr(bs)[i div 64] = barr(bs)[i div 64] or 1'u64 shl uint64(i mod 64)\n  else:\n    barr(bs)[i div 64] = barr(bs)[i div 64] and not (0'u64 shl uint64(i mod 64))\n\nproc `not`(bs: Bitset): Bitset =\n  for i,b in barr(bs):\n    barr(result)[i] = not b\n\nproc `and`(bs, cs: Bitset): Bitset =\n  for i in 0..<len(barr(bs)):\n    barr(result)[i] = barr(bs)[i] and barr(cs)[i]\n\nproc `or`(bs, cs: Bitset): Bitset =\n  for i in 0..<len(barr(bs)):\n    barr(result)[i] = barr(bs)[i] or barr(cs)[i]\n\nproc `shr`(bs: Bitset, x: Natural): Bitset =\n  let\n    n = x div 64\n    m = uint64(x mod 64)\n  for i in n..<len(barr(bs)):\n    barr(result)[i-n] = barr(bs)[i] shr m\n  for i in 0..<(len(barr(bs))-n-1):\n    barr(result)[i] = barr(result)[i] or (barr(bs)[i+n+1] shl (64'u64-m))\n\nproc `shl`(bs: Bitset, x: Natural): Bitset =\n  let\n    n = x div 64\n    m = uint64(x mod 64)\n  for i in n..<len(barr(bs)):\n    barr(result)[i] = barr(bs)[i-n] shl m\n  for i in (n+1)..<len(barr(bs)):\n    barr(result)[i] = barr(result)[i] or (barr(bs)[i-n-1] shr (64'u64-m))\n\nproc reset(bs: var Bitset) =\n  for b in barr(bs).mitems:\n    b = 0\n\nproc fill(bs: var Bitset, i,j: Natural, x: bool) =\n  let\n    k = j - i + 1\n    n = k div 64\n    m = uint64(k mod 64)\n  var cs: Bitset\n  for i in 0..<n:\n    barr(cs)[i] = not barr(cs)[i]\n  barr(cs)[n] = 1'u64 shl m - 1'u64\n  cs = cs shl i\n  if x:\n    bs = bs or cs\n  else:\n    bs = bs and not cs\n\nproc any(bs: Bitset): bool =\n  for b in barr(bs):\n    if b!=0'u64:\n      return true\n  return false\n\nlet n = stdin.readline.parseInt\nvar bss = newSeq[Bitset](n)\n\nfor i in 1..<n:\n  for j,a in stdin.readline:\n    if a == '1':\n      bss[i][j] = true\n    else:\n      bss[j][i] = true\n\nvar dp = newSeq[Bitset](n)\n\nproc anyIn(bs: Bitset, i,j: Natural): bool =\n  var cs: Bitset\n  cs.fill(i, j, true)\n  return any(bs and cs)\n\nfor i in 0..<n:\n  dp[i][i] = true\nfor w in 1..<n:\n  for i in 0..<(n-w):\n    dp[i+w][i] = anyIn(bss[i] and dp[i+1] and dp[i+w], i+1, i+w)\n  for i in w..<n:\n    dp[i-w][i] = anyIn(bss[i] and dp[i-1] and dp[i-w], i-w, i-1)\n\nvar res = 0\nfor k in 0..<n:\n  if dp[0][k] and dp[n-1][k]:\n    inc(res)\n\necho res\n"
  },
  {
    "language": "Nim",
    "code": "import sequtils, strutils\n\nlet n = stdin.readline.parseInt\nvar bss = newSeqWith(n, newSeq[int]())\n\nfor i in 1..<n:\n  for j,a in stdin.readline:\n    if a == '1':\n      bss[i].add(j)\n    else:\n      bss[j].add(i)\n\nvar dp = newSeqWith(n, newSeq[bool](n))\n\nfor i in 0..<n:\n  dp[i][i] = true\nfor w in 1..<n:\n  for i in 0..<(n-w):\n    for k in bss[i]:\n      if k > i and k <= i+w and dp[k][i+w] and dp[k][i+1]:\n        dp[i][i+w] = true\n        break\n  for i in w..<n:\n    for k in bss[i]:\n      if k < i and k >= i-w and dp[k][i-w] and dp[k][i-1]:\n        dp[i][i-w] = true\n        break\n\nvar res = 0\nfor k in 0..<n:\n  if dp[k][0] and dp[k][n-1]:\n    inc(res)\n\necho res\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\nfrom itertools import accumulate\n\ndef main():\n    N = II()\n    A = [[0] * N for _ in range(N)]\n    for i in range(1, N):\n        s = SI()\n        for j, aa in enumerate(s):\n            aa = int(aa)\n            A[i][j] = aa\n            A[j][i] = 1 - aa\n    def win(k, start, end):\n        ret = 0 if start != k else 1\n        for l in range(start, k):\n            if A[k][l] == 1:\n                if win(l, start, k):\n                    ret = 1\n                    break\n        if not ret:\n            return 0\n        ret = 0 if end - 1 != k else 1\n        for r in range(k + 1, end):\n            if A[k][r] == 1:\n                if win(r, k + 1, end):\n                    ret = 1\n                    break\n        return ret\n    ans = sum(win(k, 0, N) for k in range(N))\n\n    return ans\n\nprint(main())"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\nfrom functools import lru_cache\n\ndef main():\n    N = II()\n    A = [[0] * N for _ in range(N)]\n    for i in range(1, N):\n        s = SI()\n        for j, aa in enumerate(s):\n            aa = int(aa)\n            A[i][j] = aa\n            A[j][i] = 1 - aa\n    dpl = [[1] * N for _ in range(N)]\n    dpr = [[1] * N for _ in range(N)]\n    for sub in range(1, N):\n        for i in range(N - sub):\n            j = i + sub\n            winr = 0\n            for k in range(i + 1, j + 1):\n                if A[i][k] and dpl[i + 1][k] and dpr[k][j]:\n                    winr = 1\n                    break\n            dpr[i][j] = winr\n            winl = 0\n            for k in range(i, j):\n                if A[j][k] and dpl[i][k] and dpr[k][j - 1]:\n                    winl = 1\n                    break\n            dpl[i][j] = winl\n\n    ans = 0\n    for i in range(N):\n        ans += dpl[0][i] * dpr[i][N - 1]\n    return ans\n\nprint(main())"
  },
  {
    "language": "Python",
    "code": "import sys\n\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef SI(): return sys.stdin.readline()[:-1]\ndef pbit(aa,L):\n    for a in aa:print(format(a,\"b\").zfill(L))\n    print()\n\ndef main():\n    n=II()\n    aa=[[int(c) for c in SI()] for _ in range(n-1)]\n    #p2D(aa)\n\n    # 人iが勝てる相手をbitで管理する\n    win=[0]*n\n    for i,row in enumerate(aa,1):\n        for j,a in enumerate(row):\n            if a:win[i]|=1<<j\n            else:win[j]|=1<<i\n    #pbit(win,n)\n\n    # dpl[i]...[j,i]の範囲で優勝できるjをbitで\n    # dpr[i]...[i,j]の範囲で優勝できるjをbitで\n    dpl=[1<<i for i in range(n)]\n    dpr=[1<<i for i in range(n)]\n    for d in range(1,n):\n        for i in range(n-d):\n            j=i+d\n            if dpl[j] & dpr[i+1] & win[i]:dpl[j]|=1<<i\n        for i in range(d,n):\n            j=i-d\n            if dpl[i-1] & dpr[j] & win[i]:dpr[j]|=1<<i\n    #pbit(dpl,n)\n    #pbit(dpr,n)\n    #print(format(dpl[n-1]&dpr[0],\"b\").zfill(n))\n    print(bin(dpl[n-1]&dpr[0]).count(\"1\"))\n\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\nfrom functools import lru_cache\n\ndef main():\n    N = II()\n    A = [[0] * N for _ in range(N)]\n    for i in range(1, N):\n        s = SI()\n        for j, aa in enumerate(s):\n            aa = int(aa)\n            A[i][j] = aa\n            A[j][i] = 1 - aa\n    dpl = [[1] * N for _ in range(N)]\n    dpr = [[1] * N for _ in range(N)]\n    for sub in range(1, N):\n        for i in range(N - sub):\n            j = i + sub\n            winr = 0\n            for k in range(i + 1, j + 1):\n                if A[i][k] and dpl[i + 1][k] and dpr[k][j]:\n                    winr = 1\n                    break\n            dpr[i][j] = winr\n            winl = 0\n            for k in range(i, j):\n                if A[j][k] and dpl[i][k] and dpr[k][j - 1]:\n                    winl = 1\n                    break\n            dpl[i][j] = winl\n\n    ans = 0\n    for i in range(N):\n        ans += dpl[0][i] * dpr[i][N - 1]\n    return ans\n\nprint(main())"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nA = []\nans = 0\n\nfor i in range(N-1):\n    a = input()\n    ans += a.count('0')\n    A.append(a)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\n\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    n=II()\n    aa=[[int(c) for c in SI()] for _ in range(n-1)]\n    #p2D(aa)\n\n    dp=set()\n    dp.add((1<<n)-1)\n    for _ in range(n-1):\n        ndp=set()\n        for bit in dp:\n            i=j=(bit&-bit).bit_length()-1\n            while 1<<i<bit:\n                i+=1\n                while bit>>i&1==0 and 1<<i<=bit:i+=1\n                if 1<<i>bit:break\n                if aa[i-1][j]:nbit=bit^1<<j\n                else:nbit=bit^1<<i\n                ndp.add(nbit)\n                j=i\n        dp=ndp\n\n    print(len(dp))\n\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\n\ndef main():\n    tab = {'0': '1', '1': '0'}\n    N = II()\n    A = [['0'] * N for _ in range(N)]\n    for i in range(1, N):\n        s = SI()\n        for j, aa in enumerate(s):\n            A[i][j] = aa\n            A[j][i] = tab[aa]\n    for i in range(N):\n        A[i] = int(''.join(A[i])[::-1], 2)\n    dpl = [int('1' * N, 2) for _ in range(N)]\n    dpr = [int('1' * N, 2) for _ in range(N)]\n    for sub in range(1, N):\n        for i in range(N - sub):\n            j = i + sub\n            winr = A[i] & dpl[i + 1] & dpr[j]\n            winr = (winr >> (i + 1)) & ((1 << sub) - 1)\n            dpr[j] -= (0 if winr else 1) << i\n            winl = A[j] & dpl[i] & dpr[j - 1]\n            winl = (winl >> i) & ((1 << sub) - 1)\n            dpl[i] -= (0 if winl else 1) << j\n\n    ans = bin(dpl[0] & dpr[N - 1]).count('1')\n    return ans\n\nprint(main())"
  },
  {
    "language": "Python",
    "code": "a = 3\npront \"2\""
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ninpl = lambda: list(map(int,input().split()))\n\nN = int(input())\nA = [[]]\nfor _ in range(N-1):\n    A.append(list(map(int,list(input()))))\n\ndef match(i,j):\n    if i > j:\n        return bool(A[i][j])\n    else:\n        return not bool(A[j][i])\n\nwinmem = defaultdict(lambda: None)\n\ndef winnerlist(left,right):\n    ans = winmem[(left,right)]\n    if ans is not None:\n        return ans\n    elif right - left <= 1:\n        return set({left})\n\n    ans = set()\n    for i in range(left+1,right):\n        left_winners = winnerlist(left,i)\n        right_winners = winnerlist(i,right)\n        for l in left_winners:\n            for r in right_winners:\n                if match(l,r):\n                    ans.add(l)\n                else:\n                    ans.add(r)\n    winmem[(left,right)] = ans\n    return ans\n\nwinners = winnerlist(0,N)\nprint(len(winners))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\na_table = [[]]\n\nfor i in range(N - 1):\n\ta_table.append([x == \"1\" for x in input().strip()])\n\nfor i in range(N):\n\ta_list = a_table[i]\n\ta_list.append(None)\n\tfor j in range(i + 1, N):\n\t\ta_list.append(a_table[j][i])\n\ndef check(x):\n\tstack = [x]\n\tvisited = {x}\n\ta_list = a_table[x]\n\twhile stack:\n\t\tcur = stack.pop()\n\t\tfor i in range(N):\n\t\t\tif i != cur and a_list[i] and not i in visited:\n\t\t\t\tstack.append(i)\n\t\t\t\tvisited.add(i)\n\treturn len(visited) == N - 1\n\ncount = 0\nfor i in range(N):\n\tif check(i):\n\t\tcount += 1\nprint(count)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = [[0] * N for _ in range(N)]\ndpl = [[0] * N for _ in range(N)]\ndpr = [[0] * N for _ in range(N)]\n\nfor i in range(N) :\n    dpl[i][i] = dpr[i][i] = 1\n\nfor i in range(1, N) :\n    for j, v in enumerate(input()) :\n        if v == '1' :\n            A[i][j] = 1\n        else :\n            A[j][i] = 1\n\nfor dist in range(1, N) :\n    for i in range(N - dist) :\n        j = i + dist\n        for k in range(i + 1, j + 1) :\n            if A[i][k] and dpl[k][j] and dpr[k][i+1] :\n                dpl[i][j] = 1\n                break\n        for k in range(i, j) :\n            if A[j][k] and dpl[k][j-1] and dpr[k][i] :\n                dpr[j][i] = 1\n                break\n                \nret = 0\nfor i in range(N) :\n    if dpl[i][N-1] and dpr[i][0] :\n        ret += 1\nprint(ret)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n# X = [[1 if i == j else 0 for j in range(N)] for i in range(N)]\nX = [[0] * N for _ in range(N)]\nfor i in range(1, N):\n    X[i][:i] = [int(a) for a in input()]\nfor i in range(N):\n    for j in range(i+1, N):\n        X[i][j] = X[j][i]^1\nY = [[] for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if X[i][j]: Y[i].append(j)\n\ndpl = [[0] * N for _ in range(N)]\ndpr = [[0] * N for _ in range(N)]\nfor i in range(N):\n    dpl[i][i] = 1\n    dpr[i][i] = 1\n\nfor d in range(2, N+1):\n    for i in range(N-d+1):\n        j = i + d - 1\n        for k in range(i+1, j+1):\n            if X[i][k] and dpr[i+1][k] and dpl[k][j]:\n                dpl[i][j] = 1\n                break\n        for k in range(i, j):\n            if X[j][k] and dpr[i][k] and dpl[k][j-1]:\n                dpr[i][j] = 1\n                break\n\nprint(sum([1 if dpr[0][i] and dpl[i][N-1] else 0 for i in range(N)]))"
  },
  {
    "language": "Python",
    "code": "Q = int(input())\ndiv = 1000003\ndiv_2 = div/2\nfor _ in range(Q):\n  x, d, n = map(int, input())\n  q = 1\n  for i in range(1, n+1):\n    tmp = (x + d*(i-1)) % div\n    if tmp > div_2:\n      tmp -= div\n    q *= tmp\n  if q < 0:\n    q += div\n  print(q)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nX = [[0] * N for _ in range(N)]\nfor i in range(1, N):\n    X[i][:i] = [int(a) for a in input()]\nfor i in range(N):\n    for j in range(i+1, N):\n        X[i][j] = X[j][i]^1\n\nA = [1<<i for i in range(N)]\nB = [1<<i for i in range(N)]\nfor i in range(N):\n    for j in range(i):\n        if i and B[i-1] >> j & 1 and X[i][j]: A[i] |= A[j]\n    for j in range(i):\n        if A[i] >> j+1 & 1 and X[j][i]: B[i] |= B[j]\n\nprint(sum([(A[i] & 1) * (B[N-1]>>i & 1) for i in range(N)]))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nimport sys\nsys.setrecursionlimit(1000000)\n\nn = int(input())\npeople = [i for i in range(n)]\na = [[-1] * n for _ in range(n)]\nfor i in range(n-1):\n    ai = input()\n    for j, aij in enumerate(ai):\n        a[i+1][j] = int(aij)\n        a[j][i+1] = (int(aij) + 1) % 2\n\nmemo = {}\n\n# startからendの範囲で優勝の可能性があるやつ\ndef solve(start, end):\n    key = (start, end)\n    if key in memo:\n        return memo[key]\n    if start == end:\n        return [start]\n    elif start + 1 == end:\n        if a[start][end] == 1:\n            return [start]\n        else:\n            return [end]\n    winable = set()\n    for i in range(start+1, end+1):\n        left_winable = solve(start, i-1)\n        if (start, i-1) not in memo:\n            memo[(start, i-1)] = left_winable\n        right_winable = solve(i, end)\n        if (i, end) not in memo:\n            memo[(i, end)] = right_winable\n        for l in left_winable:\n            for r in right_winable:\n                if a[l][r] == 1:\n                    winable.add(l)\n                else:\n                    winable.add(r)\n    return list(winable)\n\n\ndef main():\n    winable = solve(0, n-1)\n    print(len(winable))\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\n\n\ndef main():\n    n = I()\n    aa = [S() for _ in range(n-1)]\n    a = [[0] * n for _ in range(n)]\n    for i in range(n-1):\n        s = aa[i]\n        t = i + 1\n        for j in range(t):\n            if s[j] == '1':\n                a[t][j] = 1\n            else:\n                a[j][t] = 1\n\n    r = 0\n    for i in range(n):\n        ns = set([i])\n        ls = set([i])\n        while len(ns):\n            ts = set()\n            for k in ns:\n                for j in range(i):\n                    if j not in ls and a[k][j]:\n                        ts.add(j)\n\n            ls |= ts\n            ns = ts\n\n        if len(ls) != i + 1:\n            continue\n\n        ns = set([i])\n        ls = set([i])\n        while len(ns):\n            ts = set()\n            for k in ns:\n                for j in range(i+1,n):\n                    if j not in ls and a[k][j]:\n                        ts.add(j)\n\n            ls |= ts\n            ns = ts\n\n        if len(ls) == n - i:\n            r += 1\n\n\n    return r\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef SI(): return sys.stdin.readline()[:-1]\ndef pbit(aa,L):\n    for a in aa:print(format(a,\"b\").zfill(L))\n    print()\n\ndef main():\n    n=II()\n    aa=[[int(c) for c in SI()] for _ in range(n-1)]\n    #p2D(aa)\n    \n    # 人iが勝てる相手をbitで管理する\n    win=[0]*n\n    for i,row in enumerate(aa,1):\n        for j,a in enumerate(row):\n            if a:win[i]|=1<<j\n            else:win[j]|=1<<i\n    #pbit(win,n)\n\n    # dpl[i]...[j,i]の範囲で優勝できるjをbitで\n    # dpr[i]...[i,j]の範囲で優勝できるjをbitで\n    dpl=[1<<i for i in range(n)]\n    dpr=[1<<i for i in range(n)]\n    for d in range(1,n):\n        for i in range(n):\n            j=i+d\n            if j<n and dpl[j] & dpr[i+1] & win[i]:dpl[j]|=1<<i\n            j=i-d\n            if j>=0 and dpl[i-1] & dpr[j] & win[i]:dpr[j]|=1<<i\n    #pbit(dpl,n)\n    #pbit(dpr,n)\n    #print(format(dpl[n-1]&dpr[0],\"b\").zfill(n))\n    print(bin(dpl[n-1]&dpr[0]).count(\"1\"))\n\nmain()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n# m-solutions2019/m_solutions2019_f\nimport sys\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\nss2nn = lambda ss: [int(s) for s in list(ss)]\nss2nnn = lambda ss: [s2nn(s) for s in list(ss)]\ni2s = lambda: sys.stdin.readline().rstrip()\ni2n = lambda: int(i2s())\ni2nn = lambda: s2nn(i2s())\nii2ss = lambda n: [i2s() for _ in range(n)]\nii2nn = lambda n: ss2nn(ii2ss(n))\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\ndef main():\n    N = i2n()\n    b = 0\n    for x in range(N - 1):\n        b ^= int(i2s() + '0' * (N - 2 - x), 2)\n    print(b)\n    return\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = [[0] * N for _ in range(N)]\ndpl = [[0] * N for _ in range(N)]\ndpr = [[0] * N for _ in range(N)]\n\nfor i in range(N) :\n    dpl[i][i] = dpr[i][i] = 1\n\nfor i in range(1, N) :\n    for j, v in enumerate(input()) :\n        if v == '1' :\n            A[i][j] = 1\n        else :\n            A[j][i] = 1\n\nfor dist in range(1, N) :\n    for i in range(N - dist) :\n        j = i + dist\n        for k in range(i + 1, j + 1) :\n            if A[i][k] and dpl[k][j] and dpr[k][i+1] :\n                dpl[i][j] = 1\n                break\n        for k in range(i, j) :\n            if A[j][k] and dpl[k][j-1] and dpr[k][i] :\n                dpr[j][i] = 1\n                break\n                \nret = 0\nfor i in range(N) :\n    if dpl[i][N-1] and dpr[i][0] :\n        ret += 1\nprint(ret)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ninpl = lambda: list(map(int,input().split()))\n\nN = int(input())\nA = [[]]\nfor _ in range(N-1):\n    A.append(list(map(int,list(input()))))\n\ndef match(i,j):\n    if i > j:\n        return bool(A[i][j])\n    else:\n        return not bool(A[j][i])\n\nwinmem = defaultdict(set)\n\ndef winnerlist(left,right):\n    ans = winmem[(left,right)]\n    if len(ans) > 0:\n        return ans\n    elif right - left <= 1:\n        return set({left})\n\n    ans = set()\n    for i in range(left+1,right):\n        left_winners = winnerlist(left,i)\n        right_winners = winnerlist(i,right)\n        for l in list(left_winners):\n            for r in list(right_winners):\n                if match(l,r):\n                    ans.add(l)\n                else:\n                    ans.add(r)\n    winmem[(left,right)] = ans\n    return ans\n\nwinners = winnerlist(0,N)\nprint(len(winners))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nimport sys\nsys.setrecursionlimit(1000000)\n\nn = int(input())\npeople = [i for i in range(n)]\na = [[-1] * n for _ in range(n)]\nfor i in range(n-1):\n    ai = input()\n    for j, aij in enumerate(ai):\n        a[i+1][j] = int(aij)\n        a[j][i+1] = (int(aij) + 1) % 2\n\nmemo = {}\n\n# startからendの範囲で優勝の可能性があるやつ\ndef solve(start, end):\n    key = (start, end)\n    if key in memo:\n        return memo[key]\n    if start == end:\n        return [start]\n    elif start + 1 == end:\n        if a[start][end] == 1:\n            return [start]\n        else:\n            return [end]\n    winable = set()\n\n    # 全勝の存在をチェック\n    for i in range(start, end):\n        if sum(a[i]) == end - start + 1 - 2:\n            return [i]\n    for i in range(start+1, end+1):\n        left_winable = solve(start, i-1)\n        if (start, i-1) not in memo:\n            memo[(start, i-1)] = left_winable\n        right_winable = solve(i, end)\n        if (i, end) not in memo:\n            memo[(i, end)] = right_winable\n        for l in left_winable:\n            for r in right_winable:\n                if a[l][r] == 1:\n                    winable.add(l)\n                else:\n                    winable.add(r)\n    return list(winable)\n\n\ndef main():\n    winable = solve(0, n-1)\n    print(len(winable))\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#人i が 人j に勝つならTrue\ndef judge(rule, i, j):\n  rev = False\n  if i < j:\n    i, j = j, i\n    rev = True\n  if rule[i - 1][j] == 0:\n    ret = False\n  else:\n    ret = True\n  \n  if rev:\n    ret = not ret\n    \n  return ret\n\n\nn = int(input())\nrule = [list(map(lambda x:int(x), list(input()))) for i in range(n - 1)]\n#print(rule)\nfor i in range(n):\n  for j in range(n):\n    if i != j:\n      vic = judge(rule, i, j)\n#      print(\"{}x{}:{}\".format(i, j, vic))    \n      \nleft = [0]\nfor i in range(1,n):\n  for j in left:\n    if judge(rule, i, j):\n      left.append(i)\n      break\n#print(left)\nright = [n - 1]\nfor i in range(n - 2, -1, -1):\n  #print(i)\n  for j in right:\n    if judge(rule, i, j):\n      right.append(i)\n      break\n#print(right)\n\nresult = set(left).intersection(set(right))\n\nprint(len(result))"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(1000000)\n\n@lru_cache(maxsize=None)\ndef l(i, j):\n    if i == j: return 1\n    for k in range(i+1, j+1):\n        if X[i][k] and r(i+1, k) and l(k, j): return 1\n    return 0\ndef r(i, j):\n    if i == j: return 1\n    for k in range(i, j):\n        if X[j][k] and r(i, k) and l(k, j-1): return 1\n    return 0\n\nN = int(input())\nX = [[0] * N for _ in range(N)]\nfor i in range(1, N):\n    X[i][:i] = [int(a) for a in input()]\nfor i in range(N):\n    for j in range(i+1, N):\n        X[i][j] = X[j][i]^1\nY = [[] for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if X[i][j]: Y[i].append(j)\n\nprint(sum([1 if r(0, i) and l(i, N-1) else 0 for i in range(N)]))"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\nfrom functools import lru_cache\n\ndef main():\n    N = II()\n    A = [[0] * N for _ in range(N)]\n    for i in range(1, N):\n        s = SI()\n        for j, aa in enumerate(s):\n            aa = int(aa)\n            A[i][j] = aa\n            A[j][i] = 1 - aa\n    @lru_cache(maxsize=10**7)\n    def win(k, start, end):\n        ret = 0 if start != k else 1\n        for l in range(start, k):\n            if A[k][l] == 1:\n                if win(l, start, k):\n                    ret = 1\n                    break\n        if not ret:\n            return 0\n        ret = 0 if end - 1 != k else 1\n        for r in range(k + 1, end):\n            if A[k][r] == 1:\n                if win(r, k + 1, end):\n                    ret = 1\n                    break\n        return ret\n    ans = sum(win(k, 0, N) for k in range(N))\n\n    return ans\n\nprint(main())"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nn = int(input())\nlose = [set() for _ in range(n)]\nfor i in range(1, n):\n  A = map(int, list(input()))\n  for j, a in enumerate(A):\n    if a:\n      lose[j].add(i)\n    else:\n      lose[i].add(j)\ndef dfs(i, left, right):\n  l_bool, r_bool = False, False\n  if left == i:\n    l_bool = True\n  if right == i:\n    r_bool = True\n  for j in range(left, i):\n    if i in lose[j]:\n      l_bool |= dfs(j, left, i-1)\n  for j in range(i+1, right+1):\n    if i in lose[j]:\n      r_bool |= dfs(j, i+1, right)\n  return l_bool & r_bool\n      \nans = 0\nfor i in range(n):\n  if dfs(i, 0, n-1):\n    ans += 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nl=[list(input()) for i in range(n-1)]\nct=0\nfor i in range(n-1):\n  for j in range(i+1):\n    if l[i][j]=='0':ct+=1\nprint(ct)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nfrom collections import deque\nfrom heapq import heappush,heappop\nimport re\n\ndef int_raw():\n    return int(input())\n \ndef ss_raw():\n    return input().split()\n \ndef ints_raw():\n    return tuple(map(int, ss_raw()))\n\n\n\nN = int_raw()\nAs =[input() for _ in range(N-1)]\n\ndef main():\n    ans =0 \n    for j in range(N):\n        is_p = j==0\n        for i in range(j):\n            if As[j-1][i] ==\"1\":\n                is_p = True\n        is_b = j == (N-2)\n        for k in range(j+1,N):\n            if As[k-1][j] ==\"0\":\n                is_b = True\n        if is_b and is_p:\n            ans+=1\n    return ans\n\nprint(main())\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    n=II()\n    aa=[[int(c) for c in SI()] for _ in range(n-1)]\n    #p2D(aa)\n\n    dp=set()\n    dp.add((1<<n)-1)\n    for _ in range(n-1):\n        ndp=set()\n        for bit in dp:\n            i=j=(bit&-bit).bit_length()-1\n            while 1<<i<bit:\n                i+=1\n                while bit>>i&1==0 and 1<<i<=bit:i+=1\n                if 1<<i>bit:break\n                if aa[i-1][j]:nbit=bit^1<<j\n                else:nbit=bit^1<<i\n                ndp.add(nbit)\n                j=i\n        dp=ndp\n\n    print(len(dp))\n\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nn = int(input())\nG = [[] for _ in range(n)]\nfor i in range(1, n):\n  A = map(int, list(input()))\n  for j, a in enumerate(A):\n    if a:\n      G[i].append(j)\n    else:\n      G[j].append(i)\ndef dfs(i, left, right):\n  l_bool, r_bool = False, False\n  if left == i:\n    l_bool = True\n  if right == i:\n    r_bool = True\n  for j in G[i]:\n    if left <= j < i:\n      l_bool |= dfs(j, left, i-1)\n    elif i < j <= right:\n      r_bool |= dfs(j, i+1, right)\n  return l_bool & r_bool\n\nans = 0\nfor i in range(n):\n  if dfs(i, 0, n-1):\n    ans += 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\n\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef SI(): return sys.stdin.readline()[:-1]\ndef pbit(aa,L):\n    for a in aa:print(format(a,\"b\").zfill(L))\n    print()\n\ndef main():\n    n=II()\n    aa=[[int(c) for c in SI()] for _ in range(n-1)]\n    #p2D(aa)\n    \n    # 人iが勝てる相手をbitで管理する\n    win=[0]*n\n    for i,row in enumerate(aa,1):\n        for j,a in enumerate(row):\n            if a:win[i]|=1<<j\n            else:win[j]|=1<<i\n    #pbit(win,n)\n\n    # dpl[i]...[j,i]の範囲で優勝できるjをbitで\n    # dpr[i]...[i,j]の範囲で優勝できるjをbitで\n    dpl=[1<<i for i in range(n)]\n    dpr=[1<<i for i in range(n)]\n    for d in range(1,n):\n        for i in range(n):\n            j=i+d\n            if j<n and dpl[j] & dpr[i+1] & win[i]:dpl[j]|=1<<i\n            j=i-d\n            if j>=0 and dpl[i-1] & dpr[j] & win[i]:dpr[j]|=1<<i\n    #pbit(dpl,n)\n    #pbit(dpr,n)\n    #print(format(dpl[n-1]&dpr[0],\"b\").zfill(n))\n    print(bin(dpl[n-1]&dpr[0]).count(\"1\"))\n\nmain()"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/m-solutions2019/tasks/m_solutions2019_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\n// ===\n\n\n#[derive(Clone, Debug)]\nstruct BitVector {\n    n: usize,\n    size: usize,\n    data: Vec<u64>\n}\n\nimpl BitVector {\n    fn new(n: usize) -> Self {\n        let size = (n+63)/64;\n        BitVector {\n            n: n,\n            size: size,\n            data: vec![0; size]\n        }\n    }\n\n    fn get(&self, i: usize) -> bool {\n        self.data[i/64]>>(i%64) & 1 != 0\n    }\n\n    fn set(&mut self, i: usize) {\n        self.data[i/64] |= 1<<(i%64);\n    }\n\n    fn count(&self) -> usize {\n        let mut cnt = 0;\n        for i in 0..self.size {\n            cnt += self.data[i].count_ones();\n        }\n        cnt as usize\n    }\n}\n\nimpl<'a> std::ops::Shl<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shl(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n\n        let diff = amount / 64;\n        let diff_mod = amount % 64;\n        if diff_mod == 0 {\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<(64-diff_mod))-1;\n            let upper_mask = ((1<<diff_mod)-1)<<(64-diff_mod);\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] |= (self.data[i] & lower_mask)<<diff_mod;\n                if i+diff+1 < self.size {\n                    new_vector.data[i+diff+1] |= (self.data[i] & upper_mask)>>(64-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\n\nimpl<'a> std::ops::Shr<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shr(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n\n        let diff = amount / 64;\n        let diff_mod = amount % 64;\n        if diff_mod == 0 {\n            for i in diff..self.size {\n                new_vector.data[i-diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<diff_mod)-1;\n            let upper_mask = ((1<<(64-diff_mod))-1)<<diff_mod;\n            for i in diff..self.size {\n                new_vector.data[i-diff] |= (self.data[i] & upper_mask)>>diff_mod;\n                if i > diff {\n                    new_vector.data[i-diff-1] |= (self.data[i] & lower_mask)<<(64-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\nimpl<'a> std::ops::BitAnd for &'a BitVector {\n    type Output = BitVector;\n\n    fn bitand(self, other: Self) -> Self::Output {\n        let mut output = BitVector::new(self.n);\n        for i in 0..self.size {\n            output.data[i] = self.data[i] & other.data[i];\n        }\n        output\n    }\n}\n\nimpl std::ops::BitAndAssign for BitVector {\n    fn bitand_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] &= rhs.data[i];\n        }\n    }\n}\n\nimpl<'a> std::ops::BitOr for &'a BitVector {\n    type Output = BitVector;\n\n    fn bitor(self, other: Self) -> Self::Output {\n        let mut output = BitVector::new(self.n);\n        for i in 0..self.size {\n            output.data[i] = self.data[i] | other.data[i];\n        }\n        output\n    }\n}\n\nimpl std::ops::BitOrAssign for BitVector {\n    fn bitor_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] |= rhs.data[i];\n        }\n    }\n}\n\nimpl std::ops::BitXorAssign for BitVector {\n    fn bitxor_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] ^= rhs.data[i];\n        }\n    }\n}\n\n//===\n\nfn main() {\n    input! {\n        n: usize,\n        table: [chars; n-1]\n    };\n\n    // 1 to n, 0 and n+1 are sentinels\n    let mut wintable = vec![BitVector::new(2048); n+2];\n    for i in 2..n+1 {\n        for j in 1..i {\n            if table[i-2][j-1] == '1' {\n                // i wins j\n                wintable[i].set(j);\n            } else {\n                wintable[j].set(i);\n            }\n        }\n    }\n\n    let mut dp_left = vec![BitVector::new(2048); n+2];\n    let mut dp_right = vec![BitVector::new(2048); n+2];\n\n    let mut dp_left_rev = vec![BitVector::new(2048); n+2];\n    let mut dp_right_rev = vec![BitVector::new(2048); n+2];\n\n    for i in 1..n+1 {\n        dp_left[i].set(i);\n        dp_right[i].set(i);\n        dp_left_rev[i].set(i);\n        dp_right_rev[i].set(i);\n    }\n    for l in 1..n {\n        for i in 1..n+1 {\n            if i > l {\n                let lj = i-l;\n                let mut ok = false;\n                ok |= (&dp_left[i] & &dp_left_rev[lj]).count() >= 1;\n                ok |= (&(&(&dp_left[i]>>1) & &dp_left_rev[lj]) & &wintable[i]).count() >= 1;\n                ok |= wintable[i].get(lj) && (&dp_left[i] & &(&dp_right[lj]<<1)).count() >= 1;\n                if ok {\n                    dp_left[i].set(lj);\n                    dp_left_rev[lj].set(i);\n                }\n            }\n            if i+l <= n {\n                let rj = i+l;\n                let mut ok = false;\n                ok |= (&dp_right[i] & &dp_right_rev[rj]).count() >= 1;\n                ok |= (&(&(&dp_right[i]<<1) & &dp_right_rev[rj]) & &wintable[i]).count() >= 1;\n                ok |= wintable[i].get(rj) && (&dp_right[i] & &(&dp_left[rj]>>1)).count() >= 1;\n                if ok {\n                    dp_right[i].set(rj);\n                    dp_right_rev[rj].set(i);\n                }\n            }\n        }\n    }\n\n\n    let mut count = 0;\n    for i in 1..n+1 {\n        if dp_left[i].get(1) && dp_right[i].get(n) {\n            count += 1;\n            // debug!(i);\n        }\n    }\n    println!(\"{}\", count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    a: Vec<usize>,\n}\n\nfn bit_size() -> usize {\n    8 * std::mem::size_of::<usize>()\n}\n\nfn quot_rem(n: usize) -> (usize, usize) {\n    let w = bit_size();\n    (n / w, n % w)\n}\n\n#[allow(dead_code)]\nimpl BitSet {\n    fn new(size: usize) -> Self {\n        let w = bit_size();\n        BitSet {\n            size: size,\n            a: vec![0; (size + w - 1) / w],\n        }\n    }\n    fn set_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] |= 1 << r;\n    }\n    fn clear_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] &= !(1 << r);\n    }\n    fn get_at(&self, x: usize) -> bool {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        (self.a[q] >> r) & 1 == 1\n    }\n    fn any(&self) -> bool {\n        self.a.iter().any(|a| *a != 0)\n    }\n    fn fix(&mut self) {\n        let (q, r) = quot_rem(self.size);\n        if r != 0 {\n            self.a[q] &= (1 << r) - 1;\n        }\n    }\n    fn clear(&mut self) {\n        let len = self.a.len();\n        self.a.clear();\n        self.a.resize(len, 0);\n    }\n    fn truncate(&mut self, len: usize) {\n        if len >= self.size {\n            return;\n        }\n        let w = bit_size();\n        self.a.truncate((len + w - 1) / w);\n        self.size = len;\n        self.fix();\n    }\n    fn shift_left(&self, rhs: usize) -> Self {\n        let (q, r) = quot_rem(rhs);\n        let mut ans = BitSet::new(self.size + rhs);\n        if r == 0 {\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = *y;\n            }\n        } else {\n            let w = bit_size();\n            let mut prev = 0;\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = (*y << r) | (prev >> (w - r));\n                prev = *y;\n            }\n            *ans.a.last_mut().unwrap() |= prev >> (w - r);\n        }\n        ans.fix();\n        ans\n    }\n    fn bitwise_or(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size >= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a |= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_and(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size <= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a &= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_or_assign(&mut self, rhs: &Self) {\n        if self.size < rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a |= *b;\n        }\n    }\n    fn bitwise_and_assign(&mut self, rhs: &Self) {\n        if self.size > rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a &= *b;\n        }\n    }\n}\n\nuse std::io::Read;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let mut dp_l = vec![BitSet::new(n); n];\n    let mut dp_r = vec![BitSet::new(n); n];\n    let mut win = vec![BitSet::new(n); n];\n    for i in 1..n {\n        let s: Vec<char> = it.next().unwrap().chars().collect();\n        for j in 0..i {\n            if s[j] == '1' {\n                win[i].set_at(j);\n            } else {\n                win[j].set_at(i);\n            }\n        }\n    }\n    for i in 0..n {\n        dp_l[i].set_at(i);\n        dp_r[i].set_at(i);\n    }\n    for len in 2..(n + 1) {\n        for l in 0..(n + 1 - len) {\n            let r = l + len - 1;\n            if win[l].bitwise_and(&dp_r[l + 1]).bitwise_and(&dp_l[r]).any() {\n                dp_l[r].set_at(l);\n            }\n            if win[r].bitwise_and(&dp_r[l]).bitwise_and(&dp_l[r - 1]).any() {\n                dp_r[l].set_at(r);\n            }\n        }\n    }\n    let mut ans = 0;\n    let valid = dp_l[n - 1].bitwise_and(&dp_r[0]);\n    for i in 0..n {\n        if valid.get_at(i) {\n            ans += 1;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    a: Vec<usize>,\n}\n\nfn bit_size() -> usize {\n    8 * std::mem::size_of::<usize>()\n}\n\nfn quot_rem(n: usize) -> (usize, usize) {\n    let w = bit_size();\n    (n / w, n % w)\n}\n\n#[allow(dead_code)]\nimpl BitSet {\n    fn new(size: usize) -> Self {\n        let w = bit_size();\n        BitSet {\n            size: size,\n            a: vec![0; (size + w - 1) / w],\n        }\n    }\n    fn set_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] |= 1 << r;\n    }\n    fn clear_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] &= !(1 << r);\n    }\n    fn get_at(&self, x: usize) -> bool {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        (self.a[q] >> r) & 1 == 1\n    }\n    fn any(&self) -> bool {\n        for a in self.a.iter() {\n            if *a != 0 {\n                return true;\n            }\n        }\n        false\n    }\n    fn fix(&mut self) {\n        let (q, r) = quot_rem(self.size);\n        if r != 0 {\n            self.a[q] &= (1 << r) - 1;\n        }\n    }\n    fn clear(&mut self) {\n        let len = self.a.len();\n        self.a.clear();\n        self.a.resize(len, 0);\n    }\n    fn truncate(&mut self, len: usize) {\n        if len >= self.size {\n            return;\n        }\n        let w = bit_size();\n        self.a.truncate((len + w - 1) / w);\n        self.size = len;\n        self.fix();\n    }\n    fn shift_left(&self, rhs: usize) -> Self {\n        let (q, r) = quot_rem(rhs);\n        let mut ans = BitSet::new(self.size + rhs);\n        if r == 0 {\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = *y;\n            }\n        } else {\n            let w = bit_size();\n            let mut prev = 0;\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = (*y << r) | (prev >> (w - r));\n                prev = *y;\n            }\n            *ans.a.last_mut().unwrap() |= prev >> (w - r);\n        }\n        ans.fix();\n        ans\n    }\n    fn bitwise_or(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size >= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a |= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_and(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size <= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a &= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_or_assign(&mut self, rhs: &Self) {\n        if self.size < rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a |= *b;\n        }\n    }\n    fn bitwise_and_assign(&mut self, rhs: &Self) {\n        if self.size > rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a &= *b;\n        }\n    }\n}\n\nuse std::io::Read;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let mut dp = vec![BitSet::new(n); n];\n    let mut win = vec![BitSet::new(n); n];\n    for i in 1..n {\n        let s: Vec<char> = it.next().unwrap().chars().collect();\n        for j in 0..i {\n            if s[j] == '1' {\n                win[i].set_at(j);\n            } else {\n                win[j].set_at(i);\n            }\n        }\n    }\n    for i in 0..n {\n        dp[i].set_at(i);\n    }\n    for len in 2..(n + 1) {\n        for l in 0..(n + 1 - len) {\n            let r = l + len - 1;\n            if win[l].bitwise_and(&dp[l + 1]).bitwise_and(&dp[r]).any() {\n                dp[r].set_at(l);\n            }\n            if win[r].bitwise_and(&dp[l]).bitwise_and(&dp[r - 1]).any() {\n                dp[l].set_at(r);\n            }\n        }\n    }\n    let mut ans = 0;\n    let valid = dp[n - 1].bitwise_and(&dp[0]);\n    for i in 0..n {\n        if valid.get_at(i) {\n            ans += 1;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    a: Vec<usize>,\n}\n\nfn bit_size() -> usize {\n    8 * std::mem::size_of::<usize>()\n}\n\nfn quot_rem(n: usize) -> (usize, usize) {\n    let w = bit_size();\n    (n / w, n % w)\n}\n\n#[allow(dead_code)]\nimpl BitSet {\n    fn new(size: usize) -> Self {\n        let w = bit_size();\n        BitSet {\n            size: size,\n            a: vec![0; (size + w - 1) / w],\n        }\n    }\n    fn set_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] |= 1 << r;\n    }\n    fn clear_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] &= !(1 << r);\n    }\n    fn get_at(&self, x: usize) -> bool {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        (self.a[q] >> r) & 1 == 1\n    }\n    fn any(&self) -> bool {\n        self.a.iter().any(|a| *a != 0)\n    }\n    fn fix(&mut self) {\n        let (q, r) = quot_rem(self.size);\n        if r != 0 {\n            self.a[q] &= (1 << r) - 1;\n        }\n    }\n    fn clear(&mut self) {\n        let len = self.a.len();\n        self.a.clear();\n        self.a.resize(len, 0);\n    }\n    fn truncate(&mut self, len: usize) {\n        if len >= self.size {\n            return;\n        }\n        let w = bit_size();\n        self.a.truncate((len + w - 1) / w);\n        self.size = len;\n        self.fix();\n    }\n    fn shift_left(&self, rhs: usize) -> Self {\n        let (q, r) = quot_rem(rhs);\n        let mut ans = BitSet::new(self.size + rhs);\n        if r == 0 {\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = *y;\n            }\n        } else {\n            let w = bit_size();\n            let mut prev = 0;\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = (*y << r) | (prev >> (w - r));\n                prev = *y;\n            }\n            *ans.a.last_mut().unwrap() |= prev >> (w - r);\n        }\n        ans.fix();\n        ans\n    }\n    fn bitwise_or(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size >= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a |= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_and(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size <= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a &= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_or_assign(&mut self, rhs: &Self) {\n        if self.size < rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a |= *b;\n        }\n    }\n    fn bitwise_and_assign(&mut self, rhs: &Self) {\n        if self.size > rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a &= *b;\n        }\n    }\n}\n\nuse std::io::Read;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let mut dp = vec![BitSet::new(n); n];\n    let mut win = vec![BitSet::new(n); n];\n    for i in 1..n {\n        let s: Vec<char> = it.next().unwrap().chars().collect();\n        for j in 0..i {\n            if s[j] == '1' {\n                win[i].set_at(j);\n            } else {\n                win[j].set_at(i);\n            }\n        }\n    }\n    for i in 0..n {\n        dp[i].set_at(i);\n    }\n    for len in 2..(n + 1) {\n        for l in 0..(n + 1 - len) {\n            let r = l + len - 1;\n            if win[l].a.iter().zip(dp[l + 1].a.iter()).zip(dp[r].a.iter()).any(|((a, b), c)| (*a & *b & *c) != 1) {\n                dp[r].set_at(l);\n            }\n            if win[r].a.iter().zip(dp[l].a.iter()).zip(dp[r - 1].a.iter()).any(|((a, b), c)| (*a & *b & *c) != 1) {\n                dp[l].set_at(r);\n            }\n        }\n    }\n    let mut ans = 0;\n    let valid = dp[n - 1].bitwise_and(&dp[0]);\n    for i in 0..n {\n        if valid.get_at(i) {\n            ans += 1;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// Try M-SOLUTIONS プロコンオープン\n// author: Leonardone @ NEETSDKASU\n\nfn main() {\n    let mut stdin = String::new();\n    std::io::Read::read_to_string(\n        &mut std::io::stdin(),\n        &mut stdin).unwrap();\n    let mut stdin = stdin.split_whitespace();\n    let mut get = || stdin.next().unwrap();\n    macro_rules! get {\n    \t($t:ty) => (get().parse::<$t>().unwrap());\n        () => (get!(i64));\n    }\n    let n = get!(usize);\n    let mut a = vec![vec![0; n]; n];\n    for j in 1..n {\n    \tlet s = get().as_bytes();\n        for i in 0..s.len() {\n        \tlet p = s[i] - b'0';\n        \ta[j][i] = p;\n            a[i][j] = 1 - p;\n        }\n\t}\n    let mut ans = 0;\n    for i in 0..n {\n    \tlet c = a[i]\n        \t.iter()\n            .filter(|p| **p == 1)\n            .count();\n\t\tif c * 2 > n {\n        \tans += 1;\n        }\n    }\n    println!(\"{}\", n - ans - 1);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n// Verified by https://atcoder.jp/contests/arc084/submissions/3935443\n#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    buf: Vec<usize>,\n}\n\nimpl BitSet {\n    // size should be a multiple of bit-size of usize.\n    fn new(size: usize) -> Self {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(size & (w - 1), 0);\n        let count = size / w;\n        BitSet {\n            size: size,\n            buf: vec![0; count],\n        }\n    }\n    #[allow(unused)]\n    fn set(&mut self, idx: usize, val: bool) {\n        debug_assert!(idx < self.size);\n        let w = 8 * std::mem::size_of::<usize>();\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        if val {\n            self.buf[idx0] |= 1 << idx1;\n        } else {\n            self.buf[idx0] &= !(1 << idx1);\n        }\n    }\n    #[allow(unused)]\n    fn get(&self, idx: usize) -> bool {\n        let w = 8 * std::mem::size_of::<usize>();\n        debug_assert!(idx < self.size);\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        (self.buf[idx0] >> idx1 & 1) == 1\n    }\n    #[allow(unused)]\n    fn shl(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i];\n            }\n        } else {\n            ans.buf[sh0] = self.buf[0] << sh1;\n            for i in 1 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i] << sh1\n                    | self.buf[i - 1] >> (w - sh1);\n            }\n        }\n        ans\n    }\n    // Not verified\n    #[allow(unused)]\n    fn shr(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i] = self.buf[i + sh0];\n            }\n        } else {\n            for i in 0 .. count - sh0 - 1 {\n                ans.buf[i] = self.buf[i + sh0] >> sh1\n                    | self.buf[i + sh0 + 1] << (w - sh1);\n            }\n            ans.buf[self.size - sh0 - 1] = self.buf[self.size - 1] >> sh1;\n        }\n        ans\n    }\n    #[allow(unused)]\n    fn msb(&self) -> Option<usize> {\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        for i in (0 .. count).rev() {\n            let v = self.buf[i];\n            if v != 0 {\n                return Some(w * i + w - 1 - v.leading_zeros() as usize);\n            }\n        }\n        None\n    }\n}\n\ntrait BitSetAdapter: Sized {\n    fn word_size(&self) -> usize;\n    fn at(&self, word_pos: usize) -> usize;\n    // short-circuit operations\n    fn any(&self) -> bool {\n        let sz = self.word_size();\n        for i in 0..sz {\n            if self.at(i) != 0 {\n                return true;\n            }\n        }\n        false\n    }\n    fn all(&self) -> bool {\n        let sz = self.word_size();\n        for i in 0..sz {\n            if self.at(i) != 1usize.wrapping_neg() {\n                return false;\n            }\n        }\n        true\n    }\n    fn and<U: BitSetAdapter>(self, other: U) -> AndAdapter<Self, U> {\n        AndAdapter {\n            t: self,\n            u: other,\n        }\n    }\n}\n\nstruct AndAdapter<T, U> {\n    t: T,\n    u: U,\n}\n\nimpl<T: BitSetAdapter, U: BitSetAdapter> BitSetAdapter for AndAdapter<T, U> {\n    fn word_size(&self) -> usize {\n        self.t.word_size()\n    }\n    fn at(&self, word_pos: usize) -> usize {\n        self.t.at(word_pos) & self.u.at(word_pos)\n    }\n}\n\n/*\nimpl BitSetAdapter for BitSet {\n    fn word_size(&self) -> usize {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(self.size & (w - 1), 0);\n        self.size / w\n    }\n    fn at(&self, word_pos: usize) -> usize {\n        self.buf[word_pos]\n    }\n}*/\n\nimpl<'a> BitSetAdapter for &'a BitSet {\n    fn word_size(&self) -> usize {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(self.size & (w - 1), 0);\n        self.size / w\n    }\n    fn at(&self, word_pos: usize) -> usize {\n        self.buf[word_pos]\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        aa: [chars; n - 1],\n    }\n    let mut a = vec![BitSet::new(2048); n];\n    let mut dp = vec![BitSet::new(2048); n];\n    for i in 1..n {\n        for j in 0..i {\n            a[i].set(j, aa[i - 1][j] == '1');\n            a[j].set(i, aa[i - 1][j] == '0');\n        }\n    }\n    for i in 0..n {\n        dp[i].set(i, true);\n    }\n    for s in 1..n {\n        for i in 0..n - s {\n            let j = i + s;\n            let res = dp[i].and(&dp[j - 1]).and(&a[j]).any();\n            dp[i].set(j, res);\n            let res = dp[i + 1].and(&dp[j]).and(&a[i]).any();\n            dp[j].set(i, res);\n        }\n    }\n    let ans = (0..n)\n        .filter(|&i|\n                dp[0].get(i) && dp[n - 1].get(i))\n        .count();\n    puts!(\"{}\\n\", ans);\n}\n\nfn main() {\n    solve();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef uint64_t u64;\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\nvoid set_at (u64 *a, i32 x) {\n  i32 q = x / 64;\n  i32 r = x % 64;\n  a[q] |= (u64)1 << r;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  u64 **win = ALLOC (n, u64 *);\n  u64 **dp = ALLOC (n, u64 *);\n  i32 len = (n + 63) / 64;\n  u64 *buf = ALLOC (2 * len * n, u64);\n  for (i32 i = 0; i < n; ++i) {\n    win[i] = buf;\n    buf += len;\n    dp[i] = buf;\n    buf += len;\n    set_at(dp[i], i);\n  }\n  char *s = ALLOC (n + 1, char);\n  for (i32 i = 1; i < n; ++i) {\n    scanf (\"%s\", s);\n    for (i32 j = 0; j < i; ++j) {\n      if (s[j] == '1') {\n        set_at(win[i], j);\n      } else {\n        set_at(win[j], i);\n      }\n    }\n  }\n  for (i32 len = 2; len <= n; ++len) {\n    for (i32 l = 0; l <= n - len; ++l) {\n      i32 r = l + len - 1;\n      i32 s = l / 64;\n      i32 t = r / 64 + 1;\n      for (i32 i = s; i < t; ++i) {\n        if (win[l][i] & dp[l + 1][i] & dp[r][i]) {\n          set_at(dp[r], l);\n          break;\n        }\n      }\n      for (i32 i = s; i < t; ++i) {\n        if (win[r][i] & dp[l][i] & dp[r - 1][i]) {\n          set_at(dp[l], r);\n          break;\n        }\n      }\n    }\n  }\n  i32 ans = 0;\n  for (i32 i = 0; i < n; ++i) {\n    i32 q = i / 64;\n    i32 r = i % 64;\n    ans += (dp[n - 1][q] >> r) & (dp[0][q] >> r) & 1;\n  }\n  printf(\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n// Verified by https://atcoder.jp/contests/arc084/submissions/3935443\n#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    buf: Vec<usize>,\n}\n\nimpl BitSet {\n    // size should be a multiple of bit-size of usize.\n    fn new(size: usize) -> Self {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(size & (w - 1), 0);\n        let count = size / w;\n        BitSet {\n            size: size,\n            buf: vec![0; count],\n        }\n    }\n    #[allow(unused)]\n    fn set(&mut self, idx: usize, val: bool) {\n        debug_assert!(idx < self.size);\n        let w = 8 * std::mem::size_of::<usize>();\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        if val {\n            self.buf[idx0] |= 1 << idx1;\n        } else {\n            self.buf[idx0] &= !(1 << idx1);\n        }\n    }\n    #[allow(unused)]\n    fn get(&self, idx: usize) -> bool {\n        let w = 8 * std::mem::size_of::<usize>();\n        debug_assert!(idx < self.size);\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        (self.buf[idx0] >> idx1 & 1) == 1\n    }\n    #[allow(unused)]\n    fn shl(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i];\n            }\n        } else {\n            ans.buf[sh0] = self.buf[0] << sh1;\n            for i in 1 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i] << sh1\n                    | self.buf[i - 1] >> (w - sh1);\n            }\n        }\n        ans\n    }\n    // Not verified\n    #[allow(unused)]\n    fn shr(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i] = self.buf[i + sh0];\n            }\n        } else {\n            for i in 0 .. count - sh0 - 1 {\n                ans.buf[i] = self.buf[i + sh0] >> sh1\n                    | self.buf[i + sh0 + 1] << (w - sh1);\n            }\n            ans.buf[self.size - sh0 - 1] = self.buf[self.size - 1] >> sh1;\n        }\n        ans\n    }\n    #[allow(unused)]\n    fn msb(&self) -> Option<usize> {\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        for i in (0 .. count).rev() {\n            let v = self.buf[i];\n            if v != 0 {\n                return Some(w * i + w - 1 - v.leading_zeros() as usize);\n            }\n        }\n        None\n    }\n}\n\ntrait BitSetAdapter: Sized {\n    fn word_size(&self) -> usize;\n    fn at(&self, word_pos: usize) -> usize;\n    // short-circuit operations\n    fn any(&self) -> bool {\n        let sz = self.word_size();\n        for i in 0..sz {\n            if self.at(i) != 0 {\n                return true;\n            }\n        }\n        false\n    }\n    fn all(&self) -> bool {\n        let sz = self.word_size();\n        for i in 0..sz {\n            if self.at(i) != 1usize.wrapping_neg() {\n                return false;\n            }\n        }\n        true\n    }\n    fn and<U: BitSetAdapter>(self, other: U) -> AndAdapter<Self, U> {\n        AndAdapter {\n            t: self,\n            u: other,\n        }\n    }\n}\n\nstruct AndAdapter<T, U> {\n    t: T,\n    u: U,\n}\n\nimpl<T: BitSetAdapter, U: BitSetAdapter> BitSetAdapter for AndAdapter<T, U> {\n    fn word_size(&self) -> usize {\n        self.t.word_size()\n    }\n    fn at(&self, word_pos: usize) -> usize {\n        self.t.at(word_pos) & self.u.at(word_pos)\n    }\n}\n\n/*\nimpl BitSetAdapter for BitSet {\n    fn word_size(&self) -> usize {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(self.size & (w - 1), 0);\n        self.size / w\n    }\n    fn at(&self, word_pos: usize) -> usize {\n        self.buf[word_pos]\n    }\n}*/\n\nimpl<'a> BitSetAdapter for &'a BitSet {\n    fn word_size(&self) -> usize {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(self.size & (w - 1), 0);\n        self.size / w\n    }\n    fn at(&self, word_pos: usize) -> usize {\n        self.buf[word_pos]\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        aa: [chars; n - 1],\n    }\n    let mut a = vec![BitSet::new(2048); n];\n    for i in 1..n {\n        for j in 0..i {\n            a[i].set(j, aa[i - 1][j] == '1');\n            a[j].set(i, aa[i - 1][j] == '0');\n        }\n    }\n    drop(aa);\n    let mut dp = vec![BitSet::new(2048); n];\n    for i in 0..n {\n        dp[i].set(i, true);\n    }\n    for s in 1..n {\n        for i in 0..n - s {\n            let j = i + s;\n            let res = dp[i].and(&dp[j - 1]).and(&a[j]).any();\n            dp[i].set(j, res);\n            let res = dp[i + 1].and(&dp[j]).and(&a[i]).any();\n            dp[j].set(i, res);\n        }\n    }\n    let ans = (0..n)\n        .filter(|&i|\n                dp[0].get(i) && dp[n - 1].get(i))\n        .count();\n    puts!(\"{}\\n\", ans);\n}\n\nfn main() {\n    solve();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    a: Vec<usize>,\n}\n\nfn bit_size() -> usize {\n    8 * std::mem::size_of::<usize>()\n}\n\nfn quot_rem(n: usize) -> (usize, usize) {\n    let w = bit_size();\n    (n / w, n % w)\n}\n\n#[allow(dead_code)]\nimpl BitSet {\n    fn new(size: usize) -> Self {\n        let w = bit_size();\n        BitSet {\n            size: size,\n            a: vec![0; (size + w - 1) / w],\n        }\n    }\n    fn set_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] |= 1 << r;\n    }\n    fn clear_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] &= !(1 << r);\n    }\n    fn get_at(&self, x: usize) -> bool {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        (self.a[q] >> r) & 1 == 1\n    }\n    fn any(&self) -> bool {\n        self.a.iter().any(|a| *a != 0)\n    }\n    fn fix(&mut self) {\n        let (q, r) = quot_rem(self.size);\n        if r != 0 {\n            self.a[q] &= (1 << r) - 1;\n        }\n    }\n    fn clear(&mut self) {\n        let len = self.a.len();\n        self.a.clear();\n        self.a.resize(len, 0);\n    }\n    fn truncate(&mut self, len: usize) {\n        if len >= self.size {\n            return;\n        }\n        let w = bit_size();\n        self.a.truncate((len + w - 1) / w);\n        self.size = len;\n        self.fix();\n    }\n    fn shift_left(&self, rhs: usize) -> Self {\n        let (q, r) = quot_rem(rhs);\n        let mut ans = BitSet::new(self.size + rhs);\n        if r == 0 {\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = *y;\n            }\n        } else {\n            let w = bit_size();\n            let mut prev = 0;\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = (*y << r) | (prev >> (w - r));\n                prev = *y;\n            }\n            *ans.a.last_mut().unwrap() |= prev >> (w - r);\n        }\n        ans.fix();\n        ans\n    }\n    fn bitwise_or(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size >= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a |= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_and(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size <= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a &= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_or_assign(&mut self, rhs: &Self) {\n        if self.size < rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a |= *b;\n        }\n    }\n    fn bitwise_and_assign(&mut self, rhs: &Self) {\n        if self.size > rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a &= *b;\n        }\n    }\n}\n\nuse std::io::Read;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let mut dp = vec![BitSet::new(n); n];\n    let mut win = vec![BitSet::new(n); n];\n    for i in 1..n {\n        let s: Vec<char> = it.next().unwrap().chars().collect();\n        for j in 0..i {\n            if s[j] == '1' {\n                win[i].set_at(j);\n            } else {\n                win[j].set_at(i);\n            }\n        }\n    }\n    for i in 0..n {\n        dp[i].set_at(i);\n    }\n    for len in 2..(n + 1) {\n        for l in 0..(n + 1 - len) {\n            let r = l + len - 1;\n            if win[l].bitwise_and(&dp[l + 1]).bitwise_and(&dp[r]).any() {\n                dp[r].set_at(l);\n            }\n            if win[r].bitwise_and(&dp[l]).bitwise_and(&dp[r - 1]).any() {\n                dp[l].set_at(r);\n            }\n        }\n    }\n    let mut ans = 0;\n    let valid = dp[n - 1].bitwise_and(&dp[0]);\n    for i in 0..n {\n        if valid.get_at(i) {\n            ans += 1;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/m-solutions2019/tasks/m_solutions2019_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nuse std::ops::{Index,IndexMut};\nuse std::ops::{Shl,Shr,BitOrAssign};\n\n\n#[derive(Clone, Debug)]\nstruct BitVector {\n    n: usize,\n    size: usize,\n    data: Vec<u64>\n}\n\nimpl BitVector {\n    fn new(n: usize) -> Self {\n        let size = (n+63)/64;\n        BitVector {\n            n: n,\n            size: size,\n            data: vec![0; size]\n        }\n    }\n\n    fn get(&self, i: usize) -> bool {\n        self.data[i/64]>>(i%64) & 1 != 0\n    }\n\n    fn set(&mut self, i: usize) {\n        self.data[i/64] |= 1<<(i%64);\n    }\n}\n\nimpl<'a> Shl<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shl(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n\n        let diff = amount / 64;\n        let diff_mod = amount % 64;\n        if diff_mod == 0 {\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<(64-diff_mod))-1;\n            let upper_mask = ((1<<diff_mod)-1)<<(64-diff_mod);\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] |= (self.data[i] & lower_mask)<<diff_mod;\n                if i+diff+1 < self.size {\n                    new_vector.data[i+diff+1] |= (self.data[i] & upper_mask)>>(64-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\nimpl BitOrAssign for BitVector {\n    fn bitor_assign(&mut self, rhs: Self) {\n        for i in 0..self.size {\n            self.data[i] |= rhs.data[i];\n        }\n    }\n}\n\n// ====\n\nfn check(from: usize, to: usize, win_vector: &Vec<BitVector>, dp_left0: &Vec<BitVector>, dp_left_row: &Vec<BitVector>, dp_right: &Vec<BitVector>) -> bool {\n    let v = win_vector[0].data.len();\n    for i in 0..v {\n        if dp_left0[from].data[i] & win_vector[from].data[i] & dp_left_row[to].data[i] >= 1 {\n            // debug!(\"found-l\", from, to);\n            return true;\n        }\n        if dp_left0[from].data[i] & dp_right[to].data[i] >= 1 && win_vector[from].get(to) {\n            // debug!(\"found-r\", from, to);\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    input! {\n        n: usize,\n        a: [chars; n-1]\n    };\n\n    let mut table = dvec!(false; n, n);\n    for i in 0..n {\n        for j in 0..i {\n            table[i][j] = ifv!(a[i-1][j] == '0', false, true);\n            table[j][i] = table[i][j] ^ true;\n        }\n        table[i][i] = true;\n    }\n\n    let mut win_vector = vec![BitVector::new(n); n];\n    for i in 0..n {\n        for j in 0..n {\n            if table[i][j] {\n                win_vector[i].set(j);\n            }\n        }\n    }\n\n    let mut dp_left = vec![BitVector::new(n); n];\n    let mut dp_right = vec![BitVector::new(n); n];\n    let mut dp_left_row = vec![BitVector::new(n); n];\n    let mut dp_right_row = vec![BitVector::new(n); n];\n    let mut dp_left0 = vec![BitVector::new(n); n];\n    let mut dp_right0 = vec![BitVector::new(n); n];\n    for i in 0..n {\n        dp_left[i].set(i);\n        dp_right[i].set(i);\n        if i >= 1 {\n            dp_left0[i].set(i-1);\n        }\n        if i+1 < n {\n            dp_right0[i].set(i+1);\n        }\n        dp_left_row[i].set(i);\n        dp_right_row[i].set(i);\n    }\n\n    for d in 1..n {\n        for i in 0..n {\n            if i >= d {\n                if check(i, i-d, &win_vector, &dp_left0, &dp_left_row, &dp_right) {\n                    dp_left[i].set(i-d);\n                    if i-d >= 1 {\n                        dp_left0[i].set(i-d-1);\n                    }\n                    dp_left_row[i-d].set(i);\n                }\n            }\n            if i+d < n {\n                if check(i, i+d, &win_vector, &dp_right0, &dp_right_row, &dp_left) {\n                    dp_right[i].set(i+d);\n                    if i+d+1 < n {\n                        dp_right[i].set(i+d+1);\n                    }\n                    dp_right_row[i+d].set(i);\n                }\n            }\n        }\n    }\n\n    let mut count = 0;\n    // for i in 0..n {\n    //     for j in 0..n {\n    //         let b = if i < j {\n    //             dp_right[i].get(j)\n    //         } else {\n    //             dp_left[i].get(j)\n    //         };\n    //         debug!(i, j, b);\n    //     }\n    // }\n\n    for i in 0..n {\n        if dp_left[i].get(0) && dp_right[i].get(n-1) {\n            count += 1;\n        }\n    }\n    println!(\"{}\", count);\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/m-solutions2019/tasks/m_solutions2019_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nuse std::ops::{Index,IndexMut};\nuse std::ops::{Shl,Shr,BitOrAssign};\n\n\n#[derive(Clone, Debug)]\nstruct BitVector {\n    n: usize,\n    size: usize,\n    data: Vec<u64>\n}\n\nimpl BitVector {\n    fn new(n: usize) -> Self {\n        let size = (n+63)/64;\n        BitVector {\n            n: n,\n            size: size,\n            data: vec![0; size]\n        }\n    }\n\n    fn get(&self, i: usize) -> bool {\n        self.data[i/64]>>(i%64) & 1 != 0\n    }\n\n    fn set(&mut self, i: usize) {\n        self.data[i/64] |= 1<<(i%64);\n    }\n}\n\nimpl<'a> Shl<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shl(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n\n        let diff = amount / 64;\n        let diff_mod = amount % 64;\n        if diff_mod == 0 {\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<(64-diff_mod))-1;\n            let upper_mask = ((1<<diff_mod)-1)<<(64-diff_mod);\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] |= (self.data[i] & lower_mask)<<diff_mod;\n                if i+diff+1 < self.size {\n                    new_vector.data[i+diff+1] |= (self.data[i] & upper_mask)>>(64-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\nimpl BitOrAssign for BitVector {\n    fn bitor_assign(&mut self, rhs: Self) {\n        for i in 0..self.size {\n            self.data[i] |= rhs.data[i];\n        }\n    }\n}\n\n// ====\n\nfn check(from: usize, to: usize, win_vector: &Vec<BitVector>, dp_left: &Vec<BitVector>, dp_left0: &Vec<BitVector>, dp_left_row: &Vec<BitVector>, dp_right: &Vec<BitVector>) -> bool {\n    let v = win_vector[0].data.len();\n    for i in 0..v {\n        if dp_left0[from].data[i] & win_vector[from].data[i] & dp_left_row[to].data[i] >= 1 {\n            // debug!(\"found-l\", from, to);\n            return true;\n        }\n        if dp_left0[from].data[i] & dp_right[to].data[i] >= 1 && win_vector[from].get(to) {\n            // debug!(\"found-r\", from, to);\n            return true;\n        }\n        if dp_left[from].data[i] & dp_left_row[to].data[i] >= 1 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    input! {\n        n: usize,\n        a: [chars; n-1]\n    };\n\n    let mut table = dvec!(false; n, n);\n    for i in 0..n {\n        for j in 0..i {\n            table[i][j] = ifv!(a[i-1][j] == '0', false, true);\n            table[j][i] = table[i][j] ^ true;\n        }\n        table[i][i] = true;\n    }\n\n    let mut win_vector = vec![BitVector::new(n); n];\n    for i in 0..n {\n        for j in 0..n {\n            if table[i][j] {\n                win_vector[i].set(j);\n            }\n        }\n    }\n\n    let mut dp_left = vec![BitVector::new(n); n];\n    let mut dp_right = vec![BitVector::new(n); n];\n    let mut dp_left_row = vec![BitVector::new(n); n];\n    let mut dp_right_row = vec![BitVector::new(n); n];\n    let mut dp_left0 = vec![BitVector::new(n); n];\n    let mut dp_right0 = vec![BitVector::new(n); n];\n    for i in 0..n {\n        dp_left[i].set(i);\n        dp_right[i].set(i);\n        if i >= 1 {\n            dp_left0[i].set(i-1);\n        }\n        if i+1 < n {\n            dp_right0[i].set(i+1);\n        }\n        dp_left_row[i].set(i);\n        dp_right_row[i].set(i);\n    }\n\n    for d in 1..n {\n        for i in 0..n {\n            if i >= d {\n                if check(i, i-d, &win_vector, &dp_left, &dp_left0, &dp_left_row, &dp_right) {\n                    dp_left[i].set(i-d);\n                    if i-d >= 1 {\n                        dp_left0[i].set(i-d-1);\n                    }\n                    dp_left_row[i-d].set(i);\n                }\n            }\n            if i+d < n {\n                if check(i, i+d, &win_vector, &dp_right, &dp_right0, &dp_right_row, &dp_left) {\n                    dp_right[i].set(i+d);\n                    if i+d+1 < n {\n                        dp_right0[i].set(i+d+1);\n                    }\n                    dp_right_row[i+d].set(i);\n                }\n            }\n        }\n    }\n\n    let mut count = 0;\n    // for i in 0..n {\n    //     for j in 0..n {\n    //         let b = if i < j {\n    //             dp_right[i].get(j)\n    //         } else {\n    //             dp_left[i].get(j)\n    //         };\n    //         debug!(i, j, b);\n    //     }\n    // }\n\n    for i in 0..n {\n        if dp_left[i].get(0) && dp_right[i].get(n-1) {\n            count += 1;\n        }\n    }\n    println!(\"{}\", count);\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    a: Vec<usize>,\n}\n\nfn bit_size() -> usize {\n    8 * std::mem::size_of::<usize>()\n}\n\nfn quot_rem(n: usize) -> (usize, usize) {\n    let w = bit_size();\n    (n / w, n % w)\n}\n\n#[allow(dead_code)]\nimpl BitSet {\n    fn new(size: usize) -> Self {\n        let w = bit_size();\n        BitSet {\n            size: size,\n            a: vec![0; (size + w - 1) / w],\n        }\n    }\n    fn set_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] |= 1 << r;\n    }\n    fn clear_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] &= !(1 << r);\n    }\n    fn get_at(&self, x: usize) -> bool {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        (self.a[q] >> r) & 1 == 1\n    }\n    fn any(&self) -> bool {\n        self.a.iter().any(|a| *a != 0)\n    }\n    fn fix(&mut self) {\n        let (q, r) = quot_rem(self.size);\n        if r != 0 {\n            self.a[q] &= (1 << r) - 1;\n        }\n    }\n    fn clear(&mut self) {\n        let len = self.a.len();\n        self.a.clear();\n        self.a.resize(len, 0);\n    }\n    fn truncate(&mut self, len: usize) {\n        if len >= self.size {\n            return;\n        }\n        let w = bit_size();\n        self.a.truncate((len + w - 1) / w);\n        self.size = len;\n        self.fix();\n    }\n    fn shift_left(&self, rhs: usize) -> Self {\n        let (q, r) = quot_rem(rhs);\n        let mut ans = BitSet::new(self.size + rhs);\n        if r == 0 {\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = *y;\n            }\n        } else {\n            let w = bit_size();\n            let mut prev = 0;\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = (*y << r) | (prev >> (w - r));\n                prev = *y;\n            }\n            *ans.a.last_mut().unwrap() |= prev >> (w - r);\n        }\n        ans.fix();\n        ans\n    }\n    fn bitwise_or(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size >= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a |= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_and(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size <= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a &= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_or_assign(&mut self, rhs: &Self) {\n        if self.size < rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a |= *b;\n        }\n    }\n    fn bitwise_and_assign(&mut self, rhs: &Self) {\n        if self.size > rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a &= *b;\n        }\n    }\n}\n\nuse std::io::Read;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let mut dp = vec![BitSet::new(n); n];\n    let mut win = vec![BitSet::new(n); n];\n    for i in 1..n {\n        let s: Vec<char> = it.next().unwrap().chars().collect();\n        for j in 0..i {\n            if s[j] == '1' {\n                win[i].set_at(j);\n            } else {\n                win[j].set_at(i);\n            }\n        }\n    }\n    for i in 0..n {\n        dp[i].set_at(i);\n    }\n    for len in 2..(n + 1) {\n        for l in 0..(n + 1 - len) {\n            let r = l + len - 1;\n            let w = bit_size();\n            let s = l / w;\n            let t = r / w + 1;\n            if win[l].a[s..t].iter().zip(dp[l + 1].a[s..t].iter()).zip(dp[r].a[s..t].iter()).any(|((a, b), c)| (*a & *b & *c) != 0) {\n                dp[r].set_at(l);\n            }\n            if win[r].a[s..t].iter().zip(dp[l].a[s..t].iter()).zip(dp[r - 1].a[s..t].iter()).any(|((a, b), c)| (*a & *b & *c) != 0) {\n                dp[l].set_at(r);\n            }\n        }\n    }\n    let mut ans = 0;\n    let valid = dp[n - 1].bitwise_and(&dp[0]);\n    for i in 0..n {\n        if valid.get_at(i) {\n            ans += 1;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/m-solutions2019/tasks/m_solutions2019_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\n// ===\n\n\n#[derive(Clone, Debug)]\nstruct BitVector {\n    n: usize,\n    size: usize,\n    data: Vec<u64>\n}\n\nimpl BitVector {\n    fn new(n: usize) -> Self {\n        let size = (n+63)/64;\n        BitVector {\n            n: n,\n            size: size,\n            data: vec![0; size]\n        }\n    }\n\n    fn get(&self, i: usize) -> bool {\n        self.data[i/64]>>(i%64) & 1 != 0\n    }\n\n    fn set(&mut self, i: usize) {\n        self.data[i/64] |= 1<<(i%64);\n    }\n\n    fn count(&self) -> usize {\n        let mut cnt = 0;\n        for i in 0..self.size {\n            cnt += self.data[i].count_ones();\n        }\n        cnt as usize\n    }\n}\n\nimpl<'a> std::ops::Shl<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shl(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n\n        let diff = amount / 64;\n        let diff_mod = amount % 64;\n        if diff_mod == 0 {\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<(64-diff_mod))-1;\n            let upper_mask = ((1<<diff_mod)-1)<<(64-diff_mod);\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] |= (self.data[i] & lower_mask)<<diff_mod;\n                if i+diff+1 < self.size {\n                    new_vector.data[i+diff+1] |= (self.data[i] & upper_mask)>>(64-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\n\nimpl<'a> std::ops::Shr<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shr(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n\n        let diff = amount / 64;\n        let diff_mod = amount % 64;\n        if diff_mod == 0 {\n            for i in diff..self.size {\n                new_vector.data[i-diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<diff_mod)-1;\n            let upper_mask = ((1<<(64-diff_mod))-1)<<diff_mod;\n            for i in diff..self.size {\n                new_vector.data[i-diff] |= (self.data[i] & upper_mask)>>diff_mod;\n                if i > diff {\n                    new_vector.data[i-diff-1] |= (self.data[i] & lower_mask)<<(64-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\nimpl<'a> std::ops::BitAnd for &'a BitVector {\n    type Output = BitVector;\n\n    fn bitand(self, other: Self) -> Self::Output {\n        let mut output = BitVector::new(self.n);\n        for i in 0..self.size {\n            output.data[i] = self.data[i] & other.data[i];\n        }\n        output\n    }\n}\n\nimpl std::ops::BitAndAssign for BitVector {\n    fn bitand_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] &= rhs.data[i];\n        }\n    }\n}\n\nimpl<'a> std::ops::BitOr for &'a BitVector {\n    type Output = BitVector;\n\n    fn bitor(self, other: Self) -> Self::Output {\n        let mut output = BitVector::new(self.n);\n        for i in 0..self.size {\n            output.data[i] = self.data[i] | other.data[i];\n        }\n        output\n    }\n}\n\nimpl std::ops::BitOrAssign for BitVector {\n    fn bitor_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] |= rhs.data[i];\n        }\n    }\n}\n\nimpl std::ops::BitXorAssign for BitVector {\n    fn bitxor_assign(&mut self, rhs: Self) {\n        for i in 0..min(self.size, rhs.size) {\n            self.data[i] ^= rhs.data[i];\n        }\n    }\n}\n\n//===\n\nfn main() {\n    input! {\n        n: usize,\n        table: [chars; n-1]\n    };\n\n    // 1 to n, 0 and n+1 are sentinels\n    let mut wintable = vec![BitVector::new(2048); n+2];\n    for i in 2..n+1 {\n        for j in 1..i {\n            if table[i-2][j-1] == '1' {\n                // i wins j\n                wintable[i].set(j);\n            } else {\n                wintable[j].set(i);\n            }\n        }\n    }\n\n    let mut dp_left = vec![BitVector::new(2048); n+2];\n    let mut dp_right = vec![BitVector::new(2048); n+2];\n\n    let mut dp_left_rev = vec![BitVector::new(2048); n+2];\n    let mut dp_right_rev = vec![BitVector::new(2048); n+2];\n\n    for i in 1..n+1 {\n        dp_left[i].set(i);\n        dp_right[i].set(i);\n        dp_left_rev[i].set(i);\n        dp_right_rev[i].set(i);\n    }\n    for l in 1..n {\n        for i in 1..n+1 {\n            if i > l {\n                let lj = i-l;\n                let mut ok = false;\n                ok |= (&(&(&dp_left[i]>>1) & &dp_left_rev[lj]) & &wintable[i]).count() >= 1;\n                ok |= wintable[i].get(lj) && (&dp_left[i] & &(&dp_right[lj]<<1)).count() >= 1;\n                if ok {\n                    dp_left[i].set(lj);\n                    dp_left_rev[lj].set(i);\n                }\n                // debug!(i, lj, ok);\n            }\n            if i+l <= n {\n                let rj = i+l;\n                let mut ok1 = false;\n                let mut ok2 = false;\n                ok1 |= (&(&(&dp_right[i]<<1) & &dp_right_rev[rj]) & &wintable[i]).count() >= 1;\n                ok2 |= wintable[i].get(rj) && (&dp_right[i] & &(&dp_left[rj]>>1)).count() >= 1;\n                let ok = ok1 | ok2;\n                if ok {\n                    dp_right[i].set(rj);\n                    dp_right_rev[rj].set(i);\n                }\n                // debug!(i, rj, ok1, ok2);\n            }\n        }\n    }\n\n\n    let mut count = 0;\n    for i in 1..n+1 {\n        if dp_left[i].get(1) && dp_right[i].get(n) {\n            count += 1;\n            // debug!(i);\n        }\n    }\n    println!(\"{}\", count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    a: Vec<usize>,\n}\n\nfn bit_size() -> usize {\n    8 * std::mem::size_of::<usize>()\n}\n\nfn quot_rem(n: usize) -> (usize, usize) {\n    let w = bit_size();\n    (n / w, n % w)\n}\n\n#[allow(dead_code)]\nimpl BitSet {\n    fn new(size: usize) -> Self {\n        let w = bit_size();\n        BitSet {\n            size: size,\n            a: vec![0; (size + w - 1) / w],\n        }\n    }\n    fn set_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] |= 1 << r;\n    }\n    fn clear_at(&mut self, x: usize) {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        self.a[q] &= !(1 << r);\n    }\n    fn get_at(&self, x: usize) -> bool {\n        assert!(x < self.size);\n        let (q, r) = quot_rem(x);\n        (self.a[q] >> r) & 1 == 1\n    }\n    fn any(&self) -> bool {\n        self.a.iter().any(|a| *a != 0)\n    }\n    fn fix(&mut self) {\n        let (q, r) = quot_rem(self.size);\n        if r != 0 {\n            self.a[q] &= (1 << r) - 1;\n        }\n    }\n    fn clear(&mut self) {\n        let len = self.a.len();\n        self.a.clear();\n        self.a.resize(len, 0);\n    }\n    fn truncate(&mut self, len: usize) {\n        if len >= self.size {\n            return;\n        }\n        let w = bit_size();\n        self.a.truncate((len + w - 1) / w);\n        self.size = len;\n        self.fix();\n    }\n    fn shift_left(&self, rhs: usize) -> Self {\n        let (q, r) = quot_rem(rhs);\n        let mut ans = BitSet::new(self.size + rhs);\n        if r == 0 {\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = *y;\n            }\n        } else {\n            let w = bit_size();\n            let mut prev = 0;\n            for (x, y) in ans.a[q..].iter_mut().zip(self.a.iter()) {\n                *x = (*y << r) | (prev >> (w - r));\n                prev = *y;\n            }\n            *ans.a.last_mut().unwrap() |= prev >> (w - r);\n        }\n        ans.fix();\n        ans\n    }\n    fn bitwise_or(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size >= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a |= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_and(&self, rhs: &Self) -> Self {\n        let (x, y) = if self.size <= rhs.size {(self, rhs)} else {(rhs, self)};\n        let mut a = x.a.clone();\n        for (a, y) in a.iter_mut().zip(y.a.iter()) {\n            *a &= *y;\n        }\n        BitSet {\n            size: x.size,\n            a: a,\n        }\n    }\n    fn bitwise_or_assign(&mut self, rhs: &Self) {\n        if self.size < rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a |= *b;\n        }\n    }\n    fn bitwise_and_assign(&mut self, rhs: &Self) {\n        if self.size > rhs.size {\n            self.size = rhs.size;\n            self.a.resize(rhs.a.len(), 0);\n        }\n        for (a, b) in self.a.iter_mut().zip(rhs.a.iter()) {\n            *a &= *b;\n        }\n    }\n}\n\nuse std::io::Read;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let mut dp = vec![BitSet::new(n); n];\n    let mut win = vec![BitSet::new(n); n];\n    for i in 1..n {\n        let s: Vec<char> = it.next().unwrap().chars().collect();\n        for j in 0..i {\n            if s[j] == '1' {\n                win[i].set_at(j);\n            } else {\n                win[j].set_at(i);\n            }\n        }\n    }\n    for i in 0..n {\n        dp[i].set_at(i);\n    }\n    for len in 2..(n + 1) {\n        for l in 0..(n + 1 - len) {\n            let r = l + len - 1;\n            if win[l].a.iter().zip(dp[l + 1].a.iter()).zip(dp[r].a.iter()).any(|((a, b), c)| (*a & *b & *c) != 0) {\n                dp[r].set_at(l);\n            }\n            if win[r].a.iter().zip(dp[l].a.iter()).zip(dp[r - 1].a.iter()).any(|((a, b), c)| (*a & *b & *c) != 0) {\n                dp[l].set_at(r);\n            }\n        }\n    }\n    let mut ans = 0;\n    let valid = dp[n - 1].bitwise_and(&dp[0]);\n    for i in 0..n {\n        if valid.get_at(i) {\n            ans += 1;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/m-solutions2019/tasks/m_solutions2019_f\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nuse std::ops::{Index,IndexMut};\nuse std::ops::{Shl,Shr,BitOrAssign};\n\n\n#[derive(Clone, Debug)]\nstruct BitVector {\n    n: usize,\n    size: usize,\n    data: Vec<u64>\n}\n\nimpl BitVector {\n    fn new(n: usize) -> Self {\n        let size = (n+63)/64;\n        BitVector {\n            n: n,\n            size: size,\n            data: vec![0; size]\n        }\n    }\n\n    fn get(&self, i: usize) -> bool {\n        self.data[i/64]>>(i%64) & 1 != 0\n    }\n\n    fn set(&mut self, i: usize) {\n        self.data[i/64] |= 1<<(i%64);\n    }\n}\n\nimpl<'a> Shl<usize> for &'a BitVector {\n    type Output = BitVector;\n\n    fn shl(self, amount: usize) -> Self::Output {\n        let mut new_vector = BitVector::new(self.n);\n\n        let diff = amount / 64;\n        let diff_mod = amount % 64;\n        if diff_mod == 0 {\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] = self.data[i];\n            }\n        } else {\n            let lower_mask = (1<<(64-diff_mod))-1;\n            let upper_mask = ((1<<diff_mod)-1)<<(64-diff_mod);\n            for i in 0..self.size-diff {\n                new_vector.data[i+diff] |= (self.data[i] & lower_mask)<<diff_mod;\n                if i+diff+1 < self.size {\n                    new_vector.data[i+diff+1] |= (self.data[i] & upper_mask)>>(64-diff_mod);\n                }\n            }\n        }\n        new_vector\n    }\n}\n\nimpl BitOrAssign for BitVector {\n    fn bitor_assign(&mut self, rhs: Self) {\n        for i in 0..self.size {\n            self.data[i] |= rhs.data[i];\n        }\n    }\n}\n\n// ====\n\nfn check(from: usize, to: usize, win_vector: &Vec<BitVector>, dp_left_row: &Vec<BitVector>, dp_right_row: &Vec<BitVector>) -> bool {\n    let v = win_vector[0].data.len();\n    let next = ifv!(from < to, from+1, from-1);\n    for i in 0..v {\n        if dp_left_row[next].data[i] & win_vector[from].data[i] & dp_right_row[to].data[i] >= 1 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    input! {\n        n: usize,\n        a: [chars; n-1]\n    };\n\n    let mut table = dvec!(false; n, n);\n    for i in 0..n {\n        for j in 0..i {\n            table[i][j] = ifv!(a[i-1][j] == '0', false, true);\n            table[j][i] = table[i][j] ^ true;\n        }\n        table[i][i] = true;\n    }\n\n    let mut win_vector = vec![BitVector::new(n); n];\n    for i in 0..n {\n        for j in 0..n {\n            if table[i][j] {\n                win_vector[i].set(j);\n            }\n        }\n    }\n\n    let mut dp_left = vec![BitVector::new(n); n];\n    let mut dp_right = vec![BitVector::new(n); n];\n    let mut dp_left_row = vec![BitVector::new(n); n];\n    let mut dp_right_row = vec![BitVector::new(n); n];\n    for i in 0..n {\n        dp_left[i].set(i);\n        dp_right[i].set(i);\n        dp_left_row[i].set(i);\n        dp_right_row[i].set(i);\n    }\n\n    for d in 1..n {\n        for i in 0..n {\n            if i >= d {\n                if check(i, i-d, &win_vector, &dp_right_row, &dp_left_row) {\n                    dp_left[i].set(i-d);\n                    dp_left_row[i-d].set(i);\n                }\n            }\n            if i+d < n {\n                if check(i, i+d, &win_vector, &dp_left_row, &dp_right_row) {\n                    dp_right[i].set(i+d);\n                    dp_right_row[i+d].set(i);\n                }\n            }\n        }\n    }\n\n    let mut count = 0;\n    // for i in 0..n {\n    //     for j in 0..n {\n    //         let b = if i < j {\n    //             dp_right[i].get(j)\n    //         } else {\n    //             dp_left[i].get(j)\n    //         };\n    //         debug!(i, j, b);\n    //     }\n    // }\n\n    for i in 0..n {\n        if dp_left[i].get(0) && dp_right[i].get(n-1) {\n            count += 1;\n        }\n    }\n    println!(\"{}\", count);\n\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n// Verified by https://atcoder.jp/contests/arc084/submissions/3935443\n#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    buf: Vec<usize>,\n}\n\nimpl BitSet {\n    // size should be a multiple of bit-size of usize.\n    fn new(size: usize) -> Self {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(size & (w - 1), 0);\n        let count = size / w;\n        BitSet {\n            size: size,\n            buf: vec![0; count],\n        }\n    }\n    #[allow(unused)]\n    fn set(&mut self, idx: usize, val: bool) {\n        debug_assert!(idx < self.size);\n        let w = 8 * std::mem::size_of::<usize>();\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        if val {\n            self.buf[idx0] |= 1 << idx1;\n        } else {\n            self.buf[idx0] &= !(1 << idx1);\n        }\n    }\n    #[allow(unused)]\n    fn get(&self, idx: usize) -> bool {\n        let w = 8 * std::mem::size_of::<usize>();\n        debug_assert!(idx < self.size);\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        (self.buf[idx0] >> idx1 & 1) == 1\n    }\n    #[allow(unused)]\n    fn shl(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i];\n            }\n        } else {\n            ans.buf[sh0] = self.buf[0] << sh1;\n            for i in 1 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i] << sh1\n                    | self.buf[i - 1] >> (w - sh1);\n            }\n        }\n        ans\n    }\n    // Not verified\n    #[allow(unused)]\n    fn shr(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i] = self.buf[i + sh0];\n            }\n        } else {\n            for i in 0 .. count - sh0 - 1 {\n                ans.buf[i] = self.buf[i + sh0] >> sh1\n                    | self.buf[i + sh0 + 1] << (w - sh1);\n            }\n            ans.buf[self.size - sh0 - 1] = self.buf[self.size - 1] >> sh1;\n        }\n        ans\n    }\n    #[allow(unused)]\n    fn msb(&self) -> Option<usize> {\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        for i in (0 .. count).rev() {\n            let v = self.buf[i];\n            if v != 0 {\n                return Some(w * i + w - 1 - v.leading_zeros() as usize);\n            }\n        }\n        None\n    }\n}\n\ntrait BitSetAdapter: Sized {\n    fn word_size(&self) -> usize;\n    fn at(&self, word_pos: usize) -> usize;\n    // short-circuit operations\n    fn any(&self) -> bool {\n        let sz = self.word_size();\n        for i in 0..sz {\n            if self.at(i) != 0 {\n                return true;\n            }\n        }\n        false\n    }\n    fn all(&self) -> bool {\n        let sz = self.word_size();\n        for i in 0..sz {\n            if self.at(i) != 1usize.wrapping_neg() {\n                return false;\n            }\n        }\n        true\n    }\n    fn and<U: BitSetAdapter>(self, other: U) -> AndAdapter<Self, U> {\n        AndAdapter {\n            t: self,\n            u: other,\n        }\n    }\n}\n\nstruct AndAdapter<T, U> {\n    t: T,\n    u: U,\n}\n\nimpl<T: BitSetAdapter, U: BitSetAdapter> BitSetAdapter for AndAdapter<T, U> {\n    fn word_size(&self) -> usize {\n        self.t.word_size()\n    }\n    fn at(&self, word_pos: usize) -> usize {\n        self.t.at(word_pos) & self.u.at(word_pos)\n    }\n}\n\n/*\nimpl BitSetAdapter for BitSet {\n    fn word_size(&self) -> usize {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(self.size & (w - 1), 0);\n        self.size / w\n    }\n    fn at(&self, word_pos: usize) -> usize {\n        self.buf[word_pos]\n    }\n}*/\n\nimpl<'a> BitSetAdapter for &'a BitSet {\n    fn word_size(&self) -> usize {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(self.size & (w - 1), 0);\n        self.size / w\n    }\n    fn at(&self, word_pos: usize) -> usize {\n        self.buf[word_pos]\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        aa: [chars; n - 1],\n    }\n    let mut a = vec![BitSet::new(2048); n];\n    let mut dp = vec![BitSet::new(2048); n];\n    for i in 1..n {\n        for j in 0..i {\n            a[i].set(j, aa[i - 1][j] == '1');\n            a[j].set(i, aa[i - 1][j] == '0');\n        }\n    }\n    for i in 0..n {\n        dp[i].set(i, true);\n    }\n    for s in 1..n {\n        for i in 0..n - s {\n            let j = i + s;\n            let res = dp[i].and(&dp[j - 1]).and(&a[j]).any();\n            dp[i].set(j, res);\n            let res = dp[i + 1].and(&dp[j]).and(&a[i]).any();\n            dp[j].set(i, res);\n        }\n    }\n    let ans = (0..n)\n        .filter(|&i|\n                dp[0].get(i) && dp[n - 1].get(i))\n        .count();\n    puts!(\"{}\\n\", ans);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]