[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nint main() {\n    int S1, P1, C1, S2, P2, C2;\n    scanf(\"%d %d %d %d %d %d\", &S1, &P1, &C1, &S2, &P2, &C2);\n\n    int result = INT_MAX;\n    \n    // Check Smile category\n    if (S1 > S2) {\n        int needed = S2 + 1 - S1;\n        result = (needed > 0) ? needed : 0;\n    }\n    \n    // Check Pure category\n    if (P1 > P2) {\n        int needed = P2 + 1 - P1;\n        result = (needed > 0 && needed < result) ? needed : result;\n    }\n    \n    // Check Cool category\n    if (C1 > C2) {\n        int needed = C2 + 1 - C1;\n        result = (needed > 0 && needed < result) ? needed : result;\n    }\n    \n    // If not possible, output -1\n    printf(\"%d\\n\", (result == INT_MAX) ? -1 : result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int smile;\n    int pure;\n    int cool;\n    int total;\n} Unit;\n\nint compare(const void *a, const void *b) {\n    Unit *unitA = (Unit *)a;\n    Unit *unitB = (Unit *)b;\n    return unitB->total - unitA->total;\n}\n\nint main() {\n    Unit units[9];\n    for (int i = 0; i < 9; i++) {\n        scanf(\"%d %d %d\", &units[i].smile, &units[i].pure, &units[i].cool);\n        units[i].total = units[i].smile + units[i].pure + units[i].cool;\n    }\n\n    Unit original = units[8];\n    int min_increase = 0;\n\n    while (1) {\n        units[8].total = original.total + min_increase;\n        qsort(units, 9, sizeof(Unit), compare);\n\n        int rank = 1;\n        for (int i = 0; i < 9; i++) {\n            if (i > 0 && units[i].total < units[i-1].total) {\n                rank = i + 1;\n            }\n            if (units[i].smile == original.smile && \n                units[i].pure == original.pure && \n                units[i].cool == original.cool + min_increase) {\n                if (rank <= 8) {\n                    printf(\"%d\\n\", min_increase);\n                    return 0;\n                }\n                break;\n            }\n        }\n\n        min_increase++;\n        for (int i = 0; i < 9; i++) {\n            units[i].total = units[i].smile + units[i].pure + units[i].cool;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Unit {\n    int smile, pure, cool, total;\n    int rank;\n};\n\nint main() {\n    vector<Unit> units(9);\n    for (int i = 0; i < 9; ++i) {\n        cin >> units[i].smile >> units[i].pure >> units[i].cool;\n        units[i].total = units[i].smile + units[i].pure + units[i].cool;\n    }\n\n    // Assign ranks\n    vector<pair<int, int>> totals;\n    for (int i = 0; i < 9; ++i) {\n        totals.emplace_back(units[i].total, i);\n    }\n    sort(totals.rbegin(), totals.rend());\n\n    int current_rank = 1;\n    for (int i = 0; i < 9; ++i) {\n        if (i > 0 && totals[i].first != totals[i-1].first) {\n            current_rank = i + 1;\n        }\n        units[totals[i].second].rank = current_rank;\n    }\n\n    Unit& dosanko = units[0];\n    if (dosanko.rank <= 8) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int min_increase = INT_MAX;\n    // Try increasing smile\n    {\n        int new_total = dosanko.total + 1;\n        int new_rank = 1;\n        for (int i = 0; i < 9; ++i) {\n            if (units[i].total > new_total) {\n                new_rank++;\n            }\n        }\n        if (new_rank <= 8) {\n            min_increase = min(min_increase, 1);\n        }\n    }\n    // Try increasing pure\n    {\n        int new_total = dosanko.total + 1;\n        int new_rank = 1;\n        for (int i = 0; i < 9; ++i) {\n            if (units[i].total > new_total) {\n                new_rank++;\n            }\n        }\n        if (new_rank <= 8) {\n            min_increase = min(min_increase, 1);\n        }\n    }\n    // Try increasing cool\n    {\n        int new_total = dosanko.total + 1;\n        int new_rank = 1;\n        for (int i = 0; i < 9; ++i) {\n            if (units[i].total > new_total) {\n                new_rank++;\n            }\n        }\n        if (new_rank <= 8) {\n            min_increase = min(min_increase, 1);\n        }\n    }\n\n    if (min_increase != INT_MAX) {\n        cout << min_increase << endl;\n    } else {\n        // Need to find the minimal increase to surpass the 8th rank's total\n        int eighth_total = totals[7].first;\n        int required_increase = eighth_total - dosanko.total + 1;\n        cout << required_increase << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:00:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] smile = new int[N];\n        int[] pure = new int[N];\n        int[] cool = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            smile[i] = scanner.nextInt();\n            pure[i] = scanner.nextInt();\n            cool[i] = scanner.nextInt();\n        }\n        \n        int[] total = new int[N];\n        for (int i = 0; i < N; i++) {\n            total[i] = smile[i] + pure[i] + cool[i];\n        }\n        \n        int initialTotal = total[0];\n        int currentRank = 1;\n        for (int i = 1; i < N; i++) {\n            if (total[i] > initialTotal) {\n                currentRank++;\n            }\n        }\n        \n        if (currentRank <= 8) {\n            System.out.println(0);\n            return;\n        }\n        \n        int minIncrease = Integer.MAX_VALUE;\n        for (int i = 0; i < N; i++) {\n            if (i == 0) continue;\n            int needed = initialTotal - total[i] + 1;\n            if (needed > 0 && needed < minIncrease) {\n                minIncrease = needed;\n            }\n        }\n        \n        if (minIncrease == Integer.MAX_VALUE) {\n            System.out.println(-1);\n        } else {\n            System.out.println(minIncrease);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:01:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DanceNow {\n    public static void solve(int[] points) {\n        Arrays.sort(points);\n        \n        int lowestRank = points[7];\n        int minIncrease = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < 3; i++) {\n            int increase = lowestRank + 1 - points[i];\n            if (increase > 0) {\n                minIncrease = Math.min(minIncrease, increase);\n            }\n        }\n        \n        System.out.println(minIncrease == Integer.MAX_VALUE ? 0 : minIncrease);\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[] points = new int[3];\n        \n        for (int i = 0; i < 3; i++) {\n            points[i] = scanner.nextInt();\n        }\n        \n        solve(points);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:01:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<vector<int>> scores(N, vector<int>(3));\n    vector<int> dosankoScore(3);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> scores[i][0] >> scores[i][1] >> scores[i][2];\n        if (i == N - 1) {\n            dosankoScore = scores[i];\n        }\n    }\n    \n    int minIncrease = INT_MAX;\n    \n    for (int category = 0; category < 3; category++) {\n        int currentIncrease = 0;\n        int target = dosankoScore[category];\n        \n        while (true) {\n            int betterCount = 0;\n            for (int i = 0; i < N - 1; i++) {\n                if (scores[i][category] > target + currentIncrease) {\n                    betterCount++;\n                }\n            }\n            \n            if (betterCount < 8) {\n                break;\n            }\n            \n            currentIncrease++;\n        }\n        \n        minIncrease = min(minIncrease, currentIncrease);\n    }\n    \n    cout << (minIncrease == INT_MAX ? 0 : minIncrease) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_increase_to_avoid_ninth(scores, dosanko_snow):\n    total_scores = [sum(unit) for unit in scores]\n    dosanko_snow_total = sum(dosanko_snow)\n\n    # Sort total scores with the highest first, for rank determination\n    sorted_scores = sorted(total_scores, reverse=True)\n    \n    # Find the score at 8th place\n    target_score = sorted_scores[7]  # The score of the 8th ranked competitor\n\n    # Calculate the current rank of Dosanko Snow\n    rank = sorted_scores.index(dosanko_snow_total) + 1\n\n    # If Dosanko Snow is already ranked 8th or better, no increase needed\n    if rank <= 8:\n        return 0\n\n    # Calculate minimum increase needed to tie with 8th place\n    min_increase_needed = target_score + 1 - dosanko_snow_total\n    \n    # Ensure it's not negative if already better ranked\n    return max(min_increase_needed, 0)\n\n# Example usage:\nscores = [\n    [85, 90, 80],  # Competitor 1\n    [92, 85, 88],  # Competitor 2\n    [75, 95, 85],  # Competitor 3\n    [89, 87, 92],  # Competitor 4\n    [90, 83, 87],  # Competitor 5\n    [87, 88, 90],  # Competitor 6\n    [95, 92, 93],  # Competitor 7\n    [88, 91, 85],  # Competitor 8\n    [85, 83, 80],  # Competitor 9\n    [84, 78, 77],  # Dosanko Snow (example current scores)\n]\n\ndosanko_snow = [84, 78, 77]\nprint(min_increase_to_avoid_ninth(scores, dosanko_snow))",
    "timestamp": "2025-08-13 08:27:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass Unit {\n    String name;\n    int smile, pure, cool, total;\n\n    Unit(String name, int smile, int pure, int cool) {\n        this.name = name;\n        this.smile = smile;\n        this.pure = pure;\n        this.cool = cool;\n        this.total = smile + pure + cool;\n    }\n}\n\npublic class DanceNow {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<Unit> units = new ArrayList<>();\n\n        for (int i = 0; i < 9; i++) {\n            String name = scanner.next();\n            int smile = scanner.nextInt();\n            int pure = scanner.nextInt();\n            int cool = scanner.nextInt();\n            units.add(new Unit(name, smile, pure, cool));\n        }\n\n        Unit target = null;\n        for (Unit unit : units) {\n            if (unit.name.equals(\"DosankoSnow\")) {\n                target = unit;\n                break;\n            }\n        }\n\n        units.remove(target);\n\n        units.sort(Comparator.comparingInt(u -> -u.total));\n\n        int minIncrease = Integer.MAX_VALUE;\n\n        Unit last = units.get(7);\n        int requiredTotal = last.total + 1;\n\n        if (target.total < requiredTotal) {\n            minIncrease = Math.min(minIncrease, Math.max(0, requiredTotal - target.total));\n        }\n\n        int bestRank = 8;\n        minIncrease = Math.min(minIncrease, findMinIncreaseForRank(units, target, bestRank, 'S'));\n        minIncrease = Math.min(minIncrease, findMinIncreaseForRank(units, target, bestRank, 'P'));\n        minIncrease = Math.min(minIncrease, findMinIncreaseForRank(units, target, bestRank, 'C'));\n\n        System.out.println(minIncrease);\n    }\n\n    static int findMinIncreaseForRank(List<Unit> units, Unit target, int rank, char category) {\n        List<Integer> categoryValues = new ArrayList<>();\n\n        for (Unit unit : units) {\n            categoryValues.add(selectCategoryValue(unit, category));\n        }\n\n        categoryValues.sort(Collections.reverseOrder());\n\n        int requiredValue = categoryValues.get(rank - 1) + 1;\n        int currentValue = selectCategoryValue(target, category);\n\n        return Math.max(0, requiredValue - currentValue);\n    }\n\n    static int selectCategoryValue(Unit unit, char category) {\n        switch (category) {\n            case 'S':\n                return unit.smile;\n            case 'P':\n                return unit.pure;\n            case 'C':\n                return unit.cool;\n            default:\n                return 0;\n        }\n    }\n}",
    "timestamp": "2025-08-13 08:28:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX_UNITS 50\n\ntypedef struct {\n    int smile;\n    int pure;\n    int cool;\n    int total;\n} Unit;\n\nvoid calculateTotal(Unit units[], int n) {\n    for (int i = 0; i < n; i++) {\n        units[i].total = units[i].smile + units[i].pure + units[i].cool;\n    }\n}\n\nint getMinimumIncreaseToAchieveRank(Unit units[], int n, int dosankoSmiles, int dosankoPure, int dosankoCool) {\n    int dosankoTotal = dosankoSmiles + dosankoPure + dosankoCool;\n    int rankThreshold = MAX_UNITS;  // This will store the score needed to be at least ranked 8th\n\n    // Find the rank threshold, which is the score of the unit ranked 8th\n    for (int i = 0; i < n; i++) {\n        if (units[i].total > dosankoTotal) {\n            rankThreshold--;\n        }\n    }\n    rankThreshold = n - rankThreshold;  // We now have the number of units having a score less than Dosanko Snow\n\n    // Find the minimum increase needed to be at least tied with the unit ranked 8th\n    int minIncrease = 0;\n    if (rankThreshold >= 8) {  // If already ranked 8th or better, no increase is needed\n        return minIncrease;\n    }\n\n    int requiredTotal = units[rankThreshold].total;  // The score of the unit ranked 8th\n    minIncrease = requiredTotal - dosankoTotal;\n    return minIncrease > 0 ? minIncrease : 0;\n}\n\nint main() {\n    Unit units[MAX_UNITS];\n    int n;  // Total number of competing units in the competition\n    int dosankoSmiles, dosankoPure, dosankoCool;\n\n    // Input number of units\n    scanf(\"%d\", &n);\n\n    // Input the scores of each unit\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &units[i].smile, &units[i].pure, &units[i].cool);\n    }\n\n    // Input 'Dosanko Snow' scores\n    scanf(\"%d %d %d\", &dosankoSmiles, &dosankoPure, &dosankoCool);\n\n    // Calculate total scores\n    calculateTotal(units, n);\n\n    // Find the minimum increase needed\n    int minIncrease = getMinimumIncreaseToAchieveRank(units, n, dosankoSmiles, dosankoPure, dosankoCool);\n\n    // Output the result\n    printf(\"%d\\n\", minIncrease);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 08:28:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_dance_now():\n    # Read input\n    participants = int(input())\n    smile_ranks = list(map(int, input().split()))\n    pure_ranks = list(map(int, input().split()))\n    cool_ranks = list(map(int, input().split()))\n    \n    # Find Dosanko Snow's current ranks\n    dosanko_smile_rank = smile_ranks[0]\n    dosanko_pure_rank = pure_ranks[0]\n    dosanko_cool_rank = cool_ranks[0]\n    \n    # Initialize minimum increase to a large value\n    min_increase = float('inf')\n    \n    # Check Smile category increase\n    smile_increase = 0\n    for rank in smile_ranks:\n        if rank < dosanko_smile_rank:\n            smile_increase = max(smile_increase, rank - dosanko_smile_rank + 1)\n    \n    # Check Pure category increase  \n    pure_increase = 0\n    for rank in pure_ranks:\n        if rank < dosanko_pure_rank:\n            pure_increase = max(pure_increase, rank - dosanko_pure_rank + 1)\n    \n    # Check Cool category increase\n    cool_increase = 0\n    for rank in cool_ranks:\n        if rank < dosanko_cool_rank:\n            cool_increase = max(cool_increase, rank - dosanko_cool_rank + 1)\n    \n    # Find minimum increase among categories\n    min_increase = min(max(0, smile_increase), \n                       max(0, pure_increase), \n                       max(0, cool_increase))\n    \n    # Print result\n    print(min_increase)\n\n# Run the solution\nsolve_dance_now()",
    "timestamp": "2025-08-13 08:28:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = 8\n    current_smile = int(data[0])\n    current_pure = int(data[1])\n    current_cool = int(data[2])\n    \n    # Read the 8 existing competitors' scores\n    competitors = []\n    index = 3\n    for _ in range(N):\n        s = int(data[index])\n        p = int(data[index+1])\n        c = int(data[index+2])\n        total = s + p + c\n        competitors.append(total)\n        index += 3\n    \n    current_total = current_smile + current_pure + current_cool\n    competitors_sorted = sorted(competitors, reverse=True)\n    \n    # Find the 8th place score\n    if len(competitors_sorted) >= 8:\n        eighth_score = competitors_sorted[7]\n    else:\n        eighth_score = 0\n    \n    if current_total > eighth_score:\n        print(0)\n        return\n    \n    needed = eighth_score - current_total + 1\n    print(max(0, needed))\n\nsolve()",
    "timestamp": "2025-08-13 08:28:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\nint main() {\n    vector<tuple<int, int, int, string>> participants = {\n        {200, 150, 250, \"Unit1\"},\n        {300, 200, 200, \"Unit2\"},\n        {250, 250, 200, \"Unit3\"},\n        {300, 250, 250, \"Unit4\"},\n        {150, 300, 150, \"Unit5\"},\n        {250, 200, 300, \"Unit6\"},\n        {200, 300, 200, \"Unit7\"},\n        {150, 200, 250, \"Unit8\"},\n        {220, 260, 220, \"Dosanko Snow\"}\n    };\n\n    int targetIndex = -1;\n    for (int i = 0; i < participants.size(); ++i) {\n        if (get<3>(participants[i]) == \"Dosanko Snow\") {\n            targetIndex = i;\n            break;\n        }\n    }\n\n    auto compare = [](const tuple<int, int, int, string>& a, const tuple<int, int, int, string>& b) {\n        return get<0>(a) + get<1>(a) + get<2>(a) > get<0>(b) + get<1>(b) + get<2>(b);\n    };\n\n    sort(participants.begin(), participants.end(), compare);\n\n    int currentRank = 0;\n    for (int i = 0; i < participants.size(); ++i) {\n        if (get<3>(participants[i]) == \"Dosanko Snow\") {\n            currentRank = i + 1;\n            break;\n        }\n    }\n\n    if (currentRank <= 8) {\n        cout << \"Dosanko Snow is already ranked at least 8th.\" << endl;\n        return 0;\n    }\n\n    int minIncrease = INT_MAX;\n    int currentSmile, currentPure, currentCool;\n    tie(currentSmile, currentPure, currentCool, ignore) = participants[targetIndex];\n\n    for (int i = 0; i <= 8; ++i) {\n        if (i == targetIndex) continue;\n\n        int theirScore = get<0>(participants[i]) + get<1>(participants[i]) + get<2>(participants[i]);\n        int requiredScore = theirScore + 1;\n        int currentScore = currentSmile + currentPure + currentCool;\n\n        int neededIncrease = requiredScore - currentScore;\n\n        if (neededIncrease > 0) {\n            int increaseSmile = max(0, neededIncrease - (currentPure + currentCool));\n            int increasePure = max(0, neededIncrease - (currentSmile + currentCool));\n            int increaseCool = max(0, neededIncrease - (currentSmile + currentPure));\n\n            minIncrease = min({minIncrease, increaseSmile, increasePure, increaseCool});\n        }\n    }\n\n    cout << \"Minimum increase needed: \" << (minIncrease > 0 ? minIncrease : 0) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:46:05"
  }
]