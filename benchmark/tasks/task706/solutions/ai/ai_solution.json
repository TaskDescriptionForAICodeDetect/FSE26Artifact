[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_POINTS 1000\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point p1, Point p2) {\n    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n}\n\ndouble circle_radius(Point points[], int n) {\n    double radius = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double center_x = (points[i].x + points[j].x) / 2.0;\n            double center_y = (points[i].y + points[j].y) / 2.0;\n            \n            double curr_radius = distance((Point){center_x, center_y}, points[i]);\n            \n            int all_inside = 1;\n            for (int k = 0; k < n; k++) {\n                if (distance((Point){center_x, center_y}, points[k]) > curr_radius) {\n                    all_inside = 0;\n                    break;\n                }\n            }\n            \n            if (all_inside && (radius == 0 || curr_radius < radius)) {\n                radius = curr_radius;\n            }\n        }\n    }\n    \n    return radius;\n}\n\nint main() {\n    int n;\n    Point points[MAX_POINTS];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    \n    printf(\"%.2f\\n\", circle_radius(points, n));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble min_enclosing_circle_radius(Point points[], int n) {\n    Point center = points[0];\n    double radius = 0.0;\n\n    for (int i = 1; i < n; i++) {\n        double dist = distance(center, points[i]);\n        if (dist > radius) {\n            radius = dist;\n        }\n    }\n\n    return radius;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point points[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n\n    double radius = min_enclosing_circle_radius(points, n);\n    printf(\"%.6f\\n\", radius);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nPoint getCenter(const Point& a, const Point& b) {\n    return Point{(a.x + b.x) / 2.0, (a.y + b.y) / 2.0};\n}\n\nPoint getCircumcenter(const Point& a, const Point& b, const Point& c) {\n    double A = b.x - a.x;\n    double B = b.y - a.y;\n    double C = c.x - a.x;\n    double D = c.y - a.y;\n    double E = A * (a.x + b.x) + B * (a.y + b.y);\n    double F = C * (a.x + c.x) + D * (a.y + c.y);\n    double G = 2.0 * (A * (c.y - b.y) - B * (c.x - b.x));\n    if (G == 0) {\n        return Point{0, 0};\n    }\n    double ox = (D * E - B * F) / G;\n    double oy = (A * F - C * E) / G;\n    return Point{ox, oy};\n}\n\ndouble minEnclosingCircle(vector<Point>& points) {\n    if (points.empty()) return 0;\n    Point center = points[0];\n    double radius = 0;\n    for (int i = 1; i < points.size(); ++i) {\n        if (distance(center, points[i]) > radius) {\n            center = points[i];\n            radius = 0;\n            for (int j = 0; j < i; ++j) {\n                if (distance(center, points[j]) > radius) {\n                    center = getCenter(points[i], points[j]);\n                    radius = distance(center, points[i]);\n                    for (int k = 0; k < j; ++k) {\n                        if (distance(center, points[k]) > radius) {\n                            center = getCircumcenter(points[i], points[j], points[k]);\n                            radius = distance(center, points[i]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return radius;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n    double result = minEnclosingCircle(points);\n    printf(\"%.10f\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinimumEnclosingCircle {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    private static double dist(Point a, Point b) {\n        return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n\n    private static Point getCircleCenter(double bx, double by, double cx, double cy) {\n        double B = bx * bx + by * by;\n        double C = cx * cx + cy * cy;\n        double D = bx * cy - by * cx;\n        return new Point((cy * B - by * C) / (2 * D), (bx * C - cx * B) / (2 * D));\n    }\n\n    private static Circle circleFrom3Points(Point A, Point B, Point C) {\n        Point I = getCircleCenter(B.x - A.x, B.y - A.y, C.x - A.x, C.y - A.y);\n        I.x += A.x;\n        I.y += A.y;\n        return new Circle(I, dist(I, A));\n    }\n\n    private static Circle circleFrom2Points(Point A, Point B) {\n        Point C = new Point((A.x + B.x) / 2.0, (A.y + B.y) / 2.0);\n        return new Circle(C, dist(A, B) / 2.0);\n    }\n\n    private static boolean isValidCircle(Circle c, List<Point> points) {\n        for (Point p : points) {\n            if (dist(c.center, p) > c.radius + 1e-6) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static Circle findMinEnclosingCircle(List<Point> points) {\n        if (points.isEmpty()) {\n            return null;\n        }\n        Collections.shuffle(points);\n        Circle c = null;\n        for (int i = 0; i < points.size(); i++) {\n            if (c == null || dist(c.center, points.get(i)) > c.radius + 1e-6) {\n                c = new Circle(points.get(i), 0);\n                for (int j = 0; j < i; j++) {\n                    if (dist(c.center, points.get(j)) > c.radius + 1e-6) {\n                        c = circleFrom2Points(points.get(i), points.get(j));\n                        for (int k = 0; k < j; k++) {\n                            if (dist(c.center, points.get(k)) > c.radius + 1e-6) {\n                                c = circleFrom3Points(points.get(i), points.get(j), points.get(k));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return c;\n    }\n\n    static class Circle {\n        Point center;\n        double radius;\n        Circle(Point center, double radius) {\n            this.center = center;\n            this.radius = radius;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        List<Point> points = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            points.add(new Point(x, y));\n        }\n        Circle minCircle = findMinEnclosingCircle(points);\n        System.out.printf(\"%.2f\\n\", minCircle.radius);\n    }\n}",
    "timestamp": "2025-08-05 22:39:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinimumCircle {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static double dist(Point p1, Point p2) {\n        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n    }\n\n    static Point circumcenter(Point p1, Point p2, Point p3) {\n        double d = 2 * (p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y));\n        double ux = ((p1.x * p1.x + p1.y * p1.y) * (p2.y - p3.y) + (p2.x * p2.x + p2.y * p2.y) * (p3.y - p1.y) + (p3.x * p3.x + p3.y * p3.y) * (p1.y - p2.y)) / d;\n        double uy = ((p1.x * p1.x + p1.y * p1.y) * (p3.x - p2.x) + (p2.x * p2.x + p2.y * p2.y) * (p1.x - p3.x) + (p3.x * p3.x + p3.y * p3.y) * (p2.x - p1.x)) / d;\n        return new Point(ux, uy);\n    }\n\n    static double minimumCircle(Point[] points) {\n        int n = points.length;\n        Random rand = new Random();\n        Point center = points[0];\n        double radius = 0;\n\n        for (int i = 1; i < n; i++) {\n            if (dist(center, points[i]) > radius) {\n                center = points[i];\n                radius = 0;\n                for (int j = 0; j < i; j++) {\n                    if (dist(center, points[j]) > radius) {\n                        center = midpoint(center, points[j]);\n                        radius = dist(center, points[j]);\n                        for (int k = 0; k < j; k++) {\n                            if (dist(center, points[k]) > radius) {\n                                center = circumcenter(center, points[j], points[k]);\n                                radius = dist(center, points[k]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return radius;\n    }\n\n    static Point midpoint(Point p1, Point p2) {\n        return new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);\n    }\n\n    public static void main(String[] args) {\n        Point[] points = {\n            new Point(0, 0),\n            new Point(1, 1),\n            new Point(-1, 1),\n            new Point(2, 2)\n        };\n        System.out.printf(\"Minimum circle radius: %.2f\\n\", minimumCircle(points));\n    }\n}",
    "timestamp": "2025-08-05 22:39:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nPoint circumcenter(const Point& a, const Point& b, const Point& c) {\n    double ax = a.x, ay = a.y;\n    double bx = b.x, by = b.y;\n    double cx = c.x, cy = c.y;\n    \n    double d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));\n    double ux = ((ax*ax + ay*ay) * (by - cy) + (bx*bx + by*by) * (cy - ay) + (cx*cx + cy*cy) * (ay - by)) / d;\n    double uy = ((ax*ax + ay*ay) * (cx - bx) + (bx*bx + by*by) * (ax - cx) + (cx*cx + cy*cy) * (bx - ax)) / d;\n    \n    return {ux, uy};\n}\n\ndouble circleRadius(const Point& center, const vector<Point>& points) {\n    double radius = 0;\n    for (const auto& p : points) {\n        radius = max(radius, dist(center, p));\n    }\n    return radius;\n}\n\ndouble welzl(vector<Point>& points, vector<Point> boundary) {\n    if (points.empty() || boundary.size() == 3) {\n        if (boundary.size() == 0) return 0;\n        if (boundary.size() == 1) return 0;\n        if (boundary.size() == 2) {\n            Point center = {\n                (boundary[0].x + boundary[1].x) / 2.0,\n                (boundary[0].y + boundary[1].y) / 2.0\n            };\n            return dist(center, boundary[0]);\n        }\n        if (boundary.size() == 3) {\n            Point center = circumcenter(boundary[0], boundary[1], boundary[2]);\n            return circleRadius(center, boundary);\n        }\n    }\n    \n    random_shuffle(points.begin(), points.end());\n    Point p = points.back();\n    points.pop_back();\n    \n    double radius = welzl(points, boundary);\n    \n    if (radius == 0 || dist(p, {0, 0}) > radius) {\n        boundary.push_back(p);\n        radius = welzl(points, boundary);\n    }\n    \n    points.push_back(p);\n    return radius;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Point> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n    \n    vector<Point> boundary;\n    double result = welzl(points, boundary);\n    \n    cout << fixed << setprecision(10) << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:39:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef minimum_enclosing_circle(points):\n    def dist(p1, p2):\n        return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n\n    def circle_from_two_points(p1, p2):\n        center = ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)\n        radius = dist(p1, center)\n        return center, radius\n\n    def circle_from_three_points(p1, p2, p3):\n        ax, ay = p1\n        bx, by = p2\n        cx, cy = p3\n        d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))\n        ux = ((ax**2 + ay**2) * (by - cy) + (bx**2 + by**2) * (cy - ay) + (cx**2 + cy**2) * (ay - by)) / d\n        uy = ((ax**2 + ay**2) * (cx - bx) + (bx**2 + by**2) * (ax - cx) + (cx**2 + cy**2) * (bx - ax)) / d\n        center = (ux, uy)\n        radius = dist(p1, center)\n        return center, radius\n\n    def is_point_in_circle(p, center, radius):\n        return dist(p, center) <= radius\n\n    def get_enclosing_circle(points):\n        points = list(points)\n        if not points:\n            return ((0, 0), 0)\n        elif len(points) == 1:\n            return (points[0], 0)\n        elif len(points) == 2:\n            return circle_from_two_points(points[0], points[1])\n\n        circle = circle_from_two_points(points[0], points[1])\n        for i in range(2, len(points)):\n            if not is_point_in_circle(points[i], circle[0], circle[1]):\n                circle = get_enclosing_circle_on(points[:i + 1], points[i])\n        return circle\n\n    def get_enclosing_circle_on(points, q):\n        circle = circle_from_two_points(points[0], q)\n        for i in range(1, len(points)):\n            if not is_point_in_circle(points[i], circle[0], circle[1]):\n                circle = circle_from_three_points(points[i], q, points[0])\n        return circle\n\n    circle = get_enclosing_circle(points)\n    return circle[1]\n\n# Example usage:\nN = 4\npoints = [(0, 0), (1, 0), (0, 1), (1, 1)]\nprint(minimum_enclosing_circle(points))",
    "timestamp": "2025-08-13 11:57:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MinEnclosingCircle {\n\n    static class Circle {\n        Point2D.Double center;\n        double radius;\n\n        Circle(Point2D.Double c, double r) {\n            this.center = c;\n            this.radius = r;\n        }\n\n        boolean contains(Point2D.Double point) {\n            return center.distance(point) <= radius;\n        }\n\n        boolean containsAll(List<Point2D.Double> points) {\n            for (Point2D.Double point : points) {\n                if (!contains(point)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    public static Circle findMinCircle(List<Point2D.Double> points) {\n        Collections.shuffle(points);\n        Circle c = null;\n        for (int i = 0; i < points.size(); i++) {\n            if (c == null || !c.contains(points.get(i))) {\n                c = makeCircleOnePoint(points.subList(0, i + 1), points.get(i));\n            }\n        }\n        return c;\n    }\n\n    private static Circle makeCircleOnePoint(List<Point2D.Double> points, Point2D.Double q) {\n        Circle c = new Circle(q, 0);\n        for (int i = 0; i < points.size(); i++) {\n            Point2D.Double p = points.get(i);\n            if (!c.contains(p)) {\n                if (c.radius == 0) {\n                    c = makeDiameter(p, q);\n                } else {\n                    c = makeCircleTwoPoints(points.subList(0, i + 1), p, q);\n                }\n            }\n        }\n        return c;\n    }\n\n    private static Circle makeCircleTwoPoints(List<Point2D.Double> points, Point2D.Double p, Point2D.Double q) {\n        Circle c = makeDiameter(p, q);\n        Circle left = null;\n        Circle right = null;\n\n        Point2D.Double pq = new Point2D.Double(q.x - p.x, q.y - p.y);\n        for (Point2D.Double r : points) {\n            if (c.contains(r)) continue;\n\n            double cross = pq.x * (r.y - p.y) - pq.y * (r.x - p.x);\n            Circle newCirc = makeCircumcircle(p, q, r);\n            if (newCirc == null) continue;\n            else if (cross > 0 && (left == null || pq.x * (newCirc.center.y - left.center.y)\n                    - pq.y * (newCirc.center.x - left.center.x) > 0))\n                left = newCirc;\n            else if (cross < 0 && (right == null || pq.x * (newCirc.center.y - right.center.y)\n                    - pq.y * (newCirc.center.x - right.center.x) < 0))\n                right = newCirc;\n        }\n\n        if (left == null && right == null) return c;\n        else if (left == null) return right;\n        else if (right == null) return left;\n        else return left.radius <= right.radius ? left : right;\n    }\n\n    private static Circle makeDiameter(Point2D.Double a, Point2D.Double b) {\n        Point2D.Double c = new Point2D.Double((a.x + b.x) / 2, (a.y + b.y) / 2);\n        return new Circle(c, c.distance(a));\n    }\n\n    private static Circle makeCircumcircle(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n        double d = (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)) * 2;\n        if (d == 0) return null;\n\n        double x = ((a.x*a.x + a.y*a.y) * (b.y - c.y) + (b.x*b.x + b.y*b.y) * (c.y - a.y)\n                + (c.x*c.x + c.y*c.y) * (a.y - b.y)) / d;\n        double y = ((a.x*a.x + a.y*a.y) * (c.x - b.x) + (b.x*b.x + b.y*b.y) * (a.x - c.x)\n                + (c.x*c.x + c.y*c.y) * (b.x - a.x)) / d;\n        Point2D.Double p = new Point2D.Double(x, y);\n        return new Circle(p, p.distance(a));\n    }\n\n    public static void main(String[] args) {\n        List<Point2D.Double> points = new ArrayList<>();\n        points.add(new Point2D.Double(0, 0));\n        points.add(new Point2D.Double(1, 0));\n        points.add(new Point2D.Double(0, 1));\n        points.add(new Point2D.Double(1, 1));\n\n        Circle result = findMinCircle(points);\n        System.out.println(\"Center : (\" + result.center.x + \", \" + result.center.y + \")\");\n        System.out.println(\"Radius : \" + result.radius);\n    }\n}",
    "timestamp": "2025-08-13 11:57:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble minCircleRadius(Point points[], int n) {\n    double min_x = DBL_MAX, max_x = -DBL_MAX;\n    double min_y = DBL_MAX, max_y = -DBL_MAX;\n    \n    for (int i = 0; i < n; i++) {\n        if (points[i].x < min_x) min_x = points[i].x;\n        if (points[i].x > max_x) max_x = points[i].x;\n        if (points[i].y < min_y) min_y = points[i].y;\n        if (points[i].y > max_y) max_y = points[i].y;\n    }\n    \n    Point center;\n    center.x = (min_x + max_x) / 2.0;\n    center.y = (min_y + max_y) / 2.0;\n\n    double radius = 0;\n    \n    for (int i = 0; i < n; i++) {\n        double d = distance(center, points[i]);\n        if (d > radius) radius = d;\n    }\n    \n    return radius;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    Point points[N];\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    \n    printf(\"%lf\\n\", minCircleRadius(points, N));\n    return 0;\n}",
    "timestamp": "2025-08-13 11:57:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findMinCircleRadius(points) {\n    if (points.length === 0) return 0;\n\n    let xSum = 0;\n    let ySum = 0;\n    points.forEach(([x, y]) => {\n        xSum += x;\n        ySum += y;\n    });\n\n    const centerX = xSum / points.length;\n    const centerY = ySum / points.length;\n\n    let maxDistSq = 0;\n    points.forEach(([x, y]) => {\n        const distSq = (x - centerX) ** 2 + (y - centerY) ** 2;\n        if (distSq > maxDistSq) maxDistSq = distSq;\n    });\n\n    return Math.sqrt(maxDistSq);\n}",
    "timestamp": "2025-08-13 11:57:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef min_enclosing_circle(points):\n    def dist(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n    \n    def is_inside_circle(circle, point):\n        return dist(circle[:2], point) <= circle[2]\n    \n    def circle_from_two_points(p1, p2):\n        center_x = (p1[0] + p2[0]) / 2\n        center_y = (p1[1] + p2[1]) / 2\n        radius = dist(p1, p2) / 2\n        return [center_x, center_y, radius]\n    \n    def circle_from_three_points(p1, p2, p3):\n        ax, ay = p1\n        bx, by = p2\n        cx, cy = p3\n        \n        d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))\n        \n        ux = ((ax*ax + ay*ay) * (by - cy) + (bx*bx + by*by) * (cy - ay) + (cx*cx + cy*cy) * (ay - by)) / d\n        uy = ((ax*ax + ay*ay) * (cx - bx) + (bx*bx + by*by) * (ax - cx) + (cx*cx + cy*cy) * (bx - ax)) / d\n        \n        radius = math.sqrt((ux - ax)**2 + (uy - ay)**2)\n        return [ux, uy, radius]\n    \n    n = len(points)\n    if n == 0:\n        return None\n    if n == 1:\n        return [points[0][0], points[0][1], 0]\n    if n == 2:\n        return circle_from_two_points(points[0], points[1])\n    \n    # Welzl's algorithm for minimum enclosing circle\n    def welzl(P, R):\n        if not P or len(R) == 3:\n            if len(R) == 0:\n                return None\n            if len(R) == 1:\n                return [R[0][0], R[0][1], 0]\n            if len(R) == 2:\n                return circle_from_two_points(R[0], R[1])\n            if len(R) == 3:\n                return circle_from_three_points(R[0], R[1], R[2])\n        \n        p = P[0]\n        P_new = P[1:]\n        D = welzl(P_new, R)\n        \n        if D and is_inside_circle(D, p):\n            return D\n        \n        R.append(p)\n        D = welzl(P_new, R)\n        R.pop()\n        \n        return D\n    \n    # Randomize points to improve average-case performance\n    import random\n    random.shuffle(points)\n    \n    result = welzl(points, [])\n    return result\n\n# Example usage\npoints = [(0, 0), (1, 1), (2, 2), (3, 3)]\ncircle = min_enclosing_circle(points)\nprint(f\"Center: ({circle[0]}, {circle[1]}), Radius: {circle[2]}\")",
    "timestamp": "2025-08-13 11:58:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findMinimumCircle(points) {\n    if (points.length === 0) return 0;\n    if (points.length === 1) return 0;\n    if (points.length === 2) {\n        const centerX = (points[0][0] + points[1][0]) / 2;\n        const centerY = (points[0][1] + points[1][1]) / 2;\n        const radius = Math.sqrt(\n            Math.pow(points[0][0] - centerX, 2) + \n            Math.pow(points[0][1] - centerY, 2)\n        );\n        return radius;\n    }\n\n    function distanceBetweenPoints(p1, p2) {\n        return Math.sqrt(\n            Math.pow(p1[0] - p2[0], 2) + \n            Math.pow(p1[1] - p2[1], 2)\n        );\n    }\n\n    function findCircumcenter(p1, p2, p3) {\n        const ax = p1[0], ay = p1[1];\n        const bx = p2[0], by = p2[1];\n        const cx = p3[0], cy = p3[1];\n\n        const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));\n        const ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;\n        const uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;\n\n        return [ux, uy];\n    }\n\n    let minRadius = Infinity;\n\n    for (let i = 0; i < points.length; i++) {\n        for (let j = i + 1; j < points.length; j++) {\n            const centerX = (points[i][0] + points[j][0]) / 2;\n            const centerY = (points[i][1] + points[j][1]) / 2;\n            const radius = Math.max(\n                distanceBetweenPoints(points[i], [centerX, centerY]),\n                distanceBetweenPoints(points[j], [centerX, centerY])\n            );\n\n            let valid = true;\n            for (let k = 0; k < points.length; k++) {\n                if (distanceBetweenPoints(points[k], [centerX, centerY]) > radius) {\n                    valid = false;\n                    break;\n                }\n            }\n\n            if (valid) {\n                minRadius = Math.min(minRadius, radius);\n            }\n        }\n    }\n\n    for (let i = 0; i < points.length; i++) {\n        for (let j = i + 1; j < points.length; j++) {\n            for (let k = j + 1; k < points.length; k++) {\n                const center = findCircumcenter(points[i], points[j], points[k]);\n                const radius = Math.max(\n                    distanceBetweenPoints(points[i], center),\n                    distanceBetweenPoints(points[j], center),\n                    distanceBetweenPoints(points[k], center)\n                );\n\n                let valid = true;\n                for (let m = 0; m < points.length; m++) {\n                    if (distanceBetweenPoints(points[m], center) > radius) {\n                        valid = false;\n                        break;\n                    }\n                }\n\n                if (valid) {\n                    minRadius = Math.min(minRadius, radius);\n                }\n            }\n        }\n    }\n\n    return minRadius;\n}",
    "timestamp": "2025-08-13 11:58:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef min_circle_radius(points):\n    if not points:\n        return 0.0\n    \n    # Calculate the centroid (mean of all points)\n    n = len(points)\n    sum_x = sum(p[0] for p in points)\n    sum_y = sum(p[1] for p in points)\n    centroid_x = sum_x / n\n    centroid_y = sum_y / n\n    \n    # Find the maximum distance from the centroid to any point\n    max_distance = 0.0\n    for (x, y) in points:\n        dx = x - centroid_x\n        dy = y - centroid_y\n        distance = math.sqrt(dx*dx + dy*dy)\n        if distance > max_distance:\n            max_distance = distance\n    \n    return max_distance",
    "timestamp": "2025-08-13 11:58:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minCircleRadius(points) {\n    if (points.length === 0) return 0;\n    \n    // Function to calculate the squared distance between two points\n    function distanceSquared(a, b) {\n        return (a.x - b.x) ** 2 + (a.y - b.y) ** 2;\n    }\n    \n    // Function to find the smallest enclosing circle for a subset of points\n    function minEnclosingCircle(points, R) {\n        if (R.length === 3) {\n            return circleFrom3Points(R[0], R[1], R[2]);\n        }\n        if (points.length === 0 || R.length === 3) {\n            return circleFromPoints(R);\n        }\n        \n        const p = points[0];\n        const remainingPoints = points.slice(1);\n        const D = minEnclosingCircle(remainingPoints, R);\n        \n        if (distanceSquared(p, D.center) <= D.radius ** 2) {\n            return D;\n        }\n        \n        return minEnclosingCircle(remainingPoints, [...R, p]);\n    }\n    \n    // Function to create a circle from a set of points\n    function circleFromPoints(points) {\n        if (points.length === 0) {\n            return { center: { x: 0, y: 0 }, radius: 0 };\n        }\n        if (points.length === 1) {\n            return { center: points[0], radius: 0 };\n        }\n        if (points.length === 2) {\n            const center = {\n                x: (points[0].x + points[1].x) / 2,\n                y: (points[0].y + points[1].y) / 2\n            };\n            const radius = Math.sqrt(distanceSquared(points[0], points[1])) / 2;\n            return { center, radius };\n        }\n        return circleFrom3Points(points[0], points[1], points[2]);\n    }\n    \n    // Function to create a circle from three points\n    function circleFrom3Points(a, b, c) {\n        const A = b.x - a.x;\n        const B = b.y - a.y;\n        const C = c.x - a.x;\n        const D = c.y - a.y;\n        \n        const E = A * (a.x + b.x) + B * (a.y + b.y);\n        const F = C * (a.x + c.x) + D * (a.y + c.y);\n        \n        const G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\n        \n        if (G === 0) {\n            // Points are colinear, return circle with diameter endpoints\n            const points = [a, b, c];\n            let maxDist = 0;\n            let center = { x: 0, y: 0 };\n            for (let i = 0; i < points.length; i++) {\n                for (let j = i + 1; j < points.length; j++) {\n                    const dist = distanceSquared(points[i], points[j]);\n                    if (dist > maxDist) {\n                        maxDist = dist;\n                        center = {\n                            x: (points[i].x + points[j].x) / 2,\n                            y: (points[i].y + points[j].y) / 2\n                        };\n                    }\n                }\n            }\n            return { center, radius: Math.sqrt(maxDist) / 2 };\n        }\n        \n        const centerX = (D * E - B * F) / G;\n        const centerY = (A * F - C * E) / G;\n        const center = { x: centerX, y: centerY };\n        const radius = Math.sqrt(distanceSquared(center, a));\n        \n        return { center, radius };\n    }\n    \n    const shuffledPoints = [...points].sort(() => Math.random() - 0.5);\n    const result = minEnclosingCircle(shuffledPoints, []);\n    return result.radius;\n}",
    "timestamp": "2025-08-13 11:58:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return std::sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nPoint calculateMidpoint(const Point& a, const Point& b) {\n    return Point{(a.x + b.x) / 2.0, (a.y + b.y) / 2.0};\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    std::vector<Point> points(N);\n\n    for (int i = 0; i < N; ++i) {\n        std::cin >> points[i].x >> points[i].y;\n    }\n\n    double minRadius = std::numeric_limits<double>::max();\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            Point center = calculateMidpoint(points[i], points[j]);\n            double radius = distance(points[i], center);\n\n            bool containsAllPoints = true;\n            for (int k = 0; k < N; ++k) {\n                if (distance(center, points[k]) > radius) {\n                    containsAllPoints = false;\n                    break;\n                }\n            }\n            if (containsAllPoints) {\n                minRadius = std::min(minRadius, radius);\n            }\n        }\n    }\n\n    printf(\"%.10f\\n\", minRadius);\n    return 0;\n}",
    "timestamp": "2025-08-13 12:06:04"
  }
]