[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MOD 998244353\n#define MAXH 20\n#define MAXW 20\n\nint H, W;\nchar grid[MAXH][MAXW+1];\nbool row_white[MAXH];\nbool col_white[MAXW];\n\nvoid solve() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    memset(row_white, false, sizeof(row_white));\n    memset(col_white, false, sizeof(col_white));\n\n    long long result = 1;\n    for (int bit = 0; bit < H + W; bit++) {\n        bool can_flip = false;\n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                char curr = grid[r][c];\n                if ((curr == '.' && row_white[r]) || \n                    (curr == '#' && !row_white[r]) ||\n                    (curr == '.' && col_white[c]) || \n                    (curr == '#' && !col_white[c])) {\n                    can_flip = true;\n                    break;\n                }\n            }\n            if (can_flip) break;\n        }\n\n        if (can_flip) {\n            result = (result * 2) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        solve();\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n#define MAX_H 20\n#define MAX_W 20\n\nint H, W;\nchar grid[MAX_H][MAX_W + 1];\nint row_white[MAX_H];\nint row_black[MAX_H];\nint col_white[MAX_W];\nint col_black[MAX_W];\nlong long dp[1 << MAX_H][1 << MAX_W];\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < H; i++) {\n        row_white[i] = 0;\n        row_black[i] = 0;\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                row_white[i] |= (1 << j);\n            } else {\n                row_black[i] |= (1 << j);\n            }\n        }\n    }\n\n    for (int j = 0; j < W; j++) {\n        col_white[j] = 0;\n        col_black[j] = 0;\n        for (int i = 0; i < H; i++) {\n            if (grid[i][j] == '.') {\n                col_white[j] |= (1 << i);\n            } else {\n                col_black[j] |= (1 << i);\n            }\n        }\n    }\n\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            for (int mask_row = 0; mask_row < (1 << H); mask_row++) {\n                for (int mask_col = 0; mask_col < (1 << W); mask_col++) {\n                    if (dp[mask_row][mask_col] == 0) continue;\n\n                    // Do not perform any operation on this cell\n                    int new_mask_row = mask_row;\n                    int new_mask_col = mask_col;\n                    long long val = dp[mask_row][mask_col];\n                    dp[new_mask_row][new_mask_col] = (dp[new_mask_row][new_mask_col] + val) % MOD;\n\n                    // Perform row operation (white or black)\n                    new_mask_row = mask_row | (1 << i);\n                    new_mask_col = mask_col;\n                    dp[new_mask_row][new_mask_col] = (dp[new_mask_row][new_mask_col] + val) % MOD;\n\n                    new_mask_row = mask_row | (1 << i);\n                    new_mask_col = mask_col;\n                    dp[new_mask_row][new_mask_col] = (dp[new_mask_row][new_mask_col] + val) % MOD;\n\n                    // Perform column operation (white or black)\n                    new_mask_row = mask_row;\n                    new_mask_col = mask_col | (1 << j);\n                    dp[new_mask_row][new_mask_col] = (dp[new_mask_row][new_mask_col] + val) % MOD;\n\n                    new_mask_row = mask_row;\n                    new_mask_col = mask_col | (1 << j);\n                    dp[new_mask_row][new_mask_col] = (dp[new_mask_row][new_mask_col] + val) % MOD;\n                }\n            }\n        }\n    }\n\n    long long result = 0;\n    for (int mask_row = 0; mask_row < (1 << H); mask_row++) {\n        for (int mask_col = 0; mask_col < (1 << W); mask_col++) {\n            if (dp[mask_row][mask_col] == 0) continue;\n\n            int valid = 1;\n            for (int i = 0; i < H && valid; i++) {\n                if (mask_row & (1 << i)) continue;\n                for (int j = 0; j < W && valid; j++) {\n                    if (mask_col & (1 << j)) continue;\n                    if (grid[i][j] == '.') {\n                        if (!(row_white[i] & (1 << j)) && !(col_white[j] & (1 << i))) {\n                            valid = 0;\n                        }\n                    } else {\n                        if (!(row_black[i] & (1 << j)) && !(col_black[j] & (1 << i))) {\n                            valid = 0;\n                        }\n                    }\n                }\n            }\n            if (valid) {\n                result = (result + dp[mask_row][mask_col]) % MOD;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:38:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> A(H);\n    for (int i = 0; i < H; ++i) cin >> A[i];\n\n    long long ans = 1;\n\n    for (int i = 0; i < H; ++i) {\n        bool has_black = false, has_white = false;\n        for (int j = 0; j < W; ++j) {\n            if (A[i][j] == '#') has_black = true;\n            if (A[i][j] == '.') has_white = true;\n        }\n        if (has_black && has_white) {\n            // No choice, must not operate on this row\n        } else {\n            ans = ans * 2 % MOD;\n        }\n    }\n\n    for (int j = 0; j < W; ++j) {\n        bool has_black = false, has_white = false;\n        for (int i = 0; i < H; ++i) {\n            if (A[i][j] == '#') has_black = true;\n            if (A[i][j] == '.') has_white = true;\n        }\n        if (has_black && has_white) {\n            // No choice, must not operate on this column\n        } else {\n            ans = ans * 2 % MOD;\n        }\n    }\n\n    // Subtract the overcounted cases where all rows or all columns are operated\n    bool all_rows_operable = true;\n    for (int i = 0; i < H; ++i) {\n        bool has_black = false, has_white = false;\n        for (int j = 0; j < W; ++j) {\n            if (A[i][j] == '#') has_black = true;\n            if (A[i][j] == '.') has_white = true;\n        }\n        if (has_black && has_white) {\n            all_rows_operable = false;\n            break;\n        }\n    }\n\n    bool all_cols_operable = true;\n    for (int j = 0; j < W; ++j) {\n        bool has_black = false, has_white = false;\n        for (int i = 0; i < H; ++i) {\n            if (A[i][j] == '#') has_black = true;\n            if (A[i][j] == '.') has_white = true;\n        }\n        if (has_black && has_white) {\n            all_cols_operable = false;\n            break;\n        }\n    }\n\n    if (all_rows_operable) ans = (ans - 1 + MOD) % MOD;\n    if (all_cols_operable) ans = (ans - 1 + MOD) % MOD;\n    if (all_rows_operable && all_cols_operable) ans = (ans + 1) % MOD;\n\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:39:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        sc.nextLine();\n        char[][] grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n            }\n        }\n\n        // Prepare row and column constraints\n        int[] rowConstraint = new int[H]; // 0: no constraint, 1: must be white, 2: must be black, 3: invalid\n        int[] colConstraint = new int[W]; // same as rowConstraint\n        Arrays.fill(rowConstraint, 0);\n        Arrays.fill(colConstraint, 0);\n\n        boolean possible = true;\n        for (int i = 0; i < H && possible; i++) {\n            for (int j = 0; j < W && possible; j++) {\n                if (grid[i][j] == '.') {\n                    if (rowConstraint[i] == 2 || colConstraint[j] == 2) {\n                        possible = false;\n                    }\n                    rowConstraint[i] = Math.max(rowConstraint[i], 1);\n                    colConstraint[j] = Math.max(colConstraint[j], 1);\n                } else if (grid[i][j] == '#') {\n                    if (rowConstraint[i] == 1 || colConstraint[j] == 1) {\n                        possible = false;\n                    }\n                    rowConstraint[i] = Math.max(rowConstraint[i], 2);\n                    colConstraint[j] = Math.max(colConstraint[j], 2);\n                }\n            }\n        }\n\n        if (!possible) {\n            System.out.println(0);\n            return;\n        }\n\n        int freeRows = 0;\n        for (int i = 0; i < H; i++) {\n            if (rowConstraint[i] == 0) {\n                freeRows++;\n            }\n        }\n\n        int freeCols = 0;\n        for (int j = 0; j < W; j++) {\n            if (colConstraint[j] == 0) {\n                freeCols++;\n            }\n        }\n\n        long ans = 1;\n        for (int i = 0; i < freeRows + freeCols; i++) {\n            ans = (ans * 2) % MOD;\n        }\n\n        // Subtract cases where a free row and free column are both white or both black\n        // But need to handle the constraints properly\n        // The correct way is to count the number of independent choices\n        // The actual answer is 2^{freeRows + freeCols - intersection_conflicts}\n        // But since free rows and columns are independent, it's just 2^{freeRows + freeCols}\n\n        System.out.println(ans);\n    }\n}",
    "timestamp": "2025-08-05 22:40:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    private static final int MOD = 998244353;\n\n    public static int countPaintings(int H, int W, String[] grid) {\n        int[][] initialState = new int[H][W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                initialState[i][j] = grid[i].charAt(j) == '#' ? 1 : 0;\n            }\n        }\n\n        Set<String> reachableStates = new HashSet<>();\n        dfs(initialState, new boolean[H], new boolean[W], reachableStates);\n\n        return reachableStates.size() % MOD;\n    }\n\n    private static void dfs(int[][] state, boolean[] rowFlipped, boolean[] colFlipped, Set<String> reachableStates) {\n        String stateKey = getStateKey(state);\n        if (!reachableStates.add(stateKey)) {\n            return;\n        }\n\n        int H = state.length;\n        int W = state[0].length;\n\n        // Flip rows\n        for (int i = 0; i < H; i++) {\n            if (!rowFlipped[i]) {\n                int[][] newState = copyState(state);\n                for (int j = 0; j < W; j++) {\n                    newState[i][j] = 1 - newState[i][j];\n                }\n                boolean[] newRowFlipped = rowFlipped.clone();\n                newRowFlipped[i] = true;\n                dfs(newState, newRowFlipped, colFlipped, reachableStates);\n            }\n        }\n\n        // Flip columns\n        for (int j = 0; j < W; j++) {\n            if (!colFlipped[j]) {\n                int[][] newState = copyState(state);\n                for (int i = 0; i < H; i++) {\n                    newState[i][j] = 1 - newState[i][j];\n                }\n                boolean[] newColFlipped = colFlipped.clone();\n                newColFlipped[j] = true;\n                dfs(newState, rowFlipped, newColFlipped, reachableStates);\n            }\n        }\n    }\n\n    private static int[][] copyState(int[][] state) {\n        int[][] copy = new int[state.length][state[0].length];\n        for (int i = 0; i < state.length; i++) {\n            System.arraycopy(state[i], 0, copy[i], 0, state[0].length);\n        }\n        return copy;\n    }\n\n    private static String getStateKey(int[][] state) {\n        StringBuilder sb = new StringBuilder();\n        for (int[] row : state) {\n            for (int cell : row) {\n                sb.append(cell);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "timestamp": "2025-08-05 22:40:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<string> grid(H);\n    for (int i = 0; i < H; i++) {\n        cin >> grid[i];\n    }\n    \n    vector<vector<int>> initial(H, vector<int>(W));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            initial[i][j] = (grid[i][j] == '#');\n        }\n    }\n    \n    set<vector<vector<int>>> unique_configs;\n    unique_configs.insert(initial);\n    \n    queue<vector<vector<int>>> q;\n    q.push(initial);\n    \n    while (!q.empty()) {\n        auto curr = q.front();\n        q.pop();\n        \n        // Row operations\n        for (int r = 0; r < H; r++) {\n            // White row\n            auto white_row = curr;\n            for (int j = 0; j < W; j++) {\n                white_row[r][j] = 0;\n            }\n            \n            if (unique_configs.find(white_row) == unique_configs.end()) {\n                unique_configs.insert(white_row);\n                q.push(white_row);\n            }\n            \n            // Black row\n            auto black_row = curr;\n            for (int j = 0; j < W; j++) {\n                black_row[r][j] = 1;\n            }\n            \n            if (unique_configs.find(black_row) == unique_configs.end()) {\n                unique_configs.insert(black_row);\n                q.push(black_row);\n            }\n        }\n        \n        // Column operations\n        for (int c = 0; c < W; c++) {\n            // White column\n            auto white_col = curr;\n            for (int i = 0; i < H; i++) {\n                white_col[i][c] = 0;\n            }\n            \n            if (unique_configs.find(white_col) == unique_configs.end()) {\n                unique_configs.insert(white_col);\n                q.push(white_col);\n            }\n            \n            // Black column\n            auto black_col = curr;\n            for (int i = 0; i < H; i++) {\n                black_col[i][c] = 1;\n            }\n            \n            if (unique_configs.find(black_col) == unique_configs.end()) {\n                unique_configs.insert(black_col);\n                q.push(black_col);\n            }\n        }\n    }\n    \n    cout << unique_configs.size() % MOD << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(H, W, grid):\n    MOD = 998244353\n    \n    # Count initial number of black squares\n    initial_black_count = sum(row.count('#') for row in grid)\n\n    # Total number of paintable configurations\n    total_configurations = pow(2, H + W, MOD)\n\n    # Number of ways to paint rows and columns to make the grid all white\n    make_all_white = pow(2, H, MOD) + pow(2, W, MOD) - 1\n\n    # Additional subtract if the grid is already entirely white\n    if initial_black_count == 0:\n        extra_subtract = 1\n    else:\n        extra_subtract = 0\n\n    # Result is total configurations minus the ways to make the grid fully white\n    result = (total_configurations - make_all_white + extra_subtract) % MOD\n    print(result)\n\n# Sample input\nH = 2\nW = 3\ngrid = ['#.#', '...']\nsolve(H, W, grid)",
    "timestamp": "2025-08-13 11:55:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GridPainting {\n    private static final int MOD = 998244353;\n\n    private static long modPow(long base, long exp, long mod) {\n        long result = 1;\n        while (exp > 0) {\n            if ((exp & 1) != 0) {\n                result = (result * base) % mod;\n            }\n            base = (base * base) % mod;\n            exp >>= 1;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        scanner.nextLine();\n\n        char[][] grid = new char[H][W];\n        int blackCount = 0;\n\n        for (int i = 0; i < H; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == '#') {\n                    blackCount++;\n                }\n            }\n        }\n\n        long ways = modPow(2, H, MOD) + modPow(2, W, MOD) - 1;\n        long result = modPow(2, blackCount, MOD) * ways % MOD;\n        \n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 11:55:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 998244353\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    char grid[H][W + 1]; // +1 for the null terminator\n    \n    for (int i = 0; i < H; ++i) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    int initialBlackCount = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '#') {\n                initialBlackCount++;\n            }\n        }\n    }\n    \n    // Each operation has 2 choices (white or black), so for H + W operations we have 2^(H + W) possible sequences\n    int totalWays = 1;\n    for (int i = 0; i < H + W; ++i) {\n        totalWays = (totalWays * 2) % MOD;\n    }\n    \n    // Subtract the invalid way\n    int invalidWay = 0;\n    if (initialBlackCount == 0) {\n        invalidWay = 1; // Special case where all initial colors are white.\n    }\n    \n    int result = (totalWays - invalidWay + MOD) % MOD;\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:55:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countWays(H, W, A) {\n    const MOD = 998244353;\n    let allWhiteGrid = true;\n    \n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (A[i][j] === '#') {\n                allWhiteGrid = false;\n                break;\n            }\n        }\n        if (!allWhiteGrid) break;\n    }\n\n    let totalWays = 1;\n    if (allWhiteGrid) {\n        totalWays = (1 << (H + W)) % MOD;\n    } else {\n        totalWays = (2 * (1 << (H + W - 1))) % MOD;\n    }\n\n    return totalWays;\n}",
    "timestamp": "2025-08-13 11:55:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(H, W, grid):\n    MOD = 998244353\n    \n    # Convert grid to set of unique configurations\n    unique_configs = set()\n    \n    def to_tuple(grid):\n        return tuple(tuple(row) for row in grid)\n    \n    def paint_row_white(grid, r):\n        new_grid = [row[:] for row in grid]\n        new_grid[r] = ['.'] * W\n        return new_grid\n    \n    def paint_row_black(grid, r):\n        new_grid = [row[:] for row in grid]\n        new_grid[r] = ['#'] * W\n        return new_grid\n    \n    def paint_col_white(grid, c):\n        new_grid = [row[:] for row in grid]\n        for r in range(H):\n            new_grid[r][c] = '.'\n        return new_grid\n    \n    def paint_col_black(grid, c):\n        new_grid = [row[:] for row in grid]\n        for r in range(H):\n            new_grid[r][c] = '#'\n        return new_grid\n    \n    def bfs(initial_grid):\n        queue = [initial_grid]\n        unique_configs.add(to_tuple(initial_grid))\n        \n        while queue:\n            current_grid = queue.pop(0)\n            \n            # Paint rows white\n            for r in range(H):\n                next_grid = paint_row_white(current_grid, r)\n                next_tuple = to_tuple(next_grid)\n                if next_tuple not in unique_configs:\n                    unique_configs.add(next_tuple)\n                    queue.append(next_grid)\n            \n            # Paint rows black\n            for r in range(H):\n                next_grid = paint_row_black(current_grid, r)\n                next_tuple = to_tuple(next_grid)\n                if next_tuple not in unique_configs:\n                    unique_configs.add(next_tuple)\n                    queue.append(next_grid)\n            \n            # Paint columns white\n            for c in range(W):\n                next_grid = paint_col_white(current_grid, c)\n                next_tuple = to_tuple(next_grid)\n                if next_tuple not in unique_configs:\n                    unique_configs.add(next_tuple)\n                    queue.append(next_grid)\n            \n            # Paint columns black\n            for c in range(W):\n                next_grid = paint_col_black(current_grid, c)\n                next_tuple = to_tuple(next_grid)\n                if next_tuple not in unique_configs:\n                    unique_configs.add(next_tuple)\n                    queue.append(next_grid)\n    \n    initial_grid = [list(row) for row in grid]\n    bfs(initial_grid)\n    \n    return len(unique_configs) % MOD\n\n# Example usage\nH, W = map(int, input().split())\ngrid = [input().strip() for _ in range(H)]\nresult = solve(H, W, grid)\nprint(result)",
    "timestamp": "2025-08-13 11:55:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(H, W, grid) {\n    const mod = 998244353n;\n    const target = new Set();\n\n    for (let r = 0; r < H; r++) {\n        for (let c = 0; c < W; c++) {\n            if (grid[r][c] === '#') {\n                target.add(r * W + c);\n            }\n        }\n    }\n\n    const possible = new Set();\n    possible.add(0n);\n\n    for (let r = 0; r < H; r++) {\n        const newPossible = new Set();\n        for (const mask of possible) {\n            let rowMask = 0n;\n            for (let c = 0; c < W; c++) {\n                if (grid[r][c] === '#') rowMask |= 1n << BigInt(r * W + c);\n            }\n            newPossible.add(mask | rowMask);\n            newPossible.add(mask & ~rowMask);\n        }\n        possible = newPossible;\n    }\n\n    for (let c = 0; c < W; c++) {\n        const newPossible = new Set();\n        for (const mask of possible) {\n            let colMask = 0n;\n            for (let r = 0; r < H; r++) {\n                if (grid[r][c] === '#') colMask |= 1n << BigInt(r * W + c);\n            }\n            newPossible.add(mask | colMask);\n            newPossible.add(mask & ~colMask);\n        }\n        possible = newPossible;\n    }\n\n    let count = 0n;\n    for (const mask of possible) {\n        if (mask === target) count++;\n    }\n\n    return Number(count % mod);\n}",
    "timestamp": "2025-08-13 11:55:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 998244353\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Determine for each row and column the possible colors\n    # For rows: if any cell is B, cannot be W row. Similarly for W.\n    row_possible = [{'B': False, 'W': False, 'any': False} for _ in range(H)]\n    for i in range(H):\n        has_B = False\n        has_W = False\n        for j in range(W):\n            c = grid[i][j]\n            if c == '#':\n                has_B = True\n            elif c == '.':\n                has_W = True\n        if not has_B:\n            row_possible[i]['W'] = True\n        if not has_W:\n            row_possible[i]['B'] = True\n        if has_B and has_W:\n            row_possible[i]['any'] = True\n    \n    # Similarly for columns\n    col_possible = [{'B': False, 'W': False, 'any': False} for _ in range(W)]\n    for j in range(W):\n        has_B = False\n        has_W = False\n        for i in range(H):\n            c = grid[i][j]\n            if c == '#':\n                has_B = True\n            elif c == '.':\n                has_W = True\n        if not has_B:\n            col_possible[j]['W'] = True\n        if not has_W:\n            col_possible[j]['B'] = True\n        if has_B and has_W:\n            col_possible[j]['any'] = True\n    \n    # Now, count the number of valid configurations\n    # The key observation is that for cells not covered by any row or column operation,\n    # they must match the initial state.\n    # So, we need to count the ways to choose row and column operations such that\n    # for each cell (i,j), either:\n    # - row i is set to some color, or\n    # - column j is set to some color, or\n    # - both, and they agree.\n    # And the remaining cells must match the initial state.\n    \n    # We'll proceed by considering the rows and columns that are set to a color.\n    # Let's first find the rows and columns that must be set (because they have both B and W in initial state)\n    # and those that can be left unset.\n    \n    # Rows that must be set (if they have both B and W)\n    must_row = [False] * H\n    for i in range(H):\n        if row_possible[i]['any']:\n            must_row[i] = True\n    \n    # Columns that must be set\n    must_col = [False] * W\n    for j in range(W):\n        if col_possible[j]['any']:\n            must_col[j] = True\n    \n    # Now, for rows and columns that are not must, they can be left unset or set to any possible color.\n    # The cells that are not covered by any set row or column must match the initial state.\n    # So, the problem reduces to choosing a subset of rows and columns to set (covering all must rows and columns)\n    # and assigning colors to them, such that for any cell (i,j):\n    # - if row i is set to c1 and column j is set to c2, then c1 == c2 or one of them is not set.\n    \n    # To count this, we can use inclusion-exclusion or DP, but it's complex.\n    # Instead, we can model this as:\n    # - The rows and columns form a bipartite graph, where edges represent cells that must have consistent colors.\n    # - The problem is to count the number of valid colorings of this graph.\n    \n    # However, a simpler approach is to note that the constraints imply that the set of rows and columns that are set must form a \"consistent\" set.\n    # Specifically, for any two set rows i and j, if there exists a column k such that grid[i][k] and grid[j][k] are different, then the row colors must be consistent with column colors.\n    # Similarly for columns.\n    \n    # Given the complexity, we can instead note that the answer is (number of valid row colorings) * (number of valid column colorings) / (overcounting due to cells covered by both).\n    # But this is not straightforward.\n    \n    # Alternative approach: for each cell (i,j), it's either:\n    # - determined by row i (if set)\n    # - determined by column j (if set)\n    # - must match initial state (if neither is set)\n    # So, the valid configurations are those where for every cell (i,j), if both row i and column j are set, their colors must agree.\n    \n    # So, the problem reduces to counting the number of ways to assign colors to rows and columns such that:\n    # 1. For every must_row[i], row i is set to a possible color.\n    # 2. For every must_col[j], column j is set to a possible color.\n    # 3. For every cell (i,j), if both row i and column j are set, their colors agree.\n    \n    # To handle this, we can think of the rows and columns as nodes in a bipartite graph, and the constraints as edges that enforce color consistency.\n    # The answer is the number of valid colorings of this graph.\n    \n    # We can model this as a 2-coloring problem with certain constraints.\n    # Specifically, for each cell (i,j) that has both row i and column j as must (or set), the colors must agree.\n    \n    # Given the complexity, we can proceed as follows:\n    # - The answer is 2^{a} * 2^{b} * ... where a, b, etc. are the sizes of independent components.\n    # But this requires identifying connected components in the bipartite graph formed by the constraints.\n    \n    # For simplicity, let's assume that the grid is such that the constraints form a set of independent components.\n    # Then, the answer is product over components of (number of valid colorings for the component).\n    \n    # To implement this, we can build a graph where rows and columns are nodes, and edges are between row i and column j if cell (i,j) has both B and W in initial state.\n    # Then, the answer is 2^c, where c is the number of connected components in this graph, multiplied by the product of the number of options for each node not in any connected component.\n    \n    # Let's proceed with this approach.\n    \n    # Build the bipartite graph\n    adj = [[] for _ in range(H + W)]\n    # Rows are 0..H-1, columns are H..H+W-1\n    for i in range(H):\n        for j in range(W):\n            if row_possible[i]['any'] and col_possible[j]['any']:\n                # This cell (i,j) has both B and W in initial state, so if both row i and column j are set, their colors must agree.\n                # Add an edge between row i and column j.\n                u = i\n                v = H + j\n                adj[u].append(v)\n                adj[v].append(u)\n    \n    # Find connected components\n    visited = [False] * (H + W)\n    components = 0\n    \n    for u in range(H + W):\n        if not visited[u]:\n            stack = [u]\n            visited[u] = True\n            if stack:\n                components += 1\n            while stack:\n                v = stack.pop()\n                for w in adj[v]:\n                    if not visited[w]:\n                        visited[w] = True\n                        stack.append(w)\n    \n    # The number of colorings for the components is 2^components, since each component can be colored in 2 ways (all B or all W).\n    # For nodes not in any component (i.e., no constraints), multiply by their options.\n    ans = pow(2, components, MOD)\n    \n    # Now, multiply by the number of options for rows not in any component\n    free_rows = 0\n    for i in range(H):\n        if not row_possible[i]['any']:\n            # This row is not in any component, so it can be set or not.\n            # If set, it can be set to B or W if possible.\n            options = 0\n            if row_possible[i]['B']:\n                options += 1\n            if row_possible[i]['W']:\n                options += 1\n            if not must_row[i]:\n                # Can also choose not to set this row (only if not must)\n                options += 1\n            # The actual number of options is options, but since not setting is equivalent to leaving it as initial,\n            # which is only possible if initial is uniform (i.e., not must_row)\n            # So, for non-must rows, options is (B + W + 1 if initial is uniform)\n            # But since initial is uniform, B or W is possible only if the other is not present.\n            # So, options is 1 (initial) + (B if possible) + (W if possible)\n            # But initial is already covered by not setting.\n            # So, options is 1 (not set) + (B if possible) + (W if possible)\n            # But if initial is uniform, not setting is same as setting to that color.\n            # So, the number of distinct outcomes is (B options) + (W options) - (overlap if any)\n            # It's simpler to think that for non-must rows, the number of ways is (number of possible operations + 1 (no op)).\n            # But since operations override, the number of distinct outcomes is the number of possible operations (including no op if initial is uniform).\n            # So, for a non-must row, the number of distinct outcomes is the number of possible colors (including initial if uniform).\n            # So, if initial is all B, then options are B (initial) and W (if possible).\n            # Similarly for all W.\n            # So, options is 1 (initial) + (W if possible) if initial is all B.\n            # But initial is all B iff row_possible[i]['B'] is True (no W in row).\n            # Similarly for all W.\n            # So, for non-must rows:\n            if row_possible[i]['B'] and row_possible[i]['W']:\n                # This should not happen since must_row is False only if not 'any'\n                pass\n            elif row_possible[i]['B']:\n                # Initial is all B\n                options = 1\n                if row_possible[i]['W']:\n                    options += 1\n            elif row_possible[i]['W']:\n                # Initial is all W\n                options = 1\n                if row_possible[i]['B']:\n                    options += 1\n            else:\n                # Initial is empty? Not possible.\n                pass\n            # So, options is:\n            # - 1 if initial is uniform and no other operations possible\n            # - 2 if initial is uniform and one other operation possible\n            # But since must_row is False, initial is uniform.\n            cnt = 0\n            if row_possible[i]['B']:\n                cnt += 1\n            if row_possible[i]['W']:\n                cnt += 1\n            # The number of distinct outcomes is cnt.\n            ans = ans * cnt % MOD\n    # Similarly for columns not in any component\n    free_cols = 0\n    for j in range(W):\n        if not col_possible[j]['any']:\n            cnt = 0\n            if col_possible[j]['B']:\n                cnt += 1\n            if col_possible[j]['W']:\n                cnt += 1\n            ans = ans * cnt % MOD\n    \n    print(ans % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 11:57:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction solve() {\n    const input = require('fs').readFileSync(0, 'utf8').trim().split('\\n');\n    const [H, W] = input[0].split(' ').map(Number);\n    const grid = input.slice(1, H + 1).map(row => row.split(''));\n    \n    let rowWhite = new Array(H).fill(false);\n    let rowBlack = new Array(H).fill(false);\n    let colWhite = new Array(W).fill(false);\n    let colBlack = new Array(W).fill(false);\n    \n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (grid[i][j] === '.') {\n                rowBlack[i] = true;\n                colBlack[j] = true;\n            } else {\n                rowWhite[i] = true;\n                colWhite[j] = true;\n            }\n        }\n    }\n    \n    let freeRows = 0;\n    for (let i = 0; i < H; i++) {\n        if (!rowWhite[i] || !rowBlack[i]) {\n            freeRows++;\n        }\n    }\n    \n    let freeCols = 0;\n    for (let j = 0; j < W; j++) {\n        if (!colWhite[j] || !colBlack[j]) {\n            freeCols++;\n        }\n    }\n    \n    let pow2 = new Array(Math.max(H, W) + 1).fill(1);\n    for (let i = 1; i <= Math.max(H, W); i++) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n    \n    let res = 0;\n    for (let k = 0; k <= freeRows; k++) {\n        let c = comb(freeRows, k);\n        res = (res + c * pow2[freeCols + (freeRows - k)]) % MOD;\n    }\n    \n    console.log(res);\n    \n    function comb(n, k) {\n        if (k < 0 || k > n) return 0;\n        let res = 1;\n        for (let i = 1; i <= k; i++) {\n            res = res * (n - k + i) / i;\n        }\n        return res % MOD;\n    }\n}\n\nsolve();",
    "timestamp": "2025-08-13 11:57:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nconst int MOD = 998244353;\n\nint main() {\n    int H, W;\n    std::cin >> H >> W;\n    std::vector<std::string> A(H);\n    for (int i = 0; i < H; ++i) {\n        std::cin >> A[i];\n    }\n\n    // Count the initial number of black squares\n    int initial_black = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (A[i][j] == '#') {\n                initial_black++;\n            }\n        }\n    }\n\n    // Compute the number of distinct configurations\n    std::set<int> row_ops, col_ops; // Independent row or column operations\n    for (int i = 0; i < H; ++i) {\n        row_ops.insert(i);\n    }\n    for (int j = 0; j < W; ++j) {\n        col_ops.insert(j);\n    }\n\n    // Total distinct operations choices\n    int row_choices = 1 << row_ops.size(); // 2^H\n    int col_choices = 1 << col_ops.size(); // 2^W\n\n    // The number of distinct configurations can be painted from the initial state\n    long long result = 1LL * row_choices * col_choices % MOD;\n    std::cout << result << '\\n';\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:06:00"
  }
]