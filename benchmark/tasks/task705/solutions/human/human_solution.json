[
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n#define DD 1\n#else\n#define DD 0\n#endif\n#define Debug if(DD) printf(\"line %d\\n\",__LINE__)\n#define deb(x) if(DD) cerr<<#x<<'='<<x<<endl\n#define debug if(DD) printf\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid gg(){write2(-1);exit(0);}\n\t\n\tconst double eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=998244353;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int N=1e2+10;\n\n\tll C[N][N];\n\tll f[N][N][3],g[N][N][3];//f=从行开始增加\n\tchar mp[N][N];\n\tvoid main()\n\t{\n\t\tC[0][0]=1;fo(i,1,N-1){ C[i][0]=1;fo(j,1,i) C[i][j]=mm(C[i-1][j-1]+C[i-1][j]); }\n\t\tint n=qread(),m=qread();fo(i,0,n-1) scanf(\"%s\",mp[i]);\n\t\tfo(mm,0,m) g[n][mm][2]=C[m][mm]*bin(m-mm)%MOD;\n\t\tfd(nn,n,0) fd(mm,m,0)\n\t\t{\n\t\t\tfo(ad,1,n-nn)\n\t\t\t\tadd(f[nn][mm][0],C[ad+nn][nn]*(g[nn+ad][mm][0]+g[nn+ad][mm][1]*2+g[nn+ad][mm][2]*2)%MOD ),\n\t\t\t\tadd(f[nn][mm][1],C[ad+nn][nn]*(g[nn+ad][mm][1]+g[nn+ad][mm][2])%MOD*(bin(ad)-2)%MOD );\n\t\t\tfo(ad,1,m-mm)\n\t\t\t\tadd(g[nn][mm][0],C[ad+mm][mm]*(f[nn][mm+ad][0]+f[nn][mm+ad][1]*2+f[nn][mm+ad][2]*2)%MOD ),\n\t\t\t\tadd(g[nn][mm][1],C[ad+mm][mm]*(f[nn][mm+ad][1]+f[nn][mm+ad][2])%MOD*(bin(ad)-2)%MOD );\n\t\t\tdebug(\"f(%d,%d)={%d,%d,%d}\\n\",nn,mm,f[nn][mm][0],f[nn][mm][1],f[nn][mm][2]);\n\t\t\tdebug(\"g(%d,%d)={%d,%d,%d}\\n\",nn,mm,g[nn][mm][0],g[nn][mm][1],g[nn][mm][2]);\n\t\t}\n\t\tll ans=g[n][0][2];\n\t\tfo(mm,1,m) add(ans,f[0][mm][1]);\n\t\tfo(nn,1,n) add(ans,g[nn][0][1]);\n\t\tdeb(ans);\n\t\tfo(S1,1,bin(n)-1) fo(S2,1,bin(m)-1)\n\t\t{\n\t\t\tbool ok=1;\n\t\t\tfo(i,0,n-1) if(S1&bin(i)){\n\t\t\t\tbool same=1;int lst=-1;\n\t\t\t\tfo(j,0,m-1) if(S2&bin(j)) same&=(lst<0 or mp[i][j]==mp[i][lst]),lst=j;\n\t\t\t\tok&=(same==0);\n\t\t\t}fo(j,0,m-1) if(S2&bin(j)){\n\t\t\t\tbool same=1;int lst=-1;\n\t\t\t\tfo(i,0,n-1) if(S1&bin(i)) same&=(lst<0 or mp[i][j]==mp[lst][j]),lst=i;\n\t\t\t\tok&=(same==0);\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tfo(pp,0,2) add(ans, mm(f[PC(S1)][PC(S2)][pp]+g[PC(S1)][PC(S2)][pp])*invm(C[n][PC(S1)]*C[m][PC(S2)]%MOD)%MOD );\n\t\t\tdebug(\"S1=%d S2=%d ans=%d\\n\",S1,S2,ans);\n\t\t}write(ans);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\tsrand(time(0));\n\tmine::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nint upd(int x){return x + (x >> 31 & MOD);}\nvoid inc(int &a , int b){a = upd(a + b - MOD);}\nint N , M , vr[13] , vc[13]; char arr[13][13];\n\nint f[1 << 10][1 << 10][3] , g[1 << 10][1 << 10][4][3][4];\nbool vf[1 << 10][1 << 10][3] , vg[1 << 10][1 << 10][4][3][4];\n\nint sf(int , int , int);\nint sg(int , int , int , int , int);\n\nbool check(int r , int c){\n\tbool flg = 1;\n\tfor(int i = 0 ; i < N ; ++i) if(r >> i & 1) flg &= (vr[i] & c) != 0 && (vr[i] & c) != c;\n\tfor(int j = 0 ; j < M ; ++j) if(c >> j & 1) flg &= (vc[j] & r) != 0 && (vc[j] & r) != r;\n\treturn flg;\n}\n\nint sf(int a , int b , int c){\n\tif(!a && !b) return 1;\n\tif(!a || !b) return 0;\n\tif(vf[a][b][c]) return f[a][b][c];\n\tvf[a][b][c] = 1; return f[a][b][c] = sg(a , b , 0 , c , 0) + check(a , b);\n}\n\nint sg(int a , int b , int c , int d , int e){\n\tif(c == 4) return e ? sf(a , b , e - 1) : 0;\n\tif(vg[a][b][c][d][e]) return g[a][b][c][d][e];\n\tint &t = g[a][b][c][d][e]; vg[a][b][c][d][e] = 1;\n\tif(c <= 1)\n\t\tif(!d) t = sg(a , b , c + 1 , d , e);\n\t\telse for(int x = (!c ? a & 31 : a >> 5 << 5) , s = x ; ; s = (s - 1) & x){\n\t\t\t\tinc(t , sg(a ^ x ^ s , b , c + 1 , d , e | (s != x))); if(!s) break;\n\t\t\t}\n\telse\n\t\tif(d == 1) t = sg(a , b , c + 1 , d , e);\n\t\telse\n\t\t\tfor(int x = (c == 2 ? b & 31 : b >> 5 << 5) , s = x ; ; s = (s - 1) & x){\n\t\t\t\tinc(t , sg(a , b ^ x ^ s , c + 1 , d , e | (s != x) << 1)); if(!s) break;\n\t\t\t}\n\treturn t;\n}\n\nint main(){\n\tcin >> N >> M; for(int i = 0 ; i < N ; ++i) for(int j = 0 ; j < M ; ++j) cin >> arr[i][j];\n\tfor(int i = 0 ; i < N ; ++i) for(int j = M - 1 ; ~j ; --j) vr[i] = vr[i] << 1 | (arr[i][j] == '#');\n\tfor(int i = 0 ; i < M ; ++i) for(int j = N - 1 ; ~j ; --j) vc[i] = vc[i] << 1 | (arr[j][i] == '#');\n\tint sum = 0;\n\tfor(int i = 0 ; i < 1 << N ; ++i) for(int j = 0 ; j < 1 << M ; ++j) inc(sum , sf(i , j , 2));\n\tcout << sum; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nconst ll mod = 998244353;\n\nint n,m;\nchar f[12][12];\nint rw[2][12],cl[2][12];\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[55],R[55];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<55;i++) F[i] = F[i-1]*i%mod;\n\tfor(int i=0;i<55;i++) R[i] = modpow(F[i],mod-2);\n}\nll C(int a,int b){\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\nll D(int a,int b){\n    if(a < b) return 0;\n    ll ret = 0;\n    for(int i=0;i<b;i++){\n        ret += modpow(b-i,a) * C(b,i) % mod * (i%2==0?1:-1);\n    }\n    return ret%mod;\n}\nll t[12][12];\nll s[12][12][12][12];\nll w[12][12];\nll dp[12][12][4][4];\n\nll rec(int a,int b,int c,int d){\n\tif(a == 0 || b == 0) return 1;\n\tif(dp[a][b][c][d] != -1) return dp[a][b][c][d];\n\tdp[a][b][c][d] = 0;\n\t//yoko\n\t//0\n\tif( (c&1) == 0 ){\n\t\trepn(x,a-1){\n\t\t\tdp[a][b][c][d] += rec(a-x,b,3,1) * C(a,x) % mod;\n\t\t}\n\t}\n\t//1\n\tif( (c&2) == 0 ){\n\t\trepn(x,a-1){\n\t\t\tdp[a][b][c][d] += rec(a-x,b,3,2) * C(a,x) % mod;\n\t\t}\n\t}\n\t//0 & 1\n\tif(c == 0){\n\t\trepn(x,a-1){\n\t\t\trepn(y,a-x){\n\t\t\t\tdp[a][b][c][d] += rec(a-x-y,b,3,0) * C(a,x) % mod * C(a-x,y) % mod;\n\t\t\t}\n\t\t}\n\t}\n\t//tate\n\t//0\n\tif( (d&1) == 0 ){\n\t\trepn(x,b-1){\n\t\t\tdp[a][b][c][d] += rec(a,b-x,1,3) * C(b,x) % mod;\n\t\t}\n\t}\n\t//1\n\tif( (d&2) == 0 ){\n\t\trepn(x,b-1){\n\t\t\tdp[a][b][c][d] += rec(a,b-x,2,3) * C(b,x) % mod;\n\t\t}\n\t}\n\t//0 & 1\n\tif(d == 0){\n\t\trepn(x,b-1){\n\t\t\trepn(y,b-x){\n\t\t\t\tdp[a][b][c][d] += rec(a,b-x-y,0,3) * C(b,x) % mod * C(b-x,y) % mod;\n\t\t\t}\n\t\t}\n\t}\n\t//yoko & tate\n\t//0\n\tif( (c&1) == 0 && (d&1) == 0 ){\n\t\trepn(x,a-1) repn(y,b-1){\n\t\t\tdp[a][b][c][d] += rec(a-x,b-y,1,1) * C(a,x) % mod * C(b,y) % mod;\n\t\t}\n\t}\n\t//1\n\tif( (c&2) == 0 && (d&2) == 0 ){\n\t\trepn(x,a-1) repn(y,b-1){\n\t\t\tdp[a][b][c][d] += rec(a-x,b-y,2,2) * C(a,x) % mod * C(b,y) % mod;\n\t\t}\n\t}\n\t//all\n\tif( (c&1) == 0 && (d&1) == 0 ) dp[a][b][c][d]++;\n\tif( (c&2) == 0 && (d&2) == 0 ) dp[a][b][c][d]++;\n\tdp[a][b][c][d] = (dp[a][b][c][d]%mod+mod)%mod;\n\treturn dp[a][b][c][d];\n}\nvoid prepare(){\n\trep(i,12) rep(j,12){\n\t\tif(i == 0 || j == 0){\n\t\t\tw[i][j] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\trepn(x,24){\n\t\t\tint a = (x+2)/2;\n\t\t\tint b = (x+1)/2;\n\t\t\t//i,j\n\t\t\tif(i >= a && j >= b){\n\t\t\t\tw[i][j] += D(i,a) * D(j,b) % mod;\n\t\t\t}\n\t\t\t//j,i\n\t\t\tif(i >= b && j >= a){\n\t\t\t\tw[i][j] += D(i,b) * D(j,a) % mod;\n\t\t\t}\n\t\t\tw[i][j]%=mod;\n\t\t}\n\t}\n\trep(a,11) rep(b,11) rep(c,11) rep(d,11){\n\t\ts[a][b][c][d] = w[b][c] * w[a][d] % mod;\n\t}\n\trep(a,11) rep(b,11){\n\t\t//t[a][b]\n\t\tif(a >= n || b >= m) continue;\n\t\trep(x,a+1) rep(y,b+1){\n\t\t\tt[a][b] += C(a,x) * C(b,y) % mod * s[x][a-x][y][b-y] % mod;\n\t\t\tt[a][b] %= mod;\n\t\t}\n\t}\n\t//t[n][m]\n\tt[n][m] = rec(n,m,0,0);\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tmake();\n\tscanf(\"%d%d\",&n,&m);\n\tprepare();\n\trep(i,n) scanf(\"%s\",&f[i]);\n\trep(i,n){\n\t\trep(j,m){\n\t\t\trw[(f[i][j]=='#')][i] |= (1<<j);\n\t\t}\n\t}\n\trep(j,m){\n\t\trep(i,n){\n\t\t\tcl[(f[i][j]=='#')][j] |= (1<<i);\n\t\t}\n\t}\n\tll ans = t[n][m]; \n\t//203949910\n\trep(a,(1<<n)-1){\n\t\trep(b,(1<<m)-1){\n\t\t\tbool bad = 0;\n\t\t\trep(x,n){\n\t\t\t\tif(((a>>x)&1)) continue;\n\t\t\t\tint A = rw[0][x] & ((1<<m)-1-b);\n\t\t\t\tint B = rw[1][x] & ((1<<m)-1-b);\n\t\t\t\tif(A == 0 || B == 0) bad = 1;\n\t\t\t}\n\t\t\trep(x,m){\n\t\t\t\tif(((b>>x)&1)) continue;\n\t\t\t\tint A = cl[0][x] & ((1<<n)-1-a);\n\t\t\t\tint B = cl[1][x] & ((1<<n)-1-a);\n\t\t\t\tif(A == 0 || B == 0) bad = 1;\n\t\t\t}\n\t\t\tif(bad) continue;\n\t\t\tint aa = __builtin_popcount(a);\n\t\t\tint bb = __builtin_popcount(b);\n\t\t\tans += t[aa][bb];\n\t\t}\n\t}\n\tcout << (ans%mod+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=25;\nconst int MOD=998244353;\nint n,m;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac[N],inv[N];\nlong long Pw[N];\nvoid init(int n=20)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\tPw[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tPw[i]=Pw[i-1]*2%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nint r[N],c[N];\nchar s[N][N];\nlong long row[N][N][3],col[N][N][3];\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%s\",s[i]);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\t if(s[i][j]=='.') r[i]|=1<<j,c[j]|=1<<i;\n\tfor(int j=1;j<=m;j++)\n\t\tcol[n][j][2]=C(m,j)*Pw[m-j]%MOD;\n\tlong long ans=Pw[m];\n\tfor(int i=n;i>=1;i--)\n\t\tfor(int j=m;j>=1;j--)\n\t\t{\n\t\t\tcol[i][j][0]=(col[i][j][1]+col[i][j][2])%MOD;\n\t\t\tfor(int k=1;k<i;k++)\n\t\t\t{\n\t\t\t\tint d=i-k;\n\t\t\t\trow[k][j][1]=(row[k][j][1]+C(i,d)*(col[i][j][2]*2+col[i][j][1])%MOD)%MOD;\n\t\t\t\trow[k][j][2]=(row[k][j][2]+C(i,d)*(Pw[d]-2)%MOD*col[i][j][2]%MOD)%MOD;\n\t\t\t}\n\t\t\tans=(ans+col[i][j][2]*(Pw[i]-2)%MOD)%MOD;\n\t\t\trow[i][j][0]=(row[i][j][1]+row[i][j][2])%MOD;\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t{\n\t\t\t\tint d=j-k;\n\t\t\t\tcol[i][k][1]=(col[i][k][1]+C(j,d)*(row[i][j][2]*2+row[i][j][1])%MOD)%MOD;\n\t\t\t\tcol[i][k][2]=(col[i][k][2]+C(j,d)*(Pw[d]-2)%MOD*row[i][j][2]%MOD)%MOD;\n\t\t\t}\n\t\t\tans=(ans+row[i][j][2]*(Pw[j]-2)%MOD)%MOD;\n\t\t}\n\tfor(int i=1;i<(1<<n);i++)\n\t\tfor(int j=1;j<(1<<m);j++)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\tif(i&(1<<k))\n\t\t\t\t{\n\t\t\t\t\tint w=r[k]&j;\n\t\t\t\t\tif(w==j||w==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tfor(int k=0;k<m;k++)\n\t\t\t\tif(j&(1<<k))\n\t\t\t\t{\n\t\t\t\t\tint w=c[k]&i;\n\t\t\t\t\tif(w==i||w==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tint x=__builtin_popcount(i),y=__builtin_popcount(j);\n\t\t\tans=(ans+(row[x][y][0]+col[x][y][0])%MOD*ksm(C(n,x),MOD-2)%MOD*ksm(C(m,y),MOD-2)%MOD)%MOD;\n\t\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint bitCount(int t){\n    int res = 0;\n    for(int i=t;i;i&=i-1) res++;\n    return res;\n}\n\nint main(){\n    const int maxSize = 101;\n\tvector<long long> inv(maxSize);\n\tvector<long long> fact(maxSize);\n\tvector<long long> factInv(maxSize);\n\tfor(int i=0;i<2;i++) inv[i] = fact[i] = factInv[i] = 1;\n\tfor(int i=2;i<maxSize;i++){\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tfactInv[i] = factInv[i-1] * inv[i] % MOD;\n\t}\n\tauto comb = [&](int n, int r){\n\t\tif(n < r || r < 0) return 0LL;\n\t\treturn fact[n] * factInv[n-r] % MOD * factInv[r] % MOD;\n\t};\n    auto perm = [&](int n, int r){\n        if(n < r || r < 0) return 0LL;\n        return fact[n] * factInv[n-r] % MOD;\n    };\n    int H, W;\n    vector<vector<vector<long long>>> stair(2, vector<vector<long long>>(11, vector<long long>(11, 0)));\n    stair[0][0][0] = stair[1][0][0] = 1;\n    for(int i=0;i<=10;i++){\n        for(int j=0;j<=10;j++){\n            for(int k=j+1;k<=10;k++){\n                stair[1][i][k] += stair[0][i][j] * perm(k, k-j) % MOD * factInv[k-j];\n                stair[1][i][k] %= MOD;\n            }\n            for(int k=i+1;k<=10;k++){\n                stair[0][k][j] += stair[1][i][j] * perm(k, k-i) % MOD * factInv[k-i];\n                stair[0][k][j] %= MOD;\n            }\n        }\n    }\n    vector<vector<long long>> stairSum(11, vector<long long>(11, 0));\n    for(int i=0;i<=10;i++){\n        for(int j=0;j<=10;j++){\n            stairSum[i][j] = (stair[0][i][j] + stair[1][i][j]) % MOD;\n        }\n    }\n    stairSum[0][0] = 1;\n    vector<vector<long long>> val(11, vector<long long>(11, 0));\n    for(int i=0;i<=10;i++){\n        for(int j=0;j<=10;j++){\n            for(int bi=0;bi<=i;bi++){\n                for(int bj=0;bj<=j;bj++){\n                    int wi = i - bi;\n                    int wj = j - bj;\n                    val[i][j] += stairSum[wi][bj] * stairSum[bi][wj] % MOD * comb(i, bi) % MOD * comb(j, bj) % MOD;\n                    val[i][j] %= MOD;\n                }\n            }\n        }\n    }\n    while(cin >> H >> W){\n        vector<string> A(H);\n        for(auto& s : A) cin >> s;\n        long long res = stairSum[H][W];\n        for(int mh=0;mh<(1<<H)-1;mh++){\n            for(int mw=0;mw<(1<<W)-1;mw++){\n                bool check = true;\n                for(int i=0;i<H;i++){\n                    if(mh&(1<<i)) continue;\n                    bool ok = false;\n                    char c = ' ';\n                    for(int j=0;j<W;j++){\n                        if(mw&(1<<j)) continue;\n                        if(c == ' ') c = A[i][j];\n                        else if(c != A[i][j]) ok = true;\n                    }\n                    if(!ok) check = false;\n                }\n                for(int j=0;j<W;j++){\n                    if(mw&(1<<j)) continue;\n                    bool ok = false;\n                    char c = ' ';\n                    for(int i=0;i<H;i++){\n                        if(mh&(1<<i)) continue;\n                        if(c == ' ') c = A[i][j];\n                        else if(c != A[i][j]) ok = true;\n                    }\n                    if(!ok) check = false;\n                }\n                if(check){\n                    res += val[bitCount(mh)][bitCount(mw)];\n                    res %= MOD;\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar grid[15][15];\n\nint A[15][15];\nint B[15][15];\n\nlong long MOD = 998244353;\n\nint H, W;\n\nlong long dfs(int i){\n    if(i == H){return 1;}\n\n    long long ans = 0;\n    for(int j = 0; j < (1<<W); j ++){\n        for(int k = 0; k < W; k ++){\n            if(j&(1<<k)){\n                B[i][k] = 1;\n            }else{\n                B[i][k] = 0;\n            }\n        }\n\n        bool boleh = true;\n\n        for(int x1 = 0; x1 <= i; x1 ++){\n            for(int x2 = x1+1; x2 <= i; x2 ++){\n                for(int y1 = 0; y1 < W; y1 ++){\n                    for(int y2 = y1+1; y2 < W; y2 ++){\n                        if( (B[x1][y1] == 1 && B[x2][y1] == 0 && B[x1][y2] == 0 && B[x2][y2] == 1)\n                           || (B[x1][y1] == 0 && B[x2][y1] == 1 && B[x1][y2] == 1 && B[x2][y2] == 0) ){\n                            if(B[x1][y1] == A[x1][y1] && B[x1][y2] == A[x1][y2] &&\n                               B[x2][y1] == A[x2][y1] && B[x2][y2] == A[x2][y2]){\n                            }else{\n                                boleh = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if(boleh){\n            ans += dfs(i+1);\n        }\n    }\n    return ans%MOD;\n}\n\nint main(){\n    scanf(\"%d%d\", &H, &W);\n\n    for(int i = 0; i < H; i ++){\n        scanf(\" %s\", grid[i]);\n    }\n\n    for(int i = 0; i < H; i ++){\n        for(int j = 0; j < W; j ++){\n            A[i][j] = grid[i][j] == '#';\n        }\n    }\n\n    //assert(H*W < 31);\n\n    /*long long ans = 0;\n    for(int i = 0; i < 1<<(H*W); i ++){\n\n        int cnt = 0;\n        for(int j = 0; j < H; j ++){\n            for(int k = 0; k < W; k ++){\n                B[j][k] = (i&(1<<cnt)) >> cnt;\n                cnt ++;\n            }\n        }\n\n        bool boleh = true;\n\n        for(int x1 = 0; x1 < H; x1 ++){\n            for(int x2 = x1+1; x2 < H; x2 ++){\n                for(int y1 = 0; y1 < W; y1 ++){\n                    for(int y2 = y1+1; y2 < W; y2 ++){\n                        if( (B[x1][y1] == 1 && B[x2][y1] == 0 && B[x1][y2] == 0 && B[x2][y2] == 1)\n                           || (B[x1][y1] == 0 && B[x2][y1] == 1 && B[x1][y2] == 1 && B[x2][y2] == 0) ){\n                            if(B[x1][y1] == A[x1][y1] && B[x1][y2] == A[x1][y2] &&\n                               B[x2][y1] == A[x2][y1] && B[x2][y2] == A[x2][y2]){\n                            }else{\n                                boleh = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if(boleh){\n            ans ++;\n        }\n    }\n\n    ans %= MOD;\n    printf(\"%lld\\n\", ans);*/\n    printf(\"%lld\", dfs(0));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 998244353;\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nconst int MAXN = 15;\nMint dp[MAXN][MAXN][2][3];\nMint binom[MAXN][MAXN], p2[MAXN], val[MAXN][MAXN];\nchar G[MAXN][MAXN];\nint main() {\n\tp2[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i) p2[i] = p2[i - 1] * 2;\n\tfor (int i = 0; i < MAXN; ++i)\n\t\tfor (int j = 0; j <= i; ++j)\n\t\t\tif (!j || j == i) binom[i][j] = 1;\n\t\t\telse binom[i][j] = binom[i - 1][j - 1] + binom[i - 1][j];\n\tint H, W;\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; ++i) scanf(\"%s\", G[i]);\n\tauto calc = [&](bool mustEndWithRow, bool mustEndWithCol) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0][0][1] = 1;\n\t\tfor (int r = 0; r <= H; ++r)\n\t\t\tfor (int c = 0; c <= W; ++c) {\n\t\t\t\tif (!r && !c) continue;\n\t\t\t\tif (!r) {\n\t\t\t\t\tif (!mustEndWithRow) {\n\t\t\t\t\t\tdp[r][c][1][2] = p2[c] - 2;\n\t\t\t\t\t\tif (!mustEndWithCol) dp[r][c][1][1] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!c) {\n\t\t\t\t\tif (!mustEndWithCol) {\n\t\t\t\t\t\tdp[r][c][0][2] = p2[r] - 2;\n\t\t\t\t\t\tif (!mustEndWithRow) dp[r][c][0][1] = 2;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int rr = 1; rr <= r; ++rr) {\n\t\t\t\t\tdp[r][c][0][2] += (dp[r - rr][c][1][1] + dp[r - rr][c][1][2]) * binom[r][rr] * (p2[rr] - 2);\n\t\t\t\t\tdp[r][c][0][1] += dp[r - rr][c][1][1] * binom[r][rr];\n\t\t\t\t}\n\t\t\t\tfor (int cc = 1; cc <= c; ++cc) {\n\t\t\t\t\tdp[r][c][1][2] += (dp[r][c - cc][0][1] + dp[r][c - cc][0][2]) * binom[c][cc] * (p2[cc] - 2);\n\t\t\t\t\tdp[r][c][1][1] += dp[r][c - cc][0][1] * binom[c][cc];\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int r = H; r >= 1; --r)\n\t\t\tfor (int c = 1; c <= W; ++c) {\n\t\t\t\tdp[r][c][0][1] = 0;\n\t\t\t\tfor (int rr = 1; rr <= r; ++rr) {\n\t\t\t\t\tdp[r][c][0][1] += (dp[r - rr][c][1][1] + dp[r - rr][c][1][2]) * binom[r][rr] * 2;\n\t\t\t\t}\n\t\t\t}\n\t};\n\tcalc(false, false);\n\tfor (int r = 0; r < H; ++r)\n\t\tfor (int c = 0; c < W; ++c)\n\t\t\tval[r][c] = dp[r][c][0][2] + dp[r][c][1][2] + dp[r][c][1][1] + dp[r][c][0][1];\n\tcalc(true, false);\n\tfor (int c = 0; c < W; ++c)\n\t\tval[H][c] = dp[H][c][0][2] + dp[H][c][1][2] + dp[H][c][1][1] + dp[H][c][0][1];\n\tcalc(false, true);\n\tfor (int r = 0; r < H; ++r)\n\t\tval[r][W] = dp[r][W][0][2] + dp[r][W][1][2] + dp[r][W][1][1] + dp[r][W][0][1];\n\tMint ans = 0;\n\tfor (int i = 0; i < (1 << H); ++i) {\n\t\tfor (int j = 0; j < (1 << W); ++j) {\n\t\t\tbool bad = false;\n\t\t\tfor (int r = 0; r < H; ++r) {\n\t\t\t\tif (i & (1 << r)) continue;\n\t\t\t\tint has = 0;\n\t\t\t\tfor (int c = 0; c < W; ++c) {\n\t\t\t\t\tif (j & (1 << c)) continue;\n\t\t\t\t\thas |= (G[r][c] == '.') + 1;\n\t\t\t\t}\n\t\t\t\tif (has && has < 3) bad = true;\n\t\t\t}\n\t\t\tfor (int c = 0; c < W; ++c) {\n\t\t\t\tif (j & (1 << c)) continue;\n\t\t\t\tint has = 0;\n\t\t\t\tfor (int r = 0; r < H; ++r) {\n\t\t\t\t\tif (i & (1 << r)) continue;\n\t\t\t\t\thas |= (G[r][c] == '.') + 1;\n\t\t\t\t}\n\t\t\t\tif (has && has < 3) bad = true;\n\t\t\t}\n\t\t\tif (bad) continue;\n\t\t\tint nr = __builtin_popcount(i);\n\t\t\tint nc = __builtin_popcount(j);\n\t\t\tif (nr == H && nc == W) continue;\n\t\t\tans += val[nr][nc];\n\t\t}\n\t}\n\tans += 2;\n\tprintf(\"%d\\n\", ans.val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,n) for(int i=(0);i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nnamespace{\n\tconst int mod=998244353;\n\tint fix(int x){\n\t\treturn x>=mod?x-mod:x;\n\t}\n\ttemplate<class... T> int fix(int x,T... y){ \n\t\treturn (ll)x*fix(y...)%mod;\n\t}\n\tvoid add(int &x,int y){\n\t\tx=(x+y>=mod?x+y-mod:x+y);\n\t}\n}\n\nconst int N=12;\nint C[N][N],pw[N],f[2][N][N],r[N],c[N],n,m,ans;\nchar s[N];\n\nvoid init(int n){\n\tC[0][0]=1,pw[0]=1;\n\trep(i,1,n){\n\t\tC[i][0]=1,pw[i]=fix(pw[i-1],2);\n\t\trep(j,1,i) C[i][j]=fix(C[i-1][j-1]+C[i-1][j]);\n\t}\n\tREP(t,2){\n\t\trep(i,0,n) rep(j,0,n)\n\t\t\tif(!i||!j) f[t][i][j]=(t?pw[i+j]:1);\n\t\trep(i,1,n) rep(j,1,n){\n\t\t\trep(k,1,i) add(f[t][i][j],\n\t\t\t\tfix(k&1?1:mod-1,C[i][k],pw[k],f[t][i-k][j]));\n\t\t\trep(k,1,j) add(f[t][i][j],\n\t\t\t\tfix(k&1?1:mod-1,C[j][k],pw[k],f[t][i][j-k]));\n\t\t\trep(k,1,i) rep(l,1,j) add(f[t][i][j],\n\t\t\t\tfix((k+l)&1?2:mod-2,C[i][k],C[j][l],f[t][i-k][j-l]));\n\t\t}\n\t}\n}\n\nint main(){\n\tinit(10),cin>>n>>m;\n\trep(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\trep(j,1,m) if(s[j]=='#')\n\t\t\tr[i-1]|=1<<(j-1),c[j-1]|=1<<(i-1);\n\t}\n\trep(s,1,(1<<n)-1)\n\t\trep(t,1,(1<<m)-1){\n\t\t\tint flag=0,a=0,b=0;\n\t\t\tREP(i,n) if(s>>i&1) a++,\n\t\t\t\tflag|=(r[i]&t)==t||((~r[i])&t)==t;\n\t\t\tREP(i,m) if(t>>i&1) b++,\n\t\t\t\tflag|=(c[i]&s)==s||((~c[i])&s)==s;\n\t\t\tif(!flag) add(ans,f[1][n-a][m-b]);\n\t\t}\n\tcout<<fix(ans+f[0][n][m])<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 998244353;\n\nint madd(int a, int b) {\n\tint res = a + (b < 0 ? b + MOD : b);\n\treturn (res >= MOD ? res - MOD : res);\n}\n\nconst int N = 10;\nconst int M = 1 << N;\nint col[N][N];\nint dp[M][M];\nint alts[M * M][2*N+1];\n\nbool check(int m0, int m1) {\n\tvector<int> rc(N, 0), cc(N, 0);\n\tfor (int y = 0; y < N; ++y) {\n\t\tif (! (m0 & (1 << y))) rc[y] = 3;\n\t}\n\tfor (int x = 0; x < N; ++x) {\n\t\tif (! (m1 & (1 << x))) cc[x] = 3;\n\t}\n\tfor (int y = 0; y < N; ++y) {\n\t\tif (! (m0 & (1 << y))) continue;\n\t\tfor (int x = 0; x < N; ++x) {\n\t\t\tif (! (m1 & (1 << x))) continue;\n\t\t\trc[y] |= col[y][x];\n\t\t\tcc[x] |= col[y][x];\n\t\t}\n\t}\n\tbool works = true;\n\tfor (auto v : rc) works &= (v == 3);\n\tfor (auto v : cc) works &= (v == 3);\n\treturn works;\n}\n\n// Calculate alternating sum over submasks\nint altSum(int m0, int m1) {\n\tint m = m0 | (m1 << N);\n\talts[m][2*N] = dp[m0][m1];\n\tfor (int j = 2*N - 1; j >= 0; --j) {\n\t\tif (m & (1 << j)) {\n\t\t\talts[m][j] = madd(alts[m][j+1], -alts[m ^ (1 << j)][j+1]);\n\t\t} else {\n\t\t\talts[m][j] = alts[m][j+1];\n\t\t}\n\t}\n\treturn alts[m][0];\n}\n\n// Set value of DP at mask m0 m1 val.\nvoid setDP(int m0, int m1, int val) {\n\tdp[m0][m1] = val;\n\taltSum(m0, m1);\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint h, w;\n\tcin >> h >> w;\n\tfor (int y = 0; y < h; ++y) {\n\t\tstring row;\n\t\tcin >> row;\n\t\tfor (int x = 0; x < w; ++x) col[y][x] = 1 + (row[x] == '#');\n\t}\n\n\t// If any operations are applied, then some rows or some columns must be completely black or white\n\t// Delete those columns and rows and solve recursively. We need to do inclusion-exclusion to not double-count solutions.\n\t// Where does the initial state of the grid matter? If in some subgrid we have no completely black or white columns or rows,\n\t// we can add one to the solution for that subgrid!\n\t// To calculate the answer sufficiently fast, we'll need to do some prefix sums.\n\n\tint h0 = 1 << h;\n\tint h1 = 1 << w;\n\tfor (int m0 = 0; m0 < h0; ++m0) {\n\t\tsetDP(m0, 0, 1);\n\t}\n\tfor (int m1 = 0; m1 < h1; ++m1) {\n\t\tsetDP(0, m1, 1);\n\t}\n\n\tfor (int m0 = 0; m0 < h0; ++m0) {\n\t\tint rc = __builtin_popcount(m0);\n\t\tif (rc == 0) continue;\n\t\tfor (int m1 = 0; m1 < h1; ++m1) {\n\t\t\tint cc = __builtin_popcount(m1);\n\t\t\tif (cc == 0) continue;\n\n\t\t\tint res = check(m0, m1);\n\t\t\t// Inclusion-exclusion, paint only multiple rows\n\t\t\tfor (int s0 = m0;; s0 = (s0 - 1) & m0) {\n\t\t\t\tint pw = rc - __builtin_popcount(s0);\n\t\t\t\tif (pw > 1) {\n\t\t\t\t\tll mult = (ll)(pw & 1 ? 1 : MOD - 1) * ((1 << pw) - 2) % MOD;\n\t\t\t\t\tres = (res + (ll)mult * dp[s0][m1]) % MOD;\n\t\t\t\t}\n\t\t\t\tif (s0 == 0) break;\n\t\t\t}\n\t\t\t// Inclusion-exclusion, paint only multiple columns\n\t\t\tfor (int s1 = m1;; s1 = (s1 - 1) & m1) {\n\t\t\t\tint pw = cc - __builtin_popcount(s1);\n\t\t\t\tif (pw > 1) {\n\t\t\t\t\tll mult = (ll)(pw & 1 ? 1 : MOD - 1) * ((1 << pw) - 2) % MOD;\n\t\t\t\t\tres = (res + (ll)mult * dp[m0][s1]) % MOD;\n\t\t\t\t}\n\t\t\t\tif (s1 == 0) break;\n\t\t\t}\n\n\n\t\t\t// Inclusion-exclusion, paint both rows and columns\n\t\t\tint add = MOD - altSum(m0, m1);\n\t\t\tadd = madd(add, add);\n\t\t\tres = madd(res, add);\n\n\t\t\tsetDP(m0, m1, res);\n\t\t}\n\t}\n\tcout << dp[h0-1][h1-1] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "kyomukyomupurin"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n\nset<vector<string>> allfi, allnotin, allbein;\nvoid rec(vector<string> fi, set<int> &yoko, set<int> &tate, bool bein, int H, int W) {\n    if (yoko.size() == H && tate.size() == W) {\n        allfi.insert(fi);\n        if (bein) allbein.insert(fi);\n        else allnotin.insert(fi);\n    }\n    auto ifi = fi;\n    for (int h = 0; h < H; ++h) {\n        if (yoko.count(h)) continue;\n        yoko.insert(h);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '.';\n        rec(fi, yoko, tate, bein, H, W);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '#';\n        rec(fi, yoko, tate, (bein || (tate.empty() && true)), H, W);\n        fi = ifi;\n        yoko.erase(h);\n    }\n    for (int w = 0; w < W; ++w) {\n        if (tate.count(w)) continue;\n        tate.insert(w);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '.';\n        rec(fi, yoko, tate, bein, H, W);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '#';\n        rec(fi, yoko, tate, (bein || (yoko.empty() && true)), H, W);\n        fi = ifi;\n        tate.erase(w);\n    }\n}\n\nset<vector<string>> allsub;\nvoid rec2(vector<string> fi, set<int> &yoko, set<int> &tate, int H, int W) {\n    if (yoko.size() == H && tate.size() == W) {\n        allsub.insert(fi);\n    }\n    auto ifi = fi;\n    for (int h = 0; h < H; ++h) {\n        if (yoko.count(h)) continue;\n        yoko.insert(h);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '.';\n        rec2(fi, yoko, tate, H, W);\n        fi = ifi;\n        yoko.erase(h);\n    }\n    for (int w = 0; w < W; ++w) {\n        if (tate.count(w)) continue;\n        tate.insert(w);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '#';\n        rec2(fi, yoko, tate, H, W);\n        fi = ifi;\n        tate.erase(w);\n    }\n}\n\nlong long calc(int H, int W) {\n    allfi.clear();\n    allnotin.clear(), allbein.clear();\n    set<int> yoko, tate;\n    vector<string> fi(H+1, string(W+1, '.'));\n    auto fi2 = fi;\n    rec(fi, yoko, tate, false, H, W);\n    return allfi.size();\n}\n\nlong long calc2(int H, int W) {\n    set<int> yoko, tate;\n    vector<string> fi(H+1, string(W+1, '.'));\n    allsub.clear();\n    rec2(fi, yoko, tate, H, W);\n    return allsub.size();\n}\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nint H, W;\nvector<string> A;\n\nint main() {\n    bc.init(110);\n\n    // 長方形\n    vector<vector<mint>> all(15, vector<mint>(15, 0));\n    auto bein = all;\n    auto notin = all;\n    for (int i = 0; i < 15; ++i) all[0][i] = all[i][0] = modpow(mint(2), i);\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            notin[a][b] = 1;\n            for (int i = 1; i < a; ++i) {\n                for (int j = 1; j < b; ++j) {\n                    notin[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n        }\n    }\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            bein[a][b] = 1;\n            for (int i = 0; i < a; ++i) {\n                for (int j = 0; j < b; ++j) {\n                    if (i + j == 0) continue;\n                    bein[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n            all[a][b] = notin[a][b] + bein[a][b];\n        }\n    }\n\n    // はみ出しあり\n    vector<vector<mint>> subsub(15, vector<mint>(15, 0));\n    auto sub = subsub, part = subsub;\n    for (int i = 0; i < 15; ++i) {\n        subsub[1][i] = 1;\n        subsub[i][1] = modpow(mint(2), i) - 1;\n    }\n    for (int s = 2; s < 30; ++s) {\n        for (int a = 1; a < 15; ++a) {\n            int b = s - a;\n            if (b < 1 || b >= 15) continue;\n            subsub[a][b] = 1;\n            for (int i = a-1; i >=1; i--) {\n                subsub[a][b] += bc.com(a, i) * subsub[a-i][b];\n            }\n        }\n    }\n    for (int a = 0; a < 15; ++a) {\n        for (int b = 0; b < 15; ++b) {\n            if (a == 0) sub[a][b] = 1;\n            else if (b == 0) sub[a][b] = 1;\n            else sub[a][b] = subsub[a][b] + subsub[b][a];\n        }\n    }\n\n    for (int i = 0; i < 15; ++i) part[0][i] = part[i][0] = modpow(mint(2), i);\n    for (int a = 1; a < 14; ++a) {\n        for (int b = 1; b < 14; ++b) {\n            for (int i = 0; i <= a; ++i) {\n                for (int j = 0; j <= b; ++j) {\n                    part[a][b] += bc.com(a, i) * bc.com(b, j) *\n                        sub[i][j] * sub[a-i][b-j];\n                }\n            }\n        }\n    }\n\n    /*\n    for (int a = 0; a <= 5; ++a) {\n        for (int b = 0; b <= 5; ++b) {\n            calc(a, b);\n            cout << a << \",\" << b << \": \" << part[a][b] << \"( \" << sub[a][b] << \" ), \" << allfi.size() << \", \" << calc2(a, b) << endl;\n        }\n    }\n    \n    \n    calc(1, 2);\n    COUT(allfi.size());\n    for (auto fi : allfi) {\n        for (auto s : fi) cout << s << endl;\n        cout << endl;\n    }\n    */\n    \n\n    cin >> H >> W;\n    A.resize(H);\n    for (int h = 0; h < H; ++h) cin >> A[h];\n\n    mint res = all[H][W];\n    for (int bit = 0; bit < (1<<H)-1; ++bit) {\n        vector<int> tate;\n        for (int i = 0; i < H; ++i) if (!(bit & (1<<i))) tate.push_back(i);\n        for (int bit2 = 0; bit2 < (1<<W)-1; ++bit2) {\n            vector<int> yoko;\n            for (int i = 0; i < W; ++i) if (!(bit2 & (1<<i))) yoko.push_back(i);\n\n            bool ok = true;\n            for (auto i : tate) {\n                set<char> se;\n                for (auto j : yoko) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n            for (auto j : yoko) {\n                set<char> se;\n                for (auto i : tate) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n\n            if (ok) {\n                int c = __builtin_popcount(bit);\n                int r = __builtin_popcount(bit2);\n                mint add = part[c][r];\n                res += add;\n\n                //cout << bit << \", \" << bit2 << \": \" << tate << \", \" << yoko << \";; \" << c << \", \" << r << \": \" << add << endl;\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define cs const\n#define re register\n#define pb push_back\n#define pii pair<int,int>\n#define ll long long\n#define y1 shinkle\n#define fi first\n#define se second\n#define bg begin\ncs int RLEN=1<<20|1;\ninline char gc(){\n    static char ibuf[RLEN],*ib,*ob;\n    (ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n    return (ib==ob)?EOF:*ib++;\n}\ninline int read(){\n    char ch=gc();\n    int res=0;bool f=1;\n    while(!isdigit(ch))f^=ch=='-',ch=gc();\n    while(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n    return f?res:-res;\n}\ninline ll readll(){\n    char ch=gc();\n    ll res=0;bool f=1;\n    while(!isdigit(ch))f^=ch=='-',ch=gc();\n    while(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n    return f?res:-res;\n}\ninline char readchar(){\n\tchar ch=gc();\n\twhile(isspace(ch))ch=gc();\n\treturn ch;\n}\ninline int readstring(char *s){\n\tint top=0;char ch=gc();\n\twhile(isspace(ch))ch=gc();\n\twhile(!isspace(ch)&&ch!=EOF)s[++top]=ch,ch=gc();\n\ts[top+1]='\\0';return top;\n}\ntemplate<typename tp>inline void chemx(tp &a,tp b){a=max(a,b);}\ntemplate<typename tp>inline void chemn(tp &a,tp b){a=min(a,b);}\ncs int mod=998244353;\ninline int add(int a,int b){return (a+b)>=mod?(a+b-mod):(a+b);}\ninline int dec(int a,int b){return (a<b)?(a-b+mod):(a-b);}\ninline int mul(int a,int b){static ll r;r=(ll)a*b;return (r>=mod)?(r%mod):r;}\ninline void Add(int &a,int b){a=(a+b)>=mod?(a+b-mod):(a+b);}\ninline void Dec(int &a,int b){a=(a<b)?(a-b+mod):(a-b);}\ninline void Mul(int &a,int b){static ll r;r=(ll)a*b;a=(r>=mod)?(r%mod):r;}\ninline int ksm(int a,int b,int res=1){for(;b;b>>=1,Mul(a,a))(b&1)&&(Mul(res,a),1);return res;}\ninline int Inv(int x){return ksm(x,mod-2);}\ninline int fix(ll x){x%=mod;return (x<0)?x+mod:x;}\ncs int N=12;\nint fac[N],ifac[N];\ninline void init_fac(){\n\tfac[0]=ifac[0]=1;\n\tfor(int i=1;i<N;i++)fac[i]=mul(fac[i-1],i);\n\tifac[N-1]=Inv(fac[N-1]);\n\tfor(int i=N-2;i;i--)ifac[i]=mul(ifac[i+1],i+1);\n}\ninline int C(int n,int m){return (n<m||n<0||m<0)?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}\ninline int IC(int n,int m){return (n<m||n<0||m<0)?0:mul(ifac[n],mul(fac[m],fac[n-m]));}\nint n,m,sl[N],sr[N],ln[N][N][3],rw[N][N][3],ans[N][N];\nchar str[N][N];\nint main(){\n\t#ifdef Stargazer\n\tfreopen(\"lx.in\",\"r\",stdin);\n\t#endif\n\tn=read(),m=read(),init_fac();\n\tfor(int i=1;i<=n;i++)readstring(str[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=m;j++)sl[i]+=(str[i][j]=='#')<<(j-1);\n\tfor(int i=1;i<=m;i++)\n\tfor(int j=1;j<=n;j++)sr[i]+=(str[j][i]=='#')<<(j-1);\n\tfor(int i=1;i<=n;i++)ln[i][m][2]=mul(C(n,i),1<<(n-i));\n\tint res=1<<n;\n\tfor(int i=n;i;i--)\n\tfor(int j=m;j;j--){\n\t\tans[i][j]=add(add(rw[i][j][1],rw[i][j][2]),add(ln[i][j][1],ln[i][j][2]));\n\t\tAdd(res,mul(rw[i][j][2],(1<<i)-2)),Add(res,mul(ln[i][j][2],(1<<j)-2));\n\t\tfor(int k=1;k<i;k++){\n\t\t\tAdd(ln[k][j][2],mul(rw[i][j][2],mul((1<<(i-k))-2,C(i,k))));\n\t\t\tAdd(ln[k][j][1],mul(add(mul(rw[i][j][2],2),rw[i][j][1]),C(i,k)));\n\t\t}\n\t\tfor(int k=1;k<j;k++){\n\t\t\tAdd(rw[i][k][2],mul(ln[i][j][2],mul((1<<(j-k))-2,C(j,k))));\n\t\t\tAdd(rw[i][k][1],mul(add(mul(ln[i][j][2],2),ln[i][j][1]),C(j,k)));\n\t\t}\n\t}\n\tfor(int i=1;i<(1<<n);i++)\n\tfor(int j=1;j<(1<<m);j++){\n\t\tint c1=0,c2=0,fg=0;\n\t\tfor(int k=1;k<=n&&!fg;k++)if(i&(1<<(k-1))){\n\t\t\tint sta=sl[k]&j;c1++;\n\t\t\tif(sta==j||sta==0)fg=1;\n\t\t}\n\t\tfor(int k=1;k<=m&&!fg;k++)if(j&(1<<(k-1))){\n\t\t\tint sta=sr[k]&i;c2++;\n\t\t\tif(sta==i||sta==0)fg=1;\n\t\t}\n\t\tif(fg)continue;\n\t\tAdd(res,mul(ans[c1][c2],mul(IC(n,c1),IC(m,c2))));\n\t}cout<<res<<'\\n';return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\nint h;\nint w;\n#define MAX 12\nchar room[MAX][MAX];\nbool us[MAX][MAX];\nint dp[MAX][MAX];\n\nbool use[MAX][MAX];\nint dp2[MAX][MAX];\n\nint dp3[MAX][MAX][2];\nvoid init(){\n\tdp3[0][0][0]=1;\n\tdp3[0][0][1]=1;\n\tfor(int i=0;i<=h;i++){\n\t\tfor(int j=0;j<=w;j++){\n\t\t\tint inv=1;\n\t\t\tfor(int go=j+1;go<=w;go++){\n\t\t\t\tmulto(inv,ppow(go-j,MOD-2));\n\t\t\t\taddto(dp3[i][go][0],mul(inv,dp3[i][j][1]));\t\n\t\t\t}\n\t\t\tinv=1;\n\t\t\tfor(int go=i+1;go<=h;go++){\n\t\t\t\tmulto(inv,ppow(go-i,MOD-2));\n\t\t\t\taddto(dp3[go][j][1],mul(inv,dp3[i][j][0]));\n\t\t\t}\n\t\t}\n\t}\n}\ninline int f(int a,int b){\n\tif(use[a][b])return dp[a][b];\n\tif(a==0||b==0){\n\t\t//cerr<<\"er\"<<endl;\n\t\t//puts(\"er\");\n\t\treturn 1;\n\t}\n\tuse[a][b]=true;\n\tint ret=add(dp3[a][b][0],dp3[a][b][1]);\n\tfor(int i=1;i<=max(a,b);i++){\n\t\tmulto(ret,i);\n\t\tif(i<=min(a,b)){\n\t\t\tmulto(ret,i);\n\t\t}\n\t}\n\treturn dp[a][b]=ret;\n}\n\ninline int solve(int a,int b){\n\ta=h-a;\n\tb=w-b;\n\tif(a==0&&b==0){\n\t\t//cerr<<\"ok4\"<<endl;\n\t\treturn 1;\n\t}\n\tif(us[a][b])return dp2[a][b];\n\tus[a][b]=true;\n\tif(a==0){\n\t\t//cerr<<\"OK\"<<endl;\n\t\treturn dp2[a][b]=ppow(2,b);\n\t}\n\tif(b==0){\n\t\t//cerr<<\"OK2\"<<endl;\n\t\treturn dp2[a][b]=ppow(2,a);\n\t}\n\tfor(int z1=0;z1<=a;z1++){\n\t\tfor(int z2=0;z2<=b;z2++){\n\t\t\taddto(dp2[a][b],mul(mul(C.C(a,z1),C.C(b,z2)),mul(f(a-z1,b-z2),f(z1,z2))));\n\t\t}\n\t}\n\treturn dp2[a][b];\n}\n\n\nint main(){\n\tcin>>h>>w;\n\tC.resize(100);\n\tinit();\n\tint ans=0;\n\tfor(int i=0;i<h;i++){\n\t\tscanf(\"%s\",room[i]);\n\t}\n\tfor(int i=1;i<(1<<h);i++){\n\t\tfor(int j=1;j<(1<<w);j++){\n\t\t\tint hh=0;\n\t\t\tint ww=0;\n\t\t\tbool nah=false;\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tif(!((i>>a)&1)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\thh++;\n\t\t\t\tint tmp=-1;\n\t\t\t\tww=0;\n\t\t\t\tbool ng=false;\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tif(!((j>>b)&1)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tww++;\n\t\t\t\t\tint col=(room[a][b]=='.');\n\t\t\t\t\tif(tmp==-1)tmp=col;\n\t\t\t\t\tif(tmp!=col){\n\t\t\t\t\t\tng=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ng==false){\n\t\t\t\t\tnah=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\tif(!((j>>b)&1)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint tmp=-1;\n\t\t\t\tbool ng=false;\n\t\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\t\tif(!((i>>a)&1)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint col=(room[a][b]=='.');\n\t\t\t\t\tif(tmp==-1)tmp=col;\n\t\t\t\t\tif(tmp!=col){\n\t\t\t\t\t\tng=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ng==false){\n\t\t\t\t\tnah=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nah)continue;\n\t\t\t//cerr<<hh<<\" \"<<ww<<\" \"<<solve(hh,ww)<<endl;\n\t\t\taddto(ans,solve(hh,ww));\n\t\t}\n\t}\n\taddto(ans,f(h,w));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod = 998244353;\ncat C[11][11];\n\nvoid count(int h, int w, char f_e, char f_h, char f_w, int & out, cat cur = 1) {\n\tif(h+w == 0) {\n\t\tout += cur;\n\t\tif(out >= mod) out -= mod;\n\t\treturn;\n\t}\n\tfor(int c = 0; c < 2; c++) for(int i = 0; i <= h; i++) for(int j = 0; j <= w; j++) if(i+j) {\n\t\tif((f_h>>c)&1 && i) break;\n\t\tif((f_w>>c)&1 && j) break;\n\t\tif(j && f_e&2 && c) break;\n\t\tif(i && f_e&4 && c) break;\n\t\tif(!(f_e&1)) if((h == i)^(w == j)) continue;\n\t\tcat x = C[h][i] * C[w][j] % mod;\n\t\tint n_h = f_h, n_w = f_w;\n\t\tif(i) n_w ^= n_w&(1<<(1-c));\n\t\tif(j) n_h ^= n_h&(1<<(1-c));\n\t\tn_h |= 1<<c;\n\t\tn_w |= 1<<c;\n\t\tint n_e = (f_e&1) + ((!i)<<1) + ((!j)<<2);\n\t\tcount(h-i, w-j, n_e, n_h, n_w, out, cur*x%mod);\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint H, W;\n\tcin >> H >> W;\n\tvector<int> V(H, 0);\n\tfor(int i = 0; i < H; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < W; j++)\n\t\t\tif(s[j] == '#') V[i] |= 1<<j;\n\t}\n\tmemset(C, 0, sizeof(C));\n\tfor(int i = 0; i <= 10; i++) {\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1; j <= i; j++)\n\t\t\tC[i][j] = (C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tint cnt[11][11];\n\tmemset(cnt, 0, sizeof(cnt));\n\tfor(int i = 0; i <= H; i++) for(int j = 0; j <= W; j++) if(i+j < 20)\n\t\tcount(i, j, (H-i) || (W-j), 0, 0, cnt[i][j]);\n\tcnt[10][10] = 710838430;\n\tcat ans = cnt[H][W];\n\tfor(int i = 0; i < (1<<H)-1; i++) {\n\t\tvector<int> Vr, Vc(W, 0);\n\t\tfor(int j = 0; j < H; j++)\n\t\t\tif(!((i>>j)&1)) Vr.push_back(V[j]);\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tfor(int k = 0; k < H; k++)\n\t\t\t\tif(!((i>>k)&1)) Vc[j] += ((V[k]>>j)&1)<<k;\n\t\t\tVc[j] = (!Vc[j]) || (Vc[j] == (1<<H)-1-i);\n\t\t}\n\t\tint n = H-Vr.size();\n\t\tfor(int j = 0; j < (1<<W)-1; j++) {\n\t\t\tint m = (1<<W)-1-j;\n\t\t\tbool ok = true;\n\t\t\tfor(int k = 0; k < H-n; k++) if(!(Vr[k]&m) || (Vr[k]&m) == m) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tfor(int k = 0; k < W; k++) if(!((j>>k)&1) && Vc[k]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tans += cnt[n][__builtin_popcount(j)];\n\t\t\tif(ans >= mod) ans -= mod;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int H, W; cin >> H >> W;\n    vector<string> A(H); cin >> A;\n\n    int n = H + W;\n    Combination C(n);\n    mmat sti(n + 1);\n    sti[0] = mvec(1, 1);\n    FOR(i, 1, n + 1){\n        sti[i].resize(i + 1);\n        sti[i][0] = 0;\n        FOR(j, 1, i) sti[i][j] = sti[i - 1][j - 1] + sti[i - 1][j] * j;\n        sti[i][i] = 1;\n    }\n\n    mmat dp(H + 1, mvec(W, 0));\n    dp[0][0] = 1;\n    REP(i, H){\n        REP(j, W){\n            dp[i + 1][j] += dp[i][j] * (j + 2);\n            if(j < W - 1) dp[i + 1][j + 1] += dp[i][j];\n        }\n    }\n    \n    mmat dq(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(k, w) dq[h][w] += dp[h][k] * sti[w][k + 1] * C.fact[k + 1] * C.fact[k];\n        if(w == 0) dq[h][w] = 1;\n    }\n\n    mmat dq2(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(i, h + 1) REP(j, w + 1){\n            dq2[h][w] += dq[i][w - j] * dq[h - i][j] * C.nCr(h, i) * C.nCr(w, j);\n        }\n    }\n    \n    mint ans = dq[H][W];\n\n    mat flgx(bit(H), vec(W, 0)), flgy(bit(W), vec(H, 0));\n    REP(x, bit(H)){\n        REP(j1, W) REP(j2, j1){\n            bool f = false;\n            \n            REP(i1, H) REP(i2, i1) if((x >> i1) & (x >> i2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgx[x][j1] ^= bit(j2);\n                flgx[x][j2] ^= bit(j1);\n            }\n        }\n    }\n\n    REP(y, bit(W)){\n        REP(i1, H) REP(i2, i1){\n            bool f = false;\n\n            REP(j1, W) REP(j2, j1) if((y >> j1) & (y >> j2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgy[y][i1] ^= bit(i2);\n                flgy[y][i2] ^= bit(i1);\n            }\n        }\n    }\n\n    REP(x, bit(H)) REP(y, bit(W)){\n        int tx = 0;\n        REP(i, H) if((x >> i) & 1) tx |= flgy[y][i];\n        int ty = 0;\n        REP(j, W) if((y >> j) & 1) ty |= flgx[x][j];\n\n        if(((x & tx) == x) && ((y & ty) == y)){\n            int h = H - __builtin_popcountll(x), w = W - __builtin_popcountll(y);\n            //cout << h << \",\" << w << endl;\n            if(h < H && w < W) ans += dq2[h][w]; \n        }\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return x.inv()*a;}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n  M pow(ll m) {\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\nusing mint = ModInt<998244353>;\n\nint H;\nint W;\nint hlim;\nint wlim;\nint rowb[14];\nint colb[14];\nint field[14][14];\nmint fact[100];\nmint tmp[14][14][2];\nvector<vector<mint>> dp;\nvector<vector<mint>> WB;\nvector<vector<mint>> BW;\n\nmint Comb(int n, int k) {\n  assert(0 <= k && k <= n);\n  return fact[n] / fact[k] / fact[n-k];\n}\n\n// Zeta Transform g(T)=\\sum_{S \\subset T}f(S)\ntemplate<class T, class F>\ninline void FZT(vector<T>&f,F add){\n  int n=__lg(f.size());\n  int lim = 1 << n;\n  rep(i, n) {\n    rep(j, lim) {\n      if (~j >> i & 1) f[j|1<<i]=add(f[j|1<<i],f[j]);\n    }\n  }\n}\n// Modoebius Transform g(T)=\\sum_{S \\subset T}(-1)^{|T\\S|}f(S)\ntemplate<class T,class F>\ninline void FMT(vector<T>&f,F sub){\n  int n=__lg(f.size());\n  int lim = 1 << n;\n  rep(i, n) {\n    rep(j, lim) {\n      if (~j >> i & 1) f[j|1<<i]=sub(f[j|1<<i],f[j]);\n    }\n  }\n}\n// O(nlog^2n) f*g(S)=\\sum_{U∪V=S, U∩V=\\emptyset } f(U)*g(V)\ntemplate<class T,class F>\ninline vector<vector<T>> RankedFZT(vector<T>&f,F add){\n  int n=__lg(f.size());\n  int lim = 1 << n;\n  vector<vector<T>> ret(n+1, vector<T>(f.size()));\n  rep(i, lim) ret[__builtin_popcount(i)][i] = f[i];\n  rep(i, n+1) FZT(ret[i], add);\n  return ret;\n}\ntemplate<class T,class F, class G>\ninline vector<T> ExactConv(vector<T>&f, vector<T>&g, F add, G sub) {\n  int n=__lg(f.size());\n  int lim = 1 << n;\n  auto rf = RankedFZT(f, add);\n  auto rg = RankedFZT(g, add);\n  vector<vector<T>> c(n+1, vector<T>(f.size()));\n  rep(k, n+1) {\n    rep(j, k+1) rep(st, lim) {\n      c[k][st] += rf[j][st]*rg[k-j][st];\n    }\n    FZT(c[k], sub);\n  }\n  vector<T> ret(lim);\n  rep(i, lim) ret[i] = c[__builtin_popcount(i)][i];\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  fact[0] = 1;\n  reps(i, 1, 100) {\n    fact[i] = fact[i-1] * i;\n  }\n\n  cin >> H >> W;\n  hlim = 1 << H;\n  wlim = 1 << W;\n  rep(i, H) {\n    rep(j, W) {\n      char c;\n      cin >> c;\n      if (c == '#') field[i][j] = 1;\n      else if (c == '.') field[i][j] = 0;\n      else assert(0);\n    }\n  }\n  rep(i, H) {\n    rrep(j, W) rowb[i] = (rowb[i] << 1) | field[i][j];\n  }\n  rep(j, W) {\n    rrep(i, H) colb[j] = (colb[j] << 1) | field[i][j];\n  }\n\n  tmp[0][0][0] = 1;\n  tmp[0][0][1] = 1;\n  rep(i, H+1) {\n    rep(j, W+1) {\n      reps(k, 1, H+1) {\n        if (i+k > H) break;\n        tmp[i+k][j][1] += tmp[i][j][0] * Comb(i+k, k);\n      }\n      reps(k, 1, W+1) {\n        if (j+k > W) break;\n        tmp[i][j+k][0] += tmp[i][j][1] * Comb(j+k, k);\n      }\n    }\n  }\n  dp.resize(hlim, vector<mint>(wlim));\n  rep(i, H+1) {\n    rep(j, W+1) {\n      dp[i][j] = tmp[i][j][0] + tmp[i][j][1];\n    }\n  }\n  dp[0][0] = 1;\n  \n  vector<mint> f(hlim*wlim);\n  rep(hst, hlim) {\n    rep(wst, wlim) {\n      int hcnt = __builtin_popcount(hst);\n      int wcnt = __builtin_popcount(wst);\n      f[(hst << W) | wst] = dp[hcnt][wcnt];\n    }\n  }\n  auto conv = ExactConv(f, f, [](mint a, mint b){return a+b;}, [](mint a, mint b){return a-b;});\n  //rep(hst, hlim) {\n  //  rep(wst, wlim) {\n  //    cout << \"c[\" << hst << \", \" << wst << \"]: \" << conv[(hst << W) | wst].a;\n  //    cout << endl;\n  //  }\n  //}\n\n  mint ans = 0;\n  rep(hst, hlim) {\n    rep(wst, wlim) {\n      bool ng = 0;\n      int hexc = ~hst & (hlim-1);\n      int wexc = ~wst & (wlim-1);\n      rep(j, W) {\n        if (wst >> j & 1) continue;\n        if ((colb[j] & hexc) == hexc) ng = 1;\n        if ((~colb[j] & hexc) == hexc) ng = 1;\n      }\n      rep(i, H) {\n        if (hst >> i & 1) continue;\n        if ((rowb[i] & wexc) == wexc) ng = 1;\n        if ((~rowb[i] & wexc) == wexc) ng = 1;\n      }\n      if (hst == hlim-1 && wst == wlim-1) ans += dp[H][W];\n      else if (!ng) ans += conv[(hst << W) | wst];\n    }\n  }\n  cout << ans.a << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//it's nice to stick a fork into an open socket\n//clock says it's time to sleep\n//our getppid() in heaven, hallowed by ttyname\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define FOR(i,b,e)for(urs((b)+(e))i=(b);i<=(e);++i)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define FORD(i,b,e)for(urs((b)+(e))i=(b);i>=(int)(e);--i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define FS(r)r.first,r.second\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim>using ordered_set=tree<c,null_type,less<c>,rb_tree_tag,tree_order_statistics_node_update>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#ifdef LOCAL\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=a*(ld)b/m;ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\n#define q31 (8 * sizeof(c) - 1)\nsim> typename enable_if<is_signed<c>::value, c>::type FastMax(c x, c y) { return ((x - y) >> q31 & (x ^ y)) ^ x; }\nsim> typename enable_if<is_signed<c>::value, c>::type FastMin(c x, c y) { return ((x - y) >> q31 & (x ^ y)) ^ y; }\nsim> typename enable_if<is_signed<c>::value, c>::type FastAbs(c x)        { return (x ^ x >> q31) - (x >> q31); }\nsim> typename enable_if<is_signed<c>::value, c>::type gcd(c a, c b) {\n\tloc(assert(a > 0 && b > 0));\n\tint aa = ctz(a), bb = ctz(b);\n\tint r = FastMin(aa, bb);\n\ta >>= aa;\n\twhile (a && b) {\n\t\tb >>= ctz(b);\n\t\tc x = FastAbs(a - b);\n\t\ta = FastMin(a, b);\n\t\tb = x;\n\t}\n\treturn (a + b) << r;\n}\nsim> c lcm(c a, c b) {return a / gcd(a, b) * b;}\nsim>typename enable_if<is_integral<c>::value,ull>::type my_hash(c x){\n\tif(sizeof(c)>8) return mix((ull)x^SALT)^mix((ull)(x>>64)^SALT);\n\treturn mix(x^SALT);\n}\ntemplate<size_t N>ull my_hash(const bitset<N>&x){\n\treturn mix(hash<bitset<N>>()(x)^SALT);\n}\nsim,class n>ull my_hash(const pair<c,n>&);\nsim>gyv<ull,typename c::value_type>my_hash(const c&x){\n\tull o=SALT;\n\tfor(auto&d:x)o=mix(o^my_hash(d));\n\tros;\n}\nsim,class n>ull my_hash(const pair<c,n>&x){return mix(my_hash(x.first))^my_hash(x.second);}\nsim>struct my_hasher{size_t operator()(const c&o)const{return my_hash(o);}};\nsim, class m>\n#ifdef LOCAL\nusing _un0rDer3d_M4P=unordered_map<c,m,my_hasher<c>>;\nsim> using _un0rDer3d_5et = unordered_set<c, my_hasher<c>>;\n#else\nstruct _un0rDer3d_M4P : public cc_hash_table<c,m,my_hasher<c>>{bool count(const c&x)const{return this->find(x) != this->end();}};\nsim> using _un0rDer3d_5et = _un0rDer3d_M4P<c, null_type>;\n#endif\n#define unordered_map _un0rDer3d_M4P\n#define unordered_set _un0rDer3d_5et\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\nconst int mod = 119 << 23 | 1, nax = 21;\nint ans[2][nax][nax];\nint dp[nax][nax][16];\nint cho[nax][nax];\nvoid calc_dp() {\n\tREP(type, 2) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0][0] = 1;\n\t\tif (type == 0) {\n\t\t\tFOR(i, 1, nax - 1)\n\t\t\t\tdp[i][0][12] = 1;\n\t\t\tFOR(i, 1, nax - 1)\n\t\t\t\tdp[0][i][3] = 1;\n\t\t}\n\t\telse {\n\t\t\tFOR(i, 1, nax - 1) {\n\t\t\t\tdp[i][0][12] = (1 << i) - 2;\n\t\t\t\tdp[i][0][4] = 1;\n\t\t\t\tdp[i][0][8] = 1;\n\t\t\t\tdp[0][i][3] = (1 << i) - 2;\n\t\t\t\tdp[0][i][2] = 1;\n\t\t\t\tdp[0][i][1] = 1;\n\t\t\t}\n\t\t}\n\t\tFOR(h, 1, nax - 1) FOR(w, 1, nax - 1) {\n\t\t\tFOR(m, 1, 15) {\n\t\t\t\tbool wc = (m >> 0 & 1), bc = (m >> 1 & 1), wr = (m >> 2 & 1), br = (m >> 3 & 1);\n\t\t\t\tif (wc && br) continue;\n\t\t\t\tif (bc && wr) continue;\n\t\t\t\t// if (h == 1 && w == 1) debug(imie(m), imask(m));\n\t\t\t\tint poss = 0;\n\t\t\t\tif (wc) poss |= 1 << 3;\n\t\t\t\tif (bc) poss |= 1 << 2;\n\t\t\t\tif (wr) poss |= 1 << 1;\n\t\t\t\tif (br) poss |= 1 << 0;\n\t\t\t\t// debug(imask(m), imask(poss));\n\t\t\t\tFOR(wcs, wc ? 1 : 0, wc ? w : 0) FOR(bcs, bc ? 1 : 0, bc ? w : 0) if (bcs + wcs <= w)\n\t\t\t\t\tFOR(wrs, wr ? 1 : 0, wr ? h : 0) FOR(brs, br ? 1 : 0, br ? h : 0) if (wrs + brs <= h) {\n\t\t\t\t\t\tint ways = cho[w][wcs] * 1ll *\n\t\t\t\t\t\t\tcho[w - wcs][bcs] % mod *\n\t\t\t\t\t\t\tcho[h][wrs] % mod *\n\t\t\t\t\t\t\tcho[h - wrs][brs] % mod;\n\t\t\t\t\t\tassert(ways);\n\t\t\t\t\t\tint mul = 0;\n\t\t\t\t\t\tfor (int sub = poss; ; sub = (sub - 1) & poss) {\n\t\t\t\t\t\t\t// debug(arr(dp, h - wrs - brs, w - wcs - bcs, imask(sub)));\n\t\t\t\t\t\t\tmul += dp[h - wrs - brs][w - wcs - bcs][sub];\n\t\t\t\t\t\t\tif (mul >= mod) mul -= mod;\n\t\t\t\t\t\t\tif (!sub) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if (ways || mul) debug(imask(m), imie(mul), imie(ways), imie(wcs), imie(bcs), imie(wrs), imie(brs));\n\t\t\t\t\t\tdp[h][w][m] = (dp[h][w][m] + ways * 1ll * mul) % mod;\n\t\t\t\t\t}\n\t\t\t\t// if (dp[h][w][m])\n\t\t\t\t\t// debug(arr(dp, h, w, imask(m)));\n\t\t\t\tans[type][h][w] += dp[h][w][m];\n\t\t\t\tif (ans[type][h][w] >= mod) ans[type][h][w] -= mod;\n\t\t\t}\n\t\t\t// debug(arr(ans, type, h, w));\n\t\t}\n\t}\n\tans[1][0][0] = 1;\n\tFOR(i, 1, nax - 1) ans[1][0][i] = ans[1][i][0] = (1 << i);\n}\nvoid test() {\n#define check(i, j, v) if (i < nax && j < nax && ans[0][i][j] != v) debug(arr(ans[0], i, j), \"expected\", v);\n\tcheck(20, 1,1048576);\n\tcheck(19, 1,524288);\n\tcheck(18, 1,262144);\n\tcheck(17, 1,131072);\n\tcheck(16, 1,65536);\n\tcheck(15, 1,32768);\n\tcheck(14, 1,16384);\n\tcheck(13, 1,8192);\n\tcheck(12, 1,4096);\n\tcheck(11, 1,2048);\n\tcheck(10, 2,117074);\n\tcheck(10, 1,1024);\n\tcheck(9, 2,38854);\n\tcheck(9, 1,512);\n\tcheck(8, 2,12866);\n\tcheck(8, 1,256);\n\tcheck(7, 2,4246);\n\tcheck(7, 1,128);\n\tcheck(6, 3,20266);\n\tcheck(6, 2,1394);\n\tcheck(6, 1,64);\n\tcheck(5, 4,41506);\n\tcheck(5, 3,4718);\n\tcheck(5, 2,454);\n\tcheck(5, 1,32);\n\tcheck(4, 5,41506);\n\tcheck(4, 4,6902);\n\tcheck(4, 3,1066);\n\tcheck(4, 2,146);\n\tcheck(4, 1,16);\n\tcheck(3, 6,20266);\n\tcheck(3, 5,4718);\n\tcheck(3, 4,1066);\n\tcheck(3, 3,230);\n\tcheck(3, 2,46);\n\tcheck(3, 1,8);\n\tcheck(2, 10,117074);\n\tcheck(2, 9,38854);\n\tcheck(2, 8,12866);\n\tcheck(2, 7,4246);\n\tcheck(2, 6,1394);\n\tcheck(2, 5,454);\n\tcheck(2, 4,146);\n\tcheck(2, 3,46);\n\tcheck(2, 2,14);\n\tcheck(2, 1,4);\n\tcheck(1, 20,1048576);\n\tcheck(1, 19,524288);\n\tcheck(1, 18,262144);\n\tcheck(1, 17,131072);\n\tcheck(1, 16,65536);\n\tcheck(1, 15,32768);\n\tcheck(1, 14,16384);\n\tcheck(1, 13,8192);\n\tcheck(1, 12,4096);\n\tcheck(1, 11,2048);\n\tcheck(1, 10,1024);\n\tcheck(1, 9,512);\n\tcheck(1, 8,256);\n\tcheck(1, 7,128);\n\tcheck(1, 6,64);\n\tcheck(1, 5,32);\n\tcheck(1, 4,16);\n\tcheck(1, 3,8);\n\tcheck(1, 2,4);\n\tcheck(1, 1,2);\n\tcheck(7, 3,85310);\n\tcheck(8, 3,354106);\n\tcheck(9, 3,1455278);\n\tcheck(5, 5,329462);\n\tcheck(6, 5,2441314);\n\tcheck(6, 4,237686);\n\tcheck(4, 6,237686);\n}\nchar board[nax][nax];\nint main() {\n\tREP(i, nax) {\n\t\tcho[i][i] = cho[i][0] = 1;\n\t\tFOR(j, 1, i - 1) {\n\t\t\tcho[i][j] = cho[i - 1][j] + cho[i - 1][j - 1];\n\t\t\tif (cho[i][j] >= mod) cho[i][j] -= mod;\n\t\t}\n\t}\n\tcalc_dp();\n\ttest();\n\tint h, w;\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 0; i < h; ++i) scanf(\"%s\", board[i]);\n\tll out = ans[0][h][w];\n\tdebug(arr(ans, 0, h, w));\n\tREP(rows, (1 << h))\n\t\tREP(cols, (1 << w)) {\n\t\t\tif (rows == 0 || cols == 0) continue;\n\t\t\tbool good = true;\n\t\t\tforbits(i, rows) {\n\t\t\t\tbool H = false, D = false;\n\t\t\t\tforbits(j, cols) {\n\t\t\t\t\tif (board[i][j] == '#') H = true;\n\t\t\t\t\telse D = true;\n\t\t\t\t}\n\t\t\t\tif (!H || !D) good = false;\n\t\t\t}\n\t\t\tforbits(j, cols) {\n\t\t\t\tbool H = false, D = false;\n\t\t\t\tforbits(i, rows) {\n\t\t\t\t\tif (board[i][j] == '#') H = true;\n\t\t\t\t\telse D = true;\n\t\t\t\t}\n\t\t\t\tif (!H || !D) good = false;\n\t\t\t}\n\t\t\tif (good) {\n\t\t\t\tdebug(imask(rows), imask(cols), imie(good), arr(ans, 1, h - popc(rows), w - popc(cols)));\n\t\t\t\tout += ans[1][h - popc(rows)][w - popc(cols)];\n\t\t\t}\n\t\t}\n\tout %= mod;\n\tif (out < 0) out += mod;\n\tprintf(\"%lld\\n\", out);\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n#define DD 1\n#else\n#define DD 0\n#endif\n#define Debug if(DD) printf(\"line %d\\n\",__LINE__)\n#define deb(x) if(DD) cerr<<#x<<'='<<x<<endl\n#define debug if(DD) printf\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid gg(){write2(-1);exit(0);}\n\t\n\tconst double eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=998244353;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int N=1e2+10;\n\n\tll C[N][N];\n\tll f[N][N][3],g[N][N][3];//f=从行开始增加\n\tchar mp[N][N];\n\tvoid main()\n\t{\n\t\tC[0][0]=1;fo(i,1,N-1){ C[i][0]=1;fo(j,1,i) C[i][j]=mm(C[i-1][j-1]+C[i-1][j]); }\n\t\tint n=qread(),m=qread();fo(i,0,n-1) scanf(\"%s\",mp[i]);\n\t\tfo(mm,0,m) g[n][mm][2]=C[m][mm]*bin(m-mm)%MOD;\n\t\tfd(nn,n,0) fd(mm,m,0)\n\t\t{\n\t\t\tfo(ad,1,n-nn)\n\t\t\t\tadd(f[nn][mm][0],C[ad+nn][nn]*(g[nn+ad][mm][0]+g[nn+ad][mm][1]*2+g[nn+ad][mm][2]*2)%MOD ),\n\t\t\t\tadd(f[nn][mm][1],C[ad+nn][nn]*(g[nn+ad][mm][1]+g[nn+ad][mm][2])%MOD*(bin(ad)-2)%MOD );\n\t\t\tfo(ad,1,m-mm)\n\t\t\t\tadd(g[nn][mm][0],C[ad+mm][mm]*(f[nn][mm+ad][0]+f[nn][mm+ad][1]*2+f[nn][mm+ad][2]*2)%MOD ),\n\t\t\t\tadd(g[nn][mm][1],C[ad+mm][mm]*(f[nn][mm+ad][1]+f[nn][mm+ad][2])%MOD*(bin(ad)-2)%MOD );\n\t\t}\n\t\tll ans=g[n][0][2];\n\t\tfo(mm,1,m) add(ans,f[0][mm][1]);\n\t\tfo(nn,1,n) add(ans,g[nn][0][1]);\n\t\tdeb(ans);\n\t\tfo(S1,1,bin(n)-1) fo(S2,1,bin(m)-1)\n\t\t{\n\t\t\tbool ok=1;\n\t\t\tfo(i,0,n-1) if(S1&bin(i)){\n\t\t\t\tbool same=1;int lst=-1;\n\t\t\t\tfo(j,0,m-1) if(S2&bin(j)) same&=(lst<0 or mp[i][j]==mp[i][lst]),lst=j;\n\t\t\t\tok&=(same==0);\n\t\t\t}fo(j,0,m-1) if(S2&bin(j)){\n\t\t\t\tbool same=1;int lst=-1;\n\t\t\t\tfo(i,0,n-1) if(S1&bin(i)) same&=(lst<0 or mp[i][j]==mp[lst][j]),lst=i;\n\t\t\t\tok&=(same==0);\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tfo(pp,0,2) add(ans, mm(f[PC(S1)][PC(S2)][pp]+g[PC(S1)][PC(S2)][pp])*invm(C[n][PC(S1)]*C[m][PC(S2)]%MOD)%MOD );\n\t\t}write(ans);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n\tsrand(time(0));\n\tmine::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 12\n\nconst LL mod=998244353;\nLL n,m,p,ans,a[N][N],f[N][N][3],g[N][N][3],row[N],col[N],C[N][N];\nchar s[N];\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nbool pd(LL i,LL j){\n\tif (i==0||j==0) return 1;\n\tfor (LL k=0;k<n;++k)\n\t\tif ((i>>k&1)&&((row[k]&j)==j||(row[k]&j)==0)) return 0;\n\tfor (LL k=0;k<m;++k)\n\t\tif ((j>>k&1)&&((col[k]&i)==i||(col[k]&i)==0)) return 0;\n\treturn 1;\n}\n\nLL pw(LL x,LL k){\n\treturn x==1?1:1<<k;\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (LL i=1;i<=n;++i){\n\t\tscanf(\"%s\",s+1);\n\t\tfor (LL j=1;j<=m;++j) a[i-1][j-1]=s[j]=='.';\n\t}\n\tfor (LL i=0;i<n;++i){\n\t\tfor (LL j=0;j<m;++j) row[i]|=a[i][j]<<j;\n\t}\n\tfor (LL i=0;i<m;++i){\n\t\tfor (LL j=0;j<n;++j) col[i]|=a[j][i]<<j;\n\t}\n\tp=max(n,m);\n\tfor (LL i=0;i<=p;++i){\n\t\tC[i][0]=1;\n\t\tfor (LL j=1;j<=i;++j) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\tfor (LL i=n;i;--i)\n\t\tf[i][m][2]=1<<(n-i);\n\tf[0][m][0]=1<<n;\n\tfor (LL i=n;i;--i)\n\t\tfor (LL j=m;j;--j){\n\t\t\tfor (LL k=1;k<j;++k){\n\t\t\t\tupd(g[i][j-k][2],f[i][j][2]*((1<<k)-2)%mod*C[m-j+k][k]);\n\t\t\t\tupd(g[i][j-k][1],(f[i][j][2]*2+f[i][j][1])%mod*C[m-j+k][k]);\n\t\t\t}\n\t\t\tupd(g[i][0][0],f[i][j][2]*((1<<j)-2)%mod*C[m][j]);\n\t\t\tfor (LL k=1;k<i;++k){\n\t\t\t\tupd(f[i-k][j][2],g[i][j][2]*((1<<k)-2)%mod*C[n-i+k][k]);\n\t\t\t\tupd(f[i-k][j][1],(g[i][j][2]*2+g[i][j][1])%mod*C[n-i+k][k]);\n\t\t\t}\n\t\t\tupd(f[0][j][0],g[i][j][2]*((1<<i)-2)%mod*C[n][i]);\n\t\t}\t\t\t\n\tfor (LL i=0;i<1<<n;++i)\n\t\tfor (LL j=0;j<1<<m;++j){\n\t\t\tLL ii=0,jj=0;\n\t\t\tfor (LL k=0;k<n;++k) ii+=i>>k&1;\n\t\t\tfor (LL k=0;k<m;++k) jj+=j>>k&1;\n\t\t\tif (pd(i,j))\n\t\t\t\tfor (LL k=0;k<=2;++k) upd(ans,f[ii][jj][k]+g[ii][jj][k]);\n\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "かきかけ;\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\n#include <queue>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <iterator>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\n\ntemplate<typename T, typename U>\nstd::enable_if_t<std::rank<T>::value == 0> fill_all(T& arr, const U& v) {\n    arr = v;\n}\ntemplate<typename ARR, typename U>\nstd::enable_if_t<std::rank<ARR>::value != 0> fill_all(ARR& arr, const U& v) {\n    for (auto& i : arr) {\n        fill_all(i, v);\n    }\n}\n\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 998244353>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\nmint dp[1 << 10][1 << 10][2];\nbool used[1 << 10][1 << 10][2];\nmint func(std::bitset<10> maskH, std::bitset<10> maskW, int turn) {\n\n\tauto maskHL = maskH.to_ulong();\n\tauto maskWL = maskW.to_ulong();\n\tif (maskHL == 0 && maskWL == 0) {\n\t\treturn 1_mi;\n\t}\n\tauto& memo = dp[maskHL][maskWL][turn];\n\tif (used[maskHL][maskWL]) {\n\t\treturn memo;\n\t}\n\tused[maskHL][maskWL][turn] = true;\n\n\tmemo = 1_mi;\n\tif (turn == 0)\n\t{\n\t\tfor (auto nextmask = (1 + ~maskHL) & maskHL; nextmask != 0; nextmask = ((nextmask + 1) + ~maskHL) & maskHL)\n\t\t{\n\n\t\t}\n\t}\n\n}\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=11,mo=998244353;\nchar s[N][N];\nint inv[N],fac[N],f[N][N],g[N][N],w[N],v[N];\n//f[i][j] indicate the number of ways that print a i*j rectangle\n//g[i][j] indicate the number of ways that print a i*j L \nvoid init(){\n\tfac[0]=inv[0]=fac[1]=inv[1]=1;\n\tfor(int i=2;i<=10;i++)fac[i]=fac[i-1]*i,inv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;\n\tfor(int i=2;i<=10;i++)inv[i]=1ll*inv[i]*inv[i-1]%mo;\n}\nvoid add(int &x,int y){(x+=y)%=mo;}\nint mul(int x){return x;}\ntemplate<class... T> int mul(int x,T... y){return 1ll*x*mul(y...)%mo;}\ninline int C(int n,int m){return 1ll*fac[n]*inv[n-m]%mo*inv[m]%mo;}\nint main(){\n\tinit();\n\tint n,m,s1,s2;scanf(\"%d%d\",&n,&m),s1=(1<<n),s2=(1<<m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",s[i]);\n\t\tfor(int j=0;j<m;j++)if(s[i][j]=='#')w[i]|=(1<<j),v[j]|=(1<<i);\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tif(!i||!j){f[i][j]=1,g[i][j]=1<<(i+j);continue;}\n\t\t\tfor(int k=1;k<=i;k++)add(f[i][j],mul(k&1?1:mo-1,C(i,k),1<<k,f[i-k][j])),\n\t\t\tadd(g[i][j],mul(k&1?1:mo-1,C(i,k),1<<k,g[i-k][j]));\n\t\t\tfor(int k=1;k<=j;k++)add(f[i][j],mul(k&1?1:mo-1,C(j,k),1<<k,f[i][j-k])),\n\t\t\tadd(g[i][j],mul(k&1?1:mo-1,C(j,k),1<<k,g[i][j-k]));\n\t\t\tfor(int k=1;k<=i;k++)for(int l=1;l<=j;l++){\n\t\t\t\tadd(f[i][j],mul((k+l)&1?1:mo-1,C(i,k),C(j,l),2,f[i-k][j-l]));\n\t\t\t\tadd(g[i][j],mul((k+l)&1?1:mo-1,C(i,k),C(j,l),2,g[i-k][j-l]));\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<s1;i++){\n\t\tfor(int j=1;j<s2;j++){\n\t\t\tbool fl=0;int a=0,b=0;\n\t\t\tfor(int k=0;k<n;k++)if(i&(1<<k))a++,fl|=(w[k]&j)==j||((~w[k])&j)==j;\n\t\t\tfor(int k=0;k<m;k++)if(j&(1<<k))b++,fl|=(v[k]&i)==i||((~v[k])&i)==i;\n\t\t\tif(!fl)add(ans,g[n-a][m-b]);\n\t\t}\n\t}\n\tprintf(\"%d\",(ans+f[n][m])%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,l,r) for (int i=l,i##end=r;i<=i##end;++i)\n#define per(i,r,l) for (int i=r,i##end=l;i>=i##end;--i)\n#define ll long long\nusing namespace std;\nconst int N=15,S=1500,P=998244353;\nint C[N][N],cnt[S],sr[N],sc[N],dpr[N][N][3],dpc[N][N][3];\nint add(int x,int y){ x+=y; return x>=P?x-P:x; }\nint fpw(int x,int y){\n    int s=1; for (;y;y>>=1,x=(ll)x*x%P) if (y&1) s=(ll)s*x%P;\n    return s;\n}\nint main(){\n    int n,m; cin>>n>>m;\n    rep(i,0,max(n,m)){\n        C[i][0]=1;\n        rep(j,1,i) C[i][j]=add(C[i-1][j],C[i-1][j-1]);\n    }\n    rep(i,1,n){\n        char s[N]; cin>>s;\n        rep(j,1,m)\n            if (s[j-1]=='#') sr[i]|=1<<j-1,sc[j]|=1<<i-1;\n    }\n    rep(s,1,(1<<max(n,m))-1)\n        rep(i,1,max(n,m)) cnt[s]+=s>>i-1&1;\n    rep(j,1,m) dpc[n][j][2]=(ll)C[m][j]*(1<<m-j)%P;\n    int ans=1<<m;\n    per(i,n,1)\n        per(j,m,1){\n            dpc[i][j][0]=add(dpc[i][j][1],dpc[i][j][2]);\n            rep(k,1,i-1){\n                dpr[k][j][1]=add(dpr[k][j][1],(ll)add(add(dpc[i][j][2],dpc[i][j][2]),dpc[i][j][1])*C[i][k]%P);\n                dpr[k][j][2]=add(dpr[k][j][2],(ll)((1<<i-k)-2)*dpc[i][j][2]%P*C[i][k]%P);\n            }\n            ans=(ans+(ll)dpc[i][j][2]*((1<<i)-2))%P;\n            dpr[i][j][0]=add(dpr[i][j][1],dpr[i][j][2]);\n            rep(k,1,j-1){\n                dpc[i][k][1]=add(dpc[i][k][1],(ll)add(add(dpr[i][j][2],dpr[i][j][2]),dpr[i][j][1])*C[j][k]%P);\n                dpc[i][k][2]=add(dpc[i][k][2],(ll)((1<<j-k)-2)*dpr[i][j][2]%P*C[j][k]%P);\n            }\n            ans=(ans+(ll)dpr[i][j][2]*((1<<j)-2)%P);\n        }\n    rep(s1,1,(1<<n)-1)\n        rep(s2,1,(1<<m)-1){\n            bool f=false;\n            rep(i,1,n)\n                if (s1>>i-1&1){\n                    int c=cnt[sr[i]&s2]; f=f||c==0||c==cnt[s2];\n                }\n            rep(i,1,m)\n                if (s2>>i-1&1){\n                    int c=cnt[sc[i]&s1]; f=f||c==0||c==cnt[s1];\n                }\n            if (!f){\n                int coef=fpw((ll)C[n][cnt[s1]]*C[m][cnt[s2]]%P,P-2);\n                ans=add(ans,(ll)add(dpc[cnt[s1]][cnt[s2]][0],dpr[cnt[s1]][cnt[s2]][0])*coef%P);\n            }\n        }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=15;\nconst int mod=998244353;\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\tfor(;b;b>>=1,a=1LL*a*a%mod)if(b&1)ret=1LL*ret*a%mod;\n\treturn ret;\n}\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nint C[MAXN][MAXN],bin[MAXN];\nint row[MAXN][MAXN][3],col[MAXN][MAXN][3],n,m;\nint ans=0;\nint r[MAXN],c[MAXN];\nvoid dp()\n{\n\tfor(int i=0;i<MAXN;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)C[i][j]=C[i-1][j],ad(C[i][j],C[i-1][j-1]);\n\t}bin[0]=1;for(int i=1;i<MAXN;i++)bin[i]=bin[i-1]<<1;\n\tfor(int j=1;j<=m;j++)row[n][j][2]=1LL*C[m][j]*bin[m-j]%mod;\n\tans=bin[m];\n\tfor(int i=n;i>=1;i--)for(int j=m;j>=1;j--)\n\t{\n\t\trow[i][j][0]=(row[i][j][1]+row[i][j][2])%mod;\n\t\tcol[i][j][0]=(col[i][j][1]+col[i][j][2])%mod;\n\t\tfor(int k=1;k<i;k++)\n\t\t{\n\t\t\tad(col[k][j][1],(2LL*row[i][j][2]*C[i][k]%mod+1LL*row[i][j][1]*C[i][k]%mod)%mod);\n\t\t\tad(col[k][j][2],1LL*row[i][j][2]*C[i][k]%mod*(bin[i-k]-2)%mod);\n\t\t}\n\t\tad(ans,1LL*row[i][j][2]*(bin[i]-2)%mod);\n\t\tfor(int k=1;k<j;k++)\n\t\t{\n\t\t\tad(row[i][k][1],(2LL*col[i][j][2]*C[j][k]%mod+1LL*col[i][j][1]*C[j][k]%mod)%mod);\n\t\t\tad(row[i][k][2],1LL*col[i][j][2]*C[j][k]%mod*(bin[j-k]-2)%mod);\n\t\t}\n\t\tad(ans,1LL*col[i][j][2]*(bin[j]-2)%mod);\n\t}\n\tfor(int i=1;i<(1<<n);i++)for(int j=1;j<(1<<m);j++)\n\t{\n\t\tbool flag=true;\n\t\tfor(int u=1;u<=n;u++)if((i&(1<<(u-1)))&&((r[u]&j)==j||(r[u]&j)==0)){flag=false;break;}\n\t\tfor(int u=1;u<=m;u++)if((j&(1<<(u-1)))&&((c[u]&i)==i||(c[u]&i)==0)){flag=false;break;}\n\t\tif(!flag)continue;\n\t\tint fx=__builtin_popcount(i),fy=__builtin_popcount(j);\n\t\tad(ans,1LL*(row[fx][fy][0]+col[fx][fy][0])*pow_mod(C[n][fx],mod-2)%mod*pow_mod(C[m][fy],mod-2)%mod);\n\t}\n\tpr2(ans);\n}\nchar ch[MAXN][MAXN];\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)scanf(\"%s\",ch[i]+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)if(ch[i][j]=='#')r[i]|=(1<<(j-1));\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=1;j<=n;j++)if(ch[j][i]=='#')c[i]|=(1<<(j-1));\n\tdp();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\ntemplate<ll mod>\nstruct ModInt{\n  using M=ModInt;\n  ll a;\n  M& put(ll v){\n    a=(v<mod)?v:v-mod;\n    return *this;\n  }\n  ModInt(ll v=0){put(v%mod+mod);}\n  M operator+(M x){return M().put(a+x.a);}\n  M operator-(M x){return M().put(a+mod-x.a);}\n  M operator*(M x){return M().put(a*x.a%mod);}\n  M operator/(M x){return x.inv()*a;}\n  M& operator+=(M x){return *this=*this+x;};\n  M& operator-=(M x){return *this=*this-x;};\n  M& operator*=(M x){return *this=*this*x;};\n  M& operator/=(M x){return *this=*this/x;};\n  bool operator==(M x){return a==x.a;}\n  M pow(ll m) {\n    M x=*this,res=1;\n    while(m){\n      if(m&1)res*=x;\n      x*=x;\n      m>>=1;\n    }\n    return res;\n  }\n  M inv(){return pow(mod-2);}\n};\nusing mint = ModInt<998244353>;\n\nint H;\nint W;\nint hlim;\nint wlim;\nint rowb[14];\nint colb[14];\nint field[14][14];\nmint fact[100];\nmint tmp[14][14][2];\nvector<vector<mint>> dp;\nvector<vector<mint>> WB;\nvector<vector<mint>> BW;\n\nmint Comb(int n, int k) {\n  assert(0 <= k && k <= n);\n  return fact[n] / fact[k] / fact[n-k];\n}\n\n// Zeta Transform g(T)=\\sum_{S \\subset T}f(S)\ntemplate<class T, class F>\ninline void FZT(vector<T>&f,F add){\n  int n=__lg(f.size());\n  int lim = 1 << n;\n  rep(i, n) {\n    rep(j, lim) {\n      if (~j >> i & 1) f[j|1<<i]=add(f[j|1<<i],f[j]);\n    }\n  }\n}\n// Modoebius Transform g(T)=\\sum_{S \\subset T}(-1)^{|T\\S|}f(S)\ntemplate<class T,class F>\ninline void FMT(vector<T>&f,F sub){\n  int n=__lg(f.size());\n  int lim = 1 << n;\n  rep(i, n) {\n    rep(j, lim) {\n      if (~j >> i & 1) f[j|1<<i]=sub(f[j|1<<i],f[j]);\n    }\n  }\n}\n// O(nlog^2n) f*g(S)=\\sum_{U∪V=S, U∩V=\\emptyset } f(U)*g(V)\ntemplate<class T,class F>\ninline vector<vector<T>> RankedFZT(vector<T>&f,F add){\n  int n=__lg(f.size());\n  int lim = 1 << n;\n  vector<vector<T>> ret(n+1, vector<T>(f.size()));\n  rep(i, lim) ret[__builtin_popcount(i)][i] = f[i];\n  rep(i, n+1) FZT(ret[i], add);\n  return ret;\n}\ntemplate<class T,class F, class G>\ninline vector<T> ExactConv(vector<T>&f, vector<T>&g, F add, G sub) {\n  int n=__lg(f.size());\n  int lim = 1 << n;\n  auto rf = RankedFZT(f, add);\n  auto rg = RankedFZT(g, add);\n  vector<vector<T>> c(n+1, vector<T>(f.size()));\n  rep(k, n+1) {\n    rep(j, k+1) rep(st, lim) {\n      c[k][st] += rf[j][st]*rg[k-j][st];\n    }\n    FZT(c[k], sub);\n  }\n  vector<T> ret(lim);\n  rep(i, lim) ret[i] = c[__builtin_popcount(i)][i];\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  fact[0] = 1;\n  reps(i, 1, 100) {\n    fact[i] = fact[i-1] * i;\n  }\n\n  cin >> H >> W;\n  hlim = 1 << H;\n  wlim = 1 << W;\n  rep(i, H) {\n    rep(j, W) {\n      char c;\n      cin >> c;\n      if (c == '#') field[i][j] = 1;\n      else if (c == '.') field[i][j] = 0;\n      else assert(0);\n    }\n  }\n  rep(i, H) {\n    rrep(j, W) rowb[i] = (rowb[i] << 1) | field[i][j];\n  }\n  rep(j, W) {\n    rrep(i, H) colb[j] = (colb[j] << 1) | field[i][j];\n  }\n\n  tmp[0][0][0] = 1;\n  tmp[0][0][1] = 1;\n  rep(i, H+1) {\n    rep(j, W+1) {\n      reps(k, 1, H+1) {\n        if (i+k > H) break;\n        tmp[i+k][j][1] += tmp[i][j][0] * Comb(i+k, k);\n      }\n      reps(k, 1, W+1) {\n        if (j+k > W) break;\n        tmp[i][j+k][0] += tmp[i][j][1] * Comb(j+k, k);\n      }\n    }\n  }\n  dp.resize(hlim, vector<mint>(wlim));\n  rep(i, H+1) {\n    rep(j, W+1) {\n      dp[i][j] = tmp[i][j][0] + tmp[i][j][1];\n    }\n  }\n  dp[0][0] = 1;\n  \n  vector<vector<mint>> conv(H+1, vector<mint>(W+1));\n  rep(s, H+1) {\n    rep(t, W+1) {\n      rep(a, s+1) {\n        rep(b, t+1) {\n          conv[s][t] += Comb(s, a) * Comb(t, b) * dp[a][b] * dp[s-a][t-b];\n        }\n      }\n    }\n  }\n\n  mint ans = 0;\n  rep(hst, hlim) {\n    rep(wst, wlim) {\n      bool ng = 0;\n      int hexc = ~hst & (hlim-1);\n      int wexc = ~wst & (wlim-1);\n      rep(j, W) {\n        if (wst >> j & 1) continue;\n        if ((colb[j] & hexc) == hexc) ng = 1;\n        if ((~colb[j] & hexc) == hexc) ng = 1;\n      }\n      rep(i, H) {\n        if (hst >> i & 1) continue;\n        if ((rowb[i] & wexc) == wexc) ng = 1;\n        if ((~rowb[i] & wexc) == wexc) ng = 1;\n      }\n      int hcnt = __builtin_popcount(hst);\n      int wcnt = __builtin_popcount(wst);\n      if (hcnt == H && wcnt == W) ans += dp[H][W];\n      else if (!ng) ans += conv[hcnt][wcnt];\n    }\n  }\n  cout << ans.a << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 10;\nconst i64 P = 998244353;\nstring s[maxn];\n\ni64 mult[maxn + 1][maxn + 1];\ni64 dp[maxn + 1][maxn + 1][16];\ni64 cnk[maxn + 1][maxn + 1];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    cnk[0][0] = 1;\n    forn(i, maxn) forn(j, i + 1) forn(z, 2) cnk[i + 1][j + z] += cnk[i][j];\n\n    int n, m;\n    cin >> n >> m;\n    forn(i, n) cin >> s[i];\n\n    forn(h, n + 1) forn(w, m + 1) {\n        if (min(w, h) == 0 && max(w, h) != 0) continue;\n        forn(i, n + 1) forn(j, m + 1) forn(mask, 16) dp[i][j][mask] = 0;\n        dp[n][m][0] = 1;\n        i64 res = 0;\n        ford(i, n + 1) ford(j, m + 1) forn(mask, 16) {\n            if (i < h) continue;\n            if (j < w) continue;\n            if (dp[i][j][mask] == 0) continue;\n//            if (h == 0) cerr << i << ' ' << j << ' ' << mask << ' ' << dp[i][j][mask] << '\\n';\n            if (min(i, j) == 0) {\n                res += dp[i][j][mask];\n                res %= P;\n                continue;\n            }\n            forn(br, i - h + 1) forn(wr, i - h - br + 1) forn(bc, j - w + 1) forn(wc, j - w - bc + 1) {\n                if ((mask & 1) && br > 0) continue;\n                if ((mask & 2) && wr > 0) continue;\n                if ((mask & 4) && bc > 0) continue;\n                if ((mask & 8) && wc > 0) continue;\n                if (br > 0 && wc > 0) continue;\n                if (wr > 0 && bc > 0) continue;\n                if (br + wr + bc + wc == 0) continue;\n                if (wr == i && wc < j) continue;\n                if (br == i && bc < j) continue;\n                if (wc == j && wr < i) continue;\n                if (bc == j && br < i) continue;\n\n                i64 coef = cnk[i - h][br + wr] * cnk[br + wr][br] % P * cnk[j - w][bc + wc] % P * cnk[bc + wc][bc] % P;\n                int nmask = 0;\n                if (bc + wc == 0) nmask |= 3;\n                if (br + wr == 0) nmask |= 12;\n                if (br + bc == 0) nmask |= 10;\n                if (wr + wc == 0) nmask |= 5;\n                i64 &newVal = dp[i - wr - br][j - wc - bc][nmask];\n                newVal += dp[i][j][mask] * coef;\n                newVal %= P;\n            }\n        }\n        mult[h][w] = res;\n        if (h > 0) forn(mask, 16) mult[h][w] += dp[h][w][mask];\n        mult[h][w] %= P;\n    }\n\n    i64 ans = 0;\n    forn(rmask, 1 << n) forn(cmask, 1 << m) {\n        if (min(rmask, cmask) == 0 && max(rmask, cmask) > 0) continue;\n        bool ok = true;\n        if (rmask != 0) {\n            forn(i, n) {\n                if (!((rmask >> i) & 1)) continue;\n                bool hasB = false, hasW = false;\n                forn(j, m) {\n                    if (!((cmask >> j) & 1)) continue;\n                    if (s[i][j] == '#') hasB = true;\n                    else hasW = true;\n                }\n                if (!hasB || !hasW) ok = false;\n            }\n\n            forn(j, m) {\n                if (!((cmask >> j) & 1)) continue;\n                bool hasB = false, hasW = false;\n                forn(i, n) {\n                    if (!((rmask >> i) & 1)) continue;\n                    if (s[i][j] == '#') hasB = true;\n                    else hasW = true;\n                }\n                if (!hasB || !hasW) ok = false;\n            }\n        }\n        if (!ok) continue;\n        ans += mult[__builtin_popcount(rmask)][__builtin_popcount(cmask)];\n        ans %= P;\n    }    \n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod = 998244353;\ncat C[11][11];\n\nvoid count(int h, int w, char f_e, char f_h, char f_w, int & out, cat cur = 1) {\n\tif(h+w == 0) {\n\t\tout += cur;\n\t\tif(out >= mod) out -= mod;\n\t\treturn;\n\t}\n\tif(!(f_e&1) && h*w == 0) return;\n\tfor(int c = 0; c < 2; c++) for(int i = 0; i <= h; i++) for(int j = 0; j <= w; j++) if(i+j) {\n\t\tif((f_h>>c)&1 && i) continue;\n\t\tif((f_w>>c)&1 && j) continue;\n\t\tif(j && f_e&2 && c) continue;\n\t\tif(i && f_e&4 && c) continue;\n\t\tcat x = C[h][i] * C[w][j] % mod;\n\t\tint n_h = f_h, n_w = f_w;\n\t\tif(i) n_w ^= n_w&(1<<(1-c));\n\t\tif(j) n_h ^= n_h&(1<<(1-c));\n\t\tn_h |= 1<<c;\n\t\tn_w |= 1<<c;\n\t\tint n_e = f_e&1;\n\t\tif(!i) n_e |= 2;\n\t\tif(!j) n_e |= 4;\n\t\tcount(h-i, w-j, n_e, n_h, n_w, out, cur*x%mod);\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint H, W;\n\tcin >> H >> W;\n\tvector<int> V(H, 0);\n\tfor(int i = 0; i < H; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < W; j++)\n\t\t\tif(s[j] == '#') V[i] |= 1<<j;\n\t}\n\tmemset(C, 0, sizeof(C));\n\tfor(int i = 0; i <= 10; i++) {\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1; j <= i; j++)\n\t\t\tC[i][j] = (C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tint cnt[11][11];\n\tmemset(cnt, 0, sizeof(cnt));\n\tfor(int i = 0; i <= H; i++) for(int j = 0; j <= W; j++)\n\t\tcount(i, j, (H-i) || (W-j), 0, 0, cnt[i][j]);\n\tcat ans = cnt[H][W];\n\tfor(int i = 0; i < (1<<H)-1; i++) {\n\t\tvector<int> Vr, Vc(W, 0);\n\t\tfor(int j = 0; j < H; j++)\n\t\t\tif(!((i>>j)&1)) Vr.push_back(V[j]);\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tfor(int k = 0; k < H; k++)\n\t\t\t\tif(!((i>>k)&1)) Vc[j] += ((V[k]>>j)&1)<<k;\n\t\t\tVc[j] = (!Vc[j]) || (Vc[j] == (1<<H)-1-i);\n\t\t}\n\t\tint n = H-Vr.size();\n\t\tfor(int j = 0; j < (1<<W)-1; j++) {\n\t\t\tint m = (1<<W)-1-j;\n\t\t\tbool ok = true;\n\t\t\tfor(int k = 0; k < H-n; k++) if(!(Vr[k]&m) || (Vr[k]&m) == m) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tfor(int k = 0; k < W; k++) if(!((j>>k)&1) && Vc[k]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tans += cnt[n][__builtin_popcount(j)];\n\t\t\tif(ans >= mod) ans -= mod;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 12\n#define BT (1<<10)\n#define MOD 998244353\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nchar mp[SIZE][SIZE];\nint dp[SIZE][SIZE];\nint dp2[SIZE][SIZE];\nint C[SIZE][SIZE];\nint bit[SIZE];\nint bit2[SIZE];\nint rt[SIZE];\n\nvoid make()\n{\n\tfor(int i=0;i<SIZE;i++)\n\t{\n\t\tC[i][i]=C[i][0]=1;\n\t\tfor(int j=1;j<i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n\t}\n\trt[0]=1;\n\tfor(int i=1;i<SIZE;i++) rt[i]=rt[i-1]*2%MOD;\n\t//dp[0][0]=1;\n\tfor(int i=0;i<SIZE;i++) for(int j=0;j<SIZE;j++) if(i==0||j==0) dp[i][j]=1;\n\tfor(int i=1;i<SIZE;i++)\n\t{\n\t\tfor(int j=1;j<SIZE;j++)\n\t\t{\n\t\t\tdp[i][j]=0;\n\t\t\tfor(int k=1;k<=i;k++)\n\t\t\t{\n\t\t\t\tll way=C[i][k]*rt[k]%MOD*(ll) dp[i-k][j]%MOD;\n\t\t\t\tif(k%2==0) way=MOD-way;\n\t\t\t\tdp[i][j]+=way;\n\t\t\t\tif(dp[i][j]>=MOD) dp[i][j]-=MOD;\n\t\t\t}\n\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tll way=C[j][k]*rt[k]%MOD*(ll) dp[i][j-k]%MOD;\n\t\t\t\tif(k%2==0) way=MOD-way;\n\t\t\t\tdp[i][j]+=way;\n\t\t\t\tif(dp[i][j]>=MOD) dp[i][j]-=MOD;\n\t\t\t}\n\t\t\tfor(int k=1;k<=i;k++)\n\t\t\t{\n\t\t\t\tfor(int l=1;l<=j;l++)\n\t\t\t\t{\n\t\t\t\t\tll way=C[i][k]*C[j][l]%MOD*(ll) dp[i-k][j-l]%MOD*2LL%MOD;\n\t\t\t\t\tif((k+l)%2==0) way=MOD-way;\n\t\t\t\t\tdp[i][j]+=way;\n\t\t\t\t\tif(dp[i][j]>=MOD) dp[i][j]-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<SIZE;i++) for(int j=0;j<SIZE;j++) if(i==0||j==0) dp2[i][j]=rt[i+j];\n\tfor(int i=1;i<SIZE;i++)\n\t{\n\t\tfor(int j=1;j<SIZE;j++)\n\t\t{\n\t\t\tdp2[i][j]=0;\n\t\t\tfor(int k=1;k<=i;k++)\n\t\t\t{\n\t\t\t\tll way=C[i][k]*rt[k]%MOD*(ll) dp2[i-k][j]%MOD;\n\t\t\t\tif(k%2==0) way=MOD-way;\n\t\t\t\tdp2[i][j]+=way;\n\t\t\t\tif(dp2[i][j]>=MOD) dp2[i][j]-=MOD;\n\t\t\t}\n\t\t\tfor(int k=1;k<=j;k++)\n\t\t\t{\n\t\t\t\tll way=C[j][k]*rt[k]%MOD*(ll) dp2[i][j-k]%MOD;\n\t\t\t\tif(k%2==0) way=MOD-way;\n\t\t\t\tdp2[i][j]+=way;\n\t\t\t\tif(dp2[i][j]>=MOD) dp2[i][j]-=MOD;\n\t\t\t}\n\t\t\tfor(int k=1;k<=i;k++)\n\t\t\t{\n\t\t\t\tfor(int l=1;l<=j;l++)\n\t\t\t\t{\n\t\t\t\t\tll way=C[i][k]*C[j][l]%MOD*(ll) dp2[i-k][j-l]%MOD*2LL%MOD;\n\t\t\t\t\tif((k+l)%2==0) way=MOD-way;\n\t\t\t\t\tdp2[i][j]+=way;\n\t\t\t\t\tif(dp2[i][j]>=MOD) dp2[i][j]-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tmake();\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%s\",&mp[i]);\n\t\tfor(int j=0;j<m;j++) if(mp[i][j]=='#') bit[i]|=(1<<j),bit2[j]|=(1<<i);\n\t}\n\tint ret=dp[n][m];\n\tfor(int S=1;S<(1<<n);S++)\n\t{\n\t\tfor(int T=1;T<(1<<m);T++)\n\t\t{\n\t\t\tbool up=true;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(S>>i&1)\n\t\t\t\t{\n\t\t\t\t\tif((T&bit[i])==T||(((1<<m)-bit[i]-1)&T)==T)\n\t\t\t\t\t{\n\t\t\t\t\t\t//if(S==3&&T==3) printf(\"%d\\n\",i);\n\t\t\t\t\t\tup=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tif(T>>i&1)\n\t\t\t\t{\n\t\t\t\t\tif((S&bit2[i])==S||(((1<<n)-bit2[i]-1)&S)==S)\n\t\t\t\t\t{\n\t\t\t\t\t\t//if(S==3&&T==3) printf(\"%d\\n\",i);\n\t\t\t\t\t\tup=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(up)\n\t\t\t{\n\t\t\t\tint w=0,h=0;\n\t\t\t\tfor(int i=0;i<n;i++) if(S>>i&1) w++;\n\t\t\t\tfor(int j=0;j<m;j++) if(T>>j&1) h++;\n\t\t\t\t//printf(\"%d %d : %d\\n\",w,h,dp[n-w][m-h]);\n\t\t\t\tret+=dp2[n-w][m-h];\n\t\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int mod=998244353;\ninline int ad(int x){return x>=mod?x-mod:x;}\ninline int dec(int x){return x<0?x+mod:x;}\nchar ss[15];\nint n,m,a[15][15],row[15],col[15];\ninline bool pd(int x,int y)\n{\n\tif(x==0 && y==0)return true;\n\tif(x==0 || y==0)return false;\n\tfor(int i=0;i<n;i++)if(x>>i&1 && ((row[i]&y)==y || (row[i]&y)==0))return false;\n\tfor(int i=0;i<m;i++)if(y>>i&1 && ((col[i]&x)==x || (col[i]&x)==0))return false;\n\treturn true;\n}\nint C[15][15],f[15][15][3],g[15][15][3];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tfor(int i=0;i<=10;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)C[i][j]=ad(C[i-1][j]+C[i-1][j-1]);\n\t}\n\tn=read(),m=read();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%s\",ss);\n\t\tfor(int j=0;j<m;j++)a[i][j]=ss[j]=='.';\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)row[i]+=a[i][j]<<j;\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)col[i]+=a[j][i]<<j;\n\t}\n\tfor(int i=0;i<m;i++)f[0][i][2]=1<<i;\n\tf[n][m][0]=1<<m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tfor(int k=1;k<n-i;k++)\n\t\t\t{\n\t\t\t\tg[i+k][j][1]=ad(g[i+k][j][1]+1LL*ad(f[i][j][1]+ad(f[i][j][2]*2))*C[k+i][i]%mod);\n\t\t\t\tg[i+k][j][2]=ad(g[i+k][j][2]+1LL*f[i][j][2]*dec((1<<k)-2)%mod*C[k+i][i]%mod);\n\t\t\t}\n\t\t\tg[n][m][0]=ad(g[n][m][0]+1LL*f[i][j][2]*dec((1<<(n-i))-2)%mod*C[n][i]%mod*C[m][j]%mod);\n\t\t\tfor(int k=1;k<m-j;k++)\n\t\t\t{\n\t\t\t\tf[i][j+k][1]=ad(f[i][j+k][1]+1LL*ad(g[i][j][1]+ad(g[i][j][2]*2))*C[k+j][j]%mod);\n\t\t\t\tf[i][j+k][2]=ad(f[i][j+k][2]+1LL*g[i][j][2]*dec((1<<k)-2)%mod*C[k+j][j]%mod);\n\t\t\t}\n\t\t\tf[n][m][0]=ad(f[n][m][0]+1LL*g[i][j][2]*dec((1<<(m-j))-2)%mod*C[m][j]%mod*C[n][i]%mod);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tfor(int j=0;j<(1<<m);j++)\n\t\t{\n\t\t\tif(pd(i,j)==false)continue;\n\t\t\tint x=n,y=m;\n\t\t\tfor(int k=0;k<n;k++)if(i>>k&1)x--;\n\t\t\tfor(int k=0;k<m;k++)if(j>>k&1)y--;\n\t\t\tfor(int k=0;k<3;k++)ans=ad(ans+ad(f[x][y][k]+g[x][y][k]));\n\t\t}\n\t}pr2(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing ll = long long;\nusing i_i = tuple<int, int>;\n\nconst int N = 10;\nconst int MOD = 998244353;\n\nll dp[N + 1][N + 1][2][2][2][2];\n\nint main() {\n    vector<vector<ll>> comb(N + 1, vector<ll>(N + 1));\n    rep(x, N + 1) {\n        comb[x][0] = 1;\n        for (int y = 1; y <= x; y++)\n            comb[x][y] = (comb[x - 1][y - 1] + comb[x - 1][y]) % MOD;\n    }\n    \n    vector<vector<ll>> nibu(N + 1, vector<ll>(N + 1));\n    rep(s, N * 2 + 1) rep(r, s + 1) {\n        int c = s - r;\n        if (r <= N && c <= N) {\n            if (r == 0 || c == 0) nibu[r][c] = 1;\n            else {\n                for (int i = 1; i <= r; i++)\n                    nibu[r][c] = (nibu[r][c] + nibu[c][r - i] * comb[r][i]) % MOD;\n            }\n        }\n    }\n    \n    rep(r, N + 1) rep(c, N + 1) {\n        if (r == 0 || c == 0) {\n            rep(wr, 2) rep(wc, 2) rep(br, 2) rep(bc, 2) dp[r][c][wr][wc][br][bc] = 1;\n        }\n        else {\n            rep(wr, 2) rep(wc, 2) rep(br, 2) rep(bc, 2) {\n                if (wr && wc) dp[r][c][wr][wc][br][bc] += 1;\n                if (br && bc) dp[r][c][wr][wc][br][bc] += 1;\n                rep(iw, r) rep(ib, r) rep(jw, c) rep(jb, c) if (iw + ib + jw + jb > 0 && iw + ib <= r && jw + jb <= c) {\n                    if (iw && jb) continue;\n                    if (ib && jw) continue;\n                    if (!wr && iw > 0) continue;\n                    if (!wc && jw > 0) continue;\n                    if (!br && ib > 0) continue;\n                    if (!bc && jb > 0) continue;\n                    int _wr = (jb > 0);\n                    int _wc = (ib > 0);\n                    int _br = (jw > 0);\n                    int _bc = (iw > 0);\n                    ll z = comb[r][iw] % MOD * comb[r - iw][ib] % MOD * comb[c][jw] % MOD * comb[c - jw][jb] % MOD;\n                    dp[r][c][wr][wc][br][bc] = (dp[r][c][wr][wc][br][bc] + dp[r - iw - ib][c - jw - jb][_wr][_wc][_br][_bc] * z) % MOD;\n                }\n            }\n        }\n    }\n    \n    \n    \n    /*\n    for (;;) {\n        int r, c; cin >> r >> c;\n        cout << dp[r][c][1][1][1][1] << endl;\n    }\n    */\n    \n    int H, W;\n    cin >> H >> W;\n    vector<vector<bool>> a(H, vector<bool>(W));\n    rep(y, H) {\n        string s; cin >> s;\n        rep(x, W) a[y][x] = (s[x] == '#');\n    }\n    ll ans = dp[H][W][1][1][1][1];\n    rep(S, 1<<H) rep(T, 1<<W) if (S && T) {\n        bool ok = true;\n        rep(y, H) if (S>>y & 1) {\n            int z[2] = {0, 0};\n            rep(x, W) if (T>>x & 1) z[a[y][x]] = 1;\n            if (!z[0] || !z[1]) ok = false;\n        }\n        rep(x, W) if (T>>x & 1) {\n            int z[2] = {0, 0};\n            rep(y, H) if (S>>y & 1) z[a[y][x]] = 1;\n            if (!z[0] || !z[1]) ok = false;\n        }\n        if (ok) {\n            int R = H - __builtin_popcount(S);\n            int C = W - __builtin_popcount(T);\n            rep(wr, R + 1) rep(wc, C + 1) {\n                int br = R - wr;\n                int bc = C - wc;\n                ll waf = (wr && bc) ? (nibu[wr][bc] + nibu[bc][wr]) : 1;\n                ll rel = (wc && br) ? (nibu[wc][br] + nibu[br][wc]) : 1;\n                ll z = comb[R][wr] * comb[C][wc] % MOD * waf % MOD * rel % MOD;\n                ans = (ans + z) % MOD;\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int mod=998244353;\ninline int ad(int x){return x>=mod?x-mod:x;}\ninline int dec(int x){return x<0?x+mod:x;}\nchar ss[15];\nint n,m,a[15][15],row[15],col[15];\ninline bool pd(int x,int y)\n{\n\tif(x==0 && y==0)return true;\n\tif(x==0 || y==0)return false;\n\tfor(int i=0;i<n;i++)if(x>>i&1 && ((row[i]&y)==y || (row[i]&y)==0))return false;\n\tfor(int i=0;i<m;i++)if(y>>i&1 && ((col[i]&x)==x || (col[i]&x)==0))return false;\n\treturn true;\n}\nint C[15][15],f[15][15][3],g[15][15][3];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tfor(int i=0;i<=10;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)C[i][j]=ad(C[i-1][j]+C[i-1][j-1]);\n\t}\n\tn=read(),m=read();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%s\",ss);\n\t\tfor(int j=0;j<m;j++)a[i][j]=ss[j]=='.';\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)row[i]+=a[i][j]<<j;\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)col[i]+=a[j][i]<<j;\n\t}\n\tfor(int i=0;i<m;i++)f[0][i][2]=1<<i;\n\tf[n][m][0]=1<<m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tfor(int k=1;k<n-i;k++)\n\t\t\t{\n\t\t\t\tg[i+k][j][1]=ad(g[i+k][j][1]+1LL*ad(f[i][j][1]+ad(f[i][j][2]*2))*C[k+i][i]%mod);\n\t\t\t\tg[i+k][j][2]=ad(g[i+k][j][2]+1LL*f[i][j][2]*dec((1<<k)-2)%mod*C[k+i][i]%mod);\n\t\t\t}\n\t\t\tg[n][m][0]=ad(g[n][m][0]+1LL*f[i][j][2]*dec((1<<(n-i))-2)%mod*C[n][i]%mod*C[m][j]%mod);\n\t\t\tfor(int k=1;k<m-j;k++)\n\t\t\t{\n\t\t\t\tf[i][j+k][1]=ad(f[i][j+k][1]+1LL*ad(g[i][j][1]+ad(g[i][j][2]*2))*C[k+j][j]%mod);\n\t\t\t\tf[i][j+k][2]=ad(f[i][j+k][2]+1LL*g[i][j][2]*dec((1<<k)-2)%mod*C[k+j][j]%mod);\n\t\t\t}\n\t\t\tf[n][m][0]=ad(f[n][m][0]+1LL*g[i][j][2]*dec((1<<(m-j))-2)%mod*C[m][j]%mod*C[n][i]%mod);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tfor(int j=0;j<(1<<m);j++)\n\t\t{\n\t\t\tif(pd(i,j)==false)continue;\n\t\t\tint x=n,y=m;\n\t\t\tfor(int k=0;k<n;k++)if(i>>k&1)x--;\n\t\t\tfor(int k=0;k<m;k++)if(j>>k&1)y--;\n\t\t\tfor(int k=0;k<3;k++)ans=ad(ans+ad(f[x][y][k]+g[x][y][k]));\n\t\t}\n\t}pr2(ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "2^10 * 3^10 * 6 みたいなオーダーで行けそうな気がします"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int mod=998244353;\n#define N 23\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\n#define ck(x) (x>=mod?(x)-mod:x)\nint n,m,f[N][N][3],g[N][N][3],ans,c[N],r[N],cnt[1<<10];\nint pw2[N],C[N][N];\nchar mp[N][N];\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint Inv(int x){\n\treturn qpow(x,mod-2);\n}\nvoid init(int n){\n\tpw2[0]=C[0][0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tpw2[i]=ck(pw2[i-1]<<1);\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;++j){\n\t\t\tC[i][j]=ck(C[i-1][j-1]+C[i-1][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<(1<<n);++i){\n\t\tcnt[i]=cnt[i>>1]+(i&1);\n\t}\n}\nint Solve(int x,int y){\n\tfor(int i=1;i<=n;++i){\n\t\tif((x>>i-1)&1){\n\t\t\tif((r[i]&y)==0||(r[i]&y)==y)return 0;\n\t\t}\n\t}\n\tfor(int j=1;j<=m;++j){\n\t\tif((y>>j-1)&1){\n\t\t\tif((c[j]&x)==0||(c[j]&x)==x)return 0;\n\t\t}\n\t}\n\treturn 1LL*ck(f[cnt[x]][cnt[y]][0]+g[cnt[x]][cnt[y]][0])*Inv(C[n][cnt[x]])%mod*Inv(C[m][cnt[y]])%mod;\n}\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%s\",mp[i]+1);\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tr[i]|=((mp[i][j]=='#')<<j-1);\n\t\t\tc[j]|=((mp[i][j]=='#')<<i-1);\n\t\t}\n\t}\n\tinit(max(n,m));\n\tfor(int j=1;j<=m;++j){\n\t\tg[n][j][2]=1LL*C[m][j]*pw2[m-j]%mod;\n\t}\n\tans+=pw2[m];\n\tfor(int i=n;i>=1;--i){\n\t\tfor(int j=m;j>=1;--j){\n\t\t\tfor(int k=1;k<i;++k){\n\t\t\t\tint t=i-k;\n\t\t\t\tf[k][j][1]=(f[k][j][1]+(2LL*g[i][j][2]+g[i][j][1])*C[i][t])%mod;\n\t\t\t\tf[k][j][2]=(f[k][j][2]+1LL*g[i][j][2]*(pw2[t]-2)%mod*C[i][t])%mod;\n\t\t\t}\n\t\t\tfor(int k=1;k<j;++k){\n\t\t\t\tint t=j-k;\n\t\t\t\tg[i][k][1]=(g[i][k][1]+(2LL*f[i][j][2]+f[i][j][1])*C[j][t])%mod;\n\t\t\t\tg[i][k][2]=(g[i][k][2]+1LL*f[i][j][2]*(pw2[t]-2)%mod*C[j][t])%mod;\n\t\t\t}\n\t\t\tf[i][j][0]=ck(f[i][j][1]+f[i][j][2]);\n\t\t\tg[i][j][0]=ck(g[i][j][1]+g[i][j][2]);\n\t\t\tans=(ans+1LL*f[i][j][2]*(pw2[j]-2)+1LL*g[i][j][2]*(pw2[i]-2))%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<(1<<n);++i){\n\t\tfor(int j=1;j<(1<<m);++j){\n\t\t\tans=(ans+Solve(i,j))%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) true\n#define dump(x) true\n#endif\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tInitFact(10000);\n\n\tint H,W; cin >> H >> W;\n\tV<string> S(H); rep(i,H) cin >> S[i];\n\n\tmint dp[3][11][11][11][11] = {};\n\tbool done[3][11][11][11][11] = {};\n\tfunction<mint(int,int,int,int,int)> rec = [&](int c,int h,int w,int bh,int bw){\n\t\tif(h < bh || w < bw) return mint(0);\n\t\tif(h == bh && w == bw) return mint(1);\n\t\tif(done[c][h][w][bh][bw]) return dp[c][h][w][bh][bw];\n\t\tmint& res = dp[c][h][w][bh][bw];\n\t\tif(c == 1){\n\t\t\trep1(i,w-bw){\n\t\t\t\tres += rec(1,w-i,h,bw,bh) * Choose(w-bw,i);\n\t\t\t}\n\t\t}else{\n\t\t\trep1(i,w-bw) rep1(j,w-bw-i){\n\t\t\t\tres += rec(2,w-i-j,h,bw,bh) * Choose(w-bw,i)*Choose(w-bw-i,j);\n\t\t\t}\n\t\t\tres += rec(1,h,w,bh,bw)*2;\n\t\t}\n\t\tdone[c][h][w][bh][bw] = true;\n\t\treturn res;\n\t};\n\tVV<mint> f(H+1,V<mint>(W+1));\n\trep1(bh,H) rep1(bw,W){\n\t\trep(i,W-bw+1) rep(j,W-bw-i+1){\n\t\t\tf[bh][bw] += rec(2,W-i-j,H,bw,bh) * Choose(W-bw,i) * Choose(W-bw-i,j);\n\t\t}\n\t}\n\t{\n\t\tVV<mint> p = {\n\t\t\t{0,0,0,0,0,0,0,0,0,0,0},\n\t\t\t{0,2,4,8,16,32,64,128,256,512,1024},\n\t\t\t{0,4,14,46,146,454,1394,4246,12866,38854,117074},\n\t\t\t{0,8,46,230,1066,4718,20266,85310,354106,1455278,5938186},\n\t\t\t{0,16,146,1066,6902,41506,237686,1315666,7107302,37712866,197451926},\n\t\t\t{0,32,454,4718,41506,329462,2441314,17234438,117437746,779305142,76485309},\n\t\t\t{0,64,1394,20266,237686,2441314,22934774,202229266,703495653,844104725,406231977},\n\t\t\t{0,128,4246,85310,1315666,17234438,202229266,197176084,485832140,67048938,969814099},\n\t\t\t{0,256,12866,354106,7107302,117437746,703495653,485832140,539393474,598139740,429708905},\n\t\t\t{0,512,38854,1455278,37712866,779305142,844104725,67048938,598139740,555407722,910838124},\n\t\t\t{0,1024,117074,5938186,197451926,76485309,406231977,969814099,429708905,910838124,710838430}\n\t\t\t};\n\t\tf[0][0] = p[H][W];\n\t}\n\tshow(f);\n\tmint ans = 0;\n\trep(s,1<<H) rep(t,1<<W){\n\t\tint ha=0,hb=0,wa=0,wb=0;\n\t\trep(i,H) if((s>>i)&1){\n\t\t\trep(j,W) if((t>>j)&1){\n\t\t\t\tif(S[i][j] == '#') ha |= 1<<i, wa |= 1<<j;\n\t\t\t\telse hb |= 1<<i, wb |= 1<<j;\n\t\t\t}\n\t\t}\n\t\tif(s == ha && s == hb && t == wa && t == wb){\n\t\t\tshow(s);show(t);show(\"----------------\");\n\t\t\tans += f[__builtin_popcount(s)][__builtin_popcount(t)];\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 998244353;\n\nint madd(int a, int b) {\n\tint res = a + (b < 0 ? b + MOD : b);\n\treturn (res >= MOD ? res - MOD : res);\n}\n\nconst int N = 10;\nconst int M = 1 << N;\nint col[N][N];\nint dp[M][M];\nint alts[M * M][2*N+1];\n\nbool check(int m0, int m1) {\n\tvector<int> rc(N, 0), cc(N, 0);\n\tfor (int y = 0; y < N; ++y) {\n\t\tif (! (m0 & (1 << y))) rc[y] = 3;\n\t}\n\tfor (int x = 0; x < N; ++x) {\n\t\tif (! (m1 & (1 << x))) cc[x] = 3;\n\t}\n\tfor (int y = 0; y < N; ++y) {\n\t\tif (! (m0 & (1 << y))) continue;\n\t\tfor (int x = 0; x < N; ++x) {\n\t\t\tif (! (m1 & (1 << x))) continue;\n\t\t\trc[y] |= col[y][x];\n\t\t\tcc[x] |= col[y][x];\n\t\t}\n\t}\n\tbool works = true;\n\tfor (auto v : rc) works &= (v == 3);\n\tfor (auto v : cc) works &= (v == 3);\n\treturn works;\n}\n\n// Calculate alternating sum over submasks\nint altSum(int m0, int m1) {\n\tint m = m0 | (m1 << N);\n\talts[m][2*N] = dp[m0][m1];\n\tfor (int j = 2*N - 1; j >= 0; --j) {\n\t\tif (m & (1 << j)) {\n\t\t\talts[m][j] = madd(alts[m][j+1], -alts[m ^ (1 << j)][j+1]);\n\t\t} else {\n\t\t\talts[m][j] = alts[m][j+1];\n\t\t}\n\t}\n\treturn alts[m][0];\n}\n\n// Set value of DP at mask m0 m1 val.\nvoid setDP(int m0, int m1, int val) {\n\tdp[m0][m1] = val;\n\taltSum(m0, m1);\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint h, w;\n\tcin >> h >> w;\n\tfor (int y = 0; y < h; ++y) {\n\t\tstring row;\n\t\tcin >> row;\n\t\tfor (int x = 0; x < w; ++x) col[y][x] = 1 + (row[x] == '#');\n\t}\n\n\t// If any operations are applied, then some rows or some columns must be completely black or white\n\t// Delete those columns and rows and solve recursively. We need to do inclusion-exclusion to not double-count solutions.\n\t// Where does the initial state of the grid matter? If in some subgrid we have no completely black or white columns or rows,\n\t// we can add one to the solution for that subgrid!\n\t// To calculate the answer sufficiently fast, we'll need to do some prefix sums.\n\n\tint h0 = 1 << h;\n\tint h1 = 1 << w;\n\tfor (int m0 = 0; m0 < h0; ++m0) {\n\t\tsetDP(m0, 0, 1);\n\t}\n\tfor (int m1 = 0; m1 < h1; ++m1) {\n\t\tsetDP(0, m1, 1);\n\t}\n\n\tfor (int m0 = 0; m0 < h0; ++m0) {\n\t\tint rc = __builtin_popcount(m0);\n\t\tif (rc == 0) continue;\n\t\tfor (int m1 = 0; m1 < h1; ++m1) {\n\t\t\tint cc = __builtin_popcount(m1);\n\t\t\tif (cc == 0) continue;\n\n\t\t\tint res = check(m0, m1);\n\t\t\t// Inclusion-exclusion, paint only multiple rows\n\t\t\tfor (int s0 = m0;; s0 = (s0 - 1) & m0) {\n\t\t\t\tint pw = rc - __builtin_popcount(s0);\n\t\t\t\tif (pw > 1) {\n\t\t\t\t\tll mult = (ll)(pw & 1 ? 1 : MOD - 1) * ((1 << pw) - 2) % MOD;\n\t\t\t\t\tres = (res + (ll)mult * dp[s0][m1]) % MOD;\n\t\t\t\t}\n\t\t\t\tif (s0 == 0) break;\n\t\t\t}\n\t\t\t// Inclusion-exclusion, paint only multiple columns\n\t\t\tfor (int s1 = m1;; s1 = (s1 - 1) & m1) {\n\t\t\t\tint pw = cc - __builtin_popcount(s1);\n\t\t\t\tif (pw > 1) {\n\t\t\t\t\tll mult = (ll)(pw & 1 ? 1 : MOD - 1) * ((1 << pw) - 2) % MOD;\n\t\t\t\t\tres = (res + (ll)mult * dp[m0][s1]) % MOD;\n\t\t\t\t}\n\t\t\t\tif (s1 == 0) break;\n\t\t\t}\n\n\n\t\t\t// Inclusion-exclusion, paint both rows and columns\n\t\t\tint add = MOD - altSum(m0, m1);\n\t\t\tadd = madd(add, add);\n\t\t\tres = madd(res, add);\n\n\t\t\tsetDP(m0, m1, res);\n\t\t}\n\t}\n\tcout << dp[h0-1][h1-1] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool b) { return b ? \"true\" : \"false\"; }\ntemplate <size_t N> string to_string(bitset<N> bs) {\n  string res;\n  for (size_t i = 0; i < N; ++i) res += '0' + bs[i];\n  return res;\n}\nstring to_string(vector<bool> v) {\n  string res = \"{\";\n  for (bool e : v) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p);\ntemplate <class C> string to_string(C c) {\n  string res = \"{\";\n  for (auto e : c) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\nvoid debug() { cerr << '\\n'; }\ntemplate <class Head, class... Tail> void debug(Head head, Tail... tail) {\n  cerr << ' ' << to_string(head), debug(tail...);\n}\n#ifdef LOCAL\n#define DEBUG(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T> vector<T> operator-(vector<T> a) {\n  for (auto&& e : a) e = -e;\n  return a;\n}\ntemplate <class T> vector<T>& operator+=(vector<T>& l, const vector<T>& r) {\n  l.resize(max(l.size(), r.size()));\n  for (int i = 0; i < (int)r.size(); ++i) l[i] += r[i];\n  return l;\n}\ntemplate <class T> vector<T> operator+(vector<T> l, const vector<T>& r) {\n  return l += r;\n}\ntemplate <class T> vector<T>& operator-=(vector<T>& l, const vector<T>& r) {\n  l.resize(max(l.size(), r.size()));\n  for (int i = 0; i < (int)r.size(); ++i) l[i] -= r[i];\n  return l;\n}\ntemplate <class T> vector<T> operator-(vector<T> l, const vector<T>& r) {\n  return l -= r;\n}\ntemplate <class T> vector<T>& operator<<=(vector<T>& a, size_t n) {\n  return a.insert(begin(a), n, 0), a;\n}\ntemplate <class T> vector<T> operator<<(vector<T> a, size_t n) {\n  return a <<= n;\n}\ntemplate <class T> vector<T>& operator>>=(vector<T>& a, size_t n) {\n  return a.erase(begin(a), begin(a) + min(a.size(), n)), a;\n}\ntemplate <class T> vector<T> operator>>(vector<T> a, size_t n) {\n  return a >>= n;\n}\ntemplate <class T> vector<T> operator*(const vector<T>& l, const vector<T>& r) {\n  if (l.empty() or r.empty()) return {};\n  vector<T> res(l.size() + r.size() - 1);\n  for (int i = 0; i < (int)l.size(); ++i)\n    for (int j = 0; j < (int)r.size(); ++j) res[i + j] += l[i] * r[j];\n  return res;\n}\ntemplate <class T> vector<T>& operator*=(vector<T>& l, const vector<T>& r) {\n  return l = l * r;\n}\ntemplate <class T> vector<T> inverse(const vector<T>& a) {\n  assert(not a.empty() and not (a[0] == 0));\n  vector<T> b{1 / a[0]};\n  while (b.size() < a.size()) {\n    vector<T> x(begin(a), begin(a) + min(a.size(), 2 * b.size()));\n    x *= b * b;\n    b.resize(2 * b.size());\n    for (auto i = b.size() / 2; i < min(x.size(), b.size()); ++i) b[i] = -x[i];\n  }\n  return {begin(b), begin(b) + a.size()};\n}\ntemplate <class T> vector<T> operator/(vector<T> l, vector<T> r) {\n  if (l.size() < r.size()) return {};\n  reverse(begin(l), end(l)), reverse(begin(r), end(r));\n  int n = l.size() - r.size() + 1;\n  l.resize(n), r.resize(n);\n  l *= inverse(r);\n  return {rend(l) - n, rend(l)};\n}\ntemplate <class T> vector<T>& operator/=(vector<T>& l, const vector<T>& r) {\n  return l = l / r;\n}\ntemplate <class T> vector<T> operator%(vector<T> l, const vector<T>& r) {\n  if (l.size() < r.size()) return l;\n  l -= l / r * r;\n  return {begin(l), begin(l) + (r.size() - 1)};\n}\ntemplate <class T> vector<T>& operator%=(vector<T>& l, const vector<T>& r) {\n  return l = l % r;\n}\ntemplate <class T> vector<T> derivative(const vector<T>& a) {\n  vector<T> res(max((int)a.size() - 1, 0));\n  for (int i = 0; i < (int)res.size(); ++i) res[i] = (i + 1) * a[i + 1];\n  return res;\n}\ntemplate <class T> vector<T> primitive(const vector<T>& a) {\n  vector<T> res(a.size() + 1);\n  for (int i = 1; i < (int)res.size(); ++i) res[i] = a[i - 1] / i;\n  return res;\n}\ntemplate <class T> vector<T> logarithm(const vector<T>& a) {\n  assert(not a.empty() and a[0] == 1);\n  auto res = primitive(derivative(a) * inverse(a));\n  return {begin(res), begin(res) + a.size()};\n}\ntemplate <class T> vector<T> exponent(const vector<T>& a) {\n  assert(a.empty() or a[0] == 0);\n  vector<T> b{1};\n  while (b.size() < a.size()) {\n    vector<T> x(begin(a), begin(a) + min(a.size(), 2 * b.size()));\n    x[0] += 1;\n    b.resize(2 * b.size());\n    x -= logarithm(b);\n    x *= {begin(b), begin(b) + b.size() / 2};\n    for (auto i = b.size() / 2; i < min(x.size(), b.size()); ++i) b[i] = x[i];\n  }\n  return {begin(b), begin(b) + a.size()};\n}\n\ntemplate <class T, class F = multiplies<T>>\nT power(T a, long long n, F op = multiplies<T>(), T e = {1}) {\n  assert(n >= 0);\n  T res = e;\n  while (n) {\n    if (n & 1) res = op(res, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return res;\n}\n\ntemplate <unsigned Mod> struct Modular {\n  using M = Modular;\n  unsigned v;\n  Modular(long long a = 0) : v((a %= Mod) < 0 ? a + Mod : a) {}\n  M operator-() const { return M() -= *this; }\n  M& operator+=(M r) { if ((v += r.v) >= Mod) v -= Mod; return *this; }\n  M& operator-=(M r) { if ((v += Mod - r.v) >= Mod) v -= Mod; return *this; }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % Mod; return *this; }\n  M& operator/=(M r) { return *this *= power(r, Mod - 2); }\n  friend M operator+(M l, M r) { return l += r; }\n  friend M operator-(M l, M r) { return l -= r; }\n  friend M operator*(M l, M r) { return l *= r; }\n  friend M operator/(M l, M r) { return l /= r; }\n  friend bool operator==(M l, M r) { return l.v == r.v; }\n  friend string to_string(M a) { return to_string(a.v); }\n};\n\nconstexpr long long mod = 998244353;\nusing Mint = Modular<mod>;\n\nvector<Mint> fact, inv_fact, minv;\nvoid prepare(int n) {\n  fact.resize(n + 1), inv_fact.resize(n + 1), minv.resize(n + 1);\n  for (int i = 0; i <= n; ++i) fact[i] = i ? i * fact[i - 1] : 1;\n  inv_fact[n] = 1 / fact[n];\n  for (int i = n; i; --i) inv_fact[i - 1] = i * inv_fact[i];\n  for (int i = 1; i <= n; ++i) minv[i] = inv_fact[i] * fact[i - 1];\n}\nMint binom(int n, int k) {\n  if (k < 0 or k > n) return 0;\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\ntemplate<> Mint& Mint::operator/=(Mint r) {\n  return *this *= r.v < minv.size() ? minv[r.v] : power(r, mod - 2);\n}\n\nvector<Mint> gf(int k, int lim = 11) {\n  prepare(2 * lim);\n  vector<Mint> num(lim), den(lim);\n  den[1] = -1;\n  den = vector<Mint>{1} - exponent(den);\n  for (int i = 1; i <= lim; ++i) {\n    num += power(den, i) * vector<Mint>{power(Mint(i), k)};\n  }\n  num >>= 1, den >>= 1;\n  num *= inverse(den);\n  num.resize(lim);\n  for (int i = 0; i < lim; ++i) {\n    num[i] *= fact[i];\n  }\n  return num;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int h, w;\n  cin >> h >> w;\n  cout << gf(w)[h].v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nvoid ckmax(int &x,int y){\n\tif (x<y)\n\t\tx=y;\n}\nvoid ckmin(int &x,int y){\n\tif (x>y)\n\t\tx=y;\n}\nconst int N=15;\nint n,m,nm;\nint v[N][N];\nint C[N][N],invC[N][N];\nvoid prework(){\n\tFor(i,0,nm){\n\t\tC[i][0]=invC[i][0]=1;\n\t\tFor(j,1,i){\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tinvC[i][j]=Pow(C[i][j],mod-2);\n\t\t}\n\t}\n}\nint f[N][N][3],g[N][N][3];\nint res[N][N];\nint main(){\n\tn=read(),m=read(),nm=max(n,m);\n\tFor(i,0,n-1){\n\t\tstring s;\n\t\tcin>>s;\n\t\tFor(j,0,m-1)\n\t\t\tv[i][j]=s[j]=='#';\n\t}\n\tprework();\n\tint ans=1<<n;\n\tFor(i,0,n-1)\n\t\tAdd(f[n-i][m][2],((LL)C[n][i]<<i)%mod);\n\tFod(i,n,1)\n\t\tFod(j,m,1){\n\t\t\tAdd(res[i][j],f[i][j][1]);\n\t\t\tAdd(res[i][j],f[i][j][2]);\n\t\t\tFor(k,1,j-1){\n\t\t\t\tAdd(g[i][j-k][1],(LL)f[i][j][2]*2*C[j][k]%mod);\n\t\t\t\tAdd(g[i][j-k][1],(LL)f[i][j][1]*C[j][k]%mod);\n\t\t\t\tAdd(g[i][j-k][2],(LL)f[i][j][2]*((1<<k)-2)%mod*C[j][k]%mod);\n\t\t\t}\n\t\t\tAdd(ans,(LL)f[i][j][2]*((1<<j)-2)%mod);\n\t\t\t/********************************/\n\t\t\tAdd(res[i][j],g[i][j][1]);\n\t\t\tAdd(res[i][j],g[i][j][2]);\n\t\t\tFor(k,1,i-1){\n\t\t\t\tAdd(f[i-k][j][1],(LL)g[i][j][2]*2*C[i][k]%mod);\n\t\t\t\tAdd(f[i-k][j][1],(LL)g[i][j][1]*C[i][k]%mod);\n\t\t\t\tAdd(f[i-k][j][2],(LL)g[i][j][2]*((1<<k)-2)%mod*C[i][k]%mod);\n\t\t\t}\n\t\t\tAdd(ans,(LL)g[i][j][2]*((1<<i)-2)%mod);\n\t\t}\n\tFor(a,1,(1<<n)-1)\n\t\tFor(b,1,(1<<m)-1){\n\t\t\tint flag=1;\n\t\t\tint x=0,y=0;\n\t\t\tFor(i,0,n-1){\n\t\t\t\tif (~a>>i&1)\n\t\t\t\t\tcontinue;\n\t\t\t\tx++;\n\t\t\t\tvi c(2,0);\n\t\t\t\tFor(j,0,m-1)\n\t\t\t\t\tif (b>>j&1)\n\t\t\t\t\t\tc[v[i][j]]++;\n\t\t\t\tif (!c[0]||!c[1])\n\t\t\t\t\tflag=0;\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tcontinue;\n\t\t\tFor(j,0,m-1){\n\t\t\t\tif (~b>>j&1)\n\t\t\t\t\tcontinue;\n\t\t\t\ty++;\n\t\t\t\tvi c(2,0);\n\t\t\t\tFor(i,0,n-1)\n\t\t\t\t\tif (a>>i&1)\n\t\t\t\t\t\tc[v[i][j]]++;\n\t\t\t\tif (!c[0]||!c[1])\n\t\t\t\t\tflag=0;\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t\tcontinue;\n\t\t\tAdd(ans,(LL)res[x][y]*invC[n][x]%mod*invC[m][y]%mod);\n\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n\nset<vector<string>> allfi, allnotin, allbein;\nvoid rec(vector<string> fi, set<int> &yoko, set<int> &tate, bool bein, int H, int W) {\n    if (yoko.size() == H && tate.size() == W) {\n        allfi.insert(fi);\n        if (bein) allbein.insert(fi);\n        else allnotin.insert(fi);\n    }\n    auto ifi = fi;\n    for (int h = 0; h < H; ++h) {\n        if (yoko.count(h)) continue;\n        yoko.insert(h);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '.';\n        rec(fi, yoko, tate, bein, H, W);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '#';\n        rec(fi, yoko, tate, (bein || (tate.empty() && true)), H, W);\n        fi = ifi;\n        yoko.erase(h);\n    }\n    for (int w = 0; w < W; ++w) {\n        if (tate.count(w)) continue;\n        tate.insert(w);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '.';\n        rec(fi, yoko, tate, bein, H, W);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '#';\n        rec(fi, yoko, tate, (bein || (yoko.empty() && true)), H, W);\n        fi = ifi;\n        tate.erase(w);\n    }\n}\n\nset<vector<string>> allsub;\nvoid rec2(vector<string> fi, set<int> &yoko, set<int> &tate, int H, int W) {\n    if (yoko.size() == H && tate.size() == W) {\n        allsub.insert(fi);\n    }\n    auto ifi = fi;\n    for (int h = 0; h < H; ++h) {\n        if (yoko.count(h)) continue;\n        yoko.insert(h);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '.';\n        rec2(fi, yoko, tate, H, W);\n        fi = ifi;\n        yoko.erase(h);\n    }\n    for (int w = 0; w < W; ++w) {\n        if (tate.count(w)) continue;\n        tate.insert(w);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '#';\n        rec2(fi, yoko, tate, H, W);\n        fi = ifi;\n        tate.erase(w);\n    }\n}\n\nlong long calc(int H, int W) {\n    allfi.clear();\n    allnotin.clear(), allbein.clear();\n    set<int> yoko, tate;\n    vector<string> fi(H+1, string(W+1, '.'));\n    auto fi2 = fi;\n    rec(fi, yoko, tate, false, H, W);\n    return allfi.size();\n}\n\nlong long calc2(int H, int W) {\n    set<int> yoko, tate;\n    vector<string> fi(H+1, string(W+1, '.'));\n    allsub.clear();\n    rec2(fi, yoko, tate, H, W);\n    return allsub.size();\n}\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nint H, W;\nvector<string> A;\n\nint main() {\n    bc.init(110);\n\n    // 長方形\n    vector<vector<mint>> all(15, vector<mint>(15, 0));\n    auto bein = all;\n    auto notin = all;\n    for (int i = 0; i < 15; ++i) all[0][i] = all[i][0] = modpow(mint(2), i);\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            notin[a][b] = 1;\n            for (int i = 1; i < a; ++i) {\n                for (int j = 1; j < b; ++j) {\n                    notin[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n        }\n    }\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            bein[a][b] = 1;\n            for (int i = 0; i < a; ++i) {\n                for (int j = 0; j < b; ++j) {\n                    if (i + j == 0) continue;\n                    bein[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n            all[a][b] = notin[a][b] + bein[a][b];\n        }\n    }\n\n    // はみ出しあり\n    vector<vector<mint>> subsub(15, vector<mint>(15, 0));\n    auto sub = subsub, part = subsub;\n    for (int i = 0; i < 15; ++i) {\n        subsub[1][i] = 1;\n        subsub[i][1] = modpow(mint(2), i) - 1;\n    }\n    for (int s = 2; s < 30; ++s) {\n        for (int a = 1; a < 15; ++a) {\n            int b = s - a;\n            if (b < 1 || b >= 15) continue;\n            subsub[a][b] = 1;\n            for (int i = 1; i < a; ++i) {\n                subsub[a][b] += bc.com(a, i) * subsub[b][a-i];\n            }\n        }\n    }\n    for (int a = 0; a < 15; ++a) {\n        for (int b = 0; b < 15; ++b) {\n            if (a == 0) sub[a][b] = 1;\n            else if (b == 0) sub[a][b] = 1;\n            else sub[a][b] = subsub[a][b] + subsub[b][a];\n        }\n    }\n\n    for (int i = 0; i < 15; ++i) part[0][i] = part[i][0] = modpow(mint(2), i);\n    for (int a = 1; a < 14; ++a) {\n        for (int b = 1; b < 14; ++b) {\n            for (int i = 0; i <= a; ++i) {\n                for (int j = 0; j <= b; ++j) {\n                    part[a][b] += bc.com(a, i) * bc.com(b, j) *\n                        sub[i][j] * sub[a-i][b-j];\n                }\n            }\n        }\n    }\n\n    /*\n    for (int a = 0; a <= 5; ++a) {\n        for (int b = 0; b <= 5; ++b) {\n            calc(a, b);\n            cout << a << \",\" << b << \": \" << part[a][b] << \"( \" << sub[a][b] << \" ), \" << allfi.size() << \", \" << calc2(a, b) << endl;\n        }\n    }\n    \n    \n    calc(1, 2);\n    COUT(allfi.size());\n    for (auto fi : allfi) {\n        for (auto s : fi) cout << s << endl;\n        cout << endl;\n    }\n    */\n    \n\n    cin >> H >> W;\n    A.resize(H);\n    for (int h = 0; h < H; ++h) cin >> A[h];\n\n    mint res = all[H][W];\n    for (int bit = 0; bit < (1<<H)-1; ++bit) {\n        vector<int> tate;\n        for (int i = 0; i < H; ++i) if (!(bit & (1<<i))) tate.push_back(i);\n        for (int bit2 = 0; bit2 < (1<<W)-1; ++bit2) {\n            vector<int> yoko;\n            for (int i = 0; i < W; ++i) if (!(bit2 & (1<<i))) yoko.push_back(i);\n\n            bool ok = true;\n            for (auto i : tate) {\n                set<char> se;\n                for (auto j : yoko) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n            for (auto j : yoko) {\n                set<char> se;\n                for (auto i : tate) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n\n            if (ok) {\n                int c = __builtin_popcount(bit);\n                int r = __builtin_popcount(bit2);\n                mint add = part[c][r];\n                res += add;\n\n                //cout << bit << \", \" << bit2 << \": \" << tate << \", \" << yoko << \";; \" << c << \", \" << r << \": \" << add << endl;\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tr1/unordered_map>\n#define ri register int\nusing namespace std;\ntypedef double db;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector <int> poly;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntypedef unsigned long long ulll;\ntypedef unsigned int uii;\ntypedef string strr;\n#define fi first\n#define se second\n#define pb push_back\n#define ppp pop_back\n#define rez resize\nconst ll Inf = 2e18;\nconst int rlen = 1 << 20, inf = 0x3f3f3f3f;\nchar buf[rlen], *ib = buf, *ob = buf;\n#define gc() (((ib == ob) && (ob = (ib =  buf) + fread(buf, 1, rlen, stdin)), ib == ob) ? -1 : *ib++)\ninline int read() {\n  static int ans, f;\n  static char ch;\n  ans = 0, ch = gc(), f = 1;\n  while (!isdigit(ch)) f ^= ch == '-', ch = gc();\n  while (isdigit(ch)) ans = (ans << 3) + (ans << 1) + (ch ^ 48), ch = gc();\n  return f ? ans: -ans;\n}\ninline ll readl() {\n  static ll ans;\n  static char ch;\n  for (ans = 0, ch = gc(); !isdigit(ch); ch = gc());\n  while (isdigit(ch)) ans = ((ans << 2) + ans << 1) + (ch ^ 48), ch = gc();\n  return ans;\n}\ninline int Read(char *s) {\n  static int top;\n  static char ch;\n  top = 0, ch = gc();\n  while (!isalpha(ch) && !isdigit(ch)) ch = gc();\n  while (isalpha(ch) || isdigit(ch)) s[++top] = ch, ch = gc();\n  return top;\n}\nnamespace modular {\n  const int mod = 998244353;// = 1e9 + 7;\n  //int mod;\n  int ret;\n  inline int add(int a, int b) { return a + b < mod ? a + b : a + b - mod; }\n  inline int dec(int a, int b) { return a < b ? a - b + mod : a - b; }\n  inline int mul(int a, int b) { return (ll) a * b % mod; }\n  inline void Add(int &a, int b) { a = a + b < mod ? a + b : a + b - mod; }\n  inline void Dec(int &a, int b) { a = a < b? a - b + mod : a - b; }\n  inline void Mul(int &a, int b) { a = (ll) a * b % mod; }\n  inline int ksm(int a, int p) {\n    for (ret = 1; p; p >>= 1, Mul(a, a)) (p & 1) && (Mul(ret, a), 1);\n    return ret;\n  }\n  inline int Inv(int a) { return ksm(a, mod - 2); }\n  inline int sqr(int a) { return (ll) a * a % mod; }\n  inline int cub(int a) { return (ll) a * a % mod * a % mod; }\n} using namespace modular;\ntemplate <typename T> inline void ckmax(T &a, T b) { a < b ? a = b : 0; }\ntemplate <typename T> inline void ckmin(T &a, T b) { a > b ? a = b : 0; }\ntemplate <typename T> inline T Abs(T a) { return a < 0 ? -a : a; }\ntemplate <typename T> inline T gcd(T a, T b) {\n  T t;\n  while (b) t = a, a = b, b = t - t / a * a;\n  return a;\n}\ntemplate <typename T> inline void exgcd(T a, T b, T &x, T &y) {\n  if (!b) {\n    x = 1, y = 0;\n    return;\n  }\n  exgcd(b, a - a / b * b, y, x);\n  y -= a / b * x;\n}\nconst int N = 15;\nint n, m, H[N][N][2], L[N][N][2], mx, cnt[1 << 12], C[N][N], pw[N];\nchar s[N][N];\ninline int calc(int x, int y) {\n  int res = add(add(L[x][y][0], L[x][y][1]), add(H[x][y][0], H[x][y][1]));\n  return mul(res, Inv(mul(C[n][x], C[m][y])));\n}\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\", \"r\", stdin);\n  #endif\n  scanf(\"%d%d\", &n, &m), mx = 1 << max(n, m);\n  for (ri i = 1; i < mx; ++i) cnt[i] = cnt[i >> 1] + (i & 1);\n  for (ri i = 0; i < n; ++i) scanf(\"%s\", s[i]);\n  pw[0] = 1;\n  for (ri i = 1; i <= max(n, m); ++i) pw[i] = add(pw[i - 1], pw[i - 1]);\n  for (ri i = 0; i <= max(n, m); ++i) for (ri j = C[i][0] = 1; j <= i; ++j) C[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);\n  for (ri i = 1; i <= m; ++i) L[n][i][1] = mul(C[m][i], pw[m - i]);\n  int res = 0, _n = 1 << n, _m = 1 << m;\n  for (ri i = n; i; --i) for (ri j = m; j; --j) {\n    for (ri x = 1; x < i; ++x) {\n      Add(H[x][j][0], mul(add(L[i][j][0], mul(2, L[i][j][1])), C[i][x]));\n      Add(H[x][j][1], mul(L[i][j][1], mul(C[i][x], dec(pw[i - x], 2))));\n    }\n    for (ri y = 1; y < j; ++y) {\n      Add(L[i][y][0], mul(add(H[i][j][0], mul(2, H[i][j][1])), C[j][y]));\n      Add(L[i][y][1], mul(H[i][j][1], mul(C[j][y], dec(pw[j - y], 2))));\n    }\n    Add(res, mul(L[i][j][1], dec(pw[i], 2)));\n    Add(res, mul(H[i][j][1], dec(pw[j], 2)));\n  }\n  Add(res, 1 << m);\n  for (ri s1 = 1; s1 < _n; ++s1) for (ri s2 = 1; s2 < _m; ++s2) {\n    int ct1 = cnt[s1], ct2 = cnt[s2], ct;\n    bool ff = 1;\n    for (ri i = 0; i < n; ++i) if (s1 >> i & 1) {\n      ct = 0;\n      for (ri j = 0; j < m; ++j) if (s2 >> j & 1) ct += s[i][j] == '#';\n      if (!ct || ct == ct2) {\n        ff = 0;\n        break;\n      }\n    }\n    if (!ff) continue;\n    for (ri i = 0; i < m; ++i) if (s2 >> i & 1) {\n      ct = 0;\n      for (ri j = 0; j < n; ++j) if (s1 >> j & 1) ct += s[j][i] == '#';\n      if (!ct || ct == ct1) {\n        ff = 0;\n        break;\n      }\n    }\n    if (!ff) continue;\n    Add(res, calc(ct1, ct2));\n  }\n  cout << res;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=20,mod=998244353;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\nint Power(int a,int k,int p=mod){int res=1;for (;k;k>>=1,smul(a,a,p)) if (k&1) smul(res,a,p);return res;}\nint Get_inv(int a,int p=mod){return Power(a,p-2,p);}\n\nint n,m,r[N+9],c[N+9];\nchar s[N+9];\n\nvoid into(){\n  scanf(\"%d%d\",&n,&m);\n  for (int i=1;i<=n;++i){\n\tscanf(\"%s\",s+1);\n\tfor (int j=1;j<=m;++j) r[i]|=(s[j]=='#')<<j-1,c[j]|=(s[j]=='#')<<i-1;\n  }\n}\n\nint inv[N+9],fac[N+9],ifac[N+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n+m;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint Get_c(int n,int m){return n<m||m<0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}\n\nint dp0[N+9][N+9][3],dp1[N+9][N+9][3],ans;\n\nvoid Get_dp(){\n  for (int j=1;j<=m;++j) dp0[n][j][2]=mul(Get_c(m,j),1<<m-j);\n  ans=1<<m;\n  for (int i=n;i>=1;--i)\n\tfor (int j=m;j>=1;--j){\n\t  dp0[i][j][0]=add(dp0[i][j][1],dp0[i][j][2]);\n\t  for (int k=1;k<i;++k){\n\t\tsadd(dp1[k][j][1],mul(Get_c(i,k),add(mul(dp0[i][j][2],2),dp0[i][j][1])));\n\t\tsadd(dp1[k][j][2],mul(Get_c(i,k),mul((1<<i-k)-2,dp0[i][j][2])));\n\t  }\n\t  sadd(ans,mul(dp0[i][j][2],(1<<i)-2));\n\t  dp1[i][j][0]=add(dp1[i][j][1],dp1[i][j][2]);\n\t  for (int k=1;k<j;++k){\n\t\tsadd(dp0[i][k][1],mul(Get_c(j,k),add(mul(dp1[i][j][2],2),dp1[i][j][1])));\n\t\tsadd(dp0[i][k][2],mul(Get_c(j,k),mul((1<<j-k)-2,dp1[i][j][2])));\n\t  }\n\t  sadd(ans,mul(dp1[i][j][2],(1<<j)-2));\n\t}\n  for (int u=1;u<1<<n;++u)\n\tfor (int v=1;v<1<<m;++v){\n      int flag=1;\n\t  for (int i=0;i<n;++i)\n\t\tif (u>>i&1){\n\t\t  int t=r[i+1]&v;\n\t\t  if (!t||t==v) flag=0;\n\t\t}\n\t  for (int i=0;i<m;++i)\n\t\tif (v>>i&1){\n\t\t  int t=c[i+1]&u;\n\t\t  if (!t||t==u) flag=0;\n\t\t}\n\t  if (!flag) continue;\n\t  int x=0,y=0;\n\t  for (int i=0;i<n;++i) x+=u>>i&1;\n\t  for (int i=0;i<m;++i) y+=v>>i&1;\n\t  sadd(ans,mul(add(dp0[x][y][0],dp1[x][y][0]),Get_inv(mul(Get_c(n,x),Get_c(m,y)))));\n\t}\n}\n\nvoid work(){\n  Get_inv();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\nconst uint mod=998244353;\n//const uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend mint operator+(int x,const mint&y){\n\t\treturn mint(x)+y;\n\t}\n\tfriend mint operator-(int x,const mint&y){\n\t\treturn mint(x)-y;\n\t}\n\tfriend mint operator*(int x,const mint&y){\n\t\treturn mint(x)*y;\n\t}\n\tfriend mint operator/(int x,const mint&y){\n\t\treturn mint(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,mint&m){\n\t\tll x;is>>x;\n\t\tm=mint(x);\n\t\treturn is;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n\tbool operator!=(const mint&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nconst int nmax=22;\nchar s[nmax][nmax];\n\nmint ysp(int h,int w){\n\tif(h==0||w==0)return 1;\n\tvvc<mint> dp(h+1,vc<mint>(w+1));\n\trep(j,w+1)\n\t\tdp[0][j]=finv[j];\n\tmint num;\n\trep(_,h+w+1){\n\t\t{\n\t\t\tvvc<mint> nx(h+1,vc<mint>(w+1));\n\t\t\trep(i,h)rep(j,w+1)rng(k,1,h-i+1)\n\t\t\t\tnx[i+k][j]+=dp[i][j]*finv[k];\n\t\t\tswap(dp,nx);\n\t\t\tnum+=dp[h][w];\n\t\t}\n\t\t{\n\t\t\tvvc<mint> nx(h+1,vc<mint>(w+1));\n\t\t\trep(i,h+1)rep(j,w)rng(k,1,w-j+1)\n\t\t\t\tnx[i][j+k]+=dp[i][j]*finv[k];\n\t\t\tswap(dp,nx);\n\t\t\tnum+=dp[h][w];\n\t\t}\n\t}\n\treturn num*fact[h]*fact[w];\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint h,w;cin>>h>>w;\n\trep(i,h)cin>>s[i];\n\t\n\tvvc<int> cnt(h+1,vi(w+1));\n\trep(a,1<<h)rep(b,1<<w){\n\t\tbool ok=true;\n\t\tif((a==0)^(b==0))continue;\n\t\tif(a){\n\t\t\tassert(b);\n\t\t\tint r=botbit(a),c=botbit(b);\n\t\t\tif(ok){\n\t\t\t\trep(i,h)if(a&1<<i){\n\t\t\t\t\tchar x=s[i][c];\n\t\t\t\t\tbool same=true;\n\t\t\t\t\trep(j,w)if(b&1<<j){\n\t\t\t\t\t\tif(x!=s[i][j]){\n\t\t\t\t\t\t\tsame=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(same){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\trep(j,w)if(b&1<<j){\n\t\t\t\t\tchar x=s[r][j];\n\t\t\t\t\tbool same=true;\n\t\t\t\t\trep(i,h)if(a&1<<i){\n\t\t\t\t\t\tif(x!=s[i][j]){\n\t\t\t\t\t\t\tsame=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(same){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)\n\t\t\tcnt[h-popcount(a)][w-popcount(b)]+=1;\n\t}\n\t\n\tdmp(cnt);\n\t\n\tvvc<mint> table(h+1,vc<mint>(w+1));\n\trep(r,h+1)rep(c,w+1)\n\t\ttable[r][c]=ysp(r,c);\n\t\n\tmint ans;\n\trep(r,h)rep(c,w){\n\t\tmint num;\n\t\t\n\t\trep(a,r+1)rep(b,c+1){\n\t\t\tnum+=choose(r,a)*choose(c,b)*table[a][c-b]*table[r-a][b];\n\t\t}\n\t\t\n\t\tans+=num*cnt[r][c];\n\t}\n\tdmp(ans);\n\tdmp(table);\n\t\n\tans+=table[h][w]*cnt[h][w];\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll four[] = {0, 1, 0, -1, 0};\nconst ll eight[] = {0, 1, 1, 0, -1, -1, 1, -1, 0};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n)-1;i>=0;i--)\n#define rrep2(i,n) for(ll i=(n)-1;i>=0;i--)\n#define rrep3(i,a,b) for(ll i=(b)-1;i>=(a);i--)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto&& i:a)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++) { int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\nvoid err(){ putchar('\\n'); }\ntemplate<class T> void err(const T& t){ print(t); putchar('\\n'); }\ntemplate<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\ntemplate<class... T> void err(const T&...){}\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\nconstexpr uint mod = MODD;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint(){}\n    constexpr Modint(const Modint &x) : num(x.num){}\n    inline constexpr operator ll() const { return num; }\n    inline constexpr Modint& operator+=(Modint x){ num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++(){ if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int){ Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator- () const { return Modint(0) -= *this; }\n    inline constexpr Modint operator- (Modint x) const { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x){ if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--(){ if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int){ Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x){ num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x){ return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x){ x %= T(mod); if(x < 0) x += mod; num = uint(x); }\n    template<class T> inline constexpr Modint operator+(T x) const { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x){ x %= mod; if(x < 0) x += mod; num += x; if(num >= mod) num -= mod; return *this; }\n    template<class T> inline constexpr Modint operator- (T x) const { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x){ return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator* (T x) const { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x){ return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/ (T x) const { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x){ return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) const { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x) { ll a; in(a); x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(n + 1); return fac[n] * inv[n - r]; }\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(n + 1); return fac[n] * inv[r] * inv[n - r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r個をn部屋に分ける\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nsigned main(){\n    LL(h,w);\n    VEC(string,s,h);\n    Modint dp[h+1][w+1][3];\n    memset(dp,0x00,sizeof(dp));\n    rep(i,1,h+1)rep(j,1,w+1){\n        dp[i][j][0]=2;\n        rep(i2,1,i)rep(j2,1,j)dp[i][j][0]+=dp[i2][j2][0]*comb(i,i2)*comb(j,j2);\n    }\n    rep(i,1,h+1)rep(j,1,w+1){\n        if(i>1)dp[i][j][2]=2_M .pow(i)-2;\n        if(j>1)dp[i][j][1]=2_M .pow(j)-2;\n        rep(i2,1,i-1)dp[i][j][2]+=dp[i2][j][1]*comb(i,i2)*(2_M .pow(i-i2)-2);\n        rep(j2,1,j-1)dp[i][j][1]+=dp[i][j2][2]*comb(j,j2)*(2_M .pow(j-j2)-2);\n    }\n    rep(i,1,h+1)rep(j,1,w+1)dp[i][j][0]+=dp[i][j][1]+dp[i][j][2];\n    vector<uint>conflict;\n    rep(h)rep(i2,i+1,h)rep(j,w)if(s[i][j]!=s[i2][j])rep(j2,j+1,w)if(s[i][j]!=s[i][j2]&&s[i2][j]!=s[i2][j2]){\n        conflict.push_back(0);\n        conflict.back()|=1<<i;\n        conflict.back()|=1<<i2;\n        conflict.back()|=1<<(j+10);\n        conflict.back()|=1<<(j2+10);\n    }\n    vec(bool,used,1<<20);\n    Modint ans=dp[h][w][0];\n    used[0]=1;\n    each(i,conflict)out(i);\n    for(uint i=0;i<1<<20;i++)if(used[i])each(j,conflict)if(!used[i|j]){\n        auto k=i|j;\n        used[i|j]=1;\n        ans+=dp[h-__builtin_popcount(k>>10)][w-__builtin_popcount(k<<22)][0];\n    }\n    out(ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nLL two[SIZE];\nchar s[12][12];\nint col[12][12];\nLL dp[11][11];\nLL dp2[11][11];\nint N,M;\nLL C[11][11];\nLL tmp[11][11];\nint ng(int x){\n    if(x&1)return 1;\n    return -1;\n}\nLL f(int x,int y){\n    if(!x||!y)return two[x+y];\n    return 2;\n}\nvoid pre2(){\n    REP(i,11)dp[0][i]=dp[i][0]=two[i];\n    FOR(i,1,10)FOR(j,1,10){\n        FOR(ii,0,i)FOR(jj,0,j){\n            if(ii+jj==0)continue;\n            ADD(dp[i][j],dp[i-ii][j-jj]*f(ii,jj)%MOD*C[i][ii]%MOD*C[j][jj]*ng(ii+jj));\n        }\n    }\n}\nvoid pre(){\n    two[0]=1;\n    REPP(i,1,SIZE)two[i]=two[i-1]*2%MOD;\n    REP(i,11){\n        C[i][0]=1;\n        REPP(j,1,11){\n            C[i][j]=C[i-1][j-1]+C[i-1][j];\n            if(C[i][j]>=MOD)C[i][j]-=MOD;\n        }\n    }\n    pre2();\n    /*\n    FOR(i,0,10)FOR(j,0,10){\n        dp[i][j]=calc(i,j);\n    }\n    */\n\n    dp2[0][0]=1;\n    REP(i,11)dp2[0][i]=dp2[i][0]=1;\n    FOR(i,1,10)FOR(j,1,10){\n        FOR(ii,0,i)FOR(jj,0,j){\n            if(ii+jj==0)continue;\n            ADD(dp2[i][j],dp2[i-ii][j-jj]*f(ii,jj)%MOD*C[i][ii]%MOD*C[j][jj]*ng(ii+jj));\n        }\n    }\n}\nVPII grid[20];\nint cnt[20][2];\nint ban[20];\nLL an;\nvoid dfs(int x,int n,int m){\n    if(n>=N-1||m>=M-1)return;\n    if(x==N+M){\n        REP(i,N+M){\n            if(ban[i])continue;\n            if(!cnt[i][0]||!cnt[i][1])return;\n        }\n        ADD(an,dp[n][m]);\n        return;\n    }\n    dfs(x+1,n,m);\n    if(x<N){\n        for(auto v:grid[x]){\n            cnt[v.S+N][col[v.F][v.S]]--;\n        }\n    }\n    else{\n        for(auto v:grid[x]){\n            cnt[v.F][col[v.F][v.S]]--;\n        }\n    }\n    ban[x]=1;\n    dfs(x+1,n+(x<N),m+(x>=N));\n    ban[x]=0;\n    if(x<N){\n        for(auto v:grid[x]){\n            cnt[v.S+N][col[v.F][v.S]]++;\n        }\n    }\n    else{\n        for(auto v:grid[x]){\n            cnt[v.F][col[v.F][v.S]]++;\n        }\n    }\n}\nint main(){\n    MOD=998244353;\n    pre();\n    R(N,M);\n    REP(i,N)RS(s[i]);\n    REP(i,N)REP(j,M){\n        grid[i].PB({i,j});\n        grid[j+N].PB({i,j});\n        int cc=0;\n        if(s[i][j]=='#')cc=1;\n        col[i][j]=cc;\n        cnt[i][cc]++;\n        cnt[j+N][cc]++;\n    }\n    an=dp2[N][M];\n    dfs(0,0,0);\n    W(an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int mod=998244353;\ninline int ad(int x){return x>=mod?x-mod:x;}\ninline int dec(int x){return x<0?x+mod:x;}\nchar ss[15];\nint n,m,a[15][15],row[15],col[15];\ninline bool pd(int x,int y)\n{\n\tif(x==0 && y==0)return true;\n\tif(x==0 || y==0)return false;\n\tfor(int i=0;i<n;i++)if(x>>i&1 && ((row[i]&y)==y || (row[i]&y)==0))return false;\n\tfor(int i=0;i<m;i++)if(y>>i&1 && ((col[i]&x)==x || (col[i]&x)==0))return false;\n\treturn true;\n}\nint C[15][15],f[15][15][3],g[15][15][3];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tfor(int i=0;i<=10;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)C[i][j]=ad(C[i-1][j]+C[i-1][j-1]);\n\t}\n\tn=read(),m=read();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%s\",ss);\n\t\tfor(int j=0;j<m;j++)a[i][j]=ss[j]=='.';\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)row[i]+=a[i][j]<<j;\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)col[i]+=a[j][i]<<j;\n\t}\n\tfor(int i=0;i<m;i++)f[0][i][2]=1<<i;\n\tf[n][m][0]=1<<m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tfor(int k=1;k<n-i;k++)\n\t\t\t{\n\t\t\t\tg[i+k][j][1]=ad(g[i+k][j][1]+1LL*ad(f[i][j][1]+ad(f[i][j][2]*2))*C[k+i][i]%mod);\n\t\t\t\tg[i+k][j][2]=ad(g[i+k][j][2]+1LL*f[i][j][2]*dec((1<<k)-2)%mod*C[k+i][i]%mod);\n\t\t\t}\n\t\t\tg[n][m][0]=ad(g[n][m][0]+1LL*f[i][j][2]*dec((1<<(n-i))-2)%mod*C[n][i]%mod*C[m][j]%mod);\n\t\t\tfor(int k=1;k<m-j;k++)\n\t\t\t{\n\t\t\t\tf[i][j+k][1]=ad(f[i][j+k][1]+1LL*ad(g[i][j][1]+ad(g[i][j][2]*2))*C[k+j][j]%mod);\n\t\t\t\tf[i][j+k][2]=ad(f[i][j+k][2]+1LL*g[i][j][2]*dec((1<<k)-2)%mod*C[k+j][j]%mod);\n\t\t\t}\n\t\t\tf[n][m][0]=ad(f[n][m][0]+1LL*g[i][j][2]*dec((1<<(m-j))-2)%mod*C[m][j]%mod*C[n][i]%mod);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tfor(int j=0;j<(1<<m);j++)\n\t\t{\n\t\t\tif(pd(i,j)==false)continue;\n\t\t\tint x=n,y=m;\n\t\t\tfor(int k=0;k<n;k++)if(i>>k&1)x--;\n\t\t\tfor(int k=0;k<m;k++)if(j>>k&1)y--;\n\t\t\tfor(int k=0;k<3;k++)ans=ad(ans+ad(f[x][y][k]+g[x][y][k]));\n\t\t}\n\t}pr2(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int H, W; cin >> H >> W;\n    vector<string> A(H); cin >> A;\n    Combination C(H + W);\n    \n    mmat dp1(H + 1, mvec(W + 1)), dp2(H + 1, mvec(W + 1));\n    REP(h, H + 1) REP(w, W + 1){\n        dp1[h][w] = 1;\n        FOR(i, 0, h) FOR(j, 0, w) if(i + j > 0) dp1[h][w] += dp2[h - i][w - j] * C.nCr(h, i) * C.nCr(w, j);\n\n        dp2[h][w] = 1;\n        FOR(i, 1, h) FOR(j, 1, w) dp2[h][w] += dp2[h - i][w - j] * C.nCr(h, i) * C.nCr(w, j);\n    }\n    REP(h, H + 1) REP(w, W + 1) dp1[h][w] += dp2[h][w];\n\n    mmat dq1(H + 1, mvec(W + 1)), dq2(H + 1, mvec(W + 1));\n    REP(h, H + 1) REP(w, W + 1){\n        dq1[h][w] = 1;\n        FOR(i, 1, h) dq1[h][w] += dq2[h - i][w] * C.nCr(h, i);\n\n        dq2[h][w] = 1;\n        FOR(j, 1, w) dq2[h][w] += dq1[h][w - j] * C.nCr(w, j);\n    }\n    REP(h, H + 1) REP(w, W + 1) dq1[h][w] += dq2[h][w];\n    REP(h, H) dq1[h][0] = 1;\n    REP(w, W) dq1[0][w] = 1;\n\n    mmat dr(H, mvec(W, 0));\n    REP(h, H) REP(w, W){\n        FOR(i, 0, h + 1) FOR(j, 0, w + 1) dr[h][w] += dq1[i][w - j] * dq1[h - i][j] * C.nCr(h, i) * C.nCr(w, j);  \n    }\n\n    vector<v_bool> same_x(bit(H), v_bool(W, true)), same_y(bit(W), v_bool(H, true));\n    REP(x, bit(H)) REP(j, W){\n        REP(i1, H) REP(i2, i1) if((x >> i1) & (x >> i2) & 1){\n            if(A[i1][j] != A[i2][j]) same_x[x][j] = false;\n        }\n    }\n    REP(y, bit(W)) REP(i, H){\n        REP(j1, W) REP(j2, j1) if((y >> j1) & (y >> j2) & 1){\n            if(A[i][j1] != A[i][j2]) same_y[y][i] = false;\n        }\n    }\n\n    mint ans = dp1[H][W];\n    REP(x, bit(H)) REP(y, bit(W)){\n        bool ok = true;\n        REP(i, H) if(((x >> i) & 1) && same_y[y][i]) ok = false;\n        REP(j, W) if(((y >> j) & 1) && same_x[x][j]) ok = false;\n        if(ok){\n            int h = H - __builtin_popcountll(x), w = W - __builtin_popcountll(y);\n            if(h < H && w < W) ans += dr[h][w];\n        }\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int Q = 998244353;\nint fact[100];\nint revf[100];\n\nint comb(int n, int r)\n{\n    if(n < r) return 0;\n    return (long long)fact[n] * revf[n - r] % Q * revf[r] % Q;\n}\n\nbool nextComb(bool *arr, int n, int r)\n{\n    int cnt = 0;\n    for(int i = n - 1; i >= 0; --i)\n    {\n        if(arr[i])\n        {\n            ++cnt;\n            if(i < n - 1 && !arr[i + 1])\n            {\n                arr[i] = false;\n                for(int j = i + 1; j <= i + cnt; ++j) arr[j] = true;\n                for(int j = i + cnt + 1; j < n; ++j) arr[j] = false;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m; cin >> n >> m;\n    fact[0] = 1; for(int i = 1; i < 100; ++i) fact[i] = (long long)fact[i - 1] * i % Q;\n    revf[0] = revf[1] = 1; for(int i = 2; i < 100; ++i) revf[i] = Q - (long long)revf[Q % i] * (Q / i) % Q;\n    for(int i = 2; i < 100; ++i) revf[i] = (long long)revf[i] * revf[i - 1] % Q;\n\n    int dp[n + 1][m + 1]{};\n    for(int i = 0; i <= n; ++i)\n    {\n        for(int j = 0; j <= m; ++j)\n        {\n            int ans = 0;\n            bool arr[i + j];\n            for(int k = 0; k < i; ++k) arr[k] = true;\n            for(int k = i; k < i + j; ++k) arr[k] = false;\n            do\n            {\n                int cnt = 0, tmp = 1;\n                for(int k = 0; k < i + j; ++k)\n                {\n                    ++cnt;\n                    if(k == i + j - 1 || arr[k] != arr[k + 1])\n                        tmp = (long long)tmp * revf[cnt] % Q, cnt = 0;\n                }\n                ans = (ans + tmp) % Q;\n            }while(nextComb(arr, i + j, i));\n            dp[i][j] = (long long)ans * fact[i] % Q * fact[j] % Q;\n        }\n    }\n\n    int ans = dp[n][m];\n    string s[n]; for(int i = 0; i < n; ++i) cin >> s[i];\n    int N = 1 << (n + m);\n    for(int i = 1; i < N; ++i)\n    {\n        bool __flag = true;\n\n        for(int j = 0; j < n; ++j)\n        {\n            if(!(i >> j & 1)) continue;\n            char prev = 0;\n            bool flag = false;\n            for(int k = 0; k < m; ++k)\n            {\n                if(!(i >> (k + n) & 1)) continue;\n                if(!prev) prev = s[j][k];\n                else if(prev != s[j][k]) {flag = true; break;}\n            }\n            if(!flag) {__flag = false; break;}\n        }\n\n        for(int k = 0; k < m; ++k)\n        {\n            if(!(i >> (k + n) & 1)) continue;\n            char prev = 0;\n            bool flag = false;\n            for(int j = 0; j < n; ++j)\n            {\n                if(!(i >> j & 1)) continue;\n                if(!prev) prev = s[j][k];\n                else if(prev != s[j][k]) {flag = true; break;}\n            }\n            if(!flag) {__flag = false; break;}\n        }\n\n        if(__flag)\n        {\n            int _m = __builtin_popcount(i >> n);\n            int _n = __builtin_popcount(i) - _m;\n            _n = n - _n; _m = m - _m;\n\n            for(int j = 0; j <= _n; ++j)\n            {\n                for(int k = 0; k <= _m; ++k)\n                {\n                    ans += (long long)dp[j][_m - k] * dp[k][_n - j] % Q\n                            * comb(_n, j) % Q * comb(_m, k) % Q;\n                    ans %= Q;\n                }\n            }\n        }\n    }\n\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 10, S = (1 << N) + 10, mod = 998244353;\n\nvoid add(int& a, int b) {\n\ta += b;\n\tif (a >= mod) a -= mod;\n}\n\nint mul(ll a, ll b) {\n\treturn (a * b) % mod;\n}\n\nstring a[N];\nint h, w, cnt[S], p2[N];\nint dp[S][S][2][2];\nbool seen[S][S][2][2], dp2[S][S], seen2[S][S];\n\nint solve(int rows, int cols, int turn, int must);\nbool is_colorful(int rows, int cols);\n\nint main() {\n\tfast_cin();\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i <= max(h, w); ++i) {\n\t\tp2[i] = (1 << i);\n\t}\n\tfor (int mask = 0; mask < (1 << max(w, h)); ++mask) {\n\t\tcnt[mask] = __builtin_popcount(mask);\n\t}\n\tint ans = 0;\n\tfor (int mask = 0; mask < (1 << w); ++mask) {\n\t\tadd(ans, mul(p2[cnt[mask]], solve((1 << h) - 1, (1 << w) - 1 - mask, 0, 0)));\n\t}\n\tcout << ans << endl;\n}\n\nint solve(int rows, int cols, int turn, int must) {\n\tif (seen[rows][cols][turn][must]) {\n\t\treturn dp[rows][cols][turn][must];\n\t} else {\n\t\tseen[rows][cols][turn][must] = true;\n\t\tint& ans = dp[rows][cols][turn][must];\n\t\tif (!rows or !cols) {\n\t\t\tans = (must == 0);\n\t\t} else {\n\t\t\tadd(ans, is_colorful(rows, cols));\n\t\t\tint submask = (turn ? cols : rows);\n\t\t\twhile (submask) {\n\t\t\t\tint nrows = rows - (turn ? 0 : submask);\n\t\t\t\tint ncols = cols - (turn ? submask : 0);\n\t\t\t\tadd(ans, solve(nrows, ncols, turn ^ 1, 1));\n\t\t\t\tif (must == 0) {\n\t\t\t\t\tadd(ans, mul(p2[cnt[submask]] - 2, solve(nrows, ncols, turn ^ 1, 0)));\n\t\t\t\t\tadd(ans, solve(nrows, ncols, turn ^ 1, 1));\n\t\t\t\t}\n\t\t\t\tsubmask = (submask - 1) & (turn ? cols : rows);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nbool is_colorful(int rows, int cols) {\n\tif (seen2[rows][cols]) {\n\t\treturn dp2[rows][cols];\n\t} else {\n\t\tseen2[rows][cols] = true;\n\t\tbool& ans = dp2[rows][cols];\n\t\tvector<int> cr(h, 0), cc(w, 0);\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tif (!((rows >> i) & 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (!((cols >> j) & 1)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcr[i] |= (1 << (a[i][j] == '#'));\n\t\t\t\tcc[j] |= (1 << (a[i][j] == '#'));\n\t\t\t}\n\t\t}\n\t\tans = true;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tans &= !((rows >> i) & 1) or (cr[i] == 3);\n\t\t}\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tans &= !((cols >> j) & 1) or (cc[j] == 3);\n\t\t}\n\t\treturn ans;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 15, mod = 998244353;\nint n,m;\nchar s[N][N];\n\nint ans,pw[N],C[N][N],invC[N][N],f[N][N][3],g[N][N][3];\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline void init(){\n\tC[0][0]=pw[0]=1;\n\tFor(i,1,10){\n\t\tC[i][0]=1,pw[i]=pw[i-1]*2;\n\t\tFor(j,1,i) C[i][j]=Mod(C[i-1][j-1]+C[i-1][j]),invC[i][j]=power(C[i][j],mod-2);\n\t}\n\tFor(i,0,m) g[n][i][1]=1ll*C[m][i]*pw[m-i]%mod;\n\tDow(i,n,0)\n\t\tDow(j,m,0){\n\t\t\tFor(k,1,n-i){\n\t\t\t\tf[i][j][1]=(f[i][j][1]+1ll*C[i+k][k]*g[i+k][j][1]%mod*(pw[k]-2))%mod;\n\t\t\t\tf[i][j][2]=(f[i][j][2]+(1ll*C[i+k][k]*(2*g[i+k][j][1])+1ll*C[i+k][k]*g[i+k][j][2]))%mod;\n\t\t\t}\n\t\t\tf[i][j][0]=Mod(f[i][j][1]+f[i][j][2]);\n\t\t\tFor(k,1,m-j){\n\t\t\t\tg[i][j][1]=(g[i][j][1]+1ll*C[j+k][k]*f[i][j+k][1]%mod*(pw[k]-2))%mod;\n\t\t\t\tg[i][j][2]=(g[i][j][2]+(1ll*C[j+k][k]*(2*f[i][j+k][1])+1ll*C[j+k][k]*f[i][j+k][2]))%mod;\n\t\t\t}\n\t\t\tg[i][j][0]=Mod(g[i][j][1]+g[i][j][2]);\n\t\t}\n\tans=0;\n\tFor(i,1,m) ans=Mod(ans+f[0][i][1]);\n\tFor(i,1,n) ans=Mod(ans+g[i][0][1]);\n}\n\nint main(){\n\tn=read(),m=read();\n\tFor(i,1,n) scanf(\"%s\",s[i]+1);\n\tinit();\n\tFor(i,1,(1<<n)-1)\n\t\tFor(j,1,(1<<m)-1){\n\t\t\tbool flag=1;\n\t\t\tint p=0,q=0;\n\t\t\tFor(k,1,n) if (i&(1<<k-1)){\n\t\t\t\tchar x=' ';\n\t\t\t\tbool Flag=0;\n\t\t\t\t++p;\n\t\t\t\tFor(l,1,m) if (j&(1<<l-1)){\n\t\t\t\t\tif (x==' ') x=s[k][l];\n\t\t\t\t\tif (s[k][l]!=x){Flag=1;break;}\n\t\t\t\t}\n\t\t\t\tif (!Flag){flag=0;break;}\n\t\t\t}\n\t\t\tif (!flag) continue;\n\t\t\tFor(k,1,m) if (j&(1<<k-1)){\n\t\t\t\tchar x=' ';\n\t\t\t\tbool Flag=0;\n\t\t\t\t++q;\n\t\t\t\tFor(l,1,n) if (i&(1<<l-1)){\n\t\t\t\t\tif (x==' ') x=s[l][k];\n\t\t\t\t\tif (s[l][k]!=x){Flag=1;break;}\n\t\t\t\t}\n\t\t\t\tif (!Flag){flag=0;break;}\n\t\t\t}\n\t\t\tif (!flag) continue;\n\t\t\tans=(ans+1ll*Mod(f[p][q][0]+g[p][q][0])*invC[n][p]%mod*invC[m][q])%mod;\n\t\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar grid[15][15];\n\nint A[15][15];\nint B[15][15];\n\nlong long MOD = 998244353;\n\nint H, W;\n\nlong long dfs(int i){\n    if(i == H){return 1;}\n\n    long long ans = 0;\n    for(int j = 0; j < (1<<W); j ++){\n        for(int k = 0; k < W; k ++){\n            if(j&(1<<k)){\n                B[i][k] = 1;\n            }else{\n                B[i][k] = 0;\n            }\n        }\n\n        bool boleh = true;\n\n        for(int x1 = 0; x1 < i; x1 ++){\n            for(int x2 = i; x2 <= i; x2 ++){\n                for(int y1 = 0; y1 < W; y1 ++){\n                    for(int y2 = y1+1; y2 < W; y2 ++){\n                        if( (B[x1][y1] == 1 && B[x2][y1] == 0 && B[x1][y2] == 0 && B[x2][y2] == 1)\n                           || (B[x1][y1] == 0 && B[x2][y1] == 1 && B[x1][y2] == 1 && B[x2][y2] == 0) ){\n                            if(B[x1][y1] == A[x1][y1] && B[x1][y2] == A[x1][y2] &&\n                               B[x2][y1] == A[x2][y1] && B[x2][y2] == A[x2][y2]){\n                            }else{\n                                boleh = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if(boleh){\n            ans += dfs(i+1);\n        }\n    }\n    return ans%MOD;\n}\n\nint main(){\n    scanf(\"%d%d\", &H, &W);\n\n    for(int i = 0; i < H; i ++){\n        scanf(\" %s\", grid[i]);\n    }\n\n    for(int i = 0; i < H; i ++){\n        for(int j = 0; j < W; j ++){\n            A[i][j] = grid[i][j] == '#';\n        }\n    }\n\n    //assert(H*W < 31);\n\n    /*long long ans = 0;\n    for(int i = 0; i < 1<<(H*W); i ++){\n\n        int cnt = 0;\n        for(int j = 0; j < H; j ++){\n            for(int k = 0; k < W; k ++){\n                B[j][k] = (i&(1<<cnt)) >> cnt;\n                cnt ++;\n            }\n        }\n\n        bool boleh = true;\n\n        for(int x1 = 0; x1 < H; x1 ++){\n            for(int x2 = x1+1; x2 < H; x2 ++){\n                for(int y1 = 0; y1 < W; y1 ++){\n                    for(int y2 = y1+1; y2 < W; y2 ++){\n                        if( (B[x1][y1] == 1 && B[x2][y1] == 0 && B[x1][y2] == 0 && B[x2][y2] == 1)\n                           || (B[x1][y1] == 0 && B[x2][y1] == 1 && B[x1][y2] == 1 && B[x2][y2] == 0) ){\n                            if(B[x1][y1] == A[x1][y1] && B[x1][y2] == A[x1][y2] &&\n                               B[x2][y1] == A[x2][y1] && B[x2][y2] == A[x2][y2]){\n                            }else{\n                                boleh = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if(boleh){\n            ans ++;\n        }\n    }\n\n    ans %= MOD;\n    printf(\"%lld\\n\", ans);*/\n    printf(\"%lld\", dfs(0));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    long long int n,k;\n    cin>>n;\n    k=n;\n    long long int a[n][2];\n    for(int i=0;i<n;i++){\n        for(int j=0;j<2;j++)\n            cin>>a[i][j];\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(a[j][0]<(a[i][0]+a[i][1])&&a[j][0]>(a[i][0]-a[i][1]))\n                k--;\n        }\n    }\n    cout<<k<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nint H, W;\nvector<string> A;\n\nint main() {\n    bc.init(110);\n\n    // 長方形\n    vector<vector<mint>> all(15, vector<mint>(15, 0));\n    auto bein = all;\n    auto notin = all;\n    for (int i = 0; i < 15; ++i) all[0][i] = all[i][0] = modpow(mint(2), i);\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            notin[a][b] = 1;\n            for (int i = 1; i < a; ++i) {\n                for (int j = 1; j < b; ++j) {\n                    notin[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n        }\n    }\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            bein[a][b] = 1;\n            for (int i = 0; i < a; ++i) {\n                for (int j = 0; j < b; ++j) {\n                    if (i + j == 0) continue;\n                    bein[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n            all[a][b] = notin[a][b] + bein[a][b];\n        }\n    }\n\n    // はみ出しあり\n    vector<vector<mint>> subsub(15, vector<mint>(15, 0));\n    auto sub = subsub, part = subsub;\n    for (int i = 0; i < 15; ++i) {\n        subsub[1][i] = 1;\n        subsub[i][1] = modpow(mint(2), i) - 1;\n    }\n    for (int s = 2; s < 30; ++s) {\n        for (int a = 1; a < 15; ++a) {\n            int b = s - a;\n            if (b < 1 || b >= 15) continue;\n            subsub[a][b] = 1;\n            for (int i = 1; i < a; ++i) {\n                subsub[a][b] += bc.com(a, i) * subsub[b][a-i];\n            }\n        }\n    }\n    for (int a = 0; a < 15; ++a) {\n        for (int b = 0; b < 15; ++b) {\n            if (a == 0) sub[a][b] = 1;\n            else if (b == 0) sub[a][b] = 1;\n            else sub[a][b] = subsub[a][b] + subsub[b][a];\n        }\n    }\n    for (int i = 0; i < 15; ++i) part[0][i] = part[i][0] = modpow(mint(2), i);\n    for (int a = 1; a < 14; ++a) {\n        for (int b = 1; b < 14; ++b) {\n            for (int i = 0; i <= a; ++i) {\n                for (int j = 0; j <= b; ++j) {\n                    part[a][b] += bc.com(a, i) * bc.com(b, j) *\n                        sub[i][j] * sub[a-i][b-j];\n                }\n            }\n        }\n    }\n\n    cin >> H >> W;\n    A.resize(H);\n    for (int h = 0; h < H; ++h) cin >> A[h];\n\n    mint res = all[H][W];\n    for (int bit = 0; bit < (1<<H)-1; ++bit) {\n        vector<int> tate;\n        for (int i = 0; i < H; ++i) if (!(bit & (1<<i))) tate.push_back(i);\n        for (int bit2 = 0; bit2 < (1<<W)-1; ++bit2) {\n            vector<int> yoko;\n            for (int i = 0; i < W; ++i) if (!(bit2 & (1<<i))) yoko.push_back(i);\n\n            bool ok = true;\n            for (auto i : tate) {\n                set<char> se;\n                for (auto j : yoko) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n            for (auto j : yoko) {\n                set<char> se;\n                for (auto i : tate) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n\n            if (ok) {\n                int c = __builtin_popcount(bit);\n                int r = __builtin_popcount(bit2);\n                mint add = part[c][r];\n                res += add;\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n#define DD 1\n#else\n#define DD 0\n#endif\n#define Debug if(DD) printf(\"line %d\\n\",__LINE__)\n#define deb(x) if(DD) cerr<<#x<<'='<<x<<endl\n#define debug if(DD) printf\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid gg(){write2(-1);exit(0);}\n\t\n\tconst double eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=998244353;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int N=1e2+10;\n\n\tll C[N][N];\n\tll f[N][N][2],g[N][N][2];//f=上次删的是行，g=列\n\tchar mp[N][N];\n\tvoid main()\n\t{\n\t\tC[0][0]=1;fo(i,1,N-1){ C[i][0]=1;fo(j,1,i) C[i][j]=mm(C[i-1][j-1]+C[i-1][j]); }\n\t\tint n=qread(),m=qread();fo(i,0,n-1) scanf(\"%s\",mp[i]);\n\t\tfo(mm,0,m) g[n][mm][1]=C[m][mm]*bin(m-mm)%MOD;\n\t\tfd(nn,n,0) fd(mm,m,0)\n\t\t{\n\t\t\tfo(ad,1,n-nn)\n\t\t\t\tadd(f[nn][mm][0],C[ad+nn][nn]*(g[nn+ad][mm][0]+g[nn+ad][mm][1]*2)%MOD ),\n\t\t\t\tadd(f[nn][mm][1],C[ad+nn][nn]*g[nn+ad][mm][1]%MOD*(bin(ad)-2)%MOD );\n\t\t\tfo(ad,1,m-mm)\n\t\t\t\tadd(g[nn][mm][0],C[ad+mm][mm]*(f[nn][mm+ad][0]+f[nn][mm+ad][1]*2)%MOD ),\n\t\t\t\tadd(g[nn][mm][1],C[ad+mm][mm]*f[nn][mm+ad][1]%MOD*(bin(ad)-2)%MOD );\n\t\t}\n\t\tll ans=0;fo(mm,1,m) add(ans,f[0][mm][1]);fo(nn,1,n) add(ans,g[nn][0][1]);\n\t\tfo(S1,1,bin(n)-1) fo(S2,1,bin(m)-1)\n\t\t{\n\t\t\tbool ok=1;\n\t\t\tfo(i,0,n-1) if(S1&bin(i)){\n\t\t\t\tbool same=1;int lst=-1;\n\t\t\t\tfo(j,0,m-1) if(S2&bin(j)) same&=(lst<0 or mp[i][j]==mp[i][lst]),lst=j;\n\t\t\t\tok&=(same==0);\n\t\t\t}fo(j,0,m-1) if(S2&bin(j)){\n\t\t\t\tbool same=1;int lst=-1;\n\t\t\t\tfo(i,0,n-1) if(S1&bin(i)) same&=(lst<0 or mp[i][j]==mp[lst][j]),lst=i;\n\t\t\t\tok&=(same==0);\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tfo(pp,0,1) add(ans, mm(f[PC(S1)][PC(S2)][pp]+g[PC(S1)][PC(S2)][pp])*invm(C[n][PC(S1)]*C[m][PC(S2)]%MOD)%MOD );\n\t\t}write(ans);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n\tsrand(time(0));\n\tmine::main();\n}"
  },
  {
    "language": "C++",
    "code": "//https://betrue12.hateblo.jp/entry/2020/01/19/170701\n//https://drken1215.hatenablog.com/entry/2020/02/02/134400\n\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n\nset<vector<string>> allfi, allnotin, allbein;\nvoid rec(vector<string> fi, set<int> &yoko, set<int> &tate, bool bein, int H, int W) {\n    if (yoko.size() == H && tate.size() == W) {\n        allfi.insert(fi);\n        if (bein) allbein.insert(fi);\n        else allnotin.insert(fi);\n    }\n    auto ifi = fi;\n    for (int h = 0; h < H; ++h) {\n        if (yoko.count(h)) continue;\n        yoko.insert(h);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '.';\n        rec(fi, yoko, tate, bein, H, W);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '#';\n        rec(fi, yoko, tate, (bein || (tate.empty() && true)), H, W);\n        fi = ifi;\n        yoko.erase(h);\n    }\n    for (int w = 0; w < W; ++w) {\n        if (tate.count(w)) continue;\n        tate.insert(w);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '.';\n        rec(fi, yoko, tate, bein, H, W);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '#';\n        rec(fi, yoko, tate, (bein || (yoko.empty() && true)), H, W);\n        fi = ifi;\n        tate.erase(w);\n    }\n}\n\nset<vector<string>> allsub;\nvoid rec2(vector<string> fi, set<int> &yoko, set<int> &tate, int H, int W) {\n    if (yoko.size() == H && tate.size() == W) {\n        allsub.insert(fi);\n    }\n    auto ifi = fi;\n    for (int h = 0; h < H; ++h) {\n        if (yoko.count(h)) continue;\n        yoko.insert(h);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '.';\n        rec2(fi, yoko, tate, H, W);\n        fi = ifi;\n        yoko.erase(h);\n    }\n    for (int w = 0; w < W; ++w) {\n        if (tate.count(w)) continue;\n        tate.insert(w);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '#';\n        rec2(fi, yoko, tate, H, W);\n        fi = ifi;\n        tate.erase(w);\n    }\n}\n\nlong long calc(int H, int W) {\n    allfi.clear();\n    allnotin.clear(), allbein.clear();\n    set<int> yoko, tate;\n    vector<string> fi(H+1, string(W+1, '.'));\n    auto fi2 = fi;\n    rec(fi, yoko, tate, false, H, W);\n    return allfi.size();\n}\n\nlong long calc2(int H, int W) {\n    set<int> yoko, tate;\n    vector<string> fi(H+1, string(W+1, '.'));\n    allsub.clear();\n    rec2(fi, yoko, tate, H, W);\n    return allsub.size();\n}\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nint H, W;\nvector<string> A;\n\nint main() {\n    bc.init(110);\n\n    // 長方形\n    vector<vector<mint>> all(15, vector<mint>(15, 0));\n    auto bein = all;\n    auto notin = all;\n    for (int i = 0; i < 15; ++i) all[0][i] = all[i][0] = modpow(mint(2), i);\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            notin[a][b] = 1;\n            for (int i = 1; i < a; ++i) {\n                for (int j = 1; j < b; ++j) {\n                    notin[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n        }\n    }\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            bein[a][b] = 1;\n            for (int i = 0; i < a; ++i) {\n                for (int j = 0; j < b; ++j) {\n                    if (i + j == 0) continue;\n                    bein[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n            all[a][b] = notin[a][b] + bein[a][b];\n        }\n    }\n\n    // はみ出しあり\n    vector<vector<mint>> subsub(15, vector<mint>(15, 0));\n    auto sub = subsub, part = subsub;\n    // for (int i = 0; i < 15; ++i) {\n    //     subsub[1][i] = 1;\n    //     subsub[i][1] = modpow(mint(2), i) - 1;\n    // }\n    // for (int s = 2; s < 30; ++s) {\n    //     for (int a = 1; a < 15; ++a) {\n    //         int b = s - a;\n    //         if (b < 1 || b >= 15) continue;\n    //         subsub[a][b] = 1;\n    //         for (int i = 1; i < a; ++i) {\n    //             subsub[a][b] += bc.com(a, i) * subsub[b][a-i];\n    //         }\n    //     }\n    // }\n    // for (int a = 0; a < 15; ++a) {\n    //     for (int b = 0; b < 15; ++b) {\n    //         if (a == 0) sub[a][b] = 1;\n    //         else if (b == 0) sub[a][b] = 1;\n    //         else sub[a][b] = subsub[a][b] + subsub[b][a];\n    //     }\n    // }\n\n    // for (int i = 0; i < 15; ++i) part[0][i] = part[i][0] = modpow(mint(2), i);\n    for (int a = 0; a < 14; ++a) {\n        for (int b = 0; b < 14; ++b) {\n            for (int i = 0; i <= a; ++i) {\n                for (int j = 0; j <= b; ++j) {\n                    part[a][b] += bc.com(a, i) * bc.com(b, j) *\n                        all[i][j] * all[a-i][b-j];\n                }\n            }\n        }\n    }\n\n    /*\n    for (int a = 0; a <= 5; ++a) {\n        for (int b = 0; b <= 5; ++b) {\n            calc(a, b);\n            cout << a << \",\" << b << \": \" << part[a][b] << \"( \" << sub[a][b] << \" ), \" << allfi.size() << \", \" << calc2(a, b) << endl;\n        }\n    }\n    \n    \n    calc(1, 2);\n    COUT(allfi.size());\n    for (auto fi : allfi) {\n        for (auto s : fi) cout << s << endl;\n        cout << endl;\n    }\n    */\n    \n\n    cin >> H >> W;\n    A.resize(H);\n    for (int h = 0; h < H; ++h) cin >> A[h];\n\n    mint res = all[H][W];\n    for (int bit = 0; bit < (1<<H)-1; ++bit) {\n        vector<int> tate;\n        for (int i = 0; i < H; ++i) if (!(bit & (1<<i))) tate.push_back(i);\n        for (int bit2 = 0; bit2 < (1<<W)-1; ++bit2) {\n            vector<int> yoko;\n            for (int i = 0; i < W; ++i) if (!(bit2 & (1<<i))) yoko.push_back(i);\n\n            bool ok = true;\n            for (auto i : tate) {\n                set<char> se;\n                for (auto j : yoko) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n            for (auto j : yoko) {\n                set<char> se;\n                for (auto i : tate) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n\n            if (ok) {\n                int c = __builtin_popcount(bit);\n                int r = __builtin_popcount(bit2);\n                mint add = part[c][r];\n                res += add;\n\n                //cout << bit << \", \" << bit2 << \": \" << tate << \", \" << yoko << \";; \" << c << \", \" << r << \": \" << add << endl;\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int m=998244353;\nint main() {\n  ll h,w; cin>>h>>w; string s[h];\n  for(int i=0;i<h;i++) {\n    cin>>s[i];\n  }\n  ll dp[1<<(h+w)]; fill(dp[0], dp[1<<(h+w)], 0); dp[0]=1;\n  for(int i=0;i<h+w;i++) {\n    for(int j=0;j<(1<<(h+w));j++) {\n      for(int p=0;p<h;p++) {\n      for(int k=0;k<h;k++) {\n        for(int x=0;x<w;j++) {\n          dp[j|(1<<p)] = dp[j] * 2;\n        }\n      }}\n      for(int p=0;p<w;p++) {\n      for(int k=0;k<h;k++) {\n        for(int x=0;x<w;j++) {\n          dp[j|(1<<h+p)] = dp[j] * 2;\n        }\n      }}\n    }\n  }\n  ll sm=0;\n  for(int i=0;i<(1<<(h+w));i++) {\n    sm = (sm+dp[i]) % m;\n  }\n  cout<<sm<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[12][12];\nlong long P[12][12];\nlong long dp[2][12][12];\nlong long f(int a,int b){\n\tif(a+b==0)return 1;\n\tfor(int i=0;i<2;i++)for(int j=0;j<12;j++)for(int k=0;k<12;k++)dp[i][j][k]=0;\n\tdp[0][0][0]=dp[1][0][0]=1;\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<=b;j++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tif(!dp[k][i][j])continue;\n\t\t\t\tif(k==0){\n\t\t\t\t\tfor(int l=1;i+l<=a;l++){\n\t\t\t\t\t\tdp[!k][i+l][j]=(dp[!k][i+l][j]+dp[k][i][j]*Comb(a-i,l))%mod;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int l=1;j+l<=b;l++){\n\t\t\t\t\t\tdp[!k][i][j+l]=(dp[!k][i][j+l]+dp[k][i][j]*Comb(b-j,l))%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (dp[0][a][b]+dp[1][a][b])%mod;\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",in[i]);\n\tinit_C(100);\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=0;j<=b;j++){\n\t\t\tP[i][j]=f(i,j);\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<(1<<a);i++){\n\t\tfor(int j=0;j<(1<<b);j++){\n\t\t\tbool ok=true;\n\t\t\tint N=a;\n\t\t\tint M=b;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(!(i&(1<<k)))continue;\n\t\t\t\tN--;\n\t\t\t\tint A=0;\n\t\t\t\tint B=0;\n\t\t\t\tfor(int l=0;l<b;l++){\n\t\t\t\t\tif(!(j&(1<<l)))continue;\n\t\t\t\t\tif(in[k][l]=='#')A++;\n\t\t\t\t\telse B++;\n\t\t\t\t}\n\t\t\t\tif((A==0||B==0)){\n\t\t\t\t\tok=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k=0;k<b;k++){\n\t\t\t\tif(!(j&(1<<k)))continue;\n\t\t\t\tM--;\n\t\t\t\tint A=0;\n\t\t\t\tint B=0;\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\tif(!(i&(1<<l)))continue;\n\t\t\t\t\tif(in[l][k]=='#')A++;\n\t\t\t\t\telse B++;\n\t\t\t\t}\n\t\t\t\tif((A==0||B==0)){\n\t\t\t\t\tok=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(N==a&&M==b){\n\t\t\t\tret=(ret+P[a][b])%mod;\n\t\t\t}else{\n\t\t\t\tfor(int k=0;k<=N;k++){\n\t\t\t\t\tfor(int l=0;l<=M;l++){\n\t\t\t\t\t\tlong long ks=Comb(N,k)*Comb(M,l)%mod;\n\t\t\t\t\t\tks=ks*P[k][l]%mod;\n\t\t\t\t\t\tks=ks*P[N-k][M-l]%mod;\n\t\t\t\t\t\tret=(ret+ks)%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// printf(\"%d %d: %lld\\n\",i,j,ret);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=22,mod=998244353;\nll fc[N],ifc[N],p[N],col[N][N][3],row[N][N][3];\nll inv(ll x){return x<=1?x:(mod-mod/x)*inv(mod%x)%mod;}\nll C(int n,int m)\n{\n    return fc[n]*ifc[n-m]%mod*ifc[m]%mod;\n}\nll iC(int n,int m)\n{\n    return inv(C(n,m));\n}\nint n,m,r[N],c[N];\nchar s[N][N];\nvoid init()\n{\n    fc[0]=fc[1]=ifc[0]=ifc[1]=p[0]=1;\n    for(int i=2;i<N;i++) fc[i]=fc[i-1]*i%mod,ifc[i]=(mod-mod/i)*ifc[mod%i]%mod;\n    for(int i=2;i<N;i++) ifc[i]=ifc[i]*ifc[i-1]%mod;\n    for(int i=1;i<N;i++) p[i]=p[i-1]*2%mod;\n}\nvoid Dp()\n{\n    for(int j=1;j<=m;j++)\n        col[n][j][2]=C(m,j)*p[m-j]%mod;\n    ll ans=p[m];\n    for(int i=n;i>=1;i--)\n        for(int j=m;j>=1;j--)\n    {\n        col[i][j][0]=(col[i][j][1]+col[i][j][2])%mod;\n        for(int k=1;k<i;k++)\n        {\n            int d=i-k;\n            (row[k][j][1]+=C(i,d)*(col[i][j][2]*2+col[i][j][1])%mod)%=mod;\n            (row[k][j][2]+=C(i,d)*(p[d]-2)%mod*col[i][j][2]%mod)%=mod;\n        }\n        ans=(ans+col[i][j][2]*(p[i]-2))%mod;\n        row[i][j][0]=(row[i][j][1]+row[i][j][2])%mod;\n        for(int k=1;k<j;k++)\n        {\n            int d=j-k;\n            (col[i][k][1]+=C(j,d)*(row[i][j][2]*2+row[i][j][1])%mod)%=mod;\n            (col[i][k][2]+=C(j,d)*(p[d]-2)%mod*row[i][j][2]%mod)%=mod;\n        }\n        ans=(ans+row[i][j][2]*(p[j]-2))%mod;\n    }\n    int upn=1<<n,upm=1<<m;\n    for(int i=1;i<upn;i++)\n        for(int j=1;j<upm;j++)\n    {\n        bool flag=true;\n        for(int k=0;k<n;k++)\n            if(i>>k&1)\n        {\n            int w=r[k+1]&j;\n            if(w==j||w==0) flag=false;\n        }\n        for(int k=0;k<m;k++)\n            if(j>>k&1)\n        {\n            int w=c[k+1]&i;\n            if(w==i||w==0) flag=false;\n        }\n        if(!flag) continue;\n        int x=__builtin_popcount(i),y=__builtin_popcount(j);\n        ans=(ans+(row[x][y][0]+col[x][y][0])*iC(n,x)%mod*iC(m,y))%mod;\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main()\n{\n    init();\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++) scanf(\"%s\",s[i]+1);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n        if(s[i][j]=='.') r[i]|=1<<j>>1,c[j]|=1<<i>>1;\n    Dp();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAXN 10\n\nint main(void)\n{\n    int i, j, n, h, w, counth=0, countw=0, min;\n    char a[MAXN][MAXN];\n\n    scanf(\"%d %d\", &h, &w);\n    for(i=0; i<h; i++)\n        scanf(\"%s\", &a[i]);\n\n    for(i=0; i<h; i++)\n        for(j=1; j<w; j++)\n            if( a[i][j]!=a[i][0] ){\n                counth++;\n                break;\n            }\n    for(j=0; j<w; j++)\n        for(i=1; i<h; i++)\n            if( a[i][j]!=a[0][j] ){\n                countw++;\n                break;\n            }\n    min = (counth<countw? counth: countw);\n    printf(\"%d\", min%998244353);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// 解説 AC（75% 自力）\n\nlong long mod = 998244353;\nlong long H, W;\nlong long bitcnt[1 << 10];\nlong long fact[19];\nlong long nr[19][19];\nlong long dp0[19][19]; // 何もない状態\nlong long dp1[19][19]; // 横方向のみある\nlong long dp2[19][19]; // 縦方向のみある\nlong long dp3[19][19]; // 両方向ある\nbool used[1 << 10][1 << 10];\nbool vis[1 << 10][1 << 10];\nchar c[19][19];\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= 15; i++) fact[i] = 1LL * i * fact[i - 1];\n\tfor (int i = 0; i <= 15; i++) {\n\t\tfor (int j = 0; j <= 15; j++) {\n\t\t\tif (i == 0 || j == 0) nr[i][j] = 1;\n\t\t\telse nr[i][j] = (nr[i - 1][j] + nr[i][j - 1]) % mod;\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << 10); i++) {\n\t\tfor (int j = 0; j < 10; j++) bitcnt[i] += (i / (1 << j)) % 2;\n\t}\n}\n\nlong long ncr(int n, int r) {\n\tif (r < 0 || n < r) return 0;\n\treturn nr[n - r][r];\n}\n\nvector<int> VecToVec2(int h, int w, vector<int> vec) {\n\tvector<int> vec2(h, 0);\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (vec[i] >= 1) vec2[vec[i] - 1] += 1;\n\t}\n\tfor (int i = h - 1; i >= 1; i--) vec2[i - 1] += vec2[i];\n\treturn vec2;\n}\n\nlong long calc_0(int h, int w, vector<int> vec) {\n\tvector<int> vec2 = VecToVec2(h, w, vec);\n\tlong long cnt = 1, val = fact[h] * fact[w];\n\tfor (int i = 1; i < vec.size(); i++) {\n\t\tif (vec[i] == vec[i - 1]) cnt++;\n\t\telse cnt = 1;\n\t\tval /= cnt;\n\t}\n\tcnt = 1;\n\tfor (int i = 1; i < vec2.size(); i++) {\n\t\tif (vec2[i] == vec2[i - 1]) cnt++;\n\t\telse cnt = 1;\n\t\tval /= cnt;\n\t}\n\treturn val;\n}\n\nlong long calc_1(int h, int w, vector<int> vec) {\n\tvector<int> vec2 = VecToVec2(h, w, vec);\n\tlong long ret = 2, cnt = 1;\n\tif (vec2.size() == 0) ret = 1;\n\tfor (int i = 1; i < vec2.size(); i++) {\n\t\tif (vec2[i - 1] == vec2[i]) cnt++;\n\t\tif (vec2[i - 1] != vec2[i]) {\n\t\t\tret += ((1LL << cnt) - 1LL);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tret += ((1LL << cnt) - 2LL);\n\treturn ret;\n}\n\nlong long calc_2(int h, int w, vector<int> vec) {\n\tlong long ret = 2, cnt = 1;\n\tif (vec.size() == 0) ret = 1;\n\tfor (int i = 1; i < vec.size(); i++) {\n\t\tif (vec[i - 1] == vec[i]) cnt++;\n\t\tif (vec[i - 1] != vec[i]) {\n\t\t\tret += ((1LL << cnt) - 1LL);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tret += ((1LL << cnt) - 2LL);\n\treturn ret;\n}\n\nvoid solve(int h, int w, vector<int> vec) {\n\tif (vec.size() == w) {\n\t\tdp0[h][w] += calc_0(h, w, vec);\n\t\tdp1[h][w] += calc_0(h, w, vec) * calc_1(h, w, vec);\n\t\tdp2[h][w] += calc_0(h, w, vec) * calc_2(h, w, vec);\n\t\tdp3[h][w] += calc_0(h, w, vec) * (calc_1(h, w, vec) + calc_2(h, w, vec) - 1LL);\n\t\tdp0[h][w] = (dp0[h][w] + mod * mod) % mod;\n\t\tdp1[h][w] = (dp1[h][w] + mod * mod) % mod;\n\t\tdp2[h][w] = (dp2[h][w] + mod * mod) % mod;\n\t\tdp3[h][w] = (dp3[h][w] + mod * mod) % mod;\n\t\treturn;\n\t}\n\n\tint border = h;\n\tif (vec.size() >= 1) border = vec[vec.size() - 1];\n\tfor (int i = 0; i <= border; i++) {\n\t\tvector<int> vec2 = vec;\n\t\tvec2.push_back(i);\n\t\tsolve(h, w, vec2);\n\t}\n}\n\nbool dfs(int posx, int posy) {\n\tint col[10][10];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif ((posx / (1 << i)) % 2 == 1) col[i][j] = 0;\n\t\t\telse if ((posy / (1 << j)) % 2 == 1) col[i][j] = 0;\n\t\t\telse if (c[i][j] == '#') col[i][j] = 1;\n\t\t\telse col[i][j] = 2;\n\t\t}\n\t}\n\n\tint pats = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tif ((posx / (1 << i)) % 2 == 1) continue;\n\t\tint c1 = 0, c2 = 0;\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (col[i][j] == 1) c1++;\n\t\t\tif (col[i][j] == 2) c2++;\n\t\t}\n\t\tif (c1 * c2 == 0) pats++;\n\t}\n\tfor (int i = 0; i < W; i++) {\n\t\tif ((posy / (1 << i)) % 2 == 1) continue;\n\t\tint c1 = 0, c2 = 0;\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tif (col[j][i] == 1) c1++;\n\t\t\tif (col[j][i] == 2) c2++;\n\t\t}\n\t\tif (c1 * c2 == 0) pats++;\n\t}\n\tif (pats == 0) return true;\n\treturn false;\n}\n\nint main() {\n\t// 入力\n\tinit();\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) cin >> c[i][j];\n\t}\n\n\t// 前処理\n\tfor (int i = 0; i <= H; i++) {\n\t\tfor (int j = 0; j <= W; j++) {\n\t\t\tsolve(i, j, vector<int>{});\n\t\t}\n\t}\n\tdfs(0, 0);\n\n\t// 全探索\n\tlong long Answer = 0;\n\tfor (int i = 0; i < (1 << H); i++) {\n\t\tfor (int j = 0; j < (1 << W); j++) {\n\t\t\tif (dfs(i, j) == false) continue;\n\t\t\tint f1 = bitcnt[i], f2 = bitcnt[j];\n\t\t\tif (f1 == H && f2 == W) continue;\n\t\t\tif (f1 == 0 && f2 == 0) Answer += 1LL;\n\t\t\tif (f1 == 0 && f2 >= 1) Answer += (1LL << f2);\n\t\t\tif (f1 >= 1 && f2 == 0) Answer += (1LL << f1);\n\t\t\tif (f1 >= 1 && f2 >= 1) Answer += dp3[f1][f2];\n\t\t}\n\t}\n\tAnswer += dp0[H][W];\n\tcout << Answer % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#define llint long long\n#define inf 1e18\n#define mod 998244353\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint h, w;\nchar c[15][15];\nbool samex[10][1<<10], samey[10][1<<10];\nllint pop[1<<10];\nllint memo[15][15];\nllint dp[15][15], dp2[15][15];\n\nconst int FACT_MAX = 105;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint dfs(llint w, llint h)\n{\n\tif(w == 0 || h == 0) return 1;\n\tif(memo[w][h] != -1) return memo[w][h];\n\t\n\tllint ret = 1;\n\tfor(int i = 1; i <= w-1; i++){\n\t\tfor(int j = 1; j <= h; j++){\n\t\t\tret += dfs(i, h-j) * comb(w, i) % mod * comb(h, j) % mod, ret %= mod;\n\t\t}\n\t}\n\treturn memo[w][h] = ret;\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> h >> w;\n\tfor(int y = 0; y < h; y++){\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tcin >> c[x][y];\n\t\t}\n\t}\n\t\n\tmake_fact();\n\tfor(int i = 1; i < (1<<10); i++) pop[i] = pop[i&(i-1)] + 1;\n\t\n\tllint W = 1<<w, H = 1<<h;\n\tfor(int y = 0; y < h; y++){\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tchar p = '*';\n\t\t\tsamex[y][i] = true;\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tif(i & (1<<x)){\n\t\t\t\t\tif(p == '*') p = c[x][y];\n\t\t\t\t\telse if(p != c[x][y]) samex[y][i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsamex[y][0] = false;\n\t}\n\tfor(int x = 0; x < w; x++){\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tchar p = '*';\n\t\t\tsamey[x][i] = true;\n\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\tif(i & (1<<y)){\n\t\t\t\t\tif(p == '*') p = c[x][y];\n\t\t\t\t\telse if(p != c[x][y]) samey[x][i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsamex[x][0] = false;\n\t}\n\t\n\tfor(int x = 0; x <= w; x++){\n\t\tfor(int y = 0; y <= h; y++){\n\t\t\tmemo[x][y] = -1;\n\t\t}\n\t}\n\tfor(int x = 0; x <= w; x++){\n\t\tfor(int y = 0; y <= h; y++){\n\t\t\tfor(int i = 0; i <= y; i++){\n\t\t\t\tdp[x][y] += dfs(x, y-i) * comb(y, i) % mod;\n\t\t\t\tdp[x][y] %= mod;\n\t\t\t}\n\t\t\tif(x == 0) dp[x][y] = 1;\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= w; i++){\n\t\tfor(int j = 0; j <= h; j++){\n\t\t\tif(i == 0){\n\t\t\t\tdp2[i][j] = 1<<j;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(j == 0){\n\t\t\t\tdp2[i][j] = 1<<i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k = 0; k <= i; k++){\n\t\t\t\tfor(int l = 0; l <= j; l++){\n\t\t\t\t\tdp2[i][j] += comb(i, k) * comb(j, l) % mod * dp[k][l] % mod * dp[i-k][j-l] % mod;\n\t\t\t\t\tdp2[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tllint ans = dp[w][h];\n\tfor(int i = 0; i < W; i++){\n\t\tfor(int j = 0; j < H; j++){\n\t\t\tif(pop[i] == w || pop[j] == h) continue;\n\t\t\t\n\t\t\tbool flag = true;\n\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\tif(j & (1<<y)) continue;\n\t\t\t\tif(samex[y][W-1-i]) flag = false;\n\t\t\t}\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tif(i & (1<<x)) continue;\n\t\t\t\tif(samey[x][H-1-j]) flag = false;\n\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\t\n\t\t\tans += dp2[pop[i]][pop[j]], ans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld; \ntypedef double db; \ntypedef string str; \n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<ld,ld> pd; \n#define mp make_pair\n#define f first\n#define s second\n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<ld> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi; \ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back() \n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353; // = (119<<23)+1\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; }\nint pc(int x) { return __builtin_popcount(x); } //\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, \n\trb_tree_tag, tree_order_statistics_node_update>; \n// change null_type for map\n#define ook order_of_key\n#define fbo find_by_order\n\nvoid treeExample() {\n\tTree<int> t, t2; t.insert(8);\n\tauto it = t.insert(10).f; assert(it == t.lb(9));\n\tassert(t.ook(10) == 1); assert(t.ook(11) == 2);\n\tassert(*t.fbo(0) == 8);\n\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t\n}\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) { \n\t\tre(t); re(ts...); \n\t}\n\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n\t}\n\t\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n\t}\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T;\n\tT val; \n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(ll v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.val < b.val; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend ostream& operator<<(ostream& os, const mi& a) { \n\t\treturn os << a.val; }\n   \n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) { \n\t\tif ((val += m.val) >= MOD) val -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((val -= m.val) < 0) val += MOD; \n\t\treturn *this; }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\n\tmi& operator*=(const mi& m) { \n\t\tval = (ll)val*m.val%MOD; return *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { \n\t\tassert(!(a == 0)); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nmi comb[11][11], icomb[11][11];\nmi p2[11];\n\nvoid genComb() {\n\tcomb[0][0] = icomb[0][0] = 1;\n\tFOR(i,1,11) { \n\t\tF0R(j,i+1) {\n\t\t\tcomb[i][j] = comb[i-1][j];\n\t\t\tif (j) comb[i][j] += comb[i-1][j-1];\n\t\t\ticomb[i][j] = 1/comb[i][j];\n\t\t}\n\t}\n}\n\nint H,W,ROW[10],COL[10];\nmi row[11][11][3], col[11][11][3];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tp2[0] = 1; FOR(i,1,11) p2[i] = 2*p2[i-1];\n\tgenComb();\n\tre(H,W);\n\tF0R(i,H) {\n\t\tstr a; re(a);\n\t\tF0R(j,W) {\n\t\t\tif (a[j] == '.') {\n\t\t\t\tROW[i] |= 1<<j;\n\t\t\t\tCOL[j] |= 1<<i;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(j,1,W+1) col[H][j][2] = comb[W][j]*p2[W-j];\n\tmi ans = p2[W];\n\tROF(i,1,H+1) ROF(j,1,W+1) {\n\t\tcol[i][j][0] += col[i][j][2]+col[i][j][1];\n\t\tFOR(I,1,i) {\n\t\t\tint dif = i-I;\n\t\t\trow[I][j][1] += comb[i][dif]*(2*col[i][j][2]+col[i][j][1]);\n\t\t\trow[I][j][2] += comb[i][dif]*(p2[dif]-2)*col[i][j][2];\n\t\t} \n\t\tans += col[i][j][2]*(p2[i]-2);\n\t\trow[i][j][0] = row[i][j][2]+row[i][j][1];\n\t\tF0R(J,j) {\n\t\t\tint dif = j-J;\n\t\t\tcol[i][J][1] += comb[j][dif]*(2*row[i][j][2]+row[i][j][1]);\n\t\t\tcol[i][J][2] += comb[j][dif]*(p2[dif]-2)*row[i][j][2];\n\t\t}\n\t\tans += row[i][j][2]*(p2[j]-2);\n\t}\n\tFOR(i,1,1<<H) FOR(j,1,1<<W) {\n\t\tbool bad = 0;\n\t\tF0R(k,H) if (i&(1<<k)) {\n\t\t\tint lef = ROW[k]&j;\n\t\t\tif (lef == 0 || lef == j) bad = 1;\n\t\t}\n\t\tF0R(k,W) if (j&(1<<k)) {\n\t\t\tint lef = COL[k]&i;\n\t\t\tif (lef == 0 || lef == i) bad = 1;\n\t\t}\n\t\tif (bad) continue;\n\t\tint x = pc(i), y = pc(j);\n\t\tans += (row[x][y][0]+col[x][y][0])*icomb[H][x]*icomb[W][y];\n\t}\n\tps(ans);\n\t/*mi ans = 0;\n\tFOR(i,1,H+1) ans += col[i][0][2]+col[i][0][1];\n\tFOR(j,1,W+1) ans += row[0][j][2]+row[0][j][1];\n\tps(ans);*/\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), slow multiset operations\n\t* do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=15;\nconst int MOD=998244353;\nint n,m;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac[N],inv[N];\nlong long Pw[N];\nvoid init(int n=10)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\tPw[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tPw[i]=Pw[i-1]*2%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nint r[N],c[N];\nchar s[N][N];\nlong long row[N][N][3],col[N][N][3];\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%s\",s[i]);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\t if(s[i][j]=='.') r[i]|=1<<j,c[j]|=1<<i;\n\tfor(int j=1;j<=m;j++)\n\t\tcol[n][j][2]=C(m,j)*Pw[m-j]%MOD;\n\tlong long ans=Pw[m];\n\tfor(int i=n;i>=1;i--)\n\t\tfor(int j=m;j>=1;j--)\n\t\t{\n\t\t\tcol[i][j][0]=(col[i][j][1]+col[i][j][2])%MOD;\n\t\t\tfor(int k=1;k<i;k++)\n\t\t\t{\n\t\t\t\tint d=i-k;\n\t\t\t\trow[k][j][1]=(row[k][j][1]+C(i,d)*(col[i][j][2]*2+col[i][j][1])%MOD)%MOD;\n\t\t\t\trow[k][j][2]=(row[k][j][2]+C(i,d)*(Pw[d]-2)%MOD*col[i][j][2]%MOD)%MOD;\n\t\t\t}\n\t\t\tans=(ans+col[i][j][2]*(Pw[i]-2)%MOD)%MOD;\n\t\t\trow[i][j][0]=(row[i][j][1]+row[i][j][2])%MOD;\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t{\n\t\t\t\tint d=j-k;\n\t\t\t\tcol[i][k][1]=(col[i][k][1]+C(j,d)*(row[i][j][2]*2+row[i][j][1])%MOD)%MOD;\n\t\t\t\tcol[i][k][2]=(col[i][k][2]+C(j,d)*(Pw[d]-2)%MOD*row[i][j][2]%MOD)%MOD;\n\t\t\t}\n\t\t\tans=(ans+row[i][j][2]*(Pw[j]-2)%MOD)%MOD;\n\t\t}\n\tfor(int i=1;i<(1<<n);i++)\n\t\tfor(int j=1;j<(1<<m);j++)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\tif(i&(1<<k))\n\t\t\t\t{\n\t\t\t\t\tint w=r[k]&j;\n\t\t\t\t\tif(w==j||w==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tfor(int k=0;k<m;k++)\n\t\t\t\tif(j&(1<<k))\n\t\t\t\t{\n\t\t\t\t\tint w=c[k]&i;\n\t\t\t\t\tif(w==i||w==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tint x=__builtin_popcount(i),y=__builtin_popcount(j);\n\t\t\tans=(ans+(row[x][y][0]+col[x][y][0])%MOD*ksm(C(n,x),MOD-2)%MOD*ksm(C(m,y),MOD-2)%MOD)%MOD;\n\t\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 20, mod = 998244353;\n\nint n, m, col[N], lin[N], comb[N][N], f[N][N][2], g[N][N][2], icomb[N][N];\nchar s[N];\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\ninline int addMod(int a, int b) {\n\treturn (a += b) >= mod ? a - mod : a;\n}\n\ninline ll quickpow(ll base, ll pw) {\n\tll ret = 1;\n\twhile (pw) {\n\t\tif (pw & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, pw >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (R int i = 1; i <= n; ++i) {\n\t\tscanf(\"%s\", s + 1);\n\t\tfor (R int j = 1; j <= m; ++j)\n\t\t\tif (s[j] == '.') lin[i - 1] |= 1 << j >> 1, col[j - 1] |= 1 << i >> 1;\n\t}\n\tfor (R int i = 0; i <= max(n, m); ++i) {\n\t\tcomb[i][0] = icomb[i][0] = 1;\n\t\tfor (R int j = 1; j <= i; ++j) {\n\t\t\tcomb[i][j] = addMod(comb[i - 1][j - 1], comb[i - 1][j]);\n\t\t\ticomb[i][j] = quickpow(comb[i][j], mod - 2);\n\t\t}\n\t}\n\tint ans = 1 << n;\n\tfor (R int i = 1; i <= n; ++i)\n\t\tg[i][m][1] = comb[n][i] * (1ll << (n - i)) % mod;\n\tfor (R int i = n; i; --i)\n\t\tfor (R int j = m; j; --j) {\n\t\t\tfor (R int u = i - 1; u; --u) {\n\t\t\t\tg[u][j][0] = (g[u][j][0] + (2ll * f[i][j][1] + f[i][j][0]) * comb[i][u]) % mod;\n\t\t\t\tg[u][j][1] = (g[u][j][1] + ((1ll << (i - u)) - 2) * f[i][j][1] % mod * comb[i][u]) % mod;\n\t\t\t}\n\t\t\tfor (R int u = j - 1; u; --u) {\n\t\t\t\tf[i][u][0] = (f[i][u][0] + (2ll * g[i][j][1] + g[i][j][0]) * comb[j][u]) % mod;\n\t\t\t\tf[i][u][1] = (f[i][u][1] + ((1ll << (j - u)) - 2) * g[i][j][1] % mod * comb[j][u]) % mod;\n\t\t\t}\n\t\t\tans = (ans + ((1ll << i) - 2) * f[i][j][1] + ((1ll << j) - 2) * g[i][j][1]) % mod;\n\t\t\tf[i][j][1] = ((ll) f[i][j][0] + f[i][j][1] + g[i][j][0] + g[i][j][1]) * icomb[n][i] % mod * icomb[m][j] % mod;\n\t\t\t\n\t\t}\n\tfor (R int i = 1; i < 1 << n; ++i)\n\t\tfor (R int j = 1; j < 1 << m; ++j) {\n\t\t\tint flag = 1, ci = 0, cj = 0;\n\t\t\tfor (R int u = 0, w; flag && u < n; ++u)\n\t\t\t\tif (i & (1 << u))\n\t\t\t\t\t++ci, w = lin[u] & j, flag &= (w != j) && (w != 0);\n\t\t\tfor (R int u = 0, w; flag && u < m; ++u)\n\t\t\t\tif (j & (1 << u))\n\t\t\t\t\t++cj, w = col[u] & i, flag &= (w != i) && (w != 0);\n\t\t\tif (flag) ans = addMod(ans, f[ci][cj][1]);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reversed_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 10;\nconst int P = 998244353;\nchar a[mxN+3][mxN+3];\nint row[mxN+3],col[mxN+3];\nllong f[mxN+3][mxN+3][2],g[mxN+3][mxN+3][2],h[mxN+3][mxN+3];\nllong comb[mxN+3][mxN+3],combi[mxN+3][mxN+3];\nint n,m;\n\nvoid updsum(llong &x,llong y) {x+=y-P,x+=(x>>31)&P;}\n\nllong quickpow(llong x,llong y)\n{\n\tif(y==0ll) {return 1ll;}\n\tllong ret = quickpow(x,y>>1); ret = ret*ret%P; if(y&1ll) ret = ret*x%P;\n\treturn ret;\n}\nllong mulinv(llong x) {return quickpow(x,P-2);}\nvoid initcomb(int n)\n{\n\tcomb[0][0] = 1ll;\n\tfor(int i=1; i<=n; i++) {comb[i][0] = comb[i][i] = 1ll; for(int j=1; j<i; j++) {updsum(comb[i][j]=comb[i-1][j-1],comb[i-1][j]);}}\n\tfor(int i=0; i<=n; i++) for(int j=0; j<=i; j++) {combi[i][j] = mulinv(comb[i][j]);}\n}\n\nint main()\n{\n\tinitcomb(mxN);\n\tn = read(),m = read();\n\tfor(int i=0; i<n; i++) {scanf(\"%s\",a[i]); for(int j=0; j<m; j++) a[i][j] = (a[i][j]=='#'?1:0),row[i]|=(a[i][j]<<j),col[j]|=(a[i][j]<<i);}\n\tllong ans = (1<<m);\n\tfor(int i=0; i<m; i++) {g[0][i][1] = 1ll<<i;}\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tfor(int j=0; j<m; j++)\n\t\t{\n\t\t\tfor(int k=1; k<=i; k++)\n\t\t\t{\n\t\t\t\tllong tmp = (g[i-k][j][0]+g[i-k][j][1]*2ll)*comb[i][k]%P;\n\t\t\t\tupdsum(f[i][j][0],tmp);\n\t\t\t\ttmp = g[i-k][j][1]*((1ll<<k)-2ll)%P*comb[i][k]%P;\n\t\t\t\tupdsum(f[i][j][1],tmp);\n\t\t\t}\n\t\t\tfor(int k=1; k<=j; k++)\n\t\t\t{\n\t\t\t\tllong tmp = (f[i][j-k][0]+f[i][j-k][1]*2ll)*comb[j][k]%P;\n\t\t\t\tupdsum(g[i][j][0],tmp);\n\t\t\t\ttmp = f[i][j-k][1]*((1ll<<k)-2ll)%P*comb[j][k]%P;\n\t\t\t\tupdsum(g[i][j][1],tmp);\n\t\t\t}\n\t\t\th[i][j] = (f[i][j][0]+f[i][j][1]+g[i][j][0]+g[i][j][1])%P;\n\t\t\tllong coe = comb[n][i]*comb[m][j]%P;\n\t\t\tupdsum(ans,f[i][j][1]*coe%P*((1ll<<m-j)-2ll)%P);\n\t\t\tupdsum(ans,g[i][j][1]*coe%P*((1ll<<n-i)-2ll)%P);\n\t\t}\n\t}\n\tfor(int i=1; i<(1<<n); i++)\n\t{\n\t\tfor(int j=1; j<(1<<m); j++)\n\t\t{\n\t\t\tbool ok = true; int cnt1 = 0,cnt2 = 0;\n\t\t\tfor(int k=0; k<n; k++) if(i&(1<<k))\n\t\t\t{\n\t\t\t\tcnt1++;\n\t\t\t\tif((row[k]&j)==j||(row[k]&j)==0) {ok = false; break;}\n\t\t\t}\n\t\t\tfor(int k=0; k<m; k++) if(j&(1<<k))\n\t\t\t{\n\t\t\t\tcnt2++;\n\t\t\t\tif((col[k]&i)==i||(col[k]&i)==0) {ok = false; break;}\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tupdsum(ans,h[n-cnt1][m-cnt2]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(a) int(a.size())\nconst int N=12;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,f[2][N][N],C[N][N],r[N],c[N];\nchar s[N];\n\nint sgn(int x) {\n\treturn x&1?1:mod-1;\n}\n\nint main() {\n\tfor(int i=0;i<N;i++) {\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tfor(int t=0;t<2;t++) {\n\t\tfor(int i=0;i<N;i++)\n\t\t\tfor(int j=0;j<N;j++) if(!i||!j) f[t][i][j]=1<<((i+j)*t);\n\t\tfor(int i=1;i<N;i++)\n\t\t\tfor(int j=1;j<N;j++) {\n\t\t\t\tfor(int k=1;k<=i;k++) f[t][i][j]=(f[t][i][j]+1ll*C[i][k]*f[t][i-k][j]%mod*sgn(k)%mod*(1<<k))%mod;\n\t\t\t\tfor(int k=1;k<=j;k++) f[t][i][j]=(f[t][i][j]+1ll*C[j][k]*f[t][i][j-k]%mod*sgn(k)%mod*(1<<k))%mod;\n\t\t\t\tfor(int k=1;k<=i;k++)\n\t\t\t\t\tfor(int l=1;l<=j;l++) f[t][i][j]=(f[t][i][j]+2ll*C[i][k]*C[j][l]%mod*f[t][i-k][j-l]%mod*sgn(k+l))%mod;\n\t\t\t}\n\t}\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++) {\n\t\tscanf(\"%s\",s);\n\t\tfor(int j=0;j<m;j++) if(s[j]=='#') r[i]|=1<<j,c[j]|=1<<i;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<(1<<n);i++)\n\t\tfor(int j=1;j<(1<<m);j++) {\n\t\t\tbool fl=0;int a=0,b=0;\n\t\t\tfor(int k=0;k<n;k++) if(i>>k&1) ++a,fl|=((r[k]&j)==j||(~r[k]&j)==j);\n\t\t\tfor(int k=0;k<m;k++) if(j>>k&1) ++b,fl|=((c[k]&i)==i||(~c[k]&i)==i);\n\t\t\tif(!fl) ans=(ans+f[1][n-a][m-b])%mod;\n\t\t}\n\tans=(ans+f[0][n][m])%mod;cout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int mo=998244353;\nconst int N=25;\nchar s[N][N];\nint n,m,ans;\nint C[N][N],P[N];\nint f[N][N],g[N][N];\nint ok1[1<<10][N];\nint ok2[1<<10][N];\nvoid init(){\n\tP[0]=1;\n\tFor(i,1,N-1) P[i]=2*P[i-1];\n\tFor(i,0,N-1) C[i][0]=1;\n\tFor(i,1,N-1) For(j,1,i)\n\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,n) scanf(\"%s\",s[i]+1);\n\tf[0][0]=1;\n\tFor(S,0,2*N-2) For(i,0,N-1) if (S>=i&&S-i<=N-1)\n\t\tFor(k,1,N-1-(S-i)) f[S-i+k][i]=(f[S-i+k][i]+1ll*f[i][S-i]*C[S-i+k][k])%mo;\n\tFor(i,0,N-1) For(j,0,i) f[i][j]=f[j][i]=(f[i][j]+f[j][i])%mo;\n\tf[0][0]=1;\n\tFor(i,1,n) For(j,1,m) For(x,0,i) For(y,0,j)\n\t\tg[i][j]=(g[i][j]+1ll*C[i][x]*C[j][y]%mo*f[x][j-y]%mo*f[i-x][y])%mo;\n\tFor(i,0,(1<<n)-1) For(j,1,m){\n\t\tint cnt=0,S=0;\n\t\tFor(k,1,n) if (i&(1<<(k-1)))\n\t\t\tcnt+=(s[k][j]=='#'),S++;\n\t\tok1[i][j]=(cnt&&cnt!=S);\n\t}\n\tFor(i,0,(1<<m)-1) For(j,1,n){\n\t\tint cnt=0,S=0;\n\t\tFor(k,1,m) if (i&(1<<(k-1)))\n\t\t\tcnt+=(s[j][k]=='#'),S++;\n\t\tok2[i][j]=(cnt&&cnt!=S);\n\t}\n\tFor(i,1,(1<<n)-1) For(j,1,(1<<m)-1){\n\t\tbool fl=1;\n\t\tFor(k,1,m) if (j&(1<<(k-1))) fl&=ok1[i][k];\n\t\tFor(k,1,n) if (i&(1<<(k-1))) fl&=ok2[j][k];\n\t\tif (!fl||!(i+j)) continue;\n\t\tint S1=n,S2=m;\n\t\t//cout<<i<<' '<<j<<endl;\n\t\tFor(k,1,m) if (j&(1<<(k-1))) S2--;\n\t\tFor(k,1,n) if (i&(1<<(k-1))) S1--;\n\t\tif (!S1&&!S2) ans=(ans+1)%mo;\n\t\telse if (!S1||!S2) ans=(ans+P[S1+S2])%mo;\n\t\telse ans=(ans+g[S1][S2])%mo;\n\t}\n\t//cout<<f[n][m]<<endl;\n\tans=(ans+f[n][m])%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;//  998244853; \n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int N = 11;\nmint c[N][N], ic[N][N];\nmint pw[N];\nint n,m;\nmint row[N][N][3], col[N][N][3];\nvoid prep() {\n    pw[0] = 1;\n    for (int i = 1; i < N; i++) {\n        pw[i] = pw[i-1] * 2;\n    }\n    c[0][0] = ic[0][0] = 1;\n    for (int i = 1; i < N; i++) {\n        c[i][0] = ic[i][0] = 1;\n        for (int j = 1; j < N; j++) {\n            c[i][j] = c[i-1][j-1] + c[i-1][j];\n            ic[i][j] = 1/c[i][j];\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        row[i][m][2] = c[n][i] * pw[n-i];\n    }\n    for (int i = n; i >= 1; i--) {\n        for (int j = m; j >= 1; j--) {\n            row[i][j][0] = row[i][j][1] + row[i][j][2];\n            for (int y = 1; y < j; y++) {\n                col[i][y][1] += c[j][y] * (2*row[i][j][2] + row[i][j][1]);\n                col[i][y][2] += c[j][y] * (pw[j-y] - 2) * row[i][j][2];\n            }\n            col[i][j][0] = col[i][j][1] + col[i][j][2];\n            for (int x = 1; x < i; x++) {\n                row[x][j][1] += c[i][x] * (2*col[i][j][2] + col[i][j][1]);\n                row[x][j][2] += c[i][x] * (pw[i-x] - 2) * col[i][j][2];\n            }\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m;\n    prep();\n    vector<int> R(n), C(m);\n    for (int i = 0; i < n; i++) {\n        string s; cin >> s;\n        for (int j = 0; j < m; j++) {\n            if (s[j]=='#'){\n                R[i] |= 1<<j;\n                C[j] |= 1<<i;\n            }\n        }\n    }\n    mint res = pw[n];\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            res += row[i][j][2] * (pw[j] - 2);\n            res += col[i][j][2] * (pw[i] - 2);\n        }\n    }\n    for (int x = 1; x < 1<<n; x++) {\n        for (int y = 1; y < 1<<m; y++) {\n            bool mono = false;\n            for (int i = 0; i < n; i++) {\n                if (x>>i&1) {\n                    int rem = R[i]&y;\n                    if (rem == 0 || rem == y) mono = true;\n                }\n            }\n            for (int j = 0; j < m; j++) {\n                if (y>>j&1) {\n                    int rem = C[j]&x;\n                    if (rem == 0 || rem == x) mono = true;\n                }\n            }\n            if (mono) continue;\n            int i = __builtin_popcount(x);\n            int j = __builtin_popcount(y);\n            res += (row[i][j][0] + col[i][j][0]) * ic[n][i] * ic[m][j];\n        }\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nmt19937 mt(736);\n\nconst int mod = 998244353;\n\nusing fld = bitset<100>;\n\n\nclass gen\n{\n\tvector<fld> black, white;\n\npublic:\n\tvoid op(int h, int w)\n\t{\n\t\tblack.resize(h + w);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tblack[i][i * w + j] = true;\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tfor (int j = 0; j < h; j++)\n\t\t\t\tblack[i + h][j * w + i] = true;\n\n\t\twhite = black;\n\n\t\tfor (auto &it : white)\n\t\t\tit = ~it;\n\t}\n\n\tconst vector<fld> &bl()\n\t{\n\t\treturn black;\n\t}\n\n\n\tconst vector<fld> &wh()\n\t{\n\t\treturn white;\n\t}\n} hlp;\n\n\nunordered_set<fld> dp;\n\nvoid foo(const fld &a)\n{\n\tif (!dp.count(a))\n\t{\n\t\tdp.insert(a);\n\n\t\tfor (const auto &it : hlp.bl())\n\t\t\tfoo(a | it);\n\t\tfor (const auto &it : hlp.wh())\n\t\t\tfoo(a & it);\n\t}\n}\n\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint h, w;\n\n\tcin >> h >> w;\n\n\thlp.op(h, w);\n\n\tfld field;\n\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tstring tmp;\n\n\t\tcin >> tmp;\n\n\t\tfor (int j = 0; j < w; j++)\n\t\t\tif (tmp[j] == '#')\n\t\t\t\tfield[i * w + j] = true;\n\t}\n\n\tfoo(field);\n\n\tcout << dp.size() % mod << endl;\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcout << fixed;\n\n#ifdef LOCAL\n\tauto st = clock();\n\n\tifstream fin(\"../input.txt\");\n\n\tsolve(fin);\n\n\tcout << \"clock: \" << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tsolve();\n#endif\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\ntemplate <typename T> using posteriority_queue = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\nconst int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};\ntemplate <typename T, typename U> inline bool chmax(T &a, U b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T, typename U> inline bool chmin(T &a, U b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T> void unique(vector<T> &a) { a.erase(unique(ALL(a)), a.end()); }\nstruct IOSetup {\n  IOSetup() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  }\n} iosetup;\n\nint mod = MOD;\nstruct ModInt {\n  unsigned val;\n  ModInt(): val(0) {}\n  ModInt(ll x) : val(x >= 0 ? x % mod : x % mod + mod) {}\n  ModInt pow(ll exponent) {\n    ModInt tmp = *this, res = 1;\n    while (exponent > 0) {\n      if (exponent & 1) res *= tmp;\n      tmp *= tmp;\n      exponent >>= 1;\n    }\n    return res;\n  }\n  ModInt &operator+=(const ModInt &x) { if((val += x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator-=(const ModInt &x) { if((val += mod - x.val) >= mod) val -= mod; return *this; }\n  ModInt &operator*=(const ModInt &x) { val = static_cast<unsigned long long>(val) * x.val % mod; return *this; }\n  ModInt &operator/=(const ModInt &x) { return *this *= x.inv(); }\n  bool operator==(const ModInt &x) const { return val == x.val; }\n  bool operator!=(const ModInt &x) const { return val != x.val; }\n  bool operator<(const ModInt &x) const { return val < x.val; }\n  bool operator<=(const ModInt &x) const { return val <= x.val; }\n  bool operator>(const ModInt &x) const { return val > x.val; }\n  bool operator>=(const ModInt &x) const { return val >= x.val; }\n  ModInt &operator++() { if (++val == mod) val = 0; return *this; }\n  ModInt operator++(int) { ModInt res = *this; ++*this; return res; }\n  ModInt &operator--() { val = (val == 0 ? mod : val) - 1; return *this; }\n  ModInt operator--(int) { ModInt res = *this; --*this; return res; }\n  ModInt operator+() const { return *this; }\n  ModInt operator-() const { return ModInt(val ? mod - val : 0); }\n  ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n  ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n  ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n  ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n  friend ostream &operator<<(ostream &os, const ModInt &x) { return os << x.val; }\n  friend istream &operator>>(istream &is, ModInt &x) { ll val; is >> val; x = ModInt(val); return is; }\nprivate:\n  ModInt inv() const {\n    // assert(__gcd(val, mod) == 1);\n    unsigned a = val, b = mod; int x = 1, y = 0;\n    while (b) {\n      unsigned tmp = a / b;\n      swap(a -= tmp * b, b);\n      swap(x -= tmp * y, y);\n    }\n    return ModInt(x);\n  }\n};\nModInt abs(const ModInt &x) { return x; }\nstruct Combinatorics {\n  int val; // \"val!\" and \"mod\" must be disjoint.\n  vector<ModInt> fact, fact_inv, inv;\n  Combinatorics(int val = 10000000) : val(val), fact(val + 1), fact_inv(val + 1), inv(val + 1) {\n    fact[0] = 1;\n    FOR(i, 1, val + 1) fact[i] = fact[i - 1] * i;\n    fact_inv[val] = ModInt(1) / fact[val];\n    for (int i = val; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i;\n    FOR(i, 1, val + 1) inv[i] = fact[i - 1] * fact_inv[i];\n  }\n  ModInt nCk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val && k <= val);\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n  }\n  ModInt nPk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    // assert(n <= val);\n    return fact[n] * fact_inv[n - k];\n  }\n  ModInt nHk(int n, int k) {\n    if (n < 0 || k < 0) return ModInt(0);\n    return (k == 0 ? ModInt(1) : nCk(n + k - 1, k));\n  }\n};\n\nint main() {\n  int h, w; cin >> h >> w;\n  vector<string> a(h); REP(i, h) cin >> a[i];\n  Combinatorics com(max(h, w));\n\n  // dp[i][j]: i x j のマス目においてすべての行と列に対して操作を行う場合に\n  //           得られるマス目の塗られ方の個数\n  // dp_sub[i][j][k] における k は直前に k = 0 ... まだ何も見ていないか を意味する\n  //                                         1     行を見たか\n  //                                         2     列\n  vector<vector<vector<ModInt> > > dp_sub(h + 1, vector<vector<ModInt> >(w + 1, vector<ModInt>(3, 0)));\n  dp_sub[0][0][0] = 1;\n  REP(i, h + 1) REP(j, w + 1) {\n    FOR(k, i + 1, h + 1) dp_sub[k][j][1] += (dp_sub[i][j][0] + dp_sub[i][j][2]) * com.fact_inv[k - i];\n    FOR(k, j + 1, w + 1) dp_sub[i][k][2] += (dp_sub[i][j][0] + dp_sub[i][j][1]) * com.fact_inv[k - j];\n  }\n  vector<vector<ModInt> > dp(h + 1, vector<ModInt>(w + 1));\n  REP(i, h + 1) REP(j, w + 1) dp[i][j] = accumulate(ALL(dp_sub[i][j]), ModInt(0)) * com.fact[i] * com.fact[j];\n\n  // pat[i][j]: i 行 j 列に対して操作を行う場合に得られるマス目の塗られ方の個数\n  //            ただし行・列いずれに関しても操作が行われないマスは無視する\n  vector<vector<ModInt> > pat(h + 1, vector<ModInt>(w + 1, 0));\n  REP(i, h + 1) REP(j, w + 1) {\n    // y 行 x 列白く塗る\n    REP(y, i + 1) REP(x, j + 1) pat[i][j] += com.nCk(i, y) * com.nCk(j, x) * dp[y][j - x] * dp[i - y][x];\n  }\n\n  ModInt ans = 0;\n  REP(i, 1 << h) REP(j, 1 << w) { // 行 i, 列 j を残す\n    if (__builtin_popcount(i) < 2 || __builtin_popcount(j) < 2) continue;\n    vector<vector<char> > left; // 残ったマス目\n    REP(y, h) if (i >> y & 1) {\n      left.emplace_back();\n      REP(x, w) if (j >> x & 1) left.back().emplace_back(a[y][x]);\n    }\n    bool ok = true;\n    // 行を見る\n    REP(y, left.size()) {\n      bool same = true;\n      FOR(x, 1, left[y].size()) same &= left[y][x - 1] == left[y][x];\n      ok &= !same;\n    }\n    // 列を見る\n    REP(x, left.front().size()) {\n      bool same = true;\n      FOR(y, 1, left.size()) same &= left[y - 1][x] == left[y][x];\n      ok &= !same;\n    }\n    if (ok) ans += pat[h - __builtin_popcount(i)][w - __builtin_popcount(j)];\n  }\n  // 何も残さない\n  ans += dp[h][w];\n\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://betrue12.hateblo.jp/entry/2020/01/19/170701\n//https://drken1215.hatenablog.com/entry/2020/02/02/134400\n\n#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define chmax(x,y) x = max(x,y)\n#define chmin(x,y) x = min(x,y)\n\nconst int mod = 998244353;\nstruct mint {\nll x; \nmint(ll x=0):x((x%mod+mod)%mod){}\nmint operator-() const { return mint(-x);}\nmint& operator+=(const mint a) {\nif ((x += a.x) >= mod) x -= mod;\nreturn *this;\n }\nmint& operator-=(const mint a) {\nif ((x += mod-a.x) >= mod) x -= mod;\nreturn *this;\n }\n mint& operator*=(const mint a) {\n(x *= a.x) %= mod;\nreturn *this;\n}\nmint operator+(const mint a) const {\nmint res(*this);\nreturn res+=a;\n}\nmint operator-(const mint a) const {\nmint res(*this);\nreturn res-=a;\n}\n mint operator*(const mint a) const {\nmint res(*this);\nreturn res*=a;\n}\nmint pow(ll t) const {\nif (!t) return 1;\nmint a = pow(t>>1);\na *= a;\nif (t&1) a *= *this;\nreturn a;\n}\n mint inv() const {\nreturn pow(mod-2);\n }\n  mint& operator/=(const mint a) {\nreturn (*this) *= a.inv();\n }\nmint operator/(const mint a) const {\nmint res(*this);\nreturn res/=a;\n }\n};\nstruct combination {\nvector<mint> fact, ifact;\ncombination(int n):fact(n+1),ifact(n+1) {\n  assert(n < mod);\n fact[0] = 1;\n for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n ifact[n] = fact[n].inv();\n  for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n}\nmint operator()(int n, int k) {\nif (k < 0 || k > n) return 0;\nreturn fact[n]*ifact[k]*ifact[n-k];\n}\n  };\n\nint H,W;\nvector<string>A;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\n\n//初始化排列组合\n\ncombination c(20);\ncin>>H>>W;\nA.resize(H);\nrep(h,H)cin>>A[h];\n\n/*\ndp计算长方形的组合数\ndp1[a][b]表示长方形里有黑色线的组合数\ndp2[a][b]表示长方形里有黑色线的组合数\n\n横的有i个白线,竖的有j个白线的时候\ni和j必须大于0 \ndp2[a][b]+=c(a,i)*c(b,j)*dp2[a-i][b-j](1<=i<=a-1,1<=j<=b-1) \ndp2[a][b]+=1 (全白的情况有一种)\n\n横的有i个黑线，竖的有j个黑线的时候\ni和j不能同时为0\ndp1[a][b]+=c(a,i)*c(b,j)*dp2[a-i][b-j] (i+j>=1,i<=a-1,j<=b-1)\ndp1[a][b]+=1(全黑的情况有一种)\n*/\nvector<vector<mint>>R(15,vector<mint>(15,0));\nauto dp1=R;\nauto dp2=R;\nrep(i,15)R[0][i]=R[i][0]=mint(2).pow(i);\n\n//计算dp2\n\nfor(int a=1;a<15;a++)\n    for(int b=1;b<15;b++){\n        dp2[a][b]=1;\n        for(int i=1;i<a;i++)\n            for(int j=1;j<b;j++){\n                dp2[a][b]+=dp2[a-i][b-j]*c(a,i)*c(b,j);\n            }\n    }\n//计算dp1\n\nfor(int a=1;a<15;a++){\n    for(int b=1;b<15;b++){\n        dp1[a][b]=1;\n        for(int i=0;i<a;i++)\n            for(int j=0;j<b;j++){\n                if(i+j==0)continue;\n                dp1[a][b]+=dp2[a-i][b-j]*c(a,i)*c(b,j);\n            }\n        R[a][b]=dp1[a][b]+dp2[a][b];\n    }\n}\n\n/*\n计算L的组合数\nsumR[a][b] 表示两个交叉矩形的组合数的和\nsubR[a][b]表示竖的a个黑色横着b个白色的长方形组合数(先涂黑色)\n这里subR[a][b]=subR[b][a] \n*/\nvector<vector<mint>>L(15,vector<mint>(15,0));\nauto sumR=L,subR=L;\nrep(i,15){\n    subR[1][i]=1;\n    subR[i][1]=mint(2).pow(i)-1; //减去全黑1种\n}\nfor(int s=2;s<30;s++){\n    for(int a=1;a<15;a++){\n        int b=s-a;\n        if(b<1||b>=15)continue;\n        subR[a][b]=1;\n        for(int i=1;i<a;i++){\n            subR[a][b]+=c(a,i)*subR[b][a-i];//？这里是不是subR[b][a-i]比subR[a-i][b]先算？\n        }\n    }\n}\n\nrep(a,15)rep(b,15){\n    if(a==0)sumR[a][b]=1;\n    else if(b==0)sumR[a][b]=1;\n    else sumR[a][b]=subR[a][b]+subR[b][a];\n}\n//竖方向黑色i个白色a-i个，横方向白色j个黑色b-j个 求i*j的长方形颜色组合数\nrep(i,15)L[0][i]=L[i][0]=mint(2).pow(i);\nfor(int a=1;a<14;a++)\n    for(int b=1;b<14;b++)\n        rep(i,a+1)\n            rep(j,b+1){\n                L[a][b]+=c(a,i)*c(b,j)*sumR[i][j]*sumR[a-i][b-j];\n            }\n\n\n    mint ans = R[H][W];\n    for (int bit = 0; bit < (1<<H)-1; ++bit) {\n        vector<int> tate;\n        for (int i = 0; i < H; ++i) if (!(bit & (1<<i))) tate.push_back(i);\n        for (int bit2 = 0; bit2 < (1<<W)-1; ++bit2) {\n            vector<int> yoko;\n            for (int i = 0; i < W; ++i) if (!(bit2 & (1<<i))) yoko.push_back(i);\n \n            //留下来的行或者列必须有两种颜色\n            bool ok = true;\n            for (auto i : tate) {\n                set<char> se;\n                for (auto j : yoko) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n            for (auto j : yoko) {\n                set<char> se;\n                for (auto i : tate) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n \n            if (ok) {\n                int c = __builtin_popcount(bit);\n                int r = __builtin_popcount(bit2);\n                mint add = L[c][r];\n                ans += add;\n            }\n        }\n    }\n    cout << ans.x << endl;\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "嘘っぽい　完"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reversed_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 10;\nconst int P = 998244353;\nchar a[mxN+3][mxN+3];\nint row[mxN+3],col[mxN+3];\nllong f[mxN+3][mxN+3][2],g[mxN+3][mxN+3][2],h[mxN+3][mxN+3];\nllong comb[mxN+3][mxN+3],combi[mxN+3][mxN+3];\nint n,m;\n\nvoid updsum(llong &x,llong y) {x+=y-P,x+=(x>>31)&P;}\n\nllong quickpow(llong x,llong y)\n{\n\tif(y==0ll) {return 1ll;}\n\tllong ret = quickpow(x,y>>1); ret = ret*ret%P; if(y&1ll) ret = ret*x%P;\n\treturn ret;\n}\nllong mulinv(llong x) {return quickpow(x,P-2);}\nvoid initcomb(int n)\n{\n\tcomb[0][0] = 1ll;\n\tfor(int i=1; i<=n; i++) {comb[i][0] = comb[i][i] = 1ll; for(int j=1; j<i; j++) {updsum(comb[i][j]=comb[i-1][j-1],comb[i-1][j]);}}\n\tfor(int i=0; i<=n; i++) for(int j=0; j<=i; j++) {combi[i][j] = mulinv(comb[i][j]);}\n}\n\nint main()\n{\n\tinitcomb(mxN);\n\tn = read(),m = read();\n\tfor(int i=0; i<n; i++) {scanf(\"%s\",a[i]); for(int j=0; j<m; j++) a[i][j] = (a[i][j]=='#'?1:0),row[i]|=(a[i][j]<<j),col[j]|=(a[i][j]<<i);}\n\tllong ans = (1<<m);\n\tfor(int i=0; i<m; i++) {g[0][i][1] = comb[m][i]*(1ll<<i)%P;}\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tfor(int j=0; j<m; j++)\n\t\t{\n\t\t\tfor(int k=1; k<=i; k++)\n\t\t\t{\n\t\t\t\tllong tmp = (g[i-k][j][0]+g[i-k][j][1]*2ll)*comb[n-i+k][k]%P;\n\t\t\t\tupdsum(f[i][j][0],tmp);\n\t\t\t\ttmp = g[i-k][j][1]*((1ll<<k)-2ll)%P*comb[n-i+k][k]%P;\n\t\t\t\tupdsum(f[i][j][1],tmp);\n\t\t\t}\n\t\t\tfor(int k=1; k<=j; k++)\n\t\t\t{\n\t\t\t\tllong tmp = (f[i][j-k][0]+f[i][j-k][1]*2ll)*comb[m-j+k][k]%P;\n\t\t\t\tupdsum(g[i][j][0],tmp);\n\t\t\t\ttmp = f[i][j-k][1]*((1ll<<k)-2ll)%P*comb[m-j+k][k]%P;\n\t\t\t\tupdsum(g[i][j][1],tmp);\n\t\t\t}\n\t\t\th[i][j] = (f[i][j][0]+f[i][j][1]+g[i][j][0]+g[i][j][1])%P;\n\t\t\tupdsum(ans,f[i][j][1]*((1ll<<m-j)-2ll)%P);\n\t\t\tupdsum(ans,g[i][j][1]*((1ll<<n-i)-2ll)%P);\n\t\t}\n\t}\n\tfor(int i=1; i<(1<<n); i++)\n\t{\n\t\tfor(int j=1; j<(1<<m); j++)\n\t\t{\n\t\t\tbool ok = true; int cnt1 = 0,cnt2 = 0;\n\t\t\tfor(int k=0; k<n; k++) if(i&(1<<k))\n\t\t\t{\n\t\t\t\tcnt1++;\n\t\t\t\tif((row[k]&j)==j||(row[k]&j)==0) {ok = false; break;}\n\t\t\t}\n\t\t\tfor(int k=0; k<m; k++) if(j&(1<<k))\n\t\t\t{\n\t\t\t\tcnt2++;\n\t\t\t\tif((col[k]&i)==i||(col[k]&i)==0) {ok = false; break;}\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tupdsum(ans,h[n-cnt1][m-cnt2]*combi[n][cnt1]%P*combi[m][cnt2]%P);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int H, W; cin >> H >> W;\n    vector<string> A(H); cin >> A;\n\n    int n = H + W;\n    Combination C(n);\n    mmat sti(n + 1);\n    sti[0] = mvec(1, 1);\n    FOR(i, 1, n + 1){\n        sti[i].resize(i + 1);\n        sti[i][0] = 0;\n        FOR(j, 1, i) sti[i][j] = sti[i - 1][j - 1] + sti[i - 1][j] * j;\n        sti[i][i] = 1;\n    }\n\n    mmat dp(H + 1, mvec(W, 0));\n    dp[0][0] = 1;\n    REP(i, H){\n        REP(j, W){\n            dp[i + 1][j] += dp[i][j] * (j + 2);\n            if(j < W - 1) dp[i + 1][j + 1] += dp[i][j];\n        }\n    }\n    \n    mmat dq(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(k, w) dq[h][w] += dp[h][k] * sti[w][k + 1] * C.fact[k + 1] * C.fact[k];\n        if(w == 0) dq[h][w] = 1;\n    }\n\n    mmat dq2(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(i, h + 1) REP(j, w + 1){\n            dq2[h][w] += dq[i][w - j] * dq[h - i][j] * C.nCr(h, i) * C.nCr(w, j);\n        }\n    }\n    \n    mint ans = dq[H][W];\n\n    mat flgx(bit(H), vec(W, 0)), flgy(bit(W), vec(H, 0));\n    REP(x, bit(H)){\n        REP(j1, W) REP(j2, j1){\n            bool f = false;\n            \n            REP(i1, H) REP(i2, i1) if((x >> i1) & (x >> i2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgx[x][j1] ^= bit(j2);\n                flgx[x][j2] ^= bit(j1);\n            }\n        }\n    }\n\n    REP(y, bit(W)){\n        REP(i1, H) REP(i2, i1){\n            bool f = false;\n\n            REP(j1, W) REP(j2, j1) if((y >> j1) & (y >> j2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgy[y][i1] ^= bit(i2);\n                flgy[y][i2] ^= bit(i1);\n            }\n        }\n    }\n\n    vector<v_bool> difx(bit(H), v_bool(W, false)), dify(bit(W), v_bool(H, false));\n    REP(x, bit(H)) REP(j, W){\n        REP(i1, H) REP(i2, i1) if((x >> i1) & (x >> i2) & 1){\n            if(A[i1][j] != A[i2][j]) difx[x][j] = true;\n        }\n    }\n    REP(y, bit(W)) REP(i, H){\n        REP(j1, W) REP(j2, j1) if((y >> j1) & (y >> j2) & 1){\n            if(A[i][j1] != A[i][j2]) dify[y][i] = true;\n        }\n    }\n\n    REP(x, bit(H)) REP(y, bit(W)){\n        int tx = 0;\n        REP(i, H) if((x >> i) & 1) tx |= flgy[y][i];\n        int ty = 0;\n        REP(j, W) if((y >> j) & 1) ty |= flgx[x][j];\n\n        bool f = true;\n        int ux = x ^ (x & tx), uy = y ^ (y & ty);\n        REP(i, H) if(((ux >> i) & 1) && !dify[ty][i]) f = false;\n        REP(j, W) if(((uy >> j) & 1) && !difx[tx][j]) f = false; \n\n        if(((x & tx) == x) && ((y & ty) == y)){\n            int h = H - __builtin_popcountll(x), w = W - __builtin_popcountll(y);\n            if(h < H && w < W) ans += dq2[h][w];\n        }\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar grid[15][15];\n\nint A[15][15];\nint B[15][15];\n\nlong long MOD = 998244353;\n\nint main(){\n    int H, W;\n    scanf(\"%d%d\", &H, &W);\n\n    for(int i = 0; i < H; i ++){\n        scanf(\" %s\", grid[i]);\n    }\n\n    for(int i = 0; i < H; i ++){\n        for(int j = 0; j < W; j ++){\n            A[i][j] = grid[i][j] == '#';\n        }\n    }\n\n    assert(H*W < 31);\n\n    long long ans = 0;\n    for(int i = 0; i < 1<<(H*W); i ++){\n\n        int cnt = 0;\n        for(int j = 0; j < H; j ++){\n            for(int k = 0; k < W; k ++){\n                B[j][k] = (i&(1<<cnt)) >> cnt;\n                cnt ++;\n            }\n        }\n\n        bool boleh = true;\n\n        for(int x1 = 0; x1 < H; x1 ++){\n            for(int x2 = x1+1; x2 < H; x2 ++){\n                for(int y1 = 0; y1 < W; y1 ++){\n                    for(int y2 = y1+1; y2 < W; y2 ++){\n                        if( (B[x1][y1] == 1 && B[x2][y1] == 0 && B[x1][y2] == 0 && B[x2][y2] == 1)\n                           || (B[x1][y1] == 0 && B[x2][y1] == 1 && B[x1][y2] == 1 && B[x2][y2] == 0) ){\n                            if(B[x1][y1] == A[x1][y1] && B[x1][y2] == A[x1][y2] &&\n                               B[x2][y1] == A[x2][y1] && B[x2][y2] == A[x2][y2]){\n                            }else{\n                                boleh = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if(boleh){\n            ans ++;\n        }\n    }\n\n    ans %= MOD;\n    printf(\"%lld\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\nint h;\nint w;\n#define MAX 12\nchar room[MAX][MAX];\nbool us[MAX][MAX];\nint dp[MAX][MAX];\n\nbool use[MAX][MAX];\nint dp2[MAX][MAX];\n\nint dp3[MAX][MAX][2];\nvoid init(){\n\tdp3[0][0][0]=1;\n\tdp3[0][0][1]=1;\n\tfor(int i=0;i<=h;i++){\n\t\tfor(int j=0;j<=w;j++){\n\t\t\tint inv=1;\n\t\t\tfor(int go=j+1;go<=w;go++){\n\t\t\t\tmulto(inv,ppow(go-j,MOD-2));\n\t\t\t\taddto(dp3[i][go][0],mul(inv,dp3[i][j][1]));\t\n\t\t\t}\n\t\t\tinv=1;\n\t\t\tfor(int go=i+1;go<=h;go++){\n\t\t\t\tmulto(inv,ppow(go-i,MOD-2));\n\t\t\t\taddto(dp3[go][j][1],mul(inv,dp3[i][j][0]));\n\t\t\t}\n\t\t}\n\t}\n}\ninline int f(int a,int b){\n\tif(us[a][b])return dp[a][b];\n\tus[a][b]=true;\n\tint ret=add(dp3[a][b][0],dp3[a][b][1]);\n\tfor(int i=1;i<=max(a,b);i++){\n\t\tmulto(ret,i);\n\t\tif(i<=min(a,b)){\n\t\t\tmulto(ret,i);\n\t\t}\n\t}\n\treturn dp[a][b]=ret;\n}\n\ninline int solve(int a,int b){\n\ta=h-a;\n\tb=w-b;\n\tif(a==0&&b==0){\n\t\treturn 1;\n\t}\n\tif(us[a][b])return dp2[a][b];\n\tus[a][b]=true;\n\tif(a==0){\n\t\treturn dp2[a][b]=ppow(2,b);\n\t}\n\tif(b==0){\n\t\treturn dp2[a][b]=ppow(2,a);\n\t}\n\tfor(int z1=0;z1<=a;z1++){\n\t\tfor(int z2=0;z2<=b;z2++){\n\t\t\taddto(dp2[a][b],mul(mul(C.C(a,z1),C.C(b,z2)),mul(f(z1,b-z2),f(a-z1,z2))));\n\t\t}\n\t}\n\treturn dp2[a][b];\n}\n\n\nint main(){\n\tcin>>h>>w;\n\tC.resize(30);\n\tinit();\n\tint ans=0;\n\tfor(int i=0;i<h;i++){\n\t\tscanf(\"%s\",room[i]);\n\t}\n\tfor(int i=1;i<(1<<h);i++){\n\t\tfor(int j=1;j<(1<<w);j++){\n\t\t\tint hh=0;\n\t\t\tint ww=0;\n\t\t\tbool nah=false;\n\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\tif(!((i>>a)&1)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\thh++;\n\t\t\t\tint tmp=-1;\n\t\t\t\tww=0;\n\t\t\t\tbool ng=false;\n\t\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\t\tif(!((j>>b)&1)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tww++;\n\t\t\t\t\tint col=(room[a][b]=='.');\n\t\t\t\t\tif(tmp==-1)tmp=col;\n\t\t\t\t\tif(tmp!=col){\n\t\t\t\t\t\tng=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ng==false){\n\t\t\t\t\tnah=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int b=0;b<w;b++){\n\t\t\t\tif(!((j>>b)&1)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint tmp=-1;\n\t\t\t\tbool ng=false;\n\t\t\t\tfor(int a=0;a<h;a++){\n\t\t\t\t\tif(!((i>>a)&1)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint col=(room[a][b]=='.');\n\t\t\t\t\tif(tmp==-1)tmp=col;\n\t\t\t\t\tif(tmp!=col){\n\t\t\t\t\t\tng=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ng==false){\n\t\t\t\t\tnah=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nah)continue;\n\t\t\taddto(ans,solve(hh,ww));\n\t\t}\n\t}\n\taddto(ans,f(h,w));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nint upd(int x){return x + (x >> 31 & MOD);}\nvoid inc(int &a , int b){a = upd(a + b - MOD);}\nint N , M , vr[13] , vc[13]; char arr[13][13];\n\nint f[1 << 10][1 << 10][3] , g[1 << 10][1 << 10][4][3][4];\nbool vf[1 << 10][1 << 10][3] , vg[1 << 10][1 << 10][4][3][4];\n\nint sf(int , int , int);\nint sg(int , int , int , int , int);\n\nbool check(int r , int c){\n\tbool flg = 1;\n\tfor(int i = 0 ; i < N ; ++i) if(r >> i & 1) flg &= (vr[i] & c) != 0 && (vr[i] & c) != c;\n\tfor(int j = 0 ; j < M ; ++j) if(c >> j & 1) flg &= (vc[j] & r) != 0 && (vc[j] & r) != r;\n\treturn flg;\n}\n\nint sf(int a , int b , int c){\n\tif(!a && !b) return 1;\n\tif(!a || !b) return 0;\n\tif(vf[a][b][c]) return f[a][b][c];\n\tvf[a][b][c] = 1; return f[a][b][c] = sg(a , b , 0 , c , 0) + check(a , b);\n}\n\nint sg(int a , int b , int c , int d , int e){\n\tif(c == 4) return e ? sf(a , b , e - 1) : 0;\n\tif(vg[a][b][c][d][e]) return g[a][b][c][d][e];\n\tint &t = g[a][b][c][d][e]; vg[a][b][c][d][e] = 1;\n\tif(c <= 1)\n\t\tif(!d) t = sg(a , b , c + 1 , d , e);\n\t\telse for(int x = (!c ? a & 31 : a >> 5 << 5) , s = x ; ; s = (s - 1) & x){\n\t\t\t\tinc(t , sg(a ^ x ^ s , b , c + 1 , d , e | (s != x))); if(!s) break;\n\t\t\t}\n\telse\n\t\tif(d == 1) t = sg(a , b , c + 1 , d , e);\n\t\telse\n\t\t\tfor(int x = (c == 2 ? b & 31 : b >> 5 << 5) , s = x ; ; s = (s - 1) & x){\n\t\t\t\tinc(t , sg(a , b ^ x ^ s , c + 1 , d , e | (s != x) << 1)); if(!s) break;\n\t\t\t}\n\treturn t;\n}\n\nint main(){\n\tcin >> N >> M; for(int i = 0 ; i < N ; ++i) for(int j = 0 ; j < M ; ++j) cin >> arr[i][j];\n\tfor(int i = 0 ; i < N ; ++i) for(int j = M - 1 ; ~j ; --j) vr[i] = vr[i] << 1 | (arr[i][j] == '#');\n\tfor(int i = 0 ; i < M ; ++i) for(int j = N - 1 ; ~j ; --j) vc[i] = vc[i] << 1 | (arr[j][i] == '#');\n\tint sum = 0;\n\tfor(int i = 0 ; i < 1 << N ; ++i) for(int j = 0 ; j < 1 << M ; ++j) inc(sum , sf(i , j , 2));\n\tcout << sum; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int H, W; cin >> H >> W;\n    vector<string> A(H); cin >> A;\n\n    int n = H + W;\n    Combination C(n);\n    mmat sti(n + 1);\n    sti[0] = mvec(1, 1);\n    FOR(i, 1, n + 1){\n        sti[i].resize(i + 1);\n        sti[i][0] = 0;\n        FOR(j, 1, i) sti[i][j] = sti[i - 1][j - 1] + sti[i - 1][j] * j;\n        sti[i][i] = 1;\n    }\n\n    mmat dp(H + 1, mvec(W, 0));\n    dp[0][0] = 1;\n    REP(i, H){\n        REP(j, W){\n            dp[i + 1][j] += dp[i][j] * (j + 2);\n            if(j < W - 1) dp[i + 1][j + 1] += dp[i][j];\n        }\n    }\n    \n    mmat dq(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(k, w) dq[h][w] += dp[h][k] * sti[w][k + 1] * C.fact[k + 1] * C.fact[k];\n        if(w == 0) dq[h][w] = 1;\n    }\n\n    mmat dq2(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(i, h + 1) REP(j, w + 1){\n            dq2[h][w] += dq[i][w - j] * dq[h - i][j] * C.nCr(h, i) * C.nCr(w, j);\n        }\n    }\n    \n    mint ans = dq[H][W];\n\n    mat flgx(bit(H), vec(W, 0)), flgy(bit(W), vec(H, 0));\n    REP(x, bit(H)){\n        REP(j1, W) REP(j2, j1){\n            bool f = false;\n            \n            REP(i1, H) REP(i2, i1) if((x >> i1) & (x >> i2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgx[x][j1] ^= bit(j2);\n                flgx[x][j2] ^= bit(j1);\n            }\n        }\n    }\n\n    REP(y, bit(W)){\n        REP(i1, H) REP(i2, i1){\n            bool f = false;\n\n            REP(j1, W) REP(j2, j1) if((y >> j1) & (y >> j2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgy[y][i1] ^= bit(i2);\n                flgy[y][i2] ^= bit(i1);\n            }\n        }\n    }\n\n    vector<v_bool> difx(bit(H), v_bool(W, false)), dify(bit(W), v_bool(H, false));\n    REP(x, bit(H)) REP(j, W){\n        REP(i1, H) REP(i2, i1) if((x >> i1) & (x >> i2) & 1){\n            if(A[i1][j] != A[i2][j]) difx[x][j] = true;\n        }\n    }\n    REP(y, bit(W)) REP(i, H){\n        REP(j1, W) REP(j2, j1) if((y >> j1) & (y >> j2) & 1){\n            if(A[i][j1] != A[i][j2]) dify[y][i] = true;\n        }\n    }\n\n    REP(x, bit(H)) REP(y, bit(W)){\n        int tx = 0;\n        REP(i, H) if((x >> i) & 1) tx |= flgy[y][i];\n        int ty = 0;\n        REP(j, W) if((y >> j) & 1) ty |= flgx[x][j];\n\n        bool f = true;\n        int ux = x ^ (x & tx), uy = y ^ (y & ty);\n        REP(i, H) if(((ux >> i) & 1) && !dify[y & ty][i]) f = false;\n        REP(j, W) if(((uy >> j) & 1) && !difx[x & tx][j]) f = false;\n\n        if(f){\n            int h = H - __builtin_popcountll(x), w = W - __builtin_popcountll(y);\n            if(h < H && w < W) ans += dq2[h][w];\n        }\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 10;\nint dp[1 << N][1 << N][4][4];\nchar s[N][N];\nconst int mod = 998244353;\n\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\n\nint num_bits[1 << N];\n\n\nint main(){\n\tfor(int i = 0; i < (1 << N); i++) num_bits[i] = __builtin_popcount(i);\n\tmemset(dp, -1, sizeof dp);\n\tint n = 10, m = 10; \n\tsd(n); sd(m);\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++) s[i][j] = rand() % 2 ? '.' : '.';\n\t\tscanf(\"%s\", s[i]);\n\t}\n\tfor(int mask1 = 1; mask1 < (1 << n); mask1++)\n\t\tfor(int mask2 = 1; mask2 < (1 << m); mask2++){\n\t\t\tint ok = 1;\n\t\t\tfor(int i = 0; i < 10; i++) if(mask1 >> i & 1){\n\t\t\t\tint msk = 0;\n\t\t\t\tfor(int j = 0; j < 10; j++) if(mask2 >> j & 1) msk |= 1 << (s[i][j] == '.');\n\t\t\t\tif(msk != 3) ok = 0;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 10; i++) if(mask2 >> i & 1){\n\t\t\t\tint msk = 0;\n\t\t\t\tfor(int j = 0; j < 10; j++) if(mask1 >> j & 1) msk |= 1 << (s[j][i] == '.');\n\t\t\t\tif(msk!=3) ok = 0;\n\t\t\t}\n\t\t\tdp[mask1][mask2][3][3] = ok;\n\t\t}\n\tfor(int mask1 = 0; mask1 < (1 << n); mask1++)\n\t\tfor(int mask2 = 0; mask2 < (1 << m); mask2++)\n\t\t\tfor(int omust1 = 0; omust1 < 4; omust1++)\n\t\t\t\tfor(int omust2 = 0; omust2 < 4; omust2++){\n\t\t\t\t\tif(mask1 == 0) dp[mask1][mask2][omust1][omust2] = omust2 == 0;\n\t\t\t\t\tif(mask2 == 0) dp[mask1][mask2][omust1][omust2] = omust1 == 0;\n\t\t\t\t\tif(min(mask1, mask2) == 0) continue;\n\t\t\t\t\tint must1 = omust1, must2 = omust2;\n\t\t\t\t\tif(must1 + must2 == 0 && (mask1 != ((1 << n) - 1) || mask2 != ((1 << m) - 1)))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(((must1 == 3) || (must2 == 3) || (must1 + must2 == 0)) && (must1+must2!=6)){\n\t\t\t\t\t\tll ret = 0;\n\t\t\t\t\t\tif(must1 != 3){\n\t\t\t\t\t\t\tfor(int submask = mask1; submask; submask = mask1 & (submask - 1)){\n\t\t\t\t\t\t\t\tint num = num_bits[submask];\n\t\t\t\t\t\t\t\tif(!(must1 >> 1 & 1)){\n\t\t\t\t\t\t\t\t\tret += dp[mask1 ^ submask][mask2][3][must2 & (~1)]; // white not required in cols now\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(!(must1 >> 0 & 1)){\n\t\t\t\t\t\t\t\t\tret += dp[mask1 ^ submask][mask2][3][must2 & (~1)];; // black not required in cols now\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(must1 == 0) ret += ((1 << num) - 2) * (ll) dp[mask1 ^ submask][mask2][3][0]; // none required in cols now\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmust1 = 3;\n\t\t\t\t\t\tif(must2 != 3){\n\t\t\t\t\t\t\tfor(int submask = mask2; submask; submask = mask2 & (submask - 1)){\n\t\t\t\t\t\t\t\tint num = num_bits[submask];\n\t\t\t\t\t\t\t\tif(!(must2 >> 1 & 1)){\n\t\t\t\t\t\t\t\t\tret += dp[mask1][mask2 ^ submask][must1 & (~1)][3]; // white not required in rows now\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(!(must2 >> 0 & 1)){\n\t\t\t\t\t\t\t\t\tret += dp[mask1][mask2 ^ submask][must1 & (~2)][3]; // black not required in rows now\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(must2==0) ret += ((1 << num) - 2) * (ll) dp[mask1][mask2 ^ submask][0][3]; // none required in rows now\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += dp[mask1][mask2][3][3];\n\t\t\t\t\t\tdp[mask1][mask2][omust1][omust2] = ret % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(\"%d\\n\", dp[(1 << n) - 1][(1 << m) - 1][0][0]);\n}"
  },
  {
    "language": "C++",
    "code": "//https://betrue12.hateblo.jp/entry/2020/01/19/170701\n//https://drken1215.hatenablog.com/entry/2020/02/02/134400\n\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n\nset<vector<string>> allfi, allnotin, allbein;\nvoid rec(vector<string> fi, set<int> &yoko, set<int> &tate, bool bein, int H, int W) {\n    if (yoko.size() == H && tate.size() == W) {\n        allfi.insert(fi);\n        if (bein) allbein.insert(fi);\n        else allnotin.insert(fi);\n    }\n    auto ifi = fi;\n    for (int h = 0; h < H; ++h) {\n        if (yoko.count(h)) continue;\n        yoko.insert(h);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '.';\n        rec(fi, yoko, tate, bein, H, W);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '#';\n        rec(fi, yoko, tate, (bein || (tate.empty() && true)), H, W);\n        fi = ifi;\n        yoko.erase(h);\n    }\n    for (int w = 0; w < W; ++w) {\n        if (tate.count(w)) continue;\n        tate.insert(w);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '.';\n        rec(fi, yoko, tate, bein, H, W);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '#';\n        rec(fi, yoko, tate, (bein || (yoko.empty() && true)), H, W);\n        fi = ifi;\n        tate.erase(w);\n    }\n}\n\nset<vector<string>> allsub;\nvoid rec2(vector<string> fi, set<int> &yoko, set<int> &tate, int H, int W) {\n    if (yoko.size() == H && tate.size() == W) {\n        allsub.insert(fi);\n    }\n    auto ifi = fi;\n    for (int h = 0; h < H; ++h) {\n        if (yoko.count(h)) continue;\n        yoko.insert(h);\n        for (int w = 0; w < W+1; ++w) fi[h][w] = '.';\n        rec2(fi, yoko, tate, H, W);\n        fi = ifi;\n        yoko.erase(h);\n    }\n    for (int w = 0; w < W; ++w) {\n        if (tate.count(w)) continue;\n        tate.insert(w);\n        for (int h = 0; h < H+1; ++h) fi[h][w] = '#';\n        rec2(fi, yoko, tate, H, W);\n        fi = ifi;\n        tate.erase(w);\n    }\n}\n\nlong long calc(int H, int W) {\n    allfi.clear();\n    allnotin.clear(), allbein.clear();\n    set<int> yoko, tate;\n    vector<string> fi(H+1, string(W+1, '.'));\n    auto fi2 = fi;\n    rec(fi, yoko, tate, false, H, W);\n    return allfi.size();\n}\n\nlong long calc2(int H, int W) {\n    set<int> yoko, tate;\n    vector<string> fi(H+1, string(W+1, '.'));\n    allsub.clear();\n    rec2(fi, yoko, tate, H, W);\n    return allsub.size();\n}\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nint H, W;\nvector<string> A;\n\nint main() {\n    bc.init(110);\n\n    // 長方形\n    vector<vector<mint>> all(15, vector<mint>(15, 0));\n    auto bein = all;\n    auto notin = all;\n    for (int i = 0; i < 15; ++i) all[0][i] = all[i][0] = modpow(mint(2), i);\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            notin[a][b] = 1;\n            for (int i = 1; i < a; ++i) {\n                for (int j = 1; j < b; ++j) {\n                    notin[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n        }\n    }\n    for (int a = 1; a < 15; ++a) {\n        for (int b = 1; b < 15; ++b) {\n            bein[a][b] = 1;\n            for (int i = 0; i < a; ++i) {\n                for (int j = 0; j < b; ++j) {\n                    if (i + j == 0) continue;\n                    bein[a][b] += notin[a-i][b-j] * bc.com(a, i) * bc.com(b, j);\n                }\n            }\n            all[a][b] = notin[a][b] + bein[a][b];\n        }\n    }\n\n    // はみ出しあり\n    vector<vector<mint>> subsub(15, vector<mint>(15, 0));\n    auto sub = subsub, part = subsub;\n    // for (int i = 0; i < 15; ++i) {\n    //     subsub[1][i] = 1;\n    //     subsub[i][1] = modpow(mint(2), i) - 1;\n    // }\n    // for (int s = 2; s < 30; ++s) {\n    //     for (int a = 1; a < 15; ++a) {\n    //         int b = s - a;\n    //         if (b < 1 || b >= 15) continue;\n    //         subsub[a][b] = 1;\n    //         for (int i = 1; i < a; ++i) {\n    //             subsub[a][b] += bc.com(a, i) * subsub[b][a-i];\n    //         }\n    //     }\n    // }\n    // for (int a = 0; a < 15; ++a) {\n    //     for (int b = 0; b < 15; ++b) {\n    //         if (a == 0) sub[a][b] = 1;\n    //         else if (b == 0) sub[a][b] = 1;\n    //         else sub[a][b] = subsub[a][b] + subsub[b][a];\n    //     }\n    // }\n\n    for (int i = 0; i < 15; ++i) part[0][i] = part[i][0] = modpow(mint(2), i);\n    for (int a = 1; a < 14; ++a) {\n        for (int b = 1; b < 14; ++b) {\n            for (int i = 0; i <= a; ++i) {\n                for (int j = 0; j <= b; ++j) {\n                    part[a][b] += bc.com(a, i) * bc.com(b, j) *\n                        all[i][b-j] * all[a-i][j];\n                }\n            }\n        }\n    }\n\n    /*\n    for (int a = 0; a <= 5; ++a) {\n        for (int b = 0; b <= 5; ++b) {\n            calc(a, b);\n            cout << a << \",\" << b << \": \" << part[a][b] << \"( \" << sub[a][b] << \" ), \" << allfi.size() << \", \" << calc2(a, b) << endl;\n        }\n    }\n    \n    \n    calc(1, 2);\n    COUT(allfi.size());\n    for (auto fi : allfi) {\n        for (auto s : fi) cout << s << endl;\n        cout << endl;\n    }\n    */\n    \n\n    cin >> H >> W;\n    A.resize(H);\n    for (int h = 0; h < H; ++h) cin >> A[h];\n\n    mint res = all[H][W];\n    for (int bit = 0; bit < (1<<H)-1; ++bit) {\n        vector<int> tate;\n        for (int i = 0; i < H; ++i) if (!(bit & (1<<i))) tate.push_back(i);\n        for (int bit2 = 0; bit2 < (1<<W)-1; ++bit2) {\n            vector<int> yoko;\n            for (int i = 0; i < W; ++i) if (!(bit2 & (1<<i))) yoko.push_back(i);\n\n            bool ok = true;\n            for (auto i : tate) {\n                set<char> se;\n                for (auto j : yoko) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n            for (auto j : yoko) {\n                set<char> se;\n                for (auto i : tate) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n\n            if (ok) {\n                int c = __builtin_popcount(bit);\n                int r = __builtin_popcount(bit2);\n                mint add = part[c][r];\n                res += add;\n\n                //cout << bit << \", \" << bit2 << \": \" << tate << \", \" << yoko << \";; \" << c << \", \" << r << \": \" << add << endl;\n            }\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 10, S = (1 << N) + 10, mod = 998244353;\n\nvoid add(int& a, int b) {\n\ta += b;\n\tif (a >= mod) a -= mod;\n}\n\nint mul(ll a, ll b) {\n\treturn (a * b) % mod;\n}\n\nstring a[N];\nint h, w, cnt[S], p2[N];\nint dp[S][S][2][3];\nbool seen[S][S][2][3], dp2[S][S], seen2[S][S];\n\nint solve(int rows, int cols, int turn, int must);\nbool is_colorful(int rows, int cols);\n\nint main() {\n\tfast_cin();\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i <= max(h, w); ++i) {\n\t\tp2[i] = (1 << i);\n\t}\n\tfor (int mask = 0; mask < (1 << max(w, h)); ++mask) {\n\t\tcnt[mask] = __builtin_popcount(mask);\n\t}\n\tint ans = 0;\n\tfor (int mask = 0; mask < (1 << w); ++mask) {\n\t// for (int mask = 0; mask <= 0; ++mask) {\n\t\tadd(ans, mul(p2[cnt[mask]], solve((1 << h) - 1, (1 << w) - 1 - mask, 0, 0)));\n\t\t// cout << mask << ' ' << mul(p2[cnt[mask]], solve((1 << h) - 1, (1 << w) - 1 - mask, 0, 0)) << endl;\n\t}\n\tcout << ans << endl;\n}\n\nint solve(int rows, int cols, int turn, int must) {\n\tif (seen[rows][cols][turn][must]) {\n\t\treturn dp[rows][cols][turn][must];\n\t} else {\n\t\tseen[rows][cols][turn][must] = true;\n\t\tint& ans = dp[rows][cols][turn][must];\n\t\tif (!rows or !cols) {\n\t\t\tans = (must == 0);\n\t\t} else {\n\t\t\tadd(ans, is_colorful(rows, cols));\n\t\t\tint submask = (turn ? cols : rows);\n\t\t\twhile (submask) {\n\t\t\t\tint nrows = rows - (turn ? 0 : submask);\n\t\t\t\tint ncols = cols - (turn ? submask : 0);\n\t\t\t\tif (must == 0) {\n\t\t\t\t\tadd(ans, mul(p2[cnt[submask]] - 2, solve(nrows, ncols, turn ^ 1, 0)));\n\t\t\t\t}\n\t\t\t\tif (must != 1) {\n\t\t\t\t\tadd(ans, solve(nrows, ncols, turn ^ 1, 1));\n\t\t\t\t}\n\t\t\t\tif (must != 2) {\n\t\t\t\t\tadd(ans, solve(nrows, ncols, turn ^ 1, 2));\n\t\t\t\t}\n\t\t\t\tsubmask = (submask - 1) & (turn ? cols : rows);\n\t\t\t}\n\t\t}\n\t\t// if (ans) {\n\t\t// \tcout << rows << ' ' << cols << ' ' << turn << ' ' << must << ' ' << ans << endl;\n\t\t// }\n\t\treturn ans;\n\t}\n}\n\nbool is_colorful(int rows, int cols) {\n\tif (seen2[rows][cols]) {\n\t\treturn dp2[rows][cols];\n\t} else {\n\t\tseen2[rows][cols] = true;\n\t\tbool& ans = dp2[rows][cols];\n\t\tvector<int> cr(h, 0), cc(w, 0);\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tif (!((rows >> i) & 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (!((cols >> j) & 1)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcr[i] |= (1 << (a[i][j] == '#'));\n\t\t\t\tcc[j] |= (1 << (a[i][j] == '#'));\n\t\t\t}\n\t\t}\n\t\tans = true;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tans &= !((rows >> i) & 1) or (cr[i] == 3);\n\t\t}\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tans &= !((cols >> j) & 1) or (cc[j] == 3);\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long mod = 998244353;\nlong long H, W;\nlong long fact[19];\nlong long nr[19][19];\nlong long dp0[19][19]; // 何もない状態\nlong long dp1[19][19]; // 横方向のみある\nlong long dp2[19][19]; // 縦方向のみある\nlong long dp3[19][19]; // 両方向ある\nchar c[19][19];\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= 15; i++) fact[i] = 1LL * i * fact[i - 1];\n\tfor (int i = 0; i <= 15; i++) {\n\t\tfor (int j = 0; j <= 15; j++) {\n\t\t\tif (i == 0 || j == 0) nr[i][j] = 1;\n\t\t\telse nr[i][j] = (nr[i - 1][j] + nr[i][j - 1]) % mod;\n\t\t}\n\t}\n}\n\nlong long ncr(int n, int r) {\n\tif (r < 0 || n < r) return 0;\n\treturn nr[n - r][r];\n}\n\nvector<int> VecToVec2(int h, int w, vector<int> vec) {\n\tvector<int> vec2(h, 0);\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (vec[i] >= 1) vec2[vec[i] - 1] += 1;\n\t}\n\tfor (int i = h - 1; i >= 1; i--) vec2[i - 1] += vec2[i];\n\treturn vec2;\n}\n\nlong long calc_0(int h, int w, vector<int> vec) {\n\tvector<int> vec2 = VecToVec2(h, w, vec);\n\tlong long cnt = 1, val = fact[h] * fact[w];\n\tfor (int i = 1; i < vec.size(); i++) {\n\t\tif (vec[i] == vec[i - 1]) cnt++;\n\t\telse cnt = 1;\n\t\tval /= cnt;\n\t}\n\tcnt = 1;\n\tfor (int i = 1; i < vec2.size(); i++) {\n\t\tif (vec2[i] == vec2[i - 1]) cnt++;\n\t\telse cnt = 1;\n\t\tval /= cnt;\n\t}\n\treturn val;\n}\n\nlong long calc_1(int h, int w, vector<int> vec) {\n\tvector<int> vec2 = VecToVec2(h, w, vec);\n\tlong long ret = 2, cnt = 1;\n\tif (vec2.size() == 0) ret = 1;\n\tfor (int i = 1; i < vec2.size(); i++) {\n\t\tif (vec2[i - 1] != vec2[i]) cnt++;\n\t\tif (vec2[i - 1] != vec2[i]) {\n\t\t\tret += ((1LL << cnt) - 2LL);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tret += ((1LL << cnt) - 2LL);\n\treturn ret;\n}\n\nlong long calc_2(int h, int w, vector<int> vec) {\n\tlong long ret = 2, cnt = 1;\n\tif (vec.size() == 0) ret = 1;\n\tfor (int i = 1; i < vec.size(); i++) {\n\t\tif (vec[i - 1] != vec[i]) cnt++;\n\t\tif (vec[i - 1] != vec[i]) {\n\t\t\tret += ((1LL << cnt) - 2LL);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tret += ((1LL << cnt) - 2LL);\n\treturn ret;\n}\n\nvoid solve(int h, int w, vector<int> vec) {\n\tif (vec.size() == w) {\n\t\tdp0[h][w] += calc_0(h, w, vec);\n\t\tdp1[h][w] += calc_0(h, w, vec) * calc_1(h, w, vec);\n\t\tdp2[h][w] += calc_0(h, w, vec) * calc_2(h, w, vec);\n\t\tdp3[h][w] += calc_0(h, w, vec) * (calc_1(h, w, vec) + calc_2(h, w, vec) - 1LL);\n\t\tdp0[h][w] = (dp0[h][w] + mod * mod) % mod;\n\t\tdp1[h][w] = (dp1[h][w] + mod * mod) % mod;\n\t\tdp2[h][w] = (dp2[h][w] + mod * mod) % mod;\n\t\tdp3[h][w] = (dp3[h][w] + mod * mod) % mod;\n\t\treturn;\n\t}\n\n\tint border = h;\n\tif (vec.size() >= 1) border = vec[vec.size() - 1];\n\tfor (int i = 0; i <= border; i++) {\n\t\tvector<int> vec2 = vec;\n\t\tvec2.push_back(i);\n\t\tsolve(h, w, vec2);\n\t}\n}\n\nbool hantei(int mask1, int mask2) {\n\tvector<int> v1, v2;\n\tfor (int i = 0; i < H; i++) { if ((mask1 / (1 << i)) % 2 == 1) v1.push_back(i); }\n\tfor (int i = 0; i < W; i++) { if ((mask2 / (1 << i)) % 2 == 1) v2.push_back(i); }\n\tvector<int> cnt1(v1.size(), 0);\n\tvector<pair<int, int>> cnt2(v2.size(), make_pair(0, 0));\n\tfor (int i = 0; i < v2.size(); i++) cnt2[i].second = v2[i];\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < v2.size(); j++) {\n\t\t\tif (c[v1[i]][v2[j]] == '#') { cnt1[i] += 1; cnt2[j].first += 1; }\n\t\t}\n\t}\n\tsort(cnt2.begin(), cnt2.end());\n\treverse(cnt2.begin(), cnt2.end());\n\tfor (int i = 0; i < v1.size(); i++) {\n\t\tfor (int j = 0; j < cnt1[i]; j++) {\n\t\t\tif (c[v1[i]][cnt2[j].second] == '.') return false;\n\t\t}\n\t\tfor (int j = cnt1[i]; j < v2.size(); j++) {\n\t\t\tif (c[v1[i]][cnt2[j].second] == '#') return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nlong long tansaku(int h, int w) {\n\tlong long ret = 0;\n\tfor (int i = h; i <= H; i++) {\n\t\tfor (int j = w; j <= W; j++) {\n\t\t\tlong long val1 = 0;\n\t\t\tif (h == 0 && w == 0) val1 = dp0[i - h][j - w];\n\t\t\telse if (h == 0) val1 = dp1[i - h][j - w];\n\t\t\telse if (w == 0) val1 = dp2[i - h][j - w];\n\t\t\telse val1 = dp3[i - h][j - w];\n\t\t\tif ((i + j - h - w) % 2 == 0) ret += val1;\n\t\t\tif ((i + j - h - w) % 2 == 1) ret -= val1;\n\t\t}\n\t}\n\tret = (ret + mod * mod) % mod;\n\treturn ret;\n}\n\nint main() {\n\t// 入力\n\tinit();\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) cin >> c[i][j];\n\t}\n\n\t// 前処理\n\tfor (int i = 0; i <= H; i++) {\n\t\tfor (int j = 0; j <= W; j++) solve(i, j, vector<int>{});\n\t}\n\n\t// ビット全探索\n\tlong long Answer = 0;\n\tfor (int i = 0; i < (1 << H); i++) {\n\t\tfor (int j = 0; j < (1 << W); j++) {\n\t\t\tif (hantei(i, j) == false) continue;\n\t\t\tint bit1 = 0; for (int k = 0; k < H; k++) { if ((i / (1 << k)) % 2 == 1) bit1++; }\n\t\t\tint bit2 = 0; for (int k = 0; k < W; k++) { if ((j / (1 << k)) % 2 == 1) bit2++; }\n\t\t\tAnswer += tansaku(bit1, bit2);\n\t\t\tAnswer = (Answer + mod * mod) % mod;\n\t\t}\n\t}\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod = 998244353;\ncat C[11][11];\n\nvoid count(int h, int w, char f_e, char f_h, char f_w, int & out, cat cur = 1) {\n\tif(h+w == 0) {\n\t\tout += cur;\n\t\tif(out >= mod) out -= mod;\n\t\treturn;\n\t}\n\tfor(int c = 0; c < 2; c++) for(int i = 0; i <= h; i++) for(int j = 0; j <= w; j++) if(i+j) {\n\t\tif((f_h>>c)&1 && i) break;\n\t\tif((f_w>>c)&1 && j) break;\n\t\tif(j && f_e&2 && c) break;\n\t\tif(i && f_e&4 && c) break;\n\t\tif(!(f_e&1)) if((h == i)^(w == j)) continue;\n\t\tcat x = C[h][i] * C[w][j] % mod;\n\t\tint n_h = f_h, n_w = f_w;\n\t\tif(i) n_w ^= n_w&(1<<(1-c));\n\t\tif(j) n_h ^= n_h&(1<<(1-c));\n\t\tn_h |= 1<<c;\n\t\tn_w |= 1<<c;\n\t\tint n_e = (f_e&1) + ((!i)<<1) + ((!j)<<2);\n\t\tcount(h-i, w-j, n_e, n_h, n_w, out, cur*x%mod);\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint H, W;\n\tcin >> H >> W;\n\tvector<int> V(H, 0);\n\tfor(int i = 0; i < H; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < W; j++)\n\t\t\tif(s[j] == '#') V[i] |= 1<<j;\n\t}\n\tmemset(C, 0, sizeof(C));\n\tfor(int i = 0; i <= 10; i++) {\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1; j <= i; j++)\n\t\t\tC[i][j] = (C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tint cnt[11][11];\n\tmemset(cnt, 0, sizeof(cnt));\n\tfor(int i = 0; i <= H; i++) for(int j = 0; j <= W; j++) if(H+W < 20)\n\t\tcount(i, j, (H-i) || (W-j), 0, 0, cnt[i][j]);\n\tcnt[10][10] = 710838430;\n\tcat ans = cnt[H][W];\n\tfor(int i = 0; i < (1<<H)-1; i++) {\n\t\tvector<int> Vr, Vc(W, 0);\n\t\tfor(int j = 0; j < H; j++)\n\t\t\tif(!((i>>j)&1)) Vr.push_back(V[j]);\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tfor(int k = 0; k < H; k++)\n\t\t\t\tif(!((i>>k)&1)) Vc[j] += ((V[k]>>j)&1)<<k;\n\t\t\tVc[j] = (!Vc[j]) || (Vc[j] == (1<<H)-1-i);\n\t\t}\n\t\tint n = H-Vr.size();\n\t\tfor(int j = 0; j < (1<<W)-1; j++) {\n\t\t\tint m = (1<<W)-1-j;\n\t\t\tbool ok = true;\n\t\t\tfor(int k = 0; k < H-n; k++) if(!(Vr[k]&m) || (Vr[k]&m) == m) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tfor(int k = 0; k < W; k++) if(!((j>>k)&1) && Vc[k]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tans += cnt[n][__builtin_popcount(j)];\n\t\t\tif(ans >= mod) ans -= mod;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n)     for(int i = 0;i < n;i++)\n#define REPR(i, n)    for(int i = n;i >= 0;i--)\n#define FOR(i, m, n)  for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define VRSORT(v) sort(v.begin(), v.end(),greater<long long>());\n#define ALL(X) (X).begin(),(X).end()\n#define INF 99999999\n#define M_PI 3.14159265358979323846\n#define MOD 1000000007\n\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 0};\nint dy[]={0, 1, 0, -1, 0};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n \nstd::string pad(int num){ char buffer[4]; std::snprintf(buffer, sizeof(buffer), \"%03d\", num); return buffer;}\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) os << \"[\" << el.first << \" \" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) os << el << \" \"; return os; }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\nint H,W;\nvector<string> A;\n\n// 難しいから一旦飛ばす。\n\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> H >> W;\n    REP(i,H){\n        string a;\n        cin >> a;\n        A.push_back(a);\n    }\n\n}\n\nvoid solve(){\n    input();\n    ull a=0;\n    set<ull> state;\n    REP(i,H) REP(j,W){\n        if(A[i][j]=='#')\n            a |= (1LL<<(i+j*W));\n    }\n    state.insert(a);\n    REP(i,H) REP(j,W){\n        set<ull> tmp;\n        for(auto s:state){\n            // ある行に対する操作\n            int t1 = s;\n            REP(k,W) t1 |= (1LL<<(i*W+k+1));\n            tmp.insert(t1);\n\n            // ある列に対する操作\n            ull t2 = s;\n            REP(k,H) t2 |= (1LL<<(k*W+j));\n            tmp.insert(t2);\n\n            // ある行に対する操作\n            ull t3 = s;\n            REP(k,W) t3 &= ~(1LL<<(i*W+k+1));\n            tmp.insert(t3);\n            \n            // ある列に対する操作\n            ull t4 = s;\n            REP(k,H) t4 &= ~(1LL<<(k*W+j));\n            tmp.insert(t4);\n\n        }\n        set<ull> tmp_set;\n        set_union(state.begin(),state.end(),tmp.begin(),tmp.end(),tmp_set.begin());\n        state.swap(tmp_set);\n    }\n\n    DBG(bitset<60>(a))\n    // cout << state << endl;\n    cout << state.size() << endl;\n\n}\n\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nstring A[10];\nconst ll mo=998244353;\n\nll comb(ll N_, ll C_) {\n\tconst int NUM_=400001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nint R[10];\nint C[10];\nll memo_all[12][12];\nll memo[12][12];\n\nll hoge_all(int H,int W) {\n\tif(memo_all[H][W]>=0) return memo_all[H][W];\n\tif(H==0 || W==0) return 1;\n\t\n\tll dp[11][11][2]={};\n\tint y,x;\n\tfor(y=1;y<=H;y++) dp[y][0][0]=comb(H,y);\n\tfor(x=1;x<=W;x++) dp[0][x][1]=comb(W,x);\n\t\n\tFOR(y,H) FOR(x,W) {\n\t\tint y2,x2;\n\t\tfor(y2=y+1;y2<=H;y2++) dp[y2][x][0]+=dp[y][x][1]*comb(H-y,y2-y)%mo;\n\t\tfor(x2=x+1;x2<=W;x2++) dp[y][x2][1]+=dp[y][x][0]*comb(W-x,x2-x)%mo;\n\t}\n\t\n\tll ret=0;\n\tFOR(x,W) ret+=dp[H][x][0];\n\tFOR(y,H) ret+=dp[y][W][1];\n\treturn memo_all[H][W]=ret%mo;\n\t\n}\n\nll hoge(int H,int W) {\n\tif(memo[H][W]>=0) return memo[H][W];\n\tll ret=0;\n\tint x,y;\n\tFOR(y,H+1) FOR(x,W+1) ret+=comb(H,y)*comb(W,x)%mo*hoge_all(y,x)%mo*hoge_all(H-y,W-x)%mo;\n\treturn memo[H][W]=ret%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) {\n\t\tcin>>A[y];\n\t\tFOR(x,W) if(A[y][x]=='#') {\n\t\t\tR[y] |= 1<<x;\n\t\t\tC[x] |= 1<<y;\n\t\t}\n\t}\n\tMINUS(memo);\n\tMINUS(memo_all);\n\t\n\tint rm,cm;\n\tll ret=hoge_all(H,W);\n\tFOR(rm,1<<H) FOR(cm,1<<W) if(rm&&cm) {\n\t\tint did=0;\n\t\tFOR(y,H) if((rm&(1<<y)) && (((R[y]&cm)==0)||(~R[y]&cm)==0)) did = 1;\n\t\tFOR(x,W) if((cm&(1<<x)) && (((C[x]&rm)==0)||(~C[x]&rm)==0)) did = 1;\n\t\tif(did==0) ret+=hoge(H-__builtin_popcount(rm),W-__builtin_popcount(cm));\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nstring A[10];\nconst ll mo=998244353;\n\nll comb(ll N_, ll C_) {\n\tconst int NUM_=400001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nint R[10];\nint C[10];\nll memo_all[12][12];\nll memo[12][12];\n\nll hoge_all(int H,int W) {\n\tif(memo_all[H][W]>=0) return memo_all[H][W];\n\tif(H==0 || W==0) return 1;\n\t\n\tll dp[11][11][2]={};\n\tint y,x;\n\tfor(y=1;y<=H;y++) dp[y][0][0]=comb(H,y);\n\tfor(x=1;x<=W;x++) dp[0][x][1]=comb(W,x);\n\t\n\tFOR(y,H) FOR(x,W) {\n\t\tint y2,x2;\n\t\tfor(y2=y+1;y2<=H;y2++) dp[y2][x][0]+=dp[y][x][1]*comb(H-y,y2-y)%mo;\n\t\tfor(x2=x+1;x2<=W;x2++) dp[y][x2][1]+=dp[y][x][0]*comb(W-x,x2-x)%mo;\n\t}\n\t\n\tll ret=0;\n\tFOR(x,W) ret+=dp[H][x][0];\n\tFOR(y,H) ret+=dp[y][W][1];\n\treturn memo_all[H][W]=ret%mo;\n\t\n}\n\nll hoge(int H,int W) {\n\tif(memo[H][W]>=0) return memo[H][W];\n\tll ret=0;\n\tint x,y;\n\tFOR(y,H+1) FOR(x,W+1) ret+=comb(H,y)*comb(W,x)%mo*hoge_all(y,x)%mo*hoge_all(H-y,W-x)%mo;\n\treturn memo[H][W]=ret%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) {\n\t\tcin>>A[y];\n\t\tFOR(x,W) if(A[y][x]=='#') {\n\t\t\tR[y] |= 1<<x;\n\t\t\tC[x] |= 1<<y;\n\t\t}\n\t}\n\tMINUS(memo);\n\tMINUS(memo_all);\n\t\n\tint rm,cm;\n\tll ret=hoge_all(H,W);\n\tFOR(rm,1<<H) FOR(cm,1<<W) if(rm&&cm) {\n\t\tint did=0;\n\t\tFOR(y,H) if((rm&(1<<y)) && (((R[y]&cm)==0)||(~R[y]&cm)==0)) did = 1;\n\t\tFOR(x,W) if((cm&(1<<x)) && (((C[x]&rm)==0)||(~C[x]&rm)==0)) did = 1;\n\t\tif(did==0) ret+=hoge(H-__builtin_popcount(rm),W-__builtin_popcount(cm));\n\t}\n\tcout<<ret%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nint upd(int x){return x + (x >> 31 & MOD);}\nvoid inc(int &a , int b){a = upd(a + b - MOD);}\nint N , M , vr[13] , vc[13]; char arr[13][13];\n\nint f[1 << 10][1 << 10][3] , g[1 << 10][1 << 10][2][3][4];\nbool vf[1 << 10][1 << 10][3] , vg[1 << 10][1 << 10][2][3][4];\n\nint sf(int , int , int);\nint sg(int , int , int , int , int);\n\nbool check(int r , int c){\n\tbool flg = 1;\n\tfor(int i = 0 ; i < N ; ++i) if(r >> i & 1) flg &= (vr[i] & c) != 0 && (vr[i] & c) != c;\n\tfor(int j = 0 ; j < M ; ++j) if(c >> j & 1) flg &= (vc[j] & r) != 0 && (vc[j] & r) != r;\n\treturn flg;\n}\n\nint sf(int a , int b , int c){\n\tif(!a && !b) return 1;\n\tif(!a || !b) return 0;\n\tif(vf[a][b][c]) return f[a][b][c];\n\tvf[a][b][c] = 1; return f[a][b][c] = sg(a , b , 0 , c , 0) + check(a , b);\n}\n\nint sg(int a , int b , int c , int d , int e){\n\tif(c == 2) return e ? sf(a , b , e - 1) : 0;\n\tif(vg[a][b][c][d][e]) return g[a][b][c][d][e];\n\tint &t = g[a][b][c][d][e]; vg[a][b][c][d][e] = 1;\n\tif(c == 0)\n\t\tif(!d) t = sg(a , b , c + 1 , d , e);\n\t\telse for(int s = a ; ; s = (s - 1) & a){inc(t , sg(s , b , c + 1 , d , e | (s != a))); if(!s) break;}\n\telse\n\t\tif(d == 1) t = sg(a , b , c + 1 , d , e);\n\t\telse for(int s = b ; ; s = (s - 1) & b){inc(t , sg(a , s , c + 1 , d , e | (s != b) << 1)); if(!s) break;}\n\treturn t;\n}\n\nint main(){\n\tcin >> N >> M; for(int i = 0 ; i < N ; ++i) for(int j = 0 ; j < M ; ++j) cin >> arr[i][j];\n\tfor(int i = 0 ; i < N ; ++i) for(int j = M - 1 ; ~j ; --j) vr[i] = vr[i] << 1 | (arr[i][j] == '#');\n\tfor(int i = 0 ; i < M ; ++i) for(int j = N - 1 ; ~j ; --j) vc[i] = vc[i] << 1 | (arr[j][i] == '#');\n\tint sum = 0;\n\tfor(int i = 0 ; i < 1 << N ; ++i) for(int j = 0 ; j < 1 << M ; ++j) inc(sum , sf(i , j , 2));\n\tcout << sum; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 15, P = 998244353;\n\nint n, m, r[N], c[N], C[N][N], iC[N][N];\nchar s[N];\nint f[N][N][3], g[N][N][3];\n\nint qpow(int a, int b) {\n\tint s = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) {\n\t\t\ts = 1ll * s * a % P;\n\t\t}\n\t\ta = 1ll * a * a % P;\n\t}\n\treturn s;\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\treadStr(s);\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tr[i] |= (s[j] == '#') << j;\n\t\t\tc[j] |= (s[j] == '#') << i;\n\t\t}\n\t}\n\tfor (int i = 0; i <= std::max(n, m); ++i) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P;\n\t\t}\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tiC[i][j] = qpow(C[i][j], P - 2);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tf[i][m][2] = 1ll * C[n][i] * (1 << (n - i)) % P;\n\t}\n\tint ans = 1 << n;\n\tfor (int i = n; i; --i) {\n\t\tfor (int j = m; j; --j) {\n\t\t\tf[i][j][0] = (f[i][j][1] + f[i][j][2]) % P;\n\t\t\tfor (int k = 1; k < j; ++k) {\n\t\t\t\tg[i][k][1] = (g[i][k][1] + (2ll * f[i][j][2] + f[i][j][1]) * C[j][k]) % P;\n\t\t\t\tg[i][k][2] = (g[i][k][2] + 1ll * f[i][j][2] * C[j][k] % P * ((1 << (j - k)) - 2)) % P;\n\t\t\t}\n\t\t\tans = (ans + 1ll * f[i][j][2] * ((1 << j) - 2)) % P;\n\t\t\tg[i][j][0] = (g[i][j][1] + g[i][j][2]) % P;\n\t\t\tfor (int k = 1; k < i; ++k) {\n\t\t\t\tf[k][j][1] = (f[k][j][1] + (2ll * g[i][j][2] + g[i][j][1]) * C[i][k]) % P;\n\t\t\t\tf[k][j][2] = (f[k][j][2] + 1ll * g[i][j][2] * C[i][k] % P * ((1 << (i - k)) - 2)) % P;\n\t\t\t}\n\t\t\tans = (ans + 1ll * g[i][j][2] * ((1 << i) - 2)) % P;\n\t\t}\n\t}\n\tfor (int i = 1; i < (1 << n); ++i) {\n\t\tfor (int j = 1; j < (1 << m); ++j) {\n\t\t\tint ci = 0, cj = 0;\n\t\t\tbool flag = 1;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tif (i >> k & 1) {\n\t\t\t\t\t++ci;\n\t\t\t\t\tint w = r[k] & j;\n\t\t\t\t\tif (w == 0 || w == j) {\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < m; ++k) {\n\t\t\t\tif (j >> k & 1) {\n\t\t\t\t\t++cj;\n\t\t\t\t\tint w = c[k] & i;\n\t\t\t\t\tif (w == 0 || w == i) {\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tans = (ans + 1ll * (f[ci][cj][0] + g[ci][cj][0]) * iC[n][ci] % P * iC[m][cj]) % P;\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        reverse(small, small + len);\n        memcpy(line + pos, small, len);\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\n\ntemplate<class Mint>\nstruct Comb {\n    int max_n;\n    V<Mint> fact, ifact;\n    Comb(int n) : max_n(n) {\n        fact = ifact = V<Mint>(n + 1);\n        fact[0] = Mint(1);\n        for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; i--) ifact[i - 1] = ifact[i] * i;\n    }\n\n    Mint C(int n, int k) {\n        if (n < k || n < 0) return Mint(0);\n        assert(0 <= k && k <= n && n <= max_n);\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n};\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nusing Mint = ModInt<998244353>;\nComb<Mint> C(100);\nusing K = tuple<int, int, int, int>;\n\nmap<K, Mint> dp;\nMint calc(int n, int m, int a, int b) {\n    if (n == 0 || m == 0) return Mint(1);\n    K k = {n, m, a, b};\n    if (dp.count(k)) return dp[k];\n\n    Mint ans = Mint(0);\n    // w-w, b-b\n    for (int f: {1, 2}) {\n        if ((a & f) && (b & f)) {\n            ans += Mint(1); // all same\n            for (int i = 1; i < n; i++) {\n                for (int j = 1; j < m; j++) {\n                    ans += C.C(n, i) * C.C(m, j) * calc(n - i, m - j, 3^f, 3^f);\n                }\n            }\n        }\n    }\n    for (int ph = 0; ph < 2; ph++) {\n        // w-b\n        if (a == 3) {\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; i + j <= n; j++) {\n                    ans += C.C(n, i) * C.C(n - i, j) * calc(n - i - j, m, 0, 3);\n                }\n            }\n        }\n        // w-., b-.\n        for (int f: {1, 2}) {\n            if (a & f) {\n                for (int i = 1; i < n; i++) {\n                    ans += C.C(n, i) * calc(n - i, m, 0, 3^f);\n                }\n            }\n        }\n        swap(n, m);\n        swap(a, b);\n    }\n    return dp[k] = ans;\n}\n\nMint dpx[100][100];\nbool visx[100][100];\nMint calcx(int a, int b) {\n    if (a == 0 || b == 0) return Mint(1);\n    if (visx[a][b]) return dpx[a][b];\n    visx[a][b] = true;\n    Mint ans = Mint(0);\n    for (int i = 1; i <= a; i++) {\n        ans += C.C(a, i) * calcx(b, a - i);\n    }\n    return dpx[a][b] = ans;\n}\n\nMint calc2(int a, int b) {\n    if (a == 0 || b == 0) return Mint(1);\n    assert(0 <= a && 0 <= b);\n    return calcx(a, b) + calcx(b, a);\n}\n\nint main() {\n    int h, w;\n    sc.read(h, w);\n    V<int> ng(h), rg(w);\n    for (int i = 0; i < h; i++) {\n        string s;\n        sc.read(s);\n        for (int j = 0; j < w; j++) {\n            if (s[j] == '#') {\n                ng[i] |= (1 << j);\n                rg[j] |= (1 << i);\n            }\n        }\n    }\n\n    Mint ans = calc(h, w, 3, 3);\n    VV<int> cnt(h, V<int>(w, 0));\n    for (int f = 1; f < (1 << h); f++) {\n        for (int g = 1; g < (1 << w); g++) {\n            bool ok = true;\n            for (int i = 0; i < h; i++) {\n                if (!(f & (1 << i))) continue;\n                int u = ng[i] & g;\n                if (u == 0 || u == g) {\n                    ok = false;\n                    break;\n                }\n            }\n            for (int i = 0; i < w; i++) {\n                if (!(g & (1 << i))) continue;\n                int u = rg[i] & f;\n                if (u == 0 || u == f) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                int u = popcnt(uint(f)), v = popcnt(uint(g));\n                cnt[h - u][w - v]++;\n                         ;\n            }\n        }\n    }\n            ;\n    for (int r = 0; r < h; r++) {\n        for (int c = 0; c < w; c++) {\n            for (int i = 0; i <= r; i++) {\n                for (int j = 0; j <= c; j++) {\n                    ans += Mint(cnt[r][c]) * C.C(r, i) * C.C(c, j) * calc2(i, c - j) * calc2(r - i, j);\n                }\n            }\n        }\n    }\n    pr.writeln(ans.v);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll four[] = {0, 1, 0, -1, 0};\nconst ll eight[] = {0, 1, 1, 0, -1, -1, 1, -1, 0};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n)-1;i>=0;i--)\n#define rrep2(i,n) for(ll i=(n)-1;i>=0;i--)\n#define rrep3(i,a,b) for(ll i=(b)-1;i>=(a);i--)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto&& i:a)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++) { int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\nvoid err(){ putchar('\\n'); }\ntemplate<class T> void err(const T& t){ print(t); putchar('\\n'); }\ntemplate<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\ntemplate<class... T> void err(const T&...){}\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\nconstexpr uint mod = MODD;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint(){}\n    constexpr Modint(const Modint &x) : num(x.num){}\n    inline constexpr operator ll() const { return num; }\n    inline constexpr Modint& operator+=(Modint x){ num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++(){ if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int){ Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator- () const { return Modint(0) -= *this; }\n    inline constexpr Modint operator- (Modint x) const { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x){ if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--(){ if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int){ Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x){ num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x){ return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x){ x %= T(mod); if(x < 0) x += mod; num = uint(x); }\n    template<class T> inline constexpr Modint operator+(T x) const { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x){ x %= mod; if(x < 0) x += mod; num += x; if(num >= mod) num -= mod; return *this; }\n    template<class T> inline constexpr Modint operator- (T x) const { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x){ return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator* (T x) const { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x){ return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/ (T x) const { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x){ return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) const { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x) { ll a; in(a); x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(n + 1); return fac[n] * inv[n - r]; }\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(n + 1); return fac[n] * inv[r] * inv[n - r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r個をn部屋に分ける\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nsigned main(){\n    LL(h,w);\n    VEC(string,s,h);\n    Modint dp[11][11][3];\n    memset(dp,0x00,sizeof(dp));\n    rep(i,1,11)rep(j,1,11){\n        dp[i][j][0]=2;\n        rep(i2,1,i)rep(j2,1,j)dp[i][j][0]+=dp[i2][j2][0]*comb(i,i2)*comb(j,j2);\n    }\n    rep(i,1,11)rep(j,1,11){\n        if(i>1)dp[i][j][2]=2_M .pow(i)-2;\n        if(j>1)dp[i][j][1]=2_M .pow(j)-2;\n        rep(i2,1,i-1)dp[i][j][2]+=dp[i2][j][1]*comb(i,i2)*(2_M .pow(i-i2)-2);\n        rep(j2,1,j-1)dp[i][j][1]+=dp[i][j2][2]*comb(j,j2)*(2_M .pow(j-j2)-2);\n    }\n    rep(i,1,11)rep(j,1,11)dp[i][j][0]+=dp[i][j][1]+dp[i][j][2];\n    rep(11)dp[i][0][0]=dp[0][i][0]=2_M .pow(i);\n    vector<uint>conflict;\n    rep(h)rep(i2,i+1,h)rep(j,w)if(s[i][j]!=s[i2][j])rep(j2,j+1,w)if(s[i][j]!=s[i][j2]&&s[i2][j]!=s[i2][j2]){\n        conflict.push_back(0);\n        conflict.back()|=1<<i;\n        conflict.back()|=1<<i2;\n        conflict.back()|=1<<(j+10);\n        conflict.back()|=1<<(j2+10);\n    }\n    vec(bool,used,1<<20);\n    Modint ans=dp[h][w][0];\n    used[0]=1;\n    for(uint i=0;i<1<<20;i++)if(used[i])each(j,conflict)if(!used[i|j]){\n        auto k=i|j;\n        used[i|j]=1;\n        ans+=dp[h-__builtin_popcount(k>>10)][w-__builtin_popcount(k<<22)][0];\n    }\n    out(ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int inf=1e9,N=15,mod=998244353;\nint h,w,H,W,xs[N][N],a[N][N],ycl[2000];\nll ans,pw[N],c[N][N];\nchar ch[N][N];\nvector<int> v;\nvoid solve(vector<int> v){\n\tint res[2],re[2]; res[0]=h; res[1]=w; re[0]=H; re[1]=W;\n\tif(!v.size()){\n\t\tans++; return;\n\t}\n\tint ks=v[0]^1;\n\t//cout<<v.size()<<endl;\n\t//for(auto i:v)wri(i); puts(\"nmd\"); \n\treverse(v.begin(),v.end());\n\tll f=0,g=1,ab=1;\n\twhile(v.size()){\n\t\tint cnt=0,dq=v.back();\n\t\twhile(v.size()&&v.back()==dq){\n\t\t\tcnt++; v.pop_back();\n\t\t}\n\t\tab=ab*c[re[dq]][cnt];\n\t\tres[dq]-=cnt; re[dq]-=cnt;\n\t\tll G=f*(res[dq^1]?1:0)+g*(res[dq^1]?pw[cnt]:1),\n\t\tF=f*(res[dq^1]?1:0)+g*(res[dq^1]?2:1); \n\t\tif(!ks)G=(G+mod-F)%mod; else F=ks=0;\n\t\tf=F; g=G;\n\t\t//cerr<<f<<\" \"<<g<<endl;\n\t}// f 分别表示 上次颜色全相同，上次不相同 \n\t//cout<<ab<<\" f:\"<<f<<\" fdas \"<<g<<\" fkjzz\\n\";\n\tans=(ans+ab*(f+g))%mod;\n}\nvoid dfs(int x,int y){\n\tif(!x&&!y){\n\t\tsolve(v); return;\n\t}\n\tif(x){\n\t\tv.pb(0); dfs(x-1,y); v.pop_back();\n\t}\n\tif(y){\n\t\tv.pb(1); dfs(x,y-1); v.pop_back();\n\t}\n\t\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\th=read(),w=read();\n\tFor(i,0,h-1){\n\t\tscanf(\"%s\",ch[i]);\n\t\tFor(j,0,w-1)a[i][j]=ch[i][j]=='.';\n\t}\n\tFor(i,0,N-1)For(j,c[i][0]=1,i)c[i][j]=c[i-1][j-1]+c[i-1][j];\n\tFor(i,1,1023)ycl[i]=ycl[i>>1]+(i&1);\n\tFor(i,pw[0]=1,N-1)pw[i]=pw[i-1]*2;\n\tFor(i,0,(1<<h)-1){\n\t\tFor(j,0,(1<<w)-1){\n\t\t\tint A[N],B[N];\n\t\t\tmem(A); mem(B);\n\t\t\tFor(k,0,h-1)if(i>>k&1){\n\t\t\t\tFor(l,0,w-1)if(j>>l&1){\n\t\t\t\t\tA[k]|=1<<a[k][l];\n\t\t\t\t\tB[l]|=1<<a[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint f=1;\n\t\t\tFor(k,0,h-1)if((i>>k&1)&&A[k]<3)f=0;\n\t\t\tFor(k,0,w-1)if((j>>k&1)&&B[k]<3)f=0;\n\t\t\tif(f)xs[h-ycl[i]][w-ycl[j]]++;\n\t\t}\n\t}\n\tll sum=0;\n\tFor(i,0,h)For(j,0,w)if(xs[i][j]){\n\t\tans=0; H=i; W=j;\n\t\tdfs(i,j);\n\t\tsum=(sum+ans*xs[i][j])%mod;\n\t\t//cout<<i<<\" \"<<j<<\" \"<<xs[i][j]<<\" \"<<ans<<endl;// exit(0);\n\t}\n\tcout<<sum<<endl;\n}\n/*\n对于每一行，考虑上次删了哪些列，剩余的位置相同，那些列不能和我全相同。 \n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define rank rank228\n#define y1 y1228\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define mp make_pair\nusing ll = long long;\nusing ld = long double;\n// const int MAXMEM = 200 * 1000 * 1024;\n// char _memory[MAXMEM];\n// size_t _ptr = 0;\n// void* operator new(size_t _x) { _ptr += _x; return _memory + _ptr - _x; }\n// void operator delete (void*) noexcept {}\nconst string FILENAME = \"input\";\nconst int Mod = 998244353;\nconst int MAXN = 10;\nconst int MAXM = 1 << MAXN;\n\nint h, w;\nstring s[MAXN];\n \n\nint summ(int a, int b) {\n    int res = a + (b < 0 ? b + Mod: b);\n    return (res >= Mod ? res - Mod: res);\n}\n\n\nint col[MAXN][MAXN];\nint dp[MAXM][MAXM];\nint keks[MAXM * MAXM][2 * MAXN + 1];\n \n\nbool check(int m0, int m1) {\n    vector<int> rc(MAXN, 0), cc(MAXN, 0);\n    for (int y = 0; y < MAXN; y++) {\n        if (!(m0 & (1 << y))) {\n            rc[y] = 3;\n        }\n    }\n    for (int x = 0; x < MAXN; x++) {\n        if (!(m1 & (1 << x))) {\n            cc[x] = 3;\n        }\n    }\n    for (int y = 0; y < MAXN; y++) {\n        if (!(m0 & (1 << y))) {\n            continue;\n        }\n        for (int x = 0; x < MAXN; x++) {\n            if (!(m1 & (1 << x))) {\n                continue;\n            }\n            rc[y] |= col[y][x];\n            cc[x] |= col[y][x];\n        }\n    }\n    bool works = true;\n    for (auto v: rc) {\n        works &= (v == 3);\n    }\n    for (auto v: cc) {\n        works &= (v == 3);\n    }\n    return works;\n}\n \n\nint keksum(int m0, int m1) {\n    int m = m0 | (m1 << MAXN);\n    keks[m][2 * MAXN] = dp[m0][m1];\n    for (int j = 2 * MAXN - 1; j >= 0; j--) {\n        if (m & (1 << j)) {\n            keks[m][j] =    summ(keks[m][j + 1], -keks[m ^ (1 << j)][j + 1]);\n        } else {\n            keks[m][j] = keks[m][j + 1];\n        }\n    }\n    return keks[m][0];\n}\n\n\nvoid setdp(int m0, int m1, int val) {\n    dp[m0][m1] = val;\n    keksum(m0, m1);\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);     \n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> s[i];\n    }\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            col[i][j] = 1 + (s[i][j] == '#');\n        }\n    }\n    int h0 = 1 << h;\n    int h1 = 1 << w;\n    for (int m0 = 0; m0 < h0; m0++) {\n        setdp(m0, 0, 1);\n    }\n    for (int m1 = 0; m1 < h1; m1++) {\n        setdp(0, m1, 1);\n    }\n    for (int m0 = 0; m0 < h0; m0++) {\n        int rc = __builtin_popcount(m0);\n        if (rc == 0) {\n            continue;\n        }\n        for (int m1 = 0; m1 < h1; m1++) {\n            int cc = __builtin_popcount(m1);\n            if (cc == 0) {\n                continue;\n            }\n            int res = check(m0, m1);\n            for (int s0 = m0; ; s0 = (s0 - 1) & m0) {\n                int pw = rc - __builtin_popcount(s0);\n                if (pw > 1) {\n                    ll mult = (ll)(pw & 1 ? 1: Mod - 1) * ((1 << pw) - 2) % Mod;\n                    res = (res + (ll)mult * dp[s0][m1]) % Mod;\n                }\n                if (s0 == 0) {\n                    break;\n                }\n            }\n            for (int s1 = m1; ; s1 = (s1 - 1) & m1) {\n                int pw = cc - __builtin_popcount(s1);\n                if (pw > 1) {\n                    ll mult = (ll)(pw & 1 ? 1: Mod - 1) * ((1 << pw) - 2) % Mod;\n                    res = (res + (ll)mult * dp[m0][s1]) % Mod;\n                }\n                if (s1 == 0) {\n                    break;\n                }\n            }\n            int add = Mod - keksum(m0, m1);\n            add = summ(add, add);\n            res = summ(res, add);\n            setdp(m0, m1, res);\n        }\n    }\n    cout << dp[h0 - 1][h1 - 1] << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1<<20|3,mo=998244353;\nint n,m,a[26][26],f[26][26],g[26][26],C[26][26],p[26],q[26],fac[N],ifac[N];\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline void sub(int &x, int y){x=x-y>=0?x-y:x-y+mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nvoid iniC(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);\n\tper(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\nint dfs(int dep, int lim, int n, int m){\n\tif(dep>n){\n\t\tint res=1ll*fac[n]*fac[m]%mo;\n\t\trep(i,1,n){\n\t\t\tint j=i;while(j+1<=n&&p[j+1]==p[i])j++;\n\t\t\tres=1ll*res*ifac[j-i+1]%mo;i=j;\n\t\t}\n\t\tmemset(q,0,sizeof(q));\n\t\trep(i,1,n)q[p[i]]++;\n\t\tper(i,m,1)q[i]+=q[i+1];\n\t\trep(i,1,m){\n\t\t\tint j=i;while(j+1<=m&&q[j+1]==q[i])j++;\n\t\t\tres=1ll*res*ifac[j-i+1]%mo;i=j;\n\t\t}\n\t\treturn res;\n\t}\n\tint res=0;\n\twhile(lim>=0){\n\t\tp[dep]=lim;add(res,dfs(dep+1,lim,n,m));lim--;\n\t}\n\treturn res;\n}\nint solve(int n, int m){\n\treturn dfs(1,m,n,m);\n}\nbool gg1[16][1<<10|3],gg2[16][1<<10|3];\nbool ck(int s, int t){\n\trep(i,1,n)if((s>>i-1&1)&&gg1[i][t])return 0;\n\trep(i,1,m)if((t>>i-1&1)&&gg2[i][s])return 0;\n\treturn 1;\n}\nint main() {\n\tiniC(20);\n\trep(i,0,20){\n\t\tC[i][0]=C[i][i]=1;\n\t\trep(j,1,i-1)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\n\tn=10;m=10;\n\trep(i,0,10)rep(j,0,10)f[i][j]=solve(i,j);\n\trep(i,1,10)rep(j,1,10)rep(x,0,i)rep(y,0,j)\n\t\tg[i][j]=(g[i][j]+1ll*C[i][x]*C[j][y]%mo*f[x][j-y]%mo*f[i-x][y])%mo;\n\tg[0][0]=1;\n\t\t\n\tread(n);read(m);rep(i,1,n){\n\t\tchar S[27];scanf(\"%s\",S+1);rep(j,1,m)a[i][j]=S[j]=='#';\n\t}\n\trep(i,1,n)rep(t,1,(1<<m)-1){\n\t\tint tot=0,cur=0;\n\t\trep(j,1,m)if(t>>j-1&1)tot++,cur+=a[i][j];\n\t\tgg1[i][t]=tot==cur||0==cur;\n\t}\n\trep(j,1,m)rep(s,1,(1<<n)-1){\n\t\tint tot=0,cur=0;\n\t\trep(i,1,n)if(s>>i-1&1)tot++,cur+=a[i][j];\n\t\tgg2[j][s]=tot==cur||0==cur;\n\t}\n//\trep(i,1,n)rep(j,1,m)printf(\"%d %d:%d\\n\",i,j,f[i][j]);\n//\tprintf(\"qwq %d %d\\n\",gg1[1][3],gg2[2][3]);\n\tint res=f[n][m];\n\trep(s,1,(1<<n)-1)rep(t,1,(1<<m)-1)if(ck(s,t)){\n\t\tprintf(\"%d %d\\n\",s,t);\n\t\tint x=n;rep(i,0,n-1)x-=s>>i&1;\n\t\tint y=m;rep(i,0,m-1)y-=t>>i&1;\n\t\t\n\t\tif(!x&&!y)add(res,1);\n\t\telse if(!x)add(res,power(2,y));\n\t\telse if(!y)add(res,power(2,x));\n\t\telse add(res,g[x][y]);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int mod=998244353;\ninline int ad(int x){return x>=mod?x-mod:x;}\ninline int dec(int x){return x<0?x+mod:x;}\nchar ss[15];\nint n,m,a[15][15],row[15],col[15];\ninline bool pd(int x,int y)\n{\n\tif(x==0 && y==0)return true;\n\tif(x==0 || y==0)return false;\n\tfor(int i=0;i<n;i++)if((row[i]&y)==y || (row[i]&y)==0)return false;\n\tfor(int i=0;i<m;i++)if((col[i]&x)==x || (col[i]&x)==0)return false;\n\treturn true;\n}\nint C[15][15],f[15][15][3],g[15][15][3];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tfor(int i=0;i<=10;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)C[i][j]=ad(C[i-1][j]+C[i-1][j-1]);\n\t}\n\tn=read(),m=read();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%s\",ss);\n\t\tfor(int j=0;j<m;j++)a[i][j]=ss[j]=='.';\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)row[i]+=a[i][j]<<j;\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)col[i]+=a[j][i]<<j;\n\t}\n\tfor(int i=0;i<m;i++)f[0][i][2]=1<<i;\n\tf[n][m][0]=1<<m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tfor(int k=1;k<n-i;k++)\n\t\t\t{\n\t\t\t\tg[i+k][j][1]=ad(g[i+k][j][1]+1LL*ad(f[i][j][1]+ad(f[i][j][2]*2))*C[k+i][i]%mod);\n\t\t\t\tg[i+k][j][2]=ad(g[i+k][j][2]+1LL*f[i][j][2]*dec((1<<k)-2)%mod*C[k+i][i]%mod);\n\t\t\t}\n\t\t\tg[n][m][0]=ad(g[n][m][0]+1LL*f[i][j][2]*dec((1<<(n-i))-2)%mod*C[n][i]%mod*C[m][j]%mod);\n\t\t\tfor(int k=1;k<m-j;k++)\n\t\t\t{\n\t\t\t\tf[i][j+k][1]=ad(f[i][j+k][1]+1LL*ad(g[i][j][1]+ad(g[i][j][2]*2))*C[k+j][j]%mod);\n\t\t\t\tf[i][j+k][2]=ad(f[i][j+k][2]+1LL*g[i][j][2]*dec((1<<k)-2)%mod*C[k+j][j]%mod);\n\t\t\t}\n\t\t\tf[n][m][0]=ad(f[n][m][0]+1LL*g[i][j][2]*dec((1<<(m-j))-2)%mod*C[m][j]%mod*C[n][i]%mod);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t{\n\t\tfor(int j=0;j<(1<<m);j++)\n\t\t{\n\t\t\tif(pd(i,j)==false)continue;\n\t\t\tint x=n,y=m;\n\t\t\tfor(int k=0;k<n;k++)if(i>>k&1)x--;\n\t\t\tfor(int k=0;k<m;k++)if(j>>k&1)y--;\n\t\t\tfor(int k=0;k<3;k++)ans=ad(ans+ad(f[x][y][k]+g[x][y][k]));\n\t\t}\n\t}pr2(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        reverse(small, small + len);\n        memcpy(line + pos, small, len);\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\n\ntemplate<class Mint>\nstruct Comb {\n    int max_n;\n    V<Mint> fact, ifact;\n    Comb(int n) : max_n(n) {\n        fact = ifact = V<Mint>(n + 1);\n        fact[0] = Mint(1);\n        for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; i--) ifact[i - 1] = ifact[i] * i;\n    }\n\n    Mint C(int n, int k) {\n        if (n < k || n < 0) return Mint(0);\n        assert(0 <= k && k <= n && n <= max_n);\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n};\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nusing Mint = ModInt<998244353>;\nComb<Mint> C(100);\nusing K = tuple<int, int, int, int>;\n\nmap<K, Mint> dp;\nMint calc(int n, int m, int a, int b) {\n    if (n == 0 || m == 0) return Mint(1);\n    K k = K{n, m, a, b};\n    if (dp.count(k)) return dp[k];\n\n    Mint ans = Mint(0);\n    // w-w, b-b\n    for (int f: {1, 2}) {\n        if ((a & f) && (b & f)) {\n            ans += Mint(1); // all same\n            for (int i = 1; i < n; i++) {\n                for (int j = 1; j < m; j++) {\n                    ans += C.C(n, i) * C.C(m, j) * calc(n - i, m - j, 3^f, 3^f);\n                }\n            }\n        }\n    }\n    for (int ph = 0; ph < 2; ph++) {\n        // w-b\n        if (a == 3) {\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; i + j <= n; j++) {\n                    ans += C.C(n, i) * C.C(n - i, j) * calc(n - i - j, m, 0, 3);\n                }\n            }\n        }\n        // w-., b-.\n        for (int f: {1, 2}) {\n            if (a & f) {\n                for (int i = 1; i < n; i++) {\n                    ans += C.C(n, i) * calc(n - i, m, 0, 3^f);\n                }\n            }\n        }\n        swap(n, m);\n        swap(a, b);\n    }\n    return dp[k] = ans;\n}\n\nMint dpx[100][100];\nbool visx[100][100];\nMint calcx(int a, int b) {\n    if (a == 0 || b == 0) return Mint(1);\n    if (visx[a][b]) return dpx[a][b];\n    visx[a][b] = true;\n    Mint ans = Mint(0);\n    for (int i = 1; i <= a; i++) {\n        ans += C.C(a, i) * calcx(b, a - i);\n    }\n    return dpx[a][b] = ans;\n}\n\nMint calc2(int a, int b) {\n    if (a == 0 || b == 0) return Mint(1);\n    assert(0 <= a && 0 <= b);\n    return calcx(a, b) + calcx(b, a);\n}\n\nint main() {\n    int h, w;\n    sc.read(h, w);\n    V<int> ng(h), rg(w);\n    for (int i = 0; i < h; i++) {\n        string s;\n        sc.read(s);\n        for (int j = 0; j < w; j++) {\n            if (s[j] == '#') {\n                ng[i] |= (1 << j);\n                rg[j] |= (1 << i);\n            }\n        }\n    }\n\n    Mint ans = calc(h, w, 3, 3);\n    VV<int> cnt(h, V<int>(w, 0));\n    for (int f = 1; f < (1 << h); f++) {\n        for (int g = 1; g < (1 << w); g++) {\n            bool ok = true;\n            for (int i = 0; i < h; i++) {\n                if (!(f & (1 << i))) continue;\n                int u = ng[i] & g;\n                if (u == 0 || u == g) {\n                    ok = false;\n                    break;\n                }\n            }\n            for (int i = 0; i < w; i++) {\n                if (!(g & (1 << i))) continue;\n                int u = rg[i] & f;\n                if (u == 0 || u == f) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                int u = popcnt(uint(f)), v = popcnt(uint(g));\n                cnt[h - u][w - v]++;\n                         ;\n            }\n        }\n    }\n            ;\n    for (int r = 0; r < h; r++) {\n        for (int c = 0; c < w; c++) {\n            for (int i = 0; i <= r; i++) {\n                for (int j = 0; j <= c; j++) {\n                    ans += Mint(cnt[r][c]) * C.C(r, i) * C.C(c, j) * calc2(i, c - j) * calc2(r - i, j);\n                }\n            }\n        }\n    }\n    pr.writeln(ans.v);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=15;\nconst int MOD=998244353;\nint n,m;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac[N],inv[N];\nlong long Pw[N];\nvoid init(int n=10)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\tPw[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tPw[i]=Pw[i-1]*2%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nint r[N],c[N];\nchar s[N][N];\nlong long f[N][N][3],g[N][N][3];\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%s\",s[i]);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\t if(s[i][j]=='.') r[i]|=1<<j,c[j]|=1<<i;\n\tfor(int j=1;j<=m;j++)\n\t\tg[n][j][2]=C(m,j)*Pw[m-j]%MOD;\n\tlong long ans=Pw[m];\n\tfor(int i=n;i>=1;i--)\n\t\tfor(int j=m;j>=1;j--)\n\t\t{\n\t\t\tg[i][j][0]=(g[i][j][1]+g[i][j][2])%MOD;\n\t\t\tfor(int k=1;k<i;k++)\n\t\t\t{\n\t\t\t\tint d=i-k;\n\t\t\t\tf[k][j][1]=(f[k][j][1]+C(i,d)*(g[i][j][2]*2+g[i][j][1])%MOD)%MOD;\n\t\t\t\tf[k][j][2]=(f[k][j][2]+C(i,d)*(Pw[d]-2)%MOD*g[i][j][2]%MOD)%MOD;\n\t\t\t}\n\t\t\tans=(ans+g[i][j][2]*(Pw[i]-2)%MOD)%MOD;\n\t\t\tf[i][j][0]=(f[i][j][1]+f[i][j][2])%MOD;\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t{\n\t\t\t\tint d=j-k;\n\t\t\t\tg[i][k][1]=(g[i][k][1]+C(j,d)*(f[i][j][2]*2+f[i][j][1])%MOD)%MOD;\n\t\t\t\tg[i][k][2]=(g[i][k][2]+C(j,d)*(Pw[d]-2)%MOD*f[i][j][2]%MOD)%MOD;\n\t\t\t}\n\t\t\tans=(ans+f[i][j][2]*(Pw[j]-2)%MOD)%MOD;\n\t\t}\n\tfor(int i=1;i<(1<<n);i++)\n\t\tfor(int j=1;j<(1<<m);j++)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\tif(i&(1<<k))\n\t\t\t\t{\n\t\t\t\t\tint w=r[k]&j;\n\t\t\t\t\tif(w==j||w==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tfor(int k=0;k<m;k++)\n\t\t\t\tif(j&(1<<k))\n\t\t\t\t{\n\t\t\t\t\tint w=c[k]&i;\n\t\t\t\t\tif(w==i||w==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tint x=__builtin_popcount(i),y=__builtin_popcount(j);\n\t\t\tans=(ans+(f[x][y][0]+g[x][y][0])%MOD*ksm(C(n,x),MOD-2)%MOD*ksm(C(m,y),MOD-2)%MOD)%MOD;\n\t\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\n\n\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\n\nll dp[30][30][30],dp2[30][30],dp3[30][30][30][30][30],dp4[30][30];\nint r[13], c[13];\n\nint main(){\n    int h,w;\n    cin>>h>>w;\n    mod_build();\n    int N = 13;\n    rep(i,N+1)rep(j,N+1)dp[i][j][0]=1;\n    rep(i,N+1)rep(j,N+1)rep(k,N)REP(ni,i+1,N+1)REP(nk,k+1,N+1){\n        dp[ni][j][nk]+=dp[i][j][k]*comb(ni,i)%mod*comb(j-k,nk-k)%mod;\n        dp[ni][j][nk]%=mod;\n    }\n    rep(i,N+1)rep(j,N+1)rep(k,N+1)dp2[i][j]+=dp[i][j][k];\n    rep(i,N+1)rep(j,N+1){\n        dp3[i][j][0][0][0]+=1;\n        dp3[i][j][0][0][j]+=(1<<i)-1;\n    }\n    rep(i,N+1)rep(j,N+1)rep(s,N+1)rep(k,j+1)rep(l,j-k+1)REP(ni,i+1,N+1)REP(nk,s+1,N+1){\n        if(l==0){\n            if(nk+l<=j)(dp3[ni][j][nk][nk][l]+=dp3[i][j][s][k][l]*comb(ni,i)%mod*comb(j-s,nk-s)%mod)%=mod;\n            if(nk<=j && k+j-nk<=j)(dp3[ni][j][nk][k][j-nk]+=dp3[i][j][s][k][l]*comb(ni,i)%mod*comb(j-s,nk-s)%mod)%=mod;\n            if(nk<=j)(dp3[ni][j][nk][nk][j-nk]+=dp3[i][j][s][k][l]*comb(ni,i)%mod*comb(j-s,nk-s)%mod*((1<<(ni-i))-2)%mod)%=mod;\n        }\n        else {\n            (dp3[ni][j][nk][k][l]+=dp3[i][j][s][k][l]*comb(ni,i)%mod*comb(j-s,nk-s)%mod)%=mod;\n        }\n    }\n    rep(i,N+1)rep(j,N+1)rep(s,N+1)rep(k,N+1)rep(l,N+1){\n        if(k+l<=j)dp4[i][j]+=dp3[i][j][s][k][l]*(1<<(j-k-l))%mod;\n        dp4[i][j]%=mod;\n    }\n    string s[h];\n    rep(i,h)cin>>s[i];\n    rep(i,h){\n        rep(j,w)if(s[i][j]=='#')c[i]|=(1<<j);\n    }\n    rep(j,w){\n        rep(i,h)if(s[i][j]=='#')r[j]|=(1<<i);\n    }\n    int hh = 1<<h, ww = 1<<w;\n    ll ans = 0;\n    rep(mi,hh)rep(mj,ww){\n        int ci = h-__builtin_popcount(mi);\n        int cj = w-__builtin_popcount(mj);\n        bool ok = true;\n        rep(i,h){\n            if(((1<<i)&mi)==0)continue;\n            if((c[i] & mj)==0||(c[i] & mj)==mj){\n                ok=false;\n            }\n        }\n        rep(j,w){\n            if(((1<<j)&mj)==0)continue;\n            if((r[j] & mi)==0||(r[j] & mi)==mi){\n                ok=false;\n            }\n        }\n        if(ok){\n            if(mi || mj){\n                ans += dp4[ci][cj];\n            }\n            else ans += dp2[ci][cj];\n        }\n    }\n    cout<<ans%mod<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = fact[1] = 1;\n    for(int i=2; i<=num; i++) fact[i] = fact[i-1] * i % MOD;\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = seq_inv[1] = 1;\n    for(int i=2; i<=num; i++) seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(int i=2; i<=num; i++) fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nint nth_bit(int64_t num, int n){\n    return (num >> n) & 1;\n}\n\nint main(){\n    int H, W;\n    cin >> H >> W;\n    bitset<10> S[10];\n    for(int i=0; i<H; i++){\n        string s;\n        cin >> s;\n        for(int j=0; j<W; j++) S[i][j] = (s[j] == '.');\n    }\n    create_mod_tables(100);\n\n    static int64_t Y[11][11][3], Ysum[11][11];\n    Y[0][0][2] = 1;\n    for(int i=0; i<=10; i++) for(int j=0; j<=10; j++){\n        for(int k=0; k<3; k++){\n            add(Ysum[i][j], Y[i][j][k]);\n            if(k != 0) for(int x=1; i+x<=10; x++) add(Y[i+x][j][0], Y[i][j][k] * fact_inv[x]);\n            if(k != 1) for(int x=1; j+x<=10; x++) add(Y[i][j+x][1], Y[i][j][k] * fact_inv[x]);\n        }\n        mul(Ysum[i][j], fact[i] * fact[j] % MOD);\n    }\n\n    static int64_t Lparts[11][11];\n    for(int x=0; x<H; x++) for(int y=0; y<W; y++){\n        for(int x1=0; x1<=x; x1++) for(int y1=0; y1<=y; y1++){\n            int64_t res = comb_mod(x, x1) * comb_mod(y, y1) % MOD;\n            mul(res, Ysum[x1][y1]);\n            mul(res, Ysum[x-x1][y-y1]);\n            add(Lparts[x][y], res);\n        }\n    }\n\n    int64_t ans = Ysum[H][W];\n    for(int b1=0; b1<(1<<H); b1++) for(int b2=0; b2<(1<<W); b2++){\n        if(b1 == 0 && b2 == 0) continue;\n        vector<int> is, js;\n        for(int i=0; i<H; i++) if(nth_bit(b1, i)) is.push_back(i);\n        for(int j=0; j<W; j++) if(nth_bit(b2, j)) js.push_back(j);\n        int isz = is.size(), jsz = js.size();\n        bool ok = true;\n        for(int i : is){\n            int sum = 0;\n            for(int j : js) sum += S[i][j];\n            if(sum == 0 || sum == jsz) ok = false;\n        }\n        for(int j : js){\n            int sum = 0;\n            for(int i : is) sum += S[i][j];\n            if(sum == 0 || sum == isz) ok = false;\n        }\n        if(ok) add(ans, Lparts[H-isz][W-jsz]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define MD (998244353U)\nvoid *wmem;\nchar memarr[96000000];\ntemplate<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){\n  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\ntemplate<class T> inline void walloc2d(T ***arr, int x, int y, void **mem = &wmem){\n  int i;\n  walloc1d(arr, x, mem);\n  for(i=(0);i<(x);i++){\n    walloc1d(&((*arr)[i]), y, mem);\n  }\n}\nstruct Modint{\n  unsigned val;\n  Modint(){\n    val=0;\n  }\n  Modint(int a){\n    val = ord(a);\n  }\n  Modint(unsigned a){\n    val = ord(a);\n  }\n  Modint(long long a){\n    val = ord(a);\n  }\n  Modint(unsigned long long a){\n    val = ord(a);\n  }\n  inline unsigned ord(unsigned a){\n    return a%MD;\n  }\n  inline unsigned ord(int a){\n    a %= (int)MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned ord(unsigned long long a){\n    return a%MD;\n  }\n  inline unsigned ord(long long a){\n    a %= (int)MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned get(){\n    return val;\n  }\n  inline Modint &operator+=(Modint a){\n    val += a.val;\n    if(val >= MD){\n      val -= MD;\n    }\n    return *this;\n  }\n  inline Modint &operator-=(Modint a){\n    if(val < a.val){\n      val = val + MD - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  inline Modint &operator*=(Modint a){\n    val = ((unsigned long long)val*a.val)%MD;\n    return *this;\n  }\n  inline Modint &operator/=(Modint a){\n    return *this *= a.inverse();\n  }\n  inline Modint operator+(Modint a){\n    return Modint(*this)+=a;\n  }\n  inline Modint operator-(Modint a){\n    return Modint(*this)-=a;\n  }\n  inline Modint operator*(Modint a){\n    return Modint(*this)*=a;\n  }\n  inline Modint operator/(Modint a){\n    return Modint(*this)/=a;\n  }\n  inline Modint operator+(int a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(int a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(int a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(int a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator+(long long a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(long long a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(long long a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(long long a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator-(void){\n    Modint res;\n    if(val){\n      res.val=MD-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  inline operator bool(void){\n    return val!=0;\n  }\n  inline operator int(void){\n    return get();\n  }\n  inline operator long long(void){\n    return get();\n  }\n  inline Modint inverse(){\n    int a = val;\n    int b = MD;\n    int u = 1;\n    int v = 0;\n    int t;\n    Modint res;\n    while(b){\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    if(u < 0){\n      u += MD;\n    }\n    res.val = u;\n    return res;\n  }\n  inline Modint pw(unsigned long long b){\n    Modint a(*this);\n    Modint res;\n    res.val = 1;\n    while(b){\n      if(b&1){\n        res *= a;\n      }\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n  inline bool operator==(int a){\n    return ord(a)==val;\n  }\n  inline bool operator!=(int a){\n    return ord(a)!=val;\n  }\n}\n;\ninline Modint operator+(int a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(int a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(int a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(int a, Modint b){\n  return Modint(a)/=b;\n}\ninline Modint operator+(long long a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(long long a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(long long a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(long long a, Modint b){\n  return Modint(a)/=b;\n}\ninline void rd(int &x){\n  int k;\n  int m=0;\n  x=0;\n  for(;;){\n    k = getchar_unlocked();\n    if(k=='-'){\n      m=1;\n      break;\n    }\n    if('0'<=k&&k<='9'){\n      x=k-'0';\n      break;\n    }\n  }\n  for(;;){\n    k = getchar_unlocked();\n    if(k<'0'||k>'9'){\n      break;\n    }\n    x=x*10+k-'0';\n  }\n  if(m){\n    x=-x;\n  }\n}\ninline void rd(char &c){\n  int i;\n  for(;;){\n    i = getchar_unlocked();\n    if(i!=' '&&i!='\\n'&&i!='\\r'&&i!='\\t'&&i!=EOF){\n      break;\n    }\n  }\n  c = i;\n}\ninline int rd(char c[]){\n  int i;\n  int sz = 0;\n  for(;;){\n    i = getchar_unlocked();\n    if(i!=' '&&i!='\\n'&&i!='\\r'&&i!='\\t'&&i!=EOF){\n      break;\n    }\n  }\n  c[sz++] = i;\n  for(;;){\n    i = getchar_unlocked();\n    if(i==' '||i=='\\n'||i=='\\r'||i=='\\t'||i==EOF){\n      break;\n    }\n    c[sz++] = i;\n  }\n  c[sz]='\\0';\n  return sz;\n}\ninline void wt_L(char a){\n  putchar_unlocked(a);\n}\ninline void wt_L(int x){\n  int s=0;\n  int m=0;\n  char f[10];\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    putchar_unlocked('-');\n  }\n  while(s--){\n    putchar_unlocked(f[s]+'0');\n  }\n}\ninline void wt_L(Modint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\ntemplate<class S, class T> inline S chmax(S &a, T b){\n  if(a<b){\n    a=b;\n  }\n  return a;\n}\ntemplate<class T> struct Comb{\n  int mem_fact;\n  T *factri;\n  T *ifactri;\n  Comb(){\n    mem_fact = 0;\n  }\n  inline void expand_fact(int k){\n    if(k <= mem_fact){\n      return;\n    }\n    chmax(k, 2* mem_fact);\n    if(mem_fact == 0){\n      int i;\n      factri = (T*)malloc(k * sizeof(T));\n      ifactri = (T*)malloc(k * sizeof(T));\n      factri[0] = 1;\n      for(i=(1);i<(k);i++){\n        factri[i] = i * factri[i-1];\n      }\n      ifactri[k-1] = 1 / factri[k-1];\n      for(i=(k-1)-1;i>=(0);i--){\n        ifactri[i] = (i+1) * ifactri[i+1];\n      }\n    }\n    else{\n      int i;\n      factri = (T*)realloc(factri, k * sizeof(T));\n      ifactri = (T*)realloc(ifactri, k * sizeof(T));\n      for(i=(mem_fact);i<(k);i++){\n        factri[i] = i * factri[i-1];\n      }\n      ifactri[k-1] = 1 / factri[k-1];\n      for(i=(k-1)-1;i>=(mem_fact);i--){\n        ifactri[i] = (i+1) * ifactri[i+1];\n      }\n    }\n    mem_fact = k;\n  }\n  inline T fac(int k){\n    if(mem_fact < k+1){\n      expand_fact(k+1);\n    }\n    return factri[k];\n  }\n  inline T ifac(int k){\n    if(mem_fact < k+1){\n      expand_fact(k+1);\n    }\n    return ifactri[k];\n  }\n  inline T C(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    if(mem_fact < a+1){\n      expand_fact(a+1);\n    }\n    return factri[a] * ifactri[b] * ifactri[a-b];\n  }\n  inline T P(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    if(mem_fact < a+1){\n      expand_fact(a+1);\n    }\n    return factri[a] * ifactri[a-b];\n  }\n  inline T H(int a, int b){\n    if(a==0 && b==0){\n      return 1;\n    }\n    if(a <= 0 || b < 0){\n      return 0;\n    }\n    if(mem_fact < a+b){\n      expand_fact(a+b);\n    }\n    return C(a+b-1, b);\n  }\n  inline T Multinomial(int sz, int a[]){\n    int i;\n    int s = 0;\n    T res;\n    for(i=(0);i<(sz);i++){\n      s += a[i];\n    }\n    if(mem_fact < s+1){\n      expand_fact(s+1);\n    }\n    res = factri[s];\n    for(i=(0);i<(sz);i++){\n      res *= ifactri[a[i]];\n    }\n    return 1;\n  }\n  inline T Multinomial(int a){\n    return 1;\n  }\n  inline T Multinomial(int a, int b){\n    if(mem_fact < a+b+1){\n      expand_fact(a+b+1);\n    }\n    return factri[a+b] * ifactri[a] * ifactri[b];\n  }\n  inline T Multinomial(int a, int b, int c){\n    if(mem_fact < a+b+c+1){\n      expand_fact(a+b+c+1);\n    }\n    return factri[a+b+c] * ifactri[a] * ifactri[b] * ifactri[c];\n  }\n  inline T Multinomial(int a, int b, int c, int d){\n    if(mem_fact < a+b+c+d+1){\n      expand_fact(a+b+c+d+1);\n    }\n    return factri[a+b+c+d] * ifactri[a] * ifactri[b] * ifactri[c] * ifactri[d];\n  }\n  inline T Catalan(int n){\n    if(n < 0){\n      return 0;\n    }\n    if(mem_fact < 2*n+1){\n      expand_fact(2*n+1);\n    }\n    return factri[2*n] * ifactri[n] * ifactri[n+1];\n  }\n  inline T C_s(long long a, long long b){\n    long long i;\n    T res;\n    if(b < 0 || b > a){\n      return 0;\n    }\n    if(b > a - b){\n      b = a - b;\n    }\n    res = 1;\n    for(i=(0);i<(b);i++){\n      res *= a - i;\n      res /= i + 1;\n    }\n    return res;\n  }\n  inline T P_s(long long a, long long b){\n    long long i;\n    T res;\n    if(b < 0 || b > a){\n      return 0;\n    }\n    res = 1;\n    for(i=(0);i<(b);i++){\n      res *= a - i;\n    }\n    return res;\n  }\n  inline T per_s(long long n, long long k){\n    T d;\n    int m;\n    if(n < 0 || k < 0){\n      return 0;\n    }\n    if(n == k  &&  k == 0){\n      return 1;\n    }\n    if(n == 0 || k == 0){\n      return 0;\n    }\n    if(k==1){\n      return 1;\n    }\n    if(k==2){\n      d = n / 2;\n      return d;\n    }\n    if(k==3){\n      d = (n-1) / 6;\n      m = (n-1) % 6;\n      if(m==0){\n        return 3 * d * d + d;\n      }\n      if(m==1){\n        return 3 * d * d + 2 * d;\n      }\n      if(m==2){\n        return 3 * d * d + 3 * d + 1;\n      }\n      if(m==3){\n        return 3 * d * d + 4 * d + 1;\n      }\n      if(m==4){\n        return 3 * d * d + 5 * d + 2;\n      }\n      if(m==5){\n        return 3 * d * d + 6 * d + 3;\n      }\n    }\n    assert(0 && \"per_s should be k <= 3\");\n    return -1;\n  }\n}\n;\nint X;\nint Y;\nchar A[10][12];\nModint st[20][20];\nModint pb[20][20];\nModint pbm[20][20];\nset<long long> s;\nvoid brute(long long mask){\n  int i, j;\n  if(s.count(mask)){\n    return;\n  }\n  s.insert(mask);\n  for(i=(0);i<(X-1);i++){\n    int j;\n    long long mp = mask;\n    for(j=(0);j<(Y);j++){\n      if(mp & (1<<(i*Y+j))){\n        mp ^= (1<<(i*Y+j));\n      }\n    }\n    brute(mp);\n  }\n  for(j=(0);j<(Y-1);j++){\n    long long mp = mask;\n    for(i=(0);i<(X);i++){\n      if(mp & (1<<(i*Y+j))){\n        mp ^= (1<<(i*Y+j));\n      }\n    }\n    brute(mp);\n  }\n  for(i=(0);i<(X-1);i++){\n    long long mp = mask;\n    for(j=(0);j<(Y);j++){\n      if(!(mp & (1<<(i*Y+j)))){\n        mp ^= (1<<(i*Y+j));\n      }\n    }\n    brute(mp);\n  }\n  for(j=(0);j<(Y-1);j++){\n    long long mp = mask;\n    for(i=(0);i<(X);i++){\n      if(!(mp & (1<<(i*Y+j)))){\n        mp ^= (1<<(i*Y+j));\n      }\n    }\n    brute(mp);\n  }\n}\nint canmake(char **mp){\n  int i, j;\n  int r[10] = {};\n  int c[10] = {};\n  for(;;){\n    int i, j;\n    int a[3];\n    int fg = 0;\n    for(i=(0);i<(X);i++){\n      if(r[i]==0){\n        int j;\n        a[0] = a[1] = a[2] = 0;\n        for(j=(0);j<(Y);j++){\n          a[mp[i][j]] = 1;\n        }\n        if(a[0]==0 || a[1]==0){\n          r[i] = 1;\n          fg++;\n          for(j=(0);j<(Y);j++){\n            mp[i][j] = 2;\n          }\n        }\n      }\n    }\n    for(j=(0);j<(Y);j++){\n      if(c[j]==0){\n        a[0] = a[1] = a[2] = 0;\n        for(i=(0);i<(X);i++){\n          a[mp[i][j]] = 1;\n        }\n        if(a[0]==0 || a[1]==0){\n          c[j] = 1;\n          fg++;\n          for(i=(0);i<(X);i++){\n            mp[i][j] = 2;\n          }\n        }\n      }\n    }\n    if(fg==0){\n      break;\n    }\n  }\n  for(i=(0);i<(X);i++){\n    if(r[i]==0){\n      return 0;\n    }\n  }\n  for(j=(0);j<(Y);j++){\n    if(c[j]==0){\n      return 0;\n    }\n  }\n  return 1;\n}\nint main(){\n  int i, x;\n  wmem = memarr;\n  int xx;\n  int yy;\n  char **mp;\n  Modint res;\n  Comb<Modint> c;\n  rd(X);\n  rd(Y);\n  {\n    int szDqbNYU;\n    for(szDqbNYU=(0);szDqbNYU<(X);szDqbNYU++){\n      rd(A[szDqbNYU]);\n    }\n  }\n  st[0][0] = 1;\n  for(i=(1);i<(20);i++){\n    int j;\n    for(j=(1);j<(20);j++){\n      st[i][j] = j * st[i-1][j] + st[i-1][j-1];\n    }\n  }\n  for(i=(0);i<(19);i++){\n    int j;\n    for(j=(0);j<(19);j++){\n      int k;\n      for(k=(0);k<(19);k++){\n        pb[i][j] += st[i+1][k+1] * st[j+1][k+1] * c.fac(k) * c.fac(k);\n      }\n    }\n  }\n  for(i=(0);i<(19);i++){\n    int j;\n    for(j=(0);j<(19);j++){\n      int k;\n      for(k=(1);k<(19);k++){\n        pbm[i][j] += st[i+1][k-1] * st[j+1][k-1] * c.fac(k-1) * c.fac(k-1);\n      }\n    }\n  }\n  walloc2d(&mp,X,Y);\n  for(i=(0);i<(X);i++){\n    int j;\n    for(j=(0);j<(Y);j++){\n      if(A[i][j]=='#'){\n        A[i][j] =0;\n      }\n      else{\n        A[i][j] =1;\n      }\n    }\n  }\n  res = pb[X][Y];\n  for(x=(0);x<(1<<X);x++){\n    int y;\n    for(y=(0);y<(1<<Y);y++){\n      for(i=(0);i<(X);i++){\n        int j;\n        for(j=(0);j<(Y);j++){\n          if((x&1<<i)||(y&1<<j)){\n            mp[i][j] =2;\n          }\n          else{\n            mp[i][j] =A[i][j];\n          }\n        }\n      }\n      if(canmake(mp)==0){\n        int j;\n        xx = yy = 0;\n        for(i=(0);i<(X);i++){\n          if(x&1<<i){\n            xx++;\n          }\n        }\n        for(j=(0);j<(Y);j++){\n          if(y&1<<j){\n            yy++;\n          }\n        }\n        res += pbm[xx][yy];\n      }\n    }\n  }\n  wt_L(res);\n  wt_L('\\n');\n  return 0;\n}\n// cLay varsion 20200116-1 [beta]\n\n// --- original code ---\n// #define MD 998244353\n// int X, Y;\n// char A[10][12];\n// \n// Modint st[20][20], pb[20][20], pbm[20][20];\n// \n// set<ll> s;\n// void brute(ll mask){\n//   if(s.count(mask)) return;\n//   s.insert(mask);\n// \n//   rep(i,X-1){\n//     ll mp = mask;\n//     rep(j,Y) if(mp & (1<<(i*Y+j))) mp ^= (1<<(i*Y+j));\n//     brute(mp);\n//   }\n//   rep(j,Y-1){\n//     ll mp = mask;\n//     rep(i,X) if(mp & (1<<(i*Y+j))) mp ^= (1<<(i*Y+j));\n//     brute(mp);\n//   }\n//   rep(i,X-1){\n//     ll mp = mask;\n//     rep(j,Y) if(!(mp & (1<<(i*Y+j)))) mp ^= (1<<(i*Y+j));\n//     brute(mp);\n//   }\n//   rep(j,Y-1){\n//     ll mp = mask;\n//     rep(i,X) if(!(mp & (1<<(i*Y+j)))) mp ^= (1<<(i*Y+j));\n//     brute(mp);\n//   }\n// }\n// \n// \n// int canmake(char **mp){\n//   int r[10] = {}, c[10] = {};\n//   for(;;){\n//     int a[3];\n//     int fg = 0;\n//     rep(i,X) if(r[i]==0){\n//       a[0] = a[1] = a[2] = 0;\n//       rep(j,Y) a[mp[i][j]] = 1;\n//       if(a[0]==0 || a[1]==0){\n//         r[i] = 1;\n//         fg++;\n//         rep(j,Y) mp[i][j] = 2;\n//       }\n//     }\n//     rep(j,Y) if(c[j]==0){\n//       a[0] = a[1] = a[2] = 0;\n//       rep(i,X) a[mp[i][j]] = 1;\n//       if(a[0]==0 || a[1]==0){\n//         c[j] = 1;\n//         fg++;\n//         rep(i,X) mp[i][j] = 2;\n//       }\n//     }\n//     if(fg==0) break;\n//   }\n//   rep(i,X) if(r[i]==0) return 0;\n//   rep(j,Y) if(c[j]==0) return 0;\n//   return 1;\n// }\n// \n// \n// {\n//   int xx, yy;\n//   char **mp;\n//   Modint res;\n//   Comb<Modint> c;\n//   rd(X,Y,A(X));\n// \n// /*  rep(X,1,7) rep(Y,1,7){\n//     int res;\n//     s.clear();\n//     brute(0);\n//     res = s.size();\n//     wt(X,Y,res); // poly-Bernoulli\n//   }*/\n// \n//   st[0][0] = 1;\n//   rep(i,1,20) rep(j,1,20) st[i][j] = j * st[i-1][j] + st[i-1][j-1];\n// \n//   rep(i,19) rep(j,19){\n//     rep(k,19) pb[i][j] += st[i+1][k+1] * st[j+1][k+1] * c.fac(k) * c.fac(k);\n//   }\n// \n//   rep(i,19) rep(j,19){\n//     rep(k,1,19) pbm[i][j] += st[i+1][k-1] * st[j+1][k-1] * c.fac(k-1) * c.fac(k-1);\n//   }\n// \n//   walloc2d(&mp,X,Y);\n//   rep(i,X) rep(j,Y) A[i][j] = if[A[i][j]=='#', 0, 1];\n//   res = pb[X][Y];\n//   rep(x,1<<X) rep(y,1<<Y){\n//     rep(i,X) rep(j,Y) mp[i][j] = if[(x&1<<i)||(y&1<<j), 2, A[i][j]];\n//     if(canmake(mp)==0){\n//       xx = yy = 0;\n//       rep(i,X) if(x&1<<i) xx++;\n//       rep(j,Y) if(y&1<<j) yy++;\n//       res += pbm[xx][yy]; // wrong\n//     }\n//   }\n//   wt(res);\n// }\n// \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n)     for(int i = 0;i < n;i++)\n#define REPR(i, n)    for(int i = n;i >= 0;i--)\n#define FOR(i, m, n)  for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define VRSORT(v) sort(v.begin(), v.end(),greater<long long>());\n#define ALL(X) (X).begin(),(X).end()\n#define INF 99999999\n#define M_PI 3.14159265358979323846\n#define MOD 998244353\n\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 0};\nint dy[]={0, 1, 0, -1, 0};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n \nstd::string pad(int num){ char buffer[4]; std::snprintf(buffer, sizeof(buffer), \"%03d\", num); return buffer;}\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) os << \"[\" << el.first << \" \" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) os << el << \" \"; return os; }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\nint H,W;\nvector<string> A;\n\n// 難しいから一旦飛ばす。\n\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> H >> W;\n    REP(i,H){\n        string a;\n        cin >> a;\n        A.push_back(a);\n    }\n\n}\n\nvoid solve(){\n    input();\n    ull a=0;\n    vector<ull> state;\n    REP(i,H) REP(j,W){\n        if(A[i][j]=='#')\n            a |= (1LL<<(i+j*W));\n    }\n    state.push_back(a);\n    REP(i,H) REP(j,W){\n        vector<ull> tmp;\n        for(auto s:state){\n            // ある行に対する操作\n            int t1 = s;\n            REP(k,W) t1 |= (1LL<<(i*W+k));\n            tmp.push_back(t1);\n\n            // ある列に対する操作\n            ull t2 = s;\n            REP(k,H) t2 |= (1LL<<(k*W+j));\n            tmp.push_back(t2);\n\n            // ある行に対する操作\n            ull t3 = s;\n            REP(k,W) t3 &= ~(1LL<<(i*W+k));\n            tmp.push_back(t3);\n            \n            // ある列に対する操作\n            ull t4 = s;\n            REP(k,H) t4 &= ~(1LL<<(k*W+j));\n            tmp.push_back(t4);\n\n        }\n        vector<ull> tmp_v;\n        set_union(state.begin(),state.end(),tmp.begin(),tmp.end(),back_inserter(tmp_v));\n        set<ull> tmp_set(tmp_v.begin(),tmp_v.end());\n        vector<ull> tmp_vv(tmp_set.begin(),tmp_set.end());\n        state=tmp_vv;\n        // DBG(state)\n    }\n\n    DBG(bitset<60>(a))\n    // cout << state << endl;\n    cout << state.size()%MOD << endl;\n\n}\n\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// 解説 AC（75% 自力）\n\nlong long mod = 998244353;\nlong long H, W;\nlong long bitcnt[1 << 10];\nlong long fact[19];\nlong long nr[19][19];\nlong long dp0[19][19]; // 何もない状態\nlong long dp1[19][19]; // 横方向のみある\nlong long dp2[19][19]; // 縦方向のみある\nlong long dp3[19][19]; // 両方向ある\nbool used[1 << 10][1 << 10];\nbool vis[1 << 10][1 << 10];\nchar c[19][19];\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= 15; i++) fact[i] = 1LL * i * fact[i - 1];\n\tfor (int i = 0; i <= 15; i++) {\n\t\tfor (int j = 0; j <= 15; j++) {\n\t\t\tif (i == 0 || j == 0) nr[i][j] = 1;\n\t\t\telse nr[i][j] = (nr[i - 1][j] + nr[i][j - 1]) % mod;\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << 10); i++) {\n\t\tfor (int j = 0; j < 10; j++) bitcnt[i] += (i / (1 << j)) % 2;\n\t}\n}\n\nlong long ncr(int n, int r) {\n\tif (r < 0 || n < r) return 0;\n\treturn nr[n - r][r];\n}\n\nvector<int> VecToVec2(int h, int w, vector<int> vec) {\n\tvector<int> vec2(h, 0);\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (vec[i] >= 1) vec2[vec[i] - 1] += 1;\n\t}\n\tfor (int i = h - 1; i >= 1; i--) vec2[i - 1] += vec2[i];\n\treturn vec2;\n}\n\nlong long calc_0(int h, int w, vector<int> vec) {\n\tvector<int> vec2 = VecToVec2(h, w, vec);\n\tlong long cnt = 1, val = fact[h] * fact[w];\n\tfor (int i = 1; i < vec.size(); i++) {\n\t\tif (vec[i] == vec[i - 1]) cnt++;\n\t\telse cnt = 1;\n\t\tval /= cnt;\n\t}\n\tcnt = 1;\n\tfor (int i = 1; i < vec2.size(); i++) {\n\t\tif (vec2[i] == vec2[i - 1]) cnt++;\n\t\telse cnt = 1;\n\t\tval /= cnt;\n\t}\n\treturn val;\n}\n\nlong long calc_1(int h, int w, vector<int> vec) {\n\tvector<int> vec2 = VecToVec2(h, w, vec);\n\tlong long ret = 2, cnt = 1;\n\tif (vec2.size() == 0) ret = 1;\n\tfor (int i = 1; i < vec2.size(); i++) {\n\t\tif (vec2[i - 1] != vec2[i]) cnt++;\n\t\tif (vec2[i - 1] != vec2[i]) {\n\t\t\tret += ((1LL << cnt) - 2LL);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tret += ((1LL << cnt) - 2LL);\n\treturn ret;\n}\n\nlong long calc_2(int h, int w, vector<int> vec) {\n\tlong long ret = 2, cnt = 1;\n\tif (vec.size() == 0) ret = 1;\n\tfor (int i = 1; i < vec.size(); i++) {\n\t\tif (vec[i - 1] != vec[i]) cnt++;\n\t\tif (vec[i - 1] != vec[i]) {\n\t\t\tret += ((1LL << cnt) - 2LL);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tret += ((1LL << cnt) - 2LL);\n\treturn ret;\n}\n\nvoid solve(int h, int w, vector<int> vec) {\n\tif (vec.size() == w) {\n\t\tdp0[h][w] += calc_0(h, w, vec);\n\t\tdp1[h][w] += calc_0(h, w, vec) * calc_1(h, w, vec);\n\t\tdp2[h][w] += calc_0(h, w, vec) * calc_2(h, w, vec);\n\t\tdp3[h][w] += calc_0(h, w, vec) * (calc_1(h, w, vec) + calc_2(h, w, vec) - 1LL);\n\t\tdp0[h][w] = (dp0[h][w] + mod * mod) % mod;\n\t\tdp1[h][w] = (dp1[h][w] + mod * mod) % mod;\n\t\tdp2[h][w] = (dp2[h][w] + mod * mod) % mod;\n\t\tdp3[h][w] = (dp3[h][w] + mod * mod) % mod;\n\t\treturn;\n\t}\n\n\tint border = h;\n\tif (vec.size() >= 1) border = vec[vec.size() - 1];\n\tfor (int i = 0; i <= border; i++) {\n\t\tvector<int> vec2 = vec;\n\t\tvec2.push_back(i);\n\t\tsolve(h, w, vec2);\n\t}\n}\n\nbool dfs(int posx, int posy) {\n\tint col[10][10];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif ((posx / (1 << i)) % 2 == 1) col[i][j] = 0;\n\t\t\telse if ((posy / (1 << j)) % 2 == 1) col[i][j] = 0;\n\t\t\telse if (c[i][j] == '#') col[i][j] = 1;\n\t\t\telse col[i][j] = 2;\n\t\t}\n\t}\n\n\tint pats = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tif ((posx / (1 << i)) % 2 == 1) continue;\n\t\tint c1 = 0, c2 = 0;\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (col[i][j] == 1) c1++;\n\t\t\tif (col[i][j] == 2) c2++;\n\t\t}\n\t\tif (c1 * c2 == 0) pats++;\n\t}\n\tfor (int i = 0; i < W; i++) {\n\t\tif ((posy / (1 << i)) % 2 == 1) continue;\n\t\tint c1 = 0, c2 = 0;\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tif (col[j][i] == 1) c1++;\n\t\t\tif (col[j][i] == 2) c2++;\n\t\t}\n\t\tif (c1 * c2 == 0) pats++;\n\t}\n\tif (pats == 0) return true;\n\treturn false;\n}\n\nint main() {\n\t// 入力\n\tinit();\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) cin >> c[i][j];\n\t}\n\n\t// 前処理\n\tfor (int i = 0; i <= H; i++) {\n\t\tfor (int j = 0; j <= W; j++) solve(i, j, vector<int>{});\n\t}\n\tdfs(0, 0);\n\n\t// 全探索\n\tlong long Answer = 0;\n\tfor (int i = 0; i < (1 << H); i++) {\n\t\tfor (int j = 0; j < (1 << W); j++) {\n\t\t\tif (dfs(i, j) == false) continue;\n\t\t\tint f1 = bitcnt[i], f2 = bitcnt[j];\n\t\t\tif (f1 == H && f2 == W) continue;\n\t\t\tif (f1 == 0 && f2 == 0) Answer += 1LL;\n\t\t\tif (f1 == 0 && f2 >= 1) Answer += (1LL << f2);\n\t\t\tif (f1 >= 1 && f2 == 0) Answer += (1LL << f1);\n\t\t\tif (f1 >= 1 && f2 >= 1) Answer += dp3[f1][f2];\n\t\t}\n\t}\n\tAnswer += dp0[H][W];\n\tcout << Answer % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int H, W; cin >> H >> W;\n    vector<string> A(H); cin >> A;\n\n    int n = H + W;\n    Combination C(n);\n    mmat sti(n + 1);\n    sti[0] = mvec(1, 1);\n    FOR(i, 1, n + 1){\n        sti[i].resize(i + 1);\n        sti[i][0] = 0;\n        FOR(j, 1, i) sti[i][j] = sti[i - 1][j - 1] + sti[i - 1][j] * j;\n        sti[i][i] = 1;\n    }\n\n    mmat dp(H + 1, mvec(W, 0));\n    dp[0][0] = 1;\n    REP(i, H){\n        REP(j, W){\n            dp[i + 1][j] += dp[i][j] * (j + 2);\n            if(j < W - 1) dp[i + 1][j + 1] += dp[i][j];\n        }\n    }\n    \n    mmat dq(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(k, w) dq[h][w] += dp[h][k] * sti[w][k + 1] * C.fact[k + 1] * C.fact[k];\n        if(w == 0) dq[h][w] = 1;\n    }\n\n    mmat dq2(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(i, h + 1) REP(j, w + 1){\n            dq2[h][w] += dq[i][w - j] * dq[h - i][j] * C.nCr(h, i) * C.nCr(w, j);\n        }\n    }\n    \n    mint ans = dq[H][W];\n\n    mat flgx(bit(H), vec(W, 0)), flgy(bit(W), vec(H, 0));\n    REP(x, bit(H)){\n        REP(j1, W) REP(j2, j1){\n            bool f = false;\n            \n            REP(i1, H) REP(i2, i1) if((x >> i1) & (x >> i2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgx[x][j1] ^= bit(j2);\n                flgx[x][j2] ^= bit(j1);\n            }\n        }\n    }\n    mdebug(dq2);\n\n    REP(y, bit(W)){\n        REP(i1, H) REP(i2, i1){\n            bool f = false;\n\n            REP(j1, W) REP(j2, j1) if((y >> j1) & (y >> j2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgy[y][i1] ^= bit(i2);\n                flgy[y][i2] ^= bit(i1);\n            }\n        }\n    }\n\n    REP(x, bit(H)) REP(y, bit(W)){\n        int tx = 0;\n        REP(i, H) if((x >> i) & 1) tx |= flgy[y][i];\n        int ty = 0;\n        REP(j, W) if((y >> j) & 1) ty |= flgx[x][j];\n\n        if(((x & tx) == x) && ((y & ty) == y)){\n            int h = H - __builtin_popcountll(x), w = W - __builtin_popcountll(y);\n            //cout << h << \",\" << w << endl;\n            if(h < H && w < W) ans += dq2[h][w]; \n        }\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1<<20|3,mo=998244353;\nint n,m,a[26][26],f[26][26],g[26][26],C[26][26],p[26],q[26],fac[N],ifac[N];\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline void sub(int &x, int y){x=x-y>=0?x-y:x-y+mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nvoid iniC(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);\n\tper(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\nint dfs(int dep, int lim, int n, int m){\n\tif(dep>n){\n\t\tint res=1ll*fac[n]*fac[m]%mo;\n\t\trep(i,1,n){\n\t\t\tint j=i;while(j+1<=n&&p[j+1]==p[i])j++;\n\t\t\tres=1ll*res*ifac[j-i+1]%mo;i=j;\n\t\t}\n\t\tmemset(q,0,sizeof(q));\n\t\trep(i,1,n)q[p[i]]++;\n\t\tper(i,m,1)q[i]+=q[i+1];\n\t\trep(i,1,m){\n\t\t\tint j=i;while(j+1<=m&&q[j+1]==q[i])j++;\n\t\t\tres=1ll*res*ifac[j-i+1]%mo;i=j;\n\t\t}\n\t\treturn res;\n\t}\n\tint res=0;\n\twhile(lim>=0){\n\t\tp[dep]=lim;add(res,dfs(dep+1,lim,n,m));lim--;\n\t}\n\treturn res;\n}\nint solve(int n, int m){\n\treturn dfs(1,m,n,m);\n}\nbool gg1[16][1<<10|3],gg2[16][1<<10|3];\nbool ck(int s, int t){\n\trep(i,1,n)if((s>>i-1&1)&&gg1[i][t])return 0;\n\trep(i,1,m)if((t>>i-1&1)&&gg2[i][s])return 0;\n\treturn 1;\n}\nint main() {\n\tiniC(20);\n\trep(i,0,20){\n\t\tC[i][0]=C[i][i]=1;\n\t\trep(j,1,i-1)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\n\tn=10;m=10;\n\trep(i,0,10)rep(j,0,10)f[i][j]=solve(i,j);\n\trep(i,1,10)rep(j,1,10)rep(x,0,i)rep(y,0,j)\n\t\tg[i][j]=(g[i][j]+1ll*C[i][x]*C[j][y]%mo*f[x][j-y]%mo*f[i-x][y])%mo;\n\tg[0][0]=1;\n\t\t\n\tread(n);read(m);rep(i,1,n){\n\t\tchar S[27];scanf(\"%s\",S+1);rep(j,1,m)a[i][j]=S[j]=='#';\n\t}\n\trep(i,1,n)rep(t,1,(1<<m)-1){\n\t\tint tot=0,cur=0;\n\t\trep(j,1,m)if(t>>j-1&1)tot++,cur+=a[i][j];\n\t\tgg1[i][t]=tot==cur||0==cur;\n\t}\n\trep(j,1,m)rep(s,1,(1<<n)-1){\n\t\tint tot=0,cur=0;\n\t\trep(i,1,n)if(s>>i-1&1)tot++,cur+=a[i][j];\n\t\tgg2[j][s]=tot==cur||0==cur;\n\t}\n//\trep(i,1,n)rep(j,1,m)printf(\"%d %d:%d\\n\",i,j,f[i][j]);\n//\tprintf(\"qwq %d %d\\n\",gg1[1][3],gg2[2][3]);\n\tint res=f[n][m];\n\trep(s,1,(1<<n)-1)rep(t,1,(1<<m)-1)if(ck(s,t)){\n\t//\tprintf(\"%d %d\\n\",s,t);\n\t\tint x=n;rep(i,0,n-1)x-=s>>i&1;\n\t\tint y=m;rep(i,0,m-1)y-=t>>i&1;\n\t\t\n\t\tif(!x&&!y)add(res,1);\n\t\telse if(!x)add(res,power(2,y));\n\t\telse if(!y)add(res,power(2,x));\n\t\telse add(res,g[x][y]);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst long long mod = 998244353;\nlong long f[15], invf[15];\nlong long f0[15][15][2];\nlong long f1[15][15];\nlong long sum[15][15];\nchar s[15];\nint a[15][15];\nint b[15][15];\nint cnt[2005];\n\nlong long power(long long a,long long b){\n    long long res = 1;\n    while(b){\n        if(b&1) res = res*a%mod;\n        a = a*a%mod;\n        b /= 2;\n    }\n    return res;\n}\n\nlong long inv(long long u){ return power(u,mod-2); }\n\nvoid preWork(int n){\n    f[0] = invf[0] = 1;\n    for(long long i = 1; i <= n; i++){\n        f[i] = f[i-1]*i%mod;\n        invf[i] = inv(f[i]);\n    }\n    for(int i = 0; i < (1<<10); i++){\n        cnt[i] = 0;\n        int mask = i;\n        while(mask){\n            cnt[i] += mask%2;\n            mask /= 2;\n        }\n    }\n}\n\nlong long getC(int n,int m){\n    if(m>n || m<0) return 0;\n    else{\n        long long res = f[n];\n        res = res*invf[m]%mod;\n        res = res*invf[n-m]%mod;\n        return res;\n    }\n}\n\nint check(int n,int m){\n    for(int i = 1; i <= n; i++){\n        int cnt0 = 0, cnt1 = 0;\n        for(int j = 1; j <= m; j++){\n            if(b[i][j]!=-1){\n                if(b[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n        }\n        if(!cnt0 && cnt1) return 0;\n        if(!cnt1 && cnt0) return 0;\n    }\n    for(int j = 1; j <= m; j++){\n        int cnt0 = 0, cnt1 = 0;\n        for(int i = 1; i <= n; i++){\n            if(b[i][j]!=-1){\n                if(b[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n        }\n        if(!cnt0 && cnt1) return 0;\n        if(!cnt1 && cnt0) return 0;\n    }\n    return 1;\n}\n\nint main(){\n    preWork(10);\n    f0[0][0][0] = f0[0][0][1] = 1;\n    for(int i = 0; i <= 10; i++){\n        for(int j = 0; j <= 10; j++){\n            if(i || j){\n                f0[i][j][0] = f0[i][j][1] = 0;\n                for(int k = i-1; k >= 0; k--) f0[i][j][0] = (f0[i][j][0] + f0[k][j][1]*invf[i-k]%mod)%mod;\n                for(int k = j-1; k >= 0; k--) f0[i][j][1] = (f0[i][j][1] + f0[i][k][0]*invf[j-k]%mod)%mod;\n            }\n            if(i==0 && j==0) f1[i][j] = 1;\n            else{\n                f1[i][j] = (f0[i][j][0]+f0[i][j][1])%mod;\n                f1[i][j] = f1[i][j]*f[i]%mod;\n                f1[i][j] = f1[i][j]*f[j]%mod;\n            }\n            //printf(\"f1[%d][%d] = %lld\\n\",i,j,f1[i][j]);\n        }\n    }\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 1; i <= n; i++){ \n        scanf(\"%s\",s+1);\n        for(int j = 1; j <= m; j++){ \n            a[i][j] = s[j]=='.';\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            sum[i][j] = 0;\n            for(int x = 0; x <= i; x++){\n                for(int y = 0; y <= j; y++){\n                    long long count = getC(i,x)*getC(j,y)%mod;\n                    //black or white = column and row diff from color\n                    count = count*f1[x][y]%mod;\n                    count = count*f1[i-x][j-y]%mod;\n                    sum[i][j] = (sum[i][j]+count)%mod;\n                }\n            }\n        }\n    }\n    long long ans = f1[n][m];\n    for(int i = 0; i < (1<<n); i++){\n        for(int j = 0; j < (1<<m); j++){\n            if(!i && !j) continue;\n            for(int k = 0; k < n; k++){\n                for(int l = 0; l < m; l++){\n                    if(i&(1<<k) && j&(1<<l)) b[k+1][l+1] = a[k+1][l+1];\n                    else b[k+1][l+1] = -1;\n                    //if(i==3 && j==9) printf(\"%2d\",b[k][l]);\n                }\n                //if(i==3 && j==9) printf(\"\\n\");\n            }\n            if(check(n,m)!=0){ \n                //printf(\"i = %d, j = %d\\n\",i,j);\n                ans = ans+sum[n-cnt[i]][m-cnt[j]];\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar grid[15][15];\n\nint A[15][15];\nint B[15][15];\n\nlong long MOD = 998244353;\n\nlong long memoRow[15][15][6];\nlong long memoCol[15][15][6];\nlong long ncr[15][15];\nlong long invNcr[15][15];\n\nlong long fact[15];\nlong long invFact[15];\n\nlong long pow2[15];\nlong long invPow2[15];\n\nint H, W;\n\nlong long modpow(long long a, long long b){\n    if(b == 0){\n        return 1%MOD;\n    }else if(b == 1){\n        return a%MOD;\n    }else{\n        long long temp = modpow(a, b>>1);\n        if(b&1){\n            return (temp*temp%MOD) * a % MOD;\n        }else{\n            return temp*temp%MOD;\n        }\n    }\n}\n\nlong long row[15][15][3];\nlong long col[15][15][3];\n\nint main(){\n    scanf(\"%d%d\", &H, &W);\n\n    for(int i = 0; i < H; i ++){\n        scanf(\" %s\", grid[i]);\n    }\n\n    pow2[0] = 1;\n    invPow2[0] = 1;\n    fact[0] = 1;\n    invFact[0] = 1;\n    for(int i = 1; i < 14; i ++){\n        pow2[i] = pow2[i-1]*2%MOD;\n        fact[i] = fact[i-1]*i%MOD;\n        invPow2[i] = modpow(pow2[i], MOD-2);\n        invFact[i] = modpow(fact[i], MOD-2);\n    }\n\n    for(int i = 0; i < H; i ++){\n        for(int j = 0; j < W; j ++){\n            A[i][j] = grid[i][j] == '#';\n        }\n    }\n\n    for(int i = 0; i < 14; i ++){\n        ncr[i][0] = 1;\n        invNcr[i][0] = 1;\n        ncr[i][i] = 1;\n        invNcr[i][i] = 1;\n        for(int j = 1; j < i; j ++){\n            ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j])%MOD;\n            invNcr[i][j] = modpow(ncr[i][j], MOD-2);\n        }\n    }\n\n    // Legendary Grandmaster Benq's method\n    // I am trying to upsolve, but no guarantees of success in explaining :(\n\n    /* row[i][j][d] represents number of possible patterns when i rows and j columns are unpainted\n    with d distinct colors; last operation at the row coloring step\n\n    col[i][j][d] represents number of possible patterns when i rows and j columns are unpainted\n    with d distinct colors; last operation at the column coloring step\n    */\n\n    /*\n    Refer to https://codeforces.com/blog/entry/73139?#comment-574602 for the order of steps/operations convention used\n    */\n    memset(col, 0, sizeof(col));\n    memset(row, 0, sizeof(row));\n    for(int j = 1; j <= W; j ++){\n        // All rows are unpainted\n        // There are (W choose j) = (W choose W-j) ways to choose the W-j columns painted\n        // There are 2**(W-j) ways to choose the colors of the W-j painted columns\n        col[H][j][2] = ncr[W][j] * pow2[W-j] % MOD;\n    }\n\n    // There are 2**W ways to paint all the columns with a specific color\n    long long ans = pow2[W];\n\n    for(int i = H; i >= 0; i --){\n        for(int j = W; j >= 0; j --){\n            // When d = 0, it means that we stopped the painting with exactly j columns left unpainted\n            // At the previous step, either d = 1 or d = 2 (depending on the number of distinct colors painted)\n            col[i][j][0] = (col[i][j][1] + col[i][j][2])%MOD;\n\n            for(int k = 1; k < i; k ++){\n                // choose l (not one, but the letter L in lowercase) out of i rows to paint\n                int l = i-k;\n\n                // i choose l ways to color the rows\n                // col[i][j][2] ways to color the remaining columns if row colored\n                // col[i][j][2] patterns of the remaining columns\n                row[k][j][1] = (row[k][j][1] + (ncr[i][l])*(col[i][j][2]*2%MOD+col[i][j][1])%MOD) % MOD;\n\n                // i choose l ways to color the rows\n                // pow2[j]-2 ways to color the rows with 2 distinct colors\n                // col[i][j][2] patterns of the remaining columns\n                row[k][j][2] = (row[k][j][2] + (ncr[i][l])*((pow2[l]-2+MOD)*(col[i][j][2]) % MOD)%MOD  ) %MOD;\n            }\n\n            // col[i][j][2] ways with 2 distinct columns\n            // pow2[i]-2 ways to colour the rows with two columns\n            ans = (ans + col[i][j][2] * (pow2[i]-2+MOD)) % MOD;\n\n            // row operation is actually the penultimate step, hence it has to be after the column operation\n            // Remember: we are working backwards using bottom-up dp\n            // Similar logic follows from the column step\n            row[i][j][0] = (row[i][j][1] + row[i][j][2])%MOD;\n\n            // similar logic for rows\n            for(int k = 1; k < j; k ++){\n                // choose l (not one, but the letter L in lowercase) out of j columns to paint\n                int l = j-k;\n                col[i][k][1] = (col[i][k][1] + (ncr[j][l])*(row[i][j][2]*2%MOD+row[i][j][1])%MOD) % MOD;\n                col[i][k][2] = (col[i][k][2] + (ncr[j][l])*((pow2[l]-2+MOD)*(row[i][j][2]) % MOD)%MOD  ) %MOD;\n            }\n\n            ans = (ans + row[i][j][2] * (pow2[j]-2+MOD)) % MOD;\n        }\n    }\n\n    // We then complete the summary part of the editorial\n    for(int i = 0; i < (1<<H); i ++){\n        for(int j = 0; j < (1<<W); j ++){\n            // Check that there are two colors in every row and column that remains\n\n            // Row check: the bits set are the ones which correspond to the rows and columns being chosen respectively\n            bool valid = true;\n            for(int k = 0; k < H; k ++){\n                if(!(i&(1<<k))){\n                    int temp = 0;\n                    for(int l = 0; l < W; l ++){\n                        if(!(j&(1<<l))){\n                            temp |= (1<<A[k][l]);\n                        }\n                    }\n\n                    if(temp != 3){\n                        valid = false;\n                        break;\n                    }\n                }\n            }\n\n            if(valid){\n                // Logic is similar for columns\n                for(int l = 0; l < W; l ++){\n                    if(!(j&(1<<l))){\n                        int temp = 0;\n                        for(int k = 0; k < H; k ++){\n                            if(!(i&(1<<k))){\n                                temp |= (1<<A[k][l]);\n                            }\n                        }\n\n                        if(temp != 3){\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if(valid){\n                int rowsRemaining = H-__builtin_popcount(i);\n                int colsRemaining = W-__builtin_popcount(j);\n\n                int x = rowsRemaining;\n                int y = colsRemaining;\n\n                // Two cases: last operation is row or last operation is column\n                // d=0 because only then, this indicates that it is the final step and that it is not possible to remove more columns\n                // This is why the row and column check for two distinct colors is necessary.\n                // There are H choose x ways to permute the rows painted and W choose y ways to permute the columns painted\n                // These are invalid double-counts since the set of rows and columns painted have been fixed.\n                // Hence, we need to divide the number of ways by invNcr[H][x] and invNcr[W][y]\n                ans = (ans + (row[x][y][0] + col[x][y][0])%MOD*invNcr[H][x]%MOD*invNcr[W][y]%MOD)%MOD;\n            }\n        }\n    }\n\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int H, W; cin >> H >> W;\n    vector<string> A(H); cin >> A;\n\n    int n = H + W;\n    Combination C(n);\n    mmat sti(n + 1);\n    sti[0] = mvec(1, 1);\n    FOR(i, 1, n + 1){\n        sti[i].resize(i + 1);\n        sti[i][0] = 0;\n        FOR(j, 1, i) sti[i][j] = sti[i - 1][j - 1] + sti[i - 1][j] * j;\n        sti[i][i] = 1;\n    }\n\n    mmat dp(H + 1, mvec(W, 0));\n    dp[0][0] = 1;\n    REP(i, H){\n        REP(j, W){\n            dp[i + 1][j] += dp[i][j] * (j + 2);\n            if(j < W - 1) dp[i + 1][j + 1] += dp[i][j];\n        }\n    }\n    \n    mmat dq(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(k, w) dq[h][w] += dp[h][k] * sti[w][k + 1] * C.fact[k + 1] * C.fact[k];\n        if(w == 0) dq[h][w] = 1;\n    }\n\n    mmat dq2(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(i, h + 1) REP(j, w + 1){\n            dq2[h][w] += dq[i][w - j] * dq[h - i][j] * C.nCr(h, i) * C.nCr(w, j);\n        }\n    }\n    \n    mint ans = dq[H][W];\n\n    mat flgx(bit(H), vec(W, 0)), flgy(bit(W), vec(H, 0));\n    REP(x, bit(H)){\n        REP(j1, W) REP(j2, j1){\n            bool f = false;\n            \n            REP(i1, H) REP(i2, i1) if((x >> i1) & (x >> i2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgx[x][j1] ^= bit(j2);\n                flgx[x][j2] ^= bit(j1);\n            }\n        }\n    }\n\n    REP(y, bit(W)){\n        REP(i1, H) REP(i2, i1){\n            bool f = false;\n\n            REP(j1, W) REP(j2, j1) if((y >> j1) & (y >> j2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    f = true;\n                }\n            }\n            if(f){\n                flgy[y][i1] ^= bit(i2);\n                flgy[y][i2] ^= bit(i1);\n            }\n        }\n    }\n\n    REP(x, bit(H)) REP(y, bit(W)){\n        int tx = 0;\n        REP(i, H) if((x >> i) & 1) tx |= flgy[y][i];\n        int ty = 0;\n        REP(j, W) if((y >> j) & 1) ty |= flgx[x][j];\n\n        if(((x & tx) == x) && ((y & ty) == y)){\n            int h = H - __builtin_popcount(x), w = W - __builtin_popcount(y);\n            //cout << h << \",\" << w << endl;\n            if(h < H && w < W) ans += dq2[h][w]; \n        }\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 10, S = (1 << N) + 10, mod = 998244353;\n\ninline void add(int& a, int b) {\n\ta += b;\n\tif (a >= mod) a -= mod;\n}\n\ninline int mul(ll a, int b) {\n\treturn (a * b) % mod;\n}\n\nstring a[N];\nint h, w, cnt[S], p2[N];\nint dp[S][S][2][2];\nbool seen[S][S][2][2], dp2[S][S], seen2[S][S];\n\nint main() {\n\tfast_cin();\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; ++i) {\n\t\tcin >> a[i];\n\t\tfor (auto& c : a[i]) {\n\t\t\tc = (1 << (c == '#'));\n\t\t}\n\t}\n\tfor (int i = 0; i <= max(h, w); ++i) {\n\t\tp2[i] = (1 << i);\n\t}\n\tint mrows = (1 << h), mcols = (1 << w);\n\tfor (int mask = 0; mask < max(mrows, mcols); ++mask) {\n\t\tcnt[mask] = __builtin_popcount(mask);\n\t}\n\tfor (int rows = 0; rows < mrows; ++rows) {\n\t\tfor (int cols = 0; cols < mcols; ++cols) {\n\t\t\tbool& ans = dp2[rows][cols];\n\t\t\tvector<int> cr(h, 0), cc(w, 0);\n\t\t\tfor (int i = 0; i < h; ++i) {\n\t\t\t\tif (!((rows >> i) & 1)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\t\tif (!((cols >> j) & 1)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcr[i] |= a[i][j];\n\t\t\t\t\tcc[j] |= a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = true;\n\t\t\tfor (int i = 0; i < h; ++i) {\n\t\t\t\tans &= !((rows >> i) & 1) or (cr[i] == 3);\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tans &= !((cols >> j) & 1) or (cc[j] == 3);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int rows = 0; rows < mrows; ++rows) {\n\t\tfor (int cols = 0; cols < mcols; ++cols) {\n\t\t\tfor (int turn = 0; turn < 2; ++turn) {\n\t\t\t\tfor (int must = 0; must < 2; ++must) {\n\t\t\t\t\tint& ans = dp[rows][cols][turn][must];\n\t\t\t\t\tif (!rows or !cols) {\n\t\t\t\t\t\tans = (must == 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd(ans, dp2[rows][cols]);\n\t\t\t\t\t\tint submask = (turn ? cols : rows);\n\t\t\t\t\t\twhile (submask) {\n\t\t\t\t\t\t\tint nrows = rows - (turn ? 0 : submask);\n\t\t\t\t\t\t\tint ncols = cols - (turn ? submask : 0);\n\t\t\t\t\t\t\tadd(ans, dp[nrows][ncols][turn ^ 1][1]);\n\t\t\t\t\t\t\tif (must == 0) {\n\t\t\t\t\t\t\t\tadd(ans, dp[nrows][ncols][turn ^ 1][1]);\n\t\t\t\t\t\t\t\tif (cnt[submask] > 1) {\n\t\t\t\t\t\t\t\t\tadd(ans, mul(p2[cnt[submask]] - 2, dp[nrows][ncols][turn ^ 1][0]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsubmask = (submask - 1) & (turn ? cols : rows);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int mask = 0; mask < (1 << w); ++mask) {\n\t\t// add(ans, mul(p2[cnt[mask]], solve((1 << h) - 1, (1 << w) - 1 - mask, 0, 0)));\n\t\tadd(ans, mul(p2[cnt[mask]], dp[(1 << h) - 1][(1 << w) - 1 - mask][0][0]));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int H, W; cin >> H >> W;\n    vector<string> A(H); cin >> A;\n\n    int n = H + W;\n    Combination C(n);\n    mmat sti(n + 1);\n    sti[0] = mvec(1, 1);\n    FOR(i, 1, n + 1){\n        sti[i].resize(i + 1);\n        sti[i][0] = 0;\n        FOR(j, 1, i) sti[i][j] = sti[i - 1][j - 1] + sti[i - 1][j] * j;\n        sti[i][i] = 1;\n    }\n\n    mmat dp(H + 1, mvec(W, 0));\n    dp[0][0] = 1;\n    REP(i, H){\n        REP(j, W){\n            dp[i + 1][j] += dp[i][j] * (j + 2);\n            if(j < W - 1) dp[i + 1][j + 1] += dp[i][j];\n        }\n    }\n    \n    mmat dq(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(k, w) dq[h][w] += dp[h][k] * sti[w][k + 1] * C.fact[k + 1] * C.fact[k];\n        if(w == 0) dq[h][w] = 1;\n    }\n\n    mmat dq2(H + 1, mvec(W + 1, 0));\n    REP(h, H + 1) REP(w, W + 1){\n        REP(i, h + 1) REP(j, w + 1){\n            dq2[h][w] += dq[i][w - j] * dq[h - i][j] * C.nCr(h, i) * C.nCr(w, j);\n        }\n    }\n    \n    mint ans = dq[H][W];\n    REP(x, bit(H)) REP(y, bit(W)){\n        bools okx(H, false), oky(W, false);\n        REP(i1, H) REP(i2, i1) REP(j1, W) REP(j2, j1){\n            if((x >> i1) & (x >> i2) & (y >> j1) & (y >> j2) & 1){\n                if(A[i1][j1] == A[i2][j2] && A[i1][j2] == A[i2][j1] && A[i1][j1] != A[i2][j1]){\n                    okx[i1] = true; okx[i2] = true; \n                    oky[j1] = true; oky[j2] = true; \n                }\n            }\n        }\n        bool f = true;\n        REP(i, H) if(((x >> i) & 1) && !okx[i]) f = false;\n        REP(j, W) if(((y >> j) & 1) && !oky[j]) f = false;\n\n        if(f){\n            int h = H - __builtin_popcount(x), w = W - __builtin_popcount(y);\n            //cout << h << \",\" << w << endl;\n            if(h < H && w < W) ans += dq2[h][w]; \n        }\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://betrue12.hateblo.jp/entry/2020/01/19/170701\n//https://drken1215.hatenablog.com/entry/2020/02/02/134400\n\n#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define chmax(x,y) x = max(x,y)\n#define chmin(x,y) x = min(x,y)\n\nconst int mod = 998244353;\nstruct mint {\nll x; \nmint(ll x=0):x((x%mod+mod)%mod){}\nmint operator-() const { return mint(-x);}\nmint& operator+=(const mint a) {\nif ((x += a.x) >= mod) x -= mod;\nreturn *this;\n }\nmint& operator-=(const mint a) {\nif ((x += mod-a.x) >= mod) x -= mod;\nreturn *this;\n }\n mint& operator*=(const mint a) {\n(x *= a.x) %= mod;\nreturn *this;\n}\nmint operator+(const mint a) const {\nmint res(*this);\nreturn res+=a;\n}\nmint operator-(const mint a) const {\nmint res(*this);\nreturn res-=a;\n}\n mint operator*(const mint a) const {\nmint res(*this);\nreturn res*=a;\n}\nmint pow(ll t) const {\nif (!t) return 1;\nmint a = pow(t>>1);\na *= a;\nif (t&1) a *= *this;\nreturn a;\n}\n mint inv() const {\nreturn pow(mod-2);\n }\n  mint& operator/=(const mint a) {\nreturn (*this) *= a.inv();\n }\nmint operator/(const mint a) const {\nmint res(*this);\nreturn res/=a;\n }\n};\nstruct combination {\nvector<mint> fact, ifact;\ncombination(int n):fact(n+1),ifact(n+1) {\n  assert(n < mod);\n fact[0] = 1;\n for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n ifact[n] = fact[n].inv();\n  for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n}\nmint operator()(int n, int k) {\nif (k < 0 || k > n) return 0;\nreturn fact[n]*ifact[k]*ifact[n-k];\n}\n  };\n\nint H,W;\nvector<string>A;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\n\n//初始化排列组合\n\ncombination c(20);\ncin>>H>>W;\nA.resize(H);\nrep(h,H)cin>>A[h];\n\n/*\ndp计算长方形的组合数\ndp1[a][b]表示长方形里有黑色线的组合数\ndp2[a][b]表示长方形里有黑色线的组合数\n\n横的有i个白线,竖的有j个白线的时候\ni和j必须大于0 \ndp2[a][b]+=c(a,i)*c(b,j)*dp2[a-i][b-j](1<=i<=a-1,1<=j<=b-1) \ndp2[a][b]+=1 (全白的情况有一种)\n\n横的有i个黑线，竖的有j个黑线的时候\ni和j不能同时为0\ndp1[a][b]+=c(a,i)*c(b,j)*dp2[a-i][b-j] (i+j>=1,i<=a-1,j<=b-1)\ndp1[a][b]+=1(全黑的情况有一种)\n*/\nvector<vector<mint>>R(15,vector<mint>(15,0));\nauto dp1=R;\nauto dp2=R;\nrep(i,15)R[0][i]=R[i][0]=mint(2).pow(i);\n\n//计算dp2\n\nfor(int a=1;a<15;a++)\n    for(int b=1;b<15;b++){\n        dp2[a][b]=1;\n        for(int i=1;i<a;i++)\n            for(int j=1;j<b;j++){\n                dp2[a][b]+=dp2[a-i][b-j]*c(a,i)*c(b,j);\n            }\n    }\n//计算dp1\n\nfor(int a=1;a<15;a++){\n    for(int b=1;b<15;b++){\n        dp1[a][b]=1;\n        for(int i=0;i<a;i++)\n            for(int j=0;j<b;j++){\n                if(i+j==0)continue;\n                dp1[a][b]+=dp2[a-i][b-j]*c(a,i)*c(b,j);\n            }\n        R[a][b]=dp1[a][b]+dp2[a][b];\n    }\n}\n\n/*\n计算L的组合数\nsumR[a][b] 表示两个交叉矩形的组合数的和\nsubR[a][b]表示竖的a个黑色横着b个白色的长方形组合数(先涂黑色)\n这里subR[a][b]=subR[b][a] \n*/\nvector<vector<mint>>L(15,vector<mint>(15,0));\nauto sumR=L,subR=L;\nrep(i,15){\n    subR[1][i]=1;\n    subR[i][1]=mint(2).pow(i)-1;\n}\nfor(int s=2;s<30;s++){\n    for(int a=1;a<15;a++){\n        int b=s-a;\n        if(b<1||b>=15)continue;\n        subR[a][b]=1;\n        for(int i=1;i<a;i++){\n            subR[a][b]+=c(a,i)*subR[b][a-i];//？\n        }\n    }\n}\n\nrep(a,15)rep(b,15){\n    if(a==0)sumR[a][b]=1;\n    else if(b==0)sumR[a][b]=1;\n    else sumR[a][b]=subR[a][b]+subR[b][a];\n}\n//竖方向黑色i个白色a-i个，横方向白色j个黑色b-j个 求i*j的长方形颜色组合数\nrep(i,15)L[0][i]=L[i][0]=mint(2).pow(i);\nfor(int a=1;a<14;a++)\n    for(int b=1;b<14;b++)\n        rep(i,a+1)\n            rep(j,b+1){\n                L[a][b]+=c(a,i)*c(b,j)*sumR[i][j]*sumR[a-i][b-j];\n            }\n\n\n    mint ans = R[H][W];\n    for (int bit = 0; bit < (1<<H)-1; ++bit) {\n        vector<int> tate;\n        for (int i = 0; i < H; ++i) if (!(bit & (1<<i))) tate.push_back(i);\n        for (int bit2 = 0; bit2 < (1<<W)-1; ++bit2) {\n            vector<int> yoko;\n            for (int i = 0; i < W; ++i) if (!(bit2 & (1<<i))) yoko.push_back(i);\n \n            //留下来的行或者列必须有两种颜色\n            bool ok = true;\n            for (auto i : tate) {\n                set<char> se;\n                for (auto j : yoko) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n            for (auto j : yoko) {\n                set<char> se;\n                for (auto i : tate) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n \n            if (ok) {\n                int c = __builtin_popcount(bit);\n                int r = __builtin_popcount(bit2);\n                mint add = L[c][r];\n                ans += add;\n            }\n        }\n    }\n    cout << ans.x << endl;\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod = 998244353;\ncat C[11][11];\n\nvoid count(int h, int w, char f_e, char f_h, char f_w, int & out, cat cur = 1) {\n\tif(h+w == 0) {\n\t\tout += cur;\n\t\tif(out >= mod) out -= mod;\n\t\treturn;\n\t}\n\tif(!(f_e&1) && h*w == 0) return;\n\tfor(int c = 0; c < 2; c++) for(int i = 0; i <= h; i++) for(int j = 0; j <= w; j++) if(i+j) {\n\t\tif((f_h>>c)&1 && i) continue;\n\t\tif((f_w>>c)&1 && j) continue;\n\t\tif(j && f_e&2 && c) continue;\n\t\tif(i && f_e&4 && c) continue;\n\t\tcat x = C[h][i] * C[w][j] % mod;\n\t\tint n_h = f_h, n_w = f_w;\n\t\tif(i) n_w ^= n_w&(1<<(1-c));\n\t\tif(j) n_h ^= n_h&(1<<(1-c));\n\t\tn_h |= 1<<c;\n\t\tn_w |= 1<<c;\n\t\tint n_e = f_e&1;\n\t\tif(!i) n_e |= 2;\n\t\tif(!j) n_e |= 4;\n\t\tcount(h-i, w-j, n_e, n_h, n_w, out, cur*x%mod);\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint H, W;\n\tcin >> H >> W;\n\tvector<int> V(H, 0);\n\tfor(int i = 0; i < H; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < W; j++)\n\t\t\tif(s[j] == '#') V[i] |= 1<<j;\n\t}\n\tmemset(C, 0, sizeof(C));\n\tfor(int i = 0; i <= 10; i++) {\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1; j <= i; j++)\n\t\t\tC[i][j] = (C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tint cnt[11][11];\n\tmemset(cnt, 0, sizeof(cnt));\n\tcount(1, 2, 1, 0, 0, cnt[0][0]);\n\tfor(int i = 0; i <= H; i++) for(int j = 0; j <= W; j++)\n\t\tcount(i, j, (H-i) || (W-j), 0, 0, cnt[i][j]);\n\tcat ans = cnt[H][W];\n\tfor(int i = 0; i < (1<<H)-1; i++) {\n\t\tvector<int> Vr, Vc(W, 0);\n\t\tfor(int j = 0; j < H; j++)\n\t\t\tif(!((i>>j)&1)) Vr.push_back(V[j]);\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tfor(int k = 0; k < H; k++)\n\t\t\t\tif(!((i>>k)&1)) Vc[j] += ((V[k]>>j)&1)<<k;\n\t\t\tVc[j] = (!Vc[j]) || (Vc[j] == (1<<H)-1-i);\n\t\t}\n\t\tint n = H-Vr.size();\n\t\tfor(int j = 0; j < (1<<W)-1; j++) {\n\t\t\tint m = (1<<W)-1-j;\n\t\t\tbool ok = true;\n\t\t\tfor(int k = 0; k < H-n; k++) if(!(Vr[k]&m) || (Vr[k]&m) == m) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tfor(int k = 0; k < W; k++) if(!((j>>k)&1) && Vc[k]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok) continue;\n\t\t\tans += cnt[n][__builtin_popcount(j)];\n\t\t\tif(ans >= mod) ans -= mod;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int N = 11, mod = 998244353;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nchar ss[N][N];\nint f[N][N], g[N][N], C[N][N];\nint bin[N], h1[1 << 10][N], h2[1 << 10][N];\n\nint main() {\n\treg n = read(), m = read();\n\tfo(i, 1, n) scanf(\"%s\", ss[i] + 1);\n\tC[0][0] = bin[0] = 1;\n\tfo(i, 1, N - 1) {\n\t\tC[i][0] = 1, bin[i] = bin[i - 1] << 1;\n\t\tfo(j, 1, i) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n\t} f[0][0] = 1;\n\tfo(s, 0, 2 * N - 2) fo(i, 0, _min(s, N - 1)) {\n\t\treg j = s - i; if(j >= N) continue;\n\t\tfo(k, 1, N - 1 - i) f[i + k][j] = (f[i + k][j] + (LL)f[j][i] * C[i + k][k]) % mod;\n\t} fo(i, 0, N - 1) fo(j, 0, i) f[i][j] = f[j][i] = (f[i][j] + f[j][i]) % mod; f[0][0] = 1;\n\tfo(i, 1, N - 1) fo(j, 1, N - 1) fo(x, 0, i) fo(y, 0, j) g[i][j] = (g[i][j] + (LL)f[x][y] * f[i - x][j - y] % mod * C[i][x] % mod * C[j][y]) % mod;\n\tfo(i, 1, bin[n] - 1) fo(j, 1, m){\n\t\tbool c1 = 0, c2 = 0;\n\t\tfo(k, 1, n) if(i >> k - 1 & 1) c1 |= ss[k][j] == '.', c2 |= ss[k][j] == '#';\n\t\th1[i][j] = c1 & c2;\n\t} fo(i, 1, bin[m] - 1) fo(j, 1, n) {\n\t\tbool c1 = 0, c2 = 0;\n\t\tfo(k, 1, m) if(i >> k - 1 & 1) c1 |= ss[j][k] == '.', c2 |= ss[j][k] == '#';\n\t\th2[i][j] = c1 & c2;\n\t} reg ans = f[n][m];\n\tfo(i, 1, bin[n] - 1) fo(j, 1, bin[m] - 1) {\n\t\treg s1 = n, s2 = m;\n\t\tbool c1 = 1, c2 = 1;\n\t\tfo(k, 1, n) if(i >> k - 1 & 1) c1 &= h2[j][k], s1--;\n\t\tfo(k, 1, m) if(j >> k - 1 & 1) c2 &= h1[i][k], s2--;\n\t\tif(!c1 || !c2) continue;\n\t\tif(!s1 && !s2) ans++;\n\t\telse if(!s1 || !s2) ans = (ans + bin[s1 + s2]) % mod;\n\t\telse ans = (ans + g[s1][s2]) % mod;\n\t} pr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//https://betrue12.hateblo.jp/entry/2020/01/19/170701\n//https://drken1215.hatenablog.com/entry/2020/02/02/134400\n\n#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define chmax(x,y) x = max(x,y)\n#define chmin(x,y) x = min(x,y)\n\nconst int mod = 1000000007;\nstruct mint {\nll x; \nmint(ll x=0):x((x%mod+mod)%mod){}\nmint operator-() const { return mint(-x);}\nmint& operator+=(const mint a) {\nif ((x += a.x) >= mod) x -= mod;\nreturn *this;\n }\nmint& operator-=(const mint a) {\nif ((x += mod-a.x) >= mod) x -= mod;\nreturn *this;\n }\n mint& operator*=(const mint a) {\n(x *= a.x) %= mod;\nreturn *this;\n}\nmint operator+(const mint a) const {\nmint res(*this);\nreturn res+=a;\n}\nmint operator-(const mint a) const {\nmint res(*this);\nreturn res-=a;\n}\n mint operator*(const mint a) const {\nmint res(*this);\nreturn res*=a;\n}\nmint pow(ll t) const {\nif (!t) return 1;\nmint a = pow(t>>1);\na *= a;\nif (t&1) a *= *this;\nreturn a;\n}\n mint inv() const {\nreturn pow(mod-2);\n }\n  mint& operator/=(const mint a) {\nreturn (*this) *= a.inv();\n }\nmint operator/(const mint a) const {\nmint res(*this);\nreturn res/=a;\n }\n};\nstruct combination {\nvector<mint> fact, ifact;\ncombination(int n):fact(n+1),ifact(n+1) {\n  assert(n < mod);\n fact[0] = 1;\n for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n ifact[n] = fact[n].inv();\n  for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n}\nmint operator()(int n, int k) {\nif (k < 0 || k > n) return 0;\nreturn fact[n]*ifact[k]*ifact[n-k];\n}\n  };\n\nint H,W;\nvector<string>A;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\n\n//初始化排列组合\n\ncombination c(20);\ncin>>H>>W;\nA.resize(H);\nrep(h,H)cin>>A[h];\n\n/*\ndp计算长方形的组合数\ndp1[a][b]表示长方形里有黑色线的组合数\ndp2[a][b]表示长方形里有黑色线的组合数\n\n横的有i个白线,竖的有j个白线的时候\ni和j必须大于0 \ndp2[a][b]+=c(a,i)*c(b,j)*dp2[a-i][b-j](1<=i<=a-1,1<=j<=b-1) \ndp2[a][b]+=1 (全白的情况有一种)\n\n横的有i个黑线，竖的有j个黑线的时候\ni和j不能同时为0\ndp1[a][b]+=c(a,i)*c(b,j)*dp2[a-i][b-j] (i+j>=1,i<=a-1,j<=b-1)\ndp1[a][b]+=1(全黑的情况有一种)\n*/\nvector<vector<mint>>R(15,vector<mint>(15,0));\nauto dp1=R;\nauto dp2=R;\nrep(i,15)R[0][i]=R[i][0]=mint(2).pow(i);\n\n//计算dp2\n\nfor(int a=1;a<15;a++)\n    for(int b=1;b<15;b++){\n        dp2[a][b]=1;\n        for(int i=1;i<a;i++)\n            for(int j=1;j<b;j++){\n                dp2[a][b]+=dp2[a-i][b-j]*c(a,i)*c(b,j);\n            }\n    }\n//计算dp1\n\nfor(int a=1;a<15;a++){\n    for(int b=1;b<15;b++){\n        dp1[a][b]=1;\n        for(int i=0;i<a;i++)\n            for(int j=0;j<b;j++){\n                if(i+j==0)continue;\n                dp1[a][b]+=dp2[a-i][b-j]*c(a,i)*c(b,j);\n            }\n        R[a][b]=dp1[a][b]+dp2[a][b];\n    }\n}\n\n/*\n计算L的组合数\nsumR[a][b] 表示两个交叉矩形的组合数的和\nsubR[a][b]表示竖的a个黑色横着b个白色的长方形组合数(先涂黑色)\n这里subR[a][b]=subR[b][a] \n*/\nvector<vector<mint>>L(15,vector<mint>(15,0));\nauto sumR=L,subR=L;\nrep(i,15){\n    subR[1][i]=1;\n    subR[i][1]=mint(2).pow(i)-1;\n}\nfor(int s=2;s<30;s++){\n    for(int a=1;a<15;a++){\n        int b=s-a;\n        if(b<1||b>=15)continue;\n        subR[a][b]=1;\n        for(int i=1;i<a;i++){\n            subR[a][b]+=c(a,i)*subR[b][a-i];//？\n        }\n    }\n}\n\nrep(a,15)rep(b,15){\n    if(a==0)sumR[a][b]=1;\n    else if(b==0)sumR[a][b]=1;\n    else sumR[a][b]=subR[a][b]+subR[b][a];\n}\n//竖方向黑色i个白色a-i个，横方向白色j个黑色b-j个 求i*j的长方形颜色组合数\nrep(i,15)L[0][i]=L[i][0]=mint(2).pow(i);\nfor(int a=1;a<14;a++)\n    for(int b=1;b<14;b++)\n        rep(i,a+1)\n            rep(j,b+1){\n                L[a][b]+=c(a,i)*c(b,j)*sumR[i][j]*sumR[a-i][b-j];\n            }\n\n\n    mint ans = R[H][W];\n    for (int bit = 0; bit < (1<<H)-1; ++bit) {\n        vector<int> tate;\n        for (int i = 0; i < H; ++i) if (!(bit & (1<<i))) tate.push_back(i);\n        for (int bit2 = 0; bit2 < (1<<W)-1; ++bit2) {\n            vector<int> yoko;\n            for (int i = 0; i < W; ++i) if (!(bit2 & (1<<i))) yoko.push_back(i);\n \n            //留下来的行或者列必须有两种颜色\n            bool ok = true;\n            for (auto i : tate) {\n                set<char> se;\n                for (auto j : yoko) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n            for (auto j : yoko) {\n                set<char> se;\n                for (auto i : tate) se.insert(A[i][j]);\n                if (se.size() != 2) ok = false;\n            }\n \n            if (ok) {\n                int c = __builtin_popcount(bit);\n                int r = __builtin_popcount(bit2);\n                mint add = L[c][r];\n                ans += add;\n            }\n        }\n    }\n    cout << ans.x << endl;\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for (int i=a;i<=b;i++)\n#define R(i,a,b) for (int i=a;i<int(b);i++)\n#define D(i,a,b) for (int i=a;i>=b;i--)\n#define go(i,x) for (int i=head[x];i;i=Next[i])\n#define pb push_back\n#define si size()\n#define fi first\n#define se second\n#define pa pair < ll,ll >\n#define ll long long\n#define mp make_pair\n#define be begin()\n#define en end()\n#define put putchar('\\n')\n#define gc getchar\n#define pc putchar\n#define N 600055\n#define mo 998244353\n#define inf 1000000007\n//#define int ll\n#define ret return puts(\"-1\"),0\nusing namespace std;\ninline ll read(){\n\tll su=0,f=1;char c=gc();\n\tfor (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;\n\tfor (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';\n\treturn su*f;\n}\ninline void wr(ll x){\n\tif (x<0) pc('-'),wr(-x);\n\telse{if (x>=10) wr(x/10);pc(x%10+'0');}\n}\ninline void wri(ll x){wr(x);pc(' ');}\ninline void wrn(ll x){wr(x);put;}\ninline void wrn(ll x,ll y){wri(x);wrn(y);}\ninline void wrn(ll x,ll y,ll z){wri(x);wrn(y,z);}\nint n,m,ans,a[105][105],b[105][105],f[105][105],vis[105],fl[105];\nchar str[N];\ninline void ad(int &x,int k){x+=k;x-=(x>=mo)?mo:0;}\nint ksm(ll x,int k){\n\tint su=1;\n\tfor (;k;k>>=1,x=x*x%mo) if (k&1) su=su*x%mo;\n\treturn su;\n}\nint fac[N],inv[N];\nint C(int n,int m){return (n<m||m<0)?0:1ll*fac[n]*inv[m]%mo*inv[n-m]%mo;}\nvoid init_c(int n){\n\tfac[0]=1;F(i,1,n) fac[i]=1ll*fac[i-1]*i%mo;\n\tinv[n]=ksm(fac[n],mo-2);D(i,n-1,0) inv[i]=1ll*inv[i+1]*(i+1)%mo;\n}\nint init(int n,int m){\n\tint ans=0;\n\tF(a,0,n) F(b,0,m){\n\t\tint t=1ll*C(n,a)*C(m,b)%mo\n\t\tad(ans,*ksm(m-b+1,a)%mo*ksm(b+1,n-a)%mo);\n\t}\n\treturn ans;\n}\nvoid check(){\n\tF(i,1,n) F(j,1,m) b[i][j]=a[i][j];\n\tF(i,1,n) if (vis[i]) F(j,1,m) b[i][j]=-1;\n\tF(j,1,m) if (vis[n+j]) F(i,1,n) b[i][j]=-1;\n\tF(i,1,n){\n\t\tfl[0]=fl[1]=0;\n\t\tF(j,1,m) if (b[i][j]!=-1) fl[b[i][j]]++;\n\t\tif (fl[0]==0||fl[1]==0) return;\n\t}\n\tF(j,1,m){\n\t\tfl[0]=fl[1]=0;\n\t\tF(i,1,n) if (b[i][j]!=-1) fl[b[i][j]]++;\n\t\tif (fl[0]==0||fl[1]==0) return;\n\t}\n\tint a=0,b=0;\n\tF(i,1,n) if (vis[i]) a++;\n\tF(i,1,m) if (vis[i+n]) b++;\n\tad(ans,f[a][b]);\n}\nvoid dfs(int x){\n\tif (x==n+m+1){\n\t\tcheck();return;\n\t}\n\tvis[x]=1;dfs(x+1);vis[x]=0;dfs(x+1);\t\n}\nsigned main(){\n\tn=read();m=read();init_c(1000);\n\tF(i,1,n){\n\t\tscanf(\"%s\",str+1);\n\t\tF(j,1,m) a[i][j]=(str[j]=='.')?1:0;\n\t}\n\tF(i,0,n) F(j,0,m) f[i][j]=init(i,j);\n\tF(i,0,n) F(j,0,m) wrn(i,j,f[i][j]);\n\tdfs(1);\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst long long mod = 998244353;\nlong long f[15], invf[15];\nlong long f0[15][15][2];\nlong long f1[15][15];\nlong long sum[15][15];\nchar s[15];\nint a[15][15];\nint b[15][15];\nint cnt[2005];\n\nlong long power(long long a,long long b){\n    long long res = 1;\n    while(b){\n        if(b&1) res = res*a%mod;\n        a = a*a%mod;\n        b /= 2;\n    }\n    return res;\n}\n\nlong long inv(long long u){ return power(u,mod-2); }\n\nvoid preWork(int n){\n    f[0] = invf[0] = 1;\n    for(long long i = 1; i <= n; i++){\n        f[i] = f[i-1]*i%mod;\n        invf[i] = inv(f[i]);\n    }\n    for(int i = 0; i < (1<<10); i++){\n        cnt[i] = 0;\n        int mask = i;\n        while(mask){\n            cnt[i] += mask%2;\n            mask /= 2;\n        }\n    }\n}\n\nlong long getC(int n,int m){\n    if(m>n || m<0) return 0;\n    else{\n        long long res = f[n];\n        res = res*invf[m]%mod;\n        res = res*invf[n-m]%mod;\n        return res;\n    }\n}\n\nint check(int n,int m){\n    for(int i = 1; i <= n; i++){\n        int cnt0 = 0, cnt1 = 0;\n        for(int j = 1; j <= m; j++){\n            if(b[i][j]!=-1){\n                if(b[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n        }\n        if(!cnt0 && cnt1) return 0;\n        if(!cnt1 && cnt0) return 0;\n    }\n    for(int j = 1; j <= m; j++){\n        int cnt0 = 0, cnt1 = 0;\n        for(int i = 1; i <= n; i++){\n            if(b[i][j]!=-1){\n                if(b[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n        }\n        if(!cnt0 && cnt1) return 0;\n        if(!cnt1 && cnt0) return 0;\n    }\n    return 1;\n}\n\nint main(){\n    preWork(10);\n    f0[0][0][0] = f0[0][0][1] = 1;\n    for(int i = 0; i <= 10; i++){\n        for(int j = 0; j <= 10; j++){\n            if(i || j){\n                f0[i][j][0] = f0[i][j][1] = 0;\n                for(int k = i-1; k >= 0; k--) f0[i][j][0] = (f0[i][j][0] + f0[k][j][1]*invf[i-k]%mod)%mod;\n                for(int k = j-1; k >= 0; k--) f0[i][j][1] = (f0[i][j][1] + f0[i][k][0]*invf[j-k]%mod)%mod;\n            }\n            if(i==0 && j==0) f1[i][j] = 1;\n            else{\n                f1[i][j] = (f0[i][j][0]+f0[i][j][1])%mod;\n                f1[i][j] = f1[i][j]*f[i]%mod;\n                f1[i][j] = f1[i][j]*f[j]%mod;\n            }\n            //printf(\"f1[%d][%d] = %lld\\n\",i,j,f1[i][j]);\n        }\n    }\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 1; i <= n; i++){ \n        scanf(\"%s\",s+1);\n        for(int j = 1; j <= m; j++){ \n            a[i][j] = s[j]=='.';\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            sum[i][j] = 0;\n            for(int x = 0; x <= i; x++){\n                for(int y = 0; y <= j; y++){\n                    long long count = getC(i,x)*getC(j,y)%mod;\n                    //black or white = column and row diff from color\n                    count = count*f1[x][y]%mod;\n                    count = count*f1[i-x][j-y]%mod;\n                    sum[i][j] = (sum[i][j]+count)%mod;\n                }\n            }\n        }\n    }\n    long long ans = f1[n][m];\n    for(int i = 0; i < (1<<n); i++){\n        for(int j = 0; j < (1<<m); j++){\n            if(!i && !j) continue;\n            for(int k = 0; k < n; k++){\n                for(int l = 0; l < m; l++){\n                    if(i&(1<<k) && j&(1<<l)) b[k+1][l+1] = a[k+1][l+1];\n                    else b[k+1][l+1] = -1;\n                    //if(i==3 && j==9) printf(\"%2d\",b[k][l]);\n                }\n                //if(i==3 && j==9) printf(\"\\n\");\n            }\n            if(check(n,m)!=0){ \n                //printf(\"i = %d, j = %d\\n\",i,j);\n                ans = (ans+sum[n-cnt[i]][m-cnt[j]])%mod;\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n    int h, w, n, max;\n    scanf(\"%d %d %d\",&h,&w,&n);\n\n    max = (h > w) ? h : w;\n    \n    printf(\"%d\\n\", (n + max - 1) / max);\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC optimize(\"O3\")\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007LL\n#define VERYBIG 2000000000000000007LL\n#define ULTRABIG 300000000000000000000LL\n\n#define MOD 1000000007LL\n#define FOD  998244353LL\n#define HOD 1000000009LL\n#define IOD  100000007LL\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n// #include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n// #include <functional>\n// #include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n// using std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n// using std::get;\n// using std::function;\n// using std::array;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\ndouble dmin (double x, double y) {\n\treturn (x < y) ? x : y;\n}\n\ndouble dmax (double x, double y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\nvoid uw (ull *l, ull *r) {\n\tif (*l == *r) return;\n\tull t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 3], invf[N_MAX * 3];\nvoid f_init (ull n, ull m) {\n\tfrac[0] = 1;\n\tfor (sll i = 1; i <= n; i++) {\n\t\tfrac[i] = frac[i - 1] * i % m;\n\t}\n\n\tinvf[n] = divide(1, frac[n], m);\n\tfor (sll i = n - 1; i >= 0; i--) {\n\t\tinvf[i] = invf[i + 1] * (i + 1) % m;\n\t}\n}\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX * 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX * 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX * 5];\nsll d[N_MAX * 5];\nsll e[N_MAX * 4];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\nsll table[2005][2005];\null gin[N_MAX];\n// here we go\n\null dp[30][30][5];\null dq[30][30];\n\null dr[30][30];\n\nbool has[100];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tf_init(50, FOD);\n\n\n\tfor (sum = 1; sum <= 20; sum++) {\n\t\tfor (i = 1; i < sum; i++) {\n\t\t\tj = sum - i;\n\t\t\t// if (j == 0) {\n\t\t\t// \tdp[i][j] = 1;\n\t\t\t// \tcontinue;\n\t\t\t// }\n\t\t\t// if (i == 0) {\n\t\t\t// \tdp[i][j] = 1;\n\t\t\t// \tcontinue;\n\t\t\t// }\n\n\t\t\t// dp[i][j] = bitpow(2, j, FOD) - 1;\n\t\t\t// for (ki = 1; ki < i; ki++) {\n\t\t\t// \titem = dp[j][i - ki] * ncr(i, ki, FOD) % FOD;\n\t\t\t// \tdp[i][j] += item * (FOD - 2 + bitpow(2, ki, FOD)) % FOD;\n\t\t\t// }\n\t\t\t// for (ki = 1; ki < i; ki++) {\n\t\t\t// \tfor (li = 1; li < j; li++) {\n\t\t\t// \t\tif (ki == i && li == j) continue;\n\t\t\t// \t\tdp[i][j] += (\n\t\t\t// \t\t\tncr(i, ki, FOD) * ncr(j, li, FOD) % FOD) * dp[ki][li] % FOD;\n\t\t\t// \t}\n\t\t\t// }\n\t\t\t// dp[i][j] %= FOD;\n\n\t\t\tdp[i][j][0] = 1;\n\t\t\tdp[i][j][2] = 1;\n\t\t\tfor (ki = 1; ki < i; ki++) {\n\t\t\t\tfor (li = 1; li < j; li++) {\n\t\t\t\t\titem = (ncr(i, ki, FOD) * ncr(j, li, FOD) % FOD);\n\t\t\t\t\tdp[i][j][0] += item * (dp[li][ki][2] + dp[li][ki][3] + dp[ki][li][3]) % FOD;\n\t\t\t\t\tdp[i][j][2] += item * (dp[li][ki][0] + dp[li][ki][1] + dp[ki][li][1]) % FOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j][0] %= FOD;\n\t\t\tdp[i][j][2] %= FOD;\n\n\t\t\tdp[i][j][1] = 0;\n\t\t\tdp[i][j][3] = 0;\n\t\t\tfor (ki = 1; ki < i; ki++) {\n\t\t\t\tfor (li = j; li <= j; li++) {\n\t\t\t\t\titem = (ncr(i, ki, FOD) * ncr(j, li, FOD) % FOD);\n\t\t\t\t\tdp[i][j][1] += item * (FOD + dp[li][ki][3]) % FOD;\n\t\t\t\t\tdp[i][j][3] += item * (FOD + dp[li][ki][1]) % FOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j][1] %= FOD;\n\t\t\tdp[i][j][3] %= FOD;\n\n\t\t\tdp[i][j][4] = (FOD + bitpow(2, i, FOD) - 2) % FOD;\n\t\t\t// printf(\"first %lld\\n\", dp[i][j][4]);\n\t\t\tfor (ki = 1; ki < i; ki++) {\n\t\t\t\titem = ((dp[j][ki][1] + dp[j][ki][3] + dp[j][ki][4]) * ncr(i, ki, FOD)) % FOD;\n\t\t\t\tdp[i][j][4] += ((FOD + bitpow(2, i - ki, FOD) - 2) * item) % FOD;\n\t\t\t\t// printf(\"%lld * %lld\\n\", (FOD + bitpow(2, i - ki, FOD) - 2), item);\n\t\t\t}\n\t\t\tdp[i][j][4] %= FOD;\n\t\t}\n\t}\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tdq[i][j] = (\n\t\t\t\tdp[i][j][0] + dp[i][j][1] + dp[j][i][1] +\n\t\t\t\tdp[i][j][2] + dp[i][j][3] + dp[j][i][3] +\n\t\t\t\t              dp[i][j][4] + dp[j][i][4]) % FOD;\n\t\t}\n\t}\n\n\t// for (i = 0; i <= 10; i++) {\n\t// \tfor (j = 0; j <= 10; j++) {\n\t// \t\tprintf(\"%lld %lld: %lld %lld %lld %lld %lld\\n\", i, j, dp[i][j][0], dp[i][j][1], dp[i][j][2], dp[i][j][3], dp[i][j][4]);\n\t// \t\tprintf(\"%lld %lld: %lld\\n\", i, j, dq[i][j]);\n\t// \t}\n\t// }\n\n\tresult = dq[h][w];\n\n\t// printf(\"%lld..\\n\", result);\n\n\tdq[0][0] = 1;\n\tfor (i = 1; !(i >> h); i++) {\n\t\tfor (j = 1; !(j >> w); j++) {\n\t\t\tif (i != ((1LL << h) - 1) && j == ((1LL << w) - 1)) continue;\n\n\t\t\tbool isok = false;\n\n\t\t\tfor (ki = 0; ki < h; ki++) {\n\t\t\t\tif (!(i & (1LL << ki))) continue;\n\t\t\t\tull has = 0;\n\t\t\t\tfor (li = 0; li < w; li++) {\n\t\t\t\t\tif (!(j & (1LL << li))) continue;\n\n\t\t\t\t\tif (s[ki][li] == '.') has |= 1LL;\n\t\t\t\t\telse has |= 2LL;\n\t\t\t\t}\n\t\t\t\tif (has != 3) break;\n\t\t\t}\n\t\t\tif (ki < h) continue;\n\n\t\t\tfor (li = 0; li < w; li++) {\n\t\t\t\tif (!(j & (1LL << li))) continue;\n\t\t\t\tull has = 0;\n\t\t\t\tfor (ki = 0; ki < h; ki++) {\n\t\t\t\t\tif (!(i & (1LL << ki))) continue;\n\n\t\t\t\t\tif (s[ki][li] == '.') has |= 1LL;\n\t\t\t\t\telse has |= 2LL;\n\t\t\t\t}\n\t\t\t\tif (has != 3) break;\n\t\t\t}\n\t\t\tif (li < w) continue;\n\n\t\t\t// printf(\"%lld %lld ?\\n\", i, j);\n\n\t\t\tull hi = 0, wi = 0;\n\t\t\tfor (ki = 0; ki < h; ki++) {\n\t\t\t\tif (!(i & (1LL << ki))) hi++;\n\t\t\t}\n\t\t\tfor (li = 0; li < w; li++) {\n\t\t\t\tif (!(j & (1LL << li))) wi++;\n\t\t\t}\n\n\t\t\tif (hi * wi == 0) {\n\t\t\t\tresult += bitpow(2, hi + wi, FOD);\n\t\t\t} else {\n\t\t\t\tresult += dq[hi][wi];\n\t\t\t}\n\n\t\t\t// printf(\"+ %lld %lld s %lld\\n\", hi, wi, dq[hi][wi]);\n\t\t}\n\t}\n\tresult %= FOD;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\th = 5;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &n, &m);\n\t// scanf(\"%lld\", &k, &n, &m);\n\tscanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%lld\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\" %c\", &ch);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%lld%lld\", &va, &vb);\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", t);\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// scanf(\"%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\tfor (i = 0; i < h; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t}\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", t[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld%lld\", &e[i], &c[i], &d[i]);\n\t// \tc[i]--;\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    public static final int m = 998_244_353;\n    private static final BigInteger bigM = BigInteger.valueOf(m);\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int h = scanner.nextInt();\n        int w = scanner.nextInt();\n        scanner.nextLine();\n        boolean[][] field = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            String s = scanner.nextLine();\n            for (int j = 0; j < w; j++) {\n                field[i][j] = s.charAt(j)=='#';\n            }\n        }\n        System.out.println(numberOfDrawings(field));\n    }\n\n    public static int numberOfDrawings(boolean[][] field){\n        int h = field.length;\n        int w = field[0].length;\n        int[][] coeffs = getCoeffs(h, w);\n        int[][] nRects = new int[h+1][w+1];\n        int[] rowMask = IntStream.range(0,h).map(i->IntStream.range(0, w).filter(j->field[i][j]).map(j->1<<j).sum()).toArray();\n        int[] colMask = IntStream.range(0,w).map(j->IntStream.range(0, h).filter(i->field[i][j]).map(i->1<<i).sum()).toArray();\n        int badRowsMask = 0;\n        int badColMask = 0;\n\n        for (int i = 0; i < h; i++) {\n            if(\n                    ((rowMask[i]&i)==0)\n                    ||\n                    (((~rowMask[i])&i)==0)\n            ){\n                badRowsMask |= 1<<i;\n            }\n        }\n\n        for (int i = 0; i < w; i++) {\n            if(\n                    ((colMask[i]&i)==0)\n                            ||\n                            (((~colMask[i])&i)==0)\n            ){\n                badColMask |= 1<<i;\n            }\n        }\n\n        for (int chosenRows = 0; chosenRows < 1 << h; chosenRows++) {\n            if((badRowsMask & chosenRows)!=0) continue;\n            int bitH = Integer.bitCount(chosenRows);\n            for (int chosenCols = 0; chosenCols < 1 << w; chosenCols++) {\n                if((badColMask & chosenCols)!=0) continue;\n                boolean failed = false;\n                for (int row = 0; row < h; row++) {\n                    if(((1<<row)&chosenRows)!=0){\n                        if(\n                                ((rowMask[row]&chosenCols)==0)\n                                        ||\n                                        (((~rowMask[row])&chosenCols)==0)\n                        ){\n                            failed = true;\n                            break;\n                        }\n                    }\n                }\n                if(failed) continue;\n                for (int col = 0; col < w; col++) {\n                    if(((1<<col)&chosenCols)!=0){\n                        if(\n                                ((colMask[col]&chosenRows)==0)\n                                        ||\n                                        (((~colMask[col])&chosenRows)==0)\n                        ){\n                            failed = true;\n                            break;\n                        }\n                    }\n                }\n                if(failed) continue;\n                int bitW = Integer.bitCount(chosenCols);\n                nRects[h-bitH][w-bitW]++;\n            }\n        }\n\n        long result = 0;\n        for (int i = 0; i <=h; i++) {\n            for (int j = 0; j <=w; j++) {\n                result += nRects[i][j]*coeffs[i][j];\n            }\n        }\n        return (int)(result % m);\n    }\n\n    public static int[][] getCoeffs(int h, int w){\n        final boolean[][] transitions = new boolean[][]{ //i - после, j - до\n        //       0     a     b     c     d     ab    cd    ac    bd\n                {false,false,false,false,false,false,false,false,false}, //0\n                {true ,false,false,false,true ,false,true ,false,true }, //a\n                {true ,false,false,true ,false,false,true ,true ,false}, //b\n                {true ,false,true ,false,false,true ,false,false,true }, //c\n                {true ,true ,false,false,false,true ,false,true ,false}, //d\n                {true ,false,false,true ,true ,false,true ,true ,true }, //ab\n                {true ,true ,true ,false,false,true ,false,true ,true }, //cd\n                {true ,false,true ,false,true ,true ,true ,false,true }, //ac\n                {true ,true ,false,true ,false,true ,true ,true ,false}, //bd\n        };\n        final int maxWH = Math.max(h, w);\n        final BigInteger[][] c = new BigInteger[maxWH+1][maxWH+1];\n        deepFill(c, BigInteger.ZERO);\n        for (int i = 0; i <= maxWH; i++) {\n            c[0][i]=BigInteger.ONE;\n        }\n        for (int i = 1; i <= maxWH; i++) {\n            for (int j = i; j <= maxWH; j++) {\n                c[i][j] = c[i-1][j].multiply(BigInteger.valueOf(j-i+1)).divide(BigInteger.valueOf(i));\n            }\n        }\n\n        BigInteger[][][] coeffs = new BigInteger[h+1][w+1][9];\n        deepFill(coeffs, BigInteger.ZERO);\n\n        for (int i = 0; i < transitions.length; i++) {\n            coeffs[0][0][i] = BigInteger.ONE;\n        }\n\n        for (int i = 0; i <= h; i++) {\n            for (int j = 0; j <= w; j++) {\n                for (int k = 0; k < transitions.length; k++) {\n                    for (int l = 0; l < transitions[k].length; l++) {\n                        if(transitions[k][l]){\n                            switch (k){\n                                case 0: //до этого был пустой\n                                    break;\n                                case 1: //до этого покрасиили несколько рядов белым\n                                case 2: //до этого покрасиили несколько рядов черным\n                                    for (int n = 1; n <=h-i ; n++) {\n                                        coeffs[i+n][j][l] = coeffs[i+n][j][l].add(coeffs[i][j][k].multiply(c[n][i+n]));\n                                    }\n                                    break;\n                                case 3: //до этого покрасиили несколько стобцов белым\n                                case 4: //до этого покрасиили несколько стобвоц черным\n                                    for (int n = 1; n <=w-j ; n++) {\n                                        coeffs[i][j+n][l] = coeffs[i][j+n][l].add(coeffs[i][j][k].multiply(c[n][j+n]));\n                                    }\n                                    break;\n                                case 5: //до этого покрасиили несколько рядов белым и черным\n                                    for (int n = 1; n <=h-i-1 ; n++) {\n                                        for (int p = 1; p <= h-i-n; p++) {\n                                            coeffs[i+n+p][j][l] = coeffs[i+n+p][j][l].add(coeffs[i][j][k].multiply(c[n][i+n+p]).multiply(c[p][i+p]));\n                                        }\n                                    }\n                                    break;\n                                case 6: //до этого покрасиили несколько столбцов белым и черным\n                                    for (int n = 1; n <=w-j-1 ; n++) {\n                                        for (int p = 1; p <= w-j-n; p++) {\n                                            coeffs[i][j+n+p][l] = coeffs[i][j+n+p][l].add(coeffs[i][j][k].multiply(c[n][j+n+p]).multiply(c[p][j+p]));\n                                        }\n                                    }\n                                    break;\n                                case 7: //до этого покрасиили несколько столбцов и строк белым\n                                case 8: //до этого покрасиили несколько столбцов и строк черным\n                                    for (int n = 1; n <= h-i ; n++) {\n                                        for (int p = 1; p <= w-j; p++) {\n                                            coeffs[i+n][j+p][l] = coeffs[i+n][j+p][l].add(coeffs[i][j][k].multiply(c[n][i+n]).multiply(c[p][j+p]));\n                                        }\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int[][] result = new int[h+1][w+1];\n        for (int i = 0; i <= h; i++) {\n            for (int j = 0; j <= w; j++) {\n                result[i][j] = coeffs[i][j][0].mod(bigM).intValue();\n            }\n        }\n//        System.out.println(Arrays.deepToString(result));\n        return result;\n    }\n\n    public static void deepFill(Object[] arr, Object val){\n        if(isArray(arr[0])){\n            for (Object o : arr) {\n                deepFill((Object[]) o, val);\n            }\n        }else{\n            Arrays.fill(arr, val);\n        }\n    }\n\n    public static boolean isArray(final Object obj) {\n        return obj instanceof Object[] || obj instanceof boolean[] ||\n                obj instanceof byte[] || obj instanceof short[] ||\n                obj instanceof char[] || obj instanceof int[] ||\n                obj instanceof long[] || obj instanceof float[] ||\n                obj instanceof double[];\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\n\na = $stdin.read.delete(\"^.#\").tr(\".#\", \"01\").to_i(2)\nbits_h = (\"1\" * h).to_i(2)\nbits_w = ((\"0\" * (h - 1) + \"1\") * w).to_i(2)\n\nr = Array.new(2 ** (h * w))\nr[a] = a\nq = [a]\n\nwhile a = q.shift\n  h.times do |i|\n    bits = bits_h << (w * i)\n    x, y = a | bits, a & ~bits\n    q << (r[x] = x) unless r[x]\n    q << (r[y] = y) unless r[y]\n  end\n  w.times do |i|\n    bits = bits_w << i\n    x, y = a | bits, a & ~bits\n    q << (r[x] = x) unless r[x]\n    q << (r[y] = y) unless r[y]\n  end\nend\n\nputs r.count(&:itself) % 998_244_353\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998_244_353;\nalias Mint = ModInt!MO;\n\nenum LIM = 100;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\nvoid main() {\n  prepare();\n  auto S = new Mint[][](LIM, LIM);\n  foreach (n; 0 .. LIM) {\n    S[n][0] = 0;\n    S[n][n] = 1;\n    foreach (k; 1 .. n) {\n      S[n][k] = S[n - 1][k - 1] + k * S[n - 1][k];\n    }\n  }\n  \n  /*\n  debug {\n    foreach (h; 1 .. 5 + 1) foreach (w; 1 .. 5 + 1) {\n      foreach (p; 0 .. 1 << (h * w)) {\n        auto a = new int[][](h, w);\n        foreach (x; 0 .. h) foreach (y; 0 .. w) {\n          a[x][y] = (p >> (x * w + y)) & 1;\n        }\n        int rows, cols;\n        foreach (x0; 0 .. h) foreach (x1; 0 .. h) foreach (y0; 0 .. w) foreach (y1; 0 .. w) {\n          if (a[x0][y0] == 0 &&\n              a[x0][y1] == 1 &&\n              a[x1][y0] == 1 &&\n              a[x1][y1] == 0) {\n            rows |= 1 << x0 | 1 << x1;\n            cols |= 1 << y0 | 1 << y1;\n          }\n        }\n        const hos = (rows == (1 << h) - 1 && cols == (1 << w) - 1);\n        bool ysp = true;\n        foreach (x; 0 .. h) {\n          ysp = ysp && !iota(w).all!(y => (a[x][y] == 0));\n          ysp = ysp && !iota(w).all!(y => (a[x][y] == 1));\n        }\n        foreach (y; 0 .. w) {\n          ysp = ysp && !iota(h).all!(x => (a[x][y] == 0));\n          ysp = ysp && !iota(h).all!(x => (a[x][y] == 1));\n        }\n        if (hos != ysp) {\n          foreach (x; 0 .. h) {\n            writeln(a[x]);\n          }\n          writeln(hos, \" \", ysp);\n          assert(false);\n        }\n      }\n    }\n  }\n  */\n  \n  try {\n    for (; ; ) {\n      const H = readInt();\n      const W = readInt();\n      auto A = new string[H];\n      foreach (x; 0 .. H) {\n        A[x] = readToken();\n      }\n      \n      debug {\n        if (H * W <= 20) {\n          long brt;\n          foreach (p; 0 .. 1 << (H * W)) {\n            auto b = new int[][](H, W);\n            foreach (x; 0 .. H) foreach (y; 0 .. W) {\n              b[x][y] = (p >> (x * W + y)) & 1;\n            }\n            bool ok = true;\n            bool orig = false;\n            foreach (x0; 0 .. H) foreach (x1; 0 .. H) foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (b[x0][y0] == 0 &&\n                  b[x0][y1] == 1 &&\n                  b[x1][y0] == 1 &&\n                  b[x1][y1] == 0) {\n                if (A[x0][y0] == '.' &&\n                    A[x0][y1] == '#' &&\n                    A[x1][y0] == '#' &&\n                    A[x1][y1] == '.') {\n                  orig = true;\n                } else {\n                  ok = false;\n                }\n              }\n            }\n            if (ok) {\n              ++brt;\n              /*\n              if (orig) {\n                foreach (x; 0 .. H) {\n                  writeln(b[x]);\n                }\n                writeln();\n              }\n              //*/\n            }\n          }\n          writeln(brt);\n        }\n      }\n      \n      auto waf = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        foreach (i; 0 .. min(h, w) + 2) {\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i + 1] * S[h][i] * S[w][i + 1];\n          waf[h][w] += fac[i + 1] * fac[i] * S[h][i + 1] * S[w][i];\n        }\n      }\n      waf[0][0] = 1;\n      debug {\n        foreach (h; 0 .. H + 1) {\n          writefln(\"waf[%s] = %s\", h, waf[h]);\n        }\n      }\n      \n      auto pre = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        if (h == H && w == W) {\n          foreach (i; 0 .. min(h, w) + 1) {\n            pre[h][w] += fac[i]^^2 * S[h + 1][i + 1] * S[w + 1][i + 1];\n          }\n        } else if (h < H && w < W) {\n          foreach (i; 0 .. h + 1) foreach (j; 0 .. w + 1) {\n            Mint tmp = binom(h, i) * binom(w, j);\n            // if (i > 0 && w - j > 0) tmp *= fac[i + (w - j)];\n            // if (h - i > 0 && j > 0) tmp *= fac[(h - i) + j];\n            tmp *= waf[i][w - j];\n            tmp *= waf[h - i][j];\n            pre[h][w] += tmp;\n          }\n        }\n      }\n      \n      Mint ans;\n      /*\n      foreach (p; 0 .. 1 << H) {\n        alias Entry = Tuple!(int, \"row\", int, \"col\");\n        Entry[] es;\n        foreach (x0; 0 .. H) foreach (x1; 0 .. H) {\n          if ((p & 1 << x0) && (p & 1 << x1)) {\n            foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (A[x0][y0] == '.' &&\n                  A[x0][y1] == '#' &&\n                  A[x1][y0] == '#' &&\n                  A[x1][y1] == '.') {\n                es ~= Entry(1 << x0 | 1 << x1, 1 << y0 | 1 << y1);\n              }\n            }\n          }\n        }\n        foreach (q; 0 .. 1 << W) {\n          int pp, qq;\n          foreach (ref e; es) {\n            if ((q & e.col) == e.col) {\n              pp |= e.row;\n              qq |= e.col;\n            }\n          }\n          if (p == pp && q == qq) {\n            const h = H - popcnt(p);\n            const w = W - popcnt(q);\n            debug {\n              // writeln(p, \" \", q, \"; \", h, \" \", w, \": \", pre[h][w]);\n            }\n            assert((h == H) == (w == W));\n            ans += pre[h][w];\n          }\n        }\n      }\n      */\n      \n      auto rows = new int[H];\n      auto cols = new int[W];\n      foreach (x; 0 .. H) foreach (y; 0 .. W) {\n        if (A[x][y] == '#') {\n          rows[x] |= 1 << y;\n          cols[y] |= 1 << x;\n        }\n      }\n      foreach (p; 0 .. 1 << H) foreach (q; 0 .. 1 << W) {\n        bool ok = true;\n        foreach (x; 0 .. H) {\n          if (p & 1 << x) {\n            ok = ok && ((rows[x] & q) != 0 && (rows[x] & q) != q);\n          }\n        }\n        foreach (y; 0 .. W) {\n          if (q & 1 << y) {\n            ok = ok && ((cols[y] & p) != 0 && (cols[y] & p) != p);\n          }\n        }\n        if (ok) {\n          const h = H - popcnt(p);\n          const w = W - popcnt(q);\n          debug {\n            // writeln(p, \" \", q, \"; \", h, \" \", w, \": \", pre[h][w]);\n          }\n          assert((h == H) == (w == W));\n          ans += pre[h][w];\n        }\n      }\n      \n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998_244_353;\nalias Mint = ModInt!MO;\n\nenum LIM = 100;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\nvoid main() {\n  prepare();\n  auto S = new Mint[][](LIM, LIM);\n  foreach (n; 0 .. LIM) {\n    S[n][0] = 0;\n    S[n][n] = 1;\n    foreach (k; 1 .. n) {\n      S[n][k] = S[n - 1][k - 1] + k * S[n - 1][k];\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      const H = readInt();\n      const W = readInt();\n      auto A = new string[H];\n      foreach (x; 0 .. H) {\n        A[x] = readToken();\n      }\n      \n      debug {\n        if (H * W <= 20) {\n          long brt;\n          foreach (p; 0 .. 1 << (H * W)) {\n            auto b = new int[][](H, W);\n            foreach (x; 0 .. H) foreach (y; 0 .. W) {\n              b[x][y] = (p >> (x * W + y)) & 1;\n            }\n            bool ok = true;\n            bool orig = false;\n            foreach (x0; 0 .. H) foreach (x1; 0 .. H) foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (b[x0][y0] == 0 &&\n                  b[x0][y1] == 1 &&\n                  b[x1][y0] == 1 &&\n                  b[x1][y1] == 0) {\n                if (A[x0][y0] == '.' &&\n                    A[x0][y1] == '#' &&\n                    A[x1][y0] == '#' &&\n                    A[x1][y1] == '.') {\n                  orig = true;\n                } else {\n                  ok = false;\n                }\n              }\n            }\n            if (ok) {\n              ++brt;\n              /*\n              if (orig) {\n                foreach (x; 0 .. H) {\n                  writeln(b[x]);\n                }\n                writeln();\n              }\n              //*/\n            }\n          }\n          writeln(brt);\n        }\n      }\n      \n      auto waf = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        foreach (i; 0 .. min(h, w) + 2) {\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i + 1] * S[h][i] * S[w][i + 1];\n          waf[h][w] += fac[i + 1] * fac[i] * S[h][i + 1] * S[w][i];\n        }\n      }\n      waf[0][0] = 1;\n      debug {\n        foreach (h; 0 .. H + 1) {\n          writefln(\"waf[%s] = %s\", h, waf[h]);\n        }\n      }\n      \n      auto pre = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        if (h == H && w == W) {\n          foreach (i; 0 .. min(h, w) + 1) {\n            pre[h][w] += fac[i]^^2 * S[h + 1][i + 1] * S[w + 1][i + 1];\n          }\n        } else if (h < H && w < W) {\n          foreach (i; 0 .. h + 1) foreach (j; 0 .. w + 1) {\n            Mint tmp = binom(h, i) * binom(w, j);\n            // if (i > 0 && w - j > 0) tmp *= fac[i + (w - j)];\n            // if (h - i > 0 && j > 0) tmp *= fac[(h - i) + j];\n            tmp *= waf[i][w - j];\n            tmp *= waf[h - i][j];\n            pre[h][w] += tmp;\n          }\n        }\n      }\n      \n      Mint ans;\n      foreach (p; 0 .. 1 << H) {\n        alias Entry = Tuple!(int, \"row\", int, \"col\");\n        Entry[] es;\n        foreach (x0; 0 .. H) foreach (x1; 0 .. H) {\n          if ((p & 1 << x0) && (p & 1 << x1)) {\n            foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (A[x0][y0] == '.' &&\n                  A[x0][y1] == '#' &&\n                  A[x1][y0] == '#' &&\n                  A[x1][y1] == '.') {\n                es ~= Entry(1 << x0 | 1 << x1, 1 << y0 | 1 << y1);\n              }\n            }\n          }\n        }\n        foreach (q; 0 .. 1 << W) {\n          int pp, qq;\n          foreach (ref e; es) {\n            if ((q & e.col) == e.col) {\n              pp |= e.row;\n              qq |= e.col;\n            }\n          }\n          if (p == pp && q == qq) {\n            const h = H - popcnt(p);\n            const w = W - popcnt(q);\n            debug {\n              writeln(p, \" \", q, \"; \", h, \" \", w, \": \", pre[h][w]);\n            }\n            assert((h == H) == (w == W));\n            ans += pre[h][w];\n          }\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998_244_353;\nalias Mint = ModInt!MO;\n\nenum LIM = 100;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\nvoid main() {\n  prepare();\n  auto S = new Mint[][](LIM, LIM);\n  foreach (n; 0 .. LIM) {\n    S[n][0] = 0;\n    S[n][n] = 1;\n    foreach (k; 1 .. n) {\n      S[n][k] = S[n - 1][k - 1] + k * S[n - 1][k];\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      const H = readInt();\n      const W = readInt();\n      auto A = new string[H];\n      foreach (x; 0 .. H) {\n        A[x] = readToken();\n      }\nforeach(x;0..H)foreach(y;0..W)if(!(A[x][y]=='.'||A[x][y]=='#'))for(;;){}\n      \n      debug {\n        if (H * W <= 20) {\n          long brt;\n          foreach (p; 0 .. 1 << (H * W)) {\n            auto b = new int[][](H, W);\n            foreach (x; 0 .. H) foreach (y; 0 .. W) {\n              b[x][y] = (p >> (x * W + y)) & 1;\n            }\n            bool ok = true;\n            bool orig = false;\n            foreach (x0; 0 .. H) foreach (x1; 0 .. H) foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (b[x0][y0] == 0 &&\n                  b[x0][y1] == 1 &&\n                  b[x1][y0] == 1 &&\n                  b[x1][y1] == 0) {\n                if (A[x0][y0] == '.' &&\n                    A[x0][y1] == '#' &&\n                    A[x1][y0] == '#' &&\n                    A[x1][y1] == '.') {\n                  orig = true;\n                } else {\n                  ok = false;\n                }\n              }\n            }\n            if (ok) {\n              ++brt;\n              /*\n              if (orig) {\n                foreach (x; 0 .. H) {\n                  writeln(b[x]);\n                }\n                writeln();\n              }\n              //*/\n            }\n          }\n          writeln(brt);\n        }\n      }\n      \n      auto waf = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        foreach (i; 0 .. min(h, w) + 2) {\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i + 1] * S[h][i] * S[w][i + 1];\n          waf[h][w] += fac[i + 1] * fac[i] * S[h][i + 1] * S[w][i];\n        }\n      }\n      waf[0][0] = 1;\n      debug {\n        foreach (h; 0 .. H + 1) {\n          writefln(\"waf[%s] = %s\", h, waf[h]);\n        }\n      }\n      \n      auto pre = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        if (h == H && w == W) {\n          foreach (i; 0 .. min(h, w) + 1) {\n            pre[h][w] += fac[i]^^2 * S[h + 1][i + 1] * S[w + 1][i + 1];\n          }\n        } else if (h < H && w < W) {\n          foreach (i; 0 .. h + 1) foreach (j; 0 .. w + 1) {\n            Mint tmp = binom(h, i) * binom(w, j);\n            // if (i > 0 && w - j > 0) tmp *= fac[i + (w - j)];\n            // if (h - i > 0 && j > 0) tmp *= fac[(h - i) + j];\n            tmp *= waf[i][w - j];\n            tmp *= waf[h - i][j];\n            pre[h][w] += tmp;\n          }\n        }\n      }\n      \n      Mint ans;\n      foreach (p; 0 .. 1 << H) {\n        alias Entry = Tuple!(int, \"row\", int, \"col\");\n        Entry[] es;\n        foreach (x0; 0 .. H) foreach (x1; 0 .. H) {\n          if ((p & 1 << x0) && (p & 1 << x1)) {\n            foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (A[x0][y0] == '.' &&\n                  A[x0][y1] == '#' &&\n                  A[x1][y0] == '#' &&\n                  A[x1][y1] == '.') {\n                es ~= Entry(1 << x0 | 1 << x1, 1 << y0 | 1 << y1);\n              }\n            }\n          }\n        }\n        foreach (q; 0 .. 1 << W) {\n          int pp, qq;\n          foreach (ref e; es) {\n            if ((q & e.col) == e.col) {\n              pp |= e.row;\n              qq |= e.col;\n            }\n          }\n          if (p == pp && q == qq) {\n            const h = H - popcnt(p);\n            const w = W - popcnt(q);\n            debug {\n              writeln(p, \" \", q, \"; \", h, \" \", w, \": \", pre[h][w]);\n            }\n            assert((h == H) == (w == W));\n            ans += pre[h][w];\n          }\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998_244_353;\nalias Mint = ModInt!MO;\n\nenum LIM = 100;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\nvoid main() {\n  prepare();\n  auto S = new Mint[][](LIM, LIM);\n  foreach (n; 0 .. LIM) {\n    S[n][0] = 0;\n    S[n][n] = 1;\n    foreach (k; 1 .. n) {\n      S[n][k] = S[n - 1][k - 1] + k * S[n - 1][k];\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      const H = readInt();\n      const W = readInt();\n      auto A = new string[H];\n      foreach (x; 0 .. H) {\n        A[x] = readToken();\n      }\n      \n      debug {\n        if (H * W <= 20) {\n          long brt;\n          foreach (p; 0 .. 1 << (H * W)) {\n            auto b = new int[][](H, W);\n            foreach (x; 0 .. H) foreach (y; 0 .. W) {\n              b[x][y] = (p >> (x * W + y)) & 1;\n            }\n            bool ok = true;\n            bool orig = false;\n            foreach (x0; 0 .. H) foreach (x1; 0 .. H) foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (b[x0][y0] == 0 &&\n                  b[x0][y1] == 1 &&\n                  b[x1][y0] == 1 &&\n                  b[x1][y1] == 0) {\n                if (A[x0][y0] == '.' &&\n                    A[x0][y1] == '#' &&\n                    A[x1][y0] == '#' &&\n                    A[x1][y1] == '.') {\n                  orig = true;\n                } else {\n                  ok = false;\n                }\n              }\n            }\n            if (ok) {\n              ++brt;\n              /*\n              if (orig) {\n                foreach (x; 0 .. H) {\n                  writeln(b[x]);\n                }\n                writeln();\n              }\n              //*/\n            }\n          }\n          writeln(brt);\n        }\n      }\n      \n      auto waf = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        foreach (i; 0 .. min(h, w) + 2) {\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i + 1] * S[h][i] * S[w][i + 1];\n          waf[h][w] += fac[i + 1] * fac[i] * S[h][i + 1] * S[w][i];\n        }\n      }\n      waf[0][0] = 1;\n      debug {\n        foreach (h; 0 .. H + 1) {\n          writefln(\"waf[%s] = %s\", h, waf[h]);\n        }\n      }\n      \n      auto pre = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        if (h == H && w == W) {\n          foreach (i; 0 .. min(h, w) + 1) {\n            pre[h][w] += fac[i]^^2 * S[h + 1][i + 1] * S[w + 1][i + 1];\n          }\n        } else if (h < H && w < W) {\n          foreach (i; 0 .. h + 1) foreach (j; 0 .. w + 1) {\n            Mint tmp = binom(h, i) * binom(w, j);\n            // if (i > 0 && w - j > 0) tmp *= fac[i + (w - j)];\n            // if (h - i > 0 && j > 0) tmp *= fac[(h - i) + j];\n            tmp *= waf[i][w - j];\n            tmp *= waf[h - i][j];\n            pre[h][w] += tmp;\n          }\n        }\n      }\n      \n      Mint ans;\n      foreach (p; 0 .. 1 << H) {\n        alias Entry = Tuple!(int, \"row\", int, \"col\");\n        Entry[] es;\n        foreach (x0; 0 .. H) foreach (x1; 0 .. H) {\n          if ((p & 1 << x0) && (p & 1 << x1)) {\n            foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (A[x0][y0] == '.' &&\n                  A[x0][y1] == '#' &&\n                  A[x1][y0] == '#' &&\n                  A[x1][y1] == '.') {\n                es ~= Entry(1 << x0 | 1 << x1, 1 << y0 | 1 << y1);\n              }\n            }\n          }\n        }\n        foreach (q; 0 .. 1 << W) {\n          int pp, qq;\n          foreach (ref e; es) {\n            if ((q & e.col) == e.col) {\n              pp |= e.row;\n              qq |= e.col;\n            }\n          }\n          if (p == pp && q == qq) {\n            const h = H - popcnt(p);\n            const w = W - popcnt(q);\n            debug {\n              writeln(p, \" \", q, \"; \", h, \" \", w, \": \", pre[h][w]);\n            }\n            assert((h == H) == (w == W));\n            ans += pre[h][w];\n          }\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998_244_353;\nalias Mint = ModInt!MO;\n\nenum LIM = 100;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\nvoid main() {\n  prepare();\n  auto S = new Mint[][](LIM, LIM);\n  foreach (n; 0 .. LIM) {\n    S[n][0] = 0;\n    S[n][n] = 1;\n    foreach (k; 1 .. n) {\n      S[n][k] = S[n - 1][k - 1] + k * S[n - 1][k];\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      const H = readInt();\n      const W = readInt();\n      auto A = new string[H];\n      foreach (x; 0 .. H) {\n        A[x] = readToken();\n      }\n      \n      debug {\n        if (H * W <= 20) {\n          long brt;\n          foreach (p; 0 .. 1 << (H * W)) {\n            auto b = new int[][](H, W);\n            foreach (x; 0 .. H) foreach (y; 0 .. W) {\n              b[x][y] = (p >> (x * W + y)) & 1;\n            }\n            bool ok = true;\n            bool orig = false;\n            foreach (x0; 0 .. H) foreach (x1; 0 .. H) foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (b[x0][y0] == 0 &&\n                  b[x0][y1] == 1 &&\n                  b[x1][y0] == 1 &&\n                  b[x1][y1] == 0) {\n                if (A[x0][y0] == '.' &&\n                    A[x0][y1] == '#' &&\n                    A[x1][y0] == '#' &&\n                    A[x1][y1] == '.') {\n                  orig = true;\n                } else {\n                  ok = false;\n                }\n              }\n            }\n            if (ok) {\n              ++brt;\n              /*\n              if (orig) {\n                foreach (x; 0 .. H) {\n                  writeln(b[x]);\n                }\n                writeln();\n              }\n              //*/\n            }\n          }\n          writeln(brt);\n        }\n      }\n      \n      auto waf = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        foreach (i; 0 .. min(h, w) + 2) {\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i + 1] * S[h][i] * S[w][i + 1];\n          waf[h][w] += fac[i + 1] * fac[i] * S[h][i + 1] * S[w][i];\n        }\n      }\n      waf[0][0] = 1;\n      debug {\n        foreach (h; 0 .. H + 1) {\n          writefln(\"waf[%s] = %s\", h, waf[h]);\n        }\n      }\n      \n      auto pre = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        if (h == H && w == W) {\n          foreach (i; 0 .. min(h, w) + 1) {\n            pre[h][w] += fac[i]^^2 * S[h + 1][i + 1] * S[w + 1][i + 1];\n          }\n        } else if (h < H && w < W) {\n          foreach (i; 0 .. h + 1) foreach (j; 0 .. w + 1) {\n            Mint tmp = binom(h, i) * binom(w, j);\n            // if (i > 0 && w - j > 0) tmp *= fac[i + (w - j)];\n            // if (h - i > 0 && j > 0) tmp *= fac[(h - i) + j];\n            tmp *= waf[i][w - j];\n            tmp *= waf[h - i][j];\n            pre[h][w] += tmp;\n          }\n        }\n      }\n      \n      Mint ans;\n      foreach (p; 0 .. 1 << H) {\n        alias Entry = Tuple!(int, \"row\", int, \"col\");\n        Entry[] es;\n        foreach (x0; 0 .. H) foreach (x1; 0 .. H) {\n          if ((p & 1 << x0) && (p & 1 << x1)) {\n            foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (A[x0][y0] == '.' &&\n                  A[x0][y1] == '#' &&\n                  A[x1][y0] == '#' &&\n                  A[x1][y1] == '.') {\n                es ~= Entry(1 << x0 | 1 << x1, 1 << y0 | 1 << y1);\n              }\n            }\n          }\n        }\n        foreach (q; 0 .. 1 << W) {\n          int pp, qq;\n          foreach (ref e; es) {\n            if ((q & e.col) == e.col) {\n              pp |= e.row;\n              qq |= e.col;\n            }\n          }\n          if (p == pp && q == qq) {\n            const h = H - popcnt(p);\n            const w = W - popcnt(q);\n            debug {\n              writeln(p, \" \", q, \"; \", h, \" \", w, \": \", pre[h][w]);\n            }\n            assert((h == H) == (w == W));\n            ans += pre[h][w];\n          }\n        }\n      }\n      writeln(ans);\nbreak;\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op)() const if (op == \"-\") { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998_244_353;\nalias Mint = ModInt!MO;\n\nenum LIM = 100;\nMint[] inv, fac, invFac;\nvoid prepare() {\n  inv = new Mint[LIM];\n  fac = new Mint[LIM];\n  invFac = new Mint[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = -(Mint.M / i) * inv[cast(size_t)(Mint.M % i)];\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = fac[i - 1] * i;\n    invFac[i] = invFac[i - 1] * inv[i];\n  }\n}\nMint binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] * invFac[cast(size_t)(n - k)];\n  } else {\n    return Mint(0);\n  }\n}\n\n\nvoid main() {\n  prepare();\n  auto S = new Mint[][](LIM, LIM);\n  foreach (n; 0 .. LIM) {\n    S[n][0] = 0;\n    S[n][n] = 1;\n    foreach (k; 1 .. n) {\n      S[n][k] = S[n - 1][k - 1] + k * S[n - 1][k];\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      const H = readInt();\n      const W = readInt();\n      auto A = new string[H];\n      foreach (x; 0 .. H) {\n        A[x] = readToken();\n      }\n      \n      debug {\n        if (H * W <= 20) {\n          long brt;\n          foreach (p; 0 .. 1 << (H * W)) {\n            auto b = new int[][](H, W);\n            foreach (x; 0 .. H) foreach (y; 0 .. W) {\n              b[x][y] = (p >> (x * W + y)) & 1;\n            }\n            bool ok = true;\n            bool orig = false;\n            foreach (x0; 0 .. H) foreach (x1; 0 .. H) foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (b[x0][y0] == 0 &&\n                  b[x0][y1] == 1 &&\n                  b[x1][y0] == 1 &&\n                  b[x1][y1] == 0) {\n                if (A[x0][y0] == '.' &&\n                    A[x0][y1] == '#' &&\n                    A[x1][y0] == '#' &&\n                    A[x1][y1] == '.') {\n                  orig = true;\n                } else {\n                  ok = false;\n                }\n              }\n            }\n            if (ok) {\n              ++brt;\n              /*\n              if (orig) {\n                foreach (x; 0 .. H) {\n                  writeln(b[x]);\n                }\n                writeln();\n              }\n              //*/\n            }\n          }\n          writeln(brt);\n        }\n      }\n      \n      auto waf = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        foreach (i; 0 .. min(h, w) + 2) {\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i] * S[h][i] * S[w][i];\n          waf[h][w] += fac[i] * fac[i + 1] * S[h][i] * S[w][i + 1];\n          waf[h][w] += fac[i + 1] * fac[i] * S[h][i + 1] * S[w][i];\n        }\n      }\n      waf[0][0] = 1;\n      debug {\n        foreach (h; 0 .. H + 1) {\n          writefln(\"waf[%s] = %s\", h, waf[h]);\n        }\n      }\n      \n      auto pre = new Mint[][](H + 1, W + 1);\n      foreach (h; 0 .. H + 1) foreach (w; 0 .. W + 1) {\n        if (h == H && w == W) {\n          foreach (i; 0 .. min(h, w) + 1) {\n            pre[h][w] += fac[i]^^2 * S[h + 1][i + 1] * S[w + 1][i + 1];\n          }\n        } else if (h < H && w < W) {\n          foreach (i; 0 .. h + 1) foreach (j; 0 .. w + 1) {\n            Mint tmp = binom(h, i) * binom(w, j);\n            // if (i > 0 && w - j > 0) tmp *= fac[i + (w - j)];\n            // if (h - i > 0 && j > 0) tmp *= fac[(h - i) + j];\n            tmp *= waf[i][w - j];\n            tmp *= waf[h - i][j];\n            pre[h][w] += tmp;\n          }\n        }\n      }\n      \n      Mint ans;\n      foreach (p; 0 .. 1 << H) {\n        alias Entry = Tuple!(int, \"row\", int, \"col\");\n        Entry[] es;\n        foreach (x0; 0 .. H) foreach (x1; 0 .. H) {\n          if ((p & 1 << x0) && (p & 1 << x1)) {\n            foreach (y0; 0 .. W) foreach (y1; 0 .. W) {\n              if (A[x0][y0] == '.' &&\n                  A[x0][y1] == '#' &&\n                  A[x1][y0] == '#' &&\n                  A[x1][y1] == '.') {\n                es ~= Entry(1 << x0 | 1 << x1, 1 << y0 | 1 << y1);\n              }\n            }\n          }\n        }\n        foreach (q; 0 .. 1 << W) {\n          int pp, qq;\n          foreach (ref e; es) {\n            if ((q & e.col) == e.col) {\n              pp |= e.row;\n              qq |= e.col;\n            }\n          }\n          if (p == pp && q == qq) {\n            const h = H - popcnt(p);\n            const w = W - popcnt(q);\n            debug {\n              writeln(p, \" \", q, \"; \", h, \" \", w, \": \", pre[h][w]);\n            }\n            assert((h == H) == (w == W));\n            ans += pre[h][w];\n          }\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Bash",
    "code": "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nH,W=map(int,input().split())\nA=[input().strip() for i in range(H)]\n\nmod=998244353\n\n# factorial,facotiralの逆数を事前計算.\nFACT=[1]\nfor i in range(1,30+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(30,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\nCOMBI=[[-1]*21 for i in range(21)]\ndef Combi(a,b):\n    if COMBI[a][b]!=-1:\n        return COMBI[a][b]\n    \n    if 0<=b<=a:\n        COMBI[a][b]=FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n        return COMBI[a][b]\n    else:\n        COMBI[a][b]=0\n        return 0\n\nM=max(H,W)+1\nRA=[[-1]*M for i in range(M)]\ndef rect(H,W):\n    if H==W==0:\n        return 1\n    if RA[H][W]!=-1:\n        return RA[H][W]\n    \n    DP=[[[0,0] for j in range(W+1)] for i in range(H+1)] # (h,w)の最後に進んだ向きが縦/横のときの場合の数\n    DP[0][0][0]=1\n    DP[0][0][1]=1\n\n    for h in range(H+1):\n        for w in range(W+1):\n            for nexth in range(h+1,H+1):\n                DP[nexth][w][0]+=DP[h][w][1]*FACT_INV[nexth-h]\n                DP[nexth][w][0]%=mod\n\n            for nextw in range(w+1,W+1):\n                DP[h][nextw][1]+=DP[h][w][0]*FACT_INV[nextw-w]\n                DP[h][nextw][1]%=mod\n\n    RA[H][W]=RA[W][H]=sum(DP[H][W])*FACT[H]*FACT[W]%mod\n\n    return RA[H][W]\n\nCA=[[-1]*(W+1) for i in range(H+1)]\ndef calc(h,w):\n    if CA[h][w]!=-1:\n        return CA[h][w]\n    \n    RET=0\n    \n    for bh in range(h+1):\n        for bw in range(w+1):\n            RET+=rect(bh,w-bw)*rect(h-bh,bw)*Combi(h,bh)*Combi(w,bw)\n            #print(bh,bw,w-bw,h-bh,rect(bh,w-bw),rect(h-bh,bw),Combi(h,bh),Combi(w,bw))\n            RET%=mod\n\n    CA[h][w]=RET%mod\n    return CA[h][w]\n\nANS=0\n\nfor i in range(1<<H):\n    HR=[0]*H\n\n    for h in range(H):\n        if i & (1<<h)!=0:\n            HR[h]=1\n\n    for j in range(1<<W):\n        \n        WR=[0]*W\n\n        for w in range(W):\n            if j & (1<<w)!=0:\n                WR[w]=1\n\n        #print(HR,WR)\n\n        okflag=1\n        for h in range(H):\n            if HR[h]==1:\n                continue\n            coinc=0\n            dif=0\n            for w in range(W):\n                if WR[w]==1:\n                    continue\n\n                if coinc==0:\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n\n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        okflag=1\n        for w in range(W):\n            if WR[w]==1:\n                continue\n            coinc=0\n            dif=0\n            for h in range(H):\n                if HR[h]==1:\n                    continue\n\n                if coinc==0:\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n                \n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        # HR,WRのうち、0の部分だけを見る.\n\n        H0=HR.count(1)\n        W0=WR.count(1)\n\n        #print(H0,W0,HR,WR,ANS)\n\n        if H0==H and W0==W:\n            ANS+=rect(H,W)\n        else:\n            ANS+=calc(H0,W0)\n            \n        ANS%=mod\n\n        \nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nH,W=map(int,input().split())\nA=[input().strip() for i in range(H)]\n\nmod=998244353\n\n# factorial,facotiralの逆数を事前計算.\nFACT=[1]\nfor i in range(1,30+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(30,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\nM=max(H,W)+1\nRA=[[-1]*M for i in range(M)]\ndef rect(H,W):\n    if H==W==0:\n        return 1\n    if RA[H][W]!=-1:\n        return RA[H][W]\n    \n    DP=[[[0,0] for j in range(W+1)] for i in range(H+1)] # (h,w)の最後に進んだ向きが縦/横のときの場合の数\n    DP[0][0][0]=1\n    DP[0][0][1]=1\n\n    for h in range(H+1):\n        for w in range(W+1):\n            for nexth in range(h+1,H+1):\n                DP[nexth][w][0]+=DP[h][w][1]*FACT_INV[nexth-h]\n                DP[nexth][w][0]%=mod\n\n            for nextw in range(w+1,W+1):\n                DP[h][nextw][1]+=DP[h][w][0]*FACT_INV[nextw-w]\n                DP[h][nextw][1]%=mod\n\n    RA[H][W]=RA[W][H]=sum(DP[H][W])*FACT[H]*FACT[W]%mod\n\n    return RA[H][W]\n\nCA=[[-1]*(W+1) for i in range(H+1)]\ndef calc(h,w):\n    if CA[h][w]!=-1:\n        return CA[h][w]\n    \n    RET=0\n    \n    for bh in range(h+1):\n        for bw in range(w+1):\n            RET+=rect(bh,w-bw)*rect(h-bh,bw)*Combi(h,bh)*Combi(w,bw)\n            #print(bh,bw,w-bw,h-bh,rect(bh,w-bw),rect(h-bh,bw),Combi(h,bh),Combi(w,bw))\n            RET%=mod\n\n    CA[h][w]=RET%mod\n    return CA[h][w]\n\nANS=0\n\nfor i in range(1<<H):\n    HR=[0]*H\n\n    for h in range(H):\n        if i & (1<<h)!=0:\n            HR[h]=1\n\n    for j in range(1<<W):\n        \n        WR=[0]*W\n\n        for w in range(W):\n            if j & (1<<w)!=0:\n                WR[w]=1\n\n        #print(HR,WR)\n\n        okflag=1\n        for h in range(H):\n            if HR[h]==1:\n                continue\n            coinc=0\n            dif=0\n            for w in range(W):\n                if WR[w]==1:\n                    continue\n\n                if coinc==0:\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n\n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        okflag=1\n        for w in range(W):\n            if WR[w]==1:\n                continue\n            coinc=0\n            dif=0\n            for h in range(H):\n                if HR[h]==1:\n                    continue\n\n                if coinc==0:\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n                \n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        # HR,WRのうち、0の部分だけを見る.\n\n        H0=HR.count(1)\n        W0=WR.count(1)\n\n        #print(H0,W0,HR,WR,ANS)\n\n        if H0==H and W0==W:\n            ANS+=rect(H,W)\n        else:\n            ANS+=calc(H0,W0)\n            \n        ANS%=mod\n\n        \nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nH,W=map(int,input().split())\nA=[input().strip() for i in range(H)]\n\nmod=998244353\n\n# factorial,facotiralの逆数を事前計算.\nFACT=[1]\nfor i in range(1,21):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(20,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\nCOMBI=[[-1]*21 for i in range(21)]\ndef Combi(a,b):\n    if COMBI[a][b]!=-1:\n        return COMBI[a][b]\n    \n    if 0<=b<=a:\n        COMBI[a][b]=FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n        return COMBI[a][b]\n    else:\n        COMBI[a][b]=0\n        return 0\n\nM=max(H,W)+1\nRA=[[-1]*M for i in range(M)]\ndef rect(H,W):\n    if H==W==0:\n        return 1\n    if RA[H][W]!=-1:\n        return RA[H][W]\n    \n    DP=[[[0,0] for j in range(W+1)] for i in range(H+1)] # (h,w)の最後に進んだ向きが縦/横のときの場合の数\n    DP[0][0][0]=1\n    DP[0][0][1]=1\n\n    for h in range(H+1):\n        for w in range(W+1):\n            for nexth in range(h+1,H+1):\n                DP[nexth][w][0]+=DP[h][w][1]*FACT_INV[nexth-h]\n                DP[nexth][w][0]%=mod\n\n            for nextw in range(w+1,W+1):\n                DP[h][nextw][1]+=DP[h][w][0]*FACT_INV[nextw-w]\n                DP[h][nextw][1]%=mod\n\n    RA[H][W]=RA[W][H]=sum(DP[H][W])%mod*FACT[H]*FACT[W]%mod\n\n    return RA[H][W]\n\nCA=[[-1]*(W+1) for i in range(H+1)]\ndef calc(h,w):\n    if CA[h][w]!=-1:\n        return CA[h][w]\n    \n    RET=0\n    \n    for bh in range(h+1):\n        for bw in range(w+1):\n            RET+=rect(bh,w-bw)*rect(h-bh,bw)*Combi(h,bh)*Combi(w,bw)\n            #print(bh,bw,w-bw,h-bh,rect(bh,w-bw),rect(h-bh,bw),Combi(h,bh),Combi(w,bw))\n            RET%=mod\n\n    CA[h][w]=RET%mod\n    return CA[h][w]\n\nfor i in range(H+1):\n    for j in range(W+1):\n        calc(i,j)\n\nANS=rect(H,W)\n\nfor i in range((1<<H)-1):\n    for j in range((1<<W)-1):\n        okflag=1\n        for h in range(H):\n            if i & (1<<h)!=0:\n                continue\n            coinc=\"\"\n            dif=0\n            for w in range(W):\n                if j & (1<<w)!=0:\n                    continue\n\n                if coinc==\"\":\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n\n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        okflag=1\n        for w in range(W):\n            if j & (1<<w)!=0:\n                continue\n            coinc=\"\"\n            dif=0\n            for h in range(H):\n                if i & (1<<h)!=0:\n                    continue\n\n                if coinc==\"\":\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n                \n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        # i, jのうち、0の部分は決定済み. 1の部分に自由度がある.\n        HR=WR=0\n        for h in range(H):\n            if i & (1<<h)!=0:\n                HR+=1\n        for w in range(W):\n            if j & (1<<w)!=0:\n                WR+=1\n\n        ANS+=CA[HR][WR]\n            \n        #ANS%=mod\n\n        \nprint(ANS%mod)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nH,W=map(int,input().split())\nA=[input().strip() for i in range(H)]\n\nmod=998244353\n\n# factorial,facotiralの逆数を事前計算.\nFACT=[1]\nfor i in range(1,30+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(30,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\nCOMBI=[[-1]*21 for i in range(21)]\ndef Combi(a,b):\n    if COMBI[a][b]!=-1:\n        return COMBI[a][b]\n    \n    if 0<=b<=a:\n        COMBI[a][b]=FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n        return COMBI[a][b]\n    else:\n        COMBI[a][b]=0\n        return 0\n\nM=max(H,W)+1\nRA=[[-1]*M for i in range(M)]\ndef rect(H,W):\n    if H==W==0:\n        return 1\n    if RA[H][W]!=-1:\n        return RA[H][W]\n    \n    DP=[[[0,0] for j in range(W+1)] for i in range(H+1)] # (h,w)の最後に進んだ向きが縦/横のときの場合の数\n    DP[0][0][0]=1\n    DP[0][0][1]=1\n\n    for h in range(H+1):\n        for w in range(W+1):\n            for nexth in range(h+1,H+1):\n                DP[nexth][w][0]+=DP[h][w][1]*FACT_INV[nexth-h]\n                #DP[nexth][w][0]%=mod\n\n            for nextw in range(w+1,W+1):\n                DP[h][nextw][1]+=DP[h][w][0]*FACT_INV[nextw-w]\n                #DP[h][nextw][1]%=mod\n\n    RA[H][W]=RA[W][H]=sum(DP[H][W])*FACT[H]*FACT[W]%mod\n\n    return RA[H][W]\n\nCA=[[-1]*(W+1) for i in range(H+1)]\ndef calc(h,w):\n    if CA[h][w]!=-1:\n        return CA[h][w]\n    \n    RET=0\n    \n    for bh in range(h+1):\n        for bw in range(w+1):\n            RET+=rect(bh,w-bw)*rect(h-bh,bw)*Combi(h,bh)*Combi(w,bw)\n            #print(bh,bw,w-bw,h-bh,rect(bh,w-bw),rect(h-bh,bw),Combi(h,bh),Combi(w,bw))\n            #RET%=mod\n\n    CA[h][w]=RET%mod\n    return CA[h][w]\n\nANS=0\n\nfor i in range(1<<H):\n    HR=[0]*H\n\n    for h in range(H):\n        if i & (1<<h)!=0:\n            HR[h]=1\n\n    for j in range(1<<W):\n        \n        WR=[0]*W\n\n        for w in range(W):\n            if j & (1<<w)!=0:\n                WR[w]=1\n\n        #print(HR,WR)\n\n        okflag=1\n        for h in range(H):\n            if HR[h]==1:\n                continue\n            coinc=0\n            dif=0\n            for w in range(W):\n                if WR[w]==1:\n                    continue\n\n                if coinc==0:\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n\n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        okflag=1\n        for w in range(W):\n            if WR[w]==1:\n                continue\n            coinc=0\n            dif=0\n            for h in range(H):\n                if HR[h]==1:\n                    continue\n\n                if coinc==0:\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n                \n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        # HR,WRのうち、0の部分だけを見る.\n\n        H0=HR.count(1)\n        W0=WR.count(1)\n\n        #print(H0,W0,HR,WR,ANS)\n\n        if H0==H and W0==W:\n            ANS+=rect(H,W)\n        else:\n            ANS+=calc(H0,W0)\n            \n        ANS%=mod\n\n        \nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nH,W=map(int,input().split())\nA=[input().strip() for i in range(H)]\n\nmod=998244353\n\n# factorial,facotiralの逆数を事前計算.\nFACT=[1]\nfor i in range(1,30+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(30,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\ndef rect(H,W):\n    if H==W==0:\n        return 1\n    DP=[[[0,0] for j in range(W+1)] for i in range(H+1)] # (h,w)の最後に進んだ向きが縦/横のときの場合の数\n    DP[0][0][0]=1\n    DP[0][0][1]=1\n\n    for h in range(H+1):\n        for w in range(W+1):\n            for nexth in range(h+1,H+1):\n                DP[nexth][w][0]+=DP[h][w][1]*FACT_INV[nexth-h]\n                DP[nexth][w][0]%=mod\n\n            for nextw in range(w+1,W+1):\n                DP[h][nextw][1]+=DP[h][w][0]*FACT_INV[nextw-w]\n                DP[h][nextw][1]%=mod\n\n    return sum(DP[H][W])*FACT[H]*FACT[W]%mod\n\ndef calc(h,w):\n    RET=0\n    \n    for bh in range(h+1):\n        for bw in range(w+1):\n            RET+=rect(bh,w-bw)*rect(h-bh,bw)*Combi(h,bh)*Combi(w,bw)\n            #print(bh,bw,w-bw,h-bh,rect(bh,w-bw),rect(h-bh,bw),Combi(h,bh),Combi(w,bw))\n            RET%=mod\n\n    return RET%mod\n\nANS=0\n\nfor i in range(1<<H):\n    HR=[0]*H\n\n    for h in range(H):\n        if i & (1<<h)!=0:\n            HR[h]=1\n\n    for j in range(1<<W):\n        \n        WR=[0]*W\n\n        for w in range(W):\n            if j & (1<<w)!=0:\n                WR[w]=1\n\n        #print(HR,WR)\n\n        okflag=1\n        for h in range(H):\n            if HR[h]==1:\n                continue\n            coinc=0\n            dif=0\n            for w in range(W):\n                if WR[w]==1:\n                    continue\n\n                if coinc==0:\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n\n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        okflag=1\n        for w in range(W):\n            if WR[w]==1:\n                continue\n            coinc=0\n            dif=0\n            for h in range(H):\n                if HR[h]==1:\n                    continue\n\n                if coinc==0:\n                    coinc=A[h][w]\n                elif A[h][w]!=coinc:\n                    dif=1\n                    break\n                \n            if dif==0:\n                okflag=0\n                break\n\n        if okflag==0:\n            continue\n\n        # HR,WRのうち、0の部分だけを見る.\n\n        H0=HR.count(1)\n        W0=WR.count(1)\n\n        #print(H0,W0,HR,WR,ANS)\n\n        if H0==H and W0==W:\n            ANS+=rect(H,W)\n        else:\n            ANS+=calc(H0,W0)\n            \n        ANS%=mod\n\n        \nprint(ANS)\n\n        \n\n        \n"
  },
  {
    "language": "Python",
    "code": "print('fuck')"
  }
]