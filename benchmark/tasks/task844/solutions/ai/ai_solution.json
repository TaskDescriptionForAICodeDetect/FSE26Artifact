[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 200000\n\nint arr[MAX_N];\n\nint findMinIndex(int* subseq, int k) {\n    int minIdx = 0;\n    for (int i = 1; i < k; i++) {\n        if (subseq[i] < subseq[minIdx]) {\n            minIdx = i;\n        }\n    }\n    return minIdx;\n}\n\nint main() {\n    int N, K, Q;\n    scanf(\"%d %d %d\", &N, &K, &Q);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    int globalMin = INT_MAX, globalMax = INT_MIN;\n    \n    for (int q = 0; q < Q; q++) {\n        int bestDiff = INT_MAX;\n        int bestStartIdx = -1;\n        \n        for (int i = 0; i <= N - K; i++) {\n            int subseq[K];\n            for (int j = 0; j < K; j++) {\n                subseq[j] = arr[i + j];\n            }\n            \n            int minIdx = findMinIndex(subseq, K);\n            int minVal = subseq[minIdx];\n            \n            int maxVal = INT_MIN;\n            for (int j = 0; j < K; j++) {\n                if (j != minIdx) {\n                    maxVal = (subseq[j] > maxVal) ? subseq[j] : maxVal;\n                }\n            }\n            \n            int diff = maxVal - minVal;\n            if (diff < bestDiff) {\n                bestDiff = diff;\n                bestStartIdx = i;\n            }\n        }\n        \n        int subseq[K];\n        for (int j = 0; j < K; j++) {\n            subseq[j] = arr[bestStartIdx + j];\n        }\n        \n        int minIdx = findMinIndex(subseq, K);\n        int minVal = subseq[minIdx];\n        \n        int maxVal = INT_MIN;\n        for (int j = 0; j < K; j++) {\n            if (j != minIdx) {\n                maxVal = (subseq[j] > maxVal) ? subseq[j] : maxVal;\n            }\n        }\n        \n        globalMin = (minVal < globalMin) ? minVal : globalMin;\n        globalMax = (maxVal > globalMax) ? maxVal : globalMax;\n        \n        for (int j = 0; j < K; j++) {\n            if (j == minIdx) {\n                arr[bestStartIdx + j] = INT_MAX;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", globalMax - globalMin);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint is_possible(int *A, int N, int K, int Q, int mid) {\n    int *B = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        B[i] = (A[i] <= mid) ? 1 : 0;\n    }\n\n    int *prefix = (int *)calloc(N + 1, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        prefix[i + 1] = prefix[i] + B[i];\n    }\n\n    int *dp = (int *)calloc(N + 1, sizeof(int));\n    int *last = (int *)calloc(N + 1, sizeof(int));\n\n    for (int i = K; i <= N; i++) {\n        if (prefix[i] - prefix[i - K] > 0) {\n            dp[i] = dp[i - K] + 1;\n            last[i] = i;\n        } else {\n            dp[i] = dp[i - 1];\n            last[i] = last[i - 1];\n        }\n    }\n\n    free(B);\n    free(prefix);\n    free(dp);\n    free(last);\n\n    return dp[N] >= Q;\n}\n\nint solve(int *A, int N, int K, int Q) {\n    int *sorted = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        sorted[i] = A[i];\n    }\n    qsort(sorted, N, sizeof(int), compare);\n\n    int left = 0;\n    int right = N - 1;\n    int answer = INT_MAX;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (is_possible(A, N, K, Q, sorted[mid])) {\n            answer = sorted[mid];\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    int X = answer;\n\n    left = 0;\n    right = N - 1;\n    answer = INT_MAX;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (is_possible(A, N, K, Q, sorted[mid])) {\n            answer = sorted[mid];\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    int Y = answer;\n\n    free(sorted);\n\n    return X - Y;\n}\n\nint main() {\n    int N, K, Q;\n    scanf(\"%d %d %d\", &N, &K, &Q);\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int result = solve(A, N, K, Q);\n    printf(\"%d\\n\", result);\n\n    free(A);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:06:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\nusing namespace std;\n\nbool is_possible(const vector<int>& A, int N, int K, int Q, int mid) {\n    vector<int> B(N);\n    for (int i = 0; i < N; ++i) {\n        B[i] = A[i];\n    }\n    \n    multiset<int> removed_elements;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    for (int i = 0; i < N; ++i) {\n        pq.push({B[i], i});\n    }\n    \n    while (!pq.empty()) {\n        auto curr = pq.top();\n        pq.pop();\n        int val = curr.first;\n        int pos = curr.second;\n        \n        if (B[pos] != val) continue;\n        \n        int left = max(0, pos - K + 1);\n        bool found = false;\n        \n        for (int i = left; i <= pos && i + K <= N; ++i) {\n            int right = i + K;\n            bool valid = true;\n            for (int j = i; j < right; ++j) {\n                if (B[j] < val) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                found = true;\n                removed_elements.insert(val);\n                B[pos] = -1;\n                for (int j = i; j < right; ++j) {\n                    if (B[j] != -1) {\n                        pq.push({B[j], j});\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    if (removed_elements.size() < Q) return false;\n    \n    auto it = removed_elements.begin();\n    advance(it, Q - 1);\n    int Y = *removed_elements.begin();\n    int X = *it;\n    \n    return (X - Y) <= mid;\n}\n\nint solve(int N, int K, int Q, vector<int>& A) {\n    vector<int> sorted_A = A;\n    sort(sorted_A.begin(), sorted_A.end());\n    \n    int low = 0;\n    int high = sorted_A.back() - sorted_A.front();\n    int ans = high;\n    \n    while (low <= high) {\n        int mid = (low + high) / 2;\n        bool possible = false;\n        \n        for (int i = 0; i <= N - Q; ++i) {\n            int Y = sorted_A[i];\n            int X_upper = Y + mid;\n            auto it = upper_bound(sorted_A.begin(), sorted_A.end(), X_upper);\n            int cnt = it - (sorted_A.begin() + i);\n            if (cnt >= Q) {\n                possible = true;\n                break;\n            }\n        }\n        \n        if (possible) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    int N, K, Q;\n    cin >> N >> K >> Q;\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n    \n    cout << solve(N, K, Q, A) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int Q = sc.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n        }\n\n        int[] sortedA = A.clone();\n        Arrays.sort(sortedA);\n        int result = Integer.MAX_VALUE;\n\n        for (int i = 0; i < N; i++) {\n            int minY = sortedA[i];\n            List<Integer> candidates = new ArrayList<>();\n            List<Integer> current = new ArrayList<>();\n\n            for (int num : A) {\n                if (num >= minY) {\n                    current.add(num);\n                } else {\n                    if (current.size() >= K) {\n                        Collections.sort(current);\n                        for (int j = 0; j <= current.size() - K; j++) {\n                            candidates.add(current.get(j));\n                        }\n                    }\n                    current.clear();\n                }\n            }\n            if (current.size() >= K) {\n                Collections.sort(current);\n                for (int j = 0; j <= current.size() - K; j++) {\n                    candidates.add(current.get(j));\n                }\n            }\n\n            if (candidates.size() >= Q) {\n                Collections.sort(candidates);\n                int currentX = candidates.get(Q - 1);\n                result = Math.min(result, currentX - minY);\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:07:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int minimizeMaxMinDifference(int[] A, int K, int Q) {\n        int N = A.length;\n        int result = Integer.MAX_VALUE;\n        \n        for (int start = 0; start <= N - K; start++) {\n            int[] B = Arrays.copyOf(A, N);\n            int maxRemoved = Integer.MIN_VALUE;\n            int minRemoved = Integer.MAX_VALUE;\n            \n            for (int q = 0; q < Q; q++) {\n                int minIdx = start;\n                for (int i = start; i < start + K; i++) {\n                    if (B[i] < B[minIdx]) {\n                        minIdx = i;\n                    }\n                }\n                \n                maxRemoved = Math.max(maxRemoved, B[minIdx]);\n                minRemoved = Math.min(minRemoved, B[minIdx]);\n                \n                B[minIdx] = Integer.MAX_VALUE;\n            }\n            \n            result = Math.min(result, maxRemoved - minRemoved);\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        int Q = scanner.nextInt();\n        \n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = scanner.nextInt();\n        }\n        \n        System.out.println(minimizeMaxMinDifference(A, K, Q));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:07:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, K, Q;\n    cin >> N >> K >> Q;\n    \n    vector<int> A(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n    \n    int minXMinusY = INT_MAX;\n    \n    for (int start = 0; start <= N - K; start++) {\n        vector<int> B = A;\n        int maxRemoved = INT_MIN;\n        int minRemoved = INT_MAX;\n        \n        for (int q = 0; q < Q; q++) {\n            int minIndex = start;\n            for (int i = start; i < start + K; i++) {\n                if (B[i] < B[minIndex]) {\n                    minIndex = i;\n                }\n            }\n            \n            maxRemoved = max(maxRemoved, B[minIndex]);\n            minRemoved = min(minRemoved, B[minIndex]);\n            \n            B[minIndex] = INT_MAX;\n        }\n        \n        minXMinusY = min(minXMinusY, maxRemoved - minRemoved);\n    }\n    \n    cout << minXMinusY << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def smallest_x_y_difference(N, K, Q, A):\n    A.sort()\n    min_difference = float('inf')\n    \n    for i in range(N - Q + 1):\n        possible_removals = A[i:i + Q]\n        min_removal = possible_removals[0]\n        max_removal = possible_removals[-1]\n        if max_removal - min_removal < min_difference:\n            min_difference = max_removal - min_removal\n\n    return min_difference\n\n# Example usage:\n# N, K, Q = 5, 2, 2\n# A = [1, 5, 3, 4, 2]\n# print(smallest_x_y_difference(N, K, Q, A))  # Output should be the smallest possible value of X-Y",
    "timestamp": "2025-08-13 13:38:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class MinDifferenceFinder {\n\n    public static int findMinDifference(int[] A, int N, int K, int Q) {\n        if (Q > N) return -1;  // invalid number of operations\n\n        Arrays.sort(A);\n\n        int minDifference = Integer.MAX_VALUE;\n        for (int i = 0; i <= N - Q; i++) {\n            int maxRemoval = Integer.MIN_VALUE;\n            int minRemoval = Integer.MAX_VALUE;\n\n            PriorityQueue<Integer> pq = new PriorityQueue<>();\n            for (int j = i; j < i + Q; j++) {\n                pq.offer(A[j]);\n            }\n\n            for (int j = 0; j < Q; j++) {\n                int removed = pq.poll();\n                maxRemoval = Math.max(maxRemoval, removed);\n                minRemoval = Math.min(minRemoval, removed);\n                if (j + K < N) pq.offer(A[i + j + K]);\n            }\n\n            minDifference = Math.min(minDifference, maxRemoval - minRemoval);\n        }\n\n        return minDifference;\n    }\n\n    public static void main(String[] args) {\n        int[] A = {5, 3, 1, 9, 7};  // Sample input\n        int N = 5;\n        int K = 3;\n        int Q = 2;\n\n        int result = findMinDifference(A, N, K, Q);\n        System.out.println(\"Minimum difference X - Y: \" + result);\n    }\n}",
    "timestamp": "2025-08-13 13:38:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nint get_min_diff(int A[], int N, int K, int Q) {\n    int left = INT_MAX, right = INT_MIN;\n    \n    for (int i = 0; i < N; ++i) {\n        if (A[i] < left) left = A[i];\n        if (A[i] > right) right = A[i];\n    }\n    \n    int result = right - left;\n    \n    for (int min_val = left; min_val <= right; ++min_val) {\n        int queue[N], head = 0, tail = 0;\n        for (int i = 0; i < N; ++i) {\n            while (head < tail && A[i] <= A[queue[tail-1]]) --tail;\n            queue[tail++] = i;\n            if (queue[head] == i - K) ++head;\n            \n            if (i >= K - 1) {\n                int min_in_subsequence = A[queue[head]];\n                if (min_in_subsequence >= min_val) {\n                    int upper_bound = min_in_subsequence + result;\n                    int count = 0;\n                    for (int j = 0; j < N && count < Q; ++j) {\n                        if (A[j] >= min_val && A[j] <= upper_bound) {\n                            ++count;\n                        }\n                    }\n                    if (count >= Q) {\n                        int current_result = upper_bound - min_val;\n                        if (current_result < result) result = current_result;\n                    }\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int N = 5, K = 2, Q = 2;\n    int A[] = {1, 5, 2, 4, 3};\n    \n    int result = get_min_diff(A, N, K, Q);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:38:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\n\nusing namespace std;\n\nint findSmallestXYDiff(const vector<int>& A, int N, int K, int Q) {\n    vector<int> all_removed;\n    dequ<int> min_deque, max_deque;\n\n    for (int i = 0; i <= N - K; ++i) {\n        min_deque.clear();\n        max_deque.clear();\n        \n        for (int j = 0; j < K; ++j) {\n            while (!min_deque.empty() && A[i + j] <= A[i + min_deque.back()]) {\n                min_deque.pop_back();\n            }\n            min_deque.push_back(j);\n\n            while (!max_deque.empty() && A[i + j] >= A[i + max_deque.back()]) {\n                max_deque.pop_back();\n            }\n            max_deque.push_back(j);\n        }\n\n        all_removed.push_back(A[i + min_deque.front()]);\n        all_removed.push_back(A[i + max_deque.front()]);\n    }\n\n    sort(all_removed.begin(), all_removed.end());\n    \n    int diff = INT_MAX;\n    for (int i = 0; i <= all_removed.size() - Q; ++i) {\n        diff = min(diff, all_removed[i + Q - 1] - all_removed[i]);\n    }\n\n    return diff;\n}\n\nint main() {\n    int N, K, Q;\n    cin >> N >> K >> Q;\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n\n    int result = findSmallestXYDiff(A, N, K, Q);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:38:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, K, A):\n    def calculate_min_diff():\n        used = [False] * N\n        min_diff = float('inf')\n        \n        for _ in range(Q):\n            best_diff = float('inf')\n            best_start = -1\n            \n            for start in range(N - K + 1):\n                if all(not used[i] for i in range(start, start + K)):\n                    subseq = [A[i] for i in range(start, start + K)]\n                    min_val = min(subseq)\n                    min_idx = subseq.index(min_val)\n                    global_min_idx = start + min_idx\n                    \n                    max_removed = max(subseq)\n                    curr_diff = max_removed - min_val\n                    \n                    if curr_diff < best_diff:\n                        best_diff = curr_diff\n                        best_start = start\n            \n            if best_start == -1:\n                break\n            \n            subseq = [A[i] for i in range(best_start, best_start + K)]\n            min_val = min(subseq)\n            min_idx = subseq.index(min_val)\n            global_min_idx = best_start + min_idx\n            \n            used[global_min_idx] = True\n            max_removed = max(subseq)\n            min_diff = min(min_diff, max_removed - min_val)\n        \n        return min_diff\n    \n    # Try all possible number of operations\n    min_overall_diff = float('inf')\n    for Q in range(1, N + 1):\n        min_diff = calculate_min_diff()\n        min_overall_diff = min(min_overall_diff, min_diff)\n    \n    return min_overall_diff\n\n# Input processing\nN, K, Q = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Solve and print result\nresult = solve(N, K, A)\nprint(result)",
    "timestamp": "2025-08-13 13:39:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import bisect\nimport heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N, K, Q = map(int, data[idx:idx+3])\n    idx +=3\n    A = list(map(int, data[idx:idx+N]))\n    idx +=N\n    \n    unique_sorted = sorted(list(set(A)))\n    res = float('inf')\n    \n    for y in unique_sorted:\n        low = y\n        high_possible = []\n        left = 0\n        current_arrays = []\n        temp = []\n        \n        # Split the array into subarrays where elements >= y\n        for num in A:\n            if num >= y:\n                temp.append(num)\n            else:\n                if len(temp) >= K:\n                    current_arrays.append(temp)\n                temp = []\n        if len(temp) >= K:\n            current_arrays.append(temp)\n        \n        collected = []\n        for arr in current_arrays:\n            if len(arr) >= K:\n                # We can perform operations on this subarray\n                # For each possible window, the minimal is >= y\n                # We need to collect the minimal elements from each possible window\n                # Then take the Q smallest among them\n                m = len(arr)\n                window_mins = []\n                # Use a deque to find sliding window minimums\n                from collections import deque\n                q = deque()\n                for i in range(m):\n                    while q and arr[q[-1]] > arr[i]:\n                        q.pop()\n                    q.append(i)\n                    while q[0] <= i - K:\n                        q.popleft()\n                    if i >= K - 1:\n                        window_mins.append(arr[q[0]])\n                # Now, we can take the smallest Q elements from window_mins\n                if len(window_mins) > 0:\n                    window_mins_sorted = sorted(window_mins)\n                    if len(window_mins_sorted) >= Q:\n                        x_candidate = window_mins_sorted[Q-1]\n                        if x_candidate >= y:\n                            res = min(res, x_candidate - y)\n                    else:\n                        # Not enough elements, skip this y\n                        pass\n        \n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 13:39:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findMinDifference(N, K, Q, A) {\n    // Sort the array\n    A.sort((a, b) => a - b);\n    let minDifference = Infinity;\n\n    // Traverse possible windows of (N-K+1) and (N-Q)\n    for (let i = 0; i <= N - K; i++) {\n        let localMin = Infinity;\n        let localMax = -Infinity;\n        let elements = [];\n        \n        // Process subsequence [i, i+K-1]\n        for (let j = i; j <= i + K - 1; j++) {\n            elements.push(A[j]);\n        }\n\n        elements.sort((a, b) => a - b);\n        \n        // Select Q smallest elements and find X and Y\n        for (let m = 0; m <= Math.min(elements.length - Q, N - Q); m++) {\n            let currentSubsequence = A.slice(m, m + Q);\n            currentSubsequence.sort((a, b) => a - b);\n            localMin = currentSubsequence[0];\n            localMax = currentSubsequence[currentSubsequence.length - 1];\n            minDifference = Math.min(minDifference, localMax - localMin);\n        }\n    }\n    return minDifference;\n}\n\n// Example usage:\n// const N = 5, K = 3, Q = 2;\n// const A = [7, 6, 8, 10, 9];\n// console.log(findMinDifference(N, K, Q, A)); // Output: 1",
    "timestamp": "2025-08-13 13:39:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, K, A) {\n    function findOptimalRemoval(sequence) {\n        let minDiff = Infinity;\n        \n        for (let q = 0; q < N - K + 1; q++) {\n            let subsequence = sequence.slice(q, q + K);\n            let minIndex = subsequence.indexOf(Math.min(...subsequence));\n            let removedMin = subsequence[minIndex];\n            \n            let tempSeq = [...sequence];\n            tempSeq.splice(q + minIndex, 1);\n            \n            let max = Math.max(...tempSeq);\n            let min = Math.min(...tempSeq);\n            \n            minDiff = Math.min(minDiff, max - min);\n        }\n        \n        return minDiff;\n    }\n    \n    return findOptimalRemoval(A);\n}",
    "timestamp": "2025-08-13 13:39:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync(0, 'utf8').trim().split('\\n');\n    const [N, K, Q] = input[0].split(' ').map(Number);\n    const A = input[1].split(' ').map(Number);\n    \n    const uniqueSorted = [...new Set(A)].sort((a, b) => a - b);\n    let minDiff = Infinity;\n    \n    for (const y of uniqueSorted) {\n        let low = y;\n        let high = uniqueSorted[uniqueSorted.length - 1];\n        let left = y;\n        let right = high;\n        \n        while (left <= right) {\n            const mid = Math.floor((left + right) / 2);\n            if (isPossible(y, mid)) {\n                right = mid - 1;\n                minDiff = Math.min(minDiff, mid - y);\n            } else {\n                left = mid + 1;\n            }\n        }\n    }\n    \n    function isPossible(y, x) {\n        const segments = [];\n        let temp = [];\n        \n        for (const num of A) {\n            if (num >= y && num <= x) {\n                temp.push(num);\n            } else {\n                if (temp.length >= K) {\n                    segments.push(temp);\n                }\n                temp = [];\n            }\n        }\n        if (temp.length >= K) {\n            segments.push(temp);\n        }\n        \n        let total = 0;\n        for (const seg of segments) {\n            const sorted = [...seg].sort((a, b) => a - b);\n            const m = seg.length - K + 1;\n            total += m;\n            if (total >= Q) {\n                return true;\n            }\n        }\n        return total >= Q;\n    }\n    \n    console.log(minDiff);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:39:47"
  }
]