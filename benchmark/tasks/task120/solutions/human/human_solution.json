[
  {
    "language": "Scala",
    "code": "object Main extends App{\n  import scala.io.StdIn.readLine\n  val n = readLine().toInt\n  val nodes = Array.tabulate(n){_ ⇒ Node(readLine().trim())}\n  for (_ ← 1 until n){\n    val Array(s, t) = readLine().split(' ').map(_.toInt)\n    nodes(s - 1).addChile(nodes(t - 1))\n  }\n  println(nodes(0).pattern())\n}\nobject Node {\n  def apply(str:String):Node = {\n    str match{\n      case \"E\" ⇒ new MaterialNode\n      case \"E?\" ⇒ new OptMaterialNode\n      case \"A\" ⇒ new AltNode\n      case \"A?\" ⇒ new OptAltNode\n      case \"R\" ⇒ new OrNode\n      case \"R?\" ⇒ new OptOrNode\n      case _ ⇒ ???\n    }\n  }\n}\nsealed trait Node{\n  protected var mChildren:List[Node] = Nil\n  def addChile(node:Node):Unit = mChildren ::= node\n  def pattern():Long = rawPattern() % mod\n  protected def mod = 1000000007l\n  protected def rawPattern():Long\n}\nsealed trait OptNode extends Node{\n  override def pattern() = (super.pattern() + 1) % mod\n}\nclass MaterialNode extends Node {\n  override def rawPattern():Long = mChildren.foldLeft(1l){case (prev, node) ⇒ prev * node.pattern() % mod}\n}\nclass OptMaterialNode extends MaterialNode with OptNode\nclass AltNode extends Node {\n  override def rawPattern():Long = mChildren.map{node ⇒ node.pattern()}.sum\n}\nclass OptAltNode extends AltNode with OptNode\nclass OrNode extends Node{\n  override def rawPattern(): Long = mChildren.foldLeft(1l){case (prev, node) ⇒ prev * (node.pattern() + 1) % mod} + mod - 1\n}\nclass OptOrNode extends OrNode with OptNode\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nchar str[1100][5];\nlong long mod=1000000007;\nvector<int>g[1100];\nlong long dp[1100];\nlong long calc(int a){\n\tfor(int i=0;i<g[a].size();i++)calc(g[a][i]);\n\tif(str[a][0]=='E'){\n\t\tlong long ret=1;\n\t\tfor(int i=0;i<g[a].size();i++)ret=ret*dp[g[a][i]]%mod;\n\t\tif(str[a][1]=='?')ret=(ret+1)%mod;\n\t\treturn dp[a]=ret;\n\t}\n\tif(str[a][0]=='R'){\n\t\tlong long ret=1;\n\t\tfor(int i=0;i<g[a].size();i++)ret=ret*(dp[g[a][i]]+1)%mod;\n\t\tif(str[a][1]!='?')ret=(ret+mod-1)%mod;\n\t\treturn dp[a]=ret;\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<g[a].size();i++)ret=(ret+dp[g[a][i]])%mod;\n\tif(str[a][1]=='?')ret=(ret+1)%mod;\n\treturn dp[a]=ret;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",str[i]);\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tint s,t;scanf(\"%d%d\",&s,&t);s--;t--;\n\t\tg[s].push_back(t);\n\t}\n\tprintf(\"%lld\\n\",calc(0));\n\t//for(int i=0;i<a;i++)printf(\"%lld\\n\",dp[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[10001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[10001];\nint dp[10001];\nbool used[10001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\tint res=0;\n\tint sub;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+= dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\t\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\t\n\t\t\tsub=1;\n\t\t\trep(i,k){\n\t\t\t\tif( (s>>i) &1 ) sub*= dfs(ch[v][i]) ;\n\t\t\t\tsub%=mod;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0;\n  if(!e[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(int i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  if(n[x][0]=='A'){\n    for(int i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }\n  if(n[x][0]=='R'){\n    res++;\n    for(int i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n;\nstring s[1000];\nvector<int> g[1000];\n\nll dfs(int v, int p){\n  if (s[v] == \"E\"){\n    ll res = 1;\n    each(u, g[v]){\n      if (u == p) continue;\n      (res *= dfs(u, v)) %= mod;\n    }\n    return res;\n  }\n  if (s[v] == \"E?\"){\n    ll res = 1;\n    each(u, g[v]){\n      if (u == p) continue;\n      (res *= dfs(u, v)) %= mod;\n    }\n    return (res + 1) % mod;\n  }\n  if (s[v] == \"R\"){\n    vector<ll> a;\n    each(u, g[v]) if (u != p) a.push_back(dfs(u, v));\n    ll res = 0;\n    rep(i, 1, 1 << a.size()){\n      ll t = 1;\n      rep(j, a.size()) if (i >> j & 1) (t *= a[j]) %= mod;\n      (res += t) %= mod;\n    }\n    return res;\n  }\n  if (s[v] == \"R?\"){\n    vector<ll> a;\n    each(u, g[v]) if (u != p) a.push_back(dfs(u, v));\n    ll res = 0;\n    rep(i, 1, 1 << a.size()){\n      ll t = 1;\n      rep(j, a.size()) if (i >> j & 1) (t *= a[j]) %= mod;\n      (res += t) %= mod;\n    }\n    return (res + 1) % mod;\n  }\n  if (s[v] == \"A\"){\n    ll res = 0;\n    each(u, g[v]) if (u != p) (res += dfs(u, v)) %= mod;\n    return res;\n  }\n  if (s[v] == \"A?\"){\n    ll res = 0;\n    each(u, g[v]) if (u != p) (res += dfs(u, v)) %= mod;\n    return (res + 1) % mod;\n  }\n}\n\nint main(){\n  cin >> n;\n  rep(i, n) cin >> s[i];\n  rep(i, n - 1){\n    int s, t;\n    cin >> s >> t, s--, t--;\n    g[s].push_back(t);\n    //g[t].push_back(s);\n  }\n  cout << dfs(0, -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[10001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[10001];\nint dp[10001];\nbool used[10001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+= dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\tint sub=1;\n\t\t\trep(i,k){\n\t\t\t\tif((s>>i) &1) sub*= dfs(ch[v][i]) ;\n\t\t\t\tsub%=mod;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define m 1000000007LL\nusing namespace std;\ntypedef long long ll;\nint n;\nstring x[1001];\nvector <int> G[1001];\nll SUM,*R;\n\nvoid saiki2(int ima,ll sum){\n  for(int i=ima-1;i>=0;i--) saiki2(i,sum*R[i]);\n  SUM+=sum;\n}\n\nll saiki(int ima){\n  ll S=G[ima].size(),res=1,r[11];\n  char C=x[ima][0];\n  for(int i=0;i<S;i++)r[i]=saiki(G[ima][i]);\n  \n  if(C=='E')\n    for(int i=0;i<S;i++) res*=r[i];\n  \n  if(C=='A'){\n    res=0;\n    for(int i=0;i<S;i++) res+=r[i];\n  }\n  if(C=='R'){\n    SUM=0,R=r;\n    saiki2(S,1);\n    res=SUM-1;\n  }\n  return (res+x[ima].size()-1)%m;\n}\n\nint main(){\n  cin >>n;\n  for(int i=1;i<=n;i++)cin>>x[i];\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin >>a>>b;\n    G[a].push_back(b);\n  }\n  cout <<saiki(1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n  return 0;\n}\n \nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2%M;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return (res2+1)%M;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res%M;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return (res+1)%M;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2%M;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return (res2-1)%M;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define PB push_back\n#define M 1000000007\nint n;\nll dp[1005];\nvector<int>g[1005];\nbool o[1005];\nint t[1005];\nvoid dfs(int v,int p){\n    vector<ll>x;\n    for(int i=0;i<g[v].size();i++){\n        int u=g[v][i];\n        if(u==p)continue;\n        dfs(u,v);\n        x.PB(dp[u]);\n    }\n    if(t[v]==0){\n        dp[v]=1;\n        for(int i=0;i<x.size();i++)dp[v]=dp[v]*x[i]%M;\n    }else if(t[v]==1){\n        for(int i=0;i<x.size();i++)dp[v]=(dp[v]+x[i])%M;\n    }else{\n        int w=x.size();\n        for(int i=1;i<1<<w;i++){\n            ll e=1;\n            for(int j=0;j<w;j++)if(i>>j&1)e=e*x[j]%M;\n            dp[v]=(dp[v]+e)%M;\n        }\n    }\n    if(o[v])dp[v]=(dp[v]+1)%M;\n}\nint main(void){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        char s[5];\n        scanf(\" %s\",s);\n        if(s[0]=='A')t[i]=1;\n        if(s[0]=='R')t[i]=2;\n        if(s[1]=='?')o[i]=true;\n    }\n    for(int i=0;i<n-1;i++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        g[--a].PB(--b);\n        g[b].PB(a);\n    }\n    dfs(0,-1);\n    printf(\"%lld\\n\",dp[0]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n\nll func(int);\n\nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<(1<<edge[x].size());i++){\n      ll t=1;\n      for(int j=0;j<edge[x].size();j++)\n\tif(i&(1<<j)) t*=func(edge[x][j]);\n      res+=t;\n    }\n    return res;\n  }\n  if(n[x]==\"R\"){\n    for(int i=1;i<(1<<edge[x].size());i++){\n      ll t=1;\n      for(int j=0;j<edge[x].size();j++)\n\tif(i&(1<<j)) t*=func(edge[x][j]);\n      res+=t;\n    }\n    return res;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint nonempty[1000];\nint empty[1000];\nvector<int> g[1000];\nstring type[1000];\nint MOD = 1e9 + 7;\n\nvoid dfs(int x){\n\t// preprocess\n\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\tdfs(g[x][j]);\t\t\t\n\t} \n\tif( type[x][0] != 'E' ){\n\t\t// main process\n\t\tempty[x] = type[x].back() == '?';\n\t\tif( type[x][0] == 'R' ){\n\t\t\tfor(int i = 1 ; i < (1<<g[x].size()) ; i++){\n\t\t\t\tint emp = 1;\n\t\t\t\tint sub = 1;\n\t\t\t\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\t\t\t\tif( i >> j & 1 ){\n\t\t\t\t\t\temp *= empty[g[x][j]];\n\t\t\t\t\t\tsub *= empty[g[x][j]] + nonempty[g[x][j]];\n\t\t\t\t\t\tsub %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsub -= emp;\n\t\t\t\tempty[x] |= emp;\n\t\t\t\tnonempty[x] += sub;\n\t\t\t\tnonempty[x] %= MOD;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\t\t\tempty[x] |= empty[g[x][j]];\n\t\t\t\tnonempty[x] += nonempty[g[x][j]];\n\t\t\t\tnonempty[x] %= MOD;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tempty[x] = type[x].back() == '?';\n\t\tint sub = 1;\n\t\tint emp = 1;\n\t\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\t\temp *= empty[g[x][j]];\n\t\t\tsub *= (empty[g[x][j]]+nonempty[g[x][j]]);\n\t\t\tsub %= MOD;\n\t\t\t\n\t\t}\n\t\tnonempty[x] = sub;\n\t\t\n\t\t\n\t}\n\t//cout << x+1 << \"  emp:\" << empty[x] << \" nonemp:\" << nonempty[x] << \"(\" << type[x] << endl;\n\t\n\t\n\t\n}\nsigned main(){\n\tint N;\n\tcin >> N;\n\tfor(int i = 0 ; i < N ; i++)\n\t\tcin >> type[i];\n\tfor(int i = 0 ; i < N - 1 ; i++){\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\t--s,--t;\n\t\tg[s].push_back(t);\n\t}\n\tdfs(0);\n\tcout << ((nonempty[0] + empty[0])%MOD+MOD)%MOD << endl;\n\t\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\n\nvector<string> node;\nvector<int> edge[1005];\n\n// now:現在見てるノードの番地\nlong long dfs(int now){\n  long long rec = 0;\n  if(edge[now].size() == 0){\n    if(node[now] == \"E?\"){\n      return 2;\n    }else{\n      return 1;\n    }\n  }else if(node[now] == \"E\"){\n    // 必ず選ぶ\n    rec = 1;\n    for(int i = 0;i < edge[now].size();++i){\n      rec = (rec * dfs(edge[now][i])) % MOD;\n    }\n  }else if(node[now] == \"E?\"){\n    // 選ぶかどうかは任意\n    rec = 1;\n    for(int i = 0;i < edge[now].size();++i){\n      rec = (rec * dfs(edge[now][i])) % MOD;\n    }\n    rec++;\n  }else if(node[now][0] == 'R'){\n    int temp;\n    rec = 1;\n    for(int i = 0;i < edge[now].size();++i){\n      temp = dfs(edge[now][i]);\n      rec = (rec * (temp + 1)) % MOD;\n    }\n    if(node[now] != \"R?\") --rec;\n    if(rec < 0) rec = MOD - 1;\n  }else if(node[now][0] == 'A'){\n    for(int i = 0;i < edge[now].size();++i){\n      rec = (rec + dfs(edge[now][i])) % MOD;\n    }\n    if(node[now] == \"A?\") ++rec;\n  }\n\n  //cout << rec % MOD << endl;\n  return rec % MOD;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int n;\n  cin >> n;\n\n  string temp;\n  for(int i = 0;i < n;++i){\n    cin >> temp;\n    node.push_back(temp);\n  }\n\n  int s, t;\n  for(int i = 0;i < n - 1;++i){\n    cin >> s >> t;\n    --s; --t;\n    edge[s].push_back(t);\n  }\n\n  cout << dfs(0) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define m 1000000007LL\nusing namespace std;\ntypedef long long ll;\nint n;\nstring x[1001];\nvector <int> G[1001];\nll R[11],SUM;\n\nvoid saiki2(int ima,ll sum,int kai){\n  if(ima==-1)return;\n  for(int i=ima-1;i>=0;i--) saiki2(i,sum*R[i],kai+1);\n  if(kai)SUM+=sum;\n}\n\nint saiki(int ima){\n  int S=G[ima].size(),res=1;\n  ll r[11];\n  for(int i=0;i<S;i++)r[i]=saiki(G[ima][i]);\n\n  if(x[ima][0]=='E') {\n    res=1;\n    for(int i=0;i<S;i++) res*=r[i];\n  }\n  \n  if(x[ima][0]=='A'){\n    res=0;\n    for(int i=0;i<S;i++) res+=r[i];\n  }\n  if(x[ima][0]=='R'){\n    SUM=0;\n    for(int i=0;i<S;i++) R[i]=r[i];\n    saiki2(S,1,0);\n    res=SUM;\n  }\n  return (res+x[ima].size()-1)%m;\n}\n\nint main(){\n\n\n\n  cin >>n;\n  string str;\n  //E,E?,A,R,A?,B?\n  for(int i=1;i<=n;i++)cin>>x[i];\n  \n  for(int i=1;i<n;i++){\n    int a,b;\n    cin >>a>>b;\n    G[a].push_back(b);\n  }\n  cout <<saiki(1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n\nll func(int);\n\nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2-1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint type; // 0:normal, 1:or, 2:alt\n\tbool op; //true:option, false:normal\n\t\n\tNode() {}\n\tNode(int type, bool op)  :type(type), op(op) {}\n};\n\nint mod = 1000000007;\nvector<int> g[1000];\nNode node[1000];\nint n;\nint memo[1000];\n\nint dfs(int pos) {\n\tif (memo[pos] != -1) return memo[pos];\n\t\n\tNode &now = node[pos];\n\t\n\tint res = 0;\n\tif (g[pos].size() == 0) memo[pos] = 1 + now.op;\n\t\n\tif (now.type == 0) {\n\t\tint plus = 1;\n\t\tREP(i, g[pos].size()) {\n\t\t\tplus = ((long long)plus * dfs(g[pos][i])) % mod;\n\t\t}\n\t\tres = (res + plus) % mod;\n\t}\n\t\n\tif (now.type == 1) {\n\t\tFOR(bit, 1, 1<<g[pos].size()) {\n\t\t\tint plus = 1;\n\t\t\tREP(i, g[pos].size()) {\n\t\t\t\tif ((bit >> i) & 1) {\n\t\t\t\t\tplus = ((long long)plus * dfs(g[pos][i])) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = (res + plus) % mod;\n\t\t}\n\t}\n\t\n\tif (now.type == 2) {\n\t\tREP(i, g[pos].size()) res = (res + dfs(g[pos][i])) % mod;\n\t}\n\t\n\tres = (res + now.op) % mod;\n\t\n\treturn memo[pos] = res;\n}\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tint type = 0;\n\t\tif (str[0] == 'R') type = 1;\n\t\tif (str[0] == 'A') type = 2;\n\t\t\n\t\tnode[i] = Node(type, str.size() == 2);\n\t}\n\t\n\tREP(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\ta--; b--;\n\t\tg[a].push_back(b);\n\t}\n\t\n\tint st;\n\tbool done[1000] = {};\n\tREP(i, n) REP(j, g[i].size()) done[g[i][j]] = true;\n\tREP(i, n) if (!done[i]) st = i;\n\t\n\tfill(memo, memo + n, -1);\n\tcout << dfs(st) << endl;\n\t\n\treturn 0;\n}\n\n// 1:54"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nvector<string> node(1010);\nvector<vector<int>> G(1010);\n\nll dfs(int cv){\n    vector<ll> children;\n    for(auto nv : G[cv]){\n        children.emplace_back(dfs(nv));\n    }\n\n    ll sum;\n    if(node[cv][0] == 'E'){\n        sum = 1;\n        for(auto i : children){\n            (sum *= i) %= MOD;\n        }\n    }\n    else if(node[cv][0] == 'A'){\n        sum = 0;\n        for(auto i : children){\n            (sum += i) %= MOD;\n        }\n    }\n    else{\n        sum = 1;\n        for(auto i : children){\n            (sum *= (i + 1)) %= MOD;\n        }\n        sum--;\n    }\n\n    if(node[cv].size() == 2){\n        sum++;\n    }\n\n    return sum;\n}\n\nint main(){\n    int n; cin>>n;\n    for(int i=0; i<n; i++){\n        cin>>node[i];\n    }\n\n    for(int i=0; i<n-1; i++){\n        int s, t; cin>>s>>t;\n        s--, t--;\n        G[s].emplace_back(t);\n    }\n\n    cout << dfs(0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\ntypedef long long int64;\n\nint N;\nint node[1000], option[1000];\nvector< int > graph[1000];\nint dp[1000];\n\nint rec(int idx)\n{\n  if(~dp[idx]) return(dp[idx]);\n  int64 ret;\n  if(node[idx] == 0) {\n    ret = 1;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      (ret *= rec(graph[idx][i])) %= MOD;\n    }\n    (ret += option[idx]) %= MOD;\n  } else if(node[idx] == 1) {\n    ret = option[idx];\n    for(int i = 0; i < graph[idx].size(); i++) {\n      (ret += rec(graph[idx][i])) %= MOD;\n    }\n  } else {\n    ret = 1;\n    for(int i = 0; i < graph[idx].size(); i++) {\n      (ret *= rec(graph[idx][i]) + 1) %= MOD;\n    }\n    if(!option[idx]) --ret;\n  }\n  return(dp[idx] = ret);\n}\n\nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    string s;\n    cin >> s;\n    if(s[0] == 'E')      node[i] = 0;\n    else if(s[0] == 'A') node[i] = 1;\n    else                 node[i] = 2;\n    option[i] = s.size() == 2;\n  }\n  for(int i = 0; i < N - 1; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[--s].push_back(--t);\n  }\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long int adjustment = 1000000007;\n\nclass Node{\npublic:\n    string info;\n    int num;\n};\n\nlist<Node> l[1001];\nNode nodes[1001];\n\nlong long int Con(int n,int r){\n    long long int result = 1;\n    for(int i=n;i>n-r;i--){\n        result *= i;\n    }\n    for(int i=1;i<=r;i++){\n        result /= i;\n    }\n    return result;\n}\n\nlong long int DFS(Node node){\n\n\n    long long int sum = 0;\n\n    if(l[node.num].size() == 0){\n        if(node.info == \"E\"){\n            sum = 1;\n        }\n        else{ //E?\n            sum = 2;\n        }\n    }\n    else {\n        if(node.info == \"E?\") {\n            sum = 1;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum *= DFS(*it);\n                sum %= adjustment;\n            }\n            sum++;\n            sum %= adjustment;\n        }\n        else if(node.info == \"E\"){\n            sum = 1;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum *= DFS(*it);\n                sum %= adjustment;\n            }\n        }\n        else if(node.info == \"A?\"){\n            sum = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum += DFS(*it);\n                sum %= adjustment;\n            }\n            sum++;\n            sum %= adjustment;\n        }\n        else if(node.info == \"A\"){\n            sum = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum += DFS(*it);\n                sum %= adjustment;\n            }\n        }\n        else if(node.info == \"R?\"){\n            sum = 0;\n            int childcount = l[node.num].size();\n            long long int childsum[childcount];\n            int k = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                childsum[k] = DFS(*it);\n                childsum[k] %= adjustment;\n                k++;\n            }\n            long long int m = 1 << childcount;\n            for(long long int i=1; i<m; i++){\n                long long int selectsum = 1;\n                for(int j=0; j<childcount; j++){\n                    if( (i >> j) & 1 ){\n                        selectsum = (selectsum*childsum[j]) & adjustment;\n                    }\n                }\n                sum = (sum + selectsum) % adjustment;\n            }\n            sum = (sum+1) % adjustment;\n        }\n        else if(node.info == \"R\"){\n            sum = 0;\n            int childcount = l[node.num].size();\n            long long int childsum[childcount];\n            int k = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                childsum[k] = DFS(*it);\n                childsum[k] %= adjustment;\n                k++;\n            }\n            long long int m = 1 << childcount;\n            for(long long int i=1; i<m; i++){\n                long long int selectsum = 1;\n                for(int j=0; j<childcount; j++){\n                    if( (i >> j) & 1 ){\n                        selectsum = (selectsum*childsum[j]) % adjustment;\n                    }\n                }\n                sum = (sum + selectsum) % adjustment;\n            }\n\n        }\n    }\n\n    return sum;\n\n}\n\nint main() {\n\n    int n;\n\n    cin >> n;\n\n    for(int i=1;i<=n;i++){\n        string s;\n        cin >> s;\n        nodes[i].info = s;\n        nodes[i].num = i;\n    }\n\n    for(int i=1;i<n;i++){\n        int s,t;\n        scanf(\" %d %d\",&s,&t);\n        l[s].push_back(nodes[t]);\n    }\n\n    cout << DFS(nodes[1]) % adjustment << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll mod=1e9+7;\nint type[1005]={0};\nvector<int> son[1005];\nint par[1005]={0};\nint main(){\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++){\n    string s;\n    cin>>s;\n    if(s==\"E\") type[i]=0;\n    else if(s==\"E?\") type[i]=3;\n    else if(s==\"A\") type[i]=1;\n    else if(s==\"A?\") type[i]=4;\n    else if(s==\"R\") type[i]=2;\n    else type[i]=5;\n  }\n  for(int i=0;i<n-1;i++){\n    int s,t;\n    cin>>s>>t;\n    son[s].push_back(t);\n    par[t]=s;\n  }\n  vector<int> vec;\n  queue<int> que;\n  que.push(1);\n  while(!que.empty()){\n    int pos=que.front();\n    que.pop();\n    vec.push_back(pos);\n    for(int i=0;i<son[pos].size();i++) que.push(son[pos][i]);\n  }\n  ll dp[1005]={0};\n  for(int i=n-1;i>=0;i--){\n    int pos=vec[i];\n    if(son[pos].size()==0){\n      if(type[pos]==0) dp[pos]=1;\n      else dp[pos]=2;\n    }\n    else{\n      if(type[pos]%3==0){\n        dp[pos]=1;\n        for(int j=0;j<son[pos].size();j++){\n          dp[pos]*=dp[son[pos][j]];\n          dp[pos]%=mod;\n        }\n        if(type[pos]>=3) dp[pos]++;\n      }\n      else if(type[pos]%3==1){\n        for(int j=0;j<son[pos].size();j++){\n          dp[pos]+=dp[son[pos][j]];\n        }\n        if(type[pos]>=3) dp[pos]++;\n      }\n      else{\n        int siz=son[pos].size();\n        for(int j=0;j<(1<<siz);j++){\n          ll ksum=1;\n          for(int k=0;k<siz;k++){\n            int snum=son[pos][k];\n            if(((j>>k)&1)==1){\n              ksum*=dp[snum];\n              ksum%=mod;\n            }\n          }\n          dp[pos]+=ksum;\n          dp[pos]%=mod;\n        }\n        if(type[pos]==2) dp[pos]--;\n      }\n    }\n    dp[pos]%=mod;\n  }\n  cout<<dp[1]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint nonempty[1000];\nint empty[1000];\nvector<int> g[1000];\nstring type[1000];\nint MOD = 1e9 + 7;\n\nvoid dfs(int x){\n\t// preprocess\n\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\tdfs(g[x][j]);\t\t\t\n\t} \n\tif( type[x][0] != 'E' ){\n\t\t// main process\n\t\tempty[x] = type[x].back() == '?';\n\t\tif( type[x][0] == 'R' ){\n\t\t\tfor(int i = 1 ; i < (1<<g[x].size()) ; i++){\n\t\t\t\tint emp = 1;\n\t\t\t\tint sub = 1;\n\t\t\t\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\t\t\t\tif( i >> j & 1 ){\n\t\t\t\t\t\temp *= empty[g[x][j]];\n\t\t\t\t\t\tsub *= empty[g[x][j]] + nonempty[g[x][j]];\n\t\t\t\t\t\tsub %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsub -= emp;\n\t\t\t\tempty[x] |= emp;\n\t\t\t\tnonempty[x] += sub;\n\t\t\t\tnonempty[x] %= MOD;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\t\t\tempty[x] |= empty[g[x][j]];\n\t\t\t\tnonempty[x] += nonempty[g[x][j]];\n\t\t\t\tnonempty[x] %= MOD;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tempty[x] = type[x].back() == '?';\n\t\tint sub = 1;\n\t\tint emp = 1;\n\t\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\t\temp *= empty[g[x][j]];\n\t\t\tsub *= (empty[g[x][j]]+nonempty[g[x][j]]);\n\t\t\tsub %= MOD;\n\t\t\t\n\t\t}\n\t\tnonempty[x] = sub;\n\t\t\n\t\t\n\t}\n\t//cout << x+1 << \"  emp:\" << empty[x] << \" nonemp:\" << nonempty[x] << \"(\" << type[x] << endl;\n\t\n\t\n\t\n}\nsigned main(){\n\tint N;\n\tcin >> N;\n\tfor(int i = 0 ; i < N ; i++)\n\t\tcin >> type[i];\n\tfor(int i = 0 ; i < N - 1 ; i++){\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\t--s,--t;\n\t\tg[s].push_back(t);\n\t}\n\tdfs(0);\n\tcout << ((nonempty[0] + empty[0])%MOD+MOD)%MOD << endl;\n\t\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define m 1000000007LL\nusing namespace std;\ntypedef long long ll;\nint n;\nstring x[1001];\nvector <int> G[1001];\nll R[11],SUM;\n\nvoid saiki2(int ima,ll sum,int kai){\n  if(ima==-1)return;\n  for(int i=ima-1;i>=0;i--) saiki2(i,sum*R[i],kai+1);\n  if(kai)SUM+=sum;\n}\n\nll saiki(int ima){\n  ll S=G[ima].size(),res=1,r[11];\n  for(int i=0;i<S;i++)r[i]=saiki(G[ima][i]);\n\n  if(x[ima][0]=='E') {\n    res=1;\n    for(int i=0;i<S;i++) res*=r[i];\n  }\n  if(x[ima][0]=='A'){\n    res=0;\n    for(int i=0;i<S;i++) res+=r[i];\n  }\n  if(x[ima][0]=='R'){\n    SUM=0;\n    for(int i=0;i<S;i++) R[i]=r[i];\n    saiki2(S,1,0);\n    res=SUM;\n  }\n  return (res+x[ima].size()-1)%m;\n}\n\nint main(){\n\n\n\n  cin >>n;\n  string str;\n  //E,E?,A,R,A?,B?\n  for(int i=1;i<=n;i++)cin>>x[i];\n  \n  for(int i=1;i<n;i++){\n    int a,b;\n    cin >>a>>b;\n    G[a].push_back(b);\n  }\n  cout <<saiki(1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[10001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[10001];\nint dp[10001];\nbool used[10001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+= dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\tint sub=1;\n\t\t\trep(i,k){\n\t\t\t\tif((s>>i) &1) sub*= dfs(ch[v][i]) ;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 1000000007;\n\nll dp[1000] = {};\nvector<int> v[1000];\nstring s[1000];\nint n;\n\nint dfs(int x){\n    dp[x] = s[x][0]!='A';\n    for(int child : v[x]){\n        if(s[x][0] == 'A')  dp[x] += dfs(child);\n        else                (dp[x] *= dfs(child)+(s[x][0]=='R')) %= mod;\n    }\n    if(s[x] == \"E?\")    dp[x] = (dp[x]+1)%mod;\n    if(s[x] == \"R\")     dp[x] = (dp[x]-1+mod)%mod;\n    if(s[x] == \"A?\")    dp[x] = (dp[x]+1)%mod;\n    return dp[x];\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0; i < n; i++)  cin >> s[i];\n    for(int i = 0; i < n-1; i++){\n        int a, b;\n        cin >> a >> b;\n        v[--a].push_back(--b);\n    }\n    cout << dfs(0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n \nll func(int x){\n  ll r=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    r++;\n    for(i=0;i<S;i++) r*=func(E);\n    if(n[x]==\"E?\") r++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) r+=func(E);\n    if(n[x]==\"A?\") r++;\n  }else{\n    r++;\n    for(i=0;i<S;i++) r*=(1+func(E));\n    if(n[x]==\"R\") r--;\n  }\n  return r%M;\n}\n  \nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  while(--N) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[1001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[1001];\nint dp[1001];\nbool used[1001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\tbool flag=0;\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+=dfs(ch[v][i]) - (d[ch[v][i]].op==0?0:1);\n\t\t\tif(d[ch[v][i]].op==1) flag=1;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\tint sub=1;\n\t\t\trep(i,k){\n\t\t\t\tif((s>>i) &1) sub*= (dfs(ch[v][i]) - (d[ch[v][i]].op==0?0:1) ) ;\n\t\t\t\tif(d[ch[v][i]].op==1) flag=1;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1||flag) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n\nll func(int);\n\nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 1;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<(1<<edge[x].size());i++){\n      ll t=1;\n      for(int j=0;j<edge[x].size();j++)\n\tif(i&(1<<j)) t*=func(edge[x][j]);\n      res+=t;\n    }\n    return res;\n  }\n  if(n[x]==\"R\"){\n    for(int i=1;i<(1<<edge[x].size());i++){\n      ll t=1;\n      for(int j=0;j<edge[x].size();j++)\n\tif(i&(1<<j)) t*=func(edge[x][j]);\n      res+=t;\n    }\n    return res;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long int adjustment = 1000000007;\n\nclass Node{\npublic:\n    string info;\n    int num;\n};\n\nlist<Node> l[1001];\nNode nodes[1001];\n\nlong long int Con(int n,int r){\n    long long int result = 1;\n    for(int i=n;i>n-r;i--){\n        result *= i;\n    }\n    for(int i=1;i<=r;i++){\n        result /= i;\n    }\n    return result;\n}\n\nlong long int DFS(Node node){\n\n\n    long long int sum = 0;\n\n    if(l[node.num].size() == 0){\n        if(node.info == \"E\"){\n            sum = 1;\n        }\n        else{ //E?\n            sum = 2;\n        }\n    }\n    else {\n        if(node.info == \"E?\") {\n            sum = 1;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum *= DFS(*it);\n                sum %= adjustment;\n            }\n            sum++;\n            sum %= adjustment;\n        }\n        else if(node.info == \"E\"){\n            sum = 1;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum *= DFS(*it);\n                sum %= adjustment;\n            }\n        }\n        else if(node.info == \"A?\"){\n            sum = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum += DFS(*it);\n                sum %= adjustment;\n            }\n            sum++;\n            sum %= adjustment;\n        }\n        else if(node.info == \"A\"){\n            sum = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum += DFS(*it);\n                sum %= adjustment;\n            }\n        }\n        else if(node.info == \"R?\"){\n            sum = 0;\n            int childcount = l[node.num].size();\n            long long int childsum[childcount];\n            int k = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                childsum[k] = DFS(*it);\n                childsum[k] %= adjustment;\n                k++;\n            }\n            long long int m = 1 << childcount;\n            for(long long int i=1; i<m; i++){\n                long long int selectsum = 1;\n                for(int j=0; j<childcount; j++){\n                    if( (i >> j) & 1 ){\n                        selectsum = (selectsum*childsum[j]) & adjustment;\n                    }\n                }\n                sum = (sum + selectsum) % adjustment;\n            }\n            sum = (sum+1) % adjustment;\n        }\n        else if(node.info == \"R\"){\n            sum = 0;\n            int childcount = l[node.num].size();\n            long long int childsum[childcount];\n            int k = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                childsum[k] = DFS(*it);\n                childsum[k] %= adjustment;\n                k++;\n            }\n            long long int m = 1 << childcount;\n            for(long long int i=1; i<m; i++){\n                long long int selectsum = 1;\n                for(int j=0; j<childcount; j++){\n                    if( (i >> j) & 1 ){\n                        selectsum = (selectsum*childsum[j]) & adjustment;\n                    }\n                }\n                sum = (sum + selectsum) % adjustment;\n            }\n\n        }\n    }\n\n    return sum;\n\n}\n\nint main() {\n\n    int n;\n\n    cin >> n;\n\n    for(int i=1;i<=n;i++){\n        string s;\n        cin >> s;\n        nodes[i].info = s;\n        nodes[i].num = i;\n    }\n\n    for(int i=1;i<n;i++){\n        int s,t;\n        scanf(\" %d %d\",&s,&t);\n        l[s].push_back(nodes[t]);\n    }\n\n    cout << DFS(nodes[1]) % adjustment << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\nusing namespace std;\nvector<int>v[100009];\nstring s[100009];\nint n,mod=1000000007;\n\nint dfs(int now,int pre){\n    //cout<<now<<endl;\n    if(s[now][0]=='E'){\n        int res=1;\n        r(i,v[now].size()){\n            int nex=v[now][i];\n            if(nex==pre)continue;\n            res*=dfs(nex,now);\n            res%=mod;\n        }\n        if(s[now].size()==2)res++,res%=mod;\n        //cout<<now<<' '<<res<<endl;\n        return res;\n    }\n    if(s[now][0]=='A'){\n        int res=0;\n        r(i,v[now].size()){\n            int nex=v[now][i];\n            if(nex==pre)continue;\n            res+=dfs(nex,now);\n            res%=mod;\n        }\n        if(s[now].size()==2)res++;\n        res%=mod;\n        return res;\n    }\n    if(s[now][0]=='R'){\n        int res=0,a[11],cnt=0;\n        r(i,v[now].size()){\n            int nex=v[now][i];\n            if(nex==pre)continue;\n            a[cnt++]=dfs(nex,now);\n        }\n        for(int i=0;i<(1<<cnt);i++){\n            if(i==0)continue;\n            int rex=1;\n            r(j,cnt)if(i&(1<<j)){\n                rex*=a[j];\n                rex%=mod;\n            }\n            res+=rex;\n            res%=mod;\n        }\n        //cout<<res<<endl;\n        if(s[now].size()==2)res++,res%=mod;\n        return res;\n    }\n}\n\nsigned main(){\n    cin>>n;\n    r(i,n)cin>>s[i];\n    r(i,n-1){\n        int a,b;\n        cin>>a>>b; a--; b--;\n        v[a].push_back(b);\n        //v[b].push_back(a);\n    }\n    cout<<dfs(0,-1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 0309.cc: New Drug Development\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\nconst int MAX_C = 10;\n\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\n/* typedef */\n\ntypedef vector<int> vi;\n\n/* global variables */\n\nstring tps[MAX_N];\nvi nbrs[MAX_N];\n\n/* subroutines */\n\nll rec(int u) {\n  ll rcs[MAX_C];\n  vi &nbru = nbrs[u];\n  int cn = nbru.size();\n\n  for (int i = 0; i < cn; i++) rcs[i] = rec(nbru[i]);\n\n  ll ret;\n  \n  switch (tps[u][0]) {\n  case 'E': // Element\n    ret = 1;\n    for (int i = 0; i < cn; i++) ret = (ret * rcs[i]) % MOD;\n    break;\n  case 'A': // Alternate\n    ret = 0;\n    for (int i = 0; i < cn; i++) ret = (ret + rcs[i]) % MOD;\n    break;\n  case 'R': // 'or'\n    ret = 1;\n    for (int i = 0; i < cn; i++) ret = (ret * (rcs[i] + 1)) % MOD;\n    ret = (ret - 1 + MOD) % MOD;\n    break;\n  }\n\n  if (tps[u].size() > 1) ret = (ret + 1) % MOD;\n  return ret;\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> tps[i];\n\n  for (int i = 0; i < n - 1; i++) {\n    int si, ti;\n    cin >> si >> ti;\n    si--, ti--;\n    nbrs[si].push_back(ti);\n  }\n\n  ll ans = rec(0);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n \nll func(int x){\n  ll r=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    r++;\n    for(i=0;i<S;i++) r*=func(E);\n    if(n[x]==\"E?\") r++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) r+=func(E);\n    if(n[x]==\"A?\") r++;\n  }else{\n    r++;\n    for(i=0;i<S;i++) r*=(1+func(E));\n    if(n[x]==\"R\") r--;\n  }\n  return r%M;\n}\n\nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  while(--N) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t,i;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(i=0;i<N;i++) cin>>n[i];\n  for(i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }else{\n    res++;\n    for(i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int mod=1000000007;\nint N;\nstring S[1111];\nvint G[1111];\n\nint dfs(int v,int p){\n    int ret=0;\n\n    if(S[v][0]=='E'){\n        ret=1;\n        for(auto u:G[v]){\n            if(u==p)continue;\n            ret=ret*dfs(u,v)%mod;\n        }\n\n        if(S[v].size()==2)ret=(ret+1)%mod;\n    }\n    else if(S[v][0]=='A'){\n        for(auto u:G[v])if(u!=p)ret=(ret+dfs(u,v))%mod;\n        if(S[v].size()==2)ret=(ret+1)%mod;\n    }\n    else{\n        ret=1;\n        for(auto u:G[v])if(u!=p)ret=ret*(dfs(u,v)+1)%mod;\n        if(S[v].size()==1)ret=(ret-1+mod)%mod;\n    }\n    cout<<v<<\" \"<<ret<<endl;\n    return ret;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>S[i];\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    cout<<dfs(0,-1)<<endl;\n    return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n\nll func(int);\n\nint N,s,t;\nbool visited[N_MAX];\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    if(res==0) return 0;\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    if(res2==0) return 0;\n    return res2-1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[1001];\nbool sss[1001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[1001];\nint dp[1001];\nbool used[1001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\tint sub=1;\n\t\t\trep(i,k){\n\t\t\t\tif((s>>i) &1) sub*=dfs(ch[v][i]);\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[1001];\nbool sss[1001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[1001];\nint dp[1001];\nbool used[1001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\tint sub=1;\n\t\t\trep(i,k){\n\t\t\t\tif((s>>i) &1) sub*=dfs(ch[v][i]);\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n\n#define PB push_back\n\n#define MOD 1000000007LL\ntypedef long long ll;\n\nchar typ[1234];\nbool opt[1234];\nvector<int> ver[1234];\n\nll cnt(int, int);\nll cnt(int nw, int par){\n\tll ret = 0;\n\tif(typ[nw]=='E'){\n\t\tret = 1;\n\t\tREP(i, ver[nw].size()){\n\t\t\tint ch = ver[nw][i];\n\t\t\tif(ch==par) continue;\n\t\t\tret*=cnt(ch, nw);\n\t\t\tret%=MOD;\n\t\t}\n\t}else if(typ[nw]=='A'){\n\t\tret = 0;\n\t\tREP(i, ver[nw].size()){\n\t\t\tint ch = ver[nw][i];\n\t\t\tif(ch==par) continue;\n\t\t\tret+=cnt(ch, nw);\n\t\t\tret%=MOD;\n\t\t}\n\t}else{\n\t\tret = 1;\n\t\tREP(i, ver[nw].size()){\n\t\t\tint ch = ver[nw][i];\n\t\t\tif(ch==par) continue;\n\t\t\tret*=cnt(ch, nw)+1;\n\t\t\tret%=MOD;\n\t\t}\n\t\tret--;\n\t}\n\tif(opt[nw]) ret++;\n\treturn (ret+MOD*3)%MOD;\n}\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, n){\n\t\tchar s[4];\n\t\tscanf(\"%s\", s);\n\t\topt[i] = (strlen(s)==2);\n\t\ttyp[i] = s[0];\n\t}\n\tREP(i, n-1){\n\t\tint a, b; scanf(\"%d%d\", &a, &b); a--; b--;\n\t\tver[a].PB(b);\n\t\tver[b].PB(a);\n\t}\n\t\n\tprintf(\"%lld\\n\", cnt(0, -1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n \nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    for(int i=0;i<edge[x].size();i++)\n      if(n[edge[x][i]]==\"E?\") return res+1;\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    return res2;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    for(int i=0;i<edge[x].size();i++)\n      if(n[edge[x][i]]==\"E?\") return res2;\n    return res2-1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n \nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    return res2;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    for(int i=0;i<edge[x].size();i++)\n      if(n[edge[x][i]]==\"E?\") return res2;\n    return res2-1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n  return 0;\n}\n \nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2%M;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return (res2+1)%M;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    for(int i=0;i<edge[x].size();i++)\n      if(n[edge[x][i]]==\"E?\") return (res+1)%M;\n    return res%M;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return (res+1)%M;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    return res2%M;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    for(int i=0;i<edge[x].size();i++)\n      if(n[edge[x][i]]==\"E?\") return res2%M;\n    return (res2-1)%M;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long lld;\n#define MOD 1000000007ll\n\nint N;\nstring node[1111];\nvector<lld> edge[1111];\nlld dp[1111];\n\nlld solve(lld now){\n  if(dp[now] != -1) return dp[now];\n  lld ret = 1;\n  if(node[now][0] == 'E'){\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret*solve(edge[now][i]))%MOD;\n    }\n    if(node[now].size() != 1) ret++;\n  } else if(node[now][0] == 'A'){\n    ret = 0;\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret+solve(edge[now][i]))%MOD;\n    }\n    if(node[now].size() != 1) ret++;\n  } else {\n    ret = 0;\n    if(node[now].size() != 1) ret++;\n    for(int j=1;j<=(int)(pow(2.0,(double)(edge[now].size()))-1);j++){\n      long long next=1;\n      long long d=1;\n      for(int i=0;i<edge[now].size();i++){\n\tif((j&d)!=0){\n\t  next = (next*solve(edge[now][i]))%MOD;\n\t}\n\td=d<<1;\n      }\n      ret+=next;\n    }\n  }    \n  return dp[now] = ret%MOD;\n}\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    cin >> node[i];\n  }\n  for(int i=0;i<N-1;i++){\n    lld a,b;\n    cin >> a >> b;\n    a--; b--;\n    edge[a].push_back(b);\n  }\n  memset(dp,-1,sizeof(dp));\n  cout << solve(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1005\ntypedef long long ll;\nll mod=1e9+7;\nll add(ll a,ll b){ return (a+b+mod)%mod; }\nll mul(ll a,ll b){ return (a*b)%mod; }\n\nstring str;\nint n,a,b;\nchar t[MAX_N];\nint u[MAX_N];\nvector<int> G[MAX_N];\n\nll solve(int pos,int prev){\n  if(t[pos]=='E'){\n    ll res=1;\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(to==prev)continue;\n      res=mul(res,solve(to,pos));\n    }\n    if(u[pos]==2)res=add(res,1);\n    return res;\n  }else if(t[pos]=='A'){\n    ll res=u[pos]-1;\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(to==prev)continue;\n      res=add(res,solve(to,pos));\n    }\n    return res;\n  }else if(t[pos]=='R'){\n    ll res=1;\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(to==prev)continue;\n      res=mul(res,solve(to,pos)+1);\n    }\n    if(u[pos]==1)res=add(res,-1);\n    return res;\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    t[i]=str[0];\n    u[i]=str.size();\n  }\n  for(int i=0;i<n-1;i++){\n    cin>>a>>b;\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  cout<<solve(0,-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n#define int long long\nint nemp[1000];\nint emp[1000];\nvector<int> g[1000];\nstring type[1000];\nint mo = 1e9 + 7;\n\nvoid dfs(int x)\n{\n    for (int j = 0; j < g[x].size(); j++) dfs(g[x][j]);\n    if (type[x][0] != 'E')\n    {\n        emp[x] = type[x].back() == '?';\n        if (type[x][0] == 'R')\n        {\n            for (int i = 1; i < (1 << g[x].size()); i++)\n            {\n                int e = 1;\n                int sub = 1;\n                for (int j = 0; j < g[x].size(); j++)\n                {\n                    if (i >> j & 1)\n                    {\n                        e *= emp[g[x][j]];\n                        sub *= emp[g[x][j]] + nemp[g[x][j]];\n                        sub %= mo;\n                    }\n                }\n                emp[x] |= e;\n                nemp[x] += sub;\n                nemp[x] %= mo;\n            }\n        }\n        else\n        {\n            for (int j = 0; j < g[x].size(); j++)\n            {\n                emp[x] |= emp[g[x][j]];\n                nemp[x] += nemp[g[x][j]];\n                nemp[x] %= mo;\n            }\n        }\n    }\n    else\n    {\n        emp[x] = type[x].back() == '?';\n        int sub = 1;\n        int e = 1;\n        for (int j = 0; j < g[x].size(); j++)\n        {\n            e *= emp[g[x][j]];\n            sub *= (emp[g[x][j]] + nemp[g[x][j]]);\n        }\n        sub %= mo;\n        nemp[x] = sub;\n    }\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)cin >> type[i];\n    for (int i = 0; i < n - 1; i++)\n    {\n        int s, t;cin >> s >> t;\n        --s, --t;\n        g[s].push_back(t);\n    }\n    dfs(0);\n    cout << ((nemp[0] + emp[0]) % mo + mo) % mo << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 1e9 + 7;\nint n, type[1000];\nvector<vi> e;\n\nint rec(int c){\n\tll ans = 1;\n\tif(type[c] % 4 == 0){\n\t\tfor(int i : e[c]) ans = ans * rec(i) % mod;\n\t\tif(type[c] == 4) ans++;\n\t\treturn ans % mod;\n\t}\n\tif(type[c] % 4 == 1){\n\t\tfor(int i : e[c]) ans += rec(i);\n\t}\n\telse if(type[c] % 4 == 2){\n\t\tfor(int i : e[c]) ans = ans * (1 + rec(i)) % mod;\n\t}\n\tif(type[c] < 4) ans += mod - 1;\n\treturn ans % mod;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n; e.resize(n);\n\trep(i, n){\n\t\tstring s; cin >> s;\n\t\tif(s[0] == 'E') type[i] = 0;\n\t\tif(s[0] == 'A') type[i] = 1;\n\t\tif(s[0] == 'R') type[i] = 2;\n\t\tif(s.size() > 1) type[i] += 4;\n\t}\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t}\n\tcout << rec(0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long lld;\n#define MOD 1000000007\n\nint N;\nstring node[1111];\nvector<lld> edge[1111];\nlld dp[1111];\n\nlld solve(lld now){\n  if(dp[now] != -1) return dp[now];\n  lld ret = 1;\n  if(node[now][0] == 'E'){\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret*solve(edge[now][i]))%MOD;\n    }\n    if(node[now].size() != 1) ret++;\n  } else if(node[now][0] == 'A'){\n    ret = 0;\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret+solve(edge[now][i]))%MOD;\n    }\n    if(node[now].size() != 1) ret++;\n  } else {\n    ret = 0;\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret+solve(edge[now][i])*(int)(pow(2.0,(double)(edge[now].size()-1))))%MOD;\n    }\n    if(node[now].size() == 1) ret--;\n  }\n  return dp[now] = ret%MOD;\n}\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    cin >> node[i];\n  }\n  for(int i=0;i<N-1;i++){\n    lld a,b;\n    cin >> a >> b;\n    a--; b--;\n    edge[a].push_back(b);\n  }\n  memset(dp,-1,sizeof(dp));\n  cout << solve(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[1001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[1001];\nint dp[1001];\nbool used[1001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+= dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\tint sub=1;\n\t\t\trep(i,k){\n\t\t\t\tif((s>>i) &1) sub*= dfs(ch[v][i]) ;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }else{\n    res++;\n    for(i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long lld;\n#define MOD 1000000007\n\nint N;\nstring node[1111];\nvector<lld> edge[1111];\nlld dp[1111];\n\nlld solve(lld now){\n  if(dp[now] != -1) return dp[now];\n  lld ret = 1;\n  if(node[now][0] == 'E'){\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret*solve(edge[now][i]))%MOD;\n    }\n    if(node[now].size() != 1) ret++;\n  } else if(node[now][0] == 'A'){\n    ret = 0;\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret+solve(edge[now][i]))%MOD;\n    }\n    if(node[now].size() != 1) ret++;\n  } else {\n    ret = 0;\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret+solve(edge[now][i])*(int)(pow(2.0,(double)(edge[now].size()-1))))%MOD;\n    }\n    if(node[now].size() == 1) ret--;\n  }\n  return dp[now] = ret%MOD;\n}\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    cin >> node[i];\n  }\n  for(int i=0;i<N-1;i++){\n    lld a,b;\n    cin >> a >> b;\n    a--; b--;\n    edge[a].push_back(b);\n  }\n  memset(dp,-1,sizeof(dp));\n  cout << solve(0) << endl;\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\n#define int long long\n\nint n;\nvector<vector<int> > tree(1010);\nstring node[1010];\n\nint dp(int i){\n\tint ans = 1;\n\tif(node[i][0] == 'E'){\n\t\tfor(auto e : tree[i]){\n\t\t\tans *= dp(e);\n\t\t\tans %= MOD;\n\t\t}\n\t\tif(node[i][node[i].size()-1] == '?') ans = (ans + 1) % MOD;\n\t}else if(node[i][0] == 'A'){\n\t\tfor(auto e : tree[i]){\n\t\t\tans += dp(e);\n\t\t\tans %= MOD;\n\t\t}\n\t\tif(node[i][node[i].size()-1] != '?') ans = (MOD+ans-1) % MOD;\n\t}else{\n\t\tfor(auto e : tree[i]){\n\t\t\tans *= (dp(e) + 1);\n\t\t\tans %= MOD;\n\t\t}\n\t\tif(node[i][node[i].size()-1] != '?') ans = (MOD+ans-1) % MOD;\n\t}\n\treturn ans;\n\n}\n\n\nsigned main(){\n\tcin >> n;\n\tfor(int i = 0;i < n;i++) cin >> node[i];\n\tfor(int j = 0;j < n-1;j++){\n\t\tint s, t; cin >> s >> t;\n\t\ts--, t--;\n\t\ttree[s].push_back(t);\n\t}\n\n\tcout << dp(0) << endl;\n\treturn 0;\n}\n\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  using LL = long long;\n  const LL M = 1000000007;\n\n  int N;\n  cin >> N;\n  vector<string> node(N);\n  for(auto& n: node) cin >> n;\n  vector<vector<int>> child(N);\n  for(int i = 1; i < N; ++i) {\n    int s, t;\n    cin >> s >> t;\n    --s; --t;\n    child[s].push_back(t);\n  }\n\n  auto A = [&node](int n){return node[n][0] == 'A';};\n  auto E = [&node](int n){return node[n][0] == 'E';};\n  auto R = [&node](int n){return node[n][0] == 'R';};\n  auto option = [&node](int n){return node[n].size() == 2;};\n  function<LL(const vector<LL>&,int)> combination = [&](const vector<LL>& list, int n){\n    if(n == list.size()) return 1ll;\n    return (combination(list, n+1) + ((list[n]*combination(list, n+1))%M)) % M;\n  };\n  function<LL(int)> dfs = [&](int cur){\n    vector<LL> part;\n    for(auto nex: child[cur]) part.push_back(dfs(nex) + (option(nex) ? 1 : 0));\n    if(E(cur)) return accumulate(begin(part), end(part), 1ll, [&](LL lhs, LL rhs){return (lhs * rhs) % M;});\n    if(A(cur)) return accumulate(begin(part), end(part), 0ll, [&](LL lhs, LL rhs){return (lhs + rhs) % M;});\n    if(R(cur)) return (combination(part, 0) + M - 1) % M;\n  };\n  cout << dfs(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  while(--N) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }else{\n    res++;\n    for(i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\n\nint func(int);\n\nint N,s,t;\nbool visited[N_MAX];\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)<<endl;\n  return 0;\n}\n\nint func(int x){\n  int res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\"||n[x]==\"A\"||n[x]==\"A?\"||n[x]==\"R\"||n[x]==\"R?\") return 1;\n    if(n[x]==\"E?\") return 2;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2-1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconst ll mod = (ll)(1e9) + 7;\n\nenum ntype {\n\tOR, ALT, MATERIAL,\n};\n\nstruct node_t {\n\tntype t;\n\tint op;\n};\n\nvector<node_t> nodes;\nvector<int> to_edge[1005];\nll n;\nll ans[1005];\n\nll dfs(int v) {\n\tif (ans[v] != -1) return ans[v];\n\t\n\tll ret;\n\t\n\tif (nodes[v].t == OR) {\n\t\tret = 0;\n\t\tfor (int i = 1; i < (1 << to_edge[v].size()); i++) {\n\t\t\tll tmp = 1;\n\t\t\tll ref = i;\n\t\t\t\n\t\t\tfor (int j = 0; ref; j++) {\n\t\t\t\tif (ref & 1) {\n\t\t\t\t\ttmp *= dfs(to_edge[v][j]);\n\t\t\t\t\ttmp %= mod;\n\t\t\t\t}\n\t\t\t\tref >>= 1;\n\t\t\t}\n\t\t\t\n\t\t\tret += tmp;\n\t\t\tret %= mod;\n\t\t}\n\t}\n\telse if (nodes[v].t == ALT) {\n\t\tret = 0;\n\t\tfor (int i = 0; i < to_edge[v].size(); i++) {\n\t\t\tret += dfs(to_edge[v][i]);\n\t\t\tret %= mod;\n\t\t}\n\t}\n\telse if (nodes[v].t == MATERIAL) {\n\t\tret = 1;\n\t\tfor (int i = 0; i < to_edge[v].size(); i++) {\n\t\t\tret *= dfs(to_edge[v][i]);\n\t\t\tret %= mod;\n\t\t}\n\t}\n\t\n\treturn ans[v] = (ret + nodes[v].op) % mod;\n}\n\nint main() {\n\tcin >> n;\n\tnodes.resize(n + 1);\n\t\n\tfor (int i = 0; i <= n; i++) {\n\t\tans[i] = -1;\n\t}\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\t\n\t\tif (s[0] == 'E') {\n\t\t\tnodes[i].t = MATERIAL;\n\t\t}\n\t\telse if (s[0] == 'R') {\n\t\t\tnodes[i].t = OR;\n\t\t}\n\t\telse if (s[0] == 'A') {\n\t\t\tnodes[i].t = ALT;\n\t\t}\n\t\t\n\t\tif (s[1] == '?') {\n\t\t\tnodes[i].op = 1;\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tll s, t;\n\t\tcin >> s >> t;\n\t\tto_edge[s].push_back(t);\n\t}\n\t\n\tcout << dfs(1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nstruct node {\n    int type;\n    bool option;\n    vector<int> child;\n    node(int type, bool option) : type(type), option(option) {};\n};\n\nint pattern(node&);\nint material_node(node&);\nint alt_node(node&);\nint or_node(node&);\n\nint n;\nvector<node> tree;\n\nint pattern(node &now) {\n\n    int ret = 0;\n\n    switch(now.type) {\n        case 0:\n            ret = material_node(now);\n            break;\n        case 1:\n            ret = alt_node(now);\n            break;\n        case 2:\n            ret = or_node(now);\n            break;\n    }\n\n    return ret % MOD;\n}\n\nint material_node(node &now) {\n\n    int ret = 1;\n\n    for(int i = 0; i < now.child.size(); ++i) {\n        ret = ret * pattern(tree[now.child[i]]) % MOD;\n    }\n\n    ret += now.option;\n\n    return ret % MOD;\n\n}\n\nint alt_node(node &now) {\n\n    int ret = 0;\n\n    for(int i = 0; i < now.child.size(); ++i) {\n        ret = (ret + pattern(tree[now.child[i]])) % MOD;\n    }\n\n    ret += now.option;\n\n    return ret % MOD;\n\n}\n\nint or_node(node &now) {\n\n    int ret = 0;\n\n    for(int i = 1; i < (1 << now.child.size()); ++i) {\n        int seki = 1;\n        for(int j = 0; j < now.child.size(); ++j) {\n            if((i >> j) & 1) {\n                seki = seki * pattern(tree[now.child[j]]) % MOD;\n            }\n        }\n        ret = (ret + seki) % MOD;\n    }\n\n    ret += now.option;\n\n    return ret;\n}\n\nint main() {\n\n    cin >> n;\n\n    for(int i = 0; i < n; ++i) {\n        int t;\n        bool o;\n        string s;\n\n        cin >> s;\n\n        if(s[0] == 'E') {\n            t = 0;\n        } else if(s[0] == 'A') {\n            t = 1;\n        } else if(s[0] == 'R') {\n            t = 2;\n        }\n\n        o = s.size() - 1;\n\n        tree.push_back(node(t, o));\n    }\n\n    for(int i = 0; i < n - 1; ++i) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n        tree[s].child.push_back(t);\n    }\n\n    cout << pattern(tree[0]) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!e[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x][0]=='E'){\n    for(int i=0;i<S;i++) res2*=func(E);\n    if(n[x]==\"E?\") res2++;\n    return res2%M;\n  }\n  if(n[x][0]=='A'){\n    for(int i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n    return res%M;\n  }\n  if(n[x][0]=='R'){\n    for(int i=0;i<S;i++) res2*=(1+func(E));\n    if(n[x]==\"R\") res2--;\n    return res2%M;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<u32 M = 1000000007>\nstruct modint{\n    u32 val;\n    modint(): val(0){}\n    template<typename T>\n    modint(T t){t %= (T)M; if(t < 0) t += (T)M; val = t;}\n\n    modint pow(ll k) const {\n        modint res(1), x(val);\n        while(k){\n            if(k&1) res *= x;\n            x *= x;\n            k >>= 1;\n        }\n        return res;\n    }\n    template<typename T>\n    modint& operator=(T t){t %= (T)M; if(t < 0) t += (T)M; val = t; return *this;}\n    modint inv() const {return pow(M-2);}\n    modint& operator+=(modint a){val += a.val; if(val >= M) val -= M; return *this;}\n    modint& operator-=(modint a){if(val < a.val) val += M-a.val; else val -= a.val; return *this;}\n    modint& operator*=(modint a){val = (u64)val*a.val%M; return *this;}\n    modint& operator/=(modint a){return (*this) *= a.inv();}\n    modint operator+(modint a) const {return modint(val) +=a;}\n    modint operator-(modint a) const {return modint(val) -=a;}\n    modint operator*(modint a) const {return modint(val) *=a;}\n    modint operator/(modint a) const {return modint(val) /=a;}\n    modint operator-(){return modint(M-val);}\n    bool operator==(const modint a) const {return val == a.val;}\n    bool operator!=(const modint a) const {return val != a.val;}\n    bool operator<(const modint a) const {return val < a.val;}\n};\nusing mint = modint<MOD>;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<string> v(n);\n    for (auto &&i : v) cin >> i;\n    vector<vector<int>> G(n);\n    for (int i = 0; i < n-1; ++i) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n    }\n    vector<mint> dp1(n), dp2(n);\n    auto dfs = [&](int x, int par, auto &&f) -> void {\n        if(v[x].size() >= 2) dp2[x] = 1;\n        for (auto &&y : G[x]) if(y != par) f(y, x, f);\n        if(v[x][0] == 'E'){\n            dp1[x] = 1;\n            for (auto &&y : G[x]) if(y != par) dp1[x] *= (dp1[y]+dp2[y]);\n        }else if(v[x][0] == 'A'){\n            for (auto &&y : G[x]) if(y != par) dp1[x] += (dp1[y]+dp2[y]);\n        }else if(v[x][0] == 'R'){\n            dp1[x] = 1;\n            mint a = 1;\n            for (auto &&y : G[x]) if(y != par) dp1[x] *= (dp1[y]+dp2[y]+1);\n            dp1[x] -= 1;\n        }\n    };\n    dfs(0, -1, dfs);\n    /*for (int i = 0; i < n; ++i) {\n        printf(\"%10d \", dp1[i].val);\n    }\n    puts(\"\");\n    for (int i = 0; i < n; ++i) {\n        printf(\"%10d \", dp2[i].val);\n    }*/\n    cout << (dp1[0]+dp2[0]).val << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0;\n  if(!e[x].size()){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(int i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  if(n[x][0]=='A'){\n    for(int i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }\n  if(n[x][0]=='R'){\n    res++;\n    for(int i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst long long MOD=1000000007;\nvector<vector<int>> G;\nvector<string> node;\n\nlong long dfs(int pos){\n    long long ret=1;\n    if(node[pos][0]=='E'){\n        for(auto i:G[pos]){\n            ret=ret*dfs(i);\n            ret=ret%MOD;\n        }\n        if(node[pos].size()==2)++ret;\n        //cout<<pos<<\" \"<<ret<<endl;\n        return ret%MOD;\n    }\n    else if(node[pos][0]=='A'){\n        --ret;\n        for(auto i:G[pos]){\n            ret=ret+dfs(i);\n            ret=ret%MOD;\n        }\n        if(node[pos].size()==2)++ret;\n        return ret%MOD;\n    }\n    else{\n        for(auto i:G[pos]){\n            ret=ret*(dfs(i)+1);\n            ret=ret%MOD;\n        }\n        --ret;\n        if(node[pos].size()==2)++ret;\n        return ret%MOD;\n    }\n}\n\nint main(){\n    int n;\n    cin>>n;\n    node.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin>>node[i];\n    }\n    G.resize(n);\n    vector<bool> isroot(n,true);\n    for (int i = 0; i < n-1; ++i) {\n        int s,t;\n        cin>>s>>t;\n        --s;--t;\n        G[s].emplace_back(t);\n        isroot[t]=false;\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if(isroot[i]){\n            root=i;\n            break;\n        }\n    }\n    cout<<dfs(root)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long int adjustment = 1000000007;\n\nclass Node{\npublic:\n    string info;\n    int num;\n};\n\nlist<Node> l[1001];\nNode nodes[1001];\n\nlong long int Con(int n,int r){\n    long long int result = 1;\n    for(int i=n;i>n-r;i--){\n        result *= i;\n    }\n    for(int i=1;i<=r;i++){\n        result /= i;\n    }\n    return result;\n}\n\nlong long int DFS(Node node){\n\n\n    long long int sum = 0;\n\n    if(l[node.num].size() == 0){\n        if(node.info == \"E\"){\n            sum = 1;\n        }\n        else{ //E?\n            sum = 2;\n        }\n    }\n    else {\n        if(node.info == \"E?\") {\n            sum = 1;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum *= DFS(*it);\n                sum %= adjustment;\n            }\n            sum++;\n            sum %= adjustment;\n        }\n        else if(node.info == \"E\"){\n            sum = 1;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum *= DFS(*it);\n                sum %= adjustment;\n            }\n        }\n        else if(node.info == \"A?\"){\n            sum = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum += DFS(*it);\n                sum %= adjustment;\n            }\n            sum++;\n            sum %= adjustment;\n        }\n        else if(node.info == \"A\"){\n            sum = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum += DFS(*it);\n                sum %= adjustment;\n            }\n        }\n        else if(node.info == \"R?\"){\n            sum = 0;\n            int childcount = l[node.num].size();\n            long long int childsum[childcount] = {0};\n            int k = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                childsum[k] += DFS(*it);\n                childsum[k] %= adjustment;\n                k++;\n            }\n            long long int m = 1 << childcount;\n            for(long long int i=1; i<m; i++){\n                long long int selectsum = 1;\n                for(int j=0; j<childcount; j++){\n                    if( (i >> j) & 1 ){\n                        selectsum = (selectsum*childsum[j]) & adjustment;\n                    }\n                }\n                sum = (sum + selectsum) % adjustment;\n            }\n            sum = (sum+1) % adjustment;\n        }\n        else if(node.info == \"R\"){\n            sum = 0;\n            int childcount = l[node.num].size();\n            long long int childsum[childcount] = {0};\n            int k = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                childsum[k] += DFS(*it);\n                childsum[k] %= adjustment;\n                k++;\n            }\n            long long int m = 1 << childcount;\n            for(long long int i=1; i<m; i++){\n                long long int selectsum = 1;\n                for(int j=0; j<childcount; j++){\n                    if( (i >> j) & 1 ){\n                        selectsum = (selectsum*childsum[j]) & adjustment;\n                    }\n                }\n                sum = (sum + selectsum) % adjustment;\n            }\n\n        }\n    }\n\n    return sum;\n\n}\n\nint main() {\n\n    int n;\n\n    cin >> n;\n\n    for(int i=1;i<=n;i++){\n        string s;\n        cin >> s;\n        nodes[i].info = s;\n        nodes[i].num = i;\n    }\n\n    for(int i=1;i<n;i++){\n        int s,t;\n        scanf(\" %d %d\",&s,&t);\n        l[s].push_back(nodes[t]);\n    }\n\n    cout << DFS(nodes[1]) % adjustment << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\nll func(int);\n\nint N,s,t;\nbool visited[N_MAX];\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\"||n[x]==\"A\"||n[x]==\"A?\"||n[x]==\"R\"||n[x]==\"R?\") return 1;\n    if(n[x]==\"E?\") return 2;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2-1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[10001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[10001];\nint dp[10001];\nbool used[10001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\tint res=0;\n\tint sub;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres *= (dfs(ch[v][i]) + (d[ch[v][i]].op==1?1:0) );\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+= dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\t\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\t\n\t\t\tsub=1;\n\t\t\trep(i,k){\n\t\t\t\tif( (s>>i) &1 ) sub*= dfs(ch[v][i]) ;\n\t\t\t\tsub%=mod;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\t//cout<<v<<\" \"<<res%mod<<endl;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(int i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  else if(n[x][0]=='A'){\n    for(int i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }else{\n    res++;\n    for(int i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int mod=1000000007;\nint N;\nstring S[1111];\nvint G[1111];\n\nint dfs(int v,int p){\n    int ret=0;\n\n    if(S[v][0]=='E'){\n        ret=1;\n        for(auto u:G[v]){\n            if(u==p)continue;\n            ret=ret*dfs(u,v)%mod;\n        }\n\n        if(S[v].size()==2)ret=(ret+1)%mod;\n    }\n    else if(S[v][0]=='A'){\n        for(auto u:G[v])if(u!=p)ret=(ret+dfs(u,v))%mod;\n        if(S[v].size()==2)ret=(ret+1)%mod;\n    }\n    else{\n        ret=1;\n        for(auto u:G[v])if(u!=p)ret=ret*(dfs(u,v)+1)%mod;\n        if(S[v].size()==1)ret=(ret-1+mod)%mod;\n    }\n    return ret;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>S[i];\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    cout<<dfs(0,-1)<<endl;\n    return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0;\n  if(!e[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(int i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  if(n[x][0]=='A'){\n    for(int i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }\n  if(n[x][0]=='R'){\n    res++;\n    for(int i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nconst long long mod = 1000000007LL;\nint type[1003], n;\nvector<int>x[1003];\nlong long solve(int pos) {\n\tlong long Kakezan = 1;\n\tlong long Tashizan = 0;\n\tlong long Warizan = 1;\n\tvector<int>vec;\n\tfor (int i = 0; i < x[pos].size(); i++) { vec.push_back(solve(x[pos][i])); }\n\tfor (int i = 0; i < x[pos].size(); i++) { Kakezan *= vec[i]; Kakezan %= mod; }\n\tfor (int i = 0; i < x[pos].size(); i++) { Tashizan += vec[i]; Tashizan %= mod; }\n\tfor (int i = 0; i < x[pos].size(); i++) { Warizan *= (vec[i] + 1); Warizan %= mod; }\n\tlong long D = 0;\n\tif (type[pos] == 1)D = Kakezan;\n\tif (type[pos] == 2)D = Kakezan + 1;\n\tif (type[pos] == 3)D = Tashizan;\n\tif (type[pos] == 4)D = Tashizan + 1;\n\tif (type[pos] == 5)D = Warizan - 1;\n\tif (type[pos] == 6)D = Warizan;\n\treturn D;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tstring S; cin >> S;\n\t\tif (S == \"E\")type[i] = 1;\n\t\tif (S == \"E?\")type[i] = 2;\n\t\tif (S == \"A\")type[i] = 3;\n\t\tif (S == \"A?\")type[i] = 4;\n\t\tif (S == \"R\")type[i] = 5;\n\t\tif (S == \"R?\")type[i] = 6;\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint s, t; cin >> s >> t; x[s].push_back(t);\n\t}\n\tcout << solve(1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n  return 0;\n}\n \nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2%M;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return (res2+1)%M;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    /*for(int i=0;i<edge[x].size();i++)\n      if(n[edge[x][i]]==\"E?\") return (res+1)%M;*/\n    return res%M;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return (res+1)%M;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    return res2%M;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    for(int i=0;i<edge[x].size();i++)\n      if(n[edge[x][i]]==\"E?\") return res2%M;\n    return (res2-1)%M;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long int adjustment = 1000000007;\n\nclass Node{\npublic:\n    string info;\n    int num;\n};\n\nlist<Node> l[1001];\nNode nodes[1001];\n\nlong long int Con(int n,int r){\n    long long int result = 1;\n    for(int i=n;i>n-r;i--){\n        result *= i;\n    }\n    for(int i=1;i<=r;i++){\n        result /= i;\n    }\n    return result;\n}\n\nlong long int DFS(Node node){\n\n\n    long long int sum = 0;\n\n    if(l[node.num].size() == 0){\n        if(node.info == \"E\"){\n            sum = 1;\n        }\n        else{ //E?\n            sum = 2;\n        }\n    }\n    else {\n        for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n            sum += DFS(*it);\n            sum %= adjustment;\n        }\n        if(node.info == \"E?\") {\n            sum = 1;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum *= DFS(*it);\n                sum %= adjustment;\n            }\n            sum++;\n            sum %= adjustment;\n        }\n        else if(node.info == \"E\"){\n            sum = 1;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum *= DFS(*it);\n                sum %= adjustment;\n            }\n        }\n        else if(node.info == \"A?\"){\n            sum = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum += DFS(*it);\n                sum %= adjustment;\n            }\n            sum++;\n            sum %= adjustment;\n        }\n        else if(node.info == \"A\"){\n            sum = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                sum += DFS(*it);\n                sum %= adjustment;\n            }\n        }\n        else if(node.info == \"R?\"){\n            sum = 0;\n            int childcount = l[node.num].size();\n            long long int childsum[childcount] = {0};\n            int k = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                childsum[k] += DFS(*it);\n                childsum[k] %= adjustment;\n                k++;\n            }\n            long long int m = 1 << childcount;\n            for(long long int i=1; i<m; i++){\n                long long int selectsum = 1;\n                for(int j=0; j<childcount; j++){\n                    if( (i >> j) & 1 ){\n                        selectsum = (selectsum*childsum[j]) & adjustment;\n                    }\n                }\n                sum = (sum + selectsum) % adjustment;\n            }\n            sum = (sum+1) % adjustment;\n        }\n        else if(node.info == \"R\"){\n            sum = 0;\n            int childcount = l[node.num].size();\n            long long int childsum[childcount] = {0};\n            int k = 0;\n            for (list<Node>::iterator it = l[node.num].begin(); it != l[node.num].end(); it++) {\n                childsum[k] += DFS(*it);\n                childsum[k] %= adjustment;\n                k++;\n            }\n            long long int m = 1 << childcount;\n            for(long long int i=1; i<m; i++){\n                long long int selectsum = 1;\n                for(int j=0; j<childcount; j++){\n                    if( (i >> j) & 1 ){\n                        selectsum = (selectsum*childsum[j]) & adjustment;\n                    }\n                }\n                sum = (sum + selectsum) % adjustment;\n            }\n\n        }\n    }\n\n    return sum;\n\n}\n\nint main() {\n\n    int n;\n\n    cin >> n;\n\n    for(int i=1;i<=n;i++){\n        string s;\n        cin >> s;\n        nodes[i].info = s;\n        nodes[i].num = i;\n    }\n\n    for(int i=1;i<n;i++){\n        int s,t;\n        scanf(\" %d %d\",&s,&t);\n        l[s].push_back(nodes[t]);\n    }\n\n    cout << DFS(nodes[1]) % adjustment << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n\nll func(int x){\n  ll r=0,i;\n  if(!S){\n    if(n[x]==\"E\") r++;\n    r++;\n  }\n  else if(n[x][0]=='E'){\n    r++;\n    for(i=0;i<S;i++) r*=func(E);\n    if(n[x]==\"E?\") r++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) r+=func(E);\n    if(n[x]==\"A?\") r++;\n  }else{\n    r++;\n    for(i=0;i<S;i++) r*=(1+func(E));\n    if(n[x]==\"R\") r--;\n  }\n  return r%M;\n}\n \nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  while(--N) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long lld;\n#define MOD 1000000007ll\n\nint N;\nstring node[1111];\nvector<lld> edge[1111];\nlld dp[1111];\n\nlld solve(lld now){\n  if(dp[now] != -1) return dp[now];\n  lld ret = 1;\n  if(node[now][0] == 'E'){\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret*solve(edge[now][i]))%MOD;\n    }\n    if(node[now].size() != 1) ret++;\n  } else if(node[now][0] == 'A'){\n    ret = 0;\n    for(int i=0;i<edge[now].size();i++){\n      ret = (ret+solve(edge[now][i]))%MOD;\n    }\n    if(node[now].size() != 1) ret++;\n  } else {\n    ret = 0;\n    if(node[now].size() != 1) ret++;\n    for(int j=1;j<=(int)(pow(2.0,(double)(edge[now].size()))-1);j++){\n      long long next=1;\n      long long d=1;\n      for(int i=0;i<edge[now].size();i++){\n\tif((j&d)!=0){\n\t  next = (next*solve(edge[now][i]))%MOD;\n\t}\n\td=d<<1;\n      }\n      ret+=next;\n    }\n  }    \n  return dp[now] = ret%MOD;\n}\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    cin >> node[i];\n  }\n  for(int i=0;i<N-1;i++){\n    lld a,b;\n    cin >> a >> b;\n    a--; b--;\n    edge[a].push_back(b);\n  }\n  memset(dp,-1,sizeof(dp));\n  cout << solve(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[10001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[10001];\nint dp[10001];\nbool used[10001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\tint res=0;\n\tint sub;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres *= (dfs(ch[v][i]) + d[ch[v][i]].op==1?1:0 );\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+= dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\t\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\t\n\t\t\tsub=1;\n\t\t\trep(i,k){\n\t\t\t\tif( (s>>i) &1 ) sub*= dfs(ch[v][i]) ;\n\t\t\t\tsub%=mod;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,e[s].push_back(t);\n  cout<<func(1)%M<<endl;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!e[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x][0]=='E'){\n    for(int i=0;i<S;i++) res2*=func(E);\n    if(n[x]==\"E?\") res2++;\n    return res2%M;\n  }\n  if(n[x][0]=='A'){\n    for(int i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n    return res%M;\n  }\n  if(n[x][0]=='R'){\n    for(int i=0;i<S;i++) res2*=(1+func(E));\n    if(n[x]==\"R\") res2--;\n    return res2%M;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n\nll func(int x){\n  ll r=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    r++;\n    for(i=0;i<S;i++) r*=func(E);\n    if(n[x]==\"E?\") r++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) r+=func(E);\n    if(n[x]==\"A?\") r++;\n  }else{\n    r++;\n    for(i=0;i<S;i++) r*=(1+func(E));\n    if(n[x]==\"R\") r--;\n  }\n  return r%M;\n}\n \nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  while(--N) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  N--;\n  while(N--) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }else{\n    res++;\n    for(i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  using LL = long long;\n  const LL M = 1000000007;\n\n  int N;\n  cin >> N;\n  vector<string> node(N);\n  vector<vector<int>> child(N);\n  for(auto& n: node) cin >> n;\n  for(int i = 0; i < N; ++i) {\n    int s, t;\n    cin >> s >> t;\n    --s; --t;\n    child[s].push_back(t);\n  }\n\n  auto A = [&node](int n){return node[n][0] == 'A';};\n  auto E = [&node](int n){return node[n][0] == 'E';};\n  auto R = [&node](int n){return node[n][0] == 'R';};\n  auto option = [&node](int n){return node[n].size() == 2;};\n  function<LL(const vector<LL>&,int)> combination = [&](const vector<LL>& list, int n){\n    if(n == list.size()) return 1ll;\n    return (combination(list, n+1) + ((list[n]*combination(list, n+1))%M)) % M;\n  };\n  function<LL(int)> dfs = [&](int cur){\n    LL res;\n    vector<LL> part;\n    for(auto nex: child[cur]) {\n      part.push_back(dfs(nex));\n      if(option(nex)) ++part.back(), res %= M;\n    }\n    if(E(cur)) return accumulate(begin(part), end(part), 1ll, [&](LL lhs, LL rhs){return (lhs * rhs) % M;});\n    if(A(cur)) return accumulate(begin(part), end(part), 0ll, [&](LL lhs, LL rhs){return (lhs + rhs) % M;});\n    if(R(cur)) return (combination(part, 0) + M - 1) % M;\n  };\n  cout << dfs(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n#define PB push_back\nconst int MOD=1e9+7;\nconst int N=1e3+10;\nvector<int> graph[N];\nint type[N];\nbool q[N];\nll ans[N];\nll dfs(int now,int from){\n    if(ans[now]>0)return ans[now];\n    if(type[now]==0){\n        ans[now]++;\n        for(int i:graph[now])if(i!=from){\n            ans[now]*=dfs(i,now);\n            ans[now]%=MOD;\n        }\n        if(q[now])ans[now]++;\n    }\n    else if(type[now]==1){\n        for(int i:graph[now])if(i!=from){\n            ans[now]+=dfs(i,now);\n            ans[now]%=MOD;\n        }\n        if(q[now])ans[now]++;\n    }\n    else{\n        int top=1<<(graph[now].size()-1);\n        ll temp;\n        vector<int> n;\n        for(int i:graph[now])if(i!=from)n.PB(i);\n        for(int i=1;i<top;i++){\n            temp=1;\n            for(int j=0;j<n.size();j++)if(i&(1<<j)){\n                temp*=dfs(n[j],now);\n                temp%=MOD;\n            }\n            ans[now]+=temp;\n            ans[now]%=MOD;\n        }\n        if(q[now])ans[now]++;\n    }\n    return ans[now];\n}\nint main(){\n    int n,l,r;\n    char c[10];\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        ans[i]=0;\n        c[0]=c[1]=' ';\n        scanf(\"%s\",c);\n        q[i]=c[1]=='?';\n        if(c[0]=='A')type[i]=1;\n        else if(c[0]=='R')type[i]=2;\n        else type[i]=0;\n    }\n    for(int i=1;i<n;i++){\n        scanf(\"%d%d\",&l,&r);\n        graph[l].PB(r);\n        graph[r].PB(l);\n    }\n    printf(\"%lld\\n\",dfs(1,0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint nonempty[1000];\nint empty[1000];\nvector<int> g[1000];\nstring type[1000];\nint MOD = 1e9 + 7;\n\nvoid dfs(int x){\n\t// preprocess\n\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\tdfs(g[x][j]);\t\t\t\n\t} \n\tif( type[x][0] != 'E' ){\n\t\t// main process\n\t\tempty[x] = type[x].back() == '?';\n\t\tif( type[x][0] == 'R' ){\n\t\t\tfor(int i = 1 ; i < (1<<g[x].size()) ; i++){\n\t\t\t\tint emp = 1;\n\t\t\t\tint sub = 1;\n\t\t\t\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\t\t\t\tif( i >> j & 1 ){\n\t\t\t\t\t\temp *= empty[g[x][j]];\n\t\t\t\t\t\tsub *= empty[g[x][j]] + nonempty[g[x][j]];\n\t\t\t\t\t\tsub %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//sub -= emp;\n\t\t\t\tempty[x] |= emp;\n\t\t\t\tnonempty[x] += sub;\n\t\t\t\tnonempty[x] %= MOD;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\t\t\tempty[x] |= empty[g[x][j]];\n\t\t\t\tnonempty[x] += nonempty[g[x][j]];\n\t\t\t\tnonempty[x] %= MOD;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tempty[x] = type[x].back() == '?';\n\t\tint sub = 1;\n\t\tint emp = 1;\n\t\tfor(int j = 0 ; j < g[x].size() ; j++){\n\t\t\temp *= empty[g[x][j]];\n\t\t\tsub *= (empty[g[x][j]]+nonempty[g[x][j]]);\n\t\t\tsub %= MOD;\n\t\t\t\n\t\t}\n\t\tnonempty[x] = sub;\n\t\t\n\t\t\n\t}\n\t//cout << x+1 << \"  emp:\" << empty[x] << \" nonemp:\" << nonempty[x] << \"(\" << type[x] << endl;\n\t\n\t\n\t\n}\nsigned main(){\n\tint N;\n\tcin >> N;\n\tfor(int i = 0 ; i < N ; i++)\n\t\tcin >> type[i];\n\tfor(int i = 0 ; i < N - 1 ; i++){\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\t--s,--t;\n\t\tg[s].push_back(t);\n\t}\n\tdfs(0);\n\tcout << ((nonempty[0] + empty[0])%MOD+MOD)%MOD << endl;\n\t\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nvector<string> node;\nvector<vector<int> > edges;\n\nlong long solve(int curr)\n{\n\n    long long ans;\n    if(node[curr][0] == 'E'){\n        ans = 1;\n        for(int next : edges[curr]){\n            ans *= solve(next);\n            ans %= MOD;\n        }\n    }\n    else if(node[curr][0] == 'A'){\n        ans = 0;\n        for(int next : edges[curr]){\n            ans += solve(next);\n            ans %= MOD;\n        }\n    }\n    else{\n        ans = 1;\n        for(int next : edges[curr]){\n            ans *= solve(next) + 1;\n            ans %= MOD;\n        }\n        ans += MOD - 1;\n        ans %= MOD;\n    }\n    \n    if(node[curr].size() == 2){\n        ++ ans;\n        ans %= MOD;\n    }\n\n    return ans;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    node.resize(n);\n    for(int i=0; i<n; ++i)\n        cin >> node[i];\n\n    edges.assign(n, vector<int>());\n    for(int i=0; i<n-1; ++i){\n        int s, t;\n        cin >> s >> t;\n        -- s;\n        -- t;\n        edges[s].push_back(t);\n    }\n\n    cout << solve(0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#define mod 1000000007\nusing namespace std;\n\ntypedef long long ll;\n\nvector<ll> v[1000];\nll s[1000], n;\n\nll dfs(int a) {\n  ll d = 1, i;\n  if(s[a] % 3 == 1) d = 0;\n  for(i = 0; i < v[a].size(); ++i) {\n    ll tmp = dfs(v[a][i]);\n    if(s[a] % 3 == 0) {\n      d *= tmp;\n    } else if(s[a] % 3 == 1) {\n     d += tmp;\n    } else {\n     d *= (tmp + 1);\n    }\n    d %= mod;\n  }\n  if(s[a] % 3 == 2) --d;\n  if(s[a] / 3) ++d;\n  return d;\n}\n\nint main(void) {\n  ll i, j, k;\n  scanf(\"%lld\", &n);\n  for(i = 0; i < n; ++i) {\n    char c[5];\n    scanf(\"%s\", c);\n    if(c[0] == 'E') s[i] = 0;\n    else if(c[0] == 'A') s[i] = 1;\n    else s[i] = 2;\n    if(c[1]) s[i] += 3;\n  }\n  for(i = 1; i < n; ++i) {\n    ll ss, t;\n    scanf(\"%lld%lld\", &ss, &t);\n    ss--, t--;\n    v[ss].push_back(t);\n  }\n  printf(\"%lld\\n\", dfs(0));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int mod = 1000000007;\nint main() {\n    int N;\n    cin >> N;\n    vector<string> tp(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> tp[i];\n    }\n    vector<vector<int> > g(N);\n    for(int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b; --a, --b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    function<int(int, int)> rec = [&](int pos, int pre) {\n        int ans = 0;\n        if(tp[pos][0] == 'E') {\n            ans = 1;\n            for(int i : g[pos]) {\n                if(i != pre) {\n                    ans = 1LL * ans * rec(i, pos) % mod;\n                }\n            }\n        }\n        if(tp[pos][0] == 'R') {\n            ans = 1;\n            for(int i : g[pos]) {\n                if(i != pre) {\n                    ans = 1LL * ans * (rec(i, pos) + (tp[i].find(\"?\") != string::npos ? 0 : 1)) % mod;\n                }\n            }\n            ans = (ans + mod - 1) % mod;\n        }\n        if(tp[pos][0] == 'A') {\n            ans = 0;\n            for(int i : g[pos]) {\n                if(i != pre) {\n                    ans = (ans + rec(i, pos)) % mod;\n                    if(tp[i].find(\"?\") != string::npos) {\n                        ans = (ans + mod - 1) % mod;\n                    }\n                }\n            }\n        }\n        if(tp[pos].find(\"?\") != string::npos) {\n            ans = (ans + 1) % mod;\n        }\n        return ans;\n    };\n    int ans = rec(0, -1);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[1001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[1001];\nint dp[1001];\nbool used[1001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+= dfs(ch[v][i])\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\tint sub=1;\n\t\t\trep(i,k){\n\t\t\t\tif((s>>i) &1) sub*= dfs(ch[v][i]) ;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[10001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[10001];\nint dp[10001];\nbool used[10001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+= dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tint sub;\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\t\n\t\t\tsub=1;\n\t\t\trep(i,k){\n\t\t\t\tif( (s>>i) &1 ) sub*= dfs(ch[v][i]) ;\n\t\t\t\tsub%=mod;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0;\n  if(!e[x].size()){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(int i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  else if(n[x][0]=='A'){\n    for(int i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }else{\n    res++;\n    for(int i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nconst int mod = 1000000007;\nint n, a, b; string s[1009]; vector<int> G[1009];\nint solve(int pos, int pre) {\n\tvector<int> res;\n\tfor (int i : G[pos]) {\n\t\tif (i == pre) continue;\n\t\tres.push_back(solve(i, pos));\n\t}\n\tint ret = 0;\n\tif (s[pos][0] == 'A') for (int i : res) ret = (ret + i) % mod;\n\telse if(s[pos][0] == 'R') {\n\t\tret = 1;\n\t\tfor (int i : res) ret = 1LL * ret * (i + 1) % mod;\n\t\tret = (ret + mod - 1) % mod;\n\t}\n\telse {\n\t\tret = 1;\n\t\tfor (int i : res) ret = 1LL * ret * i % mod;\n\t}\n\tif (s[pos].size() == 2) ret++;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> s[i];\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b; a--, b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint ret = solve(0, -1);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1000\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[T];\nvector<int> edge[T];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x][0]=='E'){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    if(n[x]==\"E?\") res2++;\n    return res2%M;\n  }\n  if(n[x][0]=='A'){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    if(n[x]==\"A?\") res++;\n    return res%M;\n  }\n  if(n[x][0]=='R'){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    if(n[x]==\"R\") res2--;\n    return res2%M;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n \nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    return res2;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++){\n      if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n      else res2*=(1+func(edge[x][i]));\n    }\n    for(int i=0;i<edge[x].size();i++)\n      if(n[edge[x][i]]==\"E?\") return res2;\n    return res2-1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n\nll func(int);\n\nint N,s,t;\nbool visited[N_MAX];\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2-1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint p[310][310] = {};\nint rui[310][310] = {};\n\n\ntypedef struct{\n  int num;\n  int idx;\n} Data;\nData dp[310][310][310] = {};\n\nint getRuiseki(int x1, int y1, int x2,int y2){\n  if(x1 > x2 || y1 > y2)        return 0;\n  x2++; y2++;\n  return rui[y2][x2] - rui[y2][x1] - rui[y1][x2] + rui[y1][x1];\n}\n\nint getDonut(int x1, int y1, int x2, int y2){\n  return getRuiseki(x1,y1,x2,y2) - getRuiseki(x1+1,y1+1,x2-1,y2-1);\n}\n\nint getL(int x1, int x2, int y){\n  return getRuiseki(x1,0,x2,y) - getRuiseki(x1, 0, x2-1, y-1);\n}\n\nint main(){\n  cin >> n;\n  for(int i = 1;i <= n;i++){\n    for(int j = 1;j <= n;j++){\n      cin >> rui[i][j];\n    }\n  }\n\n  for(int i = 0;i <= n;i++){\n    for(int j = 0;j <= n;j++){\n      rui[i][j+1] += rui[i][j];\n    }\n  }\n\n  for(int j = 0;j <= n;j++){\n    for(int i = 0;i <= n;i++){\n      rui[i+1][j] += rui[i][j];\n    }\n  }\n\n\n  for(int finx = n-1;finx >= 0;finx--){\n    for(int x = finx;x >= 0;x--){\n      dp[finx][x][n-1].num = getRuiseki(x, n-1, finx, n-1);\n      dp[finx][x][n-1].idx = n-1;\n      for(int y = n-2;y >= 0;y--){\n        int tmp = getRuiseki(x+1,y,finx-1,y);\n        if(tmp > dp[finx][x][y+1].num){\n          dp[finx][x][y].num = getRuiseki(x,y,finx,y);\n          dp[finx][x][y].idx = y;\n        }else{\n          dp[finx][x][y] = dp[finx][x][y+1];\n        }\n      }\n    }\n  }\n\n  int ans = INT_MIN;\n  for(int x = 0; x < n; x++){\n    for(int y = 0;y < n;y++){\n      for(int x2 = x;x2 < n;x2++){\n        ans = max(ans,getDonut(x,y,x2,dp[x2][x][y].idx));\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define int long long\nconst int MOD = 1000000007;\nusing namespace std;\n\nint dp[2000];\n\nint f(int node, vector<vector<int>> &g, vector<string> &c){\n\t\n\tif(dp[node] != 0) return dp[node];\n\tint sz = g[node].size();\n\t// きていけーす\n\tif(sz == 0){\n\t\tint ret;\n\t\tif(c[node] == \"E\") ret = 1;\n\t\telse ret = 2;\n\t}\n\n\tif(c[node][0] == 'E'){\n\n\t\tint ret = 1;\n\t\tfor(int j = 0; j < sz; j++){\n\t\t\tint next = g[node][j];\n\t\t\tret *= f(next, g, c);\n\t\t\tret %= MOD;\n\t\t}\n\n\t\tif(c[node].size() == 2) ret++;\n\t\tret %= MOD;\n\t\tdp[node] = ret;\n\t\treturn ret;\n\n\t}else if(c[node][0] == 'A'){\n\t\t\n\t\tint ret = 0;\n\t\tfor(int j = 0; j < sz; j++){\n\t\t\tint next = g[node][j];\n\t\t\tret += f(next, g, c);\n\t\t\tret %= MOD;\n\t\t}\n\n\t\tif(c[node].size() == 2) ret++;\n\t\tret %= MOD;\n\t\tdp[node] = ret;\n\t\treturn ret;\n\n\t}else if(c[node][0] == 'R'){\n\t\t\n\t\tint ret = 0;\n\t\tfor(int bit = 1; bit < (1 << sz); bit++){\n\t\t\t\n\t\t\tint add = 1;\n\t\t\tfor(int j = 0; j < sz; j++){\n\t\t\t\tint next = g[node][j];\n\t\t\t\tif(bit & (1 << j)) add *= f(next, g, c);\n\t\t\t\tadd %= MOD;\n\t\t\t}\n\t\t\tret += add;\n\t\t}\n\n\t\tif(c[node].size() == 2) ret++;\n\t\tret %= MOD;\n\t\tdp[node] = ret;\n\t\treturn ret;\n\n\t}else assert(false);\n\treturn 0;\n}\n\nsigned main(){\n\n\tint n; cin >> n;\n\tvector<string> c(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> c[i];\n\t}\n\n\tvector<vector<int>> g(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint s, t; cin >> s >> t;\n\t\ts--;\n\t\tt--;\n\t\tg[s].push_back(t);\n\t}\n\n\tcout << f(0, g, c) << endl;\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n\nll func(int);\n\nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<(1<<edge[x].size());i++){\n      ll t=1;\n      for(int j=0;j<edge[x].size();j++)\n\tif(i&(1<<j)) t*=func(edge[x][j]);\n      res+=t;\n    }\n    return res;\n  }\n  if(n[x]==\"R\"){\n    for(int i=1;i<(1<<edge[x].size());i++){\n      ll t=1;\n      for(int j=0;j<edge[x].size();j++)\n\tif(i&(1<<j)) t*=func(edge[x][j]);\n      res+=t;\n    }\n    return res;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  using LL = long long;\n  const LL M = 1000000007;\n\n  int N;\n  cin >> N;\n  vector<string> node(N);\n  vector<vector<int>> child(N);\n  for(auto& n: node) cin >> n;\n  for(int i = 0; i < N; ++i) {\n    int s, t;\n    cin >> s >> t;\n    --s; --t;\n    child[s].push_back(t);\n  }\n\n  auto A = [&node](int n){return node[n][0] == 'A';};\n  auto E = [&node](int n){return node[n][0] == 'E';};\n  auto R = [&node](int n){return node[n][0] == 'R';};\n  auto option = [&node](int n){return node[n].size() == 2 ? 1ll : 0ll;};\n  function<LL(const vector<LL>&,int)> combination = [&](const vector<LL>& list, int n){\n    if(n == list.size()) return 1ll;\n    return (combination(list, n+1) + ((list[n]*combination(list, n+1))%M)) % M;\n  };\n  function<LL(int)> dfs = [&](int cur){\n    vector<LL> part;\n    for(auto nex: child[cur]) part.push_back(dfs(nex));\n    if(E(cur)) return option(cur) + accumulate(begin(part), end(part), 1ll, [&](LL lhs, LL rhs){return (lhs * rhs) % M;}) % M;\n    if(A(cur)) return option(cur) + accumulate(begin(part), end(part), 0ll, [&](LL lhs, LL rhs){return (lhs + rhs) % M;}) % M;\n    if(R(cur)) return option(cur) + (combination(part, 0) + M - 1) % M;\n  };\n  cout << dfs(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define m 1000000007LL\nusing namespace std;\ntypedef long long ll;\nint n;\nstring x[1001];\nvector <int> G[1001];\nll SUM,R[11];\n\nvoid saiki2(int ima,ll sum){\n  if(ima==-1)return;\n  for(int i=ima-1;i>=0;i--) saiki2(i,sum*R[i]);\n  SUM+=sum;\n}\n\nll saiki(int ima){\n  ll S=G[ima].size(),res=1,r[11];\n  for(int i=0;i<S;i++)r[i]=saiki(G[ima][i]);\n  \n  if(x[ima][0]=='E')\n    for(int i=0;i<S;i++) res*=r[i];\n  \n  if(x[ima][0]=='A'){\n    res=0;\n    for(int i=0;i<S;i++) res+=r[i];\n  }\n  if(x[ima][0]=='R'){\n    SUM=0;\n    for(int i=0;i<S;i++) R[i]=r[i];\n    saiki2(S,1);\n    res=SUM-1;\n  }\n  return (res+x[ima].size()-1)%m;\n}\n\nint main(){\n  cin >>n;\n  for(int i=1;i<=n;i++)cin>>x[i];\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin >>a>>b;\n    G[a].push_back(b);\n  }\n  cout <<saiki(1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX 1000000007\n\nchar nodetype[1000];\t//?????????i???????????? E:?????? R:or A:alt\nbool option[1000];\t//?????????i??????????????§?????????true\nint childN[1000];\nint child[1000][10];\n\nlong long tansaku(int x){\t//?????????x??\\??????????????????????????????????????°?????????\n\tlong long ans=0;\n\tif(option[x]) ans++;\n\n\tlong long tmp;\n\tif(nodetype[x]=='A'){\t//alt??????????????????\n\t\ttmp = 0;\n\t\tfor(int i=0;i<childN[x];i++){\n\t\t\ttmp = (tmp + tansaku(child[x][i])) % MAX;\n\t\t}\n\t}else if(nodetype[x]=='R'){\t//or??????????????????\n\t\ttmp=1;\n\t\tfor(int i=0;i<childN[x];i++){\n\t\t\ttmp = (tmp * (tansaku(child[x][i])+1)) % MAX;\n\t\t}\n\t\ttmp--;\n\t}else if(nodetype[x]=='E'){\t//???????????????\n\t\ttmp = 1;\n\t\tfor(int i=0;i<childN[x];i++){\n\t\t\ttmp = (tmp * tansaku(child[x][i])) % MAX;\n\t\t}\n\t}\n\n\tans = (ans + tmp + MAX) % MAX;\n\treturn ans;\n}\n\nint main(){\n\tint n,i;\n\tchar node[3];\n\tint s,t;\n\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>node;\n\t\tnodetype[i] = node[0];\n\t\toption[i] = (node[1]=='?');\n\t\tchildN[i] = 0;\n\t}\n\tfor(i=0;i<n-1;i++){\n\t\tcin>>s>>t;\n\t\ts--;t--;\n\t\tchild[s][childN[s]++] = t;\n\t}\n\n\tcout<<tansaku(0)<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\nusing namespace std;\ntypedef long long ll;\n\nll func(int);\n\nint N,s,t;\nbool visited[N_MAX];\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    if(res==0) return 0;\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    return res2;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    if(res2==1) return 0;\n    return res2-1;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n#define PB push_back\nconst int MOD=1e9+7;\nconst int N=1e3+10;\nvector<int> graph[N];\nint type[N];\nbool q[N];\nll ans[N];\nll dfs(int now,int from){\n    if(ans[now]>0)return ans[now];\n    if(type[now]==0){\n        ans[now]++;\n        for(int i:graph[now])if(i!=from){\n            ans[now]*=dfs(i,now);\n            ans[now]%=MOD;\n        }\n        if(q[now])ans[now]++;\n    }\n    else if(type[now]==1){\n        for(int i:graph[now])if(i!=from){\n            ans[now]+=dfs(i,now);\n            ans[now]%=MOD;\n        }\n        if(q[now])ans[now]++;\n    }\n    else{\n        int top;top=1<<(graph[now].size()-1);\n        ll temp;\n        vector<int> n;\n        for(int i:graph[now])if(i!=from)n.PB(i);\n        top=1<<(n.size());\n        for(int i=1;i<top;i++){\n            temp=1;\n            for(int j=0;j<n.size();j++)if(i&(1<<j)){\n                temp*=dfs(n[j],now);\n                temp%=MOD;\n            }\n            ans[now]+=temp;\n            ans[now]%=MOD;\n        }\n        if(q[now])ans[now]++;\n    }\n    return ans[now];\n}\nint main(){\n    int n,l,r;\n    char c[10];\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        ans[i]=0;\n        c[0]=c[1]=' ';\n        scanf(\"%s\",c);\n        q[i]=c[1]=='?';\n        if(c[0]=='A')type[i]=1;\n        else if(c[0]=='R')type[i]=2;\n        else type[i]=0;\n    }\n    for(int i=1;i<n;i++){\n        scanf(\"%d%d\",&l,&r);\n        graph[l].PB(r);\n        graph[r].PB(l);\n    }\n    printf(\"%lld\\n\",dfs(1,0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int MOD = 1000000007;\n\nstruct node {\n    int type;\n    bool option;\n    vector<int> child;\n    node(int type, bool option) : type(type), option(option) {};\n};\n\nint pattern(node&);\nint material_node(node&);\nint alt_node(node&);\nint or_node(node&);\n\nint n;\nvector<node> tree;\n\nint pattern(node &now) {\n\n    int ret = 0;\n\n    switch(now.type) {\n        case 0:\n            ret = material_node(now);\n            break;\n        case 1:\n            ret = alt_node(now);\n            break;\n        case 2:\n            ret = or_node(now);\n            break;\n    }\n\n    return ret % MOD;\n}\n\nint material_node(node &now) {\n\n    int ret = 1;\n\n    for(int i = 0; i < now.child.size(); ++i) {\n        ret = ret * pattern(tree[now.child[i]]) % MOD;\n    }\n\n    ret += now.option;\n\n    return ret % MOD;\n\n}\n\nint alt_node(node &now) {\n\n    int ret = 0;\n\n    for(int i = 0; i < now.child.size(); ++i) {\n        ret = (ret + pattern(tree[now.child[i]])) % MOD;\n    }\n\n    ret += now.option;\n\n    return ret % MOD;\n\n}\n\nint or_node(node &now) {\n\n    int ret = 0;\n\n    for(int i = 1; i < (1 << now.child.size()); ++i) {\n        int seki = 1;\n        for(int j = 0; j < now.child.size(); ++j) {\n            if((i >> j) & 1) {\n                seki = seki * pattern(tree[now.child[j]]) % MOD;\n            }\n        }\n        ret = (ret + seki) % MOD;\n    }\n\n    ret += now.option;\n\n    return ret % MOD;\n}\n\nmain() {\n\n    cin >> n;\n\n    for(int i = 0; i < n; ++i) {\n        int t;\n        bool o;\n        string s;\n\n        cin >> s;\n\n        if(s[0] == 'E') {\n            t = 0;\n        } else if(s[0] == 'A') {\n            t = 1;\n        } else if(s[0] == 'R') {\n            t = 2;\n        }\n\n        o = s.size() - 1;\n\n        tree.push_back(node(t, o));\n    }\n\n    for(int i = 0; i < n - 1; ++i) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n        tree[s].child.push_back(t);\n    }\n\n    cout << pattern(tree[0]) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nstring tp[1010];\nll dp[1010];\nvector<int> G[1010];\n\nll solve(int cur) {\n    vector<ll> vals;\n    for(auto to : G[cur]) {\n        auto v = solve(to);\n        vals.emplace_back(v);\n    }\n\n    ll res;\n    if(tp[cur][0] == 'E') {\n        res = 1;\n        for(auto v : vals) (res *= v) %= MOD;\n        if(tp[cur].size() > 1) (res += 1) %= MOD;\n    }\n    if(tp[cur][0] == 'A') {\n        res = 0;\n        for(auto v : vals) (res += v) %= MOD;\n        if(tp[cur].size() > 1) (res += 1) %= MOD;\n    }\n    if(tp[cur][0] == 'R') {\n        res = 1;\n        for(auto v : vals) (res *= 1 + v) %= MOD;\n        if(tp[cur].size() == 1) (res += MOD - 1) %= MOD;\n    }\n    // fprintf(stderr, \"solve %d: %lld\\n\", cur, res);\n    return res;\n}\n \nint main() {\n    int N; cin >> N;\n    for(int i=0; i<N; i++) {\n        cin >> tp[i];\n    }\n\n    for(int i=0; i<N-1; i++) {\n        int s, t; cin >> s >> t;\n        s--; t--;\n        G[s].emplace_back(t);\n    }\n\n    cout << solve(0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nenum Shape{\n\tCircle,\n\tTriangle,\n};\n\nenum Type{\n\tNormal,\n\tOption,\n};\n\nenum Choice{\n\tNone,\n\tOR,\n\tALT,\n};\n\nstruct Node{\n\tvoid set(Shape arg_shape,Type arg_type,Choice arg_choice){\n\t\tshape = arg_shape;\n\t\ttype = arg_type;\n\t\tchoice = arg_choice;\n\t}\n\tShape shape;\n\tType type;\n\tChoice choice;\n\tvector<int> children;\n};\n\nNode nodes[1000];\n\nll calc(int node_id){\n\n\tll sum;\n\tif(nodes[node_id].shape == Circle){\n\t\tsum = 1;\n\t\tfor(int i = 0; i < nodes[node_id].children.size(); i++){\n\t\t\tsum *= calc(nodes[node_id].children[i])%MOD;\n\t\t}\n\t}else{\n\t\tif(nodes[node_id].choice == OR){\n\t\t\tsum = 1;\n\t\t\tfor(int i = 0; i < nodes[node_id].children.size();i++){\n\t\t\t\tsum *= (calc(nodes[node_id].children[i])+1)%MOD;\n\t\t\t}\n\t\t\tsum -= 1;\n\t\t}else{\n\t\t\tsum = 0;\n\t\t\tfor(int i = 0; i < nodes[node_id].children.size();i++){\n\t\t\t\tsum += calc(nodes[node_id].children[i])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif(nodes[node_id].type == Option)sum = (sum+1)%MOD;\n\treturn sum%MOD;\n}\n\nint main(){\n\n\tint N,parent,child;\n\tchar buf[5];\n\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",buf);\n\t\tif(buf[0] == 'E'){\n\t\t\tif(buf[1] == '\\0'){\n\t\t\t\tnodes[i].set(Circle,Normal,None);\n\t\t\t}else{\n\t\t\t\tnodes[i].set(Circle,Option,None);\n\t\t\t}\n\t\t}else{\n\t\t\tif(buf[0] == 'A'){\n\t\t\t\tif(buf[1] == '\\0'){\n\t\t\t\t\tnodes[i].set(Triangle,Normal,ALT);\n\t\t\t\t}else{\n\t\t\t\t\tnodes[i].set(Triangle,Option,ALT);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(buf[1] == '\\0'){\n\t\t\t\t\tnodes[i].set(Triangle,Normal,OR);\n\t\t\t\t}else{\n\t\t\t\t\tnodes[i].set(Triangle,Option,OR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tscanf(\"%d %d\",&parent,&child);\n\t\tparent--;\n\t\tchild--;\n\t\tnodes[parent].children.push_back(child);\n\t}\n\n\tprintf(\"%lld\\n\",calc(0)%MOD);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n\nll func(int x){\n  ll r=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  else if(n[x][0]=='E'){\n    r++;\n    for(i=0;i<S;i++) r*=func(E);\n    if(n[x]==\"E?\") r++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) r+=func(E);\n    if(n[x]==\"A?\") r++;\n  }else{\n    r++;\n    for(i=0;i<S;i++) r*=(1+func(E));\n    if(n[x]==\"R\") r--;\n  }\n  return r%M;\n}\n \nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  while(--N) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  while(--N) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll r=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    r++;\n    for(i=0;i<S;i++) r*=func(E);\n    if(n[x]==\"E?\") r++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) r+=func(E);\n    if(n[x]==\"A?\") r++;\n  }else{\n    r++;\n    for(i=0;i<S;i++) r*=(1+func(E));\n    if(n[x]==\"R\") r--;\n  }\n  return r%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long int ll;\nstatic const int MAX_N = 1000;\nstatic const ll MOD = 1000000007;\n\nint N;\nstring node[MAX_N];\nvector<int> G[MAX_N];\n\nll rec(int v, int pv){\n\tll ret;\n\tif(node[v][0] == 'E' || node[v][0] == 'R') ret = 1;\n\telse ret = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == pv) continue;\n\t\tif(node[v][0] == 'E') ret *= rec(G[v][i], v);\n\t\telse if(node[v][0] == 'A') ret += rec(G[v][i], v);\n\t\telse ret *= (rec(G[v][i], v) + 1);\n\t\tret %= MOD;\n\t}\n\tif(node[v][0] != 'R' && node[v].length() == 2 && node[v][1] == '?'){\n\t\tret++;\n\t\tret %= MOD;\n\t}\n\tif(node[v] == \"R\"){\n\t\tret--;\n\t\tif(ret < 0) ret += MOD;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++) cin >> node[i];\n\tfor(int i = 0; i < N - 1; i++){\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\ts--;\n\t\tt--;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\tprintf(\"%lld\\n\", rec(0, -1));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <tuple>\n#include <set>\n#include <string>\n#include <queue>\n\n#define int long long\n\nusing namespace std;\n\nclass Solver {\n};\n\nlong long dfs(int now,int mask, vector<set<int>> graph,\n\tvector<char>mode, vector<bool>option) {\n\n\tint pat;\n\tvector<int> children;\n\tfor (int child : graph[now]) {\n\t\tchildren.emplace_back(dfs(child, mask, graph, mode, option));\n\t}\n\tif (mode[now] == 'E') {\n\t\tpat = 1;\n\t\tfor (int i = 0; i < children.size(); i++) {\n\t\t\tpat *= children[i];\n\t\t\tpat %= mask;\n\t\t}\n\t}\n\telse if (mode[now] == 'A') {\n\t\tpat = 0;\n\t\tfor (int i = 0; i < children.size(); i++) {\n\t\t\tpat += children[i];\n\t\t\tpat %= mask;\n\t\t}\n\t}\n\telse {\n\t\tpat = 1;\n\t\tfor (int i = 0; i < children.size(); i++) {\n\t\t\tpat *= children[i]+1;\n\t\t\tpat %= mask;\n\t\t}\n\t\tpat--;\n\t}\n\tif (option[now])pat++;\n\n\treturn pat;\n}\n\nsigned main() {\n\tint n;\n\tcin >> n;\n\n\tvector<char> mode(n);\n\tvector<bool> option(n);\n\tvector<set<int>> graph(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tmode[i] = s[0];\n\t\tif (s.size() > 1)option[i] = true;\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\ts--;\n\t\tt--;\n\t\tgraph[s].emplace(t);\n\t}\n\n\tint mask = 1000000000 + 7;\n\n\tcout << dfs(0, mask, graph, mode, option) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//1\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b)for(int i=(a); i<(b); i++)\n#define REP(i,n)FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b){if (a<b){a = b; return 1;}return 0;}\ntemplate<typename A, typename B> inline bool chmin(A &a, B b){if (a>b){a = b; return 1;}return 0;}\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll>pll;\ntypedef pair<int,pii>pip;\n\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n\nint N;\nstring pat[1000];\nvector<int> g[1000];\nll dp[1000];\n\nll dfs(int u) {\n\tif (~dp[u]) return dp[u];\n\t\n\tll &res = dp[u];\n\tres = 0;\n\t\n\tif (g[u].size() == 0) res++;\n\t\n\tswitch (pat[u][0]) {\n\t\tcase 'E': // ???????????????\n\t\t\tres = 1;\n\t\t\tREP(i, g[u].size()) res = res * dfs(g[u][i]) % MOD;\n\t\t\tbreak;\n\t\tcase 'R': // OR\n\t\t\tFOR(i, 1, 1<<g[u].size()) {\n\t\t\t\tll now = 1;\n\t\t\t\tREP(j, g[u].size()) if (i >> j & 1) now = now * dfs(g[u][j]) % MOD;\n\t\t\t\tres = (res + now) % MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'A': // Alt\n\t\t\tREP(i, g[u].size()) res = (res + dfs(g[u][i])) % MOD;\n\t\t\tbreak;\n\t}\n\t\n\tif (pat[u].size() > 1) res++;\n\treturn res %= MOD;\n}\n\nint main(){\n\tcin >> N;\n\tREP(i, N) cin >> pat[i];\n\tREP(i, N - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tg[a - 1].push_back(b - 1);\n\t}\n\t\n\tmemset(dp, -1, sizeof(dp));\n\tcout << dfs(0) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  while(--N) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll r=0,i;\n  if(!S){\n    if(n[x]==\"E\") r++;\n    r++;\n  }\n  if(n[x][0]=='E'){\n    r++;\n    for(i=0;i<S;i++) r*=func(E);\n    if(n[x]==\"E?\") r++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) r+=func(E);\n    if(n[x]==\"A?\") r++;\n  }else{\n    r++;\n    for(i=0;i<S;i++) r*=(1+func(E));\n    if(n[x]==\"R\") r--;\n  }\n  return r%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nll func(int);\nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nmain(){\n  int i;\n  cin>>N;\n  for(i=0;i<N;i++) cin>>n[i];\n  for(i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}\n\nll func(int x){\n  ll res=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    res++;\n    for(i=0;i<S;i++) res*=func(E);\n    if(n[x]==\"E?\") res++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n  }else{\n    res++;\n    for(i=0;i<S;i++) res*=(1+func(E));\n    if(n[x]==\"R\") res--;\n  }\n  return res%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1001\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\nint N,s,t,j;\nstring n[T];\nvector<int> e[T];\n \nll func(int x){\n  ll r=0,i;\n  if(!S){\n    if(n[x]==\"E\") return 1;\n    return 2;\n  }\n  if(n[x][0]=='E'){\n    r++;\n    for(i=0;i<S;i++) r*=func(E);\n    if(n[x]==\"E?\") r++;\n  }\n  else if(n[x][0]=='A'){\n    for(i=0;i<S;i++) r+=func(E);\n    if(n[x]==\"A?\") r++;\n  }else{\n    r++;\n    for(i=0;i<S;i++) r*=(1+func(E));\n    if(n[x]==\"R\") r--;\n  }\n  return r%M;\n}\n\nmain(){\n  cin>>N;\n  for(j=0;j<N;j++) cin>>n[j];\n  while(--N) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x][0]=='E'){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    if(n[x]==\"E\") return res2%M;\n    return (res2+1)%M;\n  }\n  if(n[x][0]=='A'){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    if(n[x]==\"A\") return res%M;\n    return (res+1)%M;\n  }\n  if(n[x][0]=='R'){\n    for(int i=0;i<edge[x].size();i++) res2*=(1+func(edge[x][i]));\n    if(n[x]==\"R?\") return res2%M;\n    return (res2-1)%M;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[1001];\nbool sss[1001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[1001];\nint dp[1001];\nbool used[1001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\t//puts(\"a\");\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\trep(i,ch[v].size()){\n\t\t\tres+=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\t//cout<<k<<\" \"<<v<<endl;\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\tint sub=1;\n\t\t\trep(i,k){\n\t\t\t\tif((s>>i) &1) sub*=dfs(ch[v][i]);\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t/*rep(i,N){\n\t\tcout<<i<<endl;\n\t\tcout<<d[i].type<<\" \"<<d[i].op<<endl;\n\t\trep(j,ch[i].size()) cout<<ch[i][j]<<\" \";\n\t\tcout<<endl<<endl<<endl;\n\t}*/\n\t\n\tcout<< dfs(0) <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1000\n#define M 1000000007\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n  return 0;\n}\n \nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2%M;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return (res2+1)%M;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res%M;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return (res+1)%M;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<edge[x].size();i++){\n      /*if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n\telse*/ res2*=(1+func(edge[x][i]));\n    }\n    return res2%M;\n  }\n  if(n[x]==\"R\"){\n    for(int i=0;i<edge[x].size();i++){\n      /*if(n[edge[x][i]]==\"E?\") res2*=func(edge[x][i]);\n\telse*/ res2*=(1+func(edge[x][i]));\n    }\n    /*for(int i=0;i<edge[x].size();i++)\n      if(n[edge[x][i]]==\"E?\") return res2%M;*/\n    return (res2-1)%M;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator-(const Mod a, const long long int  b) { return a-Mod(b); }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct node {\n\tstring type;\n\tvector<int>tos;\n\n};\nMod getans(const int now,const vector<node>&nodes) {\n\tif (nodes[now].type == \"E\") {\n\t\tMod ans = 1;\n\t\tfor (auto e : nodes[now].tos) {\n\t\t\tMod a(getans(e, nodes));\n\t\t\tans *= a;\n\t\t}\n\t\treturn ans;\n\t}\n\telse if (nodes[now].type == \"E?\") {\n\t\tMod ans = 1;\n\t\tfor (auto e : nodes[now].tos) {\n\t\t\tMod a(getans(e, nodes));\n\t\t\tans *= a;\n\t\t}\n\t\treturn ans + 1ll;\n\t}\n\telse if (nodes[now].type == \"A\") {\n\t\tMod ans = 0;\n\t\tfor (auto e : nodes[now].tos) {\n\t\t\tMod a(getans(e, nodes));\n\t\t\tans += a;\n\t\t}\n\t\treturn ans;\n\t}\n\telse if (nodes[now].type == \"A?\") {\n\t\tMod ans = 0;\n\t\tfor (auto e : nodes[now].tos) {\n\t\t\tMod a(getans(e, nodes));\n\t\t\tans += a;\n\t\t}\n\t\treturn ans+1ll;\n\t}\n\telse if (nodes[now].type == \"R\") {\n\t\tMod ans = 1;\n\t\tfor (auto e : nodes[now].tos) {\n\t\t\tMod a(getans(e, nodes));\n\t\t\tans *= a+1ll;\n\t\t}\n\t\treturn ans - 1ll;\n\t}\n\telse if (nodes[now].type == \"R?\") {\n\t\tMod ans = 1;\n\t\tfor (auto e : nodes[now].tos) {\n\t\t\tMod a(getans(e, nodes));\n\t\t\tans *= a + 1ll;\n\t\t}\n\t\treturn ans;\n\t}\n}\nint main() {\n\tint N; cin >> N;\n\tvector<node>nodes;\n\tfor (int i = 0; i < N; ++i) {\n\t\tstring st; cin >> st;\n\t\tnodes.push_back(node{ st,vector<int>() });\n\t}\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint s, t; cin >> s >> t; s--; t--;\n\t\tnodes[s].tos.push_back(t);\n\t}\n\tMod ans(getans(0, nodes));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define T 1000\n#define M 1000000007\n#define E e[x][i]\n#define S e[x].size()\nusing namespace std;\ntypedef long long ll;\n \nll func(int);\n \nint N,s,t;\nstring n[T];\nvector<int> e[T];\n \nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,e[s-1].push_back(t-1);\n  cout<<func(0)%M<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!e[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x][0]=='E'){\n    for(int i=0;i<S;i++) res2*=func(E);\n    if(n[x]==\"E?\") res2++;\n    return res2%M;\n  }\n  if(n[x][0]=='A'){\n    for(int i=0;i<S;i++) res+=func(E);\n    if(n[x]==\"A?\") res++;\n    return res%M;\n  }\n  if(n[x][0]=='R'){\n    for(int i=0;i<S;i++) res2*=(1+func(E));\n    if(n[x]==\"R\") res2--;\n    return res2%M;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rrep1(i,n) for(int i=n;i>=1;i--)\n#define pb push_back\n\nvector<int> ch[1001];\n\nint N;\nconst int mod=1000000007;\nstruct node{\n\tint type;\n\tint op;\n};\nint ans;\n\nnode d[1001];\nint dp[1001];\nbool used[1001];\nstring s;\nint cnt=0;\n\nint dfs(int v){\n\t\n\tif(dp[v]>=0) return dp[v];\n\n\tint res=0;\n\tif(ch[v].size()==0) res=1;\n\telse if(d[v].type==0){\n\t\tres=1;\n\t\trep(i,ch[v].size()){\n\t\t\tres*=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==1){\n\t\tres=0;\n\t\trep(i,ch[v].size()){\n\t\t\tres+=dfs(ch[v][i]);\n\t\t\tres%=mod;\n\t\t}\n\t}\n\telse if(d[v].type==2){\n\t\tres=0;\n\t\tint k=ch[v].size();\n\t\tfor(int s=1;s< (1<<k); s++){\n\t\t\tint sub=1;\n\t\t\trep(i,k){\n\t\t\t\tif((s>>i) &1) sub*= (dfs(ch[v][i]) - (d[ch[v][i]].op==0?0:1) ) ;\n\t\t\t}\n\t\t\tres+=sub;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tif(d[v].op==1) res++;\n\treturn dp[v]=(res%mod);\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>s;\n\t\td[i].type=d[i].op=0;\n\t\tif(s[0]=='A'){\n\t\t\td[i].type=1;\n\t\t}\n\t\telse if(s[0]=='R'){\n\t\t\td[i].type=2;\n\t\t}\n\t\telse if(s[0]=='E'){\n\t\t\td[i].type=0;\n\t\t}\n\t\t\n\t\tif(s.size()>=2){\n\t\t\td[i].op=1;\n\t\t}\n\t}\n\tint x,y;\n\trep(i,N-1){\n\t\tcin>>x>>y;\n\t\tx--; y--;\n\t\tch[x].pb(y);\n\t}\n\t\n\tcout<< dfs(0)%mod <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define N_MAX 1002\nusing namespace std;\ntypedef long long ll;\n\nll func(int);\n\nint N,s,t;\nstring n[N_MAX];\nvector<int> edge[N_MAX];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++) cin>>n[i];\n  for(int i=0;i<N-1;i++) cin>>s>>t,edge[s-1].push_back(t-1);\n  cout<<func(0)%1000000007<<endl;\n  return 0;\n}\n\nll func(int x){\n  ll res=0,res2=1;\n  if(!edge[x].size()){\n    if(n[x]==\"E\") return 1;\n    if(n[x]==\"E?\") return 2;\n    return 0;\n  }\n  if(n[x]==\"E\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2;\n  }\n  if(n[x]==\"E?\"){\n    for(int i=0;i<edge[x].size();i++) res2*=func(edge[x][i]);\n    return res2+1;\n  }\n  if(n[x]==\"A\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res;\n  }\n  if(n[x]==\"A?\"){\n    for(int i=0;i<edge[x].size();i++) res+=func(edge[x][i]);\n    return res+1;\n  }\n  if(n[x]==\"R?\"){\n    for(int i=0;i<(1<<edge[x].size());i++){\n      ll t=1;\n      for(int j=0;j<edge[x].size();j++)\n\tif(i&(1<<j)) t*=func(edge[x][j]);\n      res+=t;\n    }\n    return res;\n  }\n  if(n[x]==\"R\"){\n    for(int i=1;i<(1<<edge[x].size());i++){\n      ll t=1;\n      for(int j=0;j<edge[x].size();j++)\n\tif(i&(1<<j)) t*=func(edge[x][j]);\n      res+=t;\n    }\n    return res;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> V;\ntypedef pair<ll,ll> P;\ntypedef map<ll,ll> M;\n\n#define REP(i, n) for(ll (i) = 0; (i) < (n); ++(i))\n#define FOR(i, j, n) for(ll (i) = (j); (i) < (n); ++(i))\n#define REPR(i, n) for(ll (i) = (n); (i) >= 0; --(i))\n\nconst ll MOD = 1e9+7;\n\nsigned main(){\n    int n;\n    cin >> n;\n    vector<string> s(n);\n    for(auto& xx : s)cin >> xx;\n    vector<V> edges(n);\n    vector<V> rev(n);\n    V cou(n, 0);\n    REP(i, n-1){\n        int a,b;\n        cin >> a >> b;\n        --a;--b;\n        edges[a].push_back(b);\n        ++cou[a];\n        rev[b].push_back(a);\n    }\n    V dp(n, 0);\n    queue<int> que;\n    REP(i,n)if(!cou[i])que.push(i);\n    while(!que.empty()){\n        int pos = que.front();\n        que.pop();\n\n        bool option = (s[pos].size() != 1);\n\n        ll patcou = 0;\n\n        if(s[pos][0] == 'E'){\n            ll num = 1;\n            for(auto x : edges[pos]){\n                num *= dp[x];\n                num %= MOD;\n            }\n            patcou = (num + option) % MOD;\n        }\n        else if(s[pos][0] == 'A'){\n            // alt\n            ll num = 0;\n            for(auto x : edges[pos]){\n                num += dp[x];\n                num %= MOD;\n            }\n            patcou = (num + option) % MOD;\n\n        }\n        else if(s[pos][0] == 'R'){\n            // or\n            ll num = 0;\n            FOR(i,1, 1<<(edges[pos].size())){\n                ll numnum = 1;\n                REP(j,edges[pos].size()){\n                    if(i & (1<<j)){\n                        numnum *= dp[edges[pos][j]];\n                        numnum %= MOD;\n                    }\n                }\n                num += numnum;\n                num %= MOD;\n            }\n            patcou = (num + option) % MOD;\n\n        }\n\n        dp[pos] = patcou;\n\n        for(auto x : rev[pos])\n            if(--cou[x] == 0)\n                que.push(x);\n    }\n    cout << dp[0] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\n-- import qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\n--import Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\nimport GHC.ST\n-- import System.IO.Unsafe\n \n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ntjoin :: (Show a, Show b) => (a, b) -> String\ntjoin (x, y) = show x ++ (' ' : show y)\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\nibsearch :: (Int -> Bool) -> (Int,Int) -> Int\nibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))\n-- templete\n\nedges :: Int -> [(Int,Int)] -> Array Int [Int]\nedges n es = runSTArray $ do\n    arr <- newArray (1,n) []\n    forM_ es $ \\(i,j) -> readArray arr i >>= writeArray arr i . (j:)\n    return arr\n\ncalc ts es = search 1\n  where\n    search i = case ts!i of\n        \"E\" -> product $ map search $ es!i\n        \"E?\" -> (+1) $ product $ map search $ es!i\n        \"A\" -> sum $ map search $ es!i\n        \"A?\" -> (+1) $ sum $ map search $ es!i\n        \"R\" -> subtract 1 $ product $ map (+1) $ map search $ es!i\n        \"R?\" -> product $ map (+1) $ map search $ es!i\n\n\nmain = do\n    n <- getInt\n    types <- listArray (1,n) <$> replicateM n getLine\n    es <- edges n . map (apply2 (,)) <$> replicateM (n-1) getInts\n    print $ flip mod 1000000007 $ calc types es\n    \n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\n-- import qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\n--import Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\nimport GHC.ST\n-- import System.IO.Unsafe\n \n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ntjoin :: (Show a, Show b) => (a, b) -> String\ntjoin (x, y) = show x ++ (' ' : show y)\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\nibsearch :: (Int -> Bool) -> (Int,Int) -> Int\nibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))\n-- templete\n\nedges :: Int -> [(Int,Int)] -> Array Int [Int]\nedges n es = runSTArray $ do\n    arr <- newArray (1,n) []\n    forM_ es $ \\(i,j) -> readArray arr i >>= writeArray arr i . (j:)\n    return arr\n\ncalc ts es = search 1\n  where\n    search i = case ts!i of\n        \"E\" -> product $ map search $ es!i\n        \"E?\" -> (+1) $ product $ map search $ es!i\n        \"A\" -> sum $ map search $ es!i\n        \"A?\" -> (+1) $ sum $ map search $ es!i\n        \"R\" -> subtract 1 $ product $ map (+1) $ map search $ es!i\n        \"R?\" -> product $ map (+1) $ map search $ es!i\n        \n        \n\n\nmain = do\n    n <- getInt\n    types <- listArray (1,n) <$> replicateM n getLine\n    es <- edges n . map (apply2 (,)) <$> replicateM (n-1) getInts\n    print $ calc types es\n    \n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0309: New Drug Development\n// 2017.12.24 bal4u@uu\n\n#include <stdio.h>\n\n#define M 1000000007\n#define E   1\n#define A   2\n#define R   4\n#define OPT 8\ntypedef struct { char info, lock; int n, ch[10]; } T;\nT tbl[1002];\nchar tr['Z'];\n\nint calc(int id)\n{\n\tint i, n;\n\tlong long s = 0;\n\tT *t = tbl+id;\n\n\tif (t->lock) return 0;\n\tt->lock = 1;\n\tn = t->n;\n\n\tif (t->info & E) {\n\t\ts = 1; for (i = 0; i < n; i++) s = s * (calc(t->ch[i])) % M;\n\t} else if (t->info & A) {\n\t\ts = 0; for (i = 0; i < n; i++) s += calc(t->ch[i]);\n\t\ts %= M;\n\t} else if (t->info & R) {\n\t\ts = 1; for (i = 0; i < n; i++) s = (s * (calc(t->ch[i]) + 1)) % M;\n\t\ts--; if (s < 0) s = M-1;\n\t}\n\tif (t->info & OPT) { if (++s == M) s = 0; }\n\treturn (int)s;\n}\n\nint main()\n{\n\tint n, i, a, b;\n\tchar buf[10], *p;\n\n\ttr['E'] = E, tr['A'] = A, tr['R'] = R,  tr['?'] = OPT;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", buf);\n\t\tp = buf; while (*p) tbl[i].info |= tr[*p++];\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ttbl[a].ch[tbl[a].n++] = b;\n\t}\n\tprintf(\"%d\\n\", calc(1));\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ #0309\n  title:New Drug Development\n  @kankichi573\n */\n#include <stdio.h>\n#include <string.h>\n#define DIV 1000000007\nint n;\nint from[1001],to[1001];\nchar node[1001][3];\nint res[1001];\n\nlong long solve(int no)\n{\n  char *p;\n  int i;\n  long long acc;\n  \n  p=&node[no][0];\n  // printf(\"n=%d k=%s\\n\",no,p);\n  \n  if(*p=='E')\n    {\n      for(i=0,acc=1;i<n-1;i++)\n\tif(from[i]==no)\n\t  acc = (acc * solve(to[i])) % DIV;\n      if(p[1]=='?')\n\t  acc = (acc + 1) % DIV;\n    }\n\n  if(*p=='R')\n    {\n      for(i=0,acc=1;i<n-1;i++)\n\tif(from[i]==no)\n\t  {\n\t    acc = (acc * (1+solve(to[i]))) % DIV;\n\t    // printf(\"%d* %d %d\\n\",i,solve(to[i]),acc);\n\t  }\n      if(p[1]!='?')\n\tacc  = (acc - 1) % DIV;\n    }\n  \n  if(*p=='A')\n    {\n      for(i=0,acc=0;i<n-1;i++)\n\tif(from[i]==no)\n\t  {\n\t    acc = (acc + solve(to[i])) % DIV;\n\t  }\n      if(p[1]=='?')\n\tacc  = (acc + 1)  % DIV;\n    }\n  res[no]=acc;\n  return(acc);\n}\ndump()\n{\n  int i;\n  for(i=1;i<=n;i++)\n    printf(\"%d: %d\\n\",i,res[i]);\n}\nint main()\n{\n  int i,ret;\n  \n  scanf(\"%d\",&n);\n  for(i=1;i<=n;i++)\n    scanf(\"%s\",&node[i][0]);\n\n  for(i=0;i<n;i++)\n    scanf(\"%d %d\",&from[i],&to[i]);\n  ret=solve(1);\n  #ifdef DEBUG\n  dump();\n  #endif\n  printf(\"%d\\n\",ret);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <inttypes.h>\n\n#define MOD_BY UINT32_C(1000000007)\n\nuint32_t add(uint32_t a, uint32_t b) {\n\tuint32_t r = a + b;\n\tif (r >= MOD_BY) r -= MOD_BY;\n\treturn r;\n}\n\nuint32_t mul(uint32_t a, uint32_t b) {\n\treturn (uint32_t)(((uint64_t)a * b) % MOD_BY);\n}\n\nint N;\nchar node[1000][4];\nint child_num[1000];\nint children[1000][10];\n\nuint32_t keisan(int idx) {\n\tuint32_t ret = 0;\n\tint i;\n\tswitch (node[idx][0]) {\n\tcase 'E':\n\t\tret = 1;\n\t\tfor (i = 0; i < child_num[idx]; i++) {\n\t\t\tret = mul(ret, keisan(children[idx][i]));\n\t\t}\n\t\tif (node[idx][1] == '?') ret = add(ret, 1);\n\t\tbreak;\n\tcase 'A':\n\t\tfor (i = 0; i < child_num[idx]; i++) {\n\t\t\tret = add(ret, keisan(children[idx][i]));\n\t\t}\n\t\tif (node[idx][1] == '?') ret = add(ret, 1);\n\t\tbreak;\n\tcase 'R':\n\t\tret = 1;\n\t\tfor (i = 0; i < child_num[idx]; i++) {\n\t\t\tret = mul(ret, add(keisan(children[idx][i]), 1));\n\t\t}\n\t\tif (node[idx][1] != '?') ret = add(ret, MOD_BY - 1);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tint i;\n\tif (scanf(\"%d\", &N) != 1) return 1;\n\tfor (i = 0; i < N; i++) {\n\t\tif (scanf(\"%s\", node[i]) != 1) return 1;\n\t}\n\tfor (i = 1; i < N; i++) {\n\t\tint s, t;\n\t\tif (scanf(\"%d%d\", &s, &t) != 2) return 1;\n\t\ts--;\n\t\tt--;\n\t\tchildren[s][child_num[s]++] = t;\n\t}\n\tprintf(\"%\"PRIu32\"\\n\", keisan(0));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define DIV 1000000007\nint n;\nint from[1001],to[1001];\nchar node[1001][3];\nint res[1001];\n\nlong long solve(int no)\n{\n  char *p;\n  int i;\n  long long acc;\n  \n  p=&node[no][0];\n  \n  if(*p=='E')\n    {\n      for(i=0,acc=1;i<n-1;i++)\n\tif(from[i]==no)\n\t  acc = (acc * solve(to[i])) % DIV;\n      if(p[1]=='?')\n\t  acc = (acc + 1) % DIV;\n    }\n\n  if(*p=='R')\n    {\n      for(i=0,acc=1;i<n-1;i++)\n\tif(from[i]==no)\n\t  {\n\t    acc = (acc * (1+solve(to[i]))) % DIV;\n\t  }\n      if(p[1]!='?')\n\tacc  = (acc - 1) % DIV;\n    }\n  \n  if(*p=='A')\n    {\n      for(i=0,acc=0;i<n-1;i++)\n\tif(from[i]==no)\n\t  {\n\t    acc = (acc + solve(to[i])) % DIV;\n\t  }\n      if(p[1]=='?')\n\tacc  = (acc + 1)  % DIV;\n    }\n  res[no]=acc;\n  return(acc);\n}\n\nint main()\n{\n  int i,ret;\n  \n  scanf(\"%d\",&n);\n  for(i=1;i<=n;i++)\n    scanf(\"%s\",&node[i][0]);\n\n  for(i=0;i<n;i++)\n    scanf(\"%d %d\",&from[i],&to[i]);\n  ret=solve(1);\n  printf(\"%d\\n\",ret);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ #0309\n  title:New Drug Development\n  @kankichi573\n */\n#include <stdio.h>\n#include <string.h>\n#define DIV 1000000007\nint n;\nint from[1001],to[1001];\nchar node[1001][3];\nint res[1001];\n\nint solve(int no)\n{\n  char *p;\n  int i,acc;\n  \n  p=&node[no][0];\n  // printf(\"n=%d k=%s\\n\",no,p);\n  \n  if(*p=='E')\n    {\n      for(i=0,acc=1;i<n-1;i++)\n\tif(from[i]==no)\n\t  acc = (acc * solve(to[i])) % DIV;\n      if(p[1]=='?')\n\t  acc = (acc + 1) % DIV;\n    }\n\n  if(*p=='R')\n    {\n      for(i=0,acc=1;i<n-1;i++)\n\tif(from[i]==no)\n\t  {\n\t    acc = (acc * (1+solve(to[i]))) % DIV;\n\t    // printf(\"%d* %d %d\\n\",i,solve(to[i]),acc);\n\t  }\n      if(p[1]!='?')\n\tacc  = (acc - 1) % DIV;\n    }\n  \n  if(*p=='A')\n    {\n      for(i=0,acc=0;i<n-1;i++)\n\tif(from[i]==no)\n\t  {\n\t    acc = (acc + solve(to[i])) % DIV;\n\t  }\n      if(p[1]=='?')\n\tacc  = (acc + 1)  % DIV;\n    }\n  res[no]=acc;\n  return(acc);\n}\ndump()\n{\n  int i;\n  for(i=1;i<=n;i++)\n    printf(\"%d: %d\\n\",i,res[i]);\n}\nint main()\n{\n  int i,ret;\n  \n  scanf(\"%d\",&n);\n  for(i=1;i<=n;i++)\n    scanf(\"%s\",&node[i][0]);\n\n  //for(i=1;i<=n;i++)\n  //  printf(\"%d:%s \",i,&node[i][0]);\n  //printf(\"\\n\");  \n    \n\n  for(i=0;i<n;i++)\n    scanf(\"%d %d\",&from[i],&to[i]);\n  ret=solve(1);\n  //dump();\n  printf(\"%d\\n\",ret);\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\tstatic final long MOD = 1000000007;\n\tstatic Node[] node;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tint N = sc.nextInt();\n\t\tnode = new Node[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tnode[i] = new Node();\n\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\tif(in[0] == 'E') {\n\t\t\t\tnode[i].isE = true;\n\t\t\t}\n\t\t\tif(in[0] == 'A') {\n\t\t\t\tnode[i].isA = true;\n\t\t\t}\n\t\t\tif(in[0] == 'R') {\n\t\t\t\tnode[i].isR = true;\n\t\t\t}\n\t\t\tif(in.length == 2) {\n\t\t\t\tnode[i].isO = true;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < N-1; i++) {\n\t\t\tint s = sc.nextInt()-1;\n\t\t\tint t = sc.nextInt()-1;\n\t\t\tnode[s].child.add(t);\n\t\t}\n\t\tlong ans = dfs(0);\n\t\tSystem.out.println(ans);\n\t}\n\tstatic long dfs(int id) {\n\t\tNode now = node[id];\n\t\tlong ret = 0;\n\t\tif(now.isE) {\n\t\t\tret = 1;\n\t\t\tfor(int i = 0; i < now.child.size(); i++) {\n\t\t\t\tret = (dfs(now.child.get(i)) * ret) % MOD;\n\t\t\t}\n\t\t\tif(now.isO) ret = (ret + 1) % MOD;\n\t\t}\n\t\tif(now.isA) {\n\t\t\tif(now.isO) {\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tfor(int i = 0; i < now.child.size(); i++) {\n\t\t\t\tret = (dfs(now.child.get(i)) + ret) % MOD;\n\t\t\t}\n\t\t}\n\t\tif(now.isR) {\n\t\t\tlong[] list = new long[now.child.size()];\n\t\t\t\n\t\t\tfor(int i = 0; i < now.child.size(); i++) {\n\t\t\t\tlist[i] = dfs(now.child.get(i));\n\t\t\t}\n\t\t\tlong nn = (list[0]+1);\n\t\t\tfor(int i = 1; i < list.length; i++) {\n\t\t\t\tnn = ((list[i]+1) * nn) % MOD;\n\t\t\t}\n\t\t\tif(!now.isO) nn--;\n\t\t\tret = nn;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic class Node {\n\t\tboolean isE;\n\t\tboolean isA;\n\t\tboolean isR;\n\t\tboolean isO;\n\t\tArrayList<Integer> child = new ArrayList<Integer>();\n\t}\n\t\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \treturn (int)nextLong();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String args[]){\n\t\tnew Main().mainrun();\n\t}\n\n\tScanner scan;\n\n\tprivate int N;\n\tprivate final long MOD = 1000000007;\n\tprivate Node[] node;\n\n\tprivate void mainrun() {\n\t\tscan = new Scanner(System.in);\n\n\t\tN = scan.nextInt();\n\n\t\tnode = new Node[N];\n\n\t\tfor(int i = 0;i < N;i++) {\n\t\t\tnode[i] = new Node(scan.next());\n\t\t}\n\n\t\tfor(int i = 0;i < N-1;i++) {\n\t\t\tnode[scan.nextInt()-1].child.add(scan.nextInt()-1);\n\t\t}\n\n\t\tSystem.out.println(looprun(node[0]) % MOD);\n\n\t\tscan.close();\n\t}\n\n\tprivate long looprun(Node n) {\n\t\tlong ans = 1;\n\n\t\tswitch(n.type) {\n\n\t\tcase \"E\":\n\t\t\tfor(Integer no : n.child) {\n\t\t\t\tans *= looprun(node[no]);\n\t\t\t\tans %= MOD;\n\t\t\t}\n\n\t\t\tif(n.isOption) {\n\t\t\t\tans += 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase \"R\":\n\t\t\tfor(Integer no : n.child) {\n\t\t\t\tans *= looprun(node[no]) + 1;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\n\t\t\tif(!n.isOption) {\n\t\t\t\tans -= 1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \"A\":\n\n\t\t\tfor(Integer no : n.child) {\n\t\t\t\tans += looprun(node[no]);\n\t\t\t}\n\n\t\t\tif(!n.isOption) {\n\t\t\t\tans -= 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\nclass Node{\n\tString type;\n\tboolean isOption;\n\tLinkedList<Integer> child;\n\n\tNode(String str){\n\t\tString[] sp = str.split(\"\");\n\t\ttype = sp[0];\n\t\tisOption = (sp.length == 2);\n\t\tchild = new LinkedList<>();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\nclass Main {\n\tstatic final long MOD = 1000000007;\n\tstatic Node[] node;\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tnode = new Node[N];\n\t\t\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tnode[i] = new Node();\n\t\t\tchar[] in = scan.next().toCharArray();\n\t\t\tif(in[0] == 'E') {\n\t\t\t\tnode[i].isE = true;\n\t\t\t}\n\t\t\t\n\t\t\tif(in[0] == 'A') {\n\t\t\t\tnode[i].isA = true;\n\t\t\t}\n\t\t\t\n\t\t\tif(in[0] == 'R') {\n\t\t\t\tnode[i].isR = true;\n\t\t\t}\n\t\t\t\n\t\t\tif(in.length == 2) {\n\t\t\t\tnode[i].isO = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N-1; i++) {\n\t\t\tint s = scan.nextInt()-1;\n\t\t\tint t = scan.nextInt()-1;\n\t\t\tnode[s].child.add(t);\n\t\t}\n\t\t\n\t\tlong ans = dfs(0);\n\t\tSystem.out.println(ans);\n\t\t\n\t\tscan.close();\n\t}\n\t\n\tstatic long dfs(int id) {\n\t\tNode now = node[id];\n\t\tlong ret = 0;\n\t\tif(now.isE) {\n\t\t\tret = 1;\n\t\t\tfor(int i = 0; i < now.child.size(); i++) {\n\t\t\t\tret = (dfs(now.child.get(i)) * ret) % MOD;\n\t\t\t}\n\t\t\t\n\t\t\tif(now.isO) ret = (ret + 1) % MOD;\n\t\t}\n\t\t\n\t\tif(now.isA) {\n\t\t\tif(now.isO) {\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < now.child.size(); i++) {\n\t\t\t\tret = (dfs(now.child.get(i)) + ret) % MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(now.isR) {\n\t\t\tlong[] list = new long[now.child.size()];\n\t\t\t\n\t\t\tfor(int i = 0; i < now.child.size(); i++) {\n\t\t\t\tlist[i] = dfs(now.child.get(i));\n\t\t\t}\n\t\t\t\n\t\t\tlong nn = (list[0]+1);\n\t\t\t\n\t\t\tfor(int i = 1; i < list.length; i++) {\n\t\t\t\tnn = ((list[i]+1) * nn) % MOD;\n\t\t\t}\n\t\t\t\n\t\t\tif(!now.isO) nn--;\n\t\t\tret = nn;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tstatic class Node {\n\t\tboolean isE;\n\t\tboolean isA;\n\t\tboolean isR;\n\t\tboolean isO;\n\t\tArrayList<Integer> child = new ArrayList<Integer>();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic static class combi\n{\n    public static IEnumerable<IEnumerable<T>> Comb<T>(this IEnumerable<T> items, int r)\n    {\n        if (r == 0)\n        {\n            yield return Enumerable.Empty<T>();\n        }\n        else\n        {\n            var i = 1;\n            foreach (var x in items)\n            {\n                var xs = items.Skip(i);\n                foreach (var c in Comb(xs, r - 1))\n                    yield return c.Before(x);\n                i++;\n            }\n        }\n    }\n    public static IEnumerable<T> Before<T>(this IEnumerable<T> items, T first)\n    {\n        yield return first;\n        foreach (var i in items)\n            yield return i;\n    }\n}\n\npublic class Node\n{\n    public string type { get; set; }\n    public bool option { get; set; }\n    public List<int> child { get; set; }\n}\n\npublic class hello\n{\n    const int MOD = 1000000007;\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var nodes = new Node[n];\n        for (int i = 0; i < n; i++)\n        {\n            var t = \"or\";\n            var s = Console.ReadLine().Trim();\n            if (s[0] == 'A') t = \"aLt\";\n            else if (s[0] == 'E') t = \"e\";\n            nodes[i] = new Node { child = new List<int>(), type = t, option = s.Length == 2 ? true : false };\n        }\n        string S;\n        for (; (S = Console.ReadLine()) != null;)\n        {\n            string[] line = S.Trim().Split(' ');\n            var a = int.Parse(line[0]) - 1;\n            var b = int.Parse(line[1]) - 1;\n            nodes[a].child.Add(b);\n        }\n        var ans = goRec(nodes, 0);\n        Console.WriteLine(ans);\n\n    }\n  static int goRec ( Node[] nodes , int n)\n    {\n        var w = nodes[n];\n        if (w.type == \"e\")\n        {\n            if (w.child.Count() == 0) return w.option ? 2 : 1;\n            else\n            {\n                var ans = 1L;\n                foreach (var x in w.child)\n                {\n                    ans *= goRec(nodes, x);\n                    ans %= MOD;\n                }\n                return w.option ? ((int)ans + 1) % MOD : (int)ans;\n            }\n        }\n        else if (w.type == \"aLt\")\n        {\n            var ans = 0L;\n            foreach (var x in w.child)\n            {\n                ans += goRec(nodes, x);\n                ans %= MOD;\n            }\n            return w.option ? ((int)ans + 1) % MOD : (int)ans;\n        }\n        else\n        {\n            var cc = w.child.Count();\n            var t = new int[cc];\n            var p = 0;\n            foreach(var x in w.child)\n                t[p++] = goRec(nodes, x);\n            var gor = getOR(t, cc);\n            return w.option ? (gor+ 1) % MOD : gor;\n        }\n    }\n    static int getOR (int [] a , int n)\n    {\n        var ans = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            var b = a.Comb(i);\n            var t = 0L;\n            foreach (var x in b)\n            {\n                var t2 = 1L;\n                foreach (var y in x)\n                {\n                    t2 *= y;\n                    t2 %= MOD;\n                }\n                t +=(int) t2;\n                t %= MOD;\n            }\n            ans +=(int) t;\n            ans %= MOD;\n        }\n        return ans;\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\ntype = {}\n(1..n).map {|i| type[i] = gets.chomp}\ng = {}\n(1..n).each {|i| g[i] = []}\n(n - 1).times do\n    i, j = gets.split.map(&:to_i)\n    g[i] << j\nend\ndef f(g, type, i)\n    k = (type[i].size > 1 ? 1 : 0)\n    if type[i][0] == ?A\n        g[i].each do |j|\n            k += f(g, type, j)\n        end\n    elsif type[i][0] == ?R\n        k += g[i].map {|j| 1 + f(g, type, j)}.inject(:*) - 1\n    elsif type[i][0] == ?E\n        if g[i].empty?\n            k += 1\n        else\n            k += g[i].map {|j| f(g, type, j)}.inject(:*)\n        end\n    end\n    k % 1_000_000_007\nend\np f(g, type, 1)\n\n"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nN = 1000000007\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        i, j = tuple([int(x) for x in input().split()])\n        nodes[i-1].children.append(nodes[j-1])\n        nodes[i-1].index.append(j-1)\n\n    print(reduce_to_top(nodes).n % N)\n\ndef product(iterator):\n    '''product for iterator\n    '''\n    result = 1\n    for element in iterator:\n        result *= element % N\n        result %= N\n    return result\n\ndef step_reducing(nodes):\n    last_parents = [node for node in nodes if node is not None and node.is_last_parent()]\n    for parent in last_parents:\n        parent.n = parent.number_of_cases()\n        parent.children = list()\n        for i in parent.index:\n            nodes[i] = None\n    return nodes\n\ndef reduce_to_top(nodes):\n    while nodes[1:] != [None]*(len(nodes)-1):\n        nodes = step_reducing(nodes)\n    return nodes[0]\n\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None, n=None, index=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        if index is None:\n            index = list()\n        self.children = children\n        self.index = index\n        self.n = None\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n        if self.n is not None:\n            return self.n\n\n        cases = self.generate_cases()\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product((x+1 for x in cases))\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\n    def generate_cases(self):\n        '''generate cases\n        '''\n        for child in self.children:\n            yield child.number_of_cases()\n\n    def is_last_parent(self):\n        bools = [child.children == [] for child in self.children]\n        return bools and all(bools)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    edges = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        edges.append(tuple([int(x) for x in input().split()]))\n    for (i, j) in edges:\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % 1000000007)\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n        if \"E\" in self.kind:\n            result = 1\n            for child in self.children:\n                result *= child.number_of_cases()\n            if \"?\" in self.kind:\n                result += 1\n            return result\n\n        elif \"A\" in self.kind:\n            result = sum([child.number_of_cases() for child in self.children])\n            if \"?\" in self.kind:\n                result += 1\n            return result\n\n        elif \"R\" in self.kind:\n            cases = [2*child.number_of_cases() for child in self.children]\n            result = sum(cases) - 1\n            if \"?\" in self.kind:\n                result += 1\n            return result\n\n        else:\n            raise Exception(\"unreachable.\")\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nN = 1000000007\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        i, j = tuple([int(x) for x in input().split()])\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % N)\n\ndef product(lis):\n    '''product for list\n    '''\n    result = 1\n    for element in lis:\n        result *= element % N\n        result %= N\n    return result\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n\n        cases = [child.number_of_cases() for child in self.children]\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product([x+1 for x in cases])\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(100000)\nmod = 1000000007\nn = int(input())\nnodes = [input() for _ in range(n)]\nedges = [[] for _ in range(n)]\nfor _ in range(n - 1):\n  s, t = map(int, input().split())\n  s -= 1\n  t -= 1\n  edges[s].append(t)\n\ndef score(index):\n  node = nodes[index]\n  if node[0] == \"E\":\n    ret = 1\n    for to in edges[index]:\n      ret *= score(to)\n\n  if node[0] == \"A\":\n    ret = 0\n    for to in edges[index]:\n      ret += score(to)\n\n  if node[0] == \"R\":\n    ret = 1\n    for to in edges[index]:\n      ret *= (score(to) + 1)\n    ret -= 1\n\n  if node[-1] == \"?\":\n    ret += 1\n\n  return ret % mod\n\nprint(score(0))  \n"
  },
  {
    "language": "Python",
    "code": "m = 1000000007\n\nfrom sys import stdin\nf_i = stdin\n\nN = int(f_i.readline())\n\nn_type = [''] * N\nfor i in range(N):\n    t = f_i.readline().rstrip()\n    n_type[i] = t\n\nadj = [[] for i in range(N)]\nfor i in range(N - 1):\n    s, t = map(int, f_i.readline().split())\n    s -= 1\n    t -= 1\n    adj[s].append(t)\n\nfrom itertools import combinations\n\ndef prod(nums):\n    p = 1\n    for n in nums:\n        p *= n\n    return p\n\nimport sys\nsys.setrecursionlimit(4000)\n\ndef dfs(node):\n    nt = n_type[node]\n    chld = adj[node]\n    if nt == 'E':\n        if chld:\n            return prod(map(dfs, chld)) % m\n        else:\n            return 1\n    elif nt == 'E?':\n        if chld:\n            return (prod(map(dfs, chld)) + 1) % m\n        else:\n            return 2\n    elif nt == 'A':\n        return sum(map(dfs, chld)) % m\n    elif nt == 'A?':\n        return (sum(map(dfs, chld)) + 1) % m\n    else:\n        cnt = 0\n        c_s = tuple(map(dfs, chld))\n        for i in range(1, len(chld) + 1):\n            for vals in combinations(c_s, i):\n                cnt += prod(vals)\n        if len(nt) == 1:\n            return cnt % m\n        else:\n            return (cnt + 1) % m\n\nprint(dfs(0))\n"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nN = 1000000007\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        i, j = tuple([int(x) for x in input().split()])\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % N)\n\ndef product(lis):\n    '''product for list\n    '''\n    result = 1\n    for element in lis:\n        result *= element % N\n    return result\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n\n        cases = [child.number_of_cases() for child in self.children]\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product([x+1 for x in cases])\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nN = 1000000007\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        i, j = tuple([int(x) for x in input().split()])\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % N)\n\ndef product(iterator):\n    '''product for iterator\n    '''\n    result = 1\n    for element in iterator:\n        result *= element % N\n        result %= N\n    return result\n\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n        cases = self.generate_cases()\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product((x+1 for x in cases))\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\n    def generate_cases(self):\n        '''generate cases\n        '''\n        for child in self.children:\n            yield child.number_of_cases()\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nN = 1000000007\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        i, j = tuple([int(x) for x in input().split()])\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % N)\n\ndef product(lis):\n    '''product for list\n    '''\n    result = 1\n    for element in lis:\n        result *= element % N\n        result %= N\n    return result\n\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n\n        cases = [child.number_of_cases() for child in self.children]\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product([x+1 for x in cases])\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nN = 1000000007\n\ndef main():\n    node_n = int(input())\n    nodes = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        i, j = tuple([int(x) for x in input().split()])\n        nodes[i-1].children.append(nodes[j-1])\n        nodes[i-1].index.append(j-1)\n\n    print(reduce_to_top(nodes).n % N)\n\n\ndef product(iterator):\n    result = 1\n    for element in iterator:\n        result *= element % N\n        result %= N\n    return result\n\n\ndef step_reducing(nodes):\n    last_parents = [node for node in nodes if node is not None and node.is_last_parent()]\n    for parent in last_parents:\n        parent.n = parent.number_of_cases()\n        parent.children = list()\n        for i in parent.index:\n            nodes[i] = None\n    return nodes\n\n\ndef reduce_to_top(nodes):\n    while nodes[1:] != [None]*(len(nodes)-1):\n        nodes = step_reducing(nodes)\n    return nodes[0]\n\n\nclass Node:\n\n    def __init__(self, kind, children=None, n=None, index=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        if index is None:\n            index = list()\n        self.children = children\n        self.index = index\n        self.n = n\n\n    def number_of_cases(self):\n        if self.n is not None:\n            return self.n\n\n        cases = self.generate_cases()\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product((x+1 for x in cases))\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\n    def generate_cases(self):\n        for child in self.children:\n            yield child.number_of_cases()\n\n    def is_last_parent(self):\n        bools = [child.children == [] for child in self.children]\n        return bools and all(bools)\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nN = 1000000007\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    edges = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        edges.append(tuple([int(x) for x in input().split()]))\n    for (i, j) in edges:\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % N)\n\ndef product(lis):\n    result = 1\n    for element in lis:\n        result *= element\n    return result\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n\n        cases = [child.number_of_cases() for child in self.children]\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product(map(lambda x: x+1, cases))\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nfrom math import log10\n\nN = 1000000007\nLOGN = 9\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        i, j = tuple([int(x) for x in input().split()])\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % N)\n\ndef product(lis):\n    '''product for list\n    '''\n    result = 1\n    for element in lis:\n        if log10(result) + log10(element) > LOGN:\n            if log10(result) > LOGN-4:\n                result = result-N\n            if log10(element) > LOGN-4:\n                element = element-N\n\n        result *= element % N\n        result %= N\n    return result\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n\n        cases = [child.number_of_cases() for child in self.children]\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product([x+1 for x in cases])\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nN = 1000000007\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    edges = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        edges.append(tuple([int(x) for x in input().split()]))\n    for (i, j) in edges:\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % N)\n\ndef product(lis):\n    result = 1\n    for element in lis:\n        result *= element % N\n    return result\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n\n        cases = [child.number_of_cases() for child in self.children]\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product(map(lambda x: x+1, cases))\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\nimport sys\nfrom math import log10\n\nN = 1000000007\nLOGN = 9\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        i, j = tuple([int(x) for x in input().split()])\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % N)\n\ndef product(lis):\n    '''product for list\n    '''\n    result = 1\n    for element in lis:\n        if log10(result) + log10(element) > 9:\n            result = ((result-N) * (element-N)) % N\n        else:\n            result *= element % N\n            result %= N\n    return result\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n\n        cases = [child.number_of_cases() for child in self.children]\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result % N\n\n        elif \"R\" in self.kind:\n            result = product([x+1 for x in cases])\n            if \"?\" not in self.kind:\n                result -= 1\n            return result % N\n\n        else:\n            raise Exception(\"unreachable.\")\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "'''aizu 0309\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0309\n'''\n# encoding: 'utf-8'\n\ndef main():\n    '''main func.\n    '''\n\n    node_n = int(input())\n    nodes = list()\n    edges = list()\n    for _ in range(node_n):\n        nodes.append(Node(input()))\n    for _ in range(node_n - 1):\n        edges.append(tuple([int(x) for x in input().split()]))\n    for (i, j) in edges:\n        nodes[i-1].children.append(nodes[j-1])\n\n    print(nodes[0].number_of_cases() % 1000000007)\n\ndef product(lis):\n    result = 1\n    for element in lis:\n        result *= element\n    return result\n\nclass Node:\n    '''Node class\n    '''\n\n    def __init__(self, kind, children=None):\n        self.kind = kind\n        if children is None:\n            children = list()\n        self.children = children\n\n    def number_of_cases(self):\n        ''' calc the number of cases.\n        '''\n\n        cases = [child.number_of_cases() for child in self.children]\n        if \"E\" in self.kind:\n            result = product(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result\n\n        elif \"A\" in self.kind:\n            result = sum(cases)\n            if \"?\" in self.kind:\n                result += 1\n            return result\n\n        elif \"R\" in self.kind:\n            result = product(map(lambda x: x+1, cases))\n            if \"?\" not in self.kind:\n                result -= 1\n            return result\n\n        else:\n            raise Exception(\"unreachable.\")\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\nN = int(input())\nND = [\"E\", \"E?\", \"A\", \"R\", \"A?\", \"R?\"]\nT = [input() for i in range(N)]\nG = [[] for i in range(N)]\nfor i in range(N-1):\n    s, t = map(int, input().split())\n    G[s-1].append(t-1)\nMOD = 10**9 + 7\ndef dfs(v):\n    t = T[v]\n    if t[0] in ['E', 'R']:\n        r = 1\n    else:\n        r = 0\n    t0 = t[0]\n    for w in G[v]:\n        x = dfs(w)\n        if t0 == 'E':\n            r = r * x % MOD\n        elif t0 == 'R':\n            r = r * (x+1) % MOD\n        else:\n            r += x\n    if t[0] == 'R':\n        r -= 1\n    if t[-1] == '?':\n        r += 1\n    return r % MOD\nprint(dfs(0))\n"
  }
]