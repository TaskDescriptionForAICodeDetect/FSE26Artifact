[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_NODES 1001\n\ntypedef struct Node {\n    char type[3];\n    int child_count;\n    int children[10];\n} Node;\n\nNode nodes[MAX_NODES];\nlong long dp[MAX_NODES];\n\nvoid dfs(int u) {\n    if (dp[u] != -1) return;\n\n    if (strcmp(nodes[u].type, \"E\") == 0) {\n        dp[u] = 1;\n    } else if (strcmp(nodes[u].type, \"E?\") == 0) {\n        dp[u] = 2;\n    } else if (nodes[u].type[0] == 'A' || nodes[u].type[0] == 'R') {\n        int is_optional = (nodes[u].type[1] == '?');\n        long long res = 0;\n        if (nodes[u].type[0] == 'A') {\n            if (is_optional) {\n                res = 1; // option to not select any child\n                for (int i = 0; i < nodes[u].child_count; ++i) {\n                    int v = nodes[u].children[i];\n                    dfs(v);\n                    res = (res + dp[v]) % MOD;\n                }\n            } else {\n                res = 0;\n                for (int i = 0; i < nodes[u].child_count; ++i) {\n                    int v = nodes[u].children[i];\n                    dfs(v);\n                    res = (res + dp[v]) % MOD;\n                }\n            }\n        } else { // 'R'\n            if (is_optional) {\n                res = 1; // option to not select any child\n                long long product = 1;\n                for (int i = 0; i < nodes[u].child_count; ++i) {\n                    int v = nodes[u].children[i];\n                    dfs(v);\n                    product = (product * (dp[v] + 1)) % MOD;\n                }\n                res = (res + product - 1) % MOD;\n            } else {\n                res = 1;\n                for (int i = 0; i < nodes[u].child_count; ++i) {\n                    int v = nodes[u].children[i];\n                    dfs(v);\n                    res = (res * (dp[v] + 1)) % MOD;\n                }\n                res = (res - 1) % MOD;\n                if (res < 0) res += MOD;\n            }\n        }\n        dp[u] = res;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%s\", nodes[i].type);\n        nodes[i].child_count = 0;\n        dp[i] = -1;\n    }\n    for (int i = 0; i < N - 1; ++i) {\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        nodes[s].children[nodes[s].child_count++] = t;\n    }\n    dfs(1);\n    printf(\"%lld\\n\", dp[1] % MOD);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:43:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static Node[] nodes;\n    \n    static class Node {\n        String type;\n        List<Integer> children = new ArrayList<>();\n        boolean isOptional;\n        \n        Node(String type) {\n            this.type = type;\n            this.isOptional = type.contains(\"?\");\n            if (this.isOptional) {\n                this.type = type.substring(0, type.length() - 1);\n            }\n        }\n    }\n    \n    static long countCombinations(int node) {\n        Node curr = nodes[node];\n        \n        // Substance node\n        if (curr.type.equals(\"E\")) {\n            return 1;\n        }\n        \n        // Optional substance node\n        if (curr.type.equals(\"E?\")) {\n            return 2;\n        }\n        \n        // Alt selection node\n        if (curr.type.equals(\"A\")) {\n            long[] dp = new long[curr.children.size() + 1];\n            dp[0] = 0;\n            \n            for (int i = 0; i < curr.children.size(); i++) {\n                long childCombos = countCombinations(curr.children.get(i));\n                dp[i + 1] = childCombos;\n            }\n            \n            long total = 0;\n            for (int i = 1; i <= curr.children.size(); i++) {\n                long[] subsetDP = new long[curr.children.size() + 1];\n                subsetDP[0] = 1;\n                \n                for (int j = 0; j < curr.children.size(); j++) {\n                    subsetDP[j + 1] = (j == i - 1) ? \n                        subsetDP[j] * dp[j + 1] : \n                        subsetDP[j];\n                }\n                \n                total = (total + subsetDP[curr.children.size()]) % MOD;\n            }\n            \n            return total;\n        }\n        \n        // Or selection node\n        if (curr.type.equals(\"R\")) {\n            long result = 0;\n            \n            // At least one child combination\n            for (int subset = 1; subset < (1 << curr.children.size()); subset++) {\n                long subsetProduct = 1;\n                for (int j = 0; j < curr.children.size(); j++) {\n                    if ((subset & (1 << j)) != 0) {\n                        subsetProduct = (subsetProduct * \n                            countCombinations(curr.children.get(j))) % MOD;\n                    }\n                }\n                result = (result + subsetProduct) % MOD;\n            }\n            \n            return result;\n        }\n        \n        // Optional Alt or Or node\n        if (curr.type.equals(\"A?\")) {\n            return (countCombinations(node) + 1) % MOD;\n        }\n        \n        if (curr.type.equals(\"R?\")) {\n            return (countCombinations(node) + 1) % MOD;\n        }\n        \n        return 1;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        nodes = new Node[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            String nodeType = br.readLine();\n            nodes[i] = new Node(nodeType);\n        }\n        \n        for (int i = 1; i < N; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int s = Integer.parseInt(st.nextToken());\n            int t = Integer.parseInt(st.nextToken());\n            nodes[s].children.add(t);\n        }\n        \n        System.out.println(countCombinations(1));\n    }\n}",
    "timestamp": "2025-08-05 18:43:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nstruct Node {\n    char type; // 'E', 'A', 'R'\n    bool optional;\n    vector<int> children;\n};\n\nvector<Node> nodes;\nunordered_map<int, long long> memo;\n\nlong long dfs(int u) {\n    if (memo.count(u)) return memo[u];\n    Node& node = nodes[u];\n    long long res = 0;\n    \n    if (node.type == 'E') {\n        res = 1;\n        if (!node.children.empty()) {\n            for (int v : node.children) {\n                res = (res * dfs(v)) % MOD;\n            }\n        }\n    } else if (node.type == 'A') {\n        if (node.optional) {\n            long long sum = 0;\n            for (int v : node.children) {\n                sum = (sum + dfs(v)) % MOD;\n            }\n            res = (1 + sum) % MOD;\n        } else {\n            for (int v : node.children) {\n                res = (res + dfs(v)) % MOD;\n            }\n        }\n    } else if (node.type == 'R') {\n        if (node.optional) {\n            long long product = 1;\n            for (int v : node.children) {\n                product = (product * (1 + dfs(v))) % MOD;\n            }\n            res = (product - 1 + MOD) % MOD;\n            res = (1 + res) % MOD; // +1 for choosing none\n        } else {\n            long long product = 1;\n            for (int v : node.children) {\n                product = (product * (1 + dfs(v))) % MOD;\n            }\n            res = (product - 1 + MOD) % MOD;\n        }\n    }\n    \n    return memo[u] = res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int N;\n    cin >> N;\n    nodes.resize(N + 1);\n    \n    for (int i = 1; i <= N; ++i) {\n        string s;\n        cin >> s;\n        if (s[0] == 'E') {\n            nodes[i].type = 'E';\n            nodes[i].optional = (s.size() > 1 && s[1] == '?');\n        } else {\n            nodes[i].type = s[0];\n            nodes[i].optional = (s.size() > 1 && s[1] == '?');\n        }\n    }\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int s, t;\n        cin >> s >> t;\n        nodes[s].children.push_back(t);\n    }\n    \n    long long ans = dfs(1);\n    cout << ans << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_NODES 1001\n#define MOD 1000000007\n\ntypedef struct {\n    char type[10];\n    int children[11];\n    int child_count;\n    int parent;\n} Node;\n\nNode nodes[MAX_NODES];\nlong long dp[MAX_NODES][2];\n\nlong long calculate_combinations(int node, int parent_selected) {\n    if (dp[node][parent_selected] != -1)\n        return dp[node][parent_selected];\n\n    long long result = 1;\n    char *type = nodes[node].type;\n    int is_optional = type[strlen(type) - 1] == '?';\n    int is_selection_node = strcmp(type, \"E\") != 0 && strcmp(type, \"E?\") != 0;\n\n    if (!is_selection_node) {\n        // Substance node\n        if (!parent_selected && is_optional)\n            result = 2;\n        return dp[node][parent_selected] = result;\n    }\n\n    // Selection node\n    int type_alt = type[0] == 'A';\n    int min_select = type_alt ? 1 : 1;\n    int max_select = type_alt ? 1 : nodes[node].child_count;\n\n    if (!parent_selected && is_optional)\n        result = 1;\n\n    long long ways = 0;\n    for (int select_count = min_select; select_count <= max_select; select_count++) {\n        long long curr_ways = 1;\n        int children_used = 0;\n\n        for (int i = 0; i < nodes[node].child_count; i++) {\n            int child = nodes[node].children[i];\n            long long child_combinations = calculate_combinations(child, 1);\n            curr_ways = (curr_ways * child_combinations) % MOD;\n            children_used++;\n\n            if (children_used == select_count)\n                break;\n        }\n\n        ways = (ways + curr_ways) % MOD;\n    }\n\n    result = (result * ways) % MOD;\n    return dp[node][parent_selected] = result;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", nodes[i].type);\n        nodes[i].child_count = 0;\n        nodes[i].parent = -1;\n        for (int j = 0; j < 2; j++)\n            dp[i][j] = -1;\n    }\n\n    for (int i = 0; i < N - 1; i++) {\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        nodes[s - 1].children[nodes[s - 1].child_count++] = t - 1;\n        nodes[t - 1].parent = s - 1;\n    }\n\n    long long total_combinations = calculate_combinations(0, 1);\n    printf(\"%lld\\n\", total_combinations);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\nconst int MOD = 1000000007;\n\nstruct Node {\n    string type;\n    vector<int> children;\n};\n\nclass DrugCombination {\nprivate:\n    vector<Node> nodes;\n    vector<long long> dp;\n\n    long long countCombinations(int node) {\n        if (dp[node] != -1) return dp[node];\n\n        long long result = 1;\n        \n        if (nodes[node].type == \"E\" || nodes[node].type == \"E?\") {\n            return dp[node] = 1;\n        }\n\n        bool isOptional = nodes[node].type.back() == '?';\n        bool isAltType = nodes[node].type[0] == 'A';\n\n        if (isAltType) {\n            long long altSum = 0;\n            for (int child : nodes[node].children) {\n                altSum = (altSum + countCombinations(child)) % MOD;\n            }\n            result = isOptional ? (altSum + 1) % MOD : altSum;\n        } else {  // OR type\n            long long orProduct = 1;\n            for (int child : nodes[node].children) {\n                orProduct = (orProduct * countCombinations(child)) % MOD;\n            }\n            result = isOptional ? (orProduct + 1) % MOD : orProduct;\n        }\n\n        return dp[node] = result;\n    }\n\npublic:\n    void solve() {\n        int N;\n        cin >> N;\n\n        nodes.resize(N + 1);\n        dp.assign(N + 1, -1);\n\n        for (int i = 1; i <= N; i++) {\n            cin >> nodes[i].type;\n        }\n\n        for (int i = 1; i < N; i++) {\n            int s, t;\n            cin >> s >> t;\n            nodes[s].children.push_back(t);\n        }\n\n        cout << countCombinations(1) << endl;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    DrugCombination drugCombination;\n    drugCombination.solve();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static List<List<Integer>> tree;\n    static String[] nodeTypes;\n    static long[] dp;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        nodeTypes = new String[N + 1];\n        tree = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            tree.add(new ArrayList<>());\n        }\n        for (int i = 1; i <= N; i++) {\n            nodeTypes[i] = br.readLine();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int s = Integer.parseInt(st.nextToken());\n            int t = Integer.parseInt(st.nextToken());\n            tree.get(s).add(t);\n        }\n        dp = new long[N + 1];\n        Arrays.fill(dp, -1);\n        System.out.println(dfs(1));\n    }\n\n    static long dfs(int node) {\n        if (dp[node] != -1) {\n            return dp[node];\n        }\n        String type = nodeTypes[node];\n        long res = 0;\n        if (type.equals(\"E\")) {\n            res = 1;\n            for (int child : tree.get(node)) {\n                res = res * dfs(child) % MOD;\n            }\n        } else if (type.equals(\"E?\")) {\n            res = 1;\n            for (int child : tree.get(node)) {\n                res = res * dfs(child) % MOD;\n            }\n            res = (res + 1) % MOD;\n        } else if (type.equals(\"A\") || type.equals(\"A?\")) {\n            boolean optional = type.endsWith(\"?\");\n            if (tree.get(node).isEmpty()) {\n                res = optional ? 1 : 0;\n            } else {\n                long sum = 0;\n                for (int child : tree.get(node)) {\n                    sum = (sum + dfs(child)) % MOD;\n                }\n                if (optional) {\n                    res = (sum + 1) % MOD;\n                } else {\n                    res = sum;\n                }\n            }\n        } else if (type.equals(\"R\") || type.equals(\"R?\")) {\n            boolean optional = type.endsWith(\"?\");\n            if (tree.get(node).isEmpty()) {\n                res = optional ? 1 : 0;\n            } else {\n                long product = 1;\n                for (int child : tree.get(node)) {\n                    product = product * (dfs(child) + 1) % MOD;\n                }\n                product = (product - 1 + MOD) % MOD;\n                if (optional) {\n                    res = (product + 1) % MOD;\n                } else {\n                    res = product;\n                }\n            }\n        }\n        dp[node] = res;\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 18:45:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 1000000007\n\ndef calculate_combinations(node, node_type, children, memo):\n    if node in memo:\n        return memo[node]\n    \n    if node_type[node] == 'E':\n        return 1\n    elif node_type[node] == 'E?':\n        return 2\n    \n    comb_count = 0\n    \n    if node_type[node] == 'R':\n        comb_count = 1\n        for child in children[node]:\n            comb_count *= (calculate_combinations(child, node_type, children, memo) + 1)\n            comb_count %= MOD\n        comb_count -= 1\n        comb_count %= MOD\n    elif node_type[node] == 'R?':\n        comb_count = 1\n        for child in children[node]:\n            comb_count *= (calculate_combinations(child, node_type, children, memo) + 1)\n            comb_count %= MOD\n    elif node_type[node] == 'A':\n        comb_count = 0\n        for child in children[node]:\n            comb_count += calculate_combinations(child, node_type, children, memo)\n            comb_count %= MOD\n    elif node_type[node] == 'A?':\n        comb_count = 1\n        for child in children[node]:\n            comb_count += calculate_combinations(child, node_type, children, memo)\n            comb_count %= MOD\n    \n    memo[node] = comb_count\n    return comb_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    N = int(data[0])\n    node_type = []\n    for i in range(1, N + 1):\n        node_type.append(data[i].strip())\n    \n    children = [[] for _ in range(N + 1)]\n    for line in data[N + 1:]:\n        s, t = map(int, line.split())\n        children[s].append(t)\n    \n    # Start from the root, which is node 1 with index 0\n    memo = {}\n    result = calculate_combinations(1, node_type, children, memo)\n    print(result)\n\nmain()",
    "timestamp": "2025-08-13 00:37:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class DrugDevelopment {\n\n    private static List<List<Integer>> graph = new ArrayList<>();\n    private static Map<Integer, Node> nodes = new HashMap<>();\n    private static final int MOD = 1_000_000_007;\n\n    static class Node {\n        String type;\n        boolean isOptional;\n\n        Node(String type, boolean isOptional) {\n            this.type = type;\n            this.isOptional = isOptional;\n        }\n    }\n\n    private static long dfs(int nodeIndex) {\n        Node node = nodes.get(nodeIndex);\n        List<Integer> children = graph.get(nodeIndex);\n\n        if (node.type.equals(\"E\")) {\n            return 1L;\n        } else if (node.type.equals(\"E?\")) {\n            return 2L;\n        } else if (node.type.startsWith(\"A\")) {\n            long sum = 0L;\n            for (int child : children) {\n                sum += dfs(child);\n                sum %= MOD;\n            }\n            return node.isOptional ? (sum + 1) % MOD : sum;\n        } else if (node.type.startsWith(\"R\")) {\n            long product = 1L;\n            for (int child : children) {\n                product *= (dfs(child) + 1) % MOD;\n                product %= MOD;\n            }\n            product = (product - 1 + MOD) % MOD;\n            return node.isOptional ? (product + 1) % MOD : product;\n        }\n\n        return 0;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 1; i <= N; i++) {\n            String nodeInfo = br.readLine().trim();\n            if (nodeInfo.endsWith(\"?\")) {\n                nodes.put(i, new Node(nodeInfo.substring(0, nodeInfo.length() - 1), true));\n            } else {\n                nodes.put(i, new Node(nodeInfo, false));\n            }\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            String[] edgeInfo = br.readLine().trim().split(\" \");\n            int parent = Integer.parseInt(edgeInfo[0]);\n            int child = Integer.parseInt(edgeInfo[1]);\n            graph.get(parent).add(child);\n        }\n\n        long result = dfs(1);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 00:37:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\n#define MOD 1000000007\n\nenum NodeType {\n    NON_OPTIONAL_SUBSTANCE,\n    OPTIONAL_SUBSTANCE,\n    NON_OPTIONAL_ALT,\n    OPTIONAL_ALT,\n    NON_OPTIONAL_OR,\n    OPTIONAL_OR,\n};\n\nstruct Node {\n    NodeType type;\n    vector<int> children;\n};\n\nNode nodes[1001];\n\nint dfs(int node) {\n    Node current = nodes[node];\n    \n    switch (current.type) {\n        case NON_OPTIONAL_SUBSTANCE:\n            return 1;\n            \n        case OPTIONAL_SUBSTANCE:\n            return 2; // choose or not choose\n        \n        case NON_OPTIONAL_ALT: {\n            int total = 0;\n            for (int child : current.children) {\n                total = (total + dfs(child)) % MOD;\n            }\n            return total;\n        }\n        \n        case OPTIONAL_ALT: {\n            int total = 1; // not choosing any\n            for (int child : current.children) {\n                total = (total + dfs(child)) % MOD;\n            }\n            return total;\n        }\n        \n        case NON_OPTIONAL_OR: {\n            int total = 1;\n            for (int child : current.children) {\n                total = (total * dfs(child)) % MOD;\n            }\n            int falseCombinations = 1;\n            for (int child : current.children) {\n                falseCombinations = (falseCombinations * (1 + dfs(child))) % MOD;\n            }\n            falseCombinations = (falseCombinations - total + MOD) % MOD;\n            return (falseCombinations - 1 + MOD) % MOD;\n        }\n        \n        case OPTIONAL_OR: {\n            int total = 1;\n            for (int child : current.children) {\n                total = (total * (1 + dfs(child))) % MOD;\n            }\n            return (total - 1 + MOD) % MOD;\n        }\n        \n        default:\n            return 0;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    for (int i = 1; i <= N; ++i) {\n        char input[4];\n        scanf(\"%s\", input);\n        \n        if (strcmp(input, \"E\") == 0) {\n            nodes[i].type = NON_OPTIONAL_SUBSTANCE;\n        } else if (strcmp(input, \"E?\") == 0) {\n            nodes[i].type = OPTIONAL_SUBSTANCE;\n        } else if (strcmp(input, \"A\") == 0) {\n            nodes[i].type = NON_OPTIONAL_ALT;\n        } else if (strcmp(input, \"A?\") == 0) {\n            nodes[i].type = OPTIONAL_ALT;\n        } else if (strcmp(input, \"R\") == 0) {\n            nodes[i].type = NON_OPTIONAL_OR;\n        } else if (strcmp(input, \"R?\") == 0) {\n            nodes[i].type = OPTIONAL_OR;\n        }\n    }\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        nodes[s].children.push_back(t);\n    }\n    \n    printf(\"%d\\n\", dfs(1));\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 00:38:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\nclass Node:\n    def __init__(self, name, type, optional):\n        self.name = name\n        self.type = type\n        self.optional = optional\n        self.children = []\n\ndef count_combinations(graph, nodes):\n    def dfs(node):\n        if node.type == 'E' or node.type == 'E?':\n            return 1\n\n        combinations = 0\n        \n        if node.type == 'R' or node.type == 'R?':\n            # OR type node\n            if node.optional:\n                # Option to not select any child\n                combinations += 1\n\n            # Calculate combinations by selecting at least one child\n            child_combinations = 1\n            for child in node.children:\n                child_combinations *= dfs(child)\n            \n            combinations += child_combinations\n\n        elif node.type == 'A' or node.type == 'A?':\n            # ALT type node\n            if node.optional:\n                # Option to not select any child\n                combinations += 1\n\n            # Calculate combinations by selecting exactly one child\n            for child in node.children:\n                combinations += dfs(child)\n\n        return combinations % 1000000007\n\n    return dfs(nodes[0])\n\ndef main():\n    N = int(input())\n    nodes = [None] * (N + 1)\n    graph = defaultdict(list)\n\n    # Read node information\n    for i in range(1, N+1):\n        node_info = input().split()\n        name = node_info[0]\n        \n        if len(name) > 1 and name[-1] == '?':\n            optional = True\n            type = name[:-1]\n        else:\n            optional = False\n            type = name\n\n        nodes[i] = Node(name, type, optional)\n\n    # Read edges\n    for _ in range(N-1):\n        s, t = map(int, input().split())\n        graph[s].append(t)\n        nodes[s].children.append(nodes[t])\n\n    result = count_combinations(graph, nodes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:38:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    nodes = []\n    children = defaultdict(list)\n    \n    for _ in range(N):\n        s = input[ptr]\n        ptr += 1\n        nodes.append(s)\n    \n    for _ in range(N-1):\n        s = int(input[ptr]) - 1\n        t = int(input[ptr+1]) - 1\n        ptr += 2\n        children[s].append(t)\n    \n    # We'll process nodes in post-order (children first)\n    # So we need to process in topological order (children before parents)\n    # We can use a stack for DFS post-order processing\n    stack = [(0, False)]\n    post_order = []\n    visited = [False] * N\n    \n    while stack:\n        node, processed = stack.pop()\n        if processed:\n            post_order.append(node)\n            continue\n        if visited[node]:\n            continue\n        visited[node] = True\n        stack.append((node, True))\n        # Push children in reverse order to process in order\n        for child in reversed(children[node]):\n            stack.append((child, False))\n    \n    dp = [0] * N\n    \n    for node in post_order:\n        node_info = nodes[node]\n        if not children[node]:\n            # Leaf node (substance)\n            if node_info.endswith('?'):\n                dp[node] = 2  # choose or not\n            else:\n                dp[node] = 1  # must choose\n        else:\n            # Selection node\n            is_optional = node_info.endswith('?')\n            if node_info.startswith('A') or node_info.startswith('A?'):\n                # alt type\n                ways = 1\n                for child in children[node]:\n                    ways = ways * dp[child] % MOD\n                if is_optional:\n                    ways = (ways + 1) % MOD\n                dp[node] = ways\n            elif node_info.startswith('R') or node_info.startswith('R?'):\n                # or type\n                ways = 1\n                for child in children[node]:\n                    ways = ways * (dp[child] + 1) % MOD\n                ways = (ways - 1) % MOD\n                if is_optional:\n                    ways = (ways + 1) % MOD\n                dp[node] = ways\n            else:\n                # substance node (non-leaf, but problem says selection nodes have children)\n                pass  # shouldn't happen per problem statement\n    \n    print(dp[0] % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 00:38:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nconst int MOD = 1000000007;\nunordered_map<int, vector<int>> tree;\nunordered_map<int, string> nodeType;\n\nlong long dfs(int node) {\n    string type = nodeType[node];\n    \n    if (type == \"E\") return 1;\n    if (type == \"E?\") return 2;\n    \n    vector<long long> dp(tree[node].size(), 0);\n    for (int i = 0; i < tree[node].size(); ++i) {\n        dp[i] = dfs(tree[node][i]);\n    }\n    \n    if (type == \"R\") {\n        long long ways = 1;\n        for (auto& x : dp) {\n            ways *= (x + 1);\n            ways %= MOD;\n        }\n        ways = (ways - 1 + MOD) % MOD;\n        return ways;\n    }\n    \n    if (type == \"R?\") {\n        long long ways = 1;\n        for (auto& x : dp) {\n            ways *= (x + 1);\n            ways %= MOD;\n        }\n        return ways;\n    }\n    \n    if (type == \"A\") {\n        long long ways = 0;\n        for (auto& x : dp) {\n            ways += x;\n            ways %= MOD;\n        }\n        return ways;\n    }\n    \n    if (type == \"A?\") {\n        long long ways = 1;\n        long long sum = 0;\n        for (auto& x : dp) {\n            sum += x;\n            sum %= MOD;\n        }\n        ways = (ways + sum) % MOD;\n        return ways;\n    }\n    \n    return 0; // Should never reach here\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    nodeType.resize(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> nodeType[i];\n    }\n    \n    for (int i = 0; i < N - 1; ++i) {\n        int s, t;\n        cin >> s >> t;\n        tree[s].push_back(t);\n    }\n    \n    cout << dfs(1) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:55:09"
  }
]