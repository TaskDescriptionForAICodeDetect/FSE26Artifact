[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <vector>\n\n#define MAX_N 100005\n\nstd::vector<int> graph[MAX_N];\nbool visited[MAX_N];\n\nvoid dfs(int node) {\n    visited[node] = true;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor);\n        }\n    }\n}\n\nint count_reachable_nodes(int start, int n) {\n    memset(visited, 0, sizeof(visited));\n    dfs(start);\n    \n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (visited[i]) count++;\n    }\n    \n    return count;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    \n    int fennec_reachable = count_reachable_nodes(1, n);\n    int snuke_reachable = count_reachable_nodes(n, n);\n    \n    if (fennec_reachable > snuke_reachable) {\n        printf(\"Fennec\\n\");\n    } else {\n        printf(\"Snuke\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* adj[MAX_N + 1];\nint color[MAX_N + 1];\nint parent[MAX_N + 1];\nint dist_1[MAX_N + 1];\nint dist_N[MAX_N + 1];\n\nvoid add_edge(int u, int v) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->vertex = v;\n    node->next = adj[u];\n    adj[u] = node;\n}\n\nvoid bfs(int start, int* dist) {\n    int queue[MAX_N];\n    int front = 0, rear = 0;\n    queue[rear++] = start;\n    dist[start] = 0;\n    while (front < rear) {\n        int u = queue[front++];\n        for (Node* node = adj[u]; node != NULL; node = node->next) {\n            int v = node->vertex;\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b);\n        add_edge(b, a);\n    }\n\n    memset(dist_1, -1, sizeof(dist_1));\n    memset(dist_N, -1, sizeof(dist_N));\n    bfs(1, dist_1);\n    bfs(N, dist_N);\n\n    int fennec = 0, snuke = 0;\n    for (int i = 1; i <= N; i++) {\n        if (dist_1[i] <= dist_N[i]) {\n            fennec++;\n        } else {\n            snuke++;\n        }\n    }\n\n    if (fennec > snuke) {\n        printf(\"Fennec\\n\");\n    } else {\n        printf(\"Snuke\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> dist1, distN;\n\nvoid bfs(int start, vector<int>& dist) {\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    adj.resize(N + 1);\n    dist1.assign(N + 1, -1);\n    distN.assign(N + 1, -1);\n\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    bfs(1, dist1);\n    bfs(N, distN);\n\n    int fennec = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (dist1[i] <= distN[i]) {\n            fennec++;\n        }\n    }\n\n    if (fennec > N - fennec) {\n        cout << \"Fennec\" << endl;\n    } else {\n        cout << \"Snuke\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static List<Integer>[] tree;\n    static int[] parent;\n    static int[] depth;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        tree = new ArrayList[N + 1];\n        parent = new int[N + 1];\n        depth = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            tree[a].add(b);\n            tree[b].add(a);\n        }\n\n        bfs(1);\n        int u = N;\n        int count = 0;\n        while (u != 1) {\n            u = parent[u];\n            count++;\n        }\n        int critical = (count - 1) / 2;\n        u = N;\n        for (int i = 0; i < critical; i++) {\n            u = parent[u];\n        }\n        int black = depth[u] - 1;\n        int white = N - black - 2;\n        if (black > white) {\n            System.out.println(\"Fennec\");\n        } else {\n            System.out.println(\"Snuke\");\n        }\n    }\n\n    static void bfs(int start) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        parent[start] = -1;\n        depth[start] = 1;\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : tree[u]) {\n                if (parent[v] == 0 && v != parent[u]) {\n                    parent[v] = u;\n                    depth[v] = depth[u] + 1;\n                    queue.add(v);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:18:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeGame {\n    static ArrayList<Integer>[] graph;\n    static int N;\n    static boolean[] visited;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        N = sc.nextInt();\n        graph = new ArrayList[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        \n        visited = new boolean[N + 1];\n        int result = solve();\n        \n        System.out.println(result == 1 ? \"Fennec\" : \"Snuke\");\n    }\n    \n    static int solve() {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n        visited[1] = true;\n        \n        int fennecCells = 1;\n        int snukeCells = 0;\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            \n            for (int next : graph[current]) {\n                if (!visited[next]) {\n                    queue.offer(next);\n                    visited[next] = true;\n                    \n                    if (current == 1 || current == N) {\n                        snukeCells++;\n                    } else {\n                        fennecCells++;\n                    }\n                }\n            }\n        }\n        \n        return fennecCells > snukeCells ? 1 : 2;\n    }\n}",
    "timestamp": "2025-08-05 23:18:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100005;\nvector<int> graph[MAXN];\nint depth[MAXN];\n\nvoid dfs(int node, int parent, int d) {\n    depth[node] = d;\n    for (int child : graph[node]) {\n        if (child != parent) {\n            dfs(child, node, d + 1);\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    dfs(1, 0, 0);\n\n    int fennec_cells = 0, snuke_cells = 0;\n    for (int i = 1; i <= N; i++) {\n        if (depth[i] % 2 == 0) {\n            fennec_cells++;\n        } else {\n            snuke_cells++;\n        }\n    }\n\n    if (fennec_cells > snuke_cells) {\n        cout << \"Fennec\" << endl;\n    } else {\n        cout << \"Snuke\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef fennec_vs_snuke(n, roads):\n    graph = defaultdict(list)\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(start):\n        queue = deque([start])\n        distances = [-1] * (n + 1)\n        distances[start] = 0\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n\n    distances_from_1 = bfs(1)\n    distances_from_n = bfs(n)\n    \n    fennec_moves = snuke_moves = 0\n    for i in range(1, n + 1):\n        if distances_from_1[i] <= distances_from_n[i]:\n            fennec_moves += 1\n        else:\n            snuke_moves += 1\n\n    return \"Fennec\" if fennec_moves > snuke_moves else \"Snuke\"\n\n# Example usage:\nn = 7\nroads = [(1, 3), (3, 2), (3, 4), (2, 5), (4, 6), (4, 7)]\nprint(fennec_vs_snuke(n, roads))  # Output: \"Fennec\"",
    "timestamp": "2025-08-13 14:29:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeGame {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        List<List<Integer>> adjList = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adjList.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            adjList.get(u).add(v);\n            adjList.get(v).add(u);\n        }\n        \n        int[] distFrom1 = bfs(1, adjList, N);\n        int[] distFromN = bfs(N, adjList, N);\n        \n        int fennecCount = 0;\n        int snukeCount = 0;\n        \n        for (int i = 1; i <= N; i++) {\n            if (distFrom1[i] <= distFromN[i]) {\n                fennecCount++;\n            } else {\n                snukeCount++;\n            }\n        }\n        \n        if (fennecCount > snukeCount) {\n            System.out.println(\"Fennec\");\n        } else {\n            System.out.println(\"Snuke\");\n        }\n\n        scanner.close();\n    }\n\n    private static int[] bfs(int start, List<List<Integer>> adjList, int N) {\n        int[] dist = new int[N + 1];\n        Arrays.fill(dist, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        dist[start] = 0;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : adjList.get(u)) {\n                if (dist[v] == -1) {\n                    dist[v] = dist[u] + 1;\n                    queue.offer(v);\n                }\n            }\n        }\n\n        return dist;\n    }\n}",
    "timestamp": "2025-08-13 14:29:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\ntypedef struct {\n    int node;\n    int dist;\n} QueueItem;\n\nint head = 0, tail = 0;\nQueueItem queue[2 * MAX_N];\nint queue_size = 0;\n\nint adjacency[MAX_N + 1][MAX_N];\nint degree[MAX_N + 1] = {0};\nint distance1[MAX_N + 1];\nint distanceN[MAX_N + 1];\n\nvoid enqueue(int node, int dist) {\n    queue[tail].node = node;\n    queue[tail].dist = dist;\n    tail = (tail + 1) % (2 * MAX_N);\n    queue_size++;\n}\n\nQueueItem dequeue() {\n    QueueItem item = queue[head];\n    head = (head + 1) % (2 * MAX_N);\n    queue_size--;\n    return item;\n}\n\nvoid bfs(int start, int *distance) {\n    distance[start] = 0;\n    enqueue(start, 0);\n    while (queue_size > 0) {\n        QueueItem current = dequeue();\n        int node = current.node, dist = current.dist;\n        for (int i = 0; i < degree[node]; i++) {\n            int next = adjacency[node][i];\n            if (distance[next] == -1) {\n                distance[next] = dist + 1;\n                enqueue(next, dist + 1);\n            }\n        }\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i < N-1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        adjacency[a][degree[a]++] = b;\n        adjacency[b][degree[b]++] = a;\n    }\n\n    for (int i = 1; i <= N; i++) {\n        distance1[i] = distanceN[i] = -1;\n    }\n\n    bfs(1, distance1);\n    bfs(N, distanceN);\n\n    int fennec_count = 0;\n    for (int i = 1; i <= N; i++) {\n        if (distance1[i] <= distanceN[i]) {\n            fennec_count++;\n        }\n    }\n\n    if (fennec_count > N / 2) {\n        printf(\"Fennec\\n\");\n    } else {\n        printf(\"Snuke\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:29:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\n// Function to perform BFS and compute distances from a given start node\nstd::vector<int> bfs_distance(const std::vector<std::vector<int>>& graph, int start) {\n    int n = graph.size();\n    std::vector<int> distance(n, -1);\n    std::queue<int> q;\n    q.push(start);\n    distance[start] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int neighbor : graph[node]) {\n            if (distance[neighbor] == -1) {\n                distance[neighbor] = distance[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n    return distance;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<std::vector<int>> graph(n);\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        --u, --v;  // Decrementing to convert to 0-indexed\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    // Get distances from node 0 (Cell 1)\n    std::vector<int> distance_from_1 = bfs_distance(graph, 0);\n    // Get distances from node n-1 (Cell N)\n    std::vector<int> distance_from_n = bfs_distance(graph, n - 1);\n\n    int fennec_count = 0, snuke_count = 0;\n\n    // Compare distances to determine which player can reach a cell first\n    for (int i = 0; i < n; ++i) {\n        if (distance_from_1[i] <= distance_from_n[i]) {\n            ++fennec_count;\n        } else {\n            ++snuke_count;\n        }\n    }\n\n    // Determine and print the winner\n    if (fennec_count > snuke_count) {\n        std::cout << \"Fennec\" << std::endl;\n    } else {\n        std::cout << \"Snuke\" << std::endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:30:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_game(N, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    black_cells = {1}\n    white_cells = {N}\n    \n    def get_paintable_cells(current_cells, opponent_cells):\n        paintable = set()\n        for cell in current_cells:\n            for neighbor in graph[cell]:\n                if neighbor not in current_cells and neighbor not in opponent_cells:\n                    paintable.add(neighbor)\n        return paintable\n    \n    turn = 0\n    while True:\n        if turn % 2 == 0:  # Fennec's turn (black)\n            paintable_black = get_paintable_cells(black_cells, white_cells)\n            if not paintable_black:\n                return \"Snuke\"\n            new_cell = min(paintable_black)\n            black_cells.add(new_cell)\n        else:  # Snuke's turn (white)\n            paintable_white = get_paintable_cells(white_cells, black_cells)\n            if not paintable_white:\n                return \"Fennec\"\n            new_cell = max(paintable_white)\n            white_cells.add(new_cell)\n        \n        turn += 1\n\ndef main():\n    N = int(input())\n    edges = []\n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    winner = solve_game(N, edges)\n    print(winner)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 14:30:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # BFS to find distances from 1 and N\n    def bfs(start):\n        dist = [-1] * (N+1)\n        q = deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if dist[u] == -1:\n                    dist[u] = dist[v] + 1\n                    q.append(u)\n        return dist\n    \n    dist1 = bfs(1)\n    distN = bfs(N)\n    \n    cnt = 0\n    for i in range(1, N+1):\n        if dist1[i] <= distN[i]:\n            cnt += 1\n    \n    if cnt > N - cnt:\n        print(\"Fennec\")\n    else:\n        print(\"Snuke\")\n\nsolve()",
    "timestamp": "2025-08-13 14:30:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function determineWinner(N, edges) {\n    const adjList = Array.from({ length: N + 1 }, () => []);\n    edges.forEach(([u, v]) => {\n        adjList[u].push(v);\n        adjList[v].push(u);\n    });\n\n    const distances = Array(N + 1).fill(Infinity);\n\n    function bfs(start) {\n        const queue = [start];\n        distances[start] = 0;\n        let index = 0;\n\n        while (index < queue.length) {\n            const node = queue[index++];\n            const currentDist = distances[node];\n\n            adjList[node].forEach((neighbor) => {\n                if (distances[neighbor] === Infinity) {\n                    distances[neighbor] = currentDist + 1;\n                    queue.push(neighbor);\n                }\n            });\n        }\n    }\n\n    bfs(1);\n    const distanceFrom1 = [...distances];\n    distances.fill(Infinity);\n    bfs(N);\n\n    let countFennec = 0;\n    for (let i = 1; i <= N; i++) {\n        if (distanceFrom1[i] <= distances[i]) countFennec++;\n    }\n\n    return countFennec > N / 2 ? \"Fennec\" : \"Snuke\";\n}\n\n// Example usage:\nconst N = 7;\nconst edges = [\n    [1, 3],\n    [1, 2],\n    [2, 4],\n    [2, 5],\n    [3, 6],\n    [3, 7]\n];\nconsole.log(determineWinner(N, edges)); // Outputs: \"Fennec\"",
    "timestamp": "2025-08-13 14:30:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, edges) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    const blackVisited = new Set([1]);\n    const whiteVisited = new Set([N]);\n    const blackQueue = [1];\n    const whiteQueue = [N];\n\n    while (blackQueue.length > 0 || whiteQueue.length > 0) {\n        const newBlackVisited = new Set();\n        for (const node of blackQueue) {\n            for (const neighbor of graph[node]) {\n                if (!blackVisited.has(neighbor) && !whiteVisited.has(neighbor)) {\n                    newBlackVisited.add(neighbor);\n                }\n            }\n        }\n\n        const newWhiteVisited = new Set();\n        for (const node of whiteQueue) {\n            for (const neighbor of graph[node]) {\n                if (!whiteVisited.has(neighbor) && !blackVisited.has(neighbor)) {\n                    newWhiteVisited.add(neighbor);\n                }\n            }\n        }\n\n        if (newBlackVisited.size === 0 && newWhiteVisited.size === 0) break;\n\n        for (const node of newBlackVisited) {\n            blackVisited.add(node);\n        }\n        blackQueue.splice(0, blackQueue.length, ...newBlackVisited);\n\n        for (const node of newWhiteVisited) {\n            whiteVisited.add(node);\n        }\n        whiteQueue.splice(0, whiteQueue.length, ...newWhiteVisited);\n    }\n\n    const totalVisited = new Set([...blackVisited, ...whiteVisited]);\n    const unvisited = new Set(Array.from({ length: N }, (_, i) => i + 1).filter(x => !totalVisited.has(x)));\n\n    return unvisited.size === 0 ? 'Snuke' : 'Fennec';\n}",
    "timestamp": "2025-08-13 14:31:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n\nfunction solve() {\n    const N = parseInt(input[0], 10);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    \n    for (let i = 1; i <= N - 1; i++) {\n        const [a, b] = input[i].split(' ').map(Number);\n        adj[a].push(b);\n        adj[b].push(a);\n    }\n    \n    const parent = new Array(N + 1).fill(0);\n    const depth = new Array(N + 1).fill(0);\n    const queue = [];\n    queue.push(1);\n    parent[1] = -1;\n    \n    while (queue.length > 0) {\n        const v = queue.shift();\n        for (const u of adj[v]) {\n            if (u !== parent[v]) {\n                parent[u] = v;\n                depth[u] = depth[v] + 1;\n                queue.push(u);\n            }\n        }\n    }\n    \n    const path = [];\n    let v = N;\n    while (v !== -1) {\n        path.push(v);\n        v = parent[v];\n    }\n    path.reverse();\n    \n    const mid = path[Math.floor((path.length - 1) / 2)];\n    const sepParent = path[Math.floor((path.length - 1) / 2) + 1];\n    \n    const blocked = new Array(N + 1).fill(false);\n    queue.length = 0;\n    queue.push(sepParent);\n    blocked[sepParent] = true;\n    let count = 0;\n    \n    while (queue.length > 0) {\n        const v = queue.shift();\n        count++;\n        for (const u of adj[v]) {\n            if (u !== parent[v] && !blocked[u]) {\n                blocked[u] = true;\n                queue.push(u);\n            }\n        }\n    }\n    \n    const fennecCells = (N - count) > count ? \"Fennec\" : \"Snuke\";\n    console.log(fennecCells);\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:31:13"
  }
]