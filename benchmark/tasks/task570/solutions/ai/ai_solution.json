[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BOARD_SIZE 4\n#define GOAL_STATE \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0\"\n\ntypedef struct {\n    int board[BOARD_SIZE * BOARD_SIZE];\n    int zero_pos;\n    int moves;\n} PuzzleState;\n\nint is_solvable(int *board) {\n    int inversions = 0;\n    int zero_row = 0;\n\n    for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {\n        if (board[i] == 0) {\n            zero_row = i / BOARD_SIZE;\n            continue;\n        }\n        for (int j = i + 1; j < BOARD_SIZE * BOARD_SIZE; j++) {\n            if (board[j] == 0) continue;\n            if (board[i] > board[j]) inversions++;\n        }\n    }\n\n    if (BOARD_SIZE % 2 == 1) \n        return inversions % 2 == 0;\n    else \n        return (inversions + zero_row) % 2 == 1;\n}\n\nint can_move(int pos, int new_pos) {\n    int row1 = pos / BOARD_SIZE;\n    int col1 = pos % BOARD_SIZE;\n    int row2 = new_pos / BOARD_SIZE;\n    int col2 = new_pos % BOARD_SIZE;\n\n    return (abs(row1 - row2) + abs(col1 - col2)) == 1;\n}\n\nint is_goal_state(int *board) {\n    for (int i = 0; i < BOARD_SIZE * BOARD_SIZE - 1; i++) {\n        if (board[i] != i + 1) return 0;\n    }\n    return board[BOARD_SIZE * BOARD_SIZE - 1] == 0;\n}\n\nint solve_puzzle(PuzzleState *initial) {\n    if (!is_solvable(initial->board)) return -1;\n    if (is_goal_state(initial->board)) return 0;\n\n    int visited[1000000] = {0};\n    PuzzleState *queue[1000000];\n    int front = 0, rear = 0;\n\n    queue[rear++] = initial;\n    visited[initial->zero_pos] = 1;\n\n    while (front < rear) {\n        PuzzleState *current = queue[front++];\n\n        int moves[] = {-BOARD_SIZE, BOARD_SIZE, -1, 1};\n        for (int i = 0; i < 4; i++) {\n            int new_pos = current->zero_pos + moves[i];\n\n            if (new_pos >= 0 && new_pos < BOARD_SIZE * BOARD_SIZE && \n                can_move(current->zero_pos, new_pos) && \n                !visited[new_pos]) {\n\n                PuzzleState *next = malloc(sizeof(PuzzleState));\n                memcpy(next, current, sizeof(PuzzleState));\n                next->board[current->zero_pos] = next->board[new_pos];\n                next->board[new_pos] = 0;\n                next->zero_pos = new_pos;\n                next->moves++;\n\n                if (is_goal_state(next->board)) {\n                    int result = next->moves;\n                    free(next);\n                    return result;\n                }\n\n                visited[new_pos] = 1;\n                queue[rear++] = next;\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    PuzzleState initial;\n    initial.moves = 0;\n\n    for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {\n        scanf(\"%d\", &initial.board[i]);\n        if (initial.board[i] == 0) {\n            initial.zero_pos = i;\n        }\n    }\n\n    int result = solve_puzzle(&initial);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:10:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define SIZE 4\n#define TOTAL_CELLS (SIZE * SIZE)\n\ntypedef struct {\n    int board[SIZE][SIZE];\n    int zero_row, zero_col;\n    int g, h;\n} State;\n\ntypedef struct {\n    State *array;\n    int capacity;\n    int size;\n} PriorityQueue;\n\nint target[SIZE][SIZE] = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n    {9, 10, 11, 12},\n    {13, 14, 15, 0}\n};\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nPriorityQueue* createPriorityQueue(int capacity) {\n    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));\n    pq->array = (State*)malloc(capacity * sizeof(State));\n    pq->capacity = capacity;\n    pq->size = 0;\n    return pq;\n}\n\nvoid swap(State *a, State *b) {\n    State temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid heapify(PriorityQueue* pq, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n\n    if (left < pq->size && (pq->array[left].g + pq->array[left].h) < (pq->array[smallest].g + pq->array[smallest].h))\n        smallest = left;\n    if (right < pq->size && (pq->array[right].g + pq->array[right].h) < (pq->array[smallest].g + pq->array[smallest].h))\n        smallest = right;\n    if (smallest != idx) {\n        swap(&pq->array[idx], &pq->array[smallest]);\n        heapify(pq, smallest);\n    }\n}\n\nState extractMin(PriorityQueue* pq) {\n    State root = pq->array[0];\n    pq->array[0] = pq->array[pq->size - 1];\n    pq->size--;\n    heapify(pq, 0);\n    return root;\n}\n\nvoid insert(PriorityQueue* pq, State state) {\n    if (pq->size == pq->capacity) return;\n    pq->array[pq->size] = state;\n    int i = pq->size;\n    pq->size++;\n    while (i != 0 && (pq->array[(i - 1) / 2].g + pq->array[(i - 1) / 2].h) > (pq->array[i].g + pq->array[i].h)) {\n        swap(&pq->array[i], &pq->array[(i - 1) / 2]);\n        i = (i - 1) / 2;\n    }\n}\n\nint isEqual(int a[SIZE][SIZE], int b[SIZE][SIZE]) {\n    for (int i = 0; i < SIZE; i++)\n        for (int j = 0; j < SIZE; j++)\n            if (a[i][j] != b[i][j])\n                return 0;\n    return 1;\n}\n\nint manhattanDistance(int board[SIZE][SIZE]) {\n    int distance = 0;\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (board[i][j] != 0) {\n                int target_row = (board[i][j] - 1) / SIZE;\n                int target_col = (board[i][j] - 1) % SIZE;\n                distance += abs(i - target_row) + abs(j - target_col);\n            }\n        }\n    }\n    return distance;\n}\n\nint isSafe(int row, int col) {\n    return (row >= 0 && row < SIZE && col >= 0 && col < SIZE);\n}\n\nvoid copyBoard(int dest[SIZE][SIZE], int src[SIZE][SIZE]) {\n    for (int i = 0; i < SIZE; i++)\n        for (int j = 0; j < SIZE; j++)\n            dest[i][j] = src[i][j];\n}\n\nint solvePuzzle(State initial) {\n    PriorityQueue* pq = createPriorityQueue(1000000);\n    initial.g = 0;\n    initial.h = manhattanDistance(initial.board);\n    insert(pq, initial);\n\n    while (pq->size > 0) {\n        State current = extractMin(pq);\n        if (isEqual(current.board, target)) {\n            free(pq->array);\n            free(pq);\n            return current.g;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int new_row = current.zero_row + dx[i];\n            int new_col = current.zero_col + dy[i];\n            if (isSafe(new_row, new_col)) {\n                State new_state;\n                copyBoard(new_state.board, current.board);\n                new_state.board[current.zero_row][current.zero_col] = new_state.board[new_row][new_col];\n                new_state.board[new_row][new_col] = 0;\n                new_state.zero_row = new_row;\n                new_state.zero_col = new_col;\n                new_state.g = current.g + 1;\n                new_state.h = manhattanDistance(new_state.board);\n                insert(pq, new_state);\n            }\n        }\n    }\n    free(pq->array);\n    free(pq);\n    return -1;\n}\n\nint main() {\n    State initial;\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            scanf(\"%d\", &initial.board[i][j]);\n            if (initial.board[i][j] == 0) {\n                initial.zero_row = i;\n                initial.zero_col = j;\n            }\n        }\n    }\n    printf(\"%d\\n\", solvePuzzle(initial));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:11:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 4;\nconst int target[N][N] = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n    {9, 10, 11, 12},\n    {13, 14, 15, 0}\n};\n\nstruct State {\n    int board[N][N];\n    int zero_row, zero_col;\n    int steps;\n    string hash;\n\n    State(int b[N][N], int zr, int zc, int s) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                board[i][j] = b[i][j];\n            }\n        }\n        zero_row = zr;\n        zero_col = zc;\n        steps = s;\n        hash = \"\";\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                hash += to_string(board[i][j]) + \",\";\n            }\n        }\n    }\n\n    bool isTarget() {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (board[i][j] != target[i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n\nint solve(int initial[N][N], int zero_row, int zero_col) {\n    queue<State> q;\n    unordered_set<string> visited;\n\n    State start(initial, zero_row, zero_col, 0);\n    q.push(start);\n    visited.insert(start.hash);\n\n    int dr[] = {-1, 1, 0, 0};\n    int dc[] = {0, 0, -1, 1};\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.isTarget()) {\n            return current.steps;\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = current.zero_row + dr[i];\n            int new_col = current.zero_col + dc[i];\n\n            if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                int new_board[N][N];\n                for (int r = 0; r < N; ++r) {\n                    for (int c = 0; c < N; ++c) {\n                        new_board[r][c] = current.board[r][c];\n                    }\n                }\n                swap(new_board[current.zero_row][current.zero_col], new_board[new_row][new_col]);\n\n                State next(new_board, new_row, new_col, current.steps + 1);\n                if (visited.find(next.hash) == visited.end()) {\n                    visited.insert(next.hash);\n                    q.push(next);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int initial[N][N];\n    int zero_row, zero_col;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> initial[i][j];\n            if (initial[i][j] == 0) {\n                zero_row = i;\n                zero_col = j;\n            }\n        }\n    }\n\n    cout << solve(initial, zero_row, zero_col) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:11:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FifteenPuzzle {\n    static class State {\n        int[][] board;\n        int zeroRow, zeroCol;\n        int cost;\n        String boardString;\n        State parent;\n\n        State(int[][] board, int zeroRow, int zeroCol, int cost, State parent) {\n            this.board = new int[4][4];\n            for (int i = 0; i < 4; i++) {\n                System.arraycopy(board[i], 0, this.board[i], 0, 4);\n            }\n            this.zeroRow = zeroRow;\n            this.zeroCol = zeroCol;\n            this.cost = cost;\n            this.parent = parent;\n            this.boardString = Arrays.deepToString(board);\n        }\n    }\n\n    static final int[][] TARGET = {\n            {1, 2, 3, 4},\n            {5, 6, 7, 8},\n            {9, 10, 11, 12},\n            {13, 14, 15, 0}\n    };\n\n    static final int[][] DIRS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[][] initialBoard = new int[4][4];\n        int zeroRow = 0, zeroCol = 0;\n\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                initialBoard[i][j] = scanner.nextInt();\n                if (initialBoard[i][j] == 0) {\n                    zeroRow = i;\n                    zeroCol = j;\n                }\n            }\n        }\n\n        System.out.println(bfs(initialBoard, zeroRow, zeroCol));\n    }\n\n    static int bfs(int[][] initialBoard, int zeroRow, int zeroCol) {\n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        State initialState = new State(initialBoard, zeroRow, zeroCol, 0, null);\n        queue.add(initialState);\n        visited.add(initialState.boardString);\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (Arrays.deepEquals(current.board, TARGET)) {\n                return current.cost;\n            }\n\n            for (int[] dir : DIRS) {\n                int newRow = current.zeroRow + dir[0];\n                int newCol = current.zeroCol + dir[1];\n\n                if (newRow >= 0 && newRow < 4 && newCol >= 0 && newCol < 4) {\n                    int[][] newBoard = new int[4][4];\n                    for (int i = 0; i < 4; i++) {\n                        System.arraycopy(current.board[i], 0, newBoard[i], 0, 4);\n                    }\n                    newBoard[current.zeroRow][current.zeroCol] = newBoard[newRow][newCol];\n                    newBoard[newRow][newCol] = 0;\n\n                    State newState = new State(newBoard, newRow, newCol, current.cost + 1, current);\n                    if (!visited.contains(newState.boardString)) {\n                        visited.add(newState.boardString);\n                        queue.add(newState);\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 22:12:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FifteenPuzzle {\n    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    private static final int TARGET_STATE = 0x123456789ABCDEF0L;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long initialState = 0;\n        \n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                int num = scanner.nextInt();\n                initialState = (initialState << 4) | num;\n            }\n        }\n        \n        int steps = solve(initialState);\n        System.out.println(steps);\n    }\n\n    private static int solve(long initialState) {\n        Queue<Long> queue = new LinkedList<>();\n        Set<Long> visited = new HashSet<>();\n        Map<Long, Integer> distances = new HashMap<>();\n\n        queue.offer(initialState);\n        visited.add(initialState);\n        distances.put(initialState, 0);\n\n        while (!queue.isEmpty()) {\n            long currentState = queue.poll();\n\n            if (currentState == TARGET_STATE) {\n                return distances.get(currentState);\n            }\n\n            int zeroPos = findZeroPosition(currentState);\n            int row = zeroPos / 4;\n            int col = zeroPos % 4;\n\n            for (int[] dir : DIRECTIONS) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n\n                if (newRow >= 0 && newRow < 4 && newCol >= 0 && newCol < 4) {\n                    long newState = swapTiles(currentState, zeroPos, newRow * 4 + newCol);\n\n                    if (!visited.contains(newState)) {\n                        queue.offer(newState);\n                        visited.add(newState);\n                        distances.put(newState, distances.get(currentState) + 1);\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private static int findZeroPosition(long state) {\n        for (int i = 0; i < 16; i++) {\n            if ((state & 0xFL) == 0) {\n                return i;\n            }\n            state >>= 4;\n        }\n        return -1;\n    }\n\n    private static long swapTiles(long state, int pos1, int pos2) {\n        long tile1 = (state >> (pos1 * 4)) & 0xFL;\n        long tile2 = (state >> (pos2 * 4)) & 0xFL;\n\n        state &= ~(0xFL << (pos1 * 4));\n        state &= ~(0xFL << (pos2 * 4));\n\n        state |= (tile2 << (pos1 * 4));\n        state |= (tile1 << (pos2 * 4));\n\n        return state;\n    }\n}",
    "timestamp": "2025-08-05 22:12:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 4;\nconst vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nstruct PuzzleState {\n    vector<vector<int>> board;\n    int zeroRow, zeroCol;\n    int moves;\n    string path;\n\n    bool operator==(const PuzzleState& other) const {\n        return board == other.board;\n    }\n};\n\nstruct PuzzleStateHash {\n    size_t operator()(const PuzzleState& state) const {\n        size_t hash = 0;\n        for (const auto& row : state.board) {\n            for (int val : row) {\n                hash = hash * 31 + val;\n            }\n        }\n        return hash;\n    }\n};\n\nbool isSolved(const PuzzleState& state) {\n    int counter = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == N - 1 && j == N - 1) {\n                if (state.board[i][j] != 0) return false;\n            } else {\n                if (state.board[i][j] != counter++) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint solvePuzzle(PuzzleState& initialState) {\n    queue<PuzzleState> q;\n    unordered_set<PuzzleState, PuzzleStateHash> visited;\n\n    q.push(initialState);\n    visited.insert(initialState);\n\n    while (!q.empty()) {\n        PuzzleState current = q.front();\n        q.pop();\n\n        if (isSolved(current)) {\n            return current.moves;\n        }\n\n        for (const auto& dir : directions) {\n            int newRow = current.zeroRow + dir.first;\n            int newCol = current.zeroCol + dir.second;\n\n            if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                PuzzleState next = current;\n                swap(next.board[current.zeroRow][current.zeroCol], \n                     next.board[newRow][newCol]);\n                next.zeroRow = newRow;\n                next.zeroCol = newCol;\n                next.moves++;\n\n                if (visited.find(next) == visited.end()) {\n                    q.push(next);\n                    visited.insert(next);\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    PuzzleState initialState;\n    initialState.board.resize(N, vector<int>(N));\n    initialState.moves = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> initialState.board[i][j];\n            if (initialState.board[i][j] == 0) {\n                initialState.zeroRow = i;\n                initialState.zeroCol = j;\n            }\n        }\n    }\n\n    int result = solvePuzzle(initialState);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:12:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef serialize(board):\n    return tuple(tuple(row) for row in board)\n\ndef get_next_states(state):\n    rows, cols = len(state), len(state[0])\n    zero_pos = [(i, j) for i in range(rows) for j in range(cols) if state[i][j] == 0][0]\n    i, j = zero_pos\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    next_states = []\n    for di, dj in directions:\n        ni, nj = i + di, j + dj\n        if 0 <= ni < rows and 0 <= nj < cols:\n            new_state = [list(row) for row in state]\n            new_state[i][j], new_state[ni][nj] = new_state[ni][nj], new_state[i][j]\n            next_states.append(serialize(new_state))\n    return next_states\n\ndef solve_puzzle(initial):\n    target = serialize([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]])\n    initial_serialized = serialize(initial)\n\n    queue = deque([(initial_serialized, 0)])\n    visited = set()\n    visited.add(initial_serialized)\n\n    while queue:\n        curr_state, steps = queue.popleft()\n        if curr_state == target:\n            return steps\n\n        for next_state in get_next_states(curr_state):\n            if next_state not in visited:\n                visited.add(next_state)\n                queue.append((next_state, steps + 1))\n\n    return -1  # Should never happen for solvable puzzles\n\ninitial_state = [\n    [5, 1, 2, 3],\n    [6, 0, 7, 4],\n    [9, 10, 8, 11],\n    [13, 14, 15, 12]\n]\n\nprint(solve_puzzle(initial_state))",
    "timestamp": "2025-08-13 09:19:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Puzzle15Solver {\n    private static final int N = 4;\n    private static final int[] dx = {-1, 1, 0, 0};\n    private static final int[] dy = {0, 0, -1, 1};\n    \n    static class State {\n        int[][] board;\n        int x, y;\n\n        State(int[][] b, int zeroX, int zeroY) {\n            board = new int[N][N];\n            for (int i = 0; i < N; i++) {\n                System.arraycopy(b[i], 0, board[i], 0, N);\n            }\n            x = zeroX;\n            y = zeroY;\n        }\n\n        State move(int newX, int newY) {\n            int[][] newBoard = new int[N][];\n            for (int i = 0; i < N; i++) {\n                newBoard[i] = board[i].clone();\n            }\n            newBoard[x][y] = newBoard[newX][newY];\n            newBoard[newX][newY] = 0;\n            return new State(newBoard, newX, newY);\n        }\n\n        String getHash() {\n            StringBuilder sb = new StringBuilder();\n            for (int[] row : board) {\n                for (int num : row) {\n                    sb.append(num).append(\"-\");\n                }\n            }\n            return sb.toString();\n        }\n    }\n\n    private static boolean isValid(int x, int y) {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    }\n\n    public static int solve(int[][] initial) {\n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n\n        int zeroX = -1, zeroY = -1;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (initial[i][j] == 0) {\n                    zeroX = i;\n                    zeroY = j;\n                    break;\n                }\n            }\n        }\n\n        State start = new State(initial, zeroX, zeroY);\n        queue.add(start);\n        visited.add(start.getHash());\n\n        int steps = 0;\n        int[][] target = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 0}};\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            while (size-- > 0) {\n                State current = queue.poll();\n                if (Arrays.deepEquals(current.board, target)) {\n                    return steps;\n                }\n\n                for (int i = 0; i < 4; i++) {\n                    int newX = current.x + dx[i];\n                    int newY = current.y + dy[i];\n                    if (isValid(newX, newY)) {\n                        State nextState = current.move(newX, newY);\n                        String hash = nextState.getHash();\n                        if (!visited.contains(hash)) {\n                            visited.add(hash);\n                            queue.add(nextState);\n                        }\n                    }\n                }\n            }\n            steps++;\n        }\n        return -1; // Unsolvable\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[][] puzzle = new int[N][N];\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                puzzle[i][j] = scanner.nextInt();\n            }\n        }\n        \n        int result = solve(puzzle);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 09:19:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define N 4\n#define INF INT_MAX\n\ntypedef struct {\n    int grid[N][N];\n    int x, y;\n} PuzzleState;\n\ntypedef struct {\n    PuzzleState state;\n    int g, h;\n    struct Node* parent;\n} Node;\n\ntypedef struct {\n    Node* arr;\n    int capacity;\n    int size;\n} PriorityQueue;\n\nint target[N][N] = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n    {9, 10, 11, 12},\n    {13, 14, 15, 0}\n};\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid initPriorityQueue(PriorityQueue* pq, int capacity) {\n    pq->arr = (Node*)malloc(sizeof(Node) * capacity);\n    pq->capacity = capacity;\n    pq->size = 0;\n}\n\nvoid push(PriorityQueue* pq, Node node) {\n    if (pq->size < pq->capacity) {\n        pq->arr[pq->size++] = node;\n    }\n}\n\nNode pop(PriorityQueue* pq) {\n    int bestIdx = 0;\n    for (int i = 1; i < pq->size; i++) {\n        if (pq->arr[i].g + pq->arr[i].h < pq->arr[bestIdx].g + pq->arr[bestIdx].h) {\n            bestIdx = i;\n        }\n    }\n    Node bestNode = pq->arr[bestIdx];\n    pq->arr[bestIdx] = pq->arr[--pq->size];\n    return bestNode;\n}\n\nint manhattanDistance(int grid[N][N]) {\n    int distance = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] != 0) {\n                int targetRow = (grid[i][j] - 1) / N;\n                int targetCol = (grid[i][j] - 1) % N;\n                distance += abs(i - targetRow) + abs(j - targetCol);\n            }\n        }\n    }\n    return distance;\n}\n\nint isSolvable(int grid[N][N]) {\n    int inversions = 0;\n    int flatGrid[N * N];\n    int idx = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            flatGrid[idx++] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < N * N - 1; i++) {\n        for (int j = i + 1; j < N * N; j++) {\n            if (flatGrid[i] && flatGrid[j] && flatGrid[i] > flatGrid[j]) {\n                inversions++;\n            }\n        }\n    }\n    int row = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 0) {\n                row = i;\n            }\n        }\n    }\n    return (inversions + row) % 2 == 0;\n}\n\nint areGridsEqual(int grid1[N][N], int grid2[N][N]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid1[i][j] != grid2[i][j]) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nvoid solvePuzzle(int initial[N][N]) {\n    if (!isSolvable(initial)) {\n        printf(\"-1\\n\");\n        return;\n    }\n\n    int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    PriorityQueue pq;\n    initPriorityQueue(&pq, 100000);\n\n    PuzzleState startState;\n    memcpy(startState.grid, initial, sizeof(startState.grid));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (initial[i][j] == 0) {\n                startState.x = i;\n                startState.y = j;\n                break;\n            }\n        }\n    }\n\n    Node startNode = {startState, 0, manhattanDistance(initial), NULL};\n    push(&pq, startNode);\n\n    while (pq.size > 0) {\n        Node currentNode = pop(&pq);\n        if (areGridsEqual(currentNode.state.grid, target)) {\n            printf(\"%d\\n\", currentNode.g);\n            free(pq.arr);\n            return;\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            int newX = currentNode.state.x + directions[i][0];\n            int newY = currentNode.state.y + directions[i][1];\n            if (newX >= 0 && newX < N && newY >= 0 && newY < N) {\n                PuzzleState newState;\n                memcpy(&newState.grid, &currentNode.state.grid, sizeof(newState.grid));\n                swap(&newState.grid[newX][newY], &newState.grid[currentNode.state.x][currentNode.state.y]);\n                newState.x = newX;\n                newState.y = newY;\n\n                Node newNode = {newState, currentNode.g + 1, manhattanDistance(newState.grid), NULL};\n                push(&pq, newNode);\n            }\n        }\n    }\n    \n    printf(\"-1\\n\");\n    free(pq.arr);\n}\n\nint main() {\n    int initial[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &initial[i][j]);\n        }\n    }\n    solvePuzzle(initial);\n    return 0;\n}",
    "timestamp": "2025-08-13 09:19:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport heapq\n\ndef is_goal_state(state: List[List[int]]) -> bool:\n    goal = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]\n    return state == goal\n\ndef get_zero_pos(state: List[List[int]]) -> Tuple[int, int]:\n    for i in range(4):\n        for j in range(4):\n            if state[i][j] == 0:\n                return i, j\n    return -1, -1\n\ndef get_neighbors(state: List[List[int]]) -> List[List[List[int]]]:\n    neighbors = []\n    row, col = get_zero_pos(state)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    for dr, dc in directions:\n        new_row, new_col = row + dr, col + dc\n        \n        if 0 <= new_row < 4 and 0 <= new_col < 4:\n            new_state = [row[:] for row in state]\n            new_state[row][col], new_state[new_row][new_col] = new_state[new_row][new_col], new_state[row][col]\n            neighbors.append(new_state)\n    \n    return neighbors\n\ndef manhattan_distance(state: List[List[int]]) -> int:\n    distance = 0\n    for i in range(4):\n        for j in range(4):\n            if state[i][j] != 0:\n                goal_row = (state[i][j] - 1) // 4\n                goal_col = (state[i][j] - 1) % 4\n                distance += abs(i - goal_row) + abs(j - goal_col)\n    return distance\n\ndef state_to_tuple(state: List[List[int]]) -> Tuple[Tuple[int, ...]]:\n    return tuple(tuple(row) for row in state)\n\ndef solve_15_puzzle(initial_state: List[List[int]]) -> int:\n    start = state_to_tuple(initial_state)\n    visited = set()\n    pq = [(manhattan_distance(initial_state), 0, initial_state)]\n    \n    while pq:\n        _, moves, current_state = heapq.heappop(pq)\n        \n        if is_goal_state(current_state):\n            return moves\n        \n        state_tuple = state_to_tuple(current_state)\n        if state_tuple in visited:\n            continue\n        \n        visited.add(state_tuple)\n        \n        for neighbor in get_neighbors(current_state):\n            if state_to_tuple(neighbor) not in visited:\n                priority = moves + 1 + manhattan_distance(neighbor)\n                heapq.heappush(pq, (priority, moves + 1, neighbor))\n    \n    return -1\n\ndef main():\n    initial_state = []\n    for _ in range(4):\n        row = list(map(int, input().split()))\n        initial_state.append(row)\n    \n    steps = solve_15_puzzle(initial_state)\n    print(steps)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:20:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve_puzzle(initial):\n    target = ((1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12), (13, 14, 15, 0))\n    \n    if initial == target:\n        return 0\n    \n    visited = set()\n    queue = deque()\n    queue.append((initial, 0))\n    visited.add(initial)\n    \n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while queue:\n        current, steps = queue.popleft()\n        \n        for i in range(4):\n            for j in range(4):\n                if current[i][j] == 0:\n                    x, y = i, j\n                    break\n        \n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 4 and 0 <= ny < 4:\n                temp = [list(row) for row in current]\n                temp[x][y], temp[nx][ny] = temp[nx][ny], temp[x][y]\n                next_state = tuple(tuple(row) for row in temp)\n                if next_state == target:\n                    return steps + 1\n                if next_state not in visited:\n                    visited.add(next_state)\n                    queue.append((next_state, steps + 1))\n    return -1\n\ninitial = tuple(tuple(map(int, input().split())) for _ in range(4))\nprint(solve_puzzle(initial))",
    "timestamp": "2025-08-13 09:20:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct PuzzleState {\n    vector<int> board;\n    int zeroPos;\n    int depth;\n\n    PuzzleState(const vector<int>& b, int z, int d) : board(b), zeroPos(z), depth(d) {}\n\n    bool operator==(const PuzzleState& other) const {\n        return board == other.board;\n    }\n};\n\nnamespace std {\n    template <>\n    struct hash<PuzzleState> {\n        size_t operator()(const PuzzleState& state) const {\n            size_t hashValue = 0;\n            for (int num : state.board) {\n                hashValue = hashValue * 31 + num;\n            }\n            return hashValue;\n        }\n    };\n}\n\nconst vector<vector<int>> directions = {\n    {-1, 0},\n    {1, 0},\n    {0, -1},\n    {0, 1}\n};\n\nbool isSolvable(const vector<int>& board) {\n    int inversions = 0;\n    for (int i = 0; i < 16; ++i) {\n        for (int j = i + 1; j < 16; ++j) {\n            if (board[i] && board[j] && board[i] > board[j]) {\n                ++inversions;\n            }\n        }\n    }\n    int rowFromBottom = 3 - (find(board.begin(), board.end(), 0) - board.begin()) / 4;\n    return (inversions + rowFromBottom) % 2 == 0;\n}\n\nint solvePuzzle(const vector<int>& initial) {\n    vector<int> target = {\n        1, 2, 3, 4,\n        5, 6, 7, 8,\n        9, 10, 11, 12,\n        13, 14, 15, 0\n    };\n\n    if (!isSolvable(initial)) {\n        return -1; // unsolvable\n    }\n\n    queue<PuzzleState> queue;\n    unordered_map<PuzzleState, bool> visited;\n\n    int zeroPos = find(initial.begin(), initial.end(), 0) - initial.begin();\n    PuzzleState start(initial, zeroPos, 0);\n\n    queue.push(start);\n    visited[start] = true;\n\n    while (!queue.empty()) {\n        PuzzleState current = queue.front();\n        queue.pop();\n\n        if (current.board == target) {\n            return current.depth;\n        }\n\n        int x = current.zeroPos / 4;\n        int y = current.zeroPos % 4;\n\n        for (const vector<int>& dir : directions) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n            if (nx >= 0 && nx < 4 && ny >= 0 && ny < 4) {\n                vector<int> newBoard = current.board;\n                swap(newBoard[current.zeroPos], newBoard[nx * 4 + ny]);\n                PuzzleState newState(newBoard, nx * 4 + ny, current.depth + 1);\n                if (!visited[newState]) {\n                    queue.push(newState);\n                    visited[newState] = true;\n                }\n            }\n        }\n    }\n    return -1; // should not reach here for solvable puzzles\n}\n\nint main() {\n    vector<int> initial(16);\n    for (int i = 0; i < 16; ++i) {\n        cin >> initial[i];\n    }\n    int steps = solvePuzzle(initial);\n    cout << steps << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:50:45"
  }
]