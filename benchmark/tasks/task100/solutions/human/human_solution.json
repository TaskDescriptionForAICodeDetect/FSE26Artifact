[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nqueue<pair<int, vector<vector<int> > > >Q;\nvector<vector<int>>X, P; int H, W, N, V1[20], V2[20];\npair<bool, vector<vector<int> > > hantei(vector<vector<int> >a1, int X1, int Y1, int H1, int W1, int N1) {\n\tbool OK = true;\n\tfor (int i = X1; i < X1 + H1; i++) {\n\t\tfor (int j = Y1; j < Y1 + W1; j++) {\n\t\t\tif (i >= H || j >= W) { OK = false; continue; }\n\t\t\tif (a1[i][j] != 0 || (X[i][j] != V1[N1] && X[i][j] >= 1))OK = false;\n\t\t\ta1[i][j] = V1[N1];\n\t\t}\n\t}\n\treturn make_pair(OK, a1);\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H >> N; int D1 = 0; if (W == 0 && H == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; i++) { cin >> V1[i] >> V2[i]; D1 += V2[i]; }\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tvector<int>G, I; int a;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a; G.push_back(a); I.push_back(0);\n\t\t\t}\n\t\t\tX.push_back(G); P.push_back(I);\n\t\t}\n\t\tif (D1 != W*H) { cout << \"NA\" << endl; continue; }\n\t\tQ.push(make_pair(0, P)); vector<vector<int> >res; int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tvector<vector<int>>K = Q.front().second;\n\t\t\tint L = Q.front().first; Q.pop();\n\t\t\tif (L == N) { cnt++; res = K; continue; }\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 1; k <= V2[L]; k++) {\n\t\t\t\t\t\tif (V2[L] % k != 0)continue;\n\t\t\t\t\t\tpair<bool, vector<vector<int> > >res1 = hantei(K, i, j, k, V2[L] / k, L);\n\t\t\t\t\t\tif (res1.first == true) { Q.push(make_pair(L + 1, res1.second)); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0 || cnt >= 2)cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (j >= 1) { cout << ' '; }cout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(i,H) rep(j,W) edge[i][j].clear();\n  int debug = 0;\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); debug++; }\n        if( debug >= 100000 ) while(1);\n      Skip:;\n        \n      }\n    }\n  }\n  /*  \n      rep(i,H) rep(j,W) {\n      cout << \"(\" << j << \",\" << i << \") ::\" << endl;\n      rep(l,(int)edge[i][j].size()) cout << \"(\" << edge[i][j][l].w << \",\" << edge[i][j][l].h << \",\" << edge[i][j][l].index << \") \";\n      cout << endl;\n      }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n  if( cy >= H ) while(1);\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      //assert( isValid(x+cx,y+cy) );\n      if( ans[y+cy][x+cx] != 0 ) {\n        goto Skip;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\nvector< vector<int> > draw; int drawTimes;\nvoid drawInit(int W, int H) {\n\t++W, ++H;\n\n\tdrawTimes = 0;\n\tdraw.resize(H);\n\tfor (int i = 0; i < H; ++i) draw[i].resize(W);\n\n\tfor (int y = 0; y < H; ++y)\n\t\tfor (int x = 0; x < W; ++x)\n\t\t\tdraw[y][x] = 0;\n}\nvoid drawSet(P p1, P p2) {\n\t++drawTimes;\n\n\tdraw[p1.imag()][p1.real()] += 1;\n\tdraw[p1.imag()][p2.real()] += -1;\n\tdraw[p2.imag()][p1.real()] += -1;\n\tdraw[p2.imag()][p2.real()] += 1;\n}\nvoid drawDo() {\n\tfor (int y = 0; y < draw.size(); ++y)\n\t\tfor (int x = 0; x < draw[0].size()-1; ++x)\n\t\t\tdraw[y][x+1] += draw[y][x];\n\n\tfor (int x = 0; x < draw[0].size(); ++x)\n\t\tfor (int y = 0; y < draw.size()-1; ++y)\n\t\t\tdraw[y+1][x] += draw[y][x];\n}\n\nint main() {\n\tint W, H, n;\n\twhile (cin >> W >> H >> n, W || H || n) {\n\t\tvector<int> block(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint b, k; cin >> b >> k;\n\t\t\tblock[b-1] = k;\n\t\t}\n\n\t\tvector< vector<int> > df(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 1; j*j <= block[i]; ++j) {\n\t\t\t\tif (block[i] % j == 0)\n\t\t\t\t\tdf[i].push_back( j );\n\t\t\t\t\tdf[i].push_back( block[i] / j );\n\t\t\t}\n\t\t}\n\n\t\tvector< vector<int> > m(H, vector<int>(W));\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tvector< pair<P, P> > pos(n);\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tif (m[y][x])\n\t\t\t\t\tpos[m[y][x]-1] = pair<P, P>( P(x, y), P(x, y) );\n\n\t\tint count = W * H - n;\n\t\tfor (int t = 0; t < W*H; ++t) {\n\t\t\tvector< vector<int> > state(H, vector<int>(W, 0));\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tdrawInit(W, H);\n\t\t\t\tfor (int j = 0; j < df[i].size(); ++j) {\n\t\t\t\t\tint w = df[i][j], h = block[i] / df[i][j];\n\n\t\t\t\t\tif (w <= W && h <= H) {\n\t\t\t\t\t\tP p1 = pos[i].first, p2 = pos[i].second;\n\t\t\t\t\t\tint x1 = p1.real(), y1 = p1.imag();\n\t\t\t\t\t\tint x2 = p2.real(), y2 = p2.imag();\n\t\t\t\t\t\tint posW = x2 - x1 + 1, posH = y2 - y1 + 1;\n\n\t\t\t\t\t\tif (w >= posW && h >= posH) {\n\t\t\t\t\t\t\tw -= posW, h -= posH;\n\t\t\t\t\t\t\tx1 = max(x1-w, 0),   y1 = max(y1-h, 0);\n\t\t\t\t\t\t\tx2 = min(x2+w+1, W), y2 = min(y2+h+1, H);\n\t\t\t\t\t\t\tdrawSet( P(x1, y1), P(x2, y2) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdrawDo();\n/*\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << draw[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}cout << endl;\n*/\n\t\t\t\tfor (int y = 0; y < H; ++y)\n\t\t\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\t\t\tif (draw[y][x])\n\t\t\t\t\t\t\tstate[y][x] |= 1 << i;\n\t\t\t}\n\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (!m[y][x] && state[y][x] && state[y][x] == (state[y][x] & -state[y][x])) {\n\t\t\t\t\t\tint b = 0;\n\t\t\t\t\t\tfor (int k = 1; k != state[y][x]; k *= 2, ++b);\n\n\t\t\t\t\t\tP p1 = pos[b].first, p2 = pos[b].second;\n\t\t\t\t\t\tint minX = p1.real(), minY = p1.imag();\n\t\t\t\t\t\tint maxX = p2.real(), maxY = p2.imag();\n\n\t\t\t\t\t\tminX = min(minX, x), minY = min(minY, y);\n\t\t\t\t\t\tmaxX = max(maxX, x), maxY = max(maxY, y);\n\n\t\t\t\t\t\tpos[b] = pair<P, P>( P(minX, minY), P(maxX, maxY) );\n\n\t\t\t\t\t\tfor (int Y = minY; Y <= maxY; ++Y) {\n\t\t\t\t\t\t\tfor (int X = minX; X <= maxX; ++X) {\n\t\t\t\t\t\t\t\tif (!m[Y][X]) {\n\t\t\t\t\t\t\t\t\t--count;\n\t\t\t\t\t\t\t\t\tm[Y][X] = b+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (count) cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << m[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n#define repD(i, n) for(int i = n; i >= 0; i--)\n\nint cnt;\nint field[100][100];\nint check[100][100];\nint res[100][100];\nbool used[20];\nint K[20];\nint X, Y, n;\n\nvoid solve(int y, int x){\n\tif(y == Y){\n\t\tbool ok = true;\n\t\trep(i, Y)rep(j, X) if(check[i][j] == 0) ok = false;\n\t\tassert(ok);\n\t\tif(ok){\n\t\t\tcnt++;\n\t\t\trep(i, Y)rep(j, X) res[i][j] = check[i][j];\n\t\t}\n\t\t\n\t}else{\n\t\tif(check[y][x] >= 0){\n\t\t\tif(x == X-1) solve(y+1, 0);\n\t\t\telse solve(y, x+1);\n\t\t}else{\n\t\t\tint dy = Y - y;\n\t\t\tint dx = X - x;\n\t\t\tbool ok;\n\t\t\tfor(int i = 1; i <= dy; i++){\n\t\t\t\tfor(int j = 1; j <= dx; j++){\n\t\t\t\t\tok = true;\n\t\t\t\t\tint id = -1;\n\t\t\t\t\trep(k, i){\n\t\t\t\t\t\trep(l, j){\n\t\t\t\t\t\t\tif(check[y+k][x+l] >= 0) ok = false;\n\t\t\t\t\t\t\tif(field[y+k][x+l] > 0){\n\t\t\t\t\t\t\t\tif(!used[field[y+k][x+l]] && (id == -1 || field[y+k][x+l] == id)){\n\t\t\t\t\t\t\t\t\tid = field[y+k][x+l];\n\t\t\t\t\t\t\t\t}else ok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok || id == -1 || K[id] != i * j) continue;\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = id;\n\t\t\t\t\tused[id] = true;\n\t\t\t\t\tsolve(y,x);\n\t\t\t\t\tused[id] = false;\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main(){\n\twhile(cin >> X >> Y >> n && (X || Y || n)){\n\t\n\t\trep(i, n){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tcin >> K[b];\n\t\t}\n\t\t\n\t\trep(i, Y)rep(j, X){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t\tmemset(check, -1, sizeof(check));\n\t\tmemset(used, false, sizeof(used));\n\n\t\tcnt = 0;\n\t\tsolve(0, 0);\n\t\tif(cnt != 1) cout << \"NA\" << endl;\n\t\telse{\n\t\t\tbool f = false;\n\t\t\trep(i, Y){\n\t\t\t\trep(j,X){\n\t\t\t\t\tif(j != 0) cout << \" \";\n\t\t\t\t\tcout << res[i][j];\n\t\t\t\t\tif(check[i][j] != -1) f = true;\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tassert(!f);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nint w, h, n;\nint T[SIZE][SIZE];\nint TC[SIZE][SIZE];\nint K[SIZE]; \nII U[SIZE]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[SIZE][SIZE];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n        \n        if ( cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint w, h;\nvector<int> area;\nvector<vector<int> > sum;\n\nint retNum;\nvector<string> ret;\n\nvoid solve(int y, int x, vector<string>& used)\n{\n    if(x > w){\n        ++ y;\n        x = 1;\n    }\n    if(y > h){\n        ++ retNum;\n        ret = used;\n        return;\n    }\n\n    if(used[y][x] != '0'){\n        solve(y, x+1, used);\n        return;\n    }\n\n    for(int y1=y; y1<=h; ++y1){\n        for(int x1=x; x1<=w; ++x1){\n            bitset<16> bs = sum[y1][x1] & (~sum[y1][x-1]) & (~sum[y-1][x1]);\n            if(bs.count() != 1)\n                continue;\n\n            int k = 0;\n            while(!bs[k])\n                ++ k;\n            if(area[k] != (y1 - y + 1) * (x1 - x + 1))\n                continue;\n\n            bool ng = false;\n            vector<string> used1 = used;\n            for(int i=y; i<=y1; ++i){\n                for(int j=x; j<=x1; ++j){\n                    if(used1[i][j] != '0')\n                        ng = true;\n                    used1[i][j] = k + '0';\n                }\n            }\n            if(!ng)\n                solve(y, x+1, used1);\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n\n        area.assign(n+1, 0);\n        for(int i=0; i<n; ++i){\n            int b, k;\n            cin >> b >> k;\n            area[b] = k;\n        }\n\n        sum.assign(h+1, vector<int>(w+1, 0));\n        for(int y=1; y<=h; ++y){\n            int tmp = 0;\n            for(int x=1; x<=w; ++x){\n                int a;\n                cin >> a;\n                if(a > 0)\n                    tmp |= (1 << a);\n                sum[y][x] = sum[y-1][x] | tmp;\n            }\n        }\n\n        if(accumulate(area.begin(), area.end(), 0) != h * w){\n            cout << \"NA\" << endl;\n            continue;\n        }\n\n        retNum = 0;\n        vector<string> s(h+1, string(w+1, '0'));\n        solve(1, 1, s);\n\n        if(retNum != 1){\n            cout << \"NA\" << endl;\n        }else{\n            for(int i=1; i<=h; ++i){\n                cout << ret[i][1];\n                for(int j=2; j<=w; ++j)\n                    cout << ' ' << ret[i][j];\n                cout << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint ans[10][10];\nint g[10][10];\nint y,x,n,b[15],k[15],py[15],px[15];\nbool flag,res;\n\nvoid rec(int a){\n  if(a==n){\n    if(flag)res = false;\n    else{\n      for(int i=0;i<y;i++)\n\tfor(int j=0;j<x;j++)ans[i][j] = g[i][j];\n      flag = true;\n    }\n  }else{\n    int ty = py[b[a]-1], tx = px[b[a]-1];\n    for(int h=1;h<=k[a];h++){\n      int w = k[a]/h;\n      if(h*w==k[a]){\n\tfor(int sy=0;sy<h;sy++)\n\t  for(int sx=0;sx<w;sx++){\n\t    bool f = true;\n\t    for(int i=0;i<h;i++)\n\t      for(int j=0;j<w;j++){\n\t\tif(ty-sy+i<0 || tx-sx+j<0 || y<=ty-sy+i || x<=tx-sx+j){\n\t\t  f = false;\n\t\t  break;\n\t\t}\n\t\tif(g[ty-sy+i][tx-sx+j] && g[ty-sy+i][tx-sx+j]!=b[a]){\n\t\t  f = false;\n\t\t  break;\n\t\t}\n\t\tif(!f)break;\n\t      }\n\t    if(f){\n\t      for(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)g[ty-sy+i][tx-sx+j] = b[a];\n\t      rec(a+1);\n\t      if(!res)return;\n\t      for(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)g[ty-sy+i][tx-sx+j] = 0;\n\t      g[py[b[a]-1]][px[b[a]-1]] = b[a];\n\t    }\n\t  }\n      }\n    }\n  }\n}\n\t\t\n\nint main(){\n  while(cin >> x >> y >> n && (x||y||n)){\n    for(int i=0;i<n;i++)cin >> b[i] >> k[i];\n    for(int i=0;i<y;i++)\n      for(int j=0;j<x;j++){\n\tcin >> g[i][j];\n\tif(g[i][j]){\n\t  py[g[i][j]-1] = i;\n\t  px[g[i][j]-1] = j;\n\t}\n      }\n\n    flag = false;\n    res = true;\n    rec(0);\n    if(flag && res){\n      for(int i=0;i<y;i++){\n\tfor(int j=0;j<x-1;j++)cout << ans[i][j] << \" \";\n\tcout << ans[i][x-1] << endl;\n      }\n    }else cout << \"NA\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <string>\n#include <map>\n#define FOR(i,b,a) for(int i=(b);i<=(a);i++)\n#define REP(i,a) for(int i=0;i<(a);i++)\nusing namespace std;\ntypedef pair<int,int> pr;\nconst int INF=1<<30;\nint maps[20][20],px[20],py[20];\nint ans[20][20],msize[20];\nint X,Y,n,b,k,counts=0;\nvoid search(int p){\n\tif(p==n+1){\n\t\tREP(i,20)\n\t\t\tREP(j,20)\n\t\t\t\tans[i][j]=maps[i][j];\n\t\tcounts++;\n\t\treturn ;\n\t}\n\n\tFOR(i,1,X){\n\t\tint x=i,y=msize[p]/i;\n\t\tif(x*y==msize[p]){\n\t\t\tFOR(j,max(1,py[p]-y+1),min(Y-y+1,py[p]))\n\t\t\t\tFOR(k,max(1,px[p]-x+1),min(X-x+1,px[p])){\n\t\t\t\t\tbool able=true;\n\t\t\t\t\tREP(ii,y)\n\t\t\t\t\t\tREP(jj,x)\n\t\t\t\t\t\t\tif(maps[ii+j][jj+k]!=p && maps[ii+j][jj+k]!=0)\n\t\t\t\t\t\t\t\table=false;\n\t\t\t\t\tif(able){\n\t\t\t\t\t\tREP(ii,y)\n\t\t\t\t\t\t\tREP(jj,x)\n\t\t\t\t\t\t\t\tmaps[ii+j][jj+k]=p;\n\t\t\t\t\t\t\t//\tcout << j << k << endl;\n\t\t\t\t\t\tsearch(p+1);\n\t\t\t\t\t\tREP(ii,y)\n\t\t\t\t\t\t\tREP(jj,x)\n\t\t\t\t\t\t\t\tmaps[ii+j][jj+k]=0;\n\t\t\t\t\t\tmaps[py[p]][px[p]]=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile(cin >> X >> Y >>n && X){\n\tcounts=0;\n\tFOR(i,1,n){\n\tcin >> b>>k;\n\tmsize[b]=k;\n\t}\n\tFOR(i,1,Y)\n\t\tFOR(j,1,X){\n\t\t\tcin >> maps[i][j];\n\t\t\tif(maps[i][j]){\n\t\t\t\tpx[maps[i][j]]=j;\n\t\t\t\tpy[maps[i][j]]=i;\n\t\t\t}\n\t\t\t\n\t\t}\n\tsearch(1);\n\tif(counts!=1)\n\t\tcout << \"NA\" << endl;\n\telse\n\t\tFOR(i,1,Y){\n\t\t\tFOR(j,1,X)\n\t\t\t\tif(j==X)\n\t\t\t\t\tcout <<ans[i][j];\n\t\t\t\telse\n\t\t\t\t\tcout <<ans[i][j]<<\" \";\n\t\t\tcout << endl;\n\t\t}\n\t// your code goes here\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int WH_SIZE = 11;\nconst int SIZE = 16;\nint w, h;\nint n; \nint K[SIZE]; \nint S[WH_SIZE][WH_SIZE];\nII T[11]; \nVVI M;\nVVI A;\nint cnt;\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int b;\n            cin >> b;\n            S[i][j] = b;\n            if ( b > 0 ) {\n                b --;\n                T[b] = II( i, j );\n            }\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << A[i][j];\n            if ( j + 1 < w ) cout << \" \";  \n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            int r1 = r0 + i;\n            int c1 = c0 + j;\n            if ( S[r1][c1] != k && S[r1][c1] != 0 ) return false;\n            if ( M[r1][c1] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            int r1 = r0 + i;\n            int c1 = c0 + j;\n            M[r1][c1] = k;\n        }\n    }\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        A = M;\n        cnt ++;\n        return;\n    }\n    \n    int r = T[depth].first;\n    int c = T[depth].second;\n    int k = K[depth];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( k % w0 != 0 ) continue;\n        int h0 = k / w0;\n        for ( int r0 = max( 0, r - h0 + 1 ); r0 + h0 - 1 < h; ++ r0 ) {\n            for ( int c0 = max( 0, c - w0 + 1 ); c0 + w0 - 1 < w; ++ c0 ) {\n                if ( ! ( r0 <= r && r <= r0 + h0 - 1 && c0 <= c && c <= c0 + w0 - 1 ) ) continue;\n                if ( ! canPut( depth + 1, r0, c0, w0, h0 ) ) continue;\n                put( depth + 1, r0, c0, w0, h0 );\n                solve( depth + 1 );\n                if ( cnt >= 2 ) return;\n                put( 0, r0, c0, w0, h0 );\n            }\n        }\n    }\n    \n    return;\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        M = VVI( h, VI( w, 0 ) );\n        input();\n        cnt = 0;\n        solve(0);\n        if ( cnt == 0 || cnt == 2 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint X, Y, n;\nint id[15], k[15];\nint sx[16], sy[16];\nint bd[10][10];\n\nvector<pair<int,int> > area[101];\nint ans[10][10];\n\nint dfs(int u) {\n\tif (u == n) {\n\t\tmemcpy(ans, bd, sizeof ans);\n\t\treturn 1;\n\t}\n\tint h, w, tx, ty, lx, rx, uy, dy;\n\ttx = sx[id[u]];\n\tty = sy[id[u]];\n\tbd[ty][tx] = 0;\n\tint ret = 0;\n\tfor (int i=0; i<(int)area[k[u]].size(); ++i) {\n\t\th = area[k[u]][i].first;\n\t\tw = area[k[u]][i].second;\n\t\tlx = max(tx-w+1, 0);\n\t\trx = min(tx+w-1, X-1);\n\t\tuy = max(ty-h+1, 0);\n\t\tdy = min(ty+h-1, Y-1);\n\t\tif (rx-lx+1 < w || dy-uy+1 < h) continue;\n\t\tfor (int y=uy; y+h-1<=dy; ++y) {\n\t\t\tfor (int x=lx; x+w-1<=rx; ++x) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int y2=y; y2<y+h && ok; ++y2) {\n\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\tif (bd[y2][x2] != 0) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tfor (int y2=y; y2<y+h; ++y2) {\n\t\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\t\tbd[y2][x2] = id[u];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += dfs(u+1);\n\t\t\t\t\tfor (int y2=y; y2<y+h; ++y2) {\n\t\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\t\tbd[y2][x2] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (2 <= ret) return 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbd[ty][tx] = id[u];\n\treturn ret;\n}\n\nint main() {\n\tfor (int i=1; i<=10; ++i) {\n\t\tfor (int j=1; j<=10; ++j) {\n\t\t\tarea[i*j].push_back(make_pair(i, j));\n\t\t}\n\t}\n\twhile (cin >> X >> Y >> n, X) {\n\t\tint sum = 0;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> id[i] >> k[i];\n\t\t\tsum += k[i];\n\t\t}\n\t\tfor (int i=0; i<Y; ++i) {\n\t\t\tfor (int j=0; j<X; ++j) {\n\t\t\t\tcin >> bd[i][j];\n\t\t\t\tif (bd[i][j] != 0) {\n\t\t\t\t\tsx[bd[i][j]] = j;\n\t\t\t\t\tsy[bd[i][j]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = dfs(0);\n\t\tif (X * Y != sum || res == 0 || 2 <= res) {\n\t\t\tcout << \"NA\\n\";\n\t\t} else {\n\t\t\tfor (int i=0; i<Y; ++i) {\n\t\t\t\tfor (int j=0; j<X; ++j) {\n\t\t\t\t\tcout << (j == 0 ? \"\" : \" \") << ans[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,n,land[50][50],test[50][50],ans[50][50];\n\nbool search(int i0,int j0){\n//printf(\"i0=%d, j0=%d\\n\",i0,j0);\n//for(int a=0;a<h;a++){for(int b=0;b<w;b++)printf(\"%d \",test[a][b]);puts(\"\");}puts(\"\");\n\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\nif(i<0 || h<=i || j<0 || w<=j)\twhile(1);\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\nif(id<0 || n<id)\tcontinue;\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tans[i][j]=test[i][j];}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);}\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint W, H, N; \nint b[16], k[16];\nint s[10][10];\nint ans[10][10];\nint used[10][10];\nint TX[20], TY[20];\nclass DFSError {};\nvoid dfs(int idx){\n  if(idx == N) {\n    if(ans[0][0] != -1) throw DFSError();\n    REP(y, H)REP(x, W) ans[y][x] = used[y][x];\n    return;\n  }\n  /*\n  printf(\"idx = %d\\n\", idx);\n  REP(y, H){\n    REP(x, W){\n      cout << used[y][x];\n      if(x != W - 1) cout << \" \";\n      else cout << endl;\n    }\n  }\n  */\n  int tx = TX[b[idx] - 1];\n  int ty = TY[b[idx] - 1];\n  //printf(\"idx = %d tx = %d ty = %d\\n\", idx, tx, ty);\n  \n  assert(idx < N);\n  assert(b[idx] >= 1 && b[idx] <= N);\n  assert(tx != -1);\n  for(int h = 1; h <= k[idx]; h++) if(k[idx] % h == 0){\n    int w = k[idx] / h;\n    for(int by = 0; by > -h; by--) for(int bx = 0; bx > -w; bx--){\n      int sx = tx + bx;\n      int sy = ty + by;\n      bool ok = true;\n      for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n        if(!valid(sx + x, sy + y, W, H) || used[sy + y][sx + x] != -1) ok = false;\n      }\n      if(ok){\n        int tmp[10][10];\n        memcpy(tmp, used, sizeof(used));\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n          used[sy + y][sx + x] = b[idx];\n        }\n        dfs(idx + 1);\n        memcpy(used, tmp, sizeof(used));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H >> N && (W | H | N)){\n    REP(i, N) cin >> b[i] >> k[i];\n    REP(y, H)REP(x, W) cin >> s[y][x];\n    try{\n      memset(used, -1, sizeof(used));\n      memset(ans, -1, sizeof(ans));\n      memset(TX, -1, sizeof(TX));\n      memset(TY, -1, sizeof(TY));\n      REP(y, H) REP(x, W) if(s[y][x] > 0) TX[s[y][x] - 1] = x, TY[s[y][x] - 1] = y;\n      REP(i, N)if(TX[i] == -1){\n        /*\n        cerr << W << \" \" << H << \" \" << N << endl;\n        REP(j, N) cerr << b[j] << \" \" << k[j] << endl;\n        REP(y, H) { REP(x, W) cerr << s[y][x] << \" \"; cerr << endl; }\n        assert(\"bord is dissapeared\" == \"\");\n        */\n        throw 0;\n      }\n      dfs(0);\n      if(ans[0][0] == -1) throw DFSError();\n      REP(y, H){\n        REP(x, W){\n          cout << ans[y][x];\n          if(x != W - 1) cout << \" \";\n          else cout << endl;\n        }\n      }\n    }catch(...){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair< pair<int,int>,pair<int,int> > NODE;\n#define NY first.first\n#define NX first.second\n#define SY second.first\n#define SX second.second\n\nint X,Y,n,ret;\nvector< vector<int> > solve;\nmap<int,vector<NODE> > able;\nvector< vector<int> > data(10,vector<int>(10));\nvector< vector<int> > none(10,vector<int>(10));\nvector< vector<int> > rec;\n\nvoid bt(int dp){\n\tif(ret>1)return;\n\tvector<vector<int> > tt = rec;\n\tbool flag;\n\tif(dp==n){\n\t\tflag = true;\n\t\trep(i,Y)rep(j,X)if(!rec[i][j])flag = false;\n\t\tif(flag){\n\t\t\tret++;\n\t\t\tsolve = rec;\n\t\t}\n\t\treturn;\n\t}\n\tmap<int,vector<NODE> >::iterator it = able.begin();\n\tfor(int i=0;i<dp;i++)it++;\n\t\n\tfor(int i=0;i<(*it).second.size();i++){\n\t\tflag = true;\n\t\trep(y,(*it).second[i].SY)rep(x,(*it).second[i].SX){\n\t\t\tif(rec[(*it).second[i].NY+y][(*it).second[i].NX+x])flag = false;\n\t\t\trec[(*it).second[i].NY+y][(*it).second[i].NX+x]=(*it).first;\n\t\t}\n\t\tif(flag)bt(dp+1);\n\t\trec = tt;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tmap<int,int> buy;\n\t\n\tint b,k;\n\tint name,cnt;\n\tpair<int,int> coord;\n\twhile(cin >> X >> Y >> n , X){\n\t\tret = 0;/*\trep(i,Y){\n\t\trep(j,X)cout << rec[i][j];\n\t\tcout << endl;\n\t}\n*/\n\t\table.clear();\n\t\tbuy.clear();\n\t\trep(i,Y)rep(j,X)data[i][j]=0;\n\t\trep(i,n){\n\t\t\tcin >> b >> k;\n\t\t\tbuy[b] = k;\n\t\t}\n\t\trep(i,Y)rep(j,X)cin >> data[i][j];\n\n\t\trep(i,Y)rep(j,X){\n\t\t\trep(y,Y)rep(x,X){\n\t\t\t\tif( j+x > X-1 || i+y > Y-1 )continue;\n\t\t\t\tcnt = 0;\n\t\t\t\trep(YY,i+1)rep(XX,j+1)\n\t\t\t\t\tif(data[y+YY][x+XX]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tname = data[y+YY][x+XX];\n\t\t\t\t\t\tcoord = make_pair(y,x);\n\t\t\t\t\t}\n\t\t\t\tif(cnt == 1 && (i+1)*(j+1) == buy[name] ){\n\t\t\t\t\table[name].push_back( make_pair(coord,make_pair(i+1,j+1)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tmap<int,vector<NODE> >::iterator it = able.begin();\n\t\twhile(it != able.end()){\n\t\t\tfor(int i=0;i<(*it).second.size();i++)\n\t\t\t\tcout << (*it).first << \"=\" << (*it).second[i].NX << \",\" << (*it).second[i].NY << \" -> \" << (*it).second[i].SX << \",\" << (*it).second[i].SY << endl;\n\t\t\t++it;\n\t\t}\n*/\n\t\trec = none;\n\t\tbt(0);\n\t\tif(ret==1){\n\t\t\trep(i,Y){\n\t\t\t\trep(j,X)cout << solve[i][j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n\nint h, w, n, ans[10][10];\nvector< Pii > memo;\n\nint wy, wx;\nvoid plus_n( int y, int x, int nt){\n  wy = y;\n  wx = ( x + nt ) % w;\n  if(!wx) wy++;\n  return ;\n}\n//なんでconstが値変わるの?(困惑)\nint dfs( const int mas[][10], const int used, const int y, const int x){\n  if( y == h){ //exit\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        ans[i][j] = mas[i][j];\n      }\n    }\n    return 1;\n  }\n  int ret = 0;\n  if( mas[y][x] != 0){\n    plus_n( y, x, 1);\n    ret += dfs( mas, used, wy, wx);\n  }else{\n    for(int bit = 0 ; bit < n ; bit++ ){\n      if( (used >> bit) & 1 ) continue; // もうやってある\n\n      for(int i = 1 ; i <= memo[bit].fr ; i++ ){ //高さ決定\n        if( memo[bit].fr % i != 0 ) continue; // 長方形無理\n        int height = i, width = memo[bit].fr / i;\n        if( y <= memo[bit].sc.fr && y > memo[bit].sc.fr - height &&\n            x <= memo[bit].sc.sc && x > memo[bit].sc.sc - width &&\n            y + height - 1 < h && x + width - 1 < w){\n          int java[10][10];\n          for(int j = 0 ; j < h ; j++ ){\n            for(int k = 0 ; k < w ; k++ ){\n              java[j][k] = mas[j][k];\n            }\n          }\n          bool ok = true;\n          for(int j = 0 ; j < height ; j++ ){\n            for(int k = 0 ; k < width ; k++ ){\n              if(java[j + y][k + x]) ok = false;\n              java[j + y][k + x] = bit + 1;\n            }\n          }\n          if(ok){\n            plus_n( y, x, width);\n            ret += dfs( java, used|(1<<bit), wy, wx);\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\nint main(){\n  while(cin >> w >> h >> n , w){\n    memo.resize( n);\n    for(int i = 0, bf ; i < n ; i++ ){\n      cin >> bf;\n      cin >> memo[bf - 1].fr;\n    }\n    for(int i = 0, c ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        cin >> c;\n        if(c)memo[c - 1].sc = Pi( i, j);\n      }\n    }\n    int mas[10][10] = {{}};\n    if(dfs( mas, 0, 0, 0) == 1){\n      for(int i = 0 ; i < h ; i++ ){\n        for(int j = 0 ; j < w ; j++ ){\n          cout << ( j ? \" \" : \"\" ) << ans[i][j];\n        }\n        cout << endl;\n      }\n    }else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid output2() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n\n    if ( r0 < 0 || c0 < 0 ) return false;\n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            if ( T[U[i].first][U[i].second] != i + 1 ) return;\n        }\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 - 1 ); r0 < min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 - 1 ); c0 < min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int WH_SIZE = 11;\nconst int SIZE = 16;\nint w, h;\nint n; \nint K[SIZE]; \nint S[WH_SIZE][WH_SIZE];\nII T[SIZE]; \nVVI M;\nVVI A;\nint cnt;\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int b;\n            cin >> b;\n            S[i][j] = b;\n            if ( b > 0 ) {\n                b --;\n                T[b] = II( i, j );\n            }\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << A[i][j];\n            if ( j + 1 < w ) cout << \" \";  \n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            int r1 = r0 + i;\n            int c1 = c0 + j;\n            if ( S[r1][c1] != k && S[r1][c1] != 0 ) return false;\n            if ( M[r1][c1] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            int r1 = r0 + i;\n            int c1 = c0 + j;\n            M[r1][c1] = k;\n        }\n    }\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        A = M;\n        cnt ++;\n        return;\n    }\n    \n    int r = T[depth].first;\n    int c = T[depth].second;\n    int k = K[depth];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( k % w0 != 0 ) continue;\n        int h0 = k / w0;\n        for ( int r0 = max( 0, r - h0 + 1 ); r0 + h0 - 1 < h; ++ r0 ) {\n            for ( int c0 = max( 0, c - w0 + 1 ); c0 + w0 - 1 < w; ++ c0 ) {\n                if ( ! ( r0 <= r && r <= r0 + h0 - 1 && c0 <= c && c <= c0 + w0 - 1 ) ) continue;\n                if ( ! canPut( depth + 1, r0, c0, w0, h0 ) ) continue;\n                put( depth + 1, r0, c0, w0, h0 );\n                solve( depth + 1 );\n                if ( cnt >= 2 ) return;\n                put( 0, r0, c0, w0, h0 );\n            }\n        }\n    }\n    \n    return;\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        M = VVI( h, VI( w, 0 ) );\n        input();\n        cnt = 0;\n        solve(0);\n        if ( cnt == 0 || cnt == 2 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a) = min((a), (b)))\n#define chmax(a, b) ((a) = max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint x, y, n;\nint ans;\nvector<vector<int>> fians(20, vector<int>(20));\nvector<vector<P>> divi(20);\nvector<P> larger;\n\nvoid dfs(int depth, vector<vector<int>> &s){\n    if(depth == n){\n        ans++;\n        fians = s;\n        return ;\n    }\n\n    if(1 < ans){\n        return ;\n    }\n\n    int K = larger[depth].first;\n    int B = larger[depth].second;\n\n    for(auto i:divi[B]){\n        int h = i.first;\n        int w = i.second;\n\n        for(int j=0; j+h-1<y; j++){\n            for(int k=0; k+w-1<x; k++){\n                int l = k;\n                int r = k + w - 1;\n                int u = j;\n                int d = j + h - 1;\n\n                bool exist = false;\n                bool valid = true;\n                auto cs = s;\n                for(int i1=u; i1<=d; i1++){\n                    for(int i2=l; i2<=r; i2++){\n                        if(cs[i1][i2] == B){\n                            exist = true;\n                        }\n                        else if(cs[i1][i2] != 0){\n                            valid = false;\n                            goto END;\n                        }\n                    }\n                }\n\n                END:;\n\n                if(exist && valid){\n                    for(int i1=u; i1<=d; i1++){\n                        for(int i2=l; i2<=r; i2++){\n                            cs[i1][i2] = B;\n                        }\n                    }\n\n                    dfs(depth + 1, cs);\n                }\n            }\n        }\n    }\n\n    return ;\n}\n\nint main(){\n    while(1){\n        ans = 0;\n        larger.clear();\n        for(int i=0; i<20; i++){\n            divi[i].clear();\n        }\n\n        cin>>x>>y>>n;\n        if(x == 0) return 0;\n        \n        int sum = 0;\n        for(int i=0; i<n; i++){\n            int b, k; cin>>b>>k;\n            larger.emplace_back(k, b);\n            sum += k;\n            set<P> st;\n            for(int j=1; j*j<=k; j++){\n                if(k % j == 0){\n                    st.emplace(j, k / j);\n                    st.emplace(k / j, j);\n                }\n            }\n\n            for(auto j:st){\n                divi[b].emplace_back(j.first, j.second);\n            }\n        }\n\n        sort(larger.begin(), larger.end(), greater<P>());\n\n        vector<vector<int>> s(y, vector<int>(x));\n        for(int i=0; i<y; i++){\n            for(int j=0; j<x; j++){\n                cin>>s[i][j];\n            }\n        }\n\n        if(x * y != sum){\n            cout << \"NA\" << endl;\n            continue;\n        }\n\n        dfs(0, s);\n\n        if(ans == 1){\n            for(int i=0; i<y; i++){\n                for(int j=0; j<x; j++){\n                    cout << fians[i][j] << \" \\n\"[j == x-1];\n                }\n            }\n        }\n        else{\n            cout << \"NA\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { int h,w,index; };\n\nint H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nint found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(i,H) rep(j,W) edge[i][j].clear();\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) edge[y][x].push_back((Data){hy,hx,b[i]});\n      Skip:;\n        \n      }\n    }\n  }\n  /*  \n      rep(i,H) rep(j,W) {\n      cout << \"(\" << j << \",\" << i << \") ::\" << endl;\n      rep(l,(int)edge[i][j].size()) cout << \"(\" << edge[i][j][l].w << \",\" << edge[i][j][l].h << \",\" << edge[i][j][l].index << \") \";\n      cout << endl;\n      }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      //assert( isValid(x+cx,y+cy) );\n      if( ans[y+cy][x+cx] != 0 ) {\n        goto Skip;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    rep(i,n) cin >> b[i] >> k[i];\n    rep(i,H) rep(j,W) cin >> s[i][j];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint W, H, N; \nint b[16], k[16];\nint s[10][10];\nint ans[10][10];\nint used[10][10];\nint TX[20], TY[20];\nclass DFSError {};\nvoid dfs(int idx){\n  if(idx == N) {\n    if(ans[0][0] != -1) throw DFSError();\n    REP(y, H)REP(x, W) ans[y][x] = used[y][x];\n    return;\n  }\n  /*\n  printf(\"idx = %d\\n\", idx);\n  REP(y, H){\n    REP(x, W){\n      cout << used[y][x];\n      if(x != W - 1) cout << \" \";\n      else cout << endl;\n    }\n  }\n  */\n  int tx = TX[b[idx]];\n  int ty = TY[b[idx]];\n  //printf(\"idx = %d tx = %d ty = %d\\n\", idx, tx, ty);\n  \n  assert(tx != -1);\n  for(int h = 1; h <= k[idx]; h++) if(k[idx] % h == 0){\n    int w = k[idx] / h;\n    for(int by = 0; by > -h; by--) for(int bx = 0; bx > -w; bx--){\n      int sx = tx + bx;\n      int sy = ty + by;\n      bool ok = true;\n      for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n        if(!valid(sx + x, sy + y, W, H) || used[sy + y][sx + x] != -1) ok = false;\n      }\n      if(ok){\n        int tmp[10][10];\n        memcpy(tmp, used, sizeof(used));\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n          used[sy + y][sx + x] = b[idx];\n        }\n        dfs(idx + 1);\n        memcpy(used, tmp, sizeof(used));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H >> N && W){\n    REP(i, N) cin >> b[i] >> k[i];\n    REP(y, H)REP(x, W) cin >> s[y][x];\n    try{\n      memset(used, -1, sizeof(used));\n      memset(ans, -1, sizeof(ans));\n      memset(TX, -1, sizeof(TX));\n      memset(TY, -1, sizeof(TY));\n      REP(y, H) REP(x, W) if(s[y][x] > 0) TX[s[y][x]] = x, TY[s[y][x]] = y;\n      dfs(0);\n      if(ans[0][0] == -1) throw DFSError();\n      REP(y, H){\n        REP(x, W){\n          cout << ans[y][x];\n          if(x != W - 1) cout << \" \";\n          else cout << endl;\n        }\n      }\n    }catch(...){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 21;\nint w, h, n;\nint T[SIZE][SIZE];\nint TC[SIZE][SIZE];\nint K[SIZE]; \nII U[SIZE]; \nint cnt;\nint SC[SIZE][SIZE];\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[SIZE][SIZE];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nqueue<pair<int, vector<vector<int> > > >Q;\nvector<vector<int>>X, P; int H, W, N, V1[20], V2[20];\npair<bool, vector<vector<int> > > hantei(vector<vector<int> >a1, int X1, int Y1, int H1, int W1, int N1) {\n\tbool OK = true; int G[30][30];\n\tfor (int i = 0; i < 900; i++)G[i / 30][i % 30] = 0;\n\tfor (int i = X1; i < X1 + H1; i++) {\n\t\tfor (int j = Y1; j < Y1 + W1; j++) {\n\t\t\tif (i >= H || j >= W) { OK = false; continue; }\n\t\t\tif (a1[i][j] != 0 || (X[i][j] != V1[N1] && X[i][j] >= 1))OK = false;\n\t\t\ta1[i][j] = V1[N1]; G[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (X[i][j] == V1[N1] && G[i][j] == 0)OK = false;\n\t\t}\n\t}\n\treturn make_pair(OK, a1);\n}\nint main() {\n\twhile (true) {\n\t\tX.clear(); P.clear(); H = 0; W = 0; N = 0;\n\t\tcin >> W >> H >> N; int D1 = 0; if (W == 0 && H == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; i++) { cin >> V1[i] >> V2[i]; D1 += V2[i]; }\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tvector<int>G, I; int a;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a; G.push_back(a); I.push_back(0);\n\t\t\t}\n\t\t\tX.push_back(G); P.push_back(I);\n\t\t}\n\t\tif (D1 != W*H) { cout << \"NA\" << endl; continue; }\n\t\tQ.push(make_pair(0, P)); vector<vector<int> >res; int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tvector<vector<int>>K = Q.front().second;\n\t\t\tint L = Q.front().first; Q.pop();\n\t\t\tif (Q.size() >= 10000) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\twhile (!Q.empty())Q.pop();\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (L == N) { cnt++; res = K; continue; }\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 1; k <= V2[L]; k++) {\n\t\t\t\t\t\tif (V2[L] % k != 0)continue;\n\t\t\t\t\t\tpair<bool, vector<vector<int> > >res1 = hantei(K, i, j, k, V2[L] / k, L);\n\t\t\t\t\t\tif (res1.first == true) {\n\t\t\t\t\t\t\tQ.push(make_pair(L + 1, res1.second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0 || cnt >= 2)cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (j >= 1) { cout << ' '; }cout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\tE:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Area;\n\nclass Solver {\n  public:\n    Area solve() {\n      Area area(x, Vec(y, 0));\n      vector<Area> answers;\n      for (int i = 0; i < y; ++i) {\n        for (int j = 0; j < x; ++j) {\n          area[j][i] = s[j][i];\n        }\n      }\n      search(area, answers);\n      if (answers.size() != 1) {\n        answers.resize(1);\n        answers[0].clear();\n      }\n      return answers[0];\n    }\n    int x, y, n;\n    int b[15], k[15];\n    int s[10][10];\n  private:\n    void print_area(Area &area) {\n      for (int i = 0; i < y; ++i) {\n        for (int j = 0; j < x; ++j) {\n          cerr << area[j][i] << \" \";\n        }\n        cerr << endl;\n      }\n      cerr << \"--------------------------------\" << endl;\n    }\n    void search(Area &area, vector<Area> &answers, int id = 0) {\n      //print_area(area);\n      if (id == n) {\n        answers.push_back(area);\n        return;\n      }\n      if (answers.size() > 1) {\n        return;\n      }\n      for (int yi = 0; yi < y; ++yi) {\n        for (int dy = 1; yi + dy <= y; ++dy) {\n          int dx = k[id] / dy;\n          if (k[id] % dy != 0) {\n            continue;\n          }\n          for (int xi = 0; xi + dx <= x; ++xi) {\n            bool is_valid = true;\n            for (int i = yi; i < yi + dy and is_valid; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                if (area[j][i] != 0 and area[j][i] != b[id]) {\n                  is_valid = false;\n                  break;\n                }\n              }\n            }\n            if (not is_valid) {\n              continue;\n            }\n            for (int i = yi; i < yi + dy; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                area[j][i] = b[id];\n              }\n            }\n            search(area, answers, id + 1);\n            for (int i = yi; i < yi + dy; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                area[j][i] = s[j][i];\n              }\n            }\n          }\n        }\n      }\n    }\n};\n\nint main() {\n  Solver s;\n  Area answer;\n  while (true) {\n    cin >> s.x >> s.y >> s.n;\n    for (int i = 0; i < s.n; ++i) {\n      cin >> s.b[i] >> s.k[i];\n    }\n    for (int i = 0; i < s.y; ++i) {\n      for (int j = 0; j < s.x; ++j) {\n        cin >> s.s[j][i];\n      }\n    }\n    answer = s.solve();\n    if (answer.size() == 0) {\n      cout << \"NA\" << endl;\n    } else {\n      for (int i = 0; i < s.y; ++i) {\n        for (int j = 0; j < s.x; ++j) {\n          cout << answer[j][i];\n          if (j < s.x - 1) {\n            cout << \" \";\n          } else {\n            cout << endl;\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nint T[11][11];\nint TC[11][11];\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[11][11];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[k] % w0 != 0 ) continue;\n        int h0 = K[k] / w0;\n        for ( int r0 = 0; r0 < h; ++ r0 ) {\n            for ( int c0 = 0; c0 < w; ++ c0 ) {\n                if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                    for ( int i = 0; i < h; ++ i ) {\n                        for ( int j = 0; j < w; ++ j ) {\n                            T[i][j] = Tcopy[i][j];\n                        }\n                    }\n                    if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                    if ( cnt >= 2 ) return;\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nvoid output1() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Area;\n\nclass Solver {\n  public:\n    Area solve() {\n      Area area(x, Vec(y, 0));\n      vector<Area> answers;\n      for (int i = 0; i < y; ++i) {\n        for (int j = 0; j < x; ++j) {\n          area[j][i] = s[j][i];\n        }\n      }\n      search(area, answers);\n      if (answers.size() != 1) {\n        answers.resize(1);\n        answers[0].clear();\n      }\n      return answers[0];\n    }\n    int x, y, n;\n    int b[15], k[15];\n    int s[10][10];\n  private:\n    void print_area(Area &area) {\n      for (int i = 0; i < y; ++i) {\n        for (int j = 0; j < x; ++j) {\n          cerr << area[j][i] << \" \";\n        }\n        cerr << endl;\n      }\n      cerr << \"--------------------------------\" << endl;\n    }\n    void search(Area &area, vector<Area> &answers, int id = 0) {\n      //print_area(area);\n      if (id == n) {\n        answers.push_back(area);\n        return;\n      }\n      for (int yi = 0; yi < y; ++yi) {\n        for (int dy = 1; yi + dy <= y; ++dy) {\n          int dx = k[id] / dy;\n          if (k[id] % dy != 0) {\n            continue;\n          }\n          for (int xi = 0; xi + dx <= x; ++xi) {\n            bool is_valid = true;\n            bool has_found = false;\n            for (int i = yi; i < yi + dy and is_valid; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                if (area[j][i] != 0 and area[j][i] != b[id]) {\n                  is_valid = false;\n                  break;\n                }\n                if (area[j][i] == b[id]) {\n                  has_found = true;\n                }\n              }\n            }\n            if ((not is_valid) or (not has_found)) {\n              continue;\n            }\n            for (int i = yi; i < yi + dy; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                area[j][i] = b[id];\n              }\n            }\n            search(area, answers, id + 1);\n            if (answers.size() > 1) {\n              return;\n            }\n            for (int i = yi; i < yi + dy; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                area[j][i] = s[j][i];\n              }\n            }\n          }\n        }\n      }\n    }\n};\n\nint main() {\n  Solver s;\n  Area answer;\n  while (true) {\n    cin >> s.x >> s.y >> s.n;\n    for (int i = 0; i < s.n; ++i) {\n      cin >> s.b[i] >> s.k[i];\n    }\n    for (int i = 0; i < s.y; ++i) {\n      for (int j = 0; j < s.x; ++j) {\n        cin >> s.s[j][i];\n      }\n    }\n    answer = s.solve();\n    if (answer.size() == 0) {\n      cout << \"NA\" << endl;\n    } else {\n      for (int i = 0; i < s.y; ++i) {\n        for (int j = 0; j < s.x; ++j) {\n          cout << answer[j][i];\n          if (j < s.x - 1) {\n            cout << \" \";\n          } else {\n            cout << endl;\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint X,Y,n;\nint b[15],k[15],s[10][10];\nint sx[15],sy[15],ans[10][10];\nbool ansFlg;\n\nbool isAns(void){\n\trep(i,Y) rep(j,X) if(s[i][j] == 0) return false;\n\treturn true;\n}\n\nbool settable(int y,int x,int h,int w){\n\tREP(i,y,y+h) REP(j,x,x+w) if(s[i][j]!=0) return false;\n\treturn true;\n}\n\nvoid setLand(int y,int x,int h,int w,int val){\n\tREP(i,y,y+h) REP(j,x,x+w) s[i][j] = val;\n}\n\nbool solve(int idx){\n\tif(idx == -1){\n\t\tif(isAns()){\n\t\t\tif(ansFlg) return true;\n\t\t\tansFlg = true;\n\t\t\tmemcpy(ans,s,sizeof(s));\n\t\t}\n\t\treturn false;\n\t}\n\n\tREP(h,1,k[idx]+1){\n\t\tif(k[idx] % h != 0) continue;\n\t\tint w = k[idx] / h;\n\n\t\tREP(i,sy[idx]-h+1,sy[idx]+1){\n\t\t\tREP(j,sx[idx]-w+1,sx[idx]+1){\n\t\t\t\tif(i<0 || j<0 || i+h>Y || j+w>X) continue;\n\n\t\t\t\ts[sy[idx]][sx[idx]] = 0;\n\t\t\t\tif(settable(i,j,h,w)){\n\t\t\t\t\tsetLand(i,j,h,w,idx+1);\n\t\t\t\t\tif(solve(idx-1)) return true;\n\t\t\t\t\tsetLand(i,j,h,w,0);\n\t\t\t\t}\n\t\t\t\ts[sy[idx]][sx[idx]] = idx+1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main(void){\n\twhile(cin>>X>>Y>>n && (X||Y||n)){\n\t\trep(i,n) cin>>b[i]>>k[i];\n\t\trep(i,Y) rep(j,X){\n\t\t\tcin>>s[i][j];\n\t\t\tif(s[i][j] != 0){\n\t\t\t\tsx[s[i][j]-1] = j;\n\t\t\t\tsy[s[i][j]-1] = i;\n\t\t\t}\n\t\t}\n\n\t\tansFlg = false;\n\n\t\tif(!solve(n-1) && ansFlg){\n\t\t\trep(i,Y){\n\t\t\t\trep(j,X-1) cout<<ans[i][j]<<\" \";\n\t\t\t\tcout<<ans[i][X-1]<<endl;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint stage_w,stage_h,total_buyers;\nint ans[50][50];\n\nvoid disp(int stage[50][50]){\n  for(int y = 0; y < stage_h; y++){\n    for(int x = 0; x < stage_w; x++){\n      printf(\"%d%s\",stage[y][x], x == stage_w - 1 ? \"\" : \" \");\n    }\n    printf(\"\\n\");\n  }\n}\n\nbool check(int stage[50][50]){\n  for(int y = 0; y < stage_h; y++){\n    for(int x = 0; x < stage_w; x++){\n      if(stage[y][x] == 0) return false;\n    }\n  }\n  memcpy(ans,stage,sizeof(int)*50*50);\n  return true;\n}\n\nint dfs(int id,int areas[50],P occupied[50],int stage[50][50]){\n  if(id > total_buyers){\n    return check(stage) ? 1 : 0;\n  }\n\n  int res = 0;\n  for(int w = 1; w <= areas[id]; w++){\n    int h = areas[id] / w;\n    if(h * w != areas[id]) continue;\n    int cx = occupied[id].first;\n    int cy = occupied[id].second;\n\n    for(int lx = cx - w + 1; lx <= cx; lx++){\n      if(lx < 0) continue;\n\n      int rx = lx + w - 1;\n\n      if(rx >= stage_w) continue;\n      for(int ly = cy - h + 1; ly <= cy; ly++){\n        if(ly < 0) continue;\n\n        int ry = ly + h - 1;\n        if(ry >= stage_h) continue;\n\n        int prev[50][50];\n        memcpy(prev,stage,sizeof(int)*50*50);\n        for(int x = lx; x <= rx; x++){\n          for(int y = ly; y <= ry; y++){\n            if(stage[y][x] == 0){\n              stage[y][x] = id;\n            }\n            else if(stage[y][x] != id){\n              goto fail;\n            }\n          }\n        }\n        res += dfs(id + 1,areas,occupied,stage);\n      fail:;\n        memcpy(stage,prev,sizeof(int)*50*50);\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d %d\",&stage_w,&stage_h,&total_buyers)){\n    if(stage_w == 0 && stage_h == 0) break;\n\n    int stage[50][50];\n    int areas[50];\n    for(int buyer_i = 0; buyer_i < total_buyers; buyer_i++){\n      int id;\n      int area;\n      scanf(\"%d %d\",&id,&area);\n      areas[id] = area;\n    }\n\n    P occupied[50];\n    for(int y = 0; y < stage_h; y++){\n      for(int x = 0; x < stage_w; x++){\n        scanf(\"%d\",&stage[y][x]);\n        if(stage[y][x] != 0){\n          occupied[stage[y][x]] = P(x,y);\n        }\n      }\n    }\n\n    if(dfs(1,areas,occupied,stage) == 1){\n      disp(ans);\n    }\n    else{\n      printf(\"NA\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint n,w,h;\nint a[15],b[15],c[15],f[10][10];\nint fn(int d[][10],int p){\n  int i,j,k,l,m;\n  int ct=0;\n  if(p==n){\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(d[j][i]==0)\n\t  break;\n      }\n      if(j!=w)\n\tbreak;\n    }\n    if(i==h){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++)\n\t  f[j][i]=d[j][i];\n      }\n      ct=1;\n    }\n  }else{\n    for(i=1;i<a[p]+1;i++){\n      if(a[p]%i==0){\n\tfor(j=0;j<i;j++){\n\t  if(b[p]-j>-1&&b[p]+i-j-1<w){\n\t    for(k=0;k<a[p]/i;k++){\n\t      if(c[p]-k>-1&&c[p]+a[p]/i-k-1<h){\n\t\tfor(l=0;l<i;l++){\n\t\t  for(m=0;m<a[p]/i;m++){\n\t\t    if(d[b[p]-j+l][c[p]-k+m])\n\t\t      break;\n\t\t  }\n\t\t  if(m!=a[p]/i)\n\t\t    break;\n\t\t}\n\t\tif(l==i){\n\t\t  int e[10][10];\n\t\t  memcpy(e,d,sizeof(e));\n\t\t  for(l=0;l<i;l++)\n\t\t    for(m=0;m<a[p]/i;m++)\n\t\t      e[b[p]-j+l][c[p]-k+m]=p+1;\n\t\t  ct+=fn(e,p+1);\n\t\t  if(ct>1)\n\t\t    return ct;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return ct;\n}\nint main(){\n  int i,j;\n  while(cin>>w>>h>>n&&w+h+n){\n    for(i=0;i<n;i++){\n      int p,q;\n      cin>>p>>q;\n      p--;\n      a[p]=q;\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tint p;\n\tcin>>p;\n\tif(p){\n\t  p--;\n\t  b[p]=j;\n\t  c[p]=i;\n\t}\n      }\n    }\n    int d[10][10];\n    memset(d,0,sizeof(d));\n    if(fn(d,0)==1){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w-1;j++)\n\t  cout<<f[j][i]<<\" \";\n\tcout<<f[j][i]<<endl;\n      }\n    }else\n      cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstruct State{int x[12][12];};\nint H,W,n,b[20],p[20];State S,ans;\nint area(State V,int q){\n\tint mx=100000,my=100000,nx=-1,ny=-1;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(V.x[i][j]!=q)continue;\n\t\t\tmx=min(mx,i);my=min(my,j);nx=max(nx,i);ny=max(ny,j);\n\t\t}\n\t}\n\tfor(int i=mx;i<=nx;i++){\n\t\tfor(int j=my;j<=ny;j++){\n\t\t\tif(V.x[i][j]!=q && V.x[i][j]!=0)return 99999999;\n\t\t}\n\t}\n\treturn (nx-mx+1)*(ny-my+1);\n}\nint solve(State T,int r1,int r2){\n\tif(r2==W){r1++;r2=0;}\n\tif(r1==H){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(area(T,i)!=p[i])return 0;\n\t\t}\n\t\tans=T;return 1;\n\t}\n\tif(T.x[r1][r2]>=1){return solve(T,r1,r2+1);}\n\telse{\n\t\tint ret=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tState U=T;U.x[r1][r2]=i;\n\t\t\tif(area(U,i)>p[i])continue;\n\t\t\tret+=solve(U,r1,r2+1);\n\t\t}\n\t\treturn ret;\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H>>n;if(n==0)break;\n\t\tfor(int i=0;i<n;i++){cin>>b[i];cin>>p[b[i]];}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++)cin>>S.x[i][j];\n\t\t}\n\t\tint ret=solve(S,0,0);\n\t\tif(ret==1){\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(j)cout<<' ';cout<<ans.x[i][j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint x,y,n;\nint a[16];\nint g[10][10];\n\nint dfs(int (*c)[10],bool (*u)[10]){\n  /*\n    for(int i=0;i<y;i++){\n    for(int j=0;j<x;j++){\n      cout<<c[i][j];\n    }\n    cout<<endl;\n  }\n  cout<<\"---\"<<endl;\n  */\n  int s=0;\n  for(int i=0;i<y;i++){\n    for(int j=0;j<x;j++){\n      if(u[i][j]==false){\n\tfor(int h=0;i+h<y;h++){\n\t  int cn=0,ci;\n\t  for(int w=0;j+w<x;w++){\n\t    for(int ch=0;ch<=h;ch++){\n\t      if(c[i+ch][j+w]){\n\t\tcn++;\n\t\tci=c[i+ch][j+w];\n\t      }\n\t    }\n\t    if(cn==1){\n\t      if((h+1)*(w+1)==a[ci]){\n\t\tint n[10][10];\n\t\tcopy(c[0],c[10],n[0]);\n\t\tbool nu[10][10];\n\t\tcopy(u[0],u[10],nu[0]);\n\t\tfor(int ii=i;ii<i+h+1;ii++){\n\t\t  for(int jj=j;jj<j+w+1;jj++){\n\t\t    n[ii][jj]=ci;\n\t\t    nu[ii][jj]=true;\n\t\t  }\n\t\t}\n\t\ts+=dfs(n,nu);\n\t\tbreak;\n\t      }\n\t    }\n\t    if(cn>1){\n\t      break;\n\t    }\n\t  }\n\t}\n\treturn s;\n      }\n    }\n  }\n  copy(c[0],c[10],g[0]);\n  return 1;\n}\n\t      \n\t    \n\nint main(){\n  while(cin>>x>>y>>n,x|y|n){\n    for(int i=0;i<n;i++){\n      int b,k;\n      cin>>b>>k;\n      a[b]=k;\n    }\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tcin>>g[i][j];\n      }\n    }\n    int c[10][10];\n    copy(g[0],g[10],c[0]);\n    bool u[10][10]={};\n    if(dfs(c,u)==1){\n      for(int i=0;i<y;i++){\n\tfor(int j=0;j<x;j++){\n\t  cout<<g[i][j]<<((j==x-1)?'\\n':' ');\n\t}\n      }\n    }else{\n      cout<<\"NA\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\n\n\nint field[10][10];\nint ans[10][10];\nint kukaku[15];\nP start[15];\nint X,Y,n;\n\nvoid copy_field(){\n    for(int i=0;i<Y;i++){\n        for(int j=0;j<X;j++){\n            ans[i][j] = field[i][j];\n        }\n    }\n}\n\nvoid print_field(){\n    for(int i=0;i<Y;i++){\n        for(int j=0;j<X;j++){\n            printf(\"%d\",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint  dfs(int n_i){\n    if(n_i == n){\n        copy_field();\n        return 1;\n    }\n    int p = 0;\n    for(int tate=1;tate<=kukaku[n_i];tate++){\n        if (kukaku[n_i]%tate)continue;\n        int yoko = kukaku[n_i] / tate;\n        //printf(\"tate=%d yoko=%d\\n\",tate,yoko);\n        for(int y=start[n_i].first-tate+1; y<=start[n_i].first; y++){\n            for(int x=start[n_i].second-yoko+1; x<=start[n_i].second; x++){\n                //printf(\"n_i=%d x=%d y=%d\\n\",n_i,x,y);\n                if(!(0<=y&&y+tate-1<Y&&0<=x&&x+yoko-1<X)) continue;\n                bool can_paint = true;\n                for(int i=0;i<tate;i++){\n                    for(int j=0;j<yoko;j++){\n                        if(field[y+i][x+j]==0||field[y+i][x+j]==n_i+1){\n                            field[y+i][x+j] = n_i+1;\n                        }else{\n                            can_paint = false;\n                            break;\n                        }\n                    }\n                }\n                //printf(\"can_paint=%d\\n\",can_paint);\n                if(can_paint){\n                    p += dfs(n_i+1);\n                    if(p>1) return p;\n                }\n                for(int i=0;i<tate;i++){\n                    for(int j=0;j<yoko;j++){\n                        if(field[y+i][x+j]==n_i+1){\n                            field[y+i][x+j] = 0;\n                        }\n                    }\n                }\n                field[start[n_i].first][start[n_i].second] = n_i+1;\n            }\n        }\n    }\n    return p;\n}\n\n\nint main(){\n    while(1){\n        scanf(\"%d%d%d\",&X,&Y,&n);\n        if(!X)break;\n\n        for(int i=0;i<n;i++){\n            int d;\n            scanf(\"%d\",&d);\n            scanf(\"%d\",&kukaku[d-1]);\n        }\n\n        for(int i=0;i<Y;i++){\n            for(int j=0;j<X;j++){\n                scanf(\"%d\",&field[i][j]);\n                if(field[i][j]>0){\n                    start[field[i][j]-1] = P(i,j);\n                }\n            }\n        }\n        if(dfs(0)==1){\n            print_field();\n        }else{\n            printf(\"NA\\n\");\n        }\n\n        //break;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint w[15];\nint b[15];\nint m[10][10];\nint rev[16];\nint res[10][10];\nint ans[10][10];\nvector<int> div0[15];\nbool found;\nbool ok;\nint x,y,n;\nint xx[15];\nint yy[15];\n\nvoid solve(int c){\n  /*\n  printf(\"solve(%d): b=%d w=%d\\n\",c,b[c],w[c]);\n  REP(i,y) { REP(j,x) printf(\"%d \",res[i][j]); puts(\"\"); } puts(\"\");\n  REP(i,y) { REP(j,x) printf(\"%d \",m[i][j]); puts(\"\"); } puts(\"\");\n  */\n\n  if(c == n)\n    if(found){\n      ok = false;\n      return;\n    }else{\n      found = true;\n      ok = true;\n      REP(i,y) REP(j,x) ans[i][j] = res[i][j];\n      return;\n    }\n\n  FOR(it,div0[c]){\n    int width  = *it;\n    int height = w[c] / width;\n\n    int xxx = xx[c];\n    int yyy = yy[c];\n\n    for(int i = -height + 1; i < height; i++){\n      for(int j = -width + 1; j < width; j++){\n        if(xxx - j < 0 || yyy - i < 0) continue;\n        int XX = xxx - j + width - 1;\n        int YY = yyy - i + height - 1;\n        if(XX >= x || YY >= y) continue;\n        //printf(\"X=%d, Y=%d, (%d,%d)\\n\",xxx-j,yyy-i,i,j);\n        REP(ii,height) REP(jj,width){\n          int X = xxx - j + jj;\n          int Y = yyy - i + ii;\n\n          if(res[Y][X] == 0 && (m[Y][X] == 0 || m[Y][X] == c+1)){\n            res[Y][X] = c + 1;\n          }else{\n            REP(iii,ii+1) REP(jjj,width)\n              if(res[yyy-i+iii][xxx-j+jjj] == c+1)\n                res[yyy-i+iii][xxx-j+jjj] = 0;\n            j+=(width - jj - 1);\n            goto next;\n          }\n        }\n        solve(c+1);\n        REP(ii,height) REP(jj,width){\n          int X = xxx - j + jj;\n          int Y = yyy - i + ii;\n          res[Y][X] = 0;\n        }\n        //printf(\"solve(%d)(backed): b=%d w=%d (%d,%d)\\n\",c,b[c],w[c],i,j);\n        if(found && !ok) return;\n      next:;\n        continue;\n      }\n    }\n  }\n}\n\nint main(){\n  while(true){\n    x = getInt();\n    y = getInt();\n    n = getInt();\n\n    if(x + y + n == 0) break;\n\n    REP(i,n){\n      b[i] = getInt();\n      rev[b[i]] = i+1;\n      w[i] = getInt();\n\n      div0[i] = vector<int>();\n      rep(j,1,w[i]+1) if(w[i] % j == 0)\n        div0[i].push_back(j);\n    }\n\n    REP(i,y) REP(j,x){\n      m[i][j] = getInt();\n      if(m[i][j]){\n        m[i][j] = rev[m[i][j]];\n        yy[m[i][j]-1] = i;\n        xx[m[i][j]-1] = j;\n      }\n    }\n\n    found = false;\n    solve(0);\n\n    if(found && ok)\n      REP(i,y) REP(j,x){\n        int t = ans[i][j];\n        if(t != 0) t = b[t-1];\n        printf(\"%d%c\",ans[i][j],(j==x-1?'\\n':' '));\n      }\n    else\n      puts(\"NA\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n#define PUT 0\n#define REMOVE 1\n#define CHECK_PLANE 2\n\nint cnt;\nint m[10][10];\nint ans[10][10];\n\nbool is_origin[10][10];\nbool make_rect(int now,int x,int y,int width,int height,int flag,\n\t       int r,int c){\n  rep(i,height){\n    rep(j,width){\n      if ( flag == PUT )m[y+i][j+x]=now;\n      else if ( flag == REMOVE && is_origin[y+i][x+j] == false){\n\tm[y+i][j+x]=0;\n      }else if (flag == CHECK_PLANE){\n\tif ( m[y+i][j+x]!=0 && m[y+i][j+x]!=now)return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid solve(int num,int now,int *number,int *x,int *y,int *size,int r,int c){\n  if ( now == num){\n    cnt++;\n    rep(i,r)rep(j,c)ans[i][j]=m[i][j];\n    return;\n  }\n\n  if ( cnt > 1)return;\n  \n  int cur=number[now];\n  REP(k,1,size[now]+1 && cnt <2){\n    if ( size[now]%k != 0)continue;\n    int h=k,w=size[now]/k;\n    int hstart=max(0,y[now]-h+1),wstart=max(0,x[now]-w+1);\n    REP(i,hstart,y[now]+1 && i+h <=r && cnt < 2){\n      REP(j,wstart,x[now]+1 && j+w <=c && cnt < 2){\n\tif ( make_rect(cur,j,i,w,h,CHECK_PLANE,r,c) ){\n\t  make_rect(cur,j,i,w,h,PUT,r,c);\n\t  solve(num,now+1,number,x,y,size,r,c);\n\t  make_rect(cur,j,i,w,h,REMOVE,r,c);\n\t}\n      }\n    }\n  }\n}\n\n\nmain(){\n  int c,r,n;\n  while(cin>>c>>r>>n && c){\n    pair<int,int> in[n];\n    int x[n],y[n],size[n],tmp[100+1],num[100+1];\n    rep(i,n)cin>>in[i].second>>in[i].first;\n    sort(in,in+n,greater<pair<int,int> >());\n    rep(i,n)tmp[in[i].second]=i,size[i]=in[i].first,num[i]=in[i].second;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif ( m[i][j] != 0){\n\t  x[tmp[m[i][j]]]=j;\n\t  y[tmp[m[i][j]]]=i;\n\t  is_origin[i][j]=true;\n\t}\n\tis_origin[i][j]=false;\n      }\n    }\n    cnt = 0;\n\n    solve(n,0,num,x,y,size,r,c);\n    if ( cnt == 1){\n      rep(i,r){\n\trep(j,c){\n\t  if ( j)cout << ' ';\n\t  cout <<ans[i][j];\n\t}\n\tcout << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntemplate<class T>\nostream& operator<<(ostream& os,const vector<T>& a)\n{\n\tos<<'[';\n\trep(i,a.size())\n\t\tos<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool canput(vvi& grid,int x,int y,int bw,int bh,int index)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(x<0 || w<x+bw || y<0 || h<y+bh)\n\t\treturn false;\n\tbool flg=false;\n\trep(i,bh) rep(j,bw){\n\t\tint cell=grid[y+i][x+j];\n\t\tif(cell!=-1 && cell!=index)\n\t\t\treturn false;\n\t\tflg|=cell==index;\n\t}\n\treturn flg;\n}\n\nvoid put(vvi& grid,int x,int y,int bw,int bh,int index)\n{\n\trep(i,bh) rep(j,bw)\n\t\tgrid[y+i][x+j]=index;\n}\n\nvvi res;\nint solve(vvi& grid,const vi& bs,const vi& ks,const vector<pii>& ps,int index)\n{\n\tif(index==bs.size()){\n\t\tif(res.empty())\n\t\t\tres=grid;\n\t\treturn 1;\n\t}\n\t\n\tint x=ps[index].first,y=ps[index].second;\n\tint area=ks[index];\n\tint res=0;\n\trepi(bh,1,area+1) if(area%bh==0){\n\t\tint bw=area/bh;\n\t\trep(i,bh) rep(j,bw){\n\t\t\tint left=x-j,top=y-i;\n\t\t\tif(canput(grid,left,top,bw,bh,index)){\n\t\t\t\tput(grid,left,top,bw,bh,index);\n\t\t\t\tres+=solve(grid,bs,ks,ps,index+1);\n\t\t\t\tput(grid,left,top,bw,bh,-1);\n\t\t\t\tgrid[y][x]=index;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,h,n;cin>>w>>h>>n,w|h|n;){\n\t\tvi bs(n),ks(n);\n\t\trep(i,n) cin>>bs[i]>>ks[i];\n\t\t\n\t\tvvi grid(h,vi(w));\n\t\trep(i,h) rep(j,w) cin>>grid[i][j];\n\t\t\n\t\tif(accumulate(all(ks),0)!=w*h){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<pii> ps(n);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]==0)\n\t\t\t\tgrid[i][j]=-1;\n\t\t\telse{\n\t\t\t\tgrid[i][j]=find(all(bs),grid[i][j])-bs.begin();\n\t\t\t\tps[grid[i][j]]=mp(j,i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tres.clear();\n\t\tint cnt=solve(grid,bs,ks,ps,0);\n\t\tif(cnt!=1)\n\t\t\tcout<<\"NA\"<<endl;\n\t\telse\n\t\t\trep(i,h) rep(j,w)\n\t\t\t\tcout<<bs[res[i][j]]<<(j==w-1?'\\n':' ');\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct sqe {\n\tint n,w[5],h[5];\n };\n \n struct block {\n\t int n,f[100],x[100],y[100],w[100],h[100];\n };\n  \n sqe sq[101];\n block bl[15];\n \n int t,b[15],x,y,n,m[10][10],m2[10][10],m3[10][10],m4[15],an[10][10];\n \n void makebl(int s,int x1,int y1) {\n\t int i,j,k,w2,h2;\n\t bl[s].n=0;\n\t for (i=0;i<100;i++) bl[s].f[i]=0;\n\t for (i=0;i<sq[b[s]].n;i++) {\n\t\t for (j=y1-sq[b[s]].h[i]+1;j<=y1;j++) {\n\t\t\t if (j<0 || j+sq[b[s]].h[i]>y) continue;\n\t\t\t for (k=x1-sq[b[s]].w[i]+1;k<=x1;k++) {\n\t\t\t\t if (k<0 || k+sq[b[s]].w[i]>x) continue;\n\t\t\t\t for (h2=j;h2<=j+sq[b[s]].h[i]-1;h2++)\n\t\t\t\t     for (w2=k;w2<=k+sq[b[s]].w[i]-1;w2++) if (m[h2][w2]!=0 && m[h2][w2]!=s+1) {h2=w2=99;} \n\t\t\t\t     if (h2<99) { bl[s].x[bl[s].n]=k; bl[s].y[bl[s].n]=j;\n\t\t\t\t                  bl[s].w[bl[s].n]=sq[b[s]].w[i]; bl[s].h[bl[s].n]=sq[b[s]].h[i]; bl[s].n++;}\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n    }\n    \nvoid setflg() {\n\tint i,j,k,x1,y1;\n\tfor (i=0;i<n;i++) {\n\t\tm4[i]=0;\n\t\tfor (j=0;j<bl[i].n;j++) {\n             for (y1=bl[i].y[j];y1<=bl[i].y[j]+bl[i].h[j]-1;y1++) { \n                  for(x1=bl[i].x[j];x1<=bl[i].x[j]+bl[i].w[j]-1;x1++) m2[y1][x1]=m2[y1][x1] | (1 << i);\n\t\t\t  }\n\t      }\n\t   }\n\t for (y1=0;y1<y;y1++) for (x1=0;x1<x;x1++) for (i=0;i<n;i++) if (m2[y1][x1]==(1 << i)) m4[i]++;\n\t  for (i=0;i<n;i++) {\n\t\t for (j=0;j<bl[i].n;j++) {\n\t\t\t  k=0;\n\t\t\t  for (y1=bl[i].y[j];y1<=bl[i].y[j]+bl[i].h[j]-1;y1++)\n\t\t\t\tfor(x1=bl[i].x[j];x1<=bl[i].x[j]+bl[i].w[j]-1;x1++) if (m2[y1][x1]==(1 << i)) k++;\n\t\t\t\tif (k!=m4[i]) bl[i].f[j]=1;\n\t\t\t}\n\t\t}\n\t}  \t     \n\nint ans(int n1) {\n\tint i,j,x1,y1;\n\tif (n1==n) { t++;\n\t\tif (t==1) { for (i=0;i<y;i++) for (j=0;j<x;j++) an[i][j]=m3[i][j];} else return 1;\n\t\treturn 0;}  \n\tfor (i=0;i<bl[n1].n;i++) {\n\t\tif (bl[n1].f[i]==1) continue;\n\t\t\n\t\t for (y1=bl[n1].y[i];y1<=bl[n1].y[i]+bl[n1].h[i]-1;y1++) \n\t\t \t  for (x1=bl[n1].x[i];x1<=bl[n1].x[i]+bl[n1].w[i]-1;x1++) if (m3[y1][x1]!=0) x1=y1=99;\n\t\t \t  \n\t\t \t  if (x1<99) {\n\t\t\t\t for (y1=bl[n1].y[i];y1<=bl[n1].y[i]+bl[n1].h[i]-1;y1++) \n\t\t \t     for (x1=bl[n1].x[i];x1<=bl[n1].x[i]+bl[n1].w[i]-1;x1++) m3[y1][x1]=n1+1;\n\t\t \t     if (ans(n1+1)==1) return 1;\n\t\t \t     for (y1=bl[n1].y[i];y1<=bl[n1].y[i]+bl[n1].h[i]-1;y1++) \n\t\t \t     for (x1=bl[n1].x[i];x1<=bl[n1].x[i]+bl[n1].w[i]-1;x1++) m3[y1][x1]=0;\n\t\t\t }\n\t\t\t \n\t\t }\n\t\t return 0;\n\t }\n\t \n int main() {\n\t int i,j,g,k;\n\t for (i=0;i<101;i++) sq[i].n=0;\n\t for (i=1;i<11;i++) for (j=1;j<11;j++) { sq[i*j].w[sq[i*j].n]=j; sq[i*j].h[sq[i*j].n]=i; sq[i*j].n++;}\n\t while(cin >> x >> y >> n && n>0) {\n\t\t t=0;\n\t\t for (i=0;i<n;i++) { cin >> g >> k; b[g-1]=k; t+=k; }\n\t\t for (i=0;i<y;i++) for (j=0;j<x;j++) cin >> m[i][j];\n\t\t for (i=0;i<y;i++) for (j=0;j<x;j++) { if (m[i][j]!=0) makebl(m[i][j]-1,j,i); m2[i][j]=m3[i][j]=0; }\n\t\t if (t!=i*j) { cout << \"NA\" << endl; continue;}\n\t\t t=0;\n\t\t setflg();\n\t\t ans(0);\n\t\t if (t!=1) cout << \"NA\" << endl;\n\t\t else { \t\t \n\t\t for (i=0;i<y;i++) {\n\t\t\t for (j=0;j<x;j++) { cout << an[i][j]; if (j<x-1) cout << ' ';} \n\t\t\t cout << endl;\n\t\t      }\n\t\t  }\n\t\t}\n\t\t\t \n\t return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\nvector< vector<int> > draw; int drawTimes;\nvoid drawInit(int W, int H) {\n\t++W, ++H;\n\n\tdrawTimes = 0;\n\tdraw.resize(H);\n\tfor (int i = 0; i < H; ++i) draw[i].resize(W);\n\n\tfor (int y = 0; y < H; ++y)\n\t\tfor (int x = 0; x < W; ++x)\n\t\t\tdraw[y][x] = 0;\n}\nvoid drawSet(P p1, P p2) {\n\t++drawTimes;\n\n\tdraw[p1.imag()][p1.real()] += 1;\n\tdraw[p1.imag()][p2.real()] += -1;\n\tdraw[p2.imag()][p1.real()] += -1;\n\tdraw[p2.imag()][p2.real()] += 1;\n}\nvoid drawDo() {\n\tfor (int y = 0; y < draw.size(); ++y)\n\t\tfor (int x = 0; x < draw[0].size()-1; ++x)\n\t\t\tdraw[y][x+1] += draw[y][x];\n\n\tfor (int x = 0; x < draw[0].size(); ++x)\n\t\tfor (int y = 0; y < draw.size()-1; ++y)\n\t\t\tdraw[y+1][x] += draw[y][x];\n}\n\nint main() {\n\tint W, H, n;\n\twhile (cin >> W >> H >> n, W || H || n) {\n\t\tvector<int> block(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint b, k; cin >> b >> k;\n\t\t\tblock[b-1] = k;\n\t\t}\n\n\t\tvector< vector<int> > m(H, vector<int>(W));\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tvector< vector<int> > df(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 1; j*j <= block[i]; ++j) {\n\t\t\t\tif (block[i] % j == 0) {\n\t\t\t\t\tdf[i].push_back( j );\n\t\t\t\t\tif (j != block[i] / j) df[i].push_back( block[i] / j );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector< pair<P, P> > pos(n);\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tif (m[y][x])\n\t\t\t\t\tpos[m[y][x]-1] = pair<P, P>( P(x, y), P(x, y) );\n\n\t\tfor (int t = 0; t < W*H; ++t) {\n\t\t\tvector< vector<int> > state(H, vector<int>(W, 0));\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tdrawInit(W, H);\n\t\t\t\tfor (int j = 0; j < df[i].size(); ++j) {\n\t\t\t\t\tint w = df[i][j], h = block[i] / df[i][j];\n\n\t\t\t\t\tif (w <= W && h <= H) {\n\t\t\t\t\t\tP p1 = pos[i].first, p2 = pos[i].second;\n\t\t\t\t\t\tint x1 = p1.real(), y1 = p1.imag();\n\t\t\t\t\t\tint x2 = p2.real(), y2 = p2.imag();\n\t\t\t\t\t\tint posW = x2 - x1 + 1, posH = y2 - y1 + 1;\n\n\t\t\t\t\t\tif (w >= posW && h >= posH) {\n\t\t\t\t\t\t\tw -= posW, h -= posH;\n\t\t\t\t\t\t\tx1 = max(x1-w, 0),   y1 = max(y1-h, 0);\n\t\t\t\t\t\t\tx2 = min(x2+w+1, W), y2 = min(y2+h+1, H);\n\t\t\t\t\t\t\tdrawSet( P(x1, y1), P(x2, y2) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdrawDo();\n/*\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << draw[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}cout << endl;\n*/\n\t\t\t\tint cnt = 0, fx = -1, fy = -1, lx = -1, ly = -1;\n\t\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\t\tif (draw[y][x]) {\n\t\t\t\t\t\t\tif (fx == -1) fx = x, fy = y;\n\t\t\t\t\t\t\tlx = x, ly = y;\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\tstate[y][x] |= 1 << i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt == block[i]) {\n\t\t\t\t\tfor (int y = 0; y < H; ++y)\n\t\t\t\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\t\t\t\tif (draw[y][x]) state[y][x] = i+1;\n\n\t\t\t\t\tpos[i] = pair<P, P>( P(fx, fy), P(lx, ly) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (!m[y][x] && state[y][x] && state[y][x] == (state[y][x] & -state[y][x])) {\n\t\t\t\t\t\tint b = 0;\n\t\t\t\t\t\tfor (int k = 1; k != state[y][x]; k *= 2, ++b);\n\n\t\t\t\t\t\tP p1 = pos[b].first, p2 = pos[b].second;\n\t\t\t\t\t\tint minX = p1.real(), minY = p1.imag();\n\t\t\t\t\t\tint maxX = p2.real(), maxY = p2.imag();\n\n\t\t\t\t\t\tminX = min(minX, x), minY = min(minY, y);\n\t\t\t\t\t\tmaxX = max(maxX, x), maxY = max(maxY, y);\n\n\t\t\t\t\t\tpos[b] = pair<P, P>( P(minX, minY), P(maxX, maxY) );\n\n\t\t\t\t\t\tfor (int Y = minY; Y <= maxY; ++Y)\n\t\t\t\t\t\t\tfor (int X = minX; X <= maxX; ++X)\n\t\t\t\t\t\t\t\tm[Y][X] = b+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tif (m[y][x] == 0) flag = false;\n\n\t\tif (!flag) cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << m[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { int h,w,index; };\n\nint H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nint found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(i,H) rep(j,W) edge[i][j].clear();\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) edge[y][x].push_back((Data){hy,hx,b[i]});\n      Skip:;\n        \n      }\n    }\n  }\n  /*  \n      rep(i,H) rep(j,W) {\n      cout << \"(\" << j << \",\" << i << \") ::\" << endl;\n      rep(l,(int)edge[i][j].size()) cout << \"(\" << edge[i][j][l].w << \",\" << edge[i][j][l].h << \",\" << edge[i][j][l].index << \") \";\n      cout << endl;\n      }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n  if( cy >= H ) while(1);\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      //assert( isValid(x+cx,y+cy) );\n      if( ans[y+cy][x+cx] != 0 ) {\n        goto Skip;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint X, Y, n;\n\nstruct Memo\n{\n\tint b;\n\tint k;\n};\n\nstruct Point\n{\n\tint x;\n\tint y;\n};\n\nstruct Node\n{\n\tint idx;\n\tint a[10][10];\n};\n\nclass memo_greater\n{\npublic:\n\tbool operator() (const Memo m1, const Memo m2)\n\t{\n\t\treturn m1.k > m2.k;\n\t}\n};\n\nPoint P[15];\nMemo M[15];\nint A[10][10];\n\nbool is_able(int a[10][10], int x, int y, int w, int h, int idx)\n{\n\tfor(int j=y; j<y+h; j++)\n\t{\n\t\tfor(int i=x; i<x+w; i++)\n\t\t{\n\t\t\tif(i<0 || j<0 || i>=X || j>=Y) return false;\n\t\t\tif(a[j][i]!=0 && a[j][i]!=idx) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid set(int a[10][10], int x, int y, int w, int h, int idx)\n{\n\tfor(int j=y; j<y+h; j++)\n\t{\n\t\tfor(int i=x; i<x+w; i++)\n\t\t{\n\t\t\ta[j][i] = idx;\n\t\t}\n\t}\n}\n\nbool is_ans()\n{\n\tfor(int y=0; y<Y; y++)\n\t{\n\t\tfor(int x=0; x<X; x++)\n\t\t{\n\t\t\tif(A[y][x]==0)\n\t\t\t{\n\t\t\t\treturn false;\t\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool solve()\n{\n\tqueue<Node> que;\n\tint b, k, i, j, mem_size;\n\tPoint p;\n\n\tbool is_ok;\n\tmem_size = sizeof(int) * 100;\n\tsort(&M[0], &M[n-1], memo_greater());\n\tNode nn;\n\tnn.idx = 0;\n\tmemcpy(nn.a, A, mem_size);\n\n\tque.push(nn);\n\n\tis_ok = false;\n\twhile(!que.empty())\n\t{\n\t\tnn = que.front();\n\t\tque.pop();\n\n\t\tif(nn.idx==n)\n\t\t{\n\t\t\tif(!is_ok)\n\t\t\t{\n\t\t\t\tmemcpy(A, nn.a, mem_size);\n\t\t\t\tis_ok = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tb = M[nn.idx].b;\n\t\tk = M[nn.idx].k;\n\t\tp = P[b-1];\n\n\t\tfor(i=1; i<=k; i++)\n\t\t{\n\t\t\tif(k%i!=0) continue;\n\n\t\t\tj = k / i;\n\t\t\tfor(int dy=0; dy<j; dy++)\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<i; dx++)\n\t\t\t\t{\n\t\t\t\t\tif(is_able(nn.a, p.x-dx, p.y-dy, i, j, b))\n\t\t\t\t\t{\n\t\t\t\t\t\tNode node;\n\t\t\t\t\t\tmemcpy(node.a, nn.a, mem_size);\n\t\t\t\t\t\tset(node.a, p.x-dx, p.y-dy, i, j, b);\n\t\t\t\t\t\tnode.idx = nn.idx+1;\n\t\t\t\t\t\tque.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(int argc, char** argv)\n{\n\twhile( 1 )\n\t{\n\t\tcin >> X >> Y >> n;\n\t\tif(!(X || Y || n)) break;\n\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> M[i].b >> M[i].k;\n\t\t}\n\n\t\tfor(int y=0; y<Y; y++)\n\t\t{\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t{\n\t\t\t\tcin >> A[y][x];\n\t\t\t\tif(A[y][x] != 0)\n\t\t\t\t{\n\t\t\t\t\tP[A[y][x]-1].x = x;\n\t\t\t\t\tP[A[y][x]-1].y = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(solve())\n\t\t{\t\n\t\t\tfor(int y=0; y<Y; y++)\n\t\t\t{\n\t\t\t\tfor(int x=0; x<X; x++)\n\t\t\t\t{\n\t\t\t\t\tcout << A[y][x];\n\t\t\t\t\tif(x!=X-1) cout << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\nbool use[16];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j] && !use[ok[y][x][i][j]]) {\n\t\t\t\tuse[ok[y][x][i][j]] = true;\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t\tuse[ok[y][x][i][j]] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n\t\tfor(int i = 0; i < 16; i++)\n\t\t\tuse[i] = false;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = 0; y < Y && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = 0; x < X && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt != 1) ok[i][j][k][l] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < v.size(); i++) sum += v[i];\n\t\tif(res == 1 && sum == X*Y) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n \nint h, w, n, ans[10][10];\nvector< Pii > memo;\n \nint wy, wx;\nvoid plus_n( int y, int x, int nt){\n  wy = y;\n  wx = ( x + nt ) % w;\n  if(!wx) wy++;\n  return ;\n}\n\nint dfs( const int mas[][10], const int used, const int y, const int x){\n  if( y == h){ //exit\n    memcpy( ans, mas, sizeof(int)*100);\n    return 1;\n  }\n  int ret = 0;\n  if( mas[y][x] != 0){\n    plus_n( y, x, 1);\n    ret += dfs( mas, used, wy, wx);\n  }else{\n    for(int bit = 0 ; bit < n ; bit++ ){\n      if( (used >> bit) & 1 ) continue; // もうやってある\n \n      for(int i = 1 ; i <= memo[bit].fr ; i++ ){ //高さ決定\n        if( memo[bit].fr % i != 0 ) continue; // 長方形無理\n        int height = i, width = memo[bit].fr / i;\n \n        if( y <= memo[bit].sc.fr && y > memo[bit].sc.fr - height &&\n            x <= memo[bit].sc.sc && x > memo[bit].sc.sc - width &&\n            y + height - 1 < h && x + width - 1 < w){\n          int java[10][10];\n          bool ok = true;\n          memcpy( java, mas, sizeof(int)*100);\n          for(int j = 0 ; j < height ; j++ ){\n            for(int k = 0 ; k < width ; k++ ){\n              if(java[j + y][k + x]) ok = false;\n              java[j + y][k + x] = bit + 1;\n            }\n          }\n          if(ok){\n            plus_n( y, x, width);\n            ret += dfs( java, used|(1<<bit), wy, wx);\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\nint main(){\n  while(cin >> w >> h >> n , w){\n    memo.resize( n);\n    for(int i = 0, bf ; i < n ; i++ ){\n      cin >> bf;\n      cin >> memo[bf - 1].fr;\n    }\n    for(int i = 0, c ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        cin >> c;\n        if(c)memo[c - 1].sc = Pi( i, j);\n      }\n    }\n    int mas[10][10] = {{}};\n    if(dfs( mas, 0, 0, 0) == 1){\n      for(int i = 0 ; i < h ; i++ ){\n        for(int j = 0 ; j < w ; j++ ){\n          cout << ( j ? \" \" : \"\" ) << ans[i][j];\n        }\n        cout << endl;\n      }\n    }else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define MAX 10\n\nstruct Cell{ int i, j, x, id; };\n\nint H, W, n, b, k; \nCell P[MAX*MAX], M[MAX][MAX], A[MAX][MAX];\nint V[MAX+1];\n\nint ans;\n\nbool check(int si, int sj, int r, int c ){\n    rep(i, r) rep(j, c){\n\tint ii = si + i;\n\tint jj = sj + j;\n\tif ( ii < 0 || jj < 0 || ii >= H || jj >= W ) return false;\n\tif ( M[ii][jj].x ) return false;\n    }\n    return true;\n}\n\nvoid solve(int pos){\n    if ( pos >= n ){ \n\trep(i, H) rep(j, W) if ( M[i][j].x == 0 ) return;\n\trep(i, H) rep(j, W) A[i][j] = M[i][j];\n\tans++;\n\treturn;\n    }\n\n    for(int r = 1; r <= P[pos].x; r++){\n\tif ( P[pos].x % r != 0 ) continue;\n\tint c = P[pos].x / r;\n\trep(di, r) rep(dj, c){\n\t    int si = P[pos].i - di;\n\t    int sj = P[pos].j - dj;\n\t    if ( check( si, sj,  r, c ) ){\n\t\trep(i, r) rep(j, c) M[si+i][sj+j] = P[pos];\n\t\tsolve( pos + 1 );\n\t\trep(i, r) rep(j, c) M[si+i][sj+j].x = 0;\n\t    }\n\t}\n    }\n}\n\nint main(){\n    int x;\n    while( cin >> W >> H && H && W ){\n\tcin >> n;\n\trep(i, n){\n\t    cin >> b >> k;\n\t    P[b-1].x = k;\n\t}\n\n\trep(i, H) rep(j, W){\n\t    cin >> x;\n\t    if ( x ){  P[x-1].i = i; P[x-1].j = j; P[x-1].id = x-1; }\n\t    M[i][j].x = 0;\n\t}\n\tans = 0;\n\tsolve(0);\n\tif ( ans == 1 ) {\n\t    rep(i, H){\n\t\trep(j, W){\n\t\t    if ( j ) cout << \" \";\n\t\t    cout << A[i][j].id+1;\n\t\t}\n\t\tcout << endl;\n\t    }\n\t} else {\n\t    cout << \"NA\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nconst int MAX_NUM = 16;\nint w, h, n;\nint T[SIZE][SIZE];\nint TC[SIZE][SIZE];\nint K[MAX_NUM]; \nII U[MAX_NUM]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[SIZE][SIZE];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nvoid output1() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(i,H) rep(j,W) edge[i][j].clear();\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) edge[y][x].push_back((Data){hy,hx,b[i]});\n      Skip:;\n        \n      }\n    }\n  }\n  /*  \n      rep(i,H) rep(j,W) {\n      cout << \"(\" << j << \",\" << i << \") ::\" << endl;\n      rep(l,(int)edge[i][j].size()) cout << \"(\" << edge[i][j][l].w << \",\" << edge[i][j][l].h << \",\" << edge[i][j][l].index << \") \";\n      cout << endl;\n      }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n  if( cy >= H ) while(1);\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      //assert( isValid(x+cx,y+cy) );\n      if( ans[y+cy][x+cx] != 0 ) {\n        goto Skip;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n  /*\n  rep(y,H) rep(x,W) {\n    cout << \"(\" << x  << \",\" << y << \") ---- \" << endl;\n    rep(i,(int)edge[y][x].size()){\n      cout << \"(\" << edge[y][x][i].w << \",\" << edge[y][x][i].h << \",\" << edge[y][x][i].index << \") \";\n      cout << endl;\n    }\n      cout << endl;\n      cout << endl;\n  }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n  /*\n  cout << cx << \",\" << cy << endl;\n  rep(i,H) {\n    rep(j,W) cout << ans[i][j] << \" \";\n    cout << endl;\n  }\n    cout << endl;\n  */\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip2;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip2;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip2:;\n\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) if( ans[cy+y][cx+x] == index ) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { \n      rep(j,W) {\n        if( j ) cout << \" \";\n        cout << buf[i][j]; \n      } \n      cout << endl; \n    }\n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    rep(i,H) rep(j,W) cin >> s[i][j];\n    if( sum != H*W ) { puts(\"NA\"); continue; }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[15],b[15],c[15],d[10][10],f[10][10],n,w,h;\nint fn(int p){\n  int i,j,k,l,m;\n  int ct=0;\n  if(p==n){\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(d[j][i]==0)\n\t  break;\n      }\n      if(j!=w)\n\tbreak;\n    }\n    if(i==h){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++)\n\t  f[j][i]=d[j][i];\n      }\n      ct=1;\n    }\n  }else{\n    for(i=1;i<a[p]+1;i++){\n      if(a[p]%i==0){\n\tfor(j=0;j<i;j++){\n\t  if(b[p]-j>-1&&b[p]+i-j-1<w){\n\t    for(k=0;k<a[p]/i;k++){\n\t      if(c[p]-k>-1&&c[p]+a[p]/i-k-1<h){\n\t\tfor(l=0;l<i;l++){\n\t\t  for(m=0;m<a[p]/i;m++){\n\t\t    if(d[b[p]-j+l][c[p]-k+m])\n\t\t      break;\n\t\t  }\n\t\t  if(m!=a[p]/i)\n\t\t    break;\n\t\t}\n\t\tif(l==i){\n\t\t  for(l=0;l<i;l++)\n\t\t    for(m=0;m<a[p]/i;m++)\n\t\t      d[b[p]-j+l][c[p]-k+m]=p+1;\n\t\t  ct+=fn(p+1);\n\t\t  for(l=0;l<i;l++)\n\t\t    for(m=0;m<a[p]/i;m++)\n\t\t      d[b[p]-j+l][c[p]-k+m]=0;\n\t\t  if(ct>1)\n\t\t    return ct;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return ct;\n}\nint main(){\n  int i,j;\n  while(cin>>w>>h>>n&&w+h+n){\n    for(i=0;i<n;i++){\n      int p,q;\n      cin>>p>>q;\n      p--;\n      a[p]=q;\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tint p;\n\tcin>>p;\n\tif(p){\n\t  p--;\n\t  b[p]=j;\n\t  c[p]=i;\n\t}\n      }\n    }\n    memset(d,0,sizeof(d));\n    if(fn(0)==1){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w-1;j++)\n\t  cout<<f[j][i]<<\" \";\n\tcout<<f[j][i]<<endl;\n      }\n    }else\n      cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-8;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nint w, h, n;\npint info[16];\nint land[10][10], ans_land[10][10];\npint sign_pos[16];\n\nbool can_put(int left, int top, int width, int height, int b)\n{\n\tint right = left + width - 1;\n\tint bottom = top + height - 1;\n\tif (right >= w || bottom >= h)\n\t\treturn false;\n\n\tfor (int y = top; y <= bottom; ++y)\n\t\tfor (int x = left; x <= right; ++x)\n\t\t\tif (land[y][x] != 0 && land[y][x] != b)\n\t\t\t\treturn false;\n\treturn true;\n}\nvoid put(int left, int top, int width, int height, int b)\n{\n\tint right = left + width - 1;\n\tint bottom = top + height - 1;\n\n\tfor (int y = top; y <= bottom; ++y)\n\t\tfor (int x = left; x <= right; ++x)\n\t\t\tland[y][x] = b;\n}\nbool ok()\n{\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tif (land[y][x] == 0)\n\t\t\t\treturn false;\n\treturn true;\n}\nint dfs(int depth)\n{\n\tif (depth == n)\n\t{\n\t\tif (ok())\n\t\t{\n\t\t\tmemcpy(ans_land, land, sizeof(ans_land));\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tint res = 0;\n\n\tint b = info[depth].first;\n\tint k = info[depth].second;\n\tfor (int height = 1; height <= k; ++height)\n\t{\n\t\tif (k % height)\n\t\t\tcontinue;\n\t\tint width = k / height;\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tif (can_put(x, y, width, height, b))\n\t\t\t\t{\n\t\t\t\t\tput(x, y, width, height, b);\n\t\t\t\t\tres += dfs(depth + 1);\n\t\t\t\t\tput(x, y, width, height, 0);\n\t\t\t\t\tland[sign_pos[b].second][sign_pos[b].first] = b;\n\n\t\t\t\t\tif (res > 1)\n\t\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\nint main()\n{\n\twhile (scanf(\"%d%d%d\", &w, &h, &n), w|h|n)\n\t{\n\t\tmemset(info, 0, sizeof(info));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint b, k;\n\t\t\tscanf(\"%d%d\", &b, &k);\n\t\t\tinfo[i] = pint(b, k);\n\t\t}\n\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tscanf(\"%d\", &land[y][x]);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tif (land[y][x])\n\t\t\t\t\tsign_pos[land[y][x]] = pint(x, y);\n\n\t\tif (dfs(0) == 1)\n\t\t{\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w-1; ++x)\n\t\t\t\t\tprintf(\"%d \", ans_land[y][x]);\n\t\t\t\tprintf(\"%d\\n\", ans_land[y][w-1]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,n,land[50][50],test[50][50],ans[50][50];\n\nbool search(int i0,int j0){\n//printf(\"i0=%d, j0=%d\\n\",i0,j0);\n//for(int a=0;a<h;a++){for(int b=0;b<w;b++)printf(\"%d \",test[a][b]);puts(\"\");}puts(\"\");\n\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\nif(i<0 || h<=i || j<0 || w<=j)\texit(0);\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\nif(id<0 || n<id)\twhile(1)puts(\"@@@@@@\");\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tans[i][j]=test[i][j];}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);}\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\nbool flag = false;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid output2() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n\n    if ( r0 < 0 || c0 < 0 ) return false;\n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            if ( T[U[i].first][U[i].second] != i + 1 ) return;\n        }\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 + 1 ); r0 < min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 + 1 ); c0 < min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s - 1 >= n ) {\n                flag = true;\n                return;\n            }\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        flag = false;\n        init();\n        input();\n        if ( flag ) {\n            cout << \"NA\" << endl;\n            continue;\n        }\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { int h,w,index; };\n\nint H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nint found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(i,H) rep(j,W) edge[i][j].clear();\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) edge[y][x].push_back((Data){hy,hx,b[i]});\n      Skip:;\n        \n      }\n    }\n  }\n  /*  \n      rep(i,H) rep(j,W) {\n      cout << \"(\" << j << \",\" << i << \") ::\" << endl;\n      rep(l,(int)edge[i][j].size()) cout << \"(\" << edge[i][j][l].w << \",\" << edge[i][j][l].h << \",\" << edge[i][j][l].index << \") \";\n      cout << endl;\n      }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cx == W-1 && cy == H-1 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      //assert( isValid(x+cx,y+cy) );\n      if( ans[y+cy][x+cx] != 0 ) {\n        goto Skip;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    rep(i,n) cin >> b[i] >> k[i];\n    rep(i,H) rep(j,W) cin >> s[i][j];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n#define PUT 0\n#define REMOVE 1\n#define CHECK_PLANE 2\n\nint cnt;\nint m[10][10];\nint ans[10][10];\n\nbool is_origin[10][10];\nbool make_rect(int now,int x,int y,int width,int height,int flag,\n\t       int r,int c){\n  rep(i,height){\n    rep(j,width){\n      if ( flag == PUT )m[y+i][j+x]=now;\n      else if ( flag == REMOVE && is_origin[y+i][x+j] == false){\n\tm[y+i][j+x]=0;\n      }else if (flag == CHECK_PLANE){\n\tif ( m[y+i][j+x]!=0 && m[y+i][j+x]!=now)return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid solve(int num,int now,int *number,int *x,int *y,int *size,int r,int c){\n  if ( now == num){\n    cnt++;\n    rep(i,r)rep(j,c)ans[i][j]=m[i][j];\n    return;\n  }\n\n  if ( cnt > 1)return;\n  \n  int cur=number[now];\n  REP(k,1,size[now]+1){\n    if ( size[now]%k != 0)continue;\n    int h=k,w=size[now]/k;\n    int hstart=max(0,y[now]-h+1),wstart=max(0,x[now]-w+1);\n    REP(i,hstart,y[now]+1 && i+h <=r){\n      REP(j,wstart,x[now]+1 && j+w <=c){\n\tif ( make_rect(cur,j,i,w,h,CHECK_PLANE,r,c) ){\n\t  make_rect(cur,j,i,w,h,PUT,r,c);\n\t  solve(num,now+1,number,x,y,size,r,c);\n\t  make_rect(cur,j,i,w,h,REMOVE,r,c);\n\t}\n      }\n    }\n  }\n}\n\n\nmain(){\n  int c,r,n;\n  while(cin>>c>>r>>n && c){\n    pair<int,int> in[n];\n    int x[n],y[n],size[n],tmp[100+1],num[100+1];\n    rep(i,n)cin>>in[i].second>>in[i].first;\n    sort(in,in+n,greater<pair<int,int> >());\n    rep(i,n)tmp[in[i].second]=i,size[i]=in[i].first,num[i]=in[i].second;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif ( m[i][j] != 0){\n\t  x[tmp[m[i][j]]]=j;\n\t  y[tmp[m[i][j]]]=i;\n\t  is_origin[i][j]=true;\n\t}\n\tis_origin[i][j]=false;\n      }\n    }\n    cnt = 0;\n\n    solve(n,0,num,x,y,size,r,c);\n    if ( cnt == 1){\n      rep(i,r){\n\trep(j,c){\n\t  if ( j)cout << ' ';\n\t  cout <<ans[i][j];\n\t}\n\tcout << endl;\n      }\n    }else cout << \"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\nusing namespace std;\n\nint X, Y, n;\nvector<vector<int>> s;\nvector<vector<int>> answer;\nvector<int> area;\n\n// id, 左上, 右下\nbool placeable(vector<vector<int>> field, int id, int y1, int x1, int y2, int x2) {\n    bool ok = false;\n    for(int i = y1; i <= y2; ++i) for(int j = x1; j <= x2; ++j) {\n        if(field[i][j] && field[i][j] != id) return false;\n        if(field[i][j] == id) ok = true;\n    }\n    return ok;\n}\nvector<vector<int>> place(vector<vector<int>> field, int id, int y1, int x1, int y2, int x2) {\n    for(int i = y1; i <= y2; ++i) for(int j = x1; j <= x2; ++j) field[i][j] = id;\n    return field;\n}\n\nbool in(int y, int x) {\n    return 0 <= y && y < Y && 0 <= x && x < X;\n}\n\nint dfs(vector<vector<int>> field, bitset<11> used) {\n    if(used.count() == n) {\n        answer = field;\n        return 1;\n    }\n\n    int y, x;\n    y = x = -1;\n    for(int i = 0; y == -1 && i < Y; ++i) for(int j = 0; x == -1 && j < X; ++j) if(!used[field[i][j]]) {\n        y = i;\n        x = j;\n    }\n\n    int result = 0;\n    for(int id = 1; id <= n; ++id) {\n        if(used[id]) continue;\n        if(field[y][x] && field[y][x] != id) continue;\n        int a = area[id];\n        for(int t = 0; t < a; ++t) {\n            int i = y + t;\n            int j = x + a / (t + 1) - 1;\n            if(!in(i, j)) continue;\n            if(!placeable(field, id, y, x, i, j)) continue;\n            result += dfs(place(field, id, y, x, i, j), used.set(id));\n            used.reset(id);\n        }\n    }\n    return result;\n}\n\nint main() {\n    while(cin >> X >> Y >> n, X | Y | n) {\n        area.clear();\n        area.resize(n + 1);\n        for(int i = 0; i < n; ++i) {\n            int b, k;\n            cin >> b >> k;\n            area[b] = k;\n        }\n        s.clear();\n        s.resize(Y, vector<int>(X));\n        for(auto& y: s) for(auto& x: y) cin >> x;\n\n        if(dfs(s, 0) == 1) {\n            for(int i = 0; i < Y; ++i) {\n                for(int j = 0; j < X; ++j) cout << (j ? \" \" : \"\") << answer[i][j];\n                cout << endl;\n            }\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nint cnt;\nint ans[10][10];\nint fld[10][10];\nint X,Y;\nint B[15],K[15],Bx[15],By[15],N;\nvector<int> V[15];\nbool pos(int x,int y){\n      return 0<=x&&x<X&&0<=y&&y<Y;\n}\nbool ok(int x,int y,int w,int h,int n){\n      REP(i,w)REP(j,h)if(!pos(x+i,y+j)||(fld[x+i][y+j]!=0&&fld[x+i][y+j]!=n)){\n            //cout<<i<<\" \"<<j<<\"no\"<<endl;\n            return false;\n      }\n      return true;\n}\nvoid rec(int n){\n      if(n==N){\n            REP(i,X)REP(j,Y)ans[i][j]=fld[i][j];\n            cnt++;\n            return;\n      }\n      int sx,sy;\n      //cout<<n<<\" \"<<B[n]<<endl;\n      //REP(i,Y)REP(j,X)printf(\"%d%c\",fld[j][i],j==X-1?'\\n':' ');\n      REP(i,X)REP(j,Y)if(fld[i][j]==B[n]){sx=i;sy=j;};\n      //cout<<sx<<\" \"<<sy<<endl;\n      REP(i,V[n].size()){\n            //cout<<V[n][i]<<endl;\n            for(int x=sx-V[n][i]+1;x<=sx;x++){\n                  for(int y=sy-K[n]/V[n][i]+1;y<=sy;y++){\n                        if(ok(x,y,V[n][i],K[n]/V[n][i],B[n])){\n                              REP(j,V[n][i])REP(k,K[n]/V[n][i])fld[x+j][y+k]=B[n];\n                              rec(n+1);\n                              REP(j,V[n][i])REP(k,K[n]/V[n][i]){\n                                    if(x+j==Bx[n]&&y+k==By[n])continue;\n                                    else fld[x+j][y+k]=0;\n                              }\n                        }\n                  }\n            }\n      }\n      return;\n}\nint main(){\n      while(cin>>X>>Y>>N&&(X||Y||N)){\n            REP(i,15)V[i].clear();\n            cnt=0;\n            REP(i,N){\n                  cin>>B[i]>>K[i];\n                  for(int j=1;j*j<=K[i];j++){\n                        if(K[i]%j==0){\n                              V[i].PB(j);\n                              if(K[i]/j!=j)V[i].PB(K[i]/j);\n                        }\n                  }\n            }\n            REP(i,Y)REP(j,X){\n                  cin>>fld[j][i];\n                  if(fld[j][i]!=0){\n                        REP(k,N)if(B[k]==fld[j][i]){\n                              Bx[k]=j;By[k]=i;\n                        }\n                  }\n            }\n            rec(0);\n            if(cnt==1){\n                  REP(i,Y)REP(j,X)printf(\"%d%c\",ans[j][i],j==X-1?'\\n':' ');\n            }else{\n                  cout<<\"NA\"<<endl;\n            }\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n#define PUT 0\n#define REMOVE 1\n#define CHECK_PLANE 2\n\nint cnt;\nint m[10][10];\nint ans[10][10];\n\nbool is_origin[10][10];\nbool make_rect(int now,int x,int y,int width,int height,int flag,\n\t       int r,int c){\n  rep(i,height){\n    rep(j,width){\n      if ( flag == PUT )m[y+i][j+x]=now;\n      else if ( flag == REMOVE && is_origin[y+i][x+j] == false){\n\tm[y+i][j+x]=0;\n      }else if (flag == CHECK_PLANE){\n\tif ( m[y+i][j+x]!=0 && m[y+i][j+x]!=now)return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid solve(int num,int now,int *number,int *x,int *y,int *size,int r,int c){\n  if ( now == num){\n    cnt++;\n    rep(i,r)rep(j,c)ans[i][j]=m[i][j];\n    return;\n  }\n\n  if ( cnt > 1)return;\n  \n  int cur=number[now];\n  REP(k,1,size[now]+1 && cnt <2){\n    if ( size[now]%k != 0)continue;\n    int h=k,w=size[now]/k;\n    int hstart=max(0,y[now]-h+1),wstart=max(0,x[now]-w+1);\n    REP(i,hstart,y[now]+1 && i+h <=r && cnt < 2){\n      REP(j,wstart,x[now]+1 && j+w <=c && cnt < 2){\n\tif ( make_rect(cur,j,i,w,h,CHECK_PLANE,r,c) ){\n\t  make_rect(cur,j,i,w,h,PUT,r,c);\n\t  solve(num,now+1,number,x,y,size,r,c);\n\t  make_rect(cur,j,i,w,h,REMOVE,r,c);\n\t}\n      }\n    }\n  }\n}\n\n\nmain(){\n  int c,r,n;\n  while(cin>>c>>r>>n && c){\n    pair<int,int> in[n];\n    int x[n],y[n],size[n],tmp[100+1],num[100+1];\n    rep(i,n)cin>>in[i].second>>in[i].first;\n    sort(in,in+n,greater<pair<int,int> >());\n    rep(i,n)tmp[in[i].second]=i,size[i]=in[i].first,num[i]=in[i].second;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif ( m[i][j] != 0){\n\t  x[tmp[m[i][j]]]=j;\n\t  y[tmp[m[i][j]]]=i;\n\t  is_origin[i][j]=true;\n\t}\n\tis_origin[i][j]=false;\n      }\n    }\n    cnt = 0;\n\n    solve(n,0,num,x,y,size,r,c);\n    if ( cnt == 1){\n      rep(i,r){\n\trep(j,c){\n\t  if ( j)cout << ' ';\n\t  cout <<ans[i][j];\n\t}\n\tcout << endl;\n      }\n    }else if (cnt == 0)cout << \"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nvector<long long int> divisor(long long int n) {\n\tvector<long long int> res;\n\tfor (long long int i = 1; i * i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(i);\n\t\t\tif (i * i != n) res.push_back(n / i);\n\t\t}\n\t}\n\tsort(begin(res), end(res));\n\treturn res;\n}\nint X, Y, n;\nvector<vector<int>>getans(const vector<vector<int>>&field, const int now, const vector<int>&nums,const vector<pair<int,int>>&ps) {\n\tif (now == ps.size())return field;\n\tvector<long long int>divs(divisor(nums[now]));\n\tvector<vector<int>>ans;\n\tconst int fromy = ps[now].first;\n\tconst int fromx = ps[now].second;\n\tfor (const  int  yrange : divs) {\n\t\tconst int xrange = nums[now] / yrange;\n\t\tint left = max(0, fromx - xrange + 1);\n\t\tint right = min(X-xrange, fromx);\n\t\tint up = max(0, fromy - yrange + 1);\n\t\tint down = min(Y- yrange, fromy);\n\t\tfor (int leftside = left; leftside <= right; ++leftside) {\n\t\t\tfor (int upside = up; upside <= down; ++upside) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int x = leftside; x < leftside+xrange; ++x) {\n\t\t\t\t\tfor (int y = upside; y < upside+yrange; ++y) {\n\t\t\t\t\t\tif (field[y][x] && field[y][x] != now) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tvector<vector<int>>nfield(field);\n\t\t\t\t\tfor (int x = leftside; x < leftside + xrange; ++x) {\n\t\t\t\t\t\tfor (int y = upside; y < upside + yrange; ++y) {\n\t\t\t\t\t\t\tnfield[y][x] = now;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvector<vector<int>>nans(getans(nfield, now + 1, nums, ps));\n\t\t\t\t\tif (!ans.empty()) {\n\t\t\t\t\t\tif (!nans.empty())return vector<vector<int>>();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = nans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (1) { cin >> X >> Y >> n;\n\tif (!X)break;\n\t\tvector<int>nums(n+1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tnums[x] = y;\n\t\t}\n\t\tvector<vector<int>>field(Y, vector<int>(X));\n\t\tvector<pair<int, int>>froms(n + 1);\n\t\tfor (int y = 0; y < Y; ++y) {\n\t\t\tfor (int x = 0; x < X; ++x) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tfield[y][x] = a;\n\t\t\t\tif (a) {\n\t\t\t\t\tfroms[a] = make_pair(y, x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto v=getans(field, 1, nums, froms);\n\t\tif (v.empty()) {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < Y; ++i) {\n\t\t\t\tfor (int j = 0; j < X; ++j) {\n\t\t\t\t\tcout << v[i][j];\n\t\t\t\t\tif (j != X - 1)cout << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int,int> pii;\nvector<vector<pii> > v;\nint tab[16][16];\nint m[16][16];\nint ans[16][16];\nint x, y, N;\n\nint search(int n) {\n\tif(n > N) {\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tans[i][j] = tab[i][j];\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\tint res = 0;\n\tint sx = -1, sy = -1;\n\tfor(int i = 0; i < y; i++) {\n\t\tfor(int j = 0; j < x; j++) {\n\t\t\tif(m[i][j] == n) {\n\t\t\t\t//*\n\t\t\t\tif(sx != -1 || sy != -1)\n\t\t\t\t\tabort();\n\t\t\t\t// */\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < v[n-1].size(); i++) {\n\t\tint wi, hi;\n\t\twi = v[n-1][i].first;\n\t\thi = v[n-1][i].second;\n\t\tfor(int by = 0; by < hi; by++) {\n\t\t\tfor(int bx = 0; bx < wi; bx++) {\n\t\t\t\tif(sy-by >= 0 && sx-bx >= 0 && sy-by + hi <= y && sx-bx + wi <= x) {\n\t\t\t\t\t/*\n\t\t\t\t\tcout << \"hoge:\" << n << endl;\n\t\t\t\t\tcout << \"i:\" << i << endl;\n\t\t\t\t\tcout << sy-by << \",\" << sx-bx << endl;\n\t\t\t\t\t// */\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\tif(tab[j][k] != 0 || (m[j][k] != 0 && m[j][k] != n)) {\n\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t//cout << sy << \",\" << sx << endl;\n\t\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\t\ttab[j][k] = n;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint tmp;\n\t\t\t\t\t\ttmp = search(n+1);\n\t\t\t\t\t\tres += tmp;\n\t\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\t\ttab[j][k] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << n << endl;\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> x >> y >> N, x || y || N) {\n\t\tv.clear();\n\t\tv.resize(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(k % j == 0 && j <= y && k / j <= x) {\n\t\t\t\t\tv[b-1].push_back(pii(j,k/j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\t\tcout << v[i][j].first << \",\" << v[i][j].second << endl;\n\t\t\t} cout << endl;\n\t\t} cout << endl;\n\t\t// */\n\n\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tfor(int j = 0; j < 16; j++) {\n\t\t\t\ttab[i][j] = 0;\n\t\t\t\tm[i][j] = 0;\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tcin >> m[i][j];\n\t\t\t}\n\t\t}\n\n\t\tif(search(1) != 1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tcout << ans[i][0];\n\t\t\t\tfor(int j = 1; j < x; j++) {\n\t\t\t\t\tcout << \" \" << ans[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nqueue<pair<int, vector<vector<int> > > >Q;\nvector<vector<int>>X, P; int H, W, N, V1[20], V2[20];\npair<bool, vector<vector<int> > > hantei(vector<vector<int> >a1, int X1, int Y1, int H1, int W1, int N1) {\n\tbool OK = true; int G[30][30];\n\tfor (int i = 0; i < 900; i++)G[i / 30][i % 30] = 0;\n\tfor (int i = X1; i < X1 + H1; i++) {\n\t\tfor (int j = Y1; j < Y1 + W1; j++) {\n\t\t\tif (i >= H || j >= W) { OK = false; continue; }\n\t\t\tif (a1[i][j] != 0 || (X[i][j] != V1[N1] && X[i][j] >= 1))OK = false;\n\t\t\ta1[i][j] = V1[N1]; G[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (X[i][j] == V1[N1] && G[i][j] == 0)OK = false;\n\t\t}\n\t}\n\treturn make_pair(OK, a1);\n}\nint main() {\n\twhile (true) {\n\t\tX.clear(); P.clear(); H = 0; W = 0; N = 0;\n\t\tcin >> W >> H >> N; int D1 = 0; if (W == 0 && H == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; i++) { cin >> V1[i] >> V2[i]; D1 += V2[i]; }\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tvector<int>G, I; int a;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a; G.push_back(a); I.push_back(0);\n\t\t\t}\n\t\t\tX.push_back(G); P.push_back(I);\n\t\t}\n\t\tif (D1 != W*H) { cout << \"NA\" << endl; continue; }\n\t\tQ.push(make_pair(0, P)); vector<vector<int> >res; int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tvector<vector<int>>K = Q.front().second;\n\t\t\tint L = Q.front().first; Q.pop();\n\t\t\tif (L == N) { cnt++; res = K; continue; }\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 1; k <= V2[L]; k++) {\n\t\t\t\t\t\tif (V2[L] % k != 0)continue;\n\t\t\t\t\t\tpair<bool, vector<vector<int> > >res1 = hantei(K, i, j, k, V2[L] / k, L);\n\t\t\t\t\t\tif (res1.first == true) {\n\t\t\t\t\t\t\tQ.push(make_pair(L + 1, res1.second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0 || cnt >= 2)cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (j >= 1) { cout << ' '; }cout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair< pair<int,int>,pair<int,int> > NODE;\n#define NY first.first\n#define NX first.second\n#define SY second.first\n#define SX second.second\n\nint X,Y,n,ret;\nvector< vector<int> > solve;\nmap<int,vector<NODE> > able;\nvector< vector<int> > data(20,vector<int>(20));\nvector< vector<int> > none(20,vector<int>(20));\nvector< vector<int> > rec(20,vector<int>(20));\n\nvoid bt(int dp){\n\tif(ret>1)return;\n\tvector<vector<int> > tt = rec;\n\tbool flag;\n\tif(dp==n){\n\t\tflag = true;\n\t\trep(i,Y)rep(j,X)if(!rec[i][j])flag = false;\n\t\tif(flag){\n\t\t\tret++;\n\t\t\tsolve = rec;\n\t\t}\n\t\treturn;\n\t}\n\tmap<int,vector<NODE> >::iterator it = able.begin();\n\tfor(int i=0;i<dp;i++)it++;\n\t\n\tfor(int i=0;i<(*it).second.size();i++){\n\t\tflag = true;\n\t\trep(y,(*it).second[i].SY)rep(x,(*it).second[i].SX){\n\t\t\tif(rec[(*it).second[i].NY+y][(*it).second[i].NX+x])flag = false;\n\t\t\trec[(*it).second[i].NY+y][(*it).second[i].NX+x]=(*it).first;\n\t\t}\n\t\tif(flag)bt(dp+1);\n\t\trec = tt;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tmap<int,int> buy;\n\t\n\tint b,k;\n\tint name,cnt;\n\tpair<int,int> coord;\n\twhile(cin >> X >> Y >> n , X){\n\t\tret = 0;/*\trep(i,Y){\n\t\trep(j,X)cout << rec[i][j];\n\t\tcout << endl;\n\t}\n*/\n\t\table.clear();\n\t\tbuy.clear();\n\t\trep(i,Y)rep(j,X)data[i][j]=0;\n\t\trep(i,n){\n\t\t\tcin >> b >> k;\n\t\t\tbuy[b] = k;\n\t\t}\n\t\trep(i,Y)rep(j,X)cin >> data[i][j];\n\n\t\trep(i,Y)rep(j,X){\n\t\t\trep(y,Y)rep(x,X){\n\t\t\t\tif( j+x > X-1 || i+y > Y-1 )continue;\n\t\t\t\tcnt = 0;\n\t\t\t\trep(YY,i+1)rep(XX,j+1)\n\t\t\t\t\tif(data[y+YY][x+XX]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tname = data[y+YY][x+XX];\n\t\t\t\t\t\tcoord = make_pair(y,x);\n\t\t\t\t\t}\n\t\t\t\tif(cnt == 1 && (i+1)*(j+1) == buy[name] ){\n\t\t\t\t\table[name].push_back( make_pair(coord,make_pair(i+1,j+1)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tmap<int,vector<NODE> >::iterator it = able.begin();\n\t\twhile(it != able.end()){\n\t\t\tfor(int i=0;i<(*it).second.size();i++)\n\t\t\t\tcout << (*it).first << \"=\" << (*it).second[i].NX << \",\" << (*it).second[i].NY << \" -> \" << (*it).second[i].SX << \",\" << (*it).second[i].SY << endl;\n\t\t\t++it;\n\t\t}\n*/\n\t\trec = none;\n\t\tbt(0);\n\t\tif(ret==1){\n\t\t\trep(i,Y){\n\t\t\t\trep(j,X)cout << solve[i][j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Area;\n\nclass Solver {\n  public:\n    Area solve() {\n      Area area(x, Vec(y, 0));\n      vector<Area> answers;\n      for (int i = 0; i < y; ++i) {\n        for (int j = 0; j < x; ++j) {\n          area[j][i] = s[j][i];\n        }\n      }\n      search(area, answers);\n      if (answers.size() != 1) {\n        answers.resize(1);\n        answers[0].clear();\n      }\n      return answers[0];\n    }\n    int x, y, n;\n    int b[15], k[15];\n    int s[10][10];\n  private:\n    void print_area(Area &area) {\n      for (int i = 0; i < y; ++i) {\n        for (int j = 0; j < x; ++j) {\n          cerr << area[j][i] << \" \";\n        }\n        cerr << endl;\n      }\n      cerr << \"--------------------------------\" << endl;\n    }\n    void search(Area &area, vector<Area> &answers, int id = 0) {\n      //print_area(area);\n      if (id == n) {\n        answers.push_back(area);\n        return;\n      }\n      for (int yi = 0; yi < y; ++yi) {\n        for (int dy = 1; yi + dy <= y; ++dy) {\n          int dx = k[id] / dy;\n          if (k[id] % dy != 0) {\n            continue;\n          }\n          for (int xi = 0; xi + dx <= x; ++xi) {\n            bool is_valid = true;\n            for (int i = yi; i < yi + dy and is_valid; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                if (area[j][i] != 0 and area[j][i] != b[id]) {\n                  is_valid = false;\n                  break;\n                }\n              }\n            }\n            if (not is_valid) {\n              continue;\n            }\n            for (int i = yi; i < yi + dy; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                area[j][i] = b[id];\n              }\n            }\n            search(area, answers, id + 1);\n            if (answers.size() > 1) {\n              return;\n            }\n            for (int i = yi; i < yi + dy; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                area[j][i] = s[j][i];\n              }\n            }\n          }\n        }\n      }\n    }\n};\n\nint main() {\n  Solver s;\n  Area answer;\n  while (true) {\n    cin >> s.x >> s.y >> s.n;\n    for (int i = 0; i < s.n; ++i) {\n      cin >> s.b[i] >> s.k[i];\n    }\n    for (int i = 0; i < s.y; ++i) {\n      for (int j = 0; j < s.x; ++j) {\n        cin >> s.s[j][i];\n      }\n    }\n    answer = s.solve();\n    if (answer.size() == 0) {\n      cout << \"NA\" << endl;\n    } else {\n      for (int i = 0; i < s.y; ++i) {\n        for (int j = 0; j < s.x; ++j) {\n          cout << answer[j][i];\n          if (j < s.x - 1) {\n            cout << \" \";\n          } else {\n            cout << endl;\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define int long long\nusing namespace std;\n\ntemplate <typename X, typename T>\nauto vectors(X x, T a) {\n\treturn vector<T>(x, a);\n}\n\ntemplate <typename X, typename Y, typename Z, typename... Zs>\nauto vectors(X x, Y y, Z z, Zs... zs) {\n\tauto cont = vectors(y, z, zs...);\n\treturn vector<decltype(cont)>(x, cont);\n}\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint H, W, n;\npair<int,int> bk[15];\nmap<int,pair<int, int>> p;\nvector<vector<int>> ans;\n\n/*void dfs(vector<vector<int>> b, int h, int cnt){\n\tif(cnt == n){\n\t\tif(ans[0][0] == -1){\n\t\t\tans = b;\n\t\t}else{\n\t\t\tans[0][0] = -2;\n\t\t}\n\t\treturn;\n\t}\n\n\tif(h == H) h = 0;\n\tint w;\n\trep(i,W){\n\t\tif(b[h][i] == 0){\n\t\t\tw = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << h << ' ' << w << endl;\n\n\trep(i,H - h){\n\t\trep(j,W - w){\n\t\t\tint id = b[i + h][j + w];\n\t\t\tshow(id)\n\t\t\tif(id != 0 and (i + 1) * (j + 1) == bk[id]){\n\t\t\t\tshow(\"JI\")\n\t\t\t\trep(k,h) rep(l,w) b[k][l] = id;\n\n\t\t\t\tdfs(b, h + i + 1, cnt + 1);\n\n\t\t\t\trep(k,h) rep(l,w) b[k][l] = 0;\n\t\t\t\tb[i + h][j + w] = id;\n\t\t\t}\n\t\t}\n\t}\n}*/\n\nbool paint(vector<vector<int>>& s, int y, int x, int h, int w, int b){\n\t//cout << \"left up \" << y << ' ' << x << endl;\n\t//rep(i,H) { rep(j,W){ cout << s[i][j]; } cout << endl; }\n\n\trep(i,h) rep(j,w){\n\t\tif(s[i + y][j + x] != 0 and s[i + y][j + x] != b) return false;\n\t}\n\trep(i,h) rep(j,w){\n\t\ts[i + y][j + x] = b;\n\t}\n\t//rep(i,H) { rep(j,W){ cout << s[i][j]; } cout << endl; }\n\treturn true;\n}\n\nvoid reset(vector<vector<int>>& s, int y, int x, int h, int w){\n\trep(i,h) rep(j,w){\n\t\ts[i + y][j + x] = 0;\n\t}\n}\n\nbool check(vector<vector<int>>& s){\n\trep(i,H) rep(j,W) if(s[i][j] == 0) return false;\n\treturn true;\n}\n\nvoid dfs(vector<vector<int>> s, int idx){\n\tif(idx == n){\n\n\t\tif(check(s)){\n\t\t\t//show(\"OK\")\n\t//rep(i,H) { rep(j,W){ cout << s[i][j]; } cout << endl; }\n\t\t\tif(ans[0][0] == -1) ans = s;\n\t\t\telse ans[0][0] = -2;\n\t\t}\n\t\treturn;\n\t}\n\n\tint k, b;\n\ttie(k,b) = bk[idx];\n\t//cout <<\"kb \" <<  k << ' ' << b << endl;\n\n\trange(h,1,H + 1){\n\t\tif(k % h != 0) continue;\n\t\tint w = k / h;\n\n\t\tint y, x;\n\t\ttie(y,x) = p[b];\n\n\t\t//cout << \"h  w  \" << h << ' ' << w << endl;\n\t\t//cout << \"id p  \" << y << ' ' << x << endl;\n\t\t//cout << y - h + 1 << ' ' << y << endl;\n\t\tfor(int i = max<int>(0, y - h + 1); i <= y and i + h - 1 < H; i++){\n\t\t\tfor(int j = max<int>(0, x - w + 1); j <= x and j + w - 1 < W; j++){\n\t\t\t\t//cout << \"i j \" << i << ' ' << j << endl;\n\t\t\t\tif(not paint(s, i, j, h, w, b)) continue;\n\n\t\t\t\tdfs(s, idx + 1);\n\n\t\t\t\treset(s, i, j, h, w);\n\t\t\t\ts[y][x] = b;\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\twhile(cin >> W >> H >> n, W){\n\t\trep(i,n){\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tbk[i] = make_pair(k,b);\n\t\t}\n\t\tsort(bk, bk + n, greater<pair<int, int>>());\n\n\t\tvector<vector<int>> s(H, vector<int>(W));\n\t\tans = s;\n\t\trep(i,H) rep(j,W) {\n\t\t\tcin >> s[i][j];\n\t\t\tif(s[i][j] != 0){\n\t\t\t\tp[s[i][j]] = make_pair(i,j);\n\t\t\t}\n\t\t}\n\n\t\tans[0][0] = -1;\n\t\tdfs(s, 0);\n\n\t\tif(ans[0][0] > 0){\n\t\t\trep(i,H){\n\t\t\t\trep(j,W){\n\t\t\t\t\tif(j) cout << ' ';\n\t\t\t\t\tcout << ans[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef struct position{\n  int x, y;\n}position;\nvector<vector<int> > ans2;\nbool fit(vector<vector<int> > &ans, position lu, int h, int w, int val){\n  for (int i = lu.y; i < lu.y + h; i++) {\n    for (int j = lu.x; j < lu.x + w; j++) {\n      if(ans[i][j] != 0 and ans[i][j] != val) return false;\n    }\n  }\n  return true;\n}\n         \nbool range(position p, int h, int w, int mh, int mw){\n  return ((0 <= p.x and p.x + w - 1 < mw) and\n          (0 <= p.y and p.y + h - 1 < mh));\n}\n           \nint dfs(vector<vector<int> > &land,\n        vector<vector<int> >  &ans,\n         vector<int> &b,\n         vector<int> &k,\n         vector<position> &s,\n         int depth = 0){\n  if(depth == b.size()){\n    if(ans2[0][0] != -1) return 100;\n    ans2 = ans;\n    return 1; \n  }\n  // std::cout << depth << std::endl;\n  int res = 0;\n  for (int i = 0; i < k[depth]; i++) {\n    int h = 1 + i, w = k[depth]/(i + 1);\n    if((k[depth]%(i + 1)) != 0) continue;\n    for (int j = 0; j < k[depth]; j++) {\n      position lu = s[b[depth]];\n      lu.x -= j%w;\n      lu.y -= j/w;\n      // std::cout << \"lu.x:\" << lu.x << \" lu.y:\" << lu.y << std::endl;\n      // std::cout << \"h:\" << h << \" w:\" << w << std::endl;\n      // std::cout << \"range:\" << range(lu, h, w, land.size(), land[0].size()) << std::endl;\n      if(not range(lu, h, w, land.size(), land[0].size())) continue;\n      if(fit(ans, lu, h, w, b[depth])) {\n        // ansの更新\n        for (int k = lu.y; k < lu.y + h; k++) \n          for (int l = lu.x; l < lu.x + w; l++) \n            ans[k][l] = b[depth];\n\n        // for (int i = 0; i < ans.size(); i++) {\n        //   for (int j = 0; j < ans[i].size(); j++) {\n        //     std::cout << ans[i][j];\n        //     if(j != ans[i].size() - 1) std::cout << \" \";\n        //     else std::cout << std::endl;\n        //   }\n        // }\n        // std::cout << std::endl;\n\n        res += dfs(land, ans, b, k, s, depth + 1);\n        // ansを戻す．\n        for (int k = lu.y; k < lu.y + h; k++) {\n          for (int l = lu.x; l < lu.x + w; l++) {\n            ans[k][l] = 0;\n            if(k == s[b[depth]].y and l == s[b[depth]].x)ans[k][l] = b[depth];\n          }\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int x, y, n;\n  ans2.resize(1);\n  ans2[0].resize(1, -1);\n  while(std::cin >> x >> y >> n){\n    if(x == 0) break;\n    ans2[0][0] = -1;\n    vector<int> b(n), k(n);\n    vector<position> s(n + 1, position{-1, -1});\n    vector<vector<int> > land(y, vector<int>(x));\n    for (int i = 0; i < n; i++) {\n      std::cin >> b[i] >> k[i];\n    }\n    for (int i = 0; i < y; i++) {\n      for (int j = 0; j < x; j++) {\n        std::cin >> land[i][j];\n        if(land[i][j] != 0) s[land[i][j]] = position{j, i};\n      }\n    }\n    vector<vector<int> > ans = land;\n    if(dfs(land, ans, b, k, s) == 1){\n      for (int i = 0; i < y; i++) {\n        for (int j = 0; j < x; j++) {\n          std::cout << ans2[i][j];\n          if(j != x - 1) std::cout << \" \";\n          else std::cout << std::endl;\n        }\n      }\n    }else{\n      std::cout << \"NA\" << std::endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 0\n\nint w,h,n;\nint field[16][16];\nint check[16][16],output[16][16];\nint ans;\nstruct state{\n\tint area,x,y;\n} memo[16];\n\nbool ok(int x, int y, int zx, int zy, int num){\n\trep(i,zy){\n\t\trep(j,zx){\n\t\t\tint tx = x + j;\n\t\t\tint ty = y + i;\n\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || check[ty][tx]>0 )return false;\n\t\t\tif( field[ty][tx]!=0 && field[ty][tx]!=num )return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dfs(int cnt){\n#if DEB\n\tprintf(\"cnt:%d\\n\",cnt);\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tprintf(\"%d \",check[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\tputs(\"\");\n#endif\n\t\n\tif( cnt==n ){\n\t\tans++;\n\t\tif( ans>=2 ) return;\n\t\trep(i,h)rep(j,w)output[i][j]=check[i][j];\n\n\t\trep(i,h)rep(j,w)if( check[i][j]==0 )ans=2;\n\t\treturn;\n\t}\n\n\tfor(int i=1; i<=memo[cnt].area; i++){\n\t\tif( memo[cnt].area%i!=0 )continue;\n\t\tint j = memo[cnt].area / i;\n\t\tint si = memo[cnt].y - i + 1;\n\t\tint sj = memo[cnt].x - j + 1;\n\n#if DEB\n\t\tprintf(\"(i,j)=(%d,%d),  (si,sj)=(%d,%d)\\n\",i,j,si,sj);\n#endif\t\t\n\n\t\tfor(int ii=si; ii<=memo[cnt].y; ii++){\n\t\t\tif( ii<0 )continue;\n\t\t\tfor(int jj=sj; jj<=memo[cnt].x; jj++){\n\t\t\t\tif( jj<0 )continue;\n\t\t\t\tif( ok(jj, ii, j, i, cnt+1) ){\n#if DEB\n\t\t\t\t\tprintf(\"isok:: jj:%d , ii:%d, j:%d, i:%d\\n\",jj,ii,j,i);\n#endif \t\t\t\t\t\n\t\t\t\t\trep(k,i)rep(l,j)check[ii+k][jj+l]=cnt+1;\n\t\t\t\t\tdfs(cnt+1);\n\t\t\t\t\tif( ans>=2 ) return;\n\t\t\t\t\trep(k,i)rep(l,j)check[ii+k][jj+l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t\n\twhile(scanf(\"%d%d%d\",&w,&h,&n),w|h|n){\n\t\trep(i,16)rep(j,16)check[i][j]=output[i][j]=0;\n\t\tans = 0;\n\t\t\n\t\trep(i,n){\n\t\t\tint b,k; scanf(\"%d%d\",&b,&k);\n\t\t\tmemo[b-1].area = k;\n\t\t}\n\t\trep(i,h)rep(j,w)scanf(\"%d\",&field[i][j]);\n\t\trep(i,h)rep(j,w)if( field[i][j]>0 ){\n\t\t\tmemo[ field[i][j]-1 ].x = j;\n\t\t\tmemo[ field[i][j]-1 ].y = i;\n\t\t}\n\t\t\n\t\tdfs(0);\n\n\t\tif( ans==1 ){\n\t\t\trep(i,h){\n\t\t\t\trep(j,w){\n\t\t\t\t\tif( j>0 )putchar(' ');\n\t\t\t\t\tprintf(\"%d\",output[i][j]);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"NA\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint field[11][11];\nint land[20];\npair<int,int> place[20];\n\nint w,h,n;\nbool ok;\n\nstruct landInfo{\n\tint minx;\n\tint miny;\n\tint maxy;\n\tint maxx;\n};\n\nlandInfo mem[20];\n\nbool no=false;\n\nvoid dfs(int num,int sum){\n\tif(no)\n\t\treturn;\n\tif(num==n+1){\n\t\tif(sum==h*w){\n\t\t\tif(ok){\n\t\t\t\tno=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tok=true;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\telse{\n\t\t// ßûð·×ÄµÄÝé\n\t\tfor(int i = 1; i <= land[num]; i++){\n\t\t\tif(land[num]%i!=0)\n\t\t\t\tcontinue;\n\t\t\tint tate=i;\n\t\t\tint yoko=land[num]/i;\n\t\t\t// Ç±É»ÝÌynÌÔÌÊuðÁÄ­é©\n\t\t\tfor(int j = 0; j < tate; j++){\n\t\t\t\tfor(int k = 0; k < yoko; k++){\n//\t\t\t\t\tif(mem[1].minx==0&&j==1&&k==0&&tate==2&&num==2){\n////\t\t\t\t\t\tcout<<endl;\n//\t\t\t\t\t}\n\t\t\t\t\t// ÍÝoÄÈ¯êÎAßé\n\t\t\t\t\tint minx=place[num].second-k;\n\t\t\t\t\tint miny=place[num].first-j;\n\t\t\t\t\tint maxx=minx+yoko-1;\n\t\t\t\t\tint maxy=miny+tate-1;\n\t\t\t\t\tif(minx>=0&&miny>=0&&minx<w&&miny<h&&maxx>=0&&maxy>=0&&maxx<w&&maxy<h){\n\t\t\t\t\t\t// àµ¼ÌynÌÍÍÆðíÁÄ¢È¯êÎ\n\t\t\t\t\t\tvector<pair<int,int> > ps;\n\t\t\t\t\t\tps.push_back(make_pair(miny,minx));\n\t\t\t\t\t\tps.push_back(make_pair(miny,maxx));\n\t\t\t\t\t\tps.push_back(make_pair(maxy,minx));\n\t\t\t\t\t\tps.push_back(make_pair(maxy,maxx));\n\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int l = 1; l < num; l++){\n\t\t\t\t\t\t\tif((maxx<mem[l].minx||maxy<mem[l].miny)||(minx>mem[l].maxx||miny>mem[l].maxy)){\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//for(int m = 0; m < ps.size(); m++){\n\t\t\t\t\t\t\t//\tif(ps[m].first>=mem[l].miny&&mem[l].maxy>=ps[m].first&&\n\t\t\t\t\t\t\t//\t\tps[m].second>=mem[l].minx&&mem[l].maxx>=ps[m].second){\n\t\t\t\t\t\t\t//\t\t\tf=true;\n\t\t\t\t\t\t\t//\t\t\tbreak;\n\t\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//if(f)\n\t\t\t\t\t\t\t//\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f){\n\t\t\t\t\t\t\tif(num==4){\n\t\t\t\t\t\t\t//\tcout<<endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlandInfo li;\n\t\t\t\t\t\t\tli.minx=minx;\n\t\t\t\t\t\t\tli.maxx=maxx;\n\t\t\t\t\t\t\tli.miny=miny;\n\t\t\t\t\t\t\tli.maxy=maxy;\n\t\t\t\t\t\t\tmem[num]=li;\n\t\t\t\t\t\t\tdfs(num+1,sum+land[num]);\n\t\t\t\t\t\t\tif(no)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t//if(ok)\n\t\t\t\t\t\t\t//\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h>>n&&!(w==0&&h==0&&n==0)){\n\t\tok=false;\n\t\tno=false;\n\t\tint b,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>b>>k;\n\t\t\tland[b]=k;\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]!=0){\n\t\t\t\t\tplace[field[i][j]].first=i;\n\t\t\t\t\tplace[field[i][j]].second=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ÔÉynðßÄ¢­\n\t\tdfs(1,0);\n\t\tif(ok&&!no){\n\t\t\tfor(int i = 1; i <= n; i++){ \n\t\t\t\tfor(int j = mem[i].miny; j <= mem[i].maxy; j++){\n\t\t\t\t\tfor(int k = mem[i].minx; k <= mem[i].maxx; k++){\n\t\t\t\t\t\tfield[j][k]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tcout<<field[i][j];\n\t\t\t\t\tif(j!=w-1)\n\t\t\t\t\t\tcout<<\" \";\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\nbool flag = false;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n\n    if ( r0 < 0 || c0 < 0 ) return false;\n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 + 1 ); r0 < min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 + 1 ); c0 < min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            -- s;\n            if ( s >= n ) {\n                flag = true;\n                return;\n            }\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        if ( flag ) {\n            cout << \"NA\" << endl;\n            continue;\n        }\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { \n      rep(j,W) {\n        if( j ) cout << \" \";\n        cout << buf[i][j]; \n      } \n      cout << endl; \n    }\n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    rep(i,H) rep(j,W) cin >> s[i][j];\n    //if( sum != H*W ) { puts(\"NA\"); continue; }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Subdivide The Land\n//Level: 3\n//Category: 探索\n//Note:\n\n/**\n * パズル「四角に切れ」と同じ問題設定なので、おそらくNP完全である。\n * したがって、効率のよい探索を考える。\n *\n * 全てのマスがどれかの長方形に属していることより、盤面を左上から走査していき、どの番号の長方形に属すかを探索していけばよい。\n * こうすることで、そのマスを左上とした長方形に決め打つことができる。\n * 各番号では、その面積を与える長方形を全て試す。\n */\n#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<15> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    Rect() : r(0), c(0), h(0), w(0) {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else {\n        bool conquered = false;\n        for(int i = 0; i < N; ++i) {\n            if(!state[i]) continue;\n            if(cur[i].intersect(Rect(r, c, 1, 1))) {\n                conquered = true;\n                break;\n            }\n        }\n        if(conquered) {\n            dfs(r, c+1, state, cur);\n            return;\n        }\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint X,Y,N;\nint b[100], k[100];\nint c[10][10], f[10][10];\nint ans[10][10];\nint cnt;\n\nvector<int> bx[101],by[101];\n\nbool isputs(int x, int y, int n, int a, int b)\n{\n\tif(x+bx[a][b] > X || y+by[a][b] > Y) return false;\n\n\tfor(int i=y; i<y+by[a][b]; i++)\n\tfor(int j=x; j<x+bx[a][b]; j++)\n\t{\n\t\tif(c[j][i]!=0 && c[j][i]!=n) return false;\n\t\tif(f[j][i]!=0) return false;\n\n\t\tf[j][i]=n;\n\t}\n\t\n\treturn true;\n}\n\nbool dfs(int n)\n{\n\tif(cnt>=2) return false;\n\t\n\tif(n==N) \n\t{\n\t\tcnt++;\n\t\tmemcpy(ans, f, sizeof(ans));\n\t\treturn false;\n\t}\n\n\tint p=b[n], a=k[n];\n\tint t[10][10];\n\tmemcpy(t,f,sizeof(t));\n\n\tfor(int i=0; i<Y; i++)\n\tfor(int j=0; j<X; j++)\n\tfor(int l=0; l<bx[a].size(); l++)\t\n\t{\n\t\tif(isputs(j,i,p,a,l)) dfs(n+1);\n\n\t\tmemcpy(f,t,sizeof(f));\n\t}\n\t\n\treturn false;\n}\n\n\nint main()\n{\n\tfor(int x=1; x<=10; x++)\n\tfor(int y=1; y<=10; y++)\n\t{\n\t\tint n=x*y;\n\t\tbx[n].push_back(x);\n\t\tby[n].push_back(y);\n\t}\n\n\twhile(cin >> X >> Y >> N, (X||Y||N))\n\t{\n\t\tcnt=0;\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> b[i] >> k[i];\n\t\n\t\tfor(int i=0; i<Y; i++)\n\t\tfor(int j=0; j<X; j++)\n\t\t\tcin >> c[j][i];\n\n\t\tmemset(f,0,sizeof(f));\n\t\t\n\t\tdfs(0);\n\t\tif(cnt == 1)\n\t\t{\n\t\t\tfor(int i=0; i<Y; i++)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<X; j++)\n\t\t\t\t\tcout << ans[j][i] << \" \";\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse cout << \"NA\" << endl;\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w, h, n, b[20], k[20], px[20], py[20], ans;\nint res[20][20];\n\nbool check(int id, const vector<vector<int> > &s, int sx, int sy, int gx, int gy){\n\tif( sx <= px[id] && px[id] <= gx && sy <= py[id] && py[id] <= gy ){\n\t\tbool flag = false;\n\t\n\t\tfor(int y = sy; y <= gy; y++){\n\t\t\tfor(int x = sx; x <= gx; x++){\n\t\t\t\tif( s[y][x] == id + 1 ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}else if( s[y][x] != 0 ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\treturn false;\n}\n\nvoid fill_(int id, vector<vector<int> > &next, int sx, int sy, int gx, int gy){\n\tfor(int y = sy; y <= gy; y++){\n\t\tfor(int x = sx; x <= gx; x++){\n\t\t\tnext[y][x] = id + 1;\n\t\t}\n\t}\n}\n\nvoid debug(const vector<vector<int> > &s){\n\tcout << \"debug:\" << endl;\n\tfor(int y=0; y < h; y++){\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tif( x ) cout << \" \";\n\t\t\tcout << s[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// id := 購入者番号, id = [0,n)\nvoid dfs(int id, const vector<vector<int> > &s){\n\t\n\tif( id == n ){ // ぜんぶ調べた\n\t\tans++;\n\t\tfor(int y=0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tres[y][x] = s[y][x];\n\t\t\t}\n\t\t}\n\t}else{\n\t\t\n\t\tfor(int sy = 0; sy < h; sy++){\n\t\t\tfor(int sx = 0; sx < w; sx++){\n\t\t\t\tfor(int gy = sy; gy < h; gy++){\n\t\t\t\t\tfor(int gx = sx; gx < w; gx++){\n\t\t\t\t\t\tint width = gx - sx + 1, height = gy - sy + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( width * height == k[id] && check(id, s, sx, sy, gx, gy) ){\n\t\t\t\t\t\t\tvector<vector<int> > next = s;\n\t\t\t\t\t\t\tfill_(id, next, sx, sy, gx, gy);\n\t\t\t\t\t\t\tdfs(id + 1, next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h >> n, w || h || n ){\n\t\tfor(int i = 0; i < n; i++) cin >> b[i] >> k[i];\n\t\t\n\t\tvector<vector<int> > s(h, vector<int>(w));\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tcin >> s[y][x];\n\t\t\t\tif( s[y][x] != 0 ){\n\t\t\t\t\tpx[s[y][x]-1] = x;\n\t\t\t\t\tpy[s[y][x]-1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tdfs(0, s);\n\t\tif( ans != 1 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tfor(int y=0; y < h; y++){\n\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\tif( x ) cout << \" \";\n\t\t\t\t\tcout << res[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint s[15];\nint m[10][10];\nint ans[10][10];\nint now[10][10];\nint used[15];\nint row[15];\nint col[15];\nint ret;\nint a,b,c;\nvoid solve(int x,int y){\n\t//printf(\"%d %d\\n\",x,y);\n\tif(ret>1)return;\n\tif(y==a){\n\t\tsolve(x+1,0);\n\t\treturn;\n\t}\n\tif(x==b){\n\t\tret++;\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tans[i][j]=now[i][j];\n\t\treturn ;\n\t}\n\tif(~now[x][y]&&used[now[x][y]]){\n\t\tsolve(x,y+1);\n\t\treturn;\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tif(!used[i]&&row[i]>=x&&col[i]>=y){\n\t\t\tfor(int j=row[i]-x+1;j*(col[i]-y+1)<=s[i];j++){\n\t\t\t\tif(s[i]%j==0){\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\t\t\tfor(int l=0;l<s[i]/j;l++){\n\t\t\t\t\t\t\tif(now[x+k][y+l]!=m[x+k][y+l])ok=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\t\t\t\tfor(int l=0;l<s[i]/j;l++){\n\t\t\t\t\t\t\t\tnow[x+k][y+l]=i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tused[i]=1;\n\t\t\t\t\t\tsolve(x,y+1);\n\t\t\t\t\t\tused[i]=0;\n\t\t\t\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\t\t\t\tfor(int l=0;l<s[i]/j;l++){\n\t\t\t\t\t\t\t\tnow[x+k][y+l]=m[x+k][y+l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint d,e;\n\t\t\tscanf(\"%d%d\",&d,&e);\n\t\t\ts[d-1]=e;\n\t\t\tused[i]=0;\n\t\t}\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tscanf(\"%d\",&m[i][j]);\n\t\t\t\tm[i][j]--;\n\t\t\t\tnow[i][j]=m[i][j];\n\t\t\t\tif(m[i][j]>=0){\n\t\t\t\t\trow[m[i][j]]=i;\n\t\t\t\t\tcol[m[i][j]]=j;\n\t\t\t\t}\n\t\t\t}\n\t\tret=0;\n\t\tsolve(0,0);\n\t\tif(ret==1){\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif(j)printf(\" \");\n\t\t\t\t\tprintf(\"%d\",ans[i][j]+1);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}else printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define pb push_back\n\nint X,Y,N;\nint b[100], k[100];\nint c[10][10], f[10][10], ans[10][10];\nint cnt;\n\nvector<int> bx[101],by[101];\n\nbool isputs(int x, int y, int n, int a, int b)\n{\n\tif(x+bx[a][b] > X || y+by[a][b] > Y) return false;\n\n\tfor(int i=y; i<y+by[a][b]; i++)\n\tfor(int j=x; j<x+bx[a][b]; j++)\n\t{\n\t\tif(c[j][i]!=0 && c[j][i]!=n) return false;\n\t\tif(f[j][i]!=0) return false;\n\n\t\tf[j][i]=n;\n\t}\n\t\n\treturn true;\n}\n\nvoid dfs(int n)\n{\n\tif(cnt>=2) return;\n\t\n\tif(n==N) \n\t{\n\t\tcnt++;\n\t\tmemcpy(ans, f, sizeof(ans));\n\t\treturn;\n\t}\n\n\tint p=b[n], a=k[n];\n\tint t[10][10];\n\tmemcpy(t,f,sizeof(t));\n\n\tfor(int i=0; i<Y; i++)\n\tfor(int j=0; j<X; j++)\n\t{\n\t\tif(f[j][i]!=0) continue;\n\t\tfor(int l=0; l<bx[a].size(); l++)\t\n\t\t{\t\n\t\t\tif(isputs(j,i,p,a,l)) dfs(n+1);\n\n\t\t\tmemcpy(f,t,sizeof(f));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(int x=1; x<=10; x++)\n\tfor(int y=1; y<=10; y++)\n\t{\n\t\tint n=x*y;\n\t\tbx[n].pb(x);\n\t\tby[n].pb(y);\n\t}\n\n\twhile(cin >> X >> Y >> N, (X||Y||N))\n\t{\n\t\tvector<pair<int,int> > data;\n\n\t\tcnt=0;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin >> b[i] >> k[i];\n\t\t\tdata.push_back(make_pair(k[i],b[i]));\n\t\t}\n\n\t\tsort(data.begin(), data.end());\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tb[i]=data[i].second;\n\t\t\tk[i]=data[i].first;\n\t\t}\n\t\n\n\t\n\t\tfor(int i=0; i<Y; i++)\n\t\tfor(int j=0; j<X; j++)\n\t\t\tcin >> c[j][i];\n\n\t\tmemset(f,0,sizeof(f));\n\t\t\n\t\tdfs(0);\n\t\tif(cnt == 1)\n\t\t{\n\t\t\tfor(int i=0; i<Y; i++)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<X; j++)\n\t\t\t\t\tcout << ans[j][i] << \" \";\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse cout << \"NA\" << endl;\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { int h,w,index; };\n\nint H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nint found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(i,H) rep(j,W) edge[i][j].clear();\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) edge[y][x].push_back((Data){hy,hx,b[i]});\n      Skip:;\n        \n      }\n    }\n  }\n  /*  \n      rep(i,H) rep(j,W) {\n      cout << \"(\" << j << \",\" << i << \") ::\" << endl;\n      rep(l,(int)edge[i][j].size()) cout << \"(\" << edge[i][j][l].w << \",\" << edge[i][j][l].h << \",\" << edge[i][j][l].index << \") \";\n      cout << endl;\n      }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      assert( isValid(x+cx,y+cy) );\n      if( ans[y+cy][x+cx] != 0 ) {\n        goto Skip;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    rep(i,n) cin >> b[i] >> k[i];\n    rep(i,H) rep(j,W) cin >> s[i][j];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,land[10][10],test[10][10],ans[10][10];\n\nbool search(int i0,int j0){\n//printf(\"i0=%d, j0=%d\\n\",i0,j0);\n//for(int a=0;a<h;a++){for(int b=0;b<w;b++)printf(\"%d \",test[a][b]);puts(\"\");}puts(\"\");\n\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\nif(i<0 || h<=i || j<0 || w<=j)\twhile(1);\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\n\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tans[i][j]=test[i][j];}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);}\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { int h,w,index; };\n\nint H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nint found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(i,H) rep(j,W) edge[i][j].clear();\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) edge[y][x].push_back((Data){hy,hx,b[i]});\n      Skip:;\n        \n      }\n    }\n  }\n  /*  \n      rep(i,H) rep(j,W) {\n      cout << \"(\" << j << \",\" << i << \") ::\" << endl;\n      rep(l,(int)edge[i][j].size()) cout << \"(\" << edge[i][j][l].w << \",\" << edge[i][j][l].h << \",\" << edge[i][j][l].index << \") \";\n      cout << endl;\n      }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      //assert( isValid(x+cx,y+cy) );\n      if( ans[y+cy][x+cx] != 0 ) {\n        goto Skip;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint w, h;\nvector<int> area;\nvector<vector<int> > sum;\n\nint retNum;\nvector<string> ret;\n\nvoid solve(int y, int x, vector<string>& used)\n{\n    if(x > w){\n        ++ y;\n        x = 1;\n    }\n    if(y > h){\n        ++ retNum;\n        ret = used;\n        return;\n    }\n\n    if(used[y][x] != '0'){\n        solve(y, x+1, used);\n        return;\n    }\n\n    for(int y1=y; y1<=h; ++y1){\n        for(int x1=x; x1<=w; ++x1){\n            bitset<16> bs = sum[y1][x1] & (~sum[y1][x-1]) & (~sum[y-1][x1]);\n            if(bs.count() != 1)\n                continue;\n\n            int k = 0;\n            while(!bs[k])\n                ++ k;\n            if(area[k] != (y1 - y + 1) * (x1 - x + 1))\n                continue;\n\n            bool ng = false;\n            vector<string> used1 = used;\n            for(int i=y; i<=y1; ++i){\n                for(int j=x; j<=x1; ++j){\n                    if(used1[i][j] != '0' && used1[i][j] != k + '0')\n                        ng = true;\n                    used1[i][j] = k + '0';\n                }\n            }\n            if(!ng)\n                solve(y, x+1, used1);\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n\n        area.assign(n+1, 0);\n        for(int i=0; i<n; ++i){\n            int b, k;\n            cin >> b >> k;\n            area[b] = k;\n        }\n\n        sum.assign(h+1, vector<int>(w+1, 0));\n        for(int y=1; y<=h; ++y){\n            int tmp = 0;\n            for(int x=1; x<=w; ++x){\n                int a;\n                cin >> a;\n                if(a > 0)\n                    tmp |= (1 << a);\n                sum[y][x] = sum[y-1][x] | tmp;\n            }\n        }\n\n        retNum = 0;\n        vector<string> s(h+1, string(w+1, '0'));\n        solve(1, 1, s);\n\n        if(retNum != 1){\n            cout << \"NA\" << endl;\n        }else{\n            for(int i=1; i<=h; ++i){\n                cout << ret[i][1];\n                for(int j=2; j<=w; ++j)\n                    cout << ' ' << ret[i][j];\n                cout << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    rep(i,H) rep(j,W) cin >> s[i][j];\n  \n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n#define PUT 0\n#define REMOVE 1\n#define CHECK_PLANE 2\n\nint cnt;\nint m[10][10];\nint ans[10][10];\n\nbool is_origin[10][10];\nbool make_rect(int now,int x,int y,int width,int height,int flag,\n\t       int r,int c){\n  rep(i,height){\n    rep(j,width){\n      if ( flag == PUT )m[y+i][j+x]=now;\n      else if ( flag == REMOVE && is_origin[y+i][x+j] == false){\n\tm[y+i][j+x]=0;\n      }else if (flag == CHECK_PLANE){\n\tif ( m[y+i][j+x]!=0 && m[y+i][j+x]!=now)return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid solve(int num,int now,int *number,int *x,int *y,int *size,int r,int c){\n  if ( now == num){\n    cnt++;\n    rep(i,r)rep(j,c)ans[i][j]=m[i][j];\n    return;\n  }\n\n  if ( cnt > 1)return;\n  \n  int cur=number[now];\n  REP(k,1,size[now]+1){\n    if ( size[now]%k != 0)continue;\n    int h=k,w=size[now]/k;\n    int hstart=max(0,y[now]-h+1),wstart=max(0,x[now]-w+1);\n    REP(i,hstart,y[now]+1 && i+h <=r){\n      REP(j,wstart,x[now]+1 && j+w <=c){\n\tif ( make_rect(cur,j,i,w,h,CHECK_PLANE,r,c) ){\n\t  make_rect(cur,j,i,w,h,PUT,r,c);\n\t  solve(num,now+1,number,x,y,size,r,c);\n\t  make_rect(cur,j,i,w,h,REMOVE,r,c);\n\t}\n      }\n    }\n  }\n}\n\n\nmain(){\n  int c,r,n;\n  while(cin>>c>>r>>n && c){\n    pair<int,int> in[n];\n    int x[n],y[n],size[n],tmp[100+1],num[100+1];\n    rep(i,n)cin>>in[i].second>>in[i].first;\n    sort(in,in+n,greater<pair<int,int> >());\n    rep(i,n)tmp[in[i].second]=i,size[i]=in[i].first,num[i]=in[i].second;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif ( m[i][j] != 0){\n\t  x[tmp[m[i][j]]]=j;\n\t  y[tmp[m[i][j]]]=i;\n\t  is_origin[i][j]=true;\n\t}\n\tis_origin[i][j]=false;\n      }\n    }\n    cnt = 0;\n\n    solve(n,0,num,x,y,size,r,c);\n    if ( cnt == 1){\n      rep(i,r){\n\trep(j,c){\n\t  if ( j)cout << ' ';\n\t  cout <<ans[i][j];\n\t}\n\tcout << endl;\n      }\n    }else cout << \"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint X,Y,N;\nint b[100], k[100];\nint c[10][10], f[10][10];\nint ans[10][10];\nint cnt;\n\nvector<int> bx[101],by[101];\n\nbool isputs(int x, int y, int n, int a, int b)\n{\n\tif(x+bx[a][b] > X || y+by[a][b] > Y) return false;\n\n\tfor(int i=y; i<y+by[a][b]; i++)\n\tfor(int j=x; j<x+bx[a][b]; j++)\n\t{\n\t\tif(c[j][i]!=0 && c[j][i]!=n) return false;\n\t\tif(f[j][i]!=0) return false;\n\n\t\tf[j][i]=n;\n\t}\n\t\n\treturn true;\n}\n\nvoid dfs(int n)\n{\n\tif(cnt>=2) return;\n\t\n\tif(n==N) \n\t{\n\t\tcnt++;\n\t\tmemcpy(ans, f, sizeof(ans));\n\t\treturn;\n\t}\n\n\tint p=b[n], a=k[n];\n\tint t[10][10];\n\tmemcpy(t,f,sizeof(t));\n\n\tfor(int i=0; i<Y; i++)\n\tfor(int j=0; j<X; j++)\n\t{\n\t\tif(f[j][i]!=0) continue;\n\t\tfor(int l=0; l<bx[a].size(); l++)\t\n\t\t{\t\n\t\t\tif(isputs(j,i,p,a,l)) dfs(n+1);\n\n\t\t\tmemcpy(f,t,sizeof(f));\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tfor(int x=1; x<=10; x++)\n\tfor(int y=1; y<=10; y++)\n\t{\n\t\tint n=x*y;\n\t\tbx[n].push_back(x);\n\t\tby[n].push_back(y);\n\t}\n\n\twhile(cin >> X >> Y >> N, (X||Y||N))\n\t{\n\t\tcnt=0;\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> b[i] >> k[i];\n\t\n\t\tfor(int i=0; i<Y; i++)\n\t\tfor(int j=0; j<X; j++)\n\t\t\tcin >> c[j][i];\n\n\t\tmemset(f,0,sizeof(f));\n\t\t\n\t\tdfs(0);\n\t\tif(cnt == 1)\n\t\t{\n\t\t\tfor(int i=0; i<Y; i++)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<X; j++)\n\t\t\t\t\tcout << ans[j][i] << \" \";\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse cout << \"NA\" << endl;\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<20> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    Rect() {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else if(any_of(cur.begin(), cur.end(), [r,c](const Rect &re){return re.intersect(Rect(r,c,1,1));})) {\n        dfs(r, c+1, state, cur);\n    } else {\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N+10, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        vector<vector<int>> res(H, vector<int>(W, 0));\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    res[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << res[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint X, Y, N;\nint k[16];\nbool l[16];\nint s[10][10];\nint t[10][10];\nint u;\nint v[10][10];\n\nbool input() {\n  cin >> X >> Y >> N;\n  if (!X && !Y && !N) {\n    return false;\n  }\n\n  for (int i = 0; i < N; ++i) {\n    int b;\n    cin >> b;\n    cin >> k[b];\n  }\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      cin >> s[i][j];\n    }\n  }\n\n  return true;\n}\n\nvoid paint(int id, int y1, int x1, int y2, int x2) {\n  for (int i = y1; i <= y2; ++i) {\n    for (int j = x1; j <= x2; ++j) {\n      t[i][j] = id;\n    }\n  }\n  u += (y2 - y1 + 1) * (x2 - x1 + 1);\n}\n\nvoid unpaint(int y1, int x1, int y2, int x2) {\n  for (int i = y1; i <= y2; ++i) {\n    for (int j = x1; j <= x2; ++j) {\n      t[i][j] = 0;\n    }\n  }\n  u -= (y2 - y1 + 1) * (x2 - x1 + 1);\n}\n\nvoid find_vacant(int &r, int &c) {\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      if (!t[i][j]) {\n        r = i;\n        c = j;\n        return;\n      }\n    }\n  }\n}\n\nvoid print_ans() {\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      if (!j) {\n        cout << v[i][j];\n      } else {\n        cout << \" \" << v[i][j];\n      }\n    }\n    cout << endl;\n  }\n}\n\nint dfs(int p, int q) {\n  if (u == X * Y) {\n    for (int i = 0; i < Y; ++i) {\n      for (int j = 0; j < X; ++j) {\n        v[i][j] = t[i][j];\n      }\n    }\n    return 1;\n  }\n  if (s[p][q]) {\n    int id = s[p][q];\n    if (l[id]) {\n      return 0;\n    }\n  }\n\n  int z = 0;\n  for (int i = p; i < Y; ++i) {\n    for (int j = q; j < X; ++j) {\n      if (!t[i][j] && !s[i][j]) {\n        continue;\n      }\n      if (t[i][j] > 0) {\n        break;\n      }\n      int id = s[i][j];\n      if (l[id]) {\n        break;\n      }\n      for (int f = i; f < Y; ++f) {\n        int h = f - p + 1;\n        for (int g = j; g < X; ++g) {\n          if (t[f][g] > 0 || (s[f][g] != id && s[f][g])) {\n            break;\n          }\n          int w = g - q + 1;\n          int a = h * w;\n          if (k[id] > a) {\n            continue;\n          }\n          if (k[id] < a) {\n            break;\n          }\n          l[id] = true;\n          paint(id, p, q, f, g);\n          int np, nq;\n          find_vacant(np, nq);\n          z += dfs(np, nq);\n          unpaint(p, q, f, g);\n          l[id] = false;\n        }\n      }\n      break;\n    }\n  }\n  return z;\n}\n\nvoid solve() {\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      t[i][j] = 0;\n    }\n  }\n  for (int i = 0; i < N; ++i) {\n    l[i] = false;\n  }\n  u = 0;\n  int z = dfs(0, 0);\n  if (z != 1) {\n    cout << \"NA\" << endl;\n  } else {\n    print_ans();\n  }\n}\n\nint main() {\n  while (input()) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n\n  //if( cy >= H ) while(1);\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      //if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid output2() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n\n    if ( r0 < 0 || c0 < 0 ) return false;\n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 - 1 ); r0 < min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 - 1 ); c0 < min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cy >= H ) while(1);\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      //if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint W,H,n;\nvector<int> number;\n\nint solve = 0;\n\nstruct Rect{\n\tint x1,y1,x2,y2; \n\tRect(int a,int b,int c,int d){x1 = a , y1 = b , x2 = c, y2 = d;};\n};\nvector< vector<Rect> > data(15);\nvector< vector<int> > output(10,vector<int>(10));\nvector< vector<int> > bt(10,vector<int>(10));\n\nvoid dfs(int pos){\n\tif(solve > 2)return;\n\n\tif(pos == n){\n\t\toutput = bt;\n\t\tsolve++;\n\t\treturn;\n\t}\n\tvector< vector<int> > prev = bt;\n\t\n\trep(i,data[pos].size()){\n\t\tRect t = data[pos][i];\n\t\tbool flag = true;\n\t\tfor(int i=t.y1;i<=t.y2;i++){\n\t\t\tfor(int j=t.x1;j<=t.x2;j++){\n\t\t\t\tif(bt[i][j] != -1){\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t\tbt[i][j] = pos;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tdfs(pos+1);\n\t\t}\n\t\tbt = prev;\n\t}\n\treturn;\n}\nint main(){\n\twhile(cin >> W >> H >> n , n){\n\t\trep(i,10)rep(j,10)bt[i][j] = -1;\n\t\trep(i,15)data[i].clear();\n\t\tvector<int> k(n);\n\t\tnumber.resize(n);\n\t\trep(i,n)cin >> number[i] >> k[i];\n\t\tvector< vector<int> > map(H,vector<int>(W,0));\n\t\trep(i,H)rep(j,W)cin >> map[i][j];\n\t\trep(i,H)rep(j,W){\n\t\t\tfor(int x=j;x<W;x++){\n\t\t\t\tfor(int y=i;y<H;y++){\n\t\t\t\t\tint num = -1 , cnt = 0;\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor(int X=j;X<=x;X++){\n\t\t\t\t\t\tfor(int Y=i;Y<=y;Y++){\n\t\t\t\t\t\t\tif(map[Y][X] != 0){\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\tnum = find(number.begin(),number.end(),map[Y][X])-number.begin();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint tx = x-j+1, ty = y-i+1;\n\t\t\t\t\tif(cnt != 1 || tx * ty != k[num])continue;\n\t\t\t\t\tdata[num].push_back(Rect(j,i,x,y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve = 0;\n\t\tdfs(0);\n\t\tif(solve == 1){\n\t\t\t//cout << W << \" \" << H << endl;\n\t\t\trep(i,H){\n\t\t\t\t\trep(j,W)\n\t\t\t\t\t\tcout << (j?\" \":\"\") << number[output[i][j]];\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<20> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    Rect() {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else if(any_of(cur.begin(), cur.end(), [r,c](const Rect &re){return re.intersect(Rect(r,c,1,1));})) {\n        dfs(r, c+1, state, cur);\n    } else {\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        vector<vector<int>> res(H, vector<int>(W, 0));\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    res[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << res[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint x,y,n;\nint a[16];\nint g[10][10];\n\nint dfs(int (*c)[10],bool (*u)[10]){\n  /*\n    for(int i=0;i<y;i++){\n    for(int j=0;j<x;j++){\n      cout<<c[i][j];\n    }\n    cout<<endl;\n  }\n  cout<<\"---\"<<endl;\n  */\n  int s=0;\n  for(int i=0;i<y;i++){\n    for(int j=0;j<x;j++){\n      if(u[i][j]==false){\n\tfor(int h=0;i+h<y;h++){\n\t  int cn=0,ci;\n\t  for(int w=0;j+w<x;w++){\n\t    for(int ch=0;ch<=h;ch++){\n\t      if(c[i+ch][j+w]){\n\t\tcn++;\n\t\tci=c[i+ch][j+w];\n\t      }\n\t    }\n\t    if(cn==1){\n\t      if((h+1)*(w+1)==a[ci]){\n\t\tint n[10][10];\n\t\tcopy(c[0],c[10],n[0]);\n\t\tbool nu[10][10];\n\t\tcopy(u[0],u[10],nu[0]);\n\t\tfor(int ii=i;ii<i+h+1;ii++){\n\t\t  for(int jj=j;jj<j+w+1;jj++){\n\t\t    n[ii][jj]=ci;\n\t\t    nu[ii][jj]=true;\n\t\t  }\n\t\t}\n\t\ts+=dfs(n,nu);\n\t\tbreak;\n\t      }\n\t    }\n\t    if(cn>1){\n\t      break;\n\t    }\n\t  }\n\t}\n\treturn s;\n      }\n    }\n  }\n  copy(c[0],c[10],g[0]);\n  return 1;\n}\n\t      \n\t    \n\nint main(){\n  while(cin>>x>>y>>n,x|y|n){\n    for(int i=0;i<n;i++){\n      int b,k;\n      cin>>b>>k;\n      a[b]=k;\n    }\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tcin>>g[i][j];\n      }\n    }\n    int c[10][10];\n    copy(g[0],g[10],c[0]);\n    bool u[10][10]={};\n    if(dfs(c,u)==1){\n      for(int i=0;i<y;i++){\n\tfor(int j=0;j<x;j++){\n\t  cout<<g[i][j];\n\t}\n\tcout<<endl;\n      }\n    }else{\n      cout<<\"NA\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\ntypedef pair<int,int> pii;\ntypedef vector<vector<int> > mat;\n\nmat ans(10,vector<int>(10));\nint memo[15], memo2[15], memo3[15];\npii basyo[15];\nint X, Y, n;\nint ansnum;\n\nvoid solve(mat ba, int d) {\n  if (d == n) {\n    ans = ba;\n    ansnum++;\n    return ;\n  }\n  for (int XX=1; XX<=memo[d]; ++XX) {\n    if (memo[d] % XX) continue;\n    int YY = memo[d] / XX;\n    REP(yy, YY) {\n      REP(xx, XX) {\n        bool f = 0;\n        REP(yyy, YY) {\n          REP(xxx, XX) {\n            int x = basyo[d].first - xx + xxx;\n            int y = basyo[d].second - yy + yyy;\n\n            if (x < 0 || X <= x || y < 0 || Y <= y) {\n              f = 1;\n            } else if (ba[x][y] != d && ba[x][y] != -1)\n              f = 1;\n          }\n        }\n        // ツつ「ツつッツづゥ\n        if (!f) {\n          mat tmp = ba;\n          REP(yyy, YY) {\n            REP(xxx, XX) {\n              int x = basyo[d].first - xx + xxx;\n              int y = basyo[d].second - yy + yyy;\n              tmp[x][y] = d;\n            }\n          }\n          solve(tmp, d+1);\n        }\n      }\n    }\n  }\n}\n  \n  \nint main() {\n  mat ba(10, vector<int>(10));\n  while(cin >> X >> Y >> n, X+Y+n) {\n    vector<pii> P(n);\n    REP(i,n) {\n      int b, k;\n      cin >> b >> k;\n      P[i] = make_pair(k,b);\n    }\n    sort(ALL(P), greater<pii>());\n    REP(i,n) {\n      memo[i] = P[i].first;\n      memo2[P[i].second] = i;\n      memo3[i] = P[i].second;\n    }\n    REP(y, Y) {\n      REP(x, X) {\n        cin >> ba[x][y];\n        if (ba[x][y] > 0) {\n          ba[x][y] = memo2[ba[x][y]];\n          basyo[ba[x][y]] = pii(x,y);\n        } else\n          ba[x][y] = -1;\n      }\n    }\n    ansnum = 0;\n    solve(ba, 0);\n    if (ansnum == 1) {\n      REP(y,Y) {\n        REP(x,X) {\n          cout << memo3[ans[x][y]] << \" \";\n        }\n        cout << endl;\n      }\n    } else\n      cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef map<int, P> M;\ntypedef vector<P> V;\n\nstruct F{\n\tint a[10][10];\n};\n\nvoid acopy(int a[10][10], int b[10][10], int w, int h)\n{\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tb[i][j] = a[i][j];\n\t\t}\n\t}\n\t\n\treturn ;\n}\n\nvector<F> res;\nvoid func(F r, V vec, M mpp, int w, int h, int c)\n{\n\tif(c == vec.size()){\n\t\tres.push_back(r);\n\t} else {\n\t\tint t = vec[c].second, u = vec[c].first;\n\t\tint p = mpp[u].first, q = mpp[u].second;\n\t\tfor(int m = 1; m <= t; m++){\n\t\t\tif(t%m == 0){\n\t\t\t\tF b;\n\t\t\t\tint s = t/m;\n\t\t\t\tfor(int i = 0; i <= h-s; i++){\n\t\t\t\t\tfor(int j = 0; j <= w-m; j++){\n\t\t\t\t\t\tif(i > p || i+s <= p || j > q || j+m <= q){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tacopy(r.a, b.a, w, h);\n\t\t\t\t\t\tbool f1 = true, f2 = false;\n\t\t\t\t\t\tfor(int k = 0; k < s && f1; k++){\n\t\t\t\t\t\t\tfor(int l = 0; l < m && f1; l++){\n\t\t\t\t\t\t\t\tif(!(b.a[i+k][j+l] == 0 || b.a[i+k][j+l] == u)){\n\t\t\t\t\t\t\t\t\tf1 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(b.a[i+k][j+l] == u){\n\t\t\t\t\t\t\t\t\tf2 = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tb.a[i+k][j+l] = u;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(f1 && f2){\n\t\t\t\t\t\t\tfunc(b, vec, mpp, w, h, c+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ;\n}\n\nint main()\n{\n\tint w, h, n, s, t;\n\tF r;\n\t\n\twhile(cin>>w>>h>>n && (w+h+n)){\n\t\tV vec;\n\t\tM mpp;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s >> t;\n\t\t\tvec.push_back(P(s, t));\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> r.a[i][j];\n\t\t\t\tif(r.a[i][j] != 0){\n\t\t\t\t\tmpp[r.a[i][j]] = P(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunc(r, vec, mpp, w, h, 0);\n\t\tif(res.size() == 1){\n\t\t\tr = res[0];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tcout << r.a[i][0];\n\t\t\t\tfor(int j = 1; j < w; j++){\n\t\t\t\t\tcout << \" \" << r.a[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t} else {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\t\n\t\tres.clear();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n#define PUT 0\n#define REMOVE 1\n#define CHECK_PLANE 2\n\nint cnt;\nint m[10][10];\nint ans[10][10];\n\nbool is_origin[10][10];\nbool make_rect(int now,int x,int y,int width,int height,int flag,\n\t       int r,int c){\n  rep(i,height){\n    rep(j,width){\n      if ( flag == PUT )m[y+i][j+x]=now;\n      else if ( flag == REMOVE && is_origin[y+i][x+j] == false){\n\tm[y+i][j+x]=0;\n      }else if (flag == CHECK_PLANE){\n\tif ( m[y+i][j+x]!=0 && m[y+i][j+x]!=now)return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid solve(int num,int now,int *number,int *x,int *y,int *size,int r,int c){\n  if ( now == num){\n    cnt++;\n    rep(i,r)rep(j,c)ans[i][j]=m[i][j];\n    return;\n  }\n\n  if ( cnt > 1)return;\n  \n  int cur=number[now];\n  REP(k,1,size[now]+1 && cnt <1){\n    if ( size[now]%k != 0)continue;\n    int h=k,w=size[now]/k;\n    int hstart=max(0,y[now]-h+1),wstart=max(0,x[now]-w+1);\n    REP(i,hstart,y[now]+1 && i+h <=r && cnt < 1){\n      REP(j,wstart,x[now]+1 && j+w <=c && cnt < 1){\n\tif ( make_rect(cur,j,i,w,h,CHECK_PLANE,r,c) ){\n\t  make_rect(cur,j,i,w,h,PUT,r,c);\n\t  solve(num,now+1,number,x,y,size,r,c);\n\t  make_rect(cur,j,i,w,h,REMOVE,r,c);\n\t}\n      }\n    }\n  }\n}\n\n\nmain(){\n  int c,r,n;\n  while(cin>>c>>r>>n && c){\n    pair<int,int> in[n];\n    int x[n],y[n],size[n],tmp[100+1],num[100+1];\n    rep(i,n)cin>>in[i].second>>in[i].first;\n    sort(in,in+n,greater<pair<int,int> >());\n    rep(i,n)tmp[in[i].second]=i,size[i]=in[i].first,num[i]=in[i].second;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif ( m[i][j] != 0){\n\t  x[tmp[m[i][j]]]=j;\n\t  y[tmp[m[i][j]]]=i;\n\t  is_origin[i][j]=true;\n\t}\n\tis_origin[i][j]=false;\n      }\n    }\n    cnt = 0;\n\n    solve(n,0,num,x,y,size,r,c);\n    if ( cnt == 1){\n      rep(i,r){\n\trep(j,c){\n\t  if ( j)cout << ' ';\n\t  cout <<ans[i][j];\n\t}\n\tcout << endl;\n      }\n    }else cout << \"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,land[10][10],test[10][10],ans[10][10];\n\nbool search(int i0,int j0){\n//printf(\"i0=%d, j0=%d\\n\",i0,j0);\n//for(int a=0;a<h;a++){for(int b=0;b<w;b++)printf(\"%d \",test[a][b]);puts(\"\");}puts(\"\");\n\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\nif(i<0 || h<=i || j<0 || w<=j)\twhile(1);\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\n\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tans[i][j]=test[i][j];}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1,vpii());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);}\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<20> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    Rect() : r(0), c(0), h(0), w(0) {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else {\n        bool conquered = false;\n        for(int i = 0; i < N; ++i) {\n            if(!state[i]) continue;\n            if(cur[i].intersect(Rect(r, c, 1, 1))) {\n                conquered = true;\n                break;\n            }\n        }\n        if(conquered) {\n            dfs(r, c+1, state, cur);\n            return;\n        }\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    bool na = false;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n        if(b-1 >= N) na = true;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    if(na) {\n        cout << \"NA\" << endl;\n        return true;\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define MAX 10\n\nstruct Cell{ int i, j, x, id; };\n\nint H, W, n, b, k; \nCell P[MAX*MAX], M[MAX][MAX], A[MAX][MAX];\nint V[MAX+1];\n\nint ans;\n\nbool check(int si, int sj, int r, int c ){\n    rep(i, r) rep(j, c){\n\tint ii = si + i;\n\tint jj = sj + j;\n\tif ( ii < 0 || jj < 0 || ii >= H || jj >= W ) return false;\n\tif ( M[ii][jj].x ) return false;\n    }\n    return true;\n}\n\nvoid solve(int pos){\n    if ( pos >= n ){ \n\trep(i, H) rep(j, W) if ( M[i][j].x == 0 ) return;\n\trep(i, H) rep(j, W) A[i][j] = M[i][j];\n\tans++;\n\treturn;\n    }\n\n    for(int r = 1; r <= P[pos].x; r++){\n\tif ( P[pos].x % r != 0 ) continue;\n\tint c = P[pos].x / r;\n\trep(di, r) rep(dj, c){\n\t    int si = P[pos].i - di;\n\t    int sj = P[pos].j - dj;\n\t    if ( check( si, sj,  r, c ) ){\n\t\trep(i, r) rep(j, c) M[si+i][sj+j] = P[pos];\n\t\tsolve( pos + 1 );\n\t\trep(i, r) rep(j, c) M[si+i][sj+j].x = 0;\n\t    }\n\t}\n    }\n}\n\nint main(){\n    int x;\n    while( cin >> W >> H && H && W ){\n\tcin >> n;\n\trep(i, n){\n\t    cin >> b >> k;\n\t    P[b-1].x = k;\n\t}\n\n\trep(i, H) rep(j, W){\n\t    cin >> x;\n\t    if ( x ){  P[x-1].i = i; P[x-1].j = j; P[x-1].id = x-1; }\n\t    M[i][j].x = 0;\n\t}\n\tans = 0;\n\tsolve(0);\n\tif ( ans == 1 ) {\n\t    rep(i, H){\n\t\trep(j, W){\n\t\t    if ( j ) cout << \" \";\n\t\t    cout << A[i][j].id+1;\n\t\t}\n\t\tcout << endl;\n\t    }\n\t} else {\n\t    cout << \"NA\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint X, Y, n;\nint id[10], k[10];\nint sx[11], sy[11];\nint bd[10][10];\n\nvector<pair<int,int> > area[101];\nint ans[10][10];\n\nint dfs(int u) {\n\tif (u == n) {\n\t\tmemcpy(ans, bd, sizeof ans);\n\t\treturn 1;\n\t}\n\tint h, w, tx, ty, lx, rx, uy, dy;\n\ttx = sx[id[u]];\n\tty = sy[id[u]];\n\tbd[ty][tx] = 0;\n\tint ret = 0;\n\tfor (int i=0; i<(int)area[k[u]].size(); ++i) {\n\t\th = area[k[u]][i].first;\n\t\tw = area[k[u]][i].second;\n\t\tlx = max(tx-w+1, 0);\n\t\trx = min(tx+w-1, X-1);\n\t\tuy = max(ty-h+1, 0);\n\t\tdy = min(ty+h-1, Y-1);\n\t\tif (rx-lx+1 < w || dy-uy+1 < h) continue;\n\t\tfor (int y=uy; y+h-1<=dy; ++y) {\n\t\t\tfor (int x=lx; x+w-1<=rx; ++x) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int y2=y; y2<y+h && ok; ++y2) {\n\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\tif (bd[y2][x2] != 0) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tfor (int y2=y; y2<y+h; ++y2) {\n\t\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\t\tbd[y2][x2] = id[u];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += dfs(u+1);\n\t\t\t\t\tfor (int y2=y; y2<y+h; ++y2) {\n\t\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\t\tbd[y2][x2] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (2 <= ret) return 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbd[ty][tx] = id[u];\n\treturn ret;\n}\n\nint main() {\n\tfor (int i=1; i<=10; ++i) {\n\t\tfor (int j=1; j<=10; ++j) {\n\t\t\tarea[i*j].push_back(make_pair(i, j));\n\t\t}\n\t}\n\twhile (cin >> X >> Y >> n, X) {\n\t\tint sum = 0;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> id[i] >> k[i];\n\t\t\tsum += k[i];\n\t\t}\n\t\tfor (int i=0; i<Y; ++i) {\n\t\t\tfor (int j=0; j<X; ++j) {\n\t\t\t\tcin >> bd[i][j];\n\t\t\t\tif (bd[i][j] != 0) {\n\t\t\t\t\tsx[bd[i][j]] = j;\n\t\t\t\t\tsy[bd[i][j]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = dfs(0);\n\t\tif (X * Y != sum || res == 0 || 2 <= res) {\n\t\t\tcout << \"NA\\n\";\n\t\t} else {\n\t\t\tfor (int i=0; i<Y; ++i) {\n\t\t\t\tfor (int j=0; j<X; ++j) {\n\t\t\t\t\tcout << (j == 0 ? \"\" : \" \") << ans[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\nbool use[16];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j] && !use[ok[y][x][i][j]]) {\n\t\t\t\tuse[ok[y][x][i][j]] = true;\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t\tuse[ok[y][x][i][j]] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tout.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n\t\tfor(int i = 0; i < 16; i++)\n\t\t\tuse[i] = false;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = i; y <= k && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = j; x <= l && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt != 1) ok[i][j][k][l] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < v.size(); i++) sum += v[i];\n\t\tif(res == 1 && sum == X*Y) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int W, H, N; \n  while (scanf(\"%d %d %d\", &W, &H, &N) != EOF && (W|H|N)) {\n    REP(i, N) {\n      int f, v;\n      scanf(\"%d %d\", &f, &v);\n    }\n    vector<bool> exist(N, false);\n    REP(y, H) {\n      REP(x, W) {\n        int t;\n        scanf(\"%d\", &t);\n        if(t > 0) exist[t - 1] = true;\n      }\n    }\n    REP(i, N) assert(exist[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <math.h>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Data{\n\tData(int arg_num1,int arg_num2){\n\t\tnum1 = arg_num1;\n\t\tnum2 = arg_num2;\n\t}\n\tint num1,num2;\n};\n\nstruct Info{\n\tint tmp_table[10][10];\n\tint state;\n};\n\nstruct Kanban{\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nint H,W,N;\nint table[16],POW[16];\nint ans_table[10][10];\nvector<Data> DATA[101];\nKanban kanban[16];\n\n\nvoid func(){\n\n\tint id,area,sum_area = 0;\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&id,&area);\n\t\ttable[id] = area;\n\t\tsum_area += area;\n\t}\n\n\tInfo first;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first.tmp_table[row][col]);\n\t\t\tif(first.tmp_table[row][col] > 0){\n\t\t\t\tkanban[first.tmp_table[row][col]].set(row,col);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(sum_area != H*W){\n\t\tprintf(\"NA\\n\");\n\t\treturn;\n\t}\n\n\tfirst.state = 0;\n\n\tint ans_num = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint finish = POW[N]-1;\n\tint kado_row,kado_col;\n\tbool FLG;\n\tint width,height;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().state == finish){\n\t\t\tif(ans_num == 1){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans_num = 1;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tans_table[row][col] = Q.front().tmp_table[row][col];\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tkado_row = -1;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif((Q.front().tmp_table[row][col] == 0) || (Q.front().state & (1 << (Q.front().tmp_table[row][col]-1))) == 0){\n\t\t\t\t\t\tkado_row = row;\n\t\t\t\t\t\tkado_col = col;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(kado_row != -1)break;\n\t\t\t}\n\n\t\t\tfor(int loop = 1; loop <= N; loop++){\n\t\t\t\tif(Q.front().state & (1 << (loop-1)))continue;\n\n\n\t\t\t\tfor(int i = 0; i < DATA[table[loop]].size(); i++){\n\t\t\t\t\twidth = DATA[table[loop]][i].num1;\n\t\t\t\t\theight = DATA[table[loop]][i].num2;\n\n\t\t\t\t\tif(kado_row+height-1 >= H || kado_col+width-1 >= W)continue;\n\t\t\t\t\tif(kanban[loop].col < kado_col || kanban[loop].col > kado_col+width-1\n\t\t\t\t\t\t\t|| kanban[loop].row < kado_row || kanban[loop].row > kado_row+height-1)continue;\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int row = kado_row; row <= kado_row+height-1; row++){\n\t\t\t\t\t\tfor(int col = kado_col; col <= kado_col+width-1; col++){\n\t\t\t\t\t\t\tif(Q.front().tmp_table[row][col] != 0 && Q.front().tmp_table[row][col] != loop){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tInfo next_info;\n\t\t\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\t\t\tfor(int col = 0; col < W; col++)next_info.tmp_table[row][col] = Q.front().tmp_table[row][col];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int row = kado_row; row <= kado_row+height-1; row++){\n\t\t\t\t\t\tfor(int col = kado_col; col <= kado_col+width-1; col++){\n\t\t\t\t\t\t\tnext_info.tmp_table[row][col] = loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnext_info.state = Q.front().state+POW[loop-1];\n\t\t\t\t\tQ.push(next_info);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(ans_num == 1){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tprintf(\"%d\",ans_table[row][col]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n\n}\n\n\nint main(){\n\n\tfor(int num = 1; num <= 100; num++){\n\t\tfor(int k = 1; k <= num; k++){\n\t\t\tif(num%k == 0){\n\t\t\t\tDATA[num].push_back(Data(k,num/k));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 16; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&W,&H,&N);\n\t\tif(W == 0 && H == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint W, H, N; \nint b[16], k[16];\nint s[10][10];\nint ans[10][10];\nint used[10][10];\nint TX[20], TY[20];\nclass DFSError {};\nvoid dfs(int idx){\n  if(idx == N) {\n    if(ans[0][0] != -1) throw DFSError();\n    REP(y, H)REP(x, W) ans[y][x] = used[y][x];\n    return;\n  }\n  /*\n  printf(\"idx = %d\\n\", idx);\n  REP(y, H){\n    REP(x, W){\n      cout << used[y][x];\n      if(x != W - 1) cout << \" \";\n      else cout << endl;\n    }\n  }\n  */\n  int tx = TX[b[idx] - 1];\n  int ty = TY[b[idx] - 1];\n  //printf(\"idx = %d tx = %d ty = %d\\n\", idx, tx, ty);\n  \n  assert(idx < N);\n  assert(b[idx] >= 1 && b[idx] <= N);\n  assert(tx != -1);\n  for(int h = 1; h <= k[idx]; h++) if(k[idx] % h == 0){\n    int w = k[idx] / h;\n    for(int by = 0; by > -h; by--) for(int bx = 0; bx > -w; bx--){\n      int sx = tx + bx;\n      int sy = ty + by;\n      bool ok = true;\n      for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n        if(!valid(sx + x, sy + y, W, H) || used[sy + y][sx + x] != -1) ok = false;\n      }\n      if(ok){\n        int tmp[10][10];\n        memcpy(tmp, used, sizeof(used));\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n          used[sy + y][sx + x] = b[idx];\n        }\n        dfs(idx + 1);\n        memcpy(used, tmp, sizeof(used));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H >> N && (W | H | N)){\n    REP(i, N) cin >> b[i] >> k[i];\n    REP(y, H)REP(x, W) cin >> s[y][x];\n    try{\n      memset(used, -1, sizeof(used));\n      memset(ans, -1, sizeof(ans));\n      memset(TX, -1, sizeof(TX));\n      memset(TY, -1, sizeof(TY));\n      REP(y, H) REP(x, W) if(s[y][x] > 0) TX[s[y][x] - 1] = x, TY[s[y][x] - 1] = y;\n      REP(i, N) assert(TX[i] != -1);\n      dfs(0);\n      if(ans[0][0] == -1) throw DFSError();\n      REP(y, H){\n        REP(x, W){\n          cout << ans[y][x];\n          if(x != W - 1) cout << \" \";\n          else cout << endl;\n        }\n      }\n    }catch(...){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,n,land[50][50],test[50][50],ans[50][50];\n\nbool search(int i0,int j0){\n//printf(\"i0=%d, j0=%d\\n\",i0,j0);\n//for(int a=0;a<h;a++){for(int b=0;b<w;b++)printf(\"%d \",test[a][b]);puts(\"\");}puts(\"\");\n\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\nif(i<0 || h<=i || j<0 || w<=j)\texit(0);\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\nif(id<0 || n<id)\texit(0);\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tans[i][j]=test[i][j];}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);}\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstring>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair < int , int > Pi;\ntypedef pair < int , Pi > Pii;\n\nint h, w, n, ans[10][10];\nvector< Pii > memo;\n\nint wy, wx;\ninline void plus_n( int y, int x, int nt){\n  wy = y;\n  wx = ( x + nt ) % w;\n  if(!wx) wy++;\n  return ;\n}\n//なんでconstが値変わるの?(困惑)\nint dfs( const int mas[][10], const int used, const int y, const int x){\n  if( y == h){ //exit\n    memcpy( ans, mas, sizeof(mas));\n    return 1;\n  }\n  int ret = 0;\n  if( !mas[y][x]){\n    plus_n( y, x, 1);\n    ret += dfs( mas, used, wy, wx);\n  }else{\n    for(int bit = 0 ; bit < n ; bit++ ){\n      if( (used >> bit) & 1 ) continue; // もうやってある\n\n      for(int i = 1 ; i <= memo[bit].fr ; i++ ){ //高さ決定\n        if( memo[bit].fr % i != 0 ) continue; // 長方形無理\n        int height = i, width = memo[bit].fr / i;\n\n        if( y <= memo[bit].sc.fr && y > memo[bit].sc.fr - height &&\n            x <= memo[bit].sc.sc && x > memo[bit].sc.sc - width &&\n            y + height - 1 < h && x + width - 1 < w){\n          int java[10][10];\n          bool ok = true;\n          memcpy( java, mas, sizeof(mas));\n          for(int j = 0 ; j < height ; j++ ){\n            for(int k = 0 ; k < width ; k++ ){\n              if(java[j + y][k + x]) ok = false;\n              java[j + y][k + x] = bit + 1;\n            }\n          }\n          if(ok){\n            plus_n( y, x, width);\n            ret += dfs( java, used|(1<<bit), wy, wx);\n          }\n        }\n      }\n    }\n  }\n  return ret;\n}\nint main(){\n  while(cin >> w >> h >> n , w){\n    memo.resize( n);\n    for(int i = 0, bf ; i < n ; i++ ){\n      cin >> bf;\n      cin >> memo[bf - 1].fr;\n    }\n    for(int i = 0, c ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        cin >> c;\n        if(c)memo[c - 1].sc = Pi( i, j);\n      }\n    }\n    int mas[10][10] = {{}};\n    if(dfs( mas, 0, 0, 0) == 1){\n      for(int i = 0 ; i < h ; i++ ){\n        for(int j = 0 ; j < w ; j++ ){\n          cout << ( j ? \" \" : \"\" ) << ans[i][j];\n        }\n        cout << endl;\n      }\n    }else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nqueue<pair<int, vector<vector<int> > > >Q;\nvector<vector<int>>X, P; int H, W, N, V1[10], V2[10];\npair<bool, vector<vector<int> > > hantei(vector<vector<int> >a1, int X1, int Y1, int H1, int W1, int N1) {\n\tbool OK = true;\n\tfor (int i = X1; i < X1 + H1; i++) {\n\t\tfor (int j = Y1; j < Y1 + W1; j++) {\n\t\t\tif (i >= H || j >= W) { OK = false; continue; }\n\t\t\tif (a1[i][j] != 0 || (X[i][j] != V1[N1] && X[i][j] >= 1))OK = false;\n\t\t\ta1[i][j] = V1[N1];\n\t\t}\n\t}\n\treturn make_pair(OK, a1);\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H >> N; if (W == 0 && H == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; i++) { cin >> V1[i] >> V2[i]; }\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tvector<int>G, I; int a;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a; G.push_back(a); I.push_back(0);\n\t\t\t}\n\t\t\tX.push_back(G); P.push_back(I);\n\t\t}\n\t\tQ.push(make_pair(0, P)); vector<vector<int> >res; int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tvector<vector<int>>K = Q.front().second;\n\t\t\tint L = Q.front().first; Q.pop();\n\t\t\tif (L == N) { cnt++; res = K; }\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 1; k <= V2[L]; k++) {\n\t\t\t\t\t\tif (V2[L] % k != 0)continue;\n\t\t\t\t\t\tpair<bool, vector<vector<int> > >res1 = hantei(K, i, j, k, V2[L] / k, L);\n\t\t\t\t\t\tif (res1.first == true) { Q.push(make_pair(L + 1, res1.second)); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0 || cnt >= 2)cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (j >= 1) { cout << ' '; }cout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n    \n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid output2() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 ); r0 <= min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 ); c0 <= min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nint T[20][20];\nint TC[20][20];\nint K[20]; \nII U[20]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[20][20];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[k] % w0 != 0 ) continue;\n        int h0 = K[k] / w0;\n        for ( int r0 = 0; r0 < h; ++ r0 ) {\n            for ( int c0 = 0; c0 < w; ++ c0 ) {\n                if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                    for ( int i = 0; i < h; ++ i ) {\n                        for ( int j = 0; j < w; ++ j ) {\n                            T[i][j] = Tcopy[i][j];\n                        }\n                    }\n                    if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                    if ( cnt >= 2 ) return;\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nvoid output1() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint H, W, n, input[15], data[10][10], map[10][10], px[15], py[15];\nbool ans;\n\nbool check(int y, int x){\n  if(y<0 || y>=H) return false;\n  if(x<0 || x>=W) return false;\n  return true;\n}\n\nbool settable(int y, int x, int h, int w){\n  for(int i=y;i<y+h;i++){\n    for(int j=x;j<x+w;j++){\n      if(data[i][j]) return false;\n    }\n  }\n  return true;\n}\n\nvoid setPanel(int y, int x, int h, int w, int p){\n  for(int i=y;i<y+h;i++){\n    for(int j=x;j<x+w;j++){\n      data[i][j] = p;\n    }\n  }\n}\n\nbool finish(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(data[i][j] == 0) return false;\n    }\n  }\n  return true;\n}\n\nbool solve(int p){\n  if(p == -1){\n    if(finish()){\n      if(ans) return true;\n      ans = true;\n      for(int i=0;i<H;i++) for(int j=0;j<W;j++) map[i][j] = data[i][j];\n    }\n    return false;\n  }\n  for(int h=1;h<=input[p];h++){\n    if(input[p] % h != 0) continue;\n    int w = input[p] / h;\n    for(int i=py[p]-h+1;i<=py[p];i++){\n      for(int j=px[p]-w+1;j<=px[p];j++){\n        if(!check(i, j)) continue;\n        data[py[p]][px[p]] = 0;\n        if(settable(i, j, h, w)){\n          setPanel(i, j, h, w, p+1);\n          if(solve(p-1)) return true;\n          setPanel(i, j, h, w, 0);\n        }\n        data[py[p]][px[p]] = p+1;\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  while(cin >> W >> H >> n && (W|H|n)){\n    for(int i=0;i<n;i++){\n      int a, b;\n      cin >> a >> b;\n      input[a-1] = b;\n    }\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin >> data[i][j];\n        if(data[i][j] != 0){\n          px[data[i][j]-1] = j;\n          py[data[i][j]-1] = i;\n        }\n      }\n    }\n    ans = false;\n    if(!solve(n-1) && ans){\n      for(int i=0;i<H;i++){\n        cout << map[i][0];\n        for(int j=1;j<W;j++){\n          cout << ' ' << map[i][j];\n        }\n        cout << endl;\n      }\n    }else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint field[11][11];\nint land[20];\npair<int,int> place[20];\n\nint w,h,n;\nbool ok;\n\nstruct landInfo{\n\tint minx;\n\tint miny;\n\tint maxy;\n\tint maxx;\n};\n\nlandInfo mem[20];\nlandInfo fin[20];\n\nbool no=false;\n\nvoid dfs(int num,int sum){\n\tif(no)\n\t\treturn;\n\tif(num==n+1){\n\t\tif(sum==h*w){\n\t\t\tif(ok){\n\t\t\t\tno=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tok=true;\n\t\t\t\tfor(int i = 1; i < num; i++){\n\t\t\t\t\tfin[i]=mem[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\telse{\n\t\t// ßûð·×ÄµÄÝé\n\t\tfor(int i = 1; i <= land[num]; i++){\n\t\t\tif(land[num]%i!=0)\n\t\t\t\tcontinue;\n\t\t\tint tate=i;\n\t\t\tint yoko=land[num]/i;\n\t\t\t// Ç±É»ÝÌynÌÔÌÊuðÁÄ­é©\n\t\t\tfor(int j = 0; j < tate; j++){\n\t\t\t\tfor(int k = 0; k < yoko; k++){\n\t\t\t\t\t// ÍÝoÄÈ¯êÎAßé\n\t\t\t\t\tint minx=place[num].second-k;\n\t\t\t\t\tint miny=place[num].first-j;\n\t\t\t\t\tint maxx=minx+yoko-1;\n\t\t\t\t\tint maxy=miny+tate-1;\n\t\t\t\t\tif(minx>=0&&miny>=0&&minx<w&&miny<h&&maxx>=0&&maxy>=0&&maxx<w&&maxy<h){\n\t\t\t\t\t\t// àµ¼ÌynÌÍÍÆðíÁÄ¢È¯êÎ\n\t\t\t\t\t\tvector<pair<int,int> > ps;\n\t\t\t\t\t\tps.push_back(make_pair(miny,minx));\n\t\t\t\t\t\tps.push_back(make_pair(miny,maxx));\n\t\t\t\t\t\tps.push_back(make_pair(maxy,minx));\n\t\t\t\t\t\tps.push_back(make_pair(maxy,maxx));\n\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int l = 1; l < num; l++){\n\t\t\t\t\t\t\tif((maxx<mem[l].minx||maxy<mem[l].miny)||(minx>mem[l].maxx||miny>mem[l].maxy)){\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f){\n\t\t\t\t\t\t\tlandInfo li;\n\t\t\t\t\t\t\tli.minx=minx;\n\t\t\t\t\t\t\tli.maxx=maxx;\n\t\t\t\t\t\t\tli.miny=miny;\n\t\t\t\t\t\t\tli.maxy=maxy;\n\t\t\t\t\t\t\tmem[num]=li;\n\t\t\t\t\t\t\tdfs(num+1,sum+land[num]);\n\t\t\t\t\t\t\tif(no)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h>>n&&!(w==0&&h==0&&n==0)){\n\t\tok=false;\n\t\tno=false;\n\t\tint b,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>b>>k;\n\t\t\tland[b]=k;\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]!=0){\n\t\t\t\t\tplace[field[i][j]].first=i;\n\t\t\t\t\tplace[field[i][j]].second=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ÔÉynðßÄ¢­\n\t\tdfs(1,0);\n\t\tif(ok&&!no){\n\t\t\tfor(int i = 1; i <= n; i++){ \n\t\t\t\tfor(int j = fin[i].miny; j <= fin[i].maxy; j++){\n\t\t\t\t\tfor(int k = fin[i].minx; k <= fin[i].maxx; k++){\n\t\t\t\t\t\tfield[j][k]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tcout<<field[i][j];\n\t\t\t\t\tif(j!=w-1)\n\t\t\t\t\t\tcout<<\" \";\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint X,Y,N;\nint b[100], k[100];\nint c[10][10], f[10][10];\nint ans[10][10];\nint cnt;\n\nvector<int> bx[101],by[101];\n\nbool isputs(int x, int y, int n, int a, int b)\n{\n\tif(x+bx[a][b] > X || y+by[a][b] > Y) return false;\n\n\tfor(int i=y; i<y+by[a][b]; i++)\n\tfor(int j=x; j<x+bx[a][b]; j++)\n\t{\n\t\tif(c[j][i]!=0 && c[j][i]!=n) return false;\n\t\tif(f[j][i]!=0) return false;\n\n\t\tf[j][i]=n;\n\t}\n\t\n\treturn true;\n}\n\nbool dfs(int n)\n{\n\tif(n==N) \n\t{\n\t\tcnt++;\n\t\tmemcpy(ans, f, sizeof(ans));\n\t}\n\n\tint p=b[n], a=k[n];\n\tint t[10][10];\n\tmemcpy(t,f,sizeof(t));\n\n\tfor(int i=0; i<Y; i++)\n\tfor(int j=0; j<X; j++)\n\tfor(int l=0; l<bx[a].size(); l++)\t\n\t{\n\t\tif(isputs(j,i,p,a,l)) if(dfs(n+1)) return true;\n\n\t\tmemcpy(f,t,sizeof(f));\n\t}\n\t\n\treturn false;\n}\n\n\nint main()\n{\n\tfor(int x=1; x<=10; x++)\n\tfor(int y=1; y<=10; y++)\n\t{\n\t\tint n=x*y;\n\t\tbx[n].push_back(x);\n\t\tby[n].push_back(y);\n\t}\n\n\twhile(cin >> X >> Y >> N, (X||Y||N))\n\t{\n\t\tcnt=0;\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> b[i] >> k[i];\n\t\n\t\tfor(int i=0; i<Y; i++)\n\t\tfor(int j=0; j<X; j++)\n\t\t\tcin >> c[j][i];\n\n\t\tmemset(f,0,sizeof(f));\n\t\t\n\t\tdfs(0);\n\t\tif(cnt == 1)\n\t\t{\n\t\t\tfor(int i=0; i<Y; i++)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<X; j++)\n\t\t\t\t\tcout << ans[j][i] << \" \";\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse cout << \"NA\" << endl;\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define repn(i, m, n) for (int i = m; i < int(n); ++i)\n\nint bk[16];\nint mp[10][10];\nint res[10][10];\nint result[10][10];\nint xy[16][2];\nint x, y ,n;\n\nint solve(int used[], int bit) {\n  if (bit == 0) {\n    rep (i, y) rep (j, x) result[i][j] = res[i][j];\n    return 1;\n  }\n  int xx, yy;\n  rep (i, y) {\n    if (__builtin_popcount(used[i]) == x) continue;\n    yy = i;\n    xx = __builtin_popcount((~used[i] & -~used[i]) - 1);\n    break;\n  }\n  int r = 0;\n  rep (i, 16) {\n    if ((bit & 1 << i) == 0) continue;\n    if (xy[i][1] < xx) continue;\n    repn (j, xy[i][1] - xx + 1, x - xx + 1) {\n      if (bk[i] % j > 0) continue;\n      if (yy + bk[i] / j > y) continue;\n      if (yy + bk[i] / j <= xy[i][0]) continue;\n      int bb = (1 << (xx + j)) - (1 << xx);\n      bool ok = true;\n      rep (k, bk[i] / j) {\n\tif (used[yy + k] & bb) {\n\t  ok = false;\n\t  break;\n\t}\n      }\n      if (!ok) continue;\n      int next[10];\n      rep (k, y) {\n\tnext[k] = used[k];\n      }\n      rep (k, bk[i] / j) {\n\trep (l, j) {\n\t  res[yy + k][xx + l] = i;\n\t}\n\tnext[yy + k] |= bb;\n      }\n      r += solve(next, bit ^ 1 << i);\n      if (r > 1) return r;\n    }\n  }\n  return r;\n}\n\nint main() {\n  int used[10], sum;\n  for (;;) {\n    cin >> x >> y >> n;\n    if (x == 0 && y == 0 && n == 0) break;\n    sum = 0;\n    memset(bk, -1, sizeof(bk));\n    rep (i, n) {\n      int b, k;\n      cin >> b >> k;\n      bk[b] = k;\n      sum += k;\n    }\n    if (sum != x * y) {\n      cout << \"NA\\n\";\n      continue;\n    }\n    memset(xy, -1, sizeof(xy));\n    int bit = 0;\n    rep (i, y) rep (j, x) {\n      cin >> mp[i][j];\n      if (mp[i][j] > 0) {\n\txy[mp[i][j]][0] = i;\n\txy[mp[i][j]][1] = j;\n\tbit |= 1 << mp[i][j];\n      }\n    }\n    rep (i, 16) {\n      assert(!(bk[i] > 0 && xy[i][0] < 0)); \n    }\n    memset(used, 0, sizeof(used));\n    int r = solve(used, bit);\n    if (r == 1) {\n      rep (i, y) {\n\trep (j, x - 1) cout << result[i][j] << \" \";\n\tcout << result[i][x - 1] << endl;\n      }\n    } else {\n      cout << \"NA\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nqueue<pair<int, vector<vector<int> > > >Q;\nvector<vector<int>>X, P; int H, W, N, V1[20], V2[20];\npair<bool, vector<vector<int> > > hantei(vector<vector<int> >a1, int X1, int Y1, int H1, int W1, int N1) {\n\tbool OK = true;\n\tfor (int i = X1; i < X1 + H1; i++) {\n\t\tfor (int j = Y1; j < Y1 + W1; j++) {\n\t\t\tif (i >= H || j >= W) { OK = false; continue; }\n\t\t\tif (a1[i][j] != 0 || (X[i][j] != V1[N1] && X[i][j] >= 1))OK = false;\n\t\t\ta1[i][j] = V1[N1];\n\t\t}\n\t}\n\treturn make_pair(OK, a1);\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H >> N; if (W == 0 && H == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; i++) { cin >> V1[i] >> V2[i]; }\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tvector<int>G, I; int a;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a; G.push_back(a); I.push_back(0);\n\t\t\t}\n\t\t\tX.push_back(G); P.push_back(I);\n\t\t}\n\t\tQ.push(make_pair(0, P)); vector<vector<int> >res; int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tvector<vector<int>>K = Q.front().second;\n\t\t\tint L = Q.front().first; Q.pop();\n\t\t\tif (L == N) { cnt++; res = K; }\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 1; k <= V2[L]; k++) {\n\t\t\t\t\t\tif (V2[L] % k != 0)continue;\n\t\t\t\t\t\tpair<bool, vector<vector<int> > >res1 = hantei(K, i, j, k, V2[L] / k, L);\n\t\t\t\t\t\tif (res1.first == true) { Q.push(make_pair(L + 1, res1.second)); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0 || cnt >= 2)cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (j >= 1) { cout << ' '; }cout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n#define PUT 0\n#define REMOVE 1\n#define CHECK_PLANE 2\n\nint cnt;\nint m[10][10];\nint ans[10][10];\n\nbool is_origin[10][10];\nbool make_rect(int now,int x,int y,int width,int height,int flag,\n\t       int r,int c){\n  rep(i,height){\n    rep(j,width){\n      if ( flag == PUT )m[y+i][j+x]=now;\n      else if ( flag == REMOVE && is_origin[y+i][x+j] == false){\n\tm[y+i][j+x]=0;\n      }else if (flag == CHECK_PLANE){\n\tif ( m[y+i][j+x]!=0 && m[y+i][j+x]!=now)return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid solve(int num,int now,int *number,int *x,int *y,int *size,int r,int c){\n  if ( now == num){\n    cnt++;\n    rep(i,r)rep(j,c)ans[i][j]=m[i][j];\n    return;\n  }\n\n  if ( cnt > 1)return;\n  \n  int cur=number[now];\n  REP(k,1,size[now]+1 && cnt <2){\n    if ( size[now]%k != 0)continue;\n    int h=k,w=size[now]/k;\n    int hstart=max(0,y[now]-h+1),wstart=max(0,x[now]-w+1);\n    REP(i,hstart,y[now]+1 && i+h <=r && cnt < 2){\n      REP(j,wstart,x[now]+1 && j+w <=c && cnt < 2){\n\tif ( make_rect(cur,j,i,w,h,CHECK_PLANE,r,c) ){\n\t  make_rect(cur,j,i,w,h,PUT,r,c);\n\t  solve(num,now+1,number,x,y,size,r,c);\n\t  make_rect(cur,j,i,w,h,REMOVE,r,c);\n\t}\n      }\n    }\n  }\n}\n\n\nmain(){\n  int c,r,n;\n  while(cin>>c>>r>>n && c){\n    pair<int,int> in[n];\n    int x[n],y[n],size[n],tmp[100+1],num[100+1];\n    rep(i,n)cin>>in[i].second>>in[i].first;\n    sort(in,in+n,greater<pair<int,int> >());\n    rep(i,n)tmp[in[i].second]=i,size[i]=in[i].first,num[i]=in[i].second;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif ( m[i][j] != 0){\n\t  x[tmp[m[i][j]]]=j;\n\t  y[tmp[m[i][j]]]=i;\n\t  is_origin[i][j]=true;\n\t}\n\tis_origin[i][j]=false;\n      }\n    }\n    cnt = 0;\n\n    solve(n,0,num,x,y,size,r,c);\n    if ( cnt == 1){\n      rep(i,r){\n\trep(j,c){\n\t  if ( j)cout << ' ';\n\t  cout <<ans[i][j];\n\t}\n\tcout << endl;\n      }\n    }else cout << \"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,h,n,a[16],m[10][10],bx[16],by[16],mans[10][10],ans;\nvoid dfs(int c){\n\tif(c==n+1){\n\t\trep(i,h)rep(j,w)mans[i][j]=m[i][j];\n\t\tans++;return;\n\t}\n\tfor(int i=1;i<=a[c];i++)if(a[c]%i==0){\n\t\tint x=i,y=a[c]/i;\n\t\trep(j,x)rep(k,y){\n\t\t\tint l=bx[c]-j,r=l+x,t=by[c]-k,b=t+y;\n\t\t\tif(l<0||r>w||t<0||b>h)continue;\n\t\t\tfor(int ii=l;ii<r;ii++)for(int jj=t;jj<b;jj++)if(m[jj][ii]!=0&&m[jj][ii]!=c)goto NEXT;\n\t\t\tfor(int ii=l;ii<r;ii++)for(int jj=t;jj<b;jj++)m[jj][ii]=c;\n\t\t\tdfs(c+1);\n\t\t\tfor(int ii=l;ii<r;ii++)for(int jj=t;jj<b;jj++)m[jj][ii]=0;\n\t\t\tm[by[c]][bx[c]]=c;\n\t\t\tNEXT:;\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>w>>h>>n,w){\n\t\tint t,u,sum=0;\n\t\trep(i,n)cin>>t>>u,a[t]=u,sum+=u;\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>t;m[i][j]=t;\n\t\t\tif(t!=0)bx[t]=j,by[t]=i;\n\t\t}\n\t\tif(sum!=w*h)goto FAIL;\n\t\tans=0;dfs(1);\n\t\tif(ans==1){\n\t\t\trep(i,h)rep(j,w)cout<<mans[i][j]<<(j==w-1?'\\n':' ');\n\t\t\tcontinue;\n\t\t}\n\t\tFAIL:cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a) = min((a), (b)))\n#define chmax(a, b) ((a) = max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint x, y, n;\nint ans;\nvector<vector<int>> fians(20, vector<int>(20));\nvector<vector<P>> divi(20);\nvector<P> larger;\n\nvoid dfs(int depth, vector<vector<int>> &s){\n    if(depth == n){\n        ans++;\n        fians = s;\n        return ;\n    }\n\n    if(1 < ans){\n        return ;\n    }\n\n    int K = larger[depth].first;\n    int B = larger[depth].second;\n\n    for(auto i:divi[B]){\n        int h = i.first;\n        int w = i.second;\n\n        for(int j=0; j+h-1<y; j++){\n            for(int k=0; k+w-1<x; k++){\n                int l = k;\n                int r = k + w - 1;\n                int u = j;\n                int d = j + h - 1;\n\n                bool exist = false;\n                bool valid = true;\n                auto cs = s;\n                for(int i1=u; i1<=d; i1++){\n                    for(int i2=l; i2<=r; i2++){\n                        if(cs[i1][i2] == B){\n                            exist = true;\n                        }\n                        else if(cs[i1][i2] != 0){\n                            valid = false;\n                            goto END;\n                        }\n                    }\n                }\n\n                END:;\n\n                if(exist && valid){\n                    for(int i1=u; i1<=d; i1++){\n                        for(int i2=l; i2<=r; i2++){\n                            cs[i1][i2] = B;\n                        }\n                    }\n\n                    dfs(depth + 1, cs);\n                }\n            }\n        }\n    }\n\n    return ;\n}\n\nint main(){\n    while(1){\n        ans = 0;\n        larger.clear();\n        for(int i=0; i<20; i++){\n            divi[i].clear();\n        }\n\n        cin>>x>>y>>n;\n        if(x == 0) return 0;\n        \n        int sum = 0;\n        for(int i=0; i<n; i++){\n            int b, k; cin>>b>>k;\n            larger.emplace_back(k, b);\n            sum += k;\n            set<P> st;\n            for(int j=1; j*j<=k; j++){\n                if(k % j == 0){\n                    st.emplace(j, k / j);\n                    st.emplace(k / j, j);\n                }\n            }\n\n            for(auto j:st){\n                divi[b].emplace_back(j.first, j.second);\n            }\n        }\n\n        sort(larger.begin(), larger.end(), greater<P>());\n\n        vector<vector<int>> s(y, vector<int>(x));\n        for(int i=0; i<y; i++){\n            for(int j=0; j<x; j++){\n                cin>>s[i][j];\n            }\n        }\n\n        if(x * y != sum){\n            cout << \"NA\" << endl;\n            continue;\n        }\n\n        dfs(0, s);\n\n        if(ans == 1){\n            for(int i=0; i<y; i++){\n                for(int j=0; j<x; j++){\n                    cout << fians[i][j] << \" \\n\"[j == x-1];\n                }\n            }\n        }\n        else{\n            cout << \"NA\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint X, Y, n;\n\nstruct Memo\n{\n\tint b;\n\tint k;\n};\n\nstruct Point\n{\n\tint x;\n\tint y;\n};\n\nstruct Node\n{\n\tint idx;\n\tint a[10][10];\n};\n\nclass memo_greater\n{\npublic:\n\tbool operator() (const Memo m1, const Memo m2)\n\t{\n\t\treturn m1.k > m2.k;\n\t}\n};\n\nPoint P[15];\nMemo M[15];\nint A[10][10];\n\nbool is_able(int a[10][10], int x, int y, int w, int h, int idx)\n{\n\tfor(int j=y; j<y+h; j++)\n\t{\n\t\tfor(int i=x; i<x+w; i++)\n\t\t{\n\t\t\tif(i<0 || j<0 || i>=X || j>=Y) return false;\n\t\t\tif(a[j][i]!=0 && a[j][i]!=idx) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid set(int a[10][10], int x, int y, int w, int h, int idx)\n{\n\tfor(int j=y; j<y+h; j++)\n\t{\n\t\tfor(int i=x; i<x+w; i++)\n\t\t{\n\t\t\ta[j][i] = idx;\n\t\t}\n\t}\n}\n\nbool is_ans()\n{\n\tfor(int y=0; y<Y; y++)\n\t{\n\t\tfor(int x=0; x<X; x++)\n\t\t{\n\t\t\tif(A[y][x]==0)\n\t\t\t{\n\t\t\t\treturn false;\t\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool solve()\n{\n\tqueue<Node> que;\n\tint b, k, i, j, mem_size;\n\tPoint p;\n\n\tbool is_ok;\n\tmem_size = sizeof(int) * 100;\n\tsort(&M[0], &M[n-1], memo_greater());\n\tNode nn;\n\tnn.idx = 0;\n\tmemcpy(nn.a, A, mem_size);\n\n\tque.push(nn);\n\n\tis_ok = false;\n\twhile(!que.empty())\n\t{\n\t\tnn = que.front();\n\t\tque.pop();\n\n\t\tif(nn.idx==n)\n\t\t{\n\t\t\tif(!is_ok)\n\t\t\t{\n\t\t\t\tmemcpy(A, nn.a, mem_size);\n\t\t\t\tis_ok = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tb = M[nn.idx].b;\n\t\tk = M[nn.idx].k;\n\t\tp = P[b-1];\n\n\t\tfor(i=1; i<=k; i++)\n\t\t{\n\t\t\tif(k%i!=0) continue;\n\n\t\t\tj = k / i;\n\t\t\tfor(int dy=0; dy<j; dy++)\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<i; dx++)\n\t\t\t\t{\n\t\t\t\t\tif(is_able(nn.a, p.x-dx, p.y-dy, i, j, b))\n\t\t\t\t\t{\n\t\t\t\t\t\tNode node;\n\t\t\t\t\t\tmemcpy(node.a, nn.a, mem_size);\n\t\t\t\t\t\tset(node.a, p.x-dx, p.y-dy, i, j, b);\n\t\t\t\t\t\tnode.idx = nn.idx+1;\n\t\t\t\t\t\tque.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(int argc, char** argv)\n{\n\twhile( 1 )\n\t{\n\t\tcin >> X >> Y >> n;\n\t\tif(!(X || Y || n)) break;\n\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> M[i].b >> M[i].k;\n\t\t}\n\n\t\tfor(int y=0; y<Y; y++)\n\t\t{\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t{\n\t\t\t\tcin >> A[y][x];\n\t\t\t\tif(A[y][x] != 0)\n\t\t\t\t{\n\t\t\t\t\tP[A[y][x]-1].x = x;\n\t\t\t\t\tP[A[y][x]-1].y = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(solve())\n\t\t{\t\n\t\t\tfor(int y=0; y<Y; y++)\n\t\t\t{\n\t\t\t\tfor(int x=0; x<X; x++)\n\t\t\t\t{\n\t\t\t\t\tcout << A[y][x];\n\t\t\t\t\tif(x!=X-1) cout << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define repn(i, m, n) for (int i = m; i < int(n); ++i)\n\nint bk[16];\nint mp[10][10];\nint res[10][10];\nint result[10][10];\nint xy[16][2];\nint x, y ,n;\n\nint solve(int used[], int bit) {\n  if (bit == 0) {\n    rep (i, y) rep (j, x) result[i][j] = res[i][j];\n    return 1;\n  }\n  int xx, yy;\n  rep (i, y) {\n    if (__builtin_popcount(used[i]) == x) continue;\n    yy = i;\n    xx = __builtin_popcount((~used[i] & -~used[i]) - 1);\n    break;\n  }\n  int r = 0;\n  rep (i, 16) {\n    if ((bit & 1 << i) == 0) continue;\n    if (xy[i][1] < xx) continue;\n    repn (j, xy[i][1] - xx + 1, x - xx + 1) {\n      if (bk[i] % j > 0) continue;\n      if (yy + bk[i] / j > y) continue;\n      if (yy + bk[i] / j <= xy[i][0]) continue;\n      int bb = (1 << (xx + j)) - (1 << xx);\n      bool ok = true;\n      rep (k, bk[i] / j) {\n\tif (used[yy + k] & bb) {\n\t  ok = false;\n\t  break;\n\t}\n      }\n      int next[10];\n      rep (k, y) {\n\tnext[k] = used[k];\n      }\n      if (ok) {\n\trep (k, bk[i] / j) {\n\t  rep (l, j) {\n\t    res[yy + k][xx + l] = i;\n\t  }\n\t  next[yy + k] |= bb;\n\t}\n\tr += solve(next, bit ^ 1 << i);\n\tif (r > 1) return r;\n      }\n    }\n  }\n  return r;\n}\n\nint main() {\n  int used[10], sum;\n  for (;;) {\n    cin >> x >> y >> n;\n    if (x == 0 && y == 0 && n == 0) break;\n    sum = 0;\n    rep (i, n) {\n      int b, k;\n      cin >> b >> k;\n      bk[b] = k;\n      sum += k;\n    }\n    if (sum != x * y) {\n      cout << \"NA\\n\";\n      continue;\n    }\n    memset(xy, -1, sizeof(xy));\n    int bit = 0;\n    rep (i, y) rep (j, x) {\n      cin >> mp[i][j];\n      if (mp[i][j] > 0) {\n\txy[mp[i][j]][0] = i;\n\txy[mp[i][j]][1] = j;\n\tbit |= 1 << mp[i][j];\n      }\n    }\n    memset(used, 0, sizeof(used));\n    int r = solve(used, bit);\n    if (r == 1) {\n      rep (i, y) {\n\trep (j, x - 1) cout << result[i][j] << \" \";\n\tcout << result[i][x - 1] << endl;\n      }\n    } else {\n      cout << \"NA\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n#define repD(i, n) for(int i = n; i >= 0; i--)\n\nint cnt;\nint field[100][100];\nint check[100][100];\nint res[100][100];\nbool used[20];\nint K[20];\nint X, Y, n;\n\nvoid solve(int y, int x){\n\tif(y == Y){\n\t\tbool ok = true;\n\t\trep(i, Y)rep(j, X) if(check[i][j] == 0) ok = false;\n\t\tif(ok){\n\t\t\tcnt++;\n\t\t\trep(i, Y)rep(j, X) res[i][j] = check[i][j];\n\t\t}\n\t}else{\n\t\tif(check[y][x] >= 0){\n\t\t\tif(x == X-1) solve(y+1, 0);\n\t\t\telse solve(y, x+1);\n\t\t}else{\n\t\t\tint dy = Y - y;\n\t\t\tint dx = X - x;\n\t\t\tbool ok;\n\t\t\tfor(int i = 1; i <= dy; i++){\n\t\t\t\tfor(int j = 1; j <= dx; j++){\n\t\t\t\t\tok = true;\n\t\t\t\t\tint id = -1;\n\t\t\t\t\trep(k, i){\n\t\t\t\t\t\trep(l, j){\n\t\t\t\t\t\t\tif(check[y+k][x+l] >= 0) ok = false;\n\t\t\t\t\t\t\tif(field[y+k][x+l] > 0){\n\t\t\t\t\t\t\t\tif(!used[field[y+k][x+l]] && (id == -1 || field[y+k][x+l] == id)){\n\t\t\t\t\t\t\t\t\tid = field[y+k][x+l];\n\t\t\t\t\t\t\t\t}else ok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok || id == -1 || K[id] != i * j) continue;\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = id;\n\t\t\t\t\tused[id] = true;\n\t\t\t\t\tsolve(y,x);\n\t\t\t\t\tused[id] = false;\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main(){\n\twhile(cin >> X >> Y >> n && (X || Y || n)){\n\t\tint total = 0;\n\t\n\t\trep(i, n){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tcin >> K[b];\n\t\t\ttotal += K[b];\n\t\t}\n\t\tif(total != X * Y){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i, Y)rep(j, X){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t\tmemset(check, -1, sizeof(check));\n\t\tmemset(used, false, sizeof(used));\n\n\t\tcnt = 0;\n\t\tsolve(0, 0);\n\t\tif(cnt != 1) cout << \"NA\" << endl;\n\t\telse{\n\t\t\tbool f = false;\n\t\t\trep(i, Y){\n\t\t\t\trep(j,X){\n\t\t\t\t\tif(j != 0) cout << \" \";\n\t\t\t\t\tcout << res[i][j];\n\t\t\t\t\tif(check[i][j] != -1) f = true;\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tassert(!f);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint h,w,n;\nmap<int,int> ma;\nmap<int,pair<int,int> > p;\nvector<vector<int> > v;\n\nbool can(int i,int j,int ny,int nx)\n{\n\tif(0 <= i && ny <= h && 0 <= j && nx <= w)\n\t{\n\t\treturn true;\n\t}\n\telse return false;\n}\n\nbool canSet(int num,int y,int x,int y2,int x2)\n{\n\tbool flag = true;\n\n\tREP(i,y,y2)\n\t{\n\t\tREP(j,x,x2)\n\t\t{\n\t\t\tif(v[i][j] != 0)\n\t\t\t{ \n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn flag;\n}\n\nvoid set(int num,int y,int x,int y2,int x2)\n{\n\tREP(i,y,y2)\n\t{\n\t\tREP(j,x,x2)\n\t\t{\n\t\t\tv[i][j] = num;\n\t\t}\n\t}\n}\n\nint cnt = 0;\nvector<vector<int> > v2;\n\nvoid dfs(int num)\n{\n\tif(num == 0)\n\t{\n\t\tif(cnt == 0)\n\t\t{\n\t\t\tbool flag = true;\n\t\t\trep(i,h)\n\t\t\t{\n\t\t\t\trep(j,w)\n\t\t\t\t{\n\t\t\t\t\tif(v[i][j] == 0) flag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tv2.resize(h);\n\t\t\t\trep(i,h) v2[i].resize(w);\n\t\t\t\trep(i,h) rep(j,w) v2[i][j] = v[i][j];\n\t\t\t\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbool flag = true;\n\n\t\t\trep(i,h)\n\t\t\t{\n\t\t\t\trep(j,w)\n\t\t\t\t{\n\t\t\t\t\tif(v[i][j] == 0) flag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(y,1,ma[num]+1)\n\t\t{\n\t\t\tif(ma[num]%y == 0)\n\t\t\t{\n\t\t\t\tint x = ma[num]/y;\n\t\t\t\tREP(i,p[num].first-y+1,p[num].first+1)\n\t\t\t\t{\n\t\t\t\t\tREP(j,p[num].second-x+1,p[num].second+1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ny = i+y;\n\t\t\t\t\t\tint nx = j+x;\n\n\t\t\t\t\t\tif(can(i,j,ny,nx))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tv[p[num].first][p[num].second] = 0;\n\t\t\t\t\t\t\tif(canSet(num,i,j,ny,nx))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tset(num,i,j,ny,nx);\n\t\t\t\t\t\t\t\tdfs(num-1);\n\t\t\t\t\t\t\t\tset(0,i,j,ny,nx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv[p[num].first][p[num].second] = num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(cin >> w >> h >> n)\n\t{\n\t\tif(h == 0 && w == 0 && n == 0) break;\n\n\t\tv.resize(h);\n\t\trep(i,h) v[i].clear();\n\n\t\tma.clear();\n\t\tp.clear();\n\t\tcnt = 0;\n\n\t\trep(i,n)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tma[a] = b;\n\t\t}\n\n\t\tv.resize(n);\n\t\trep(i,h)\n\t\t{\n\t\t\trep(j,w)\n\t\t\t{\n\t\t\t\tint temp;\n\t\t\t\tcin >> temp;\n\t\t\t\tv[i].push_back(temp);\n\n\t\t\t\tif(1 <= temp && temp <= 15)\n\t\t\t\t{\n\t\t\t\t\tp[temp] = pair<int,int>(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(n);\n\n\t\tif(cnt == 1)\n\t\t{\n\t\t\trep(i,h)\n\t\t\t{\n\t\t\t\trep(j,w)\n\t\t\t\t{\n\t\t\t\t\tcout << v2[i][j];\n\t\t\t\t\tif(j != w-1) cout << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cy >= H ) while(1);\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nqueue<pair<int, vector<vector<int> > > >Q;\nvector<vector<int>>X, P; int H, W, N, V1[20], V2[20];\npair<bool, vector<vector<int> > > hantei(vector<vector<int> >a1, int X1, int Y1, int H1, int W1, int N1) {\n\tbool OK = true;\n\tfor (int i = X1; i < X1 + H1; i++) {\n\t\tfor (int j = Y1; j < Y1 + W1; j++) {\n\t\t\tif (i >= H || j >= W) { OK = false; continue; }\n\t\t\tif (a1[i][j] != 0 || (X[i][j] != V1[N1] && X[i][j] >= 1))OK = false;\n\t\t\ta1[i][j] = V1[N1];\n\t\t}\n\t}\n\treturn make_pair(OK, a1);\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H >> N; if (W == 0 && H == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; i++) { cin >> V1[i] >> V2[i]; }\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tvector<int>G, I; int a;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a; G.push_back(a); I.push_back(0);\n\t\t\t}\n\t\t\tX.push_back(G); P.push_back(I);\n\t\t}\n\t\tQ.push(make_pair(0, P)); vector<vector<int> >res; int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tvector<vector<int>>K = Q.front().second;\n\t\t\tint L = Q.front().first; Q.pop();\n\t\t\tif (L == N) { cnt++; res = K; }\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 1; k <= V2[L]; k++) {\n\t\t\t\t\t\tif (V2[L] % k != 0)continue;\n\t\t\t\t\t\tpair<bool, vector<vector<int> > >res1 = hantei(K, i, j, k, V2[L] / k, L);\n\t\t\t\t\t\tif (res1.first == true) { Q.push(make_pair(L + 1, res1.second)); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0 || cnt >= 2)cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (j >= 1) { cout << ' '; }cout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n#define repD(i, n) for(int i = n; i >= 0; i--)\n\nint cnt;\nint field[100][100];\nint check[100][100];\nint res[100][100];\nint K[20];\nint X, Y, n;\n\nvoid solve(int y, int x){\n\tif(y == Y){\n\t\tcnt++;\n\t\trep(i, Y)rep(j, X) res[i][j] = check[i][j];\n\t}else{\n\t\tif(check[y][x] >= 0){\n\t\t\tif(x == X-1) solve(y+1, 0);\n\t\t\telse solve(y, x+1);\n\t\t}else{\n\t\t\tint dy = Y - y;\n\t\t\tint dx = X- x;\n\t\t\tbool ok;\n\t\t\trep2(i, 1, dy + 1){\n\t\t\t\trep2(j, 1, dx + 1){\n\t\t\t\t\tok = true;\n\t\t\t\t\tint id = -1;\n\t\t\t\t\trep(k, i){\n\t\t\t\t\t\trep(l, j){\n\t\t\t\t\t\t\tif(check[y+k][x+l] >= 0) ok = false;\n\t\t\t\t\t\t\tif(field[y+k][x+l] > 0){\n\t\t\t\t\t\t\t\tif(id == -1){\n\t\t\t\t\t\t\t\t\tid = field[y+k][x+l];\n\t\t\t\t\t\t\t\t}else ok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok || id == -1 || K[id] != i * j) continue;\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = id;\n\t\t\t\t\tsolve(y,x);\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main(){\n\twhile(cin >> X >> Y >> n && (X || Y || n)){\n\t\tint total = 0;\n\t\n\t\trep(i, n){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tcin >> K[b];\n\t\t\ttotal += K[b];\n\t\t}\n\t\tif(total != X * Y){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i, Y)rep(j, X){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t\tmemset(check, -1, sizeof(check));\n\t\tcnt = 0;\n\t\tsolve(0, 0);\n\t\tif(cnt != 1) cout << \"NA\" << endl;\n\t\telse{\n\t\t\trep(i, Y){\n\t\t\t\trep(j,X){\n\t\t\t\t\tif(j != 0) cout << \" \";\n\t\t\t\t\tcout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstruct State{int x[15][15];};\nint H,W,n,b[15],p[15];State S,ans;\nint area(State V,int q){\n\tint mx=100000,my=100000,nx=-1,ny=-1;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(V.x[i][j]!=q)continue;\n\t\t\tmx=min(mx,i);my=min(my,j);nx=max(nx,i);ny=max(ny,j);\n\t\t}\n\t}\n\tfor(int i=mx;i<=nx;i++){\n\t\tfor(int j=my;j<=ny;j++){\n\t\t\tif(V.x[i][j]!=q && V.x[i][j]!=0)return 99999999;\n\t\t}\n\t}\n\treturn (nx-mx+1)*(ny-my+1);\n}\nint solve(State T,int r1,int r2){\n\tif(r2==W){r1++;r2=0;}\n\tif(r1==H){ans=T;return 1;}\n\tif(T.x[r1][r2]>=1){return solve(T,r1,r2+1);}\n\telse{\n\t\tint ret=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tState U=T;U.x[r1][r2]=i;\n\t\t\tif(area(U,i)>p[i])continue;\n\t\t\tret+=solve(U,r1,r2+1);\n\t\t}\n\t\treturn ret;\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H>>n;if(n==0)break;\n\t\tfor(int i=0;i<n;i++){cin>>b[i];cin>>p[b[i]];}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++)cin>>S.x[i][j];\n\t\t}\n\t\tint ret=solve(S,0,0);\n\t\tif(ret==1){\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(j)cout<<' ';cout<<ans.x[i][j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint X, Y, N;\nint k[16];\nint s[10][10];\nint t[10][10];\nint u;\nint v[10][10];\n\nbool input() {\n  cin >> X >> Y >> N;\n  if (!X && !Y && !N) {\n    return false;\n  }\n\n  for (int i = 0; i < N; ++i) {\n    int b;\n    cin >> b;\n    cin >> k[b];\n  }\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      cin >> s[i][j];\n    }\n  }\n\n  return true;\n}\n\nvoid paint(int id, int y1, int x1, int y2, int x2) {\n  for (int i = y1; i <= y2; ++i) {\n    for (int j = x1; j <= x2; ++j) {\n      t[i][j] = id;\n    }\n  }\n  u += (y2 - y1 + 1) * (x2 - x1 + 1);\n}\n\nvoid unpaint(int y1, int x1, int y2, int x2) {\n  for (int i = y1; i <= y2; ++i) {\n    for (int j = x1; j <= x2; ++j) {\n      t[i][j] = 0;\n    }\n  }\n  u -= (y2 - y1 + 1) * (x2 - x1 + 1);\n}\n\nvoid find_vacant(int &r, int &c) {\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      if (!t[i][j]) {\n        r = i;\n        c = j;\n        return;\n      }\n    }\n  }\n}\n\nint dfs(int p, int q) {\n  if (u == X * Y) {\n    for (int i = 0; i < Y; ++i) {\n      for (int j = 0; j < X; ++j) {\n        v[i][j] = t[i][j];\n      }\n    }\n    return 1;\n  }\n\n  int z = 0;\n  for (int i = p; i < Y; ++i) {\n    for (int j = q; j < X; ++j) {\n      if (!t[i][j] && !s[i][j]) {\n        continue;\n      }\n      if (t[i][j] > 0) {\n        break;\n      }\n      int id = s[i][j];\n      for (int f = i; f < Y; ++f) {\n        int h = f - p + 1;\n        for (int g = j; g < X; ++g) {\n          if (t[f][g] > 0 || (s[f][g] != id && s[f][g])) {\n            break;\n          }\n          int w = g - q + 1;\n          int a = h * w;\n          if (k[id] > a) {\n            continue;\n          }\n          if (k[id] < a) {\n            break;\n          }\n          paint(id, p, q, f, g);\n          int np, nq;\n          find_vacant(np, nq);\n          z += dfs(np, nq);\n          unpaint(p, q, f, g);\n        }\n      }\n      break;\n    }\n  }\n  return z;\n}\n\nvoid print_ans() {\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      if (!j) {\n        cout << v[i][j];\n      } else {\n        cout << \" \" << v[i][j];\n      }\n    }\n    cout << endl;\n  }\n}\n\nvoid solve() {\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      t[i][j] = 0;\n    }\n  }\n  u = 0;\n  if (dfs(0, 0) != 1) {\n    cout << \"NA\" << endl;\n  } else {\n    print_ans();\n  }\n}\n\nint main() {\n  while (input()) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint w, h;\nvector<int> area;\nvector<vector<int> > sum;\n\nint retNum;\nvector<string> ret;\n\nvoid solve(int y, int x, vector<string>& used)\n{\n    if(x > w){\n        ++ y;\n        x = 1;\n    }\n    if(y > h){\n        ++ retNum;\n        ret = used;\n        return;\n    }\n\n    if(used[y][x] != '0'){\n        solve(y, x+1, used);\n        return;\n    }\n\n    for(int y1=y; y1<=h; ++y1){\n        for(int x1=x; x1<=w; ++x1){\n            if(used[y1][x1] != '0'){\n                w = x1 - 1;\n                break;\n            }\n\n            bitset<16> bs = sum[y1][x1] & (~sum[y1][x-1]) & (~sum[y-1][x1]);\n            if(bs.count() != 1)\n                continue;\n\n            int k = 0;\n            while(!bs[k])\n                ++ k;\n            if(area[k] != (y1 - y + 1) * (x1 - x + 1))\n                continue;\n\n            bool ng = false;\n            vector<string> used1 = used;\n            for(int i=y; i<=y1; ++i){\n                for(int j=x; j<=x1; ++j){\n                    if(used1[i][j] != '0')\n                        ng = true;\n                    used1[i][j] = k + '0';\n                }\n            }\n            if(!ng)\n                solve(y, x+1, used1);\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n\n        area.assign(n+1, 0);\n        for(int i=0; i<n; ++i){\n            int b, k;\n            cin >> b >> k;\n            area[b] = k;\n        }\n\n        sum.assign(h+1, vector<int>(w+1, 0));\n        for(int y=1; y<=h; ++y){\n            int tmp = 0;\n            for(int x=1; x<=w; ++x){\n                int a;\n                cin >> a;\n                if(a > 0)\n                    tmp |= (1 << a);\n                sum[y][x] = sum[y-1][x] | tmp;\n            }\n        }\n\n        retNum = 0;\n        vector<string> s(h+1, string(w+1, '0'));\n        solve(1, 1, s);\n\n        if(retNum != 1){\n            cout << \"NA\" << endl;\n        }else{\n            for(int i=1; i<=h; ++i){\n                cout << ret[i][1];\n                for(int j=2; j<=w; ++j)\n                    cout << ' ' << ret[i][j];\n                cout << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint W, H, N; \nint b[16], k[16];\nint s[10][10];\nint ans[10][10];\nint used[10][10];\nint TX[20], TY[20];\nclass DFSError {};\nvoid dfs(int idx){\n  if(idx == N) {\n    if(ans[0][0] != -1) throw DFSError();\n    REP(y, H)REP(x, W) ans[y][x] = used[y][x];\n    return;\n  }\n  /*\n  printf(\"idx = %d\\n\", idx);\n  REP(y, H){\n    REP(x, W){\n      cout << used[y][x];\n      if(x != W - 1) cout << \" \";\n      else cout << endl;\n    }\n  }\n  */\n  int tx = TX[b[idx]];\n  int ty = TY[b[idx]];\n  //printf(\"idx = %d tx = %d ty = %d\\n\", idx, tx, ty);\n  \n  assert(idx < N);\n  assert(b[idx] >= 1 && b[idx] <= N);\n  assert(tx != -1);\n  for(int h = 1; h <= k[idx]; h++) if(k[idx] % h == 0){\n    int w = k[idx] / h;\n    for(int by = 0; by > -h; by--) for(int bx = 0; bx > -w; bx--){\n      int sx = tx + bx;\n      int sy = ty + by;\n      bool ok = true;\n      for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n        if(!valid(sx + x, sy + y, W, H) || used[sy + y][sx + x] != -1) ok = false;\n      }\n      if(ok){\n        int tmp[10][10];\n        memcpy(tmp, used, sizeof(used));\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n          used[sy + y][sx + x] = b[idx];\n        }\n        dfs(idx + 1);\n        memcpy(used, tmp, sizeof(used));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H >> N && W){\n    REP(i, N) cin >> b[i] >> k[i];\n    REP(y, H)REP(x, W) cin >> s[y][x];\n    try{\n      memset(used, -1, sizeof(used));\n      memset(ans, -1, sizeof(ans));\n      memset(TX, -1, sizeof(TX));\n      memset(TY, -1, sizeof(TY));\n      REP(y, H) REP(x, W) if(s[y][x] > 0) TX[s[y][x]] = x, TY[s[y][x]] = y;\n      REP(i, N) assert(TX[i + 1] != -1);\n      dfs(0);\n      if(ans[0][0] == -1) throw DFSError();\n      REP(y, H){\n        REP(x, W){\n          cout << ans[y][x];\n          if(x != W - 1) cout << \" \";\n          else cout << endl;\n        }\n      }\n    }catch(...){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\nbool use[16];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j] && !use[ok[y][x][i][j]]) {\n\t\t\t\tuse[ok[y][x][i][j]] = true;\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t\tuse[ok[y][x][i][j]] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n\t\tfor(int i = 0; i < 16; i++)\n\t\t\tuse[i] = false;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = 0; y < Y && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = 0; x < X && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg)\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tif(res == 1) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Subdivide The Land\n//Level: 3\n//Category: 探索\n//Note:\n\n/**\n * パズル「四角に切れ」と同じ問題設定なので、おそらくNP完全である。\n * したがって、効率のよい探索を考える。\n *\n * 全てのマスがどれかの長方形に属していることより、盤面を左上から走査していき、どの番号の長方形に属すかを探索していけばよい。\n * こうすることで、そのマスを左上とした長方形に決め打つことができる。\n * 各番号では、その面積を与える長方形を全て試す。\n */\n#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<15> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    //Rect() : r(0), c(0), h(0), w(0) {}\n    Rect() {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else {\n        bool conquered = false;\n        for(int i = 0; i < N; ++i) {\n            if(!state[i]) continue;\n            if(cur[i].intersect(Rect(r, c, 1, 1))) {\n                conquered = true;\n                break;\n            }\n        }\n        if(conquered) {\n            dfs(r, c+1, state, cur);\n            return;\n        }\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint stage_w,stage_h,total_buyers;\nint ans[50][50];\n\nvoid disp(int stage[50][50]){\n  for(int y = 0; y < stage_h; y++){\n    for(int x = 0; x < stage_w; x++){\n      printf(\"%d\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nbool check(int stage[50][50]){\n  for(int y = 0; y < stage_h; y++){\n    for(int x = 0; x < stage_w; x++){\n      if(stage[y][x] == 0) return false;\n    }\n  }\n  memcpy(ans,stage,sizeof(int)*50*50);\n  return true;\n}\n\nint dfs(int id,int areas[50],P occupied[50],int stage[50][50]){\n  if(id > total_buyers){\n    return check(stage) ? 1 : 0;\n  }\n\n  int res = 0;\n  for(int w = 1; w <= areas[id]; w++){\n    int h = areas[id] / w;\n    if(h * w != areas[id]) continue;\n    int cx = occupied[id].first;\n    int cy = occupied[id].second;\n\n    for(int lx = cx - w + 1; lx <= cx; lx++){\n      if(lx < 0) continue;\n\n      int rx = lx + w - 1;\n\n      if(rx >= stage_w) continue;\n      for(int ly = cy - h + 1; ly <= cy; ly++){\n        if(ly < 0) continue;\n\n        int ry = ly + h - 1;\n        if(ry >= stage_h) continue;\n\n        int prev[50][50];\n        memcpy(prev,stage,sizeof(int)*50*50);\n        for(int x = lx; x <= rx; x++){\n          for(int y = ly; y <= ry; y++){\n            if(stage[y][x] == 0){\n              stage[y][x] = id;\n            }\n            else if(stage[y][x] != id){\n              goto fail;\n            }\n          }\n        }\n        res += dfs(id + 1,areas,occupied,stage);\n      fail:;\n        memcpy(stage,prev,sizeof(int)*50*50);\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d %d\",&stage_w,&stage_h,&total_buyers)){\n    if(stage_w == 0 && stage_h == 0) break;\n\n    int stage[50][50];\n    int areas[50];\n    for(int buyer_i = 0; buyer_i < total_buyers; buyer_i++){\n      int id;\n      int area;\n      scanf(\"%d %d\",&id,&area);\n      areas[id] = area;\n    }\n\n    P occupied[50];\n    for(int y = 0; y < stage_h; y++){\n      for(int x = 0; x < stage_w; x++){\n        scanf(\"%d\",&stage[y][x]);\n        if(stage[y][x] != 0){\n          occupied[stage[y][x]] = P(x,y);\n        }\n      }\n    }\n\n    if(dfs(1,areas,occupied,stage) == 1){\n      disp(ans);\n    }\n    else{\n      printf(\"NA\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int W, H, N; \n  while(cin >> W >> H >> N && (W|H|N)){\n    int F[20], V[20];\n    REP(i, N){\n      cin >> F[i] >> V[i];\n    }\n    vector<bool> exist(N, false);\n    REP(y, H) REP(x, W) {\n      int t; cin >> t;\n      if(t > 0) exist[t - 1] = true;\n    }\n    REP(i, N) assert(exist[i]);\n    cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(i,H) rep(j,W) edge[i][j].clear();\n  int debug = 0;\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); debug++; }\n        if( debug >= 1000000 ) while(1);\n      Skip:;\n        \n      }\n    }\n  }\n  /*  \n      rep(i,H) rep(j,W) {\n      cout << \"(\" << j << \",\" << i << \") ::\" << endl;\n      rep(l,(int)edge[i][j].size()) cout << \"(\" << edge[i][j][l].w << \",\" << edge[i][j][l].h << \",\" << edge[i][j][l].index << \") \";\n      cout << endl;\n      }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n  if( cy >= H ) while(1);\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      //assert( isValid(x+cx,y+cy) );\n      if( ans[y+cy][x+cx] != 0 ) {\n        goto Skip;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { \n      rep(j,W) {\n        if( j ) cout << \" \";\n        cout << buf[i][j]; \n      } \n      cout << endl; \n    }\n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    rep(i,H) rep(j,W) cin >> s[i][j];\n    if( sum != H*W ) { puts(\"NA\"); continue; }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<P> V;\n\nstruct F{\n\tint a[10][10];\n};\n\nvoid acopy(int a[10][10], int b[10][10], int w, int h)\n{\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tb[i][j] = a[i][j];\n\t\t}\n\t}\n\t\n\treturn ;\n}\n\nvector<F> res;\nvoid func(F r, V vec, int w, int h, int p)\n{\n\tif(p == vec.size()){\n\t\tres.push_back(r);\n\t} else {\n\t\tint t = vec[p].second, u = vec[p].first;\n\t\tfor(int m = 1; m <= t; m++){\n\t\t\tif(t%m == 0){\n\t\t\t\tF b;\n\t\t\t\tint s = t/m;\n\t\t\t\tfor(int i = 0; i <= h-s; i++){\n\t\t\t\t\tfor(int j = 0; j <= w-m; j++){\n\t\t\t\t\t\tacopy(r.a, b.a, w, h);\n\t\t\t\t\t\tbool f1 = true, f2 = false;\n\t\t\t\t\t\tfor(int k = 0; k < s && f1; k++){\n\t\t\t\t\t\t\tfor(int l = 0; l < m && f1; l++){\n\t\t\t\t\t\t\t\tif(!(b.a[i+k][j+l] == 0 || b.a[i+k][j+l] == u)){\n\t\t\t\t\t\t\t\t\tf1 = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(b.a[i+k][j+l] == u){\n\t\t\t\t\t\t\t\t\tf2 = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tb.a[i+k][j+l] = u;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(f1 && f2){\n\t\t\t\t\t\t\tfunc(b, vec, w, h, p+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ;\n}\n\nint main()\n{\n\tint w, h, n, s, t;\n\tF r;\n\t\n\twhile(cin>>w>>h>>n && (w+h+n)){\n\t\tV vec;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s >> t;\n\t\t\tvec.push_back(P(s, t));\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> r.a[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunc(r, vec, w, h, 0);\n\t\tif(res.size() == 1){\n\t\t\tr = res[0];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tcout << r.a[i][0];\n\t\t\t\tfor(int j = 1; j < w; j++){\n\t\t\t\t\tcout << \" \" << r.a[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t} else {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\t\n\t\tres.clear();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-8;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nint w, h, n;\npint info[16];\nint land[10][10], ans_land[10][10];\npint sign_pos[16];\n\nbool can_put(int left, int top, int width, int height, int b)\n{\n\tint right = left + width - 1;\n\tint bottom = top + height - 1;\n\tif (left < 0 || top < 0 || right >= w || bottom >= h)\n\t\treturn false;\n\n\tfor (int y = top; y <= bottom; ++y)\n\t\tfor (int x = left; x <= right; ++x)\n\t\t\tif (land[y][x] != 0 && land[y][x] != b)\n\t\t\t\treturn false;\n\treturn true;\n}\nvoid put(int left, int top, int width, int height, int b)\n{\n\tint right = left + width - 1;\n\tint bottom = top + height - 1;\n\n\tfor (int y = top; y <= bottom; ++y)\n\t\tfor (int x = left; x <= right; ++x)\n\t\t\tland[y][x] = b;\n}\nbool ok()\n{\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tif (land[y][x] == 0)\n\t\t\t\treturn false;\n\treturn true;\n}\nint dfs(int depth)\n{\n\tif (depth == n)\n\t{\n\t\tif (ok())\n\t\t{\n\t\t\tmemcpy(ans_land, land, sizeof(ans_land));\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tint res = 0;\n\n\tint b = info[depth].second;\n\tint k = info[depth].first;\n\tint sx = sign_pos[b].first;\n\tint sy = sign_pos[b].second;\n\tfor (int height = 1; height <= k; ++height)\n\t{\n\t\tif (k % height)\n\t\t\tcontinue;\n\t\tint width = k / height;\n\t\tfor (int y = sy - height-1; y <= sy; ++y)\n\t\t{\n\t\t\tfor (int x = sx - width-1; x <= sx; ++x)\n\t\t\t{\n\t\t\t\tif (can_put(x, y, width, height, b))\n\t\t\t\t{\n\t\t\t\t\tput(x, y, width, height, b);\n\t\t\t\t\tres += dfs(depth + 1);\n\t\t\t\t\tput(x, y, width, height, 0);\n\t\t\t\t\tland[sy][sx] = b;\n\n\t\t\t\t\tif (res > 1)\n\t\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\nint main()\n{\n\twhile (scanf(\"%d%d%d\", &w, &h, &n), w|h|n)\n\t{\n\t\tmemset(info, 0, sizeof(info));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint b, k;\n\t\t\tscanf(\"%d%d\", &b, &k);\n\t\t\tinfo[i] = pint(k, b);\n\t\t}\n\t\tsort(info, info+n, greater<pint>());\n\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tscanf(\"%d\", &land[y][x]);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tif (land[y][x])\n\t\t\t\t\tsign_pos[land[y][x]] = pint(x, y);\n\n\t\tif (dfs(0) == 1)\n\t\t{\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w-1; ++x)\n\t\t\t\t\tprintf(\"%d \", ans_land[y][x]);\n\t\t\t\tprintf(\"%d\\n\", ans_land[y][w-1]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\nvector<vector<pii> > v;\nint tab[16][16];\nint m[16][16];\nint ans[16][16];\nint x, y, N;\n\nint search(int n) {\n\tif(n > N) {\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tans[i][j] = tab[i][j];\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\tint res = 0;\n\tint sx = -1, sy = -1;\n\tfor(int i = 0; i < y; i++) {\n\t\tfor(int j = 0; j < x; j++) {\n\t\t\tif(m[i][j] == n) {\n\t\t\t\t/*\n\t\t\t\tif(sx != -1 || sy != -1)\n\t\t\t\t\tabort();\n\t\t\t\t// */\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < v[n-1].size(); i++) {\n\t\tint wi, hi;\n\t\twi = v[n-1][i].first;\n\t\thi = v[n-1][i].second;\n\t\tfor(int by = 0; by < hi; by++) {\n\t\t\tfor(int bx = 0; bx < wi; bx++) {\n\t\t\t\tif(sy-by >= 0 && sx-bx >= 0 && sy-by + hi <= y && sx-bx + wi <= x) {\n\t\t\t\t\t/*\n\t\t\t\t\tcout << \"hoge:\" << n << endl;\n\t\t\t\t\tcout << \"i:\" << i << endl;\n\t\t\t\t\tcout << sy-by << \",\" << sx-bx << endl;\n\t\t\t\t\t// */\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\tif(tab[j][k] != 0 || (m[j][k] != 0 && m[j][k] != n)) {\n\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t//cout << sy << \",\" << sx << endl;\n\t\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\t\ttab[j][k] = n;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint tmp;\n\t\t\t\t\t\ttmp = search(n+1);\n\t\t\t\t\t\tres += tmp;\n\t\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\t\ttab[j][k] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << n << endl;\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> x >> y >> N, x || y || N) {\n\t\tv.clear();\n\t\tv.resize(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(k % j == 0 && j <= y && k / j <= x) {\n\t\t\t\t\tv[b-1].push_back(pii(j,k/j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\t\tcout << v[i][j].first << \",\" << v[i][j].second << endl;\n\t\t\t} cout << endl;\n\t\t} cout << endl;\n\t\t// */\n\n\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tfor(int j = 0; j < 16; j++) {\n\t\t\t\ttab[i][j] = 0;\n\t\t\t\tm[i][j] = 0;\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tcin >> m[i][j];\n\t\t\t}\n\t\t}\n\n\t\tif(search(1) != 1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tcout << ans[i][0];\n\t\t\t\tfor(int j = 1; j < x; j++) {\n\t\t\t\t\tcout << \" \" << ans[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n#define repD(i, n) for(int i = n; i >= 0; i--)\n\nint cnt;\nint field[100][100];\nint check[100][100];\nint res[100][100];\nbool used[20];\nint K[20];\nint X, Y, n;\n\nvoid solve(int y, int x){\n\tif(y == Y){\n\t\tcnt++;\n\t\trep(i, Y)rep(j, X) res[i][j] = check[i][j];\n\t}else{\n\t\tif(check[y][x] >= 0){\n\t\t\tif(x == X-1) solve(y+1, 0);\n\t\t\telse solve(y, x+1);\n\t\t}else{\n\t\t\tint dy = Y - y;\n\t\t\tint dx = X- x;\n\t\t\tbool ok;\n\t\t\trep2(i, 1, dy + 1){\n\t\t\t\trep2(j, 1, dx + 1){\n\t\t\t\t\tok = true;\n\t\t\t\t\tint id = -1;\n\t\t\t\t\trep(k, i){\n\t\t\t\t\t\trep(l, j){\n\t\t\t\t\t\t\tif(check[y+k][x+l] >= 0) ok = false;\n\t\t\t\t\t\t\tif(field[y+k][x+l] > 0){\n\t\t\t\t\t\t\t\tif(!used[field[y+k][x+l]] && (id == -1 || field[y+k][x+l] == id)){\n\t\t\t\t\t\t\t\t\tid = field[y+k][x+l];\n\t\t\t\t\t\t\t\t}else ok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok || id == -1 || K[id] != i * j) continue;\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = id;\n\t\t\t\t\tused[id] = true;\n\t\t\t\t\tsolve(y,x);\n\t\t\t\t\tused[id] = false;\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main(){\n\twhile(cin >> X >> Y >> n && (X || Y || n)){\n\t\tint total = 0;\n\t\n\t\trep(i, n){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tcin >> K[b];\n\t\t\ttotal += K[b];\n\t\t}\n\t\tif(total != X * Y){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i, Y)rep(j, X){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t\tmemset(check, -1, sizeof(check));\n\t\tmemset(used, false, sizeof(used));\n\n\t\tcnt = 0;\n\t\tsolve(0, 0);\n\t\tif(cnt != 1) cout << \"NA\" << endl;\n\t\telse{\n\t\t\trep(i, Y){\n\t\t\t\trep(j,X){\n\t\t\t\t\tif(j != 0) cout << \" \";\n\t\t\t\t\tcout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,n,land[50][50],test[50][50],ans[50][50];\n\nbool search(int i0,int j0){\n//printf(\"i0=%d, j0=%d\\n\",i0,j0);\n//for(int a=0;a<h;a++){for(int b=0;b<w;b++)printf(\"%d \",test[a][b]);puts(\"\");}puts(\"\");\n\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\nif(i<0 || h<=i || j<0 || w<=j)\texit(0);\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\nif(id<0 || n<id)\twhile(1)puts(\"@@@@@@\");\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tans[i][j]=test[i][j];}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);}\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint field[11][11];\nint land[20];\npair<int,int> place[20];\n\nint w,h,n;\nbool ok;\n\nstruct landInfo{\n\tint minx;\n\tint miny;\n\tint maxy;\n\tint maxx;\n};\n\nlandInfo mem[20];\nlandInfo fin[20];\n\nbool no=false;\n\nvoid dfs(int num,int sum){\n\tif(no)\n\t\treturn;\n\tif(num==n+1){\n\t\tif(sum==h*w){\n\t\t\tif(ok)\n\t\t\t\tno=true;\n\t\t\telse{\n\t\t\t\tok=true;\n\t\t\t\tfor(int i = 1; i < num; i++)\n\t\t\t\t\tfin[i]=mem[i];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\telse{\n\t\t// ßûð·×ÄµÄÝé\n\t\tfor(int i = 1; i <= land[num]; i++){\n\t\t\tif(land[num]%i!=0)\n\t\t\t\tcontinue;\n\t\t\tint tate=i;\n\t\t\tint yoko=land[num]/i;\n\t\t\t// Ç±É»ÝÌynÌÔÌÊuðÁÄ­é©\n\t\t\tfor(int j = 0; j < tate; j++){\n\t\t\t\tfor(int k = 0; k < yoko; k++){\n\t\t\t\t\t// ÍÝoÄÈ¯êÎAßé\n\t\t\t\t\tint minx=place[num].second-k;\n\t\t\t\t\tint miny=place[num].first-j;\n\t\t\t\t\tint maxx=minx+yoko-1;\n\t\t\t\t\tint maxy=miny+tate-1;\n\t\t\t\t\tif(minx>=0&&miny>=0&&minx<w&&miny<h&&maxx>=0&&maxy>=0&&maxx<w&&maxy<h){\n\t\t\t\t\t\t// àµ¼ÌynÌÍÍÆðíÁÄ¢È¯êÎ\n\t\t\t\t\t\tbool f=false;\n\t\t\t\t\t\tfor(int l = 1; l < num; l++){\n\t\t\t\t\t\t\tif(!((maxx<mem[l].minx||maxy<mem[l].miny)||(minx>mem[l].maxx||miny>mem[l].maxy))){\n\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f){\n\t\t\t\t\t\t\tlandInfo li;\n\t\t\t\t\t\t\tmem[num].minx=minx;\n\t\t\t\t\t\t\tmem[num].maxx=maxx;\n\t\t\t\t\t\t\tmem[num].miny=miny;\n\t\t\t\t\t\t\tmem[num].maxy=maxy;\n\t\t\t\t\t\t\tdfs(num+1,sum+land[num]);\n\t\t\t\t\t\t\tif(no)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h>>n&&!(w==0&&h==0&&n==0)){\n\t\tok=false;\n\t\tno=false;\n\t\tint b,k;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>b>>k;\n\t\t\tland[b]=k;\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]!=0){\n\t\t\t\t\tplace[field[i][j]].first=i;\n\t\t\t\t\tplace[field[i][j]].second=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ÔÉynðßÄ¢­\n\t\tdfs(1,0);\n\t\tif(ok&&!no){\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\tfor(int j = fin[i].miny; j <= fin[i].maxy; j++)\n\t\t\t\t\tfor(int k = fin[i].minx; k <= fin[i].maxx; k++)\n\t\t\t\t\t\tfield[j][k]=i;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tcout<<field[i][j];\n\t\t\t\t\tif(j!=w-1)\n\t\t\t\t\t\tcout<<\" \";\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstruct State{int x[12][12];};\nint H,W,n,b[20],p[20];State S,ans;\nint area(State V,int q){\n\tint mx=100000,my=100000,nx=-1,ny=-1;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(V.x[i][j]!=q)continue;\n\t\t\tmx=min(mx,i);my=min(my,j);nx=max(nx,i);ny=max(ny,j);\n\t\t}\n\t}\n\tfor(int i=mx;i<=nx;i++){\n\t\tfor(int j=my;j<=ny;j++){\n\t\t\tif(V.x[i][j]!=q && V.x[i][j]!=0)return 99999999;\n\t\t}\n\t}\n\treturn (nx-mx+1)*(ny-my+1);\n}\nint solve(State T,int r1,int r2){\n\tif(r2==W){r1++;r2=0;}\n\tif(r1==H){ans=T;return 1;}\n\tif(T.x[r1][r2]>=1){return solve(T,r1,r2+1);}\n\telse{\n\t\tint ret=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tState U=T;U.x[r1][r2]=i;\n\t\t\tif(area(U,i)>p[i])continue;\n\t\t\tret+=solve(U,r1,r2+1);\n\t\t}\n\t\treturn ret;\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H>>n;if(n==0)break;\n\t\tfor(int i=0;i<n;i++){cin>>b[i];cin>>p[b[i]];}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++)cin>>S.x[i][j];\n\t\t}\n\t\tint ret=solve(S,0,0);\n\t\tif(ret==1){\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(j)cout<<' ';cout<<ans.x[i][j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\telse cout<<\"NA\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\ntypedef pair<int,int> pii;\ntypedef vector<vector<int> > mat;\n\nmat ans(10,vector<int>(10));\nint memo[15], memo2[15], memo3[15];\npii basyo[15];\nint X, Y, n;\nint ansnum;\n\nvoid solve(mat ba, int d) {\n  if (d == n) {\n    ans = ba;\n    ansnum++;\n    return ;\n  }\n  for (int XX=1; XX<=memo[d]; ++XX) {\n    if (memo[d] % XX) continue;\n    int YY = memo[d] / XX;\n    REP(yy, YY) {\n      REP(xx, XX) {\n        bool f = 0;\n        REP(yyy, YY) {\n          REP(xxx, XX) {\n            int x = basyo[d].first - xx + xxx;\n            int y = basyo[d].second - yy + yyy;\n\n            if (x < 0 || X <= x || y < 0 || Y <= y) {\n              f = 1;\n            } else if (ba[x][y] != d && ba[x][y] != -1)\n              f = 1;\n          }\n        }\n        // ツつ「ツつッツづゥ\n        if (!f) {\n          mat tmp = ba;\n          REP(yyy, YY) {\n            REP(xxx, XX) {\n              int x = basyo[d].first - xx + xxx;\n              int y = basyo[d].second - yy + yyy;\n              tmp[x][y] = d;\n            }\n          }\n          solve(tmp, d+1);\n        }\n      }\n    }\n  }\n}\n  \n  \nint main() {\n  mat ba(10, vector<int>(10));\n  while(cin >> X >> Y >> n, X+Y+n) {\n    vector<pii> P(n);\n    REP(i,n) {\n      int b, k;\n      cin >> b >> k;\n      P[i] = make_pair(k,b);\n    }\n    sort(ALL(P), greater<pii>());\n    REP(i,n) {\n      memo[i] = P[i].first;\n      memo2[P[i].second] = i;\n      memo3[i] = P[i].second;\n    }\n    REP(y, Y) {\n      REP(x, X) {\n        cin >> ba[x][y];\n        if (ba[x][y] > 0) {\n          ba[x][y] = memo2[ba[x][y]];\n          basyo[ba[x][y]] = pii(x,y);\n        } else\n          ba[x][y] = -1;\n      }\n    }\n    ansnum = 0;\n    solve(ba, 0);\n    if (ansnum == 1) {\n      REP(y,Y) {\n        REP(x,X) {\n          if (x) cout << \" \";\n          cout << memo3[ans[x][y]];\n        }\n        cout << endl;\n      }\n    } else\n      cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nqueue<pair<int, vector<vector<int> > > >Q;\nvector<vector<int>>X, P; int H, W, N, V1[20], V2[20];\npair<bool, vector<vector<int> > > hantei(vector<vector<int> >a1, int X1, int Y1, int H1, int W1, int N1) {\n\tbool OK = true; int G[30][30];\n\tfor (int i = 0; i < 900; i++)G[i / 30][i % 30] = 0;\n\tfor (int i = X1; i < X1 + H1; i++) {\n\t\tfor (int j = Y1; j < Y1 + W1; j++) {\n\t\t\tif (i >= H || j >= W) { OK = false; continue; }\n\t\t\tif (a1[i][j] != 0 || (X[i][j] != V1[N1] && X[i][j] >= 1))OK = false;\n\t\t\ta1[i][j] = V1[N1]; G[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (X[i][j] == V1[N1] && G[i][j] == 0)OK = false;\n\t\t}\n\t}\n\treturn make_pair(OK, a1);\n}\nint main() {\n\twhile (true) {\n\t\tX.clear(); P.clear(); H = 0; W = 0; N = 0;\n\t\tcin >> W >> H >> N; int D1 = 0; if (W == 0 && H == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; i++) { cin >> V1[i] >> V2[i]; D1 += V2[i]; }\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tvector<int>G, I; int a;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a; G.push_back(a); I.push_back(0);\n\t\t\t}\n\t\t\tX.push_back(G); P.push_back(I);\n\t\t}\n\t\tif (D1 != W*H) { cout << \"NA\" << endl; continue; }\n\t\tQ.push(make_pair(0, P)); vector<vector<int> >res; int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tvector<vector<int>>K = Q.front().second;\n\t\t\tint L = Q.front().first; Q.pop();\n\t\t\tif (Q.size() >= 1000) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\twhile (!Q.empty())Q.pop();\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (L == N) { cnt++; res = K; continue; }\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 1; k <= V2[L]; k++) {\n\t\t\t\t\t\tif (V2[L] % k != 0)continue;\n\t\t\t\t\t\tpair<bool, vector<vector<int> > >res1 = hantei(K, i, j, k, V2[L] / k, L);\n\t\t\t\t\t\tif (res1.first == true) {\n\t\t\t\t\t\t\tQ.push(make_pair(L + 1, res1.second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0 || cnt >= 2)cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (j >= 1) { cout << ' '; }cout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\tE:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\nbool flag = false;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n\n    if ( r0 < 0 || c0 < 0 ) return false;\n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 + 1 ); r0 < min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 + 1 ); c0 < min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            -- s;\n            if ( s >= n ) {\n                flag = true;\n                return;\n            }\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        flag = false;\n        init();\n        input();\n        if ( flag ) {\n            cout << \"NA\" << endl;\n            continue;\n        }\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint X, Y, N;\nint k[16];\nint s[10][10];\nint t[10][10];\nint u;\nint v[10][10];\n\nbool input() {\n  cin >> X >> Y >> N;\n  if (!X && !Y && !N) {\n    return false;\n  }\n\n  for (int i = 0; i < N; ++i) {\n    int b;\n    cin >> b;\n    cin >> k[b];\n  }\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      cin >> s[i][j];\n    }\n  }\n\n  return true;\n}\n\nvoid paint(int id, int y1, int x1, int y2, int x2) {\n  for (int i = y1; i <= y2; ++i) {\n    for (int j = x1; j <= x2; ++j) {\n      t[i][j] = id;\n    }\n  }\n  u += (y2 - y1 + 1) * (x2 - x1 + 1);\n}\n\nvoid unpaint(int y1, int x1, int y2, int x2) {\n  for (int i = y1; i <= y2; ++i) {\n    for (int j = x1; j <= x2; ++j) {\n      t[i][j] = 0;\n    }\n  }\n  u -= (y2 - y1 + 1) * (x2 - x1 + 1);\n}\n\nvoid find_vacant(int &r, int &c) {\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      if (!t[i][j]) {\n        r = i;\n        c = j;\n        return;\n      }\n    }\n  }\n}\n\nvoid print_ans() {\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      if (!j) {\n        cout << v[i][j];\n      } else {\n        cout << \" \" << v[i][j];\n      }\n    }\n    cout << endl;\n  }\n}\n\nint dfs(int p, int q) {\n  if (u == X * Y) {\n    for (int i = 0; i < Y; ++i) {\n      for (int j = 0; j < X; ++j) {\n        v[i][j] = t[i][j];\n      }\n    }\n    return 1;\n  }\n\n  int z = 0;\n  for (int i = p; i < Y; ++i) {\n    for (int j = q; j < X; ++j) {\n      if (!t[i][j] && !s[i][j]) {\n        continue;\n      }\n      if (t[i][j] > 0) {\n        break;\n      }\n      int id = s[i][j];\n      for (int f = i; f < Y; ++f) {\n        int h = f - p + 1;\n        for (int g = j; g < X; ++g) {\n          if (t[f][g] > 0 || (s[f][g] != id && s[f][g])) {\n            break;\n          }\n          int w = g - q + 1;\n          int a = h * w;\n          if (k[id] > a) {\n            continue;\n          }\n          if (k[id] < a) {\n            break;\n          }\n          paint(id, p, q, f, g);\n          int np, nq;\n          find_vacant(np, nq);\n          z += dfs(np, nq);\n          unpaint(p, q, f, g);\n        }\n      }\n      break;\n    }\n  }\n  return z;\n}\n\nvoid solve() {\n  for (int i = 0; i < Y; ++i) {\n    for (int j = 0; j < X; ++j) {\n      t[i][j] = 0;\n    }\n  }\n  u = 0;\n  int z = dfs(0, 0);\n  if (z != 1) {\n    cout << \"NA\" << endl;\n  } else {\n    print_ans();\n  }\n}\n\nint main() {\n  while (input()) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n  /*\n  rep(y,H) rep(x,W) {\n    cout << \"(\" << x  << \",\" << y << \") ---- \" << endl;\n    rep(i,(int)edge[y][x].size()){\n      cout << \"(\" << edge[y][x][i].w << \",\" << edge[y][x][i].h << \",\" << edge[y][x][i].index << \") \";\n      cout << endl;\n    }\n      cout << endl;\n      cout << endl;\n  }\n  */\n}\n\nbool BackTracking(int cx,int cy){\n  /*\n  cout << cx << \",\" << cy << endl;\n  rep(i,H) {\n    rep(j,W) cout << ans[i][j] << \" \";\n    cout << endl;\n  }\n    cout << endl;\n  */\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    ii memo = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ){\n        memo = ii(x,y);\n        goto Skip2;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip2;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip2:;\n\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) {\n      if( x == memo.first && y == memo.second ) goto Skip3;\n      ans[cy+y][cx+x] = 0;\n    }\n  Skip3:;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { \n      rep(j,W) {\n        if( j ) cout << \" \";\n        cout << buf[i][j]; \n      } \n      cout << endl; \n    }\n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    rep(i,H) rep(j,W) cin >> s[i][j];\n    if( sum != H*W ) { puts(\"NA\"); continue; }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define repn(i, m, n) for (int i = m; i < int(n); ++i)\n\nint bk[20];\nint mp[20][20];\nint res[20][20];\nint result[20][20];\nint xy[20][2];\nint x, y ,n;\n\nint solve(int used[], int bit) {\n  /*\n  rep (i, y) {\n    rep (j, x) {\n      cout << res[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n  if (bit == 0) {\n    rep (i, y) rep (j, x) result[i][j] = res[i][j];\n    return 1;\n  }\n  int xx, yy;\n  rep (i, y) {\n    if (__builtin_popcount(used[i]) == x) continue;\n    yy = i;\n    xx = __builtin_popcount((~used[i] & -~used[i]) - 1);\n    break;\n  }\n  int r = 0;\n  rep (i, 20) {\n    if ((bit & 1 << i) == 0) continue;\n    if (xy[i][1] < xx) continue;\n    repn (j, xy[i][1] - xx + 1, x - xx + 1) {\n      if (bk[i] % j > 0) continue;\n      if (yy + bk[i] / j > y) continue;\n      if (yy + bk[i] / j <= xy[i][0]) continue;\n      int bb = (1 << (xx + j)) - (1 << xx);\n      bool ok = true;\n      rep (k, bk[i] / j) {\n\tif (used[yy + k] & bb) {\n\t  ok = false;\n\t  break;\n\t}\n      }\n      if (!ok) continue;\n      int next[20];\n      rep (k, y) {\n\tnext[k] = used[k];\n      }\n      rep (k, bk[i] / j) {\n\trep (l, j) {\n\t  res[yy + k][xx + l] = i;\n\t}\n\tnext[yy + k] |= bb;\n      }\n      r += solve(next, bit ^ 1 << i);\n      if (r > 1) return r;\n    }\n  }\n  return r;\n}\n\nint main() {\n  int used[20], sum;\n  for (;;) {\n    cin >> x >> y >> n;\n    if (x == 0 && y == 0 && n == 0) break;\n    sum = 0;\n    memset(bk, -1, sizeof(bk));\n    rep (i, n) {\n      int b, k;\n      cin >> b >> k;\n      bk[b] = k;\n      sum += k;\n    }\n    if (sum != x * y) {\n      cout << \"NA\\n\";\n      continue;\n    }\n    memset(xy, -1, sizeof(xy));\n    int bit = 0;\n    rep (i, y) rep (j, x) {\n      cin >> mp[i][j];\n      if (mp[i][j] > 0) {\n\txy[mp[i][j]][0] = i;\n\txy[mp[i][j]][1] = j;\n\tbit |= 1 << mp[i][j];\n      }\n    }\n    rep (i, 20) {\n      assert(!(bk[i] > 0 && xy[i][0] < 0)); \n    }\n    memset(used, 0, sizeof(used));\n    int r = solve(used, bit);\n    if (r == 1) {\n      rep (i, y) {\n\trep (j, x - 1) cout << result[i][j] << \" \";\n\tcout << result[i][x - 1] << endl;\n      }\n    } else {\n      cout << \"NA\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair< pair<int,int>,pair<int,int> > NODE;\n#define NY first.first\n#define NX first.second\n#define SY second.first\n#define SX second.second\n\nint X,Y,n,ret;\nvector< vector<int> > solve;\nmap<int,vector<NODE> > able;\nvector< vector<int> > data(10,vector<int>(10));\nvector< vector<int> > none(10,vector<int>(10));\nvector< vector<int> > rec;\n\nvoid bt(int dp){\n\tif(ret>1)return;\n\tvector<vector<int> > tt = rec;\n\tif(dp==n){\n\t\tbool flag = true;\n\t\trep(i,Y)rep(j,X)if(!rec[i][j])flag = false;\n\t\tif(flag){\n\t\t\tret++;\n\t\t\tsolve = rec;\n\t\t}\n\t\treturn;\n\t}\n\tmap<int,vector<NODE> >::iterator it = able.begin();\n\tfor(int i=0;i<dp;i++)it++;\n\t\n\tfor(int i=0;i<(*it).second.size();i++){\n\t\trep(y,(*it).second[i].SY)rep(x,(*it).second[i].SX){\n\t\t\trec[(*it).second[i].NY+y][(*it).second[i].NX+x]=(*it).first;\n\t\t}\n\t\tbt(dp+1);\n\t\trec = tt;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tmap<int,int> buy;\n\t\n\tint b,k;\n\tint name,cnt;\n\tpair<int,int> coord;\n\twhile(cin >> X >> Y >> n , X){\n\t\tret = 0;/*\trep(i,Y){\n\t\trep(j,X)cout << rec[i][j];\n\t\tcout << endl;\n\t}\n*/\n\t\table.clear();\n\t\tbuy.clear();\n\t\trep(i,Y)rep(j,X)data[i][j]=0;\n\t\trep(i,n){\n\t\t\tcin >> b >> k;\n\t\t\tbuy[b] = k;\n\t\t}\n\t\trep(i,Y)rep(j,X)cin >> data[i][j];\n\n\t\trep(i,Y)rep(j,X){\n\t\t\trep(y,Y)rep(x,X){\n\t\t\t\tif( j+x > X-1 || i+y > Y-1 )continue;\n\t\t\t\tcnt = 0;\n\t\t\t\trep(YY,i+1)rep(XX,j+1)\n\t\t\t\t\tif(data[y+YY][x+XX]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tname = data[y+YY][x+XX];\n\t\t\t\t\t\tcoord = make_pair(y,x);\n\t\t\t\t\t}\n\t\t\t\tif(cnt == 1 && (i+1)*(j+1) == buy[name] ){\n\t\t\t\t\table[name].push_back( make_pair(coord,make_pair(i+1,j+1)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tmap<int,vector<NODE> >::iterator it = able.begin();\n\t\twhile(it != able.end()){\n\t\t\tfor(int i=0;i<(*it).second.size();i++)\n\t\t\t\tcout << (*it).first << \"=\" << (*it).second[i].NX << \",\" << (*it).second[i].NY << \" -> \" << (*it).second[i].SX << \",\" << (*it).second[i].SY << endl;\n\t\t\t++it;\n\t\t}\n*/\n\t\trec = none;\n\t\tbt(0);\n\t\tif(ret==1){\n\t\t\trep(i,Y){\n\t\t\t\trep(j,X)cout << solve[i][j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair< pair<int,int>,pair<int,int> > NODE;\n#define NY first.first\n#define NX first.second\n#define SY second.first\n#define SX second.second\n\nint X,Y,n,ret;\nvector< vector<int> > solve;\nmap<int,vector<NODE> > able;\nvector< vector<int> > data(20,vector<int>(20));\nvector< vector<int> > none(20,vector<int>(20));\nvector< vector<int> > rec(20,vector<int>(20));\n\nvoid bt(int dp){\n\tif(ret>1)return;\n\tvector<vector<int> > tt = rec;\n\tbool flag;\n\tif(dp==n){\n\t\tflag = true;\n\t\trep(i,Y)rep(j,X)if(!rec[i][j])flag = false;\n\t\tif(flag){\n\t\t\tret++;\n\t\t\tsolve = rec;\n\t\t}\n\t\treturn;\n\t}\n\tmap<int,vector<NODE> >::iterator it = able.begin();\n\tfor(int i=0;i<dp;i++)it++;\n\tfor(int i=0;i<(*it).second.size();i++){\n\t\tflag = true;\n\t\trep(y,(*it).second[i].SY)rep(x,(*it).second[i].SX){\n\t\t\tif(rec[(*it).second[i].NY+y][(*it).second[i].NX+x])flag = false;\n\t\t\trec[(*it).second[i].NY+y][(*it).second[i].NX+x]=(*it).first;\n\t\t}\n\t\tif(flag)bt(dp+1);\n\t\trec = tt;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tmap<int,int> buy;\n\t\n\tint b,k;\n\tint name,cnt;\n\tpair<int,int> coord;\n\twhile(cin >> X >> Y >> n , X){\n\t\tret = 0;/*\trep(i,Y){\n\t\trep(j,X)cout << rec[i][j];\n\t\tcout << endl;\n\t}\n*/\n\t\table.clear();\n\t\tbuy.clear();\n\t\trep(i,Y)rep(j,X)data[i][j]=0;\n\t\trep(i,n){\n\t\t\tcin >> b >> k;\n\t\t\tbuy[b] = k;\n\t\t}\n\t\trep(i,Y)rep(j,X)cin >> data[i][j];\n\n\t\trep(i,Y)rep(j,X){\n\t\t\trep(y,Y)rep(x,X){\n\t\t\t\tif( j+x > X-1 || i+y > Y-1 )continue;\n\t\t\t\tcnt = 0;\n\t\t\t\trep(YY,i+1)rep(XX,j+1)\n\t\t\t\t\tif(data[y+YY][x+XX]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tname = data[y+YY][x+XX];\n\t\t\t\t\t\tcoord = make_pair(y,x);\n\t\t\t\t\t}\n\t\t\t\tif(cnt == 1 && (i+1)*(j+1) == buy[name] ){\n\t\t\t\t\table[name].push_back( make_pair(coord,make_pair(i+1,j+1)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tmap<int,vector<NODE> >::iterator it = able.begin();\n\t\twhile(it != able.end()){\n\t\t\tfor(int i=0;i<(*it).second.size();i++)\n\t\t\t\tcout << (*it).first << \"=\" << (*it).second[i].NX << \",\" << (*it).second[i].NY << \" -> \" << (*it).second[i].SX << \",\" << (*it).second[i].SY << endl;\n\t\t\t++it;\n\t\t}\n*/\n\t\trec = none;\n\t\tif(n == able.size() )bt(0);\n\t\tif(ret==1){\n\t\t\trep(i,Y){\n\t\t\t\trep(j,X){if(j)cout << \" \";cout << solve[i][j];}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint w, h;\nvector<int> area;\nvector<vector<int> > sum;\n\nint retNum;\nvector<vector<int> > ret;\n\nvoid solve(int y, int x, vector<vector<int> >& used)\n{\n    if(x > w){\n        ++ y;\n        x = 1;\n    }\n    if(y > h){\n        ++ retNum;\n        ret = used;\n        return;\n    }\n\n    if(used[y][x] != 0){\n        solve(y, x+1, used);\n        return;\n    }\n\n    for(int y1=y; y1<=h; ++y1){\n        for(int x1=x; x1<=w; ++x1){\n            bitset<16> bs = sum[y1][x1] & (~sum[y1][x-1]) & (~sum[y-1][x1]);\n            if(bs.count() != 1)\n                continue;\n\n            int k = 0;\n            while(!bs[k])\n                ++ k;\n            if(area[k] != (y1 - y + 1) * (x1 - x + 1))\n                continue;\n\n            bool ng = false;\n            vector<vector<int> > used1 = used;\n            for(int i=y; i<=y1; ++i){\n                for(int j=x; j<=x1; ++j){\n                    if(used1[i][j] != 0)\n                        ng = true;\n                    used1[i][j] = k;\n                }\n            }\n            if(!ng)\n                solve(y, x+1, used1);\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n\n        area.assign(n+1, 0);\n        for(int i=0; i<n; ++i){\n            int b, k;\n            cin >> b >> k;\n            area[b] = k;\n        }\n\n        sum.assign(h+1, vector<int>(w+1, 0));\n        for(int y=1; y<=h; ++y){\n            int tmp = 0;\n            for(int x=1; x<=w; ++x){\n                int a;\n                cin >> a;\n                if(a > 0)\n                    tmp |= (1 << a);\n                sum[y][x] = sum[y-1][x] | tmp;\n            }\n        }\n\n        retNum = 0;\n        vector<vector<int>> s(h+1, vector<int>(w+1, 0));\n        solve(1, 1, s);\n\n        if(retNum != 1){\n            cout << \"NA\" << endl;\n        }else{\n            for(int i=1; i<=h; ++i){\n                cout << ret[i][1];\n                for(int j=2; j<=w; ++j)\n                    cout << ' ' << ret[i][j];\n                cout << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\nusing namespace std;\n\nint X, Y, n;\nvector<vector<int>> s;\nvector<vector<int>> answer;\nvector<int> area;\n\n// id, 左上, 右下\nbool placeable(vector<vector<int>> field, int id, int y1, int x1, int y2, int x2) {\n    bool ok = false;\n    for(int i = y1; i <= y2; ++i) for(int j = x1; j <= x2; ++j) {\n        if(field[i][j] && field[i][j] != id) return false;\n        if(field[i][j] == id) ok = true;\n    }\n    return ok;\n}\nvector<vector<int>> place(vector<vector<int>> field, int id, int y1, int x1, int y2, int x2) {\n    for(int i = y1; i <= y2; ++i) for(int j = x1; j <= x2; ++j) field[i][j] = id;\n    return field;\n}\n\nbool in(int y, int x) {\n    return 0 <= y && y < Y && 0 <= x && x < X;\n}\n\nint dfs(vector<vector<int>> field, bitset<16> used) {\n    if(used.count() == n) {\n        answer = field;\n        return 1;\n    }\n\n    int y, x;\n    y = x = -1;\n    for(int i = 0; y == -1 && i < Y; ++i) for(int j = 0; x == -1 && j < X; ++j) if(!used[field[i][j]]) {\n        y = i;\n        x = j;\n    }\n\n    int result = 0;\n    for(int id = 1; id <= n; ++id) {\n        if(used[id]) continue;\n        if(field[y][x] && field[y][x] != id) continue;\n        int a = area[id];\n        for(int i = 1; i <= a; ++i) {\n            if(a % i) continue;\n            int j = a / i;\n            int ny = y + i - 1;\n            int nx = x + j - 1;\n            if(!in(ny, nx)) continue;\n            if(!placeable(field, id, y, x, ny, nx)) continue;\n            result += dfs(place(field, id, y, x, ny, nx), used.set(id));\n            used.reset(id);\n        }\n        /*\n        for(int t = 0; t < a; ++t) {\n            int i = y + t;\n            int j = x + a / (t + 1) - 1;\n            if(!in(i, j)) continue;\n            if(!placeable(field, id, y, x, i, j)) continue;\n            result += dfs(place(field, id, y, x, i, j), used.set(id));\n            used.reset(id);\n        }\n        */\n    }\n    return result;\n}\n\nint main() {\n    while(cin >> X >> Y >> n, X | Y | n) {\n        area.clear();\n        area.resize(n + 1);\n        for(int i = 0; i < n; ++i) {\n            int b, k;\n            cin >> b >> k;\n            area[b] = k;\n        }\n        s.clear();\n        s.resize(Y, vector<int>(X));\n        for(auto& y: s) for(auto& x: y) cin >> x;\n\n        if(dfs(s, 0) == 1) {\n            for(int i = 0; i < Y; ++i) {\n                for(int j = 0; j < X; ++j) cout << (j ? \" \" : \"\") << answer[i][j];\n                cout << endl;\n            }\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,n,land[10][10],test[10][10],ans[10][10];\n\nbool search(int i0,int j0){\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\n\t\t\tif(id<0 || n<id)\tcontinue;\n\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++)test[yy][xx]=id;\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++)test[yy][xx]=0;\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn cnt==1;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tans[i][j]=test[i][j];\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++)\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n\n    if ( r0 < 0 || c0 < 0 ) return false;\n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid output2() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 ); r0 < min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 ); c0 < min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nconst int MAX_NUM = 11;\nint w, h, n;\nint T[SIZE][SIZE];\nint TC[SIZE][SIZE];\nint K[MAX_NUM]; \nII U[MAX_NUM]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[SIZE][SIZE];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint W, H, N; \nint b[16], k[16];\nint s[10][10];\nint ans[10][10];\nint used[10][10];\nint TX[20], TY[20];\nclass DFSError {};\nvoid dfs(int idx){\n  if(idx == N) {\n    if(ans[0][0] != -1) throw DFSError();\n    REP(y, H)REP(x, W) ans[y][x] = used[y][x];\n    return;\n  }\n  /*\n  printf(\"idx = %d\\n\", idx);\n  REP(y, H){\n    REP(x, W){\n      cout << used[y][x];\n      if(x != W - 1) cout << \" \";\n      else cout << endl;\n    }\n  }\n  */\n  int tx = TX[b[idx] - 1];\n  int ty = TY[b[idx] - 1];\n  //printf(\"idx = %d tx = %d ty = %d\\n\", idx, tx, ty);\n  \n  assert(idx < N);\n  assert(b[idx] >= 1 && b[idx] <= N);\n  assert(tx != -1);\n  for(int h = 1; h <= k[idx]; h++) if(k[idx] % h == 0){\n    int w = k[idx] / h;\n    for(int by = 0; by > -h; by--) for(int bx = 0; bx > -w; bx--){\n      int sx = tx + bx;\n      int sy = ty + by;\n      bool ok = true;\n      for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n        if(!valid(sx + x, sy + y, W, H) || used[sy + y][sx + x] != -1) ok = false;\n      }\n      if(ok){\n        int tmp[10][10];\n        memcpy(tmp, used, sizeof(used));\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n          used[sy + y][sx + x] = b[idx];\n        }\n        dfs(idx + 1);\n        memcpy(used, tmp, sizeof(used));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H >> N && W){\n    REP(i, N) cin >> b[i] >> k[i];\n    REP(y, H)REP(x, W) cin >> s[y][x];\n    try{\n      memset(used, -1, sizeof(used));\n      memset(ans, -1, sizeof(ans));\n      memset(TX, -1, sizeof(TX));\n      memset(TY, -1, sizeof(TY));\n      REP(y, H) REP(x, W) if(s[y][x] > 0) TX[s[y][x] - 1] = x, TY[s[y][x] - 1] = y;\n      REP(i, N) assert(TX[i] != -1);\n      dfs(0);\n      if(ans[0][0] == -1) throw DFSError();\n      REP(y, H){\n        REP(x, W){\n          cout << ans[y][x];\n          if(x != W - 1) cout << \" \";\n          else cout << endl;\n        }\n      }\n    }catch(...){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/01/07 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nbool DFS(int X, int Y, int n, int bk[15][2], int s[10][10], int& cnt, int ans[10][10])\n{\n\tif(n==0){\n\t\tfor(int y=0; y<Y; y++)\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t\tif(s[y][x]==0)\n\t\t\t\t\treturn false;\n\n\t\tcnt++;\n\t\tfor(int y=0; y<Y; y++)\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t\tans[y][x] = s[y][x];\n\t\treturn true;\n\t}\n\n\tint bx;\n\tint by;\n\tbool flg = false;\n\tfor(by=0; by<Y; by++){\n\t\tfor(bx=0; bx<X; bx++){\n\t\t\tif(s[by][bx]==bk[n-1][0])\n\t\t\t\tflg = true;\n\t\t\tif(flg)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(flg)\n\t\t\tbreak;\n\t}\n\n\tfor(int kY=1; kY<=bk[n-1][1]; kY++){\n\t\tif(bk[n-1][1]%kY!=0)\n\t\t\tcontinue;\n\n\t\tint kX = bk[n-1][1]/kY;\n\n\t\tfor(int i=0; i<kY; i++)\n\t\t\tfor(int j=0; j<kX; j++){\n\t\t\t\tint tmp[10][10];\n\t\t\t\tfor(int y=0; y<Y; y++)\n\t\t\t\t\tfor(int x=0; x<X; x++)\n\t\t\t\t\t\ttmp[y][x] = s[y][x];\n\n\t\t\t\tbool flg2 = true;\n\t\t\t\tint my = by-i;\n\t\t\t\tfor(int mm=0; mm<kY; mm++){\n\t\t\t\t\tint nx = bx-j;\n\t\t\t\t\tfor(int nn=0; nn<kX; nn++){\n\t\t\t\t\t\tif((my>=0&&my<Y)\n\t\t\t\t\t\t &&(nx>=0&&nx<X)\n\t\t\t\t\t\t &&(s[my][nx]==0||s[my][nx]==bk[n-1][0]))\n\t\t\t\t\t\t\ttmp[my][nx] = bk[n-1][0];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tflg2 = false;\n\t\t\t\t\t\tif(!flg2)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tnx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmy++;\n\t\t\t\t}\n\n\t\t\t\tif(flg2)\n\t\t\t\t\tDFS(X, Y, n-1, bk, tmp, cnt, ans);\n\t\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile(true){\n\t\tint X, Y, n;\n\t\tcin >> X >> Y >> n;\n\t\tif(X==0&&Y==0&&n==0)\n\t\t\tbreak;\n\n\t\tint bk[15][2];\n\t\tfor(int i=0; i<n; i++)\n\t\t\tcin >> bk[i][0] >> bk[i][1];\n\n\t\tint s[10][10];\n\t\tfor(int y=0; y<Y; y++)\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t\tcin >> s[y][x];\n\n\t\tint cnt = 0;\n\t\tint ans[10][10];\n\t\tfor(int y=0; y<Y; y++)\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t\tans[y][x] = -1;\n\n\t\tDFS(X, Y, n, bk, s, cnt, ans);\n\n\t\tif(cnt==1)\n\t\t\tfor(int y=0; y<Y; y++)\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tcout << ans[y][x];\n\t\t\t\t\tif(x!=X-1)\n\t\t\t\t\t\tcout << ' ';\n\t\t\t\t\telse\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int WH_SIZE = 11;\nconst int SIZE = 16;\nint w, h;\nint n; \nint K[SIZE*2]; \nint S[WH_SIZE*2][WH_SIZE*2];\nII T[11*2]; \nVVI M;\nVVI A;\nint cnt;\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int b;\n            cin >> b;\n            S[i][j] = b;\n            if ( b > 0 ) {\n                b --;\n                T[b] = II( i, j );\n            }\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << A[i][j];\n            if ( j + 1 < w ) cout << \" \";  \n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            int r1 = r0 + i;\n            int c1 = c0 + j;\n            if ( S[r1][c1] != k && S[r1][c1] != 0 ) return false;\n            if ( M[r1][c1] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            int r1 = r0 + i;\n            int c1 = c0 + j;\n            M[r1][c1] = k;\n        }\n    }\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        A = M;\n        cnt ++;\n        return;\n    }\n    \n    int r = T[depth].first;\n    int c = T[depth].second;\n    int k = K[depth];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( k % w0 != 0 ) continue;\n        int h0 = k / w0;\n        for ( int r0 = max( 0, r - h0 + 1 ); r0 + h0 - 1 < h; ++ r0 ) {\n            for ( int c0 = max( 0, c - w0 + 1 ); c0 + w0 - 1 < w; ++ c0 ) {\n                if ( ! ( r0 <= r && r <= r0 + h0 - 1 && c0 <= c && c <= c0 + w0 - 1 ) ) continue;\n                if ( ! canPut( depth + 1, r0, c0, w0, h0 ) ) continue;\n                put( depth + 1, r0, c0, w0, h0 );\n                solve( depth + 1 );\n                if ( cnt >= 2 ) return;\n                put( 0, r0, c0, w0, h0 );\n            }\n        }\n    }\n    \n    return;\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        M = VVI( h, VI( w, 0 ) );\n        input();\n        cnt = 0;\n        solve(0);\n        if ( cnt == 0 || cnt == 2 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\n\tbool isAnswer(){\n\t\tREP(y,Y)REP(x,X) if(board[y][x]==0)return false;\n\t\treturn true;\n\t}\n\n\tbool canset(int yl,int xl,int h,int w){\n\t\tFOR(y,yl,yl+h)FOR(x,xl,xl+w)if(board[y][x]!=0)return false; \n\t\treturn true;\n\t}\n\tvoid set(int yl,int xl,int h,int w,int v){\n\t\tFOR(y,yl,yl+h)FOR(x,xl,xl+w)board[y][x]=v;\n\t}\n\n\tint dfs(int i){\n\t\tif(i==N){\n\t\t\tif(isAnswer()){\n\t\t\t\tres=board;\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tint res=0;\n\t\tfor(int w=1;w<=X;w++)if(as[i]%w==0){\n\t\t\tint h=as[i]/w;\n\n\t\t\tfor(int y=ys[i]-h+1;y<=ys[i];y++)for(int x=xs[i]-w+1;x<=xs[i];x++)\n\t\t\t\tif((0<=x && x+w<=X) && (0<=y && y+h<=Y)){\n\t\t\t\t\tboard[ys[i]][xs[i]]=0;\t\n\t\t\t\t\tif(canset(y,x,h,w)){\n\t\t\t\t\t\tset(y,x,h,w,i+1);\n\t\t\t\t\t\tres+=dfs(i+1);\n\t\t\t\t\t\tset(y,x,h,w,0);\n\t\t\t\t\t}\n\t\t\t\t\tboard[ys[i]][xs[i]]=i+1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint X,Y,N;\n\tvector<int> xs,ys;\n\n\tvector<int> as;\n\tvector<vector<int>> board;vector<vector<int>> res;\n\t\n\tvoid run(){\n\t\twhile(true){\n\t\t\tcin >> X >> Y >> N;\n\t\t\tif(X==0)break;\t\n\t\t\tas=vector<int>(N);\n\t\t\tREP(i,N){\n\t\t\t\tint j,v;cin >> j >> v;j--;\n\t\t\t\tas[j]=v;\n\t\t\t}\n\t\t\txs=vector<int>(N);ys=vector<int>(N);\n\n\t\t\tboard=vector<vector<int>>(Y,vector<int>(X));\n\t\t\tREP(y,Y)REP(x,X){\n\t\t\t\tcin >> board[y][x];\n\t\t\t\tif(board[y][x]!=0){\n\t\t\t\t\txs[board[y][x]-1]=x;ys[board[y][x]-1]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint resc=dfs(0);\n\t\t\tif(resc==1){\n\t\t\t\tcout << toString(res)<<endl;\n\t\t\t}else{\n\t\t\t\tcout <<\"NA\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef bitset<20> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    Rect() {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\nvector<Rect> ans;\nvector<Rect> tags;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else if(any_of(cur.begin(), cur.end(), [r,c](const Rect &re){return re.intersect(Rect(r,c,1,1));})) {\n        dfs(r, c+1, state, cur);\n    } else {\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int i = 0; i < N; ++i) {\n                    if(i == b && !cand.intersect(tags[i])) goto next;\n                    if(i != b && cand.intersect(tags[i])) goto next;\n                }\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    tags.clear();\n    tags.resize(N);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            int v;\n            cin >> v;\n            if(v != 0) {\n                tags[v-1] = Rect(r, c, 1, 1);\n            }\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        vector<vector<int>> field(H, vector<int>(W, 0));\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing vec = std::vector<int>;\nusing Land = std::vector<std::vector<int>>;\n\nint W, H, N;\nLand s;\nstd::vector<Land> res;\n\nbool check(int h, int w, int a, int b, int num)\n{\n    if (h + a > H || w + b > W) {\n        return false;\n    }\n    for (int i = h; i < h + a; i++) {\n        for (int j = w; j < w + b; j++) {\n            if (s[i][j] != 0 && s[i][j] != num) {\n                return false;\n            }\n        }\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (h <= i && i < h + a && w <= j && j < w + b) {\n                continue;\n            }\n            if (s[i][j] == num) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nvoid paint(int h, int w, int a, int b, int num)\n{\n    for (int i = h; i < h + a; i++) {\n        for (int j = w; j < w + b; j++) {\n            s[i][j] = num;\n        }\n    }\n}\n\nvoid dfs(int idx, const vec &b, const vec &k)\n{\n    if (idx == N) {\n        res.emplace_back(s);        \n        return;\n    }    \n    \n    for (int i = 1; i <= k[idx]; i++) {\n        int j = k[idx] / i;\n        if (i * j != k[idx]) continue;\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {                \n                if (check(h, w, i, j, b[idx])) {\n                    auto tmp = s;\n                    paint(h, w, i, j, b[idx]);\n                    dfs(idx + 1, b, k);\n                    s = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid print(Land &l)\n{\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (j > 0) std::cout << \" \";            \n            std::cout << l[i][j];\n        }\n        std::cout << std::endl;\n    }\n}\n\nvoid init()\n{\n    s.assign(H, std::vector<int>(W));\n    res.clear();\n}\n\nint main()\n{\n    while (std::cin >> W >> H >> N, W) {\n        init();\n        vec b(N), k(N);\n        for (int i = 0; i < N; i++) {\n            std::cin >> b[i] >> k[i];\n        }\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                std::cin >> s[i][j];\n            }\n        }\n\n        dfs(0, b, k);\n\n        if (res.size() != 1) {\n            std::cout << \"NA\" << std::endl;\n        } else {\n            print(res[0]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing vec = std::vector<int>;\nusing Land = std::vector<std::vector<char>>;\n\nint W, H, N;\nLand s;\nstd::vector<Land> res;\n\nbool check(int h, int w, int a, int b, char num)\n{\n    if (h + a > H || w + b > W) {\n        return false;\n    }\n    for (int i = h; i < h + a; i++) {\n        for (int j = w; j < w + b; j++) {\n            if (s[i][j] != '0' && s[i][j] != num) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid paint(int h, int w, int a, int b, char num)\n{\n    for (int i = h; i < h + a; i++) {\n        for (int j = w; j < w + b; j++) {\n            s[i][j] = num;\n        }\n    }\n}\n\nvoid dfs(int idx, const vec &b, const vec &k)\n{\n    if (idx == N) {\n        res.emplace_back(s);\n        return;\n    }\n\n    for (int i = 1; i <= k[idx]; i++) {\n        int j = k[idx] / i;\n        if (i * j != k[idx]) continue;\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {                \n                if (check(h, w, i, j, b[idx] + '0')) {\n                    auto tmp = s;\n                    paint(h, w, i, j, b[idx] + '0');\n                    dfs(idx + 1, b, k);\n                    s = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid print(Land &l)\n{\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (j > 0) std::cout << \" \";            \n            std::cout << l[i][j];\n        }\n        std::cout << std::endl;\n    }\n}\n\nvoid init()\n{\n    s.assign(H, std::vector<char>(W));\n    res.clear();\n}\n\nint main()\n{\n    while (std::cin >> W >> H >> N, W) {\n        init();\n        vec b(N), k(N);\n        for (int i = 0; i < N; i++) {\n            std::cin >> b[i] >> k[i];\n        }\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                std::cin >> s[i][j];\n            }\n        }\n\n        dfs(0, b, k);\n\n        if (res.size() != 1) {\n            std::cout << \"NA\" << std::endl;\n        } else {\n            print(res[0]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,land[10][10],test[10][10],ans[10][10];\n\nbool search(int i0,int j0){\n//printf(\"i0=%d, j0=%d\\n\",i0,j0);\n//for(int a=0;a<h;a++){for(int b=0;b<w;b++)printf(\"%d \",test[a][b]);puts(\"\");}puts(\"\");\n\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\n\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++)test[yy][xx]=id;\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++)test[yy][xx]=0;\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tans[i][j]=test[i][j];\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++)\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\n\nint w, h, n;\nint area[15];\nvector<pii> size[15];\npii flag[15];\nint field[10][10];\nint tmp[10][10];\nint ans[10][10];\nbool found;\n\nvoid dfs(int y, int x, int d, int a[])\n{\n\tif(d == n){\n\t\tif(!found){\n\t\t\trep(i, h) rep(j, w)\n\t\t\t\tans[i][j] = tmp[i][j];\n\t\t\tfound = true;\n\t\t}\n\t\telse{\n\t\t\tans[0][0] = -1;\n\t\t}\n\t\treturn;\n\t}\n\t\n\twhile(tmp[y][x]){\n\t\t++x;\n\t\tif(x == w){\n\t\t\tx = 0;\n\t\t\t++y;\n\t\t}\n\t}\n\treps(k, d, n){\n\t\tswap(a[d], a[k]);\n\t\tint minh = flag[a[d]].first - y + 1;\n\t\tint minw = flag[a[d]].second - x + 1;\n\t\tif(0<=minh && 0<=minw){\n\t\t\tint maxh = h-y;\n\t\t\tint maxw = w-x;\n\t\t\trep(l, size[a[d]].size()){\n\t\t\t\tint th = size[a[d]][l].first;\n\t\t\t\tint tw = size[a[d]][l].second;\n\t\t\t\tif(th<minh || maxh<th || tw<minw || maxw<tw)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(i, th) rep(j, tw){\n\t\t\t\t\tif(tmp[y+i][x+j] != 0 || (field[y+i][x+j] != 0 && field[y+i][x+j] != a[d]+1))\n\t\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\trep(i, th) rep(j, tw){\n\t\t\t\t\ttmp[y+i][x+j] = a[d] + 1;\n\t\t\t\t}\n\t\t\t\tdfs(y, x, d+1, a);\n\t\t\t\trep(i, th) rep(j, tw){\n\t\t\t\t\ttmp[y+i][x+j] = 0;\n\t\t\t\t}\nend:;\n\t\t\t}\n\t\t}\n\t\tswap(a[d], a[k]);\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d%d\", &w, &h, &n), n){\n\t\tans[0][0] = -1;\n\t\trep(i, h) \n\t\t\tfill(tmp[i], tmp[i]+w, 0);\n\t\tfound = false;\n\n\t\trep(i, n){\n\t\t\tint b, k;\n\t\t\tscanf(\"%d%d\", &b, &k);\n\t\t\t--b;\n\t\t\tarea[b] = k;\n\t\t\tsize[b].clear();\n\t\t\treps(y, 1, h+1){\n\t\t\t\tif(k%y == 0){\n\t\t\t\t\tint x = k / y;\n\t\t\t\t\tif(x <= w)\n\t\t\t\t\t\tsize[b].push_back(pii(y, x));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, h) rep(j, w){\n\t\t\tscanf(\"%d\", &field[i][j]);\n\t\t\tif(field[i][j] != 0)\n\t\t\t\tflag[field[i][j]-1] = pii(i, j);\n\t\t}\n\t\tint a[15];\n\t\trep(i, n)\n\t\t\ta[i] = i;\n\t\tdfs(0, 0, 0, a);\n\n\t\tif(ans[0][0] == -1)\n\t\t\tputs(\"NA\");\n\t\telse{\n\t\t\trep(i, h) rep(j, w)\n\t\t\t\tprintf(\"%d%c\", ans[i][j], j==w-1?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <functional>\nusing namespace std;\n\n#define N_MAX 15\n#define S_MAX 10\n\nint X, Y, n, M[S_MAX][S_MAX];\nvector< pair<int, int> > k;\nint ans;\n\nstruct Rect {\n  int x, y, w, h;\n};\nRect R[N_MAX];\n\nbool isHit(int u) {\n  for(int i = 0; i < n; ++i) {\n    if(i == u) continue;\n    if(R[u].x >= R[i].x + R[i].w) continue;\n    if(R[u].y >= R[i].y + R[i].h) continue;\n    if(R[i].x >= R[u].x + R[u].w) continue;\n    if(R[i].y >= R[u].y + R[u].h) continue;\n    return true;\n  }\n  return false;\n}\n\nvoid draw() {\n  for(int i = 0; i < n; ++i) {\n    for(int dx = 0; dx < R[i].w; ++dx) {\n      for(int dy = 0; dy < R[i].h; ++dy) {\n\tM[R[i].y+dy][R[i].x+dx] = i+1;\n      }\n    }\n  }\n}\n\nvoid rec(int p) {\n  if(p == n) {\n    draw();\n    ans++;\n    return;\n  }\n\n  int x = R[k[p].second].x;\n  int y = R[k[p].second].y;\n\n  for(int h = 1; h <= k[p].first; ++h) {\n    if(k[p].first % h != 0) continue;\n    int w = k[p].first / h;\n    R[k[p].second].h = h;\n    R[k[p].second].w = w;\n    for(int ny = y-h+1; ny <= y; ++ny) {\n      for(int nx = x-w+1; nx <= x; ++nx) {\n\tif(nx < 0 || nx + w > X) continue;\n\tif(ny < 0 || ny + h > Y) continue;\n\tR[k[p].second].x = nx;\n\tR[k[p].second].y = ny;\n\tif(!isHit(k[p].second)) rec(p+1);\n\tif(ans >= 2) return;\n      }\n    }\n  }\n  R[k[p].second].x = x;\n  R[k[p].second].y = y;\n  R[k[p].second].w = 1;\n  R[k[p].second].h = 1;\n}\n\n\nvoid solve() {\n  ans = 0;\n  sort(k.begin(), k.end(), greater< pair<int, int> >());\n  rec(0);\n  if(ans == 1) {\n    for(int i = 0; i < Y; ++i) {\n      for(int j = 0; j < X; ++j) {\n\tif(j != 0) cout << \" \";\n\tcout << M[i][j];\n      }\n      cout << endl;\n    }\n  } else {\n    cout << \"NA\" << endl;\n  }\n}\n\nmain() {\n  while((cin >> X >> Y >> n) && (X || Y || n)) {\n    k.clear();\n    for(int i = 0; i < n; ++i) {\n      int b, s;\n      cin >> b >> s;\n      b--;\n      k.push_back(pair<int, int>(s, b));\n    }\n    for(int i = 0; i < Y; ++i) {\n      for(int j = 0; j < X; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] != 0) {\n\t  int u = M[i][j] - 1;\n\t  R[u].x = j;\n\t  R[u].y = i;\n\t  R[u].w = 1;\n\t  R[u].h = 1;\n\t}\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\nbool use[16];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tvector<vector<int> > cpy = ans;\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j] && !use[ok[y][x][i][j]]) {\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tuse[ok[y][x][i][j]] = true;\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tans = cpy;\n\t\t\t\tuse[ok[y][x][i][j]] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tout.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n\t\tfor(int i = 0; i < 16; i++)\n\t\t\tuse[i] = false;\n\t\tfor(int i = 1; i < v.size(); i++) v[i] = -1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tif(v[i] < 0) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = 0; y < Y && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = 0; x < X && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt != 1) ok[i][j][k][l] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < v.size(); i++) sum += v[i];\n\t\tbool flg = true;\n\t\tfor(int i = 0; i < out.size(); i++)\n\t\t\tfor(int j = 0; j < out[i].size(); j++)\n\t\t\t\tflg &= out[i][j] != 0;\n\n\t\tif(res == 1 && sum == X*Y && flg) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nint T[11][11];\nint TC[11][11];\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[k] % w0 != 0 ) continue;\n        int h0 = K[k] / w0;\n        for ( int r0 = 0; r0 + h0 - 1 < h; ++ r0 ) {\n            for ( int c0 = 0; c0 + w0 - 1 < w; ++ c0 ) {\n                if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                    if ( canPut( r0, c0, w0, h0 ) ) {\n                        for ( int i = 0; i < h0; ++ i ) {\n                            for ( int j = 0; j < w0; ++ j ) {\n                                Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                            }\n                        }\n                        put( k, r0, c0, w0, h0 );\n                        solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                        for ( int i = 0; i < h0; ++ i ) {\n                            for ( int j = 0; j < w0; ++ j ) {\n                                T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                            }\n                        }\n                    }\n                    if ( cnt >= 2 ) return;\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<int> sx[101],sy[101],ex[101],ey[101];\nint W,H,K;\nint ans_cnt = 0;\nint used[10][10];\nint ans[10][10];\nint current[10][10];\nvoid f(int pos){\n\tif(pos == K+1){\n\t\tint ok = 1;\n\t\tfor(int i = 0 ; i < H ; i++)\n\t\t\tfor(int j = 0 ; j < W ; j++)\n\t\t\t\tok &= used[i][j] == 1;\n\t\tif(ok){\n\t\t\tfor(int i = 0 ; i < H ; i++)\n\t\t\t\tfor(int j = 0 ; j < W ; j++)\n\t\t\t\t\tans[i][j] = current[i][j];\n\t\t\tans_cnt++;\n\t\t}\n\t\treturn;\n\t}\n\tif(ans_cnt >= 2) return;\n\tfor(int i = 0 ; i < sx[pos].size() ; i++){\n\t\tint ok = 1;\n\t\tfor(int x = sx[pos][i] ; x < ex[pos][i] ; x++){\n\t\t\tfor(int y = sy[pos][i] ; y < ey[pos][i] ; y++){\n\t\t\t\tok &= used[y][x] == 0;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tfor(int x = sx[pos][i] ; x < ex[pos][i] ; x++){\n\t\t\t\tfor(int y = sy[pos][i] ; y < ey[pos][i] ; y++){\n\t\t\t\t\tused[y][x] = 1;\n\t\t\t\t\tcurrent[y][x] = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(pos+1);\n\t\t\tfor(int x = sx[pos][i] ; x < ex[pos][i] ; x++){\n\t\t\t\tfor(int y = sy[pos][i] ; y < ey[pos][i] ; y++){\n\t\t\t\t\tused[y][x] = 0;\n\t\t\t\t\tcurrent[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint d[10][10];\n\tint sz[101];\n\twhile(cin >> W >> H >> K && W){\n\t\tfor(int i = 0 ; i < 101 ; i++){\n\t\t\tsx[i].clear(); sy[i].clear(); ex[i].clear(); ey[i].clear();\n\t\t}\n\t\tmap<int,int> from,to;\n\t\tfrom[0] = 0; // dummy\n\t\tfor(int i = 0 ; i < K ; i++){\n\t\t\tint t,s;\n\t\t\tcin >> t >> s;\n\t\t\tto[t] = from.size();\n\t\t\tfrom[to[t]] = t;\n\t\t\tsz[to[t]] = s;\n\t\t}\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> d[i][j];\n\t\t\t\td[i][j] = to[d[i][j]];\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int h = 1 ; h <= H ; h++){\n\t\t\tfor(int w = 1 ; w <= W ; w++){\n\t\t\t\tfor(int i = 0 ; i <= H - h ; i++){\n\t\t\t\t\tfor(int j = 0 ; j <= W - w ; j++){\n\t\t\t\t\t\tint c = -1 , cnt = 0;\n\t\t\t\t\t\tfor(int k = 0 ; k < h ; k++){\n\t\t\t\t\t\t\tfor(int l = 0 ; l < w ; l++){\n\t\t\t\t\t\t\t\tif(d[i+k][j+l] != 0){\n\t\t\t\t\t\t\t\t\tc = d[i+k][j+l];\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt == 1 && sz[c] == w*h){\n\t\t\t\t\t\t\tsx[c].push_back(j);\n\t\t\t\t\t\t\tsy[c].push_back(i);\n\t\t\t\t\t\t\tex[c].push_back(j+w);\n\t\t\t\t\t\t\tey[c].push_back(i+h);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans_cnt = 0;\n\t\tfor(int i = 0 ; i < 10 ; i++)\n\t\t\tfor(int j = 0 ; j < 10 ; j++) used[i][j] = 0;\n\t\tf(1);\n\t\tif(ans_cnt == 1){\n\t\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\t\tcout << from[ans[i][j]] << (j==W-1?\"\\n\":\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-8;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nint w, h, n;\npint info[16];\nint land[10][10], ans_land[10][10];\npint sign_pos[16];\n\nbool can_put(int left, int top, int width, int height, int b)\n{\n\tint right = left + width - 1;\n\tint bottom = top + height - 1;\n\tif (left < 0 || top < 0 || right >= w || bottom >= h)\n\t\treturn false;\n\n\tfor (int y = top; y <= bottom; ++y)\n\t\tfor (int x = left; x <= right; ++x)\n\t\t\tif (land[y][x] != 0 && land[y][x] != b)\n\t\t\t\treturn false;\n\treturn true;\n}\nvoid put(int left, int top, int width, int height, int b)\n{\n\tint right = left + width - 1;\n\tint bottom = top + height - 1;\n\n\tfor (int y = top; y <= bottom; ++y)\n\t\tfor (int x = left; x <= right; ++x)\n\t\t\tland[y][x] = b;\n}\nbool ok()\n{\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tif (land[y][x] == 0)\n\t\t\t\treturn false;\n\treturn true;\n}\nint dfs(int depth)\n{\n\tif (depth == n)\n\t{\n\t\tif (ok())\n\t\t{\n\t\t\tmemcpy(ans_land, land, sizeof(ans_land));\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tint res = 0;\n\n\tint b = info[depth].first;\n\tint k = info[depth].second;\n\tint sx = sign_pos[b].first;\n\tint sy = sign_pos[b].second;\n\tfor (int height = 1; height <= k; ++height)\n\t{\n\t\tif (k % height)\n\t\t\tcontinue;\n\t\tint width = k / height;\n\t\tfor (int y = sy - height-1; y <= sy; ++y)\n\t\t{\n\t\t\tfor (int x = sx - width-1; x <= sx; ++x)\n\t\t\t{\n\t\t\t\tif (can_put(x, y, width, height, b))\n\t\t\t\t{\n\t\t\t\t\tput(x, y, width, height, b);\n\t\t\t\t\tres += dfs(depth + 1);\n\t\t\t\t\tput(x, y, width, height, 0);\n\t\t\t\t\tland[sy][sx] = b;\n\n\t\t\t\t\tif (res > 1)\n\t\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\nint main()\n{\n\twhile (scanf(\"%d%d%d\", &w, &h, &n), w|h|n)\n\t{\n\t\tmemset(info, 0, sizeof(info));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint b, k;\n\t\t\tscanf(\"%d%d\", &b, &k);\n\t\t\tinfo[i] = pint(b, k);\n\t\t}\n\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tscanf(\"%d\", &land[y][x]);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tif (land[y][x])\n\t\t\t\t\tsign_pos[land[y][x]] = pint(x, y);\n\n\t\tif (dfs(0) == 1)\n\t\t{\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w-1; ++x)\n\t\t\t\t\tprintf(\"%d \", ans_land[y][x]);\n\t\t\t\tprintf(\"%d\\n\", ans_land[y][w-1]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<functional>\nusing namespace std;\n\nstruct Area{\n    int si, ti, sj, tj;\n};\n\nint main(){\n    int w, h, n;\n    while(cin >> w >> h >> n, w){\n        int cnt[n+1];\n        for(int i = 1; i <= n; i++){\n            int a, b;\n            cin >> a >> b;\n            cnt[a] = b;\n        }\n        string s[h][w];\n        for(int i = 0; i < h*w; i++)    cin >> s[i/w][i%w];\n        vector<Area> ok[n+1];\n        for(int si = 0; si < h; si++){\n            for(int sj = 0; sj < w; sj++){\n                for(int ti = si; ti < h; ti++){\n                    for(int tj = sj; tj < w; tj++){\n                        string tmp = \"\";\n                        bool valid = true;\n                        for(int i = si; i <= ti; i++){\n                            for(int j = sj; j <= tj; j++){\n                                if(s[i][j] == \"0\")  continue;\n                                if(tmp != \"\" && tmp != s[i][j]){\n                                    valid = false;\n                                    break;\n                                }\n                                tmp = s[i][j];\n                            }\n                            if(!valid)  break;\n                        }\n                        if(tmp != \"\" && valid && (ti-si+1)*(tj-sj+1)==cnt[stoi(tmp)]){\n                            ok[stoi(tmp)].push_back(Area({si,ti,sj,tj}));\n                        }\n                    }\n                }\n            }\n        }\n        vector<vector<int>> ans(h, vector<int>(w, 0)), pool(h, vector<int>(w, 0));\n        bool na = false;\n        function<void(int)> dfs = [&](int ind)->void{\n            if(ind == n+1){\n                if(pool[0][0] != 0){\n                    na = true;\n                    return;\n                }\n                pool = ans;\n                return;\n            }\n            for(Area a : ok[ind]){\n                bool valid = true;\n                for(int i = a.si; i <= a.ti; i++){\n                    for(int j = a.sj; j <= a.tj; j++){\n                        valid &= ans[i][j] == 0;\n                    }\n                }\n                if(!valid)  continue;\n                for(int i = a.si; i <= a.ti; i++){\n                    for(int j = a.sj; j <= a.tj; j++){\n                        ans[i][j] = ind;\n                    }\n                }\n                dfs(ind+1);\n                for(int i = a.si; i <= a.ti; i++){\n                    for(int j = a.sj; j <= a.tj; j++){\n                        ans[i][j] = 0;\n                    }\n                }\n            }\n        };\n        dfs(1);\n        if(na || pool[0][0] == 0){\n            cout << \"NA\" << endl;\n        }else{\n            for(int i = 0; i < h; i++){\n                for(int j = 0; j < w; j++){\n                    cout << pool[i][j] << \" \\n\"[j==w-1];\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\nvector< vector<int> > draw; int drawTimes;\nvoid drawInit(int W, int H) {\n\t++W, ++H;\n\n\tdrawTimes = 0;\n\tdraw.resize(H);\n\tfor (int i = 0; i < H; ++i) draw[i].resize(W);\n\n\tfor (int y = 0; y < H; ++y)\n\t\tfor (int x = 0; x < W; ++x)\n\t\t\tdraw[y][x] = 0;\n}\nvoid drawSet(P p1, P p2) {\n\t++drawTimes;\n\n\tdraw[p1.imag()][p1.real()] += 1;\n\tdraw[p1.imag()][p2.real()] += -1;\n\tdraw[p2.imag()][p1.real()] += -1;\n\tdraw[p2.imag()][p2.real()] += 1;\n}\nvoid drawDo() {\n\tfor (int y = 0; y < draw.size(); ++y)\n\t\tfor (int x = 0; x < draw[0].size()-1; ++x)\n\t\t\tdraw[y][x+1] += draw[y][x];\n\n\tfor (int x = 0; x < draw[0].size(); ++x)\n\t\tfor (int y = 0; y < draw.size()-1; ++y)\n\t\t\tdraw[y+1][x] += draw[y][x];\n}\n\nint main() {\n\tint W, H, n;\n\twhile (cin >> W >> H >> n, W || H || n) {\n\t\tvector<int> block(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint b, k; cin >> b >> k;\n\t\t\tblock[b-1] = k;\n\t\t}\n\n\t\tvector< vector<int> > df(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 1; j*j <= block[i]; ++j) {\n\t\t\t\tif (block[i] % j == 0)\n\t\t\t\t\tdf[i].push_back( j );\n\t\t\t\t\tdf[i].push_back( block[i] / j );\n\t\t\t}\n\t\t}\n\n\t\tvector< vector<int> > m(H, vector<int>(W));\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tvector< pair<P, P> > pos(n);\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tif (m[y][x])\n\t\t\t\t\tpos[m[y][x]-1] = pair<P, P>( P(x, y), P(x, y) );\n\n\t\tint count = W * H - n;\n\t\tfor (int t = 0; t < W*H; ++t) {\n\t\t\tvector< vector<int> > state(H, vector<int>(W, 0));\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tdrawInit(W, H);\n\t\t\t\tfor (int j = 0; j < df[i].size(); ++j) {\n\t\t\t\t\tint w = df[i][j], h = block[i] / df[i][j];\n\n\t\t\t\t\tif (w <= W && h <= H) {\n\t\t\t\t\t\tP p1 = pos[i].first, p2 = pos[i].second;\n\t\t\t\t\t\tint x1 = p1.real(), y1 = p1.imag();\n\t\t\t\t\t\tint x2 = p2.real(), y2 = p2.imag();\n\t\t\t\t\t\tint posW = x2 - x1 + 1, posH = y2 - y1 + 1;\n\n\t\t\t\t\t\tif (w >= posW && h >= posH) {\n\t\t\t\t\t\t\tw -= posW, h -= posH;\n\t\t\t\t\t\t\tx1 = max(x1-w, 0),   y1 = max(y1-h, 0);\n\t\t\t\t\t\t\tx2 = min(x2+w+1, W), y2 = min(y2+h+1, H);\n\t\t\t\t\t\t\tdrawSet( P(x1, y1), P(x2, y2) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdrawDo();\n/*\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << draw[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}cout << endl;\n*/\n\t\t\t\tfor (int y = 0; y < H; ++y)\n\t\t\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\t\t\tif (draw[y][x])\n\t\t\t\t\t\t\tstate[y][x] |= 1 << i;\n\t\t\t}\n\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (!m[y][x] && state[y][x] && state[y][x] == (state[y][x] & -state[y][x])) {\n\t\t\t\t\t\tint b = 0;\n\t\t\t\t\t\tfor (int k = 1; k != state[y][x]; k *= 2, ++b);\n\n\t\t\t\t\t\tP p1 = pos[b].first, p2 = pos[b].second;\n\t\t\t\t\t\tint minX = p1.real(), minY = p1.imag();\n\t\t\t\t\t\tint maxX = p2.real(), maxY = p2.imag();\n\n\t\t\t\t\t\tminX = min(minX, x), minY = min(minY, y);\n\t\t\t\t\t\tmaxX = max(maxX, x), maxY = max(maxY, y);\n\n\t\t\t\t\t\tpos[b] = pair<P, P>( P(minX, minY), P(maxX, maxY) );\n\n\t\t\t\t\t\tfor (int Y = minY; Y <= maxY; ++Y) {\n\t\t\t\t\t\t\tfor (int X = minX; X <= maxX; ++X) {\n\t\t\t\t\t\t\t\tif (!m[Y][X]) {\n\t\t\t\t\t\t\t\t\t--count;\n\t\t\t\t\t\t\t\t\tm[Y][X] = b+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tif (m[y][x] == 0) flag = false;\n\n\t\tif (!flag) cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << m[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\nbool use[16];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j] && !use[ok[y][x][i][j]]) {\n\t\t\t\tuse[ok[y][x][i][j]] = true;\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t\tuse[ok[y][x][i][j]] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tout.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n\t\tfor(int i = 0; i < 16; i++)\n\t\t\tuse[i] = false;\n\t\tfor(int i = 0; i < v.size(); i++) v[i] = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = 0; y < Y && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = 0; x < X && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt != 1) ok[i][j][k][l] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < v.size(); i++) sum += v[i];\n\t\tbool flg = true;\n\t\tfor(int i = 0; i < out.size(); i++)\n\t\t\tfor(int j = 0; j < out[i].size(); j++)\n\t\t\t\tflg &= out[i][j] != 0;\n\t\tif(res == 1 && sum == X*Y && flg) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  int debug = 0;\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); debug++; }\n        if( debug >= 1000000 ) while(1);\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n  if( cy >= H ) while(1);\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nconst int MAX_NUM = 11;\nint w, h, n;\nint T[SIZE][SIZE];\nint TC[SIZE][SIZE];\nint K[MAX_NUM]; \nII U[MAX_NUM]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[SIZE][SIZE];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nvoid output1() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\tvpii;\n\nvector<vpii> rect;\nint w,h,n,land[10][10],test[10][10],ans[10][10];\n\nbool search(int i0,int j0){\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\n\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++)for(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\tbool canput=true;\n\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\n\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++)\ttest[yy][xx]=id;\n\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++)\ttest[yy][xx]=0;\n\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn cnt==1;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tans[i][j]=test[i][j];\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++)\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\nint R, C, N;\nint size[20];\nint table[12][12];\n\nint ans[12][12];\nint ans_num;\n\nvoid dfs(int depth) {\n//       REP(r, R) {\n//         cout << table[r][0];\n//         for(int c = 1; c < C; c++) cout << ' ' << table[r][c];\n//         cout << endl;\n//       }\n//       cout << endl;\n  \n  if( depth > N ) {\n    bool same = true;\n    REP(r, R) REP(c, C) if( ans[r][c] != table[r][c] ) same = false;\n    if( !same ) {\n      ans_num++;\n      REP(r, R) REP(c, C) ans[r][c] = table[r][c];\n    }\n    return;\n  }\n  if( ans_num >= 2 ) return;\n  int r, c;\n  REP(i, R) REP(j, C) if( table[i][j] == depth ) {\n    r = i;\n    c = j;\n  }\n  \n  table[r][c] = 0;\n  for(int r1 = 0; r1 <= r; r1++)\n    for(int r2 = r; r2 < R; r2++)\n      if( size[depth] % (r2 - r1 + 1) == 0 )\n        for(int c1 = 0; c1 <= c; c1++)\n          for(int c2 = c; c2 < C; c2++)\n            if( (r2 - r1 + 1) * (c2 - c1 + 1) == size[depth] ) {\n              \n              \n              bool go = true;\n              for(int i = r1; i <= r2; i++)\n                for(int j = c1; j <= c2; j++)\n                  if( table[i][j] != 0 )\n                    go = false;\n              \n              if( go ) {\n                for(int i = r1; i <= r2; i++)\n                  for(int j = c1; j <= c2; j++)\n                    table[i][j] = depth;\n                \n                dfs(depth + 1);\n                \n                for(int i = r1; i <= r2; i++)\n                  for(int j = c1; j <= c2; j++)\n                    table[i][j] = 0;\n              }\n            }\n  table[r][c] = depth;\n}\n\nint main() {\n  for(;;) {\n    cin >> C >> R >> N;\n    if( C == 0 && R == 0 && N == 0 ) break;\n    REP(i, N) {\n      int x, c; cin >> x >> c;\n      size[x] = c;\n    }\n    REP(r, R) REP(c, C) {\n      int v; cin >> v; table[r][c] = v;\n    }\n\n    REP(i, R) REP(j, C) ans[i][j] = -1;\n    ans_num = 0;\n    dfs(1);\n    if( ans_num == 1 ) {\n      REP(r, R) {\n        cout << ans[r][0];\n        for(int c = 1; c < C; c++) cout << ' ' << ans[r][c];\n        cout << endl;\n      }\n    }else\n      cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint w, h;\nvector<int> area;\nvector<vector<int> > sum;\n\nint retNum;\nvector<string> ret;\n\nvoid solve(int y, int x, vector<string>& used)\n{\n    if(x > w){\n        ++ y;\n        x = 1;\n    }\n    if(y > h){\n        ++ retNum;\n        ret = used;\n        return;\n    }\n\n    if(used[y][x] != '0'){\n        solve(y, x+1, used);\n        return;\n    }\n\n    int w1 = w;\n    for(int y1=y; y1<=h; ++y1){\n        for(int x1=x; x1<=w1; ++x1){\n            if(used[y1][x1] != '0'){\n                w = x1 - 1;\n                break;\n            }\n\n            bitset<16> bs = sum[y1][x1] & (~sum[y1][x-1]) & (~sum[y-1][x1]);\n            if(bs.count() != 1)\n                continue;\n\n            int k = 0;\n            while(!bs[k])\n                ++ k;\n            if(area[k] != (y1 - y + 1) * (x1 - x + 1))\n                continue;\n\n            vector<string> used1 = used;\n            for(int i=y; i<=y1; ++i){\n                for(int j=x; j<=x1; ++j){\n                    used1[i][j] = k + '0';\n                }\n            }\n            solve(y, x+1, used1);\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n\n        area.assign(n+1, 0);\n        for(int i=0; i<n; ++i){\n            int b, k;\n            cin >> b >> k;\n            area[b] = k;\n        }\n\n        sum.assign(h+1, vector<int>(w+1, 0));\n        for(int y=1; y<=h; ++y){\n            int tmp = 0;\n            for(int x=1; x<=w; ++x){\n                int a;\n                cin >> a;\n                if(a > 0)\n                    tmp |= (1 << a);\n                sum[y][x] = sum[y-1][x] | tmp;\n            }\n        }\n\n        retNum = 0;\n        vector<string> s(h+1, string(w+1, '0'));\n        solve(1, 1, s);\n\n        if(retNum != 1){\n            cout << \"NA\" << endl;\n        }else{\n            for(int i=1; i<=h; ++i){\n                cout << ret[i][1];\n                for(int j=2; j<=w; ++j)\n                    cout << ' ' << ret[i][j];\n                cout << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing vec = std::vector<int>;\nusing Land = std::vector<std::vector<int>>;\n\nint W, H, N;\nLand s;\nstd::vector<Land> res;\n\nbool check(int h, int w, int a, int b, int num)\n{\n    if (h + a > H || w + b > W) {\n        return false;\n    }\n    for (int i = h; i < h + a; i++) {\n        for (int j = w; j < w + b; j++) {\n            if (s[i][j] != 0 && s[i][j] != num) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid paint(int h, int w, int a, int b, int num)\n{\n    for (int i = h; i < h + a; i++) {\n        for (int j = w; j < w + b; j++) {\n            s[i][j] = num;\n        }\n    }\n}\n\nvoid dfs(int idx, const vec &b, const vec &k)\n{\n    if (idx == N) {\n        res.emplace_back(s);\n        return;\n    }\n\n    for (int i = 1; i <= k[idx]; i++) {\n        int j = k[idx] / i;\n        if (i * j != k[idx]) continue;\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {                \n                if (check(h, w, i, j, b[idx])) {\n                    auto tmp = s;\n                    paint(h, w, i, j, b[idx]);\n                    dfs(idx + 1, b, k);\n                    s = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid print(Land &l)\n{\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (j > 0) std::cout << \" \";            \n            std::cout << l[i][j];\n        }\n        std::cout << std::endl;\n    }\n}\n\nvoid init()\n{\n    s.assign(H, std::vector<int>(W));\n    res.clear();\n}\n\nint main()\n{\n    while (std::cin >> W >> H >> N, W) {\n        init();\n        vec b(N), k(N);\n        for (int i = 0; i < N; i++) {\n            std::cin >> b[i] >> k[i];\n        }\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                std::cin >> s[i][j];\n            }\n        }\n\n        dfs(0, b, k);\n\n        if (res.size() != 1) {\n            std::cout << \"NA\" << std::endl;\n        } else {\n            print(res[0]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nconst int MAX_NUM = 16;\nint w, h, n;\nint T[SIZE][SIZE];\nint TC[SIZE][SIZE];\nint K[MAX_NUM]; \nII U[MAX_NUM]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[SIZE][SIZE];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nint T[11][11];\nint TC[11][11];\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[k] % w0 != 0 ) continue;\n        int h0 = K[k] / w0;\n        for ( int r0 = 0; r0 < h; ++ r0 ) {\n            for ( int c0 = 0; c0 < w; ++ c0 ) {\n                if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                    if ( canPut( r0, c0, w0, h0 ) ) {\n                        for ( int i = 0; i < h0; ++ i ) {\n                            for ( int j = 0; j < w0; ++ j ) {\n                                Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                            }\n                        }\n                        put( k, r0, c0, w0, h0 );\n                        solve( k + 1 );\n                        for ( int i = 0; i < h0; ++ i ) {\n                            for ( int j = 0; j < w0; ++ j ) {\n                                T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                            }\n                        }\n                    }\n                    if ( cnt >= 2 ) return;\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint n,w,h;\nint a[15],b[15],c[15],f[10][10];\nint fn(int d[][10],int p){\n  int i,j,k,l,m;\n  int ct=0;\n  if(p==n){\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(d[j][i]==0)\n\t  break;\n      }\n      if(j!=w)\n\tbreak;\n    }\n    if(i==h){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++)\n\t  f[j][i]=d[j][i];\n      }\n      ct=1;\n    }\n  }else{\n    for(i=1;i<a[p]+1;i++){\n      if(a[p]%i==0){\n\tfor(j=0;j<i;j++){\n\t  if(b[p]-j>-1&&b[p]+i-j-1<w){\n\t    for(k=0;k<a[p]/i;k++){\n\t      if(c[p]-k>-1&&c[p]+a[p]/i-k-1<h){\n\t\tfor(l=0;l<i;l++){\n\t\t  for(m=0;m<a[p]/i;m++){\n\t\t    if(d[b[p]-j+l][c[p]-k+m])\n\t\t      break;\n\t\t  }\n\t\t  if(m!=a[p]/i)\n\t\t    break;\n\t\t}\n\t\tif(l==i){\n\t\t  int e[10][10];\n\t\t  memcpy(e,d,sizeof(e));\n\t\t  for(l=0;l<i;l++)\n\t\t    for(m=0;m<a[p]/i;m++)\n\t\t      e[b[p]-j+l][c[p]-k+m]=p+1;\n\t\t  ct+=fn(e,p+1);\n\t\t  if(ct>1)\n\t\t    return ct;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return ct;\n}\nint main(){\n  int i,j;\n  while(cin>>w>>h>>n&&w+h+n){\n    for(i=0;i<n;i++){\n      int p,q;\n      cin>>p>>q;\n      p--;\n      a[p]=q;\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tint p;\n\tcin>>p;\n\tif(p){\n\t  p--;\n\t  b[p]=j;\n\t  c[p]=i;\n\t}\n      }\n    }\n    int d[10][10];\n    memset(d,0,sizeof(d));\n    if(fn(d,0)==1){\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++)\n\t  cout<<f[j][i];\n\tcout<<endl;\n      }\n    }else\n      cout<<\"NA\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Subdivide The Land\n//Level: 3\n//Category: 探索\n//Note:\n\n/**\n * パズル「四角に切れ」と同じ問題設定なので、おそらくNP完全である。\n * したがって、効率のよい探索を考える。\n *\n * 全てのマスがどれかの長方形に属していることより、盤面を左上から走査していき、どの番号の長方形に属すかを探索していけばよい。\n * こうすることで、そのマスを左上とした長方形に決め打つことができる。\n * 各番号では、その面積を与える長方形を全て試す。\n */\n#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<15> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    //Rect() : r(0), c(0), h(0), w(0) {}\n    Rect() {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else {\n        bool conquered = false;\n        for(int i = 0; i < N; ++i) {\n            //if(!state[i]) continue;\n            if(cur[i].intersect(Rect(r, c, 1, 1))) {\n                conquered = true;\n                break;\n            }\n        }\n        if(conquered) {\n            dfs(r, c+1, state, cur);\n            return;\n        }\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nbool canput(const vvi& grid,int x,int y,int bw,int bh,int index)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(x<0 || w<x+bw || y<0 || h<y+bh)\n\t\treturn false;\n\tbool flg=false;\n\trep(i,bh) rep(j,bw){\n\t\tint cell=grid[y+i][x+j];\n\t\tif(cell!=-1 && cell!=index)\n\t\t\treturn false;\n\t\tflg|=cell==index;\n\t}\n\treturn flg;\n}\n\nvoid put(vvi& grid,int x,int y,int bw,int bh,int index)\n{\n\trep(i,bh) rep(j,bw)\n\t\tgrid[y+i][x+j]=index;\n}\n\nvvi res;\nint solve(vvi& grid,const vi& bs,const vi& ks,const vector<pii>& ps,int index)\n{\n\tif(index==bs.size()){\n\t\tif(res.empty())\n\t\t\tres=grid;\n\t\treturn 1;\n\t}\n\t\n\tint x=ps[index].first,y=ps[index].second;\n\tint area=ks[index];\n\tint res=0;\n\trepi(bh,1,area+1) if(area%bh==0){\n\t\tint bw=area/bh;\n\t\trep(i,bh) rep(j,bw){\n\t\t\tint left=x-j,top=y-i;\n\t\t\tif(canput(grid,left,top,bw,bh,index)){\n\t\t\t\tput(grid,left,top,bw,bh,index);\n\t\t\t\tres+=solve(grid,bs,ks,ps,index+1);\n\t\t\t\tput(grid,left,top,bw,bh,-1);\n\t\t\t\tgrid[y][x]=index;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,h,n;scanf(\"%d%d%d\",&w,&h,&n),w|h|n;){\n\t\tvi bs(n),ks(n);\n\t\trep(i,n) scanf(\"%d%d\",&bs[i],&ks[i]);\n\t\t\n\t\tvvi grid(h,vi(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tif(accumulate(all(ks),0)!=w*h){\n\t\t\tputs(\"NA\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<pii> ps(n);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]==0)\n\t\t\t\tgrid[i][j]=-1;\n\t\t\telse{\n\t\t\t\tgrid[i][j]=find(all(bs),grid[i][j])-bs.begin();\n\t\t\t\tps[grid[i][j]]=mp(j,i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tres.clear();\n\t\tint cnt=solve(grid,bs,ks,ps,0);\n\t\tif(cnt!=1)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\trep(i,h) rep(j,w)\n\t\t\t\tprintf(\"%d%c\",bs[res[i][j]],j==w-1?'\\n':' ');\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n  /*\n  cout << cx << \",\" << cy << endl;\n  rep(i,H) {\n    rep(j,W) cout << ans[i][j] << \" \";\n    cout << endl;\n  }\n    cout << endl;\n    cout << endl;\n  */\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { \n      rep(j,W) {\n        if( j ) cout << \" \";\n        cout << buf[i][j]; \n      } \n      cout << endl; \n    }\n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    rep(i,H) rep(j,W) cin >> s[i][j];\n    if( sum != H*W ) { puts(\"NA\"); continue; }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\nvector<vector<pii> > v;\nint tab[16][16];\nint m[16][16];\nint ans[16][16];\nint x, y, N;\n\nint search(int n) {\n\tif(n > N) {\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tans[i][j] = tab[i][j];\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\tint res = 0;\n\tint sx = -1, sy = -1;\n\tfor(int i = 0; i < y; i++) {\n\t\tfor(int j = 0; j < x; j++) {\n\t\t\tif(m[i][j] == n) {\n\t\t\t\t//*\n\t\t\t\tif(sx != -1 || sy != -1)\n\t\t\t\t\tabort();\n\t\t\t\t// */\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < v[n-1].size(); i++) {\n\t\tint wi, hi;\n\t\twi = v[n-1][i].first;\n\t\thi = v[n-1][i].second;\n\t\tfor(int by = 0; by < hi; by++) {\n\t\t\tfor(int bx = 0; bx < wi; bx++) {\n\t\t\t\tif(sy-by >= 0 && sx-bx >= 0 && sy-by + hi <= y && sx-bx + wi <= x) {\n\t\t\t\t\t/*\n\t\t\t\t\tcout << \"hoge:\" << n << endl;\n\t\t\t\t\tcout << \"i:\" << i << endl;\n\t\t\t\t\tcout << sy-by << \",\" << sx-bx << endl;\n\t\t\t\t\t// */\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\tif(tab[j][k] != 0 || (m[j][k] != 0 && m[j][k] != n)) {\n\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t//cout << sy << \",\" << sx << endl;\n\t\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\t\ttab[j][k] = n;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint tmp;\n\t\t\t\t\t\ttmp = search(n+1);\n\t\t\t\t\t\tres += tmp;\n\t\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\t\ttab[j][k] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << n << endl;\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> x >> y >> N, x || y || N) {\n\t\tv.clear();\n\t\tv.resize(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(k % j == 0 && j <= y && k / j <= x) {\n\t\t\t\t\tv[b-1].push_back(pii(j,k/j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\t\tcout << v[i][j].first << \",\" << v[i][j].second << endl;\n\t\t\t} cout << endl;\n\t\t} cout << endl;\n\t\t// */\n\n\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tfor(int j = 0; j < 16; j++) {\n\t\t\t\ttab[i][j] = 0;\n\t\t\t\tm[i][j] = 0;\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tcin >> m[i][j];\n\t\t\t}\n\t\t}\n\n\t\tif(search(1) != 1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tcout << ans[i][0];\n\t\t\t\tfor(int j = 1; j < x; j++) {\n\t\t\t\t\tcout << \" \" << ans[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint W, H, N; \nint b[16], k[16];\nint s[10][10];\nint ans[10][10];\nint used[10][10];\nint TX[20], TY[20];\nclass DFSError {};\nvoid dfs(int idx){\n  if(idx == N) {\n    if(ans[0][0] != -1) throw DFSError();\n    REP(y, H)REP(x, W) ans[y][x] = used[y][x];\n    return;\n  }\n  /*\n  printf(\"idx = %d\\n\", idx);\n  REP(y, H){\n    REP(x, W){\n      cout << used[y][x];\n      if(x != W - 1) cout << \" \";\n      else cout << endl;\n    }\n  }\n  */\n  int tx = TX[b[idx] - 1];\n  int ty = TY[b[idx] - 1];\n  //printf(\"idx = %d tx = %d ty = %d\\n\", idx, tx, ty);\n  \n  assert(idx < N);\n  assert(b[idx] >= 1 && b[idx] <= N);\n  assert(tx != -1);\n  for(int h = 1; h <= k[idx]; h++) if(k[idx] % h == 0){\n    int w = k[idx] / h;\n    for(int by = 0; by > -h; by--) for(int bx = 0; bx > -w; bx--){\n      int sx = tx + bx;\n      int sy = ty + by;\n      bool ok = true;\n      for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n        if(!valid(sx + x, sy + y, W, H) || used[sy + y][sx + x] != -1) ok = false;\n      }\n      if(ok){\n        int tmp[10][10];\n        memcpy(tmp, used, sizeof(used));\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n          used[sy + y][sx + x] = b[idx];\n        }\n        dfs(idx + 1);\n        memcpy(used, tmp, sizeof(used));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H >> N && (W | H | N)){\n    REP(i, N) cin >> b[i] >> k[i];\n    REP(y, H)REP(x, W) cin >> s[y][x];\n    try{\n      memset(used, -1, sizeof(used));\n      memset(ans, -1, sizeof(ans));\n      memset(TX, -1, sizeof(TX));\n      memset(TY, -1, sizeof(TY));\n      REP(y, H) REP(x, W) if(s[y][x] > 0) TX[s[y][x] - 1] = x, TY[s[y][x] - 1] = y;\n      REP(i, N)if(TX[i] == -1){\n        cerr << W << \" \" << H << \" \" << N << endl;\n        REP(j, N) cerr << b[j] << \" \" << k[j] << endl;\n        REP(y, H) { REP(x, W) cerr << s[y][x] << \" \"; cerr << endl; }\n        assert(\"bord is dissapeared\" == \"\");\n      }\n      dfs(0);\n      if(ans[0][0] == -1) throw DFSError();\n      REP(y, H){\n        REP(x, W){\n          cout << ans[y][x];\n          if(x != W - 1) cout << \" \";\n          else cout << endl;\n        }\n      }\n    }catch(...){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Area;\n\nclass Solver {\n  public:\n    Area solve() {\n      Area area(x, Vec(y, 0));\n      vector<Area> answers;\n      for (int i = 0; i < y; ++i) {\n        for (int j = 0; j < x; ++j) {\n          area[j][i] = s[j][i];\n        }\n      }\n      search(area, answers);\n      if (answers.size() != 1) {\n        answers.resize(1);\n        answers[0].clear();\n      }\n      return answers[0];\n    }\n    int x, y, n;\n    int b[15], k[15];\n    int s[10][10];\n  private:\n    void print_area(Area &area) {\n      for (int i = 0; i < y; ++i) {\n        for (int j = 0; j < x; ++j) {\n          cerr << area[j][i] << \" \";\n        }\n        cerr << endl;\n      }\n      cerr << \"--------------------------------\" << endl;\n    }\n    void search(Area &area, vector<Area> &answers, int id = 0) {\n      //print_area(area);\n      if (id == n) {\n        answers.push_back(area);\n        return;\n      }\n      for (int yi = 0; yi < y; ++yi) {\n        for (int dy = 1; yi + dy <= y; ++dy) {\n          int dx = k[id] / dy;\n          if (k[id] % dy != 0) {\n            continue;\n          }\n          for (int xi = 0; xi + dx <= x; ++xi) {\n            bool is_valid = true;\n            for (int i = yi; i < yi + dy and is_valid; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                if (area[j][i] != 0 and area[j][i] != b[id]) {\n                  is_valid = false;\n                  break;\n                }\n              }\n            }\n            if (not is_valid) {\n              continue;\n            }\n            for (int i = yi; i < yi + dy; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                area[j][i] = b[id];\n              }\n            }\n            search(area, answers, id + 1);\n            if (answers.size() > 1) {\n              return;\n            }\n            for (int i = yi; i < yi + dy; ++i) {\n              for (int j = xi; j < xi + dx; ++j) {\n                area[j][i] = s[j][i];\n              }\n            }\n          }\n        }\n      }\n    }\n};\n\nint main() {\n  Solver s;\n  Area answer;\n  while (true) {\n    cin >> s.x >> s.y >> s.n;\n    for (int i = 0; i < s.n; ++i) {\n      cin >> s.b[i] >> s.k[i];\n    }\n    for (int i = 0; i < s.y; ++i) {\n      for (int j = 0; j < s.x; ++j) {\n        cin >> s.s[j][i];\n      }\n    }\n    answer = s.solve();\n    if (answer.size() == 0) {\n      cout << \"NA\" << endl;\n    } else {\n      for (int i = 0; i < s.y; ++i) {\n        for (int j = 0; j < s.x; ++j) {\n          cout << answer[j][i];\n          if (j < s.x - 1) {\n            cout << \" \";\n          } else {\n            cout << endl;\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint X, Y, n;\n\nstruct Memo\n{\n\tint b;\n\tint k;\n};\n\nstruct Point\n{\n\tint x;\n\tint y;\n};\n\nstruct Node\n{\n\tint idx;\n\tint a[10][10];\n};\n\nclass memo_greater\n{\npublic:\n\tbool operator() (const Memo m1, const Memo m2)\n\t{\n\t\treturn m1.k > m2.k;\n\t}\n};\n\nPoint P[15];\nMemo M[15];\nint A[10][10];\n\nbool is_able(int a[10][10], int x, int y, int w, int h, int idx)\n{\n\tfor(int j=y; j<y+h; j++)\n\t{\n\t\tfor(int i=x; i<x+w; i++)\n\t\t{\n\t\t\tif(i<0 || j<0 || i>=X || j>=Y) return false;\n\t\t\tif(a[j][i]!=0 && a[j][i]!=idx) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid set(int a[10][10], int x, int y, int w, int h, int idx)\n{\n\tfor(int j=y; j<y+h; j++)\n\t{\n\t\tfor(int i=x; i<x+w; i++)\n\t\t{\n\t\t\ta[j][i] = idx;\n\t\t}\n\t}\n}\n\nbool is_ans()\n{\n\tfor(int y=0; y<Y; y++)\n\t{\n\t\tfor(int x=0; x<X; x++)\n\t\t{\n\t\t\tif(A[y][x]==0)\n\t\t\t{\n\t\t\t\treturn false;\t\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool solve()\n{\n\tqueue<Node> que;\n\tint b, k, i, j, mem_size;\n\tPoint p;\n\n\tbool is_ok;\n\tmem_size = sizeof(int) * 100;\n\tsort(&M[0], &M[n-1], memo_greater());\n\tNode nn;\n\tnn.idx = 0;\n\tmemcpy(nn.a, A, mem_size);\n\n\tque.push(nn);\n\n\tis_ok = false;\n\twhile(!que.empty())\n\t{\n\t\tnn = que.front();\n\t\tque.pop();\n\n\t\tif(nn.idx==n)\n\t\t{\n\t\t\tif(!is_ok)\n\t\t\t{\n\t\t\t\tmemcpy(A, nn.a, mem_size);\n\t\t\t\tis_ok = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tb = M[nn.idx].b;\n\t\tk = M[nn.idx].k;\n\t\tp = P[b-1];\n\n\t\tfor(i=1; i<=k; i++)\n\t\t{\n\t\t\tif(k%i!=0) continue;\n\n\t\t\tj = k / i;\n\t\t\tfor(int dy=0; dy<j; dy++)\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<i; dx++)\n\t\t\t\t{\n\t\t\t\t\tif(is_able(nn.a, p.x-dx, p.y-dy, i, j, b))\n\t\t\t\t\t{\n\t\t\t\t\t\tNode node;\n\t\t\t\t\t\tmemcpy(node.a, nn.a, mem_size);\n\t\t\t\t\t\tset(node.a, p.x-dx, p.y-dy, i, j, b);\n\t\t\t\t\t\tnode.idx = nn.idx+1;\n\t\t\t\t\t\tque.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(int argc, char** argv)\n{\n\twhile( 1 )\n\t{\n\t\tcin >> X >> Y >> n;\n\t\tif(!(X || Y || n)) break;\n\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> M[i].b >> M[i].k;\n\t\t}\n\n\t\tfor(int y=0; y<Y; y++)\n\t\t{\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t{\n\t\t\t\tcin >> A[y][x];\n\t\t\t\tif(A[y][x] != 0)\n\t\t\t\t{\n\t\t\t\t\tP[A[y][x]-1].x = x;\n\t\t\t\t\tP[A[y][x]-1].y = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(solve())\n\t\t{\t\n\t\t\tfor(int y=0; y<Y; y++)\n\t\t\t{\n\t\t\t\tfor(int x=0; x<X; x++)\n\t\t\t\t{\n\t\t\t\t\tcout << A[y][x];\n\t\t\t\t\tif(x!=X-1) cout << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 0\n\nint w,h,n;\nint field[16][16];\nint check[16][16],output[16][16];\nint ans;\nstruct state{\n\tint area,x,y;\n} memo[16];\n\nbool ok(int x, int y, int zx, int zy, int num){\n\trep(i,zy){\n\t\trep(j,zx){\n\t\t\tint tx = x + j;\n\t\t\tint ty = y + i;\n\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || check[ty][tx]>0 )return false;\n\t\t\tif( field[ty][tx]!=0 && field[ty][tx]!=num )return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dfs(int cnt){\n#if DEB\n\tprintf(\"cnt:%d\\n\",cnt);\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tprintf(\"%d \",check[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\tputs(\"\");\n#endif\n\t\n\tif( cnt==n ){\n\t\tans++;\n\t\tif( ans>=2 ) return;\n\t\trep(i,h)rep(j,w)output[i][j]=check[i][j];\n\t\treturn;\n\t}\n\n\tfor(int i=1; i<=memo[cnt].area; i++){\n\t\tif( memo[cnt].area%i!=0 )continue;\n\t\tint j = memo[cnt].area / i;\n\t\tint si = memo[cnt].y - i + 1;\n\t\tint sj = memo[cnt].x - j + 1;\n\n#if DEB\n\t\tprintf(\"(i,j)=(%d,%d),  (si,sj)=(%d,%d)\\n\",i,j,si,sj);\n#endif\t\t\n\n\t\tfor(int ii=si; ii<=memo[cnt].y; ii++){\n\t\t\tif( ii<0 )continue;\n\t\t\tfor(int jj=sj; jj<=memo[cnt].x; jj++){\n\t\t\t\tif( jj<0 )continue;\n\t\t\t\tif( ok(jj, ii, j, i, cnt+1) ){\n#if DEB\n\t\t\t\t\tprintf(\"isok:: jj:%d , ii:%d, j:%d, i:%d\\n\",jj,ii,j,i);\n#endif \t\t\t\t\t\n\t\t\t\t\trep(k,i)rep(l,j)check[ii+k][jj+l]=cnt+1;\n\t\t\t\t\tdfs(cnt+1);\n\t\t\t\t\tif( ans>=2 ) return;\n\t\t\t\t\trep(k,i)rep(l,j)check[ii+k][jj+l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t\n\twhile(scanf(\"%d%d%d\",&w,&h,&n),w|h|n){\n\t\trep(i,16)rep(j,16)check[i][j]=output[i][j]=0;\n\t\tans = 0;\n\t\t\n\t\trep(i,n){\n\t\t\tint b,k; scanf(\"%d%d\",&b,&k);\n\t\t\tmemo[b-1].area = k;\n\t\t}\n\t\trep(i,h)rep(j,w)scanf(\"%d\",&field[i][j]);\n\t\trep(i,h)rep(j,w)if( field[i][j]>0 ){\n\t\t\tmemo[ field[i][j]-1 ].x = j;\n\t\t\tmemo[ field[i][j]-1 ].y = i;\n\t\t}\n\t\t\n\t\tdfs(0);\n\n\t\tif( ans==1 ){\n\t\t\trep(i,h){\n\t\t\t\trep(j,w){\n\t\t\t\t\tprintf(\"%d \",output[i][j]);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"NA\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint main() {\n\tint H, W, N;\n\twhile (cin >> W >> H >> N, N) {\n\t\tvector<int> S(N);\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint b, x;\n\t\t\tcin >> b >> x; --b;\n\t\t\tS[b] = x;\n\t\t\tsum += x;\n\t\t}\n\t\tvector<vector<int> > C(H, vector<int>(W));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> C[i][j]; --C[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > curstate(H, vector<int>(W, -1));\n\t\tvector<vector<vector<int> > > sols;\n\t\tfunction<void(int)> dfs = [&](int bit) {\n\t\t\tif (bit == 0) {\n\t\t\t\tsols.push_back(curstate);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint x = -1, y = -1;\n\t\t\tfor (int i = 0; i < H && x == -1; ++i) {\n\t\t\t\tfor (int j = 0; j < W && y == -1; ++j) {\n\t\t\t\t\tif (curstate[i][j] == -1) {\n\t\t\t\t\t\tx = i, y = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (!((bit >> i) & 1)) continue;\n\t\t\t\tfor (int j = 1; j <= S[i]; ++j) {\n\t\t\t\t\tif (S[i] % j != 0) continue;\n\t\t\t\t\tint h = j, w = S[i] / j;\n\t\t\t\t\tif (x + h > H || y + w > W) continue;\n\t\t\t\t\tbool f1 = true, f2 = false;\n\t\t\t\t\tfor (int k = 0; k < h; ++k) {\n\t\t\t\t\t\tfor (int l = 0; l < w; ++l) {\n\t\t\t\t\t\t\tif (C[x + k][y + l] == i) f2 = true;\n\t\t\t\t\t\t\telse if (C[x + k][y + l] != -1 || curstate[x + k][y + l] != -1) f1 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f1 && f2) {\n\t\t\t\t\t\tfor (int k = 0; k < h; ++k) {\n\t\t\t\t\t\t\tfor (int l = 0; l < w; ++l) {\n\t\t\t\t\t\t\t\tcurstate[x + k][y + l] = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdfs(bit - (1 << i));\n\t\t\t\t\t\tfor (int k = 0; k < h; ++k) {\n\t\t\t\t\t\t\tfor (int l = 0; l < w; ++l) {\n\t\t\t\t\t\t\t\tcurstate[x + k][y + l] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (sum == H * W) {\n\t\t\tdfs((1 << N) - 1);\n\t\t}\n\t\tif (sols.size() != 1) {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (j) cout << ' ';\n\t\t\t\t\tcout << sols[0][i][j] + 1;\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\nvector< vector<int> > draw; int drawTimes;\nvoid drawInit(int W, int H) {\n\t++W, ++H;\n\n\tdrawTimes = 0;\n\tdraw.resize(H);\n\tfor (int i = 0; i < H; ++i) draw[i].resize(W);\n\n\tfor (int y = 0; y < H; ++y)\n\t\tfor (int x = 0; x < W; ++x)\n\t\t\tdraw[y][x] = 0;\n}\nvoid drawSet(P p1, P p2) {\n\t++drawTimes;\n\n\tdraw[p1.imag()][p1.real()] += 1;\n\tdraw[p1.imag()][p2.real()] += -1;\n\tdraw[p2.imag()][p1.real()] += -1;\n\tdraw[p2.imag()][p2.real()] += 1;\n}\nvoid drawDo() {\n\tfor (int y = 0; y < draw.size(); ++y)\n\t\tfor (int x = 0; x < draw[0].size()-1; ++x)\n\t\t\tdraw[y][x+1] += draw[y][x];\n\n\tfor (int x = 0; x < draw[0].size(); ++x)\n\t\tfor (int y = 0; y < draw.size()-1; ++y)\n\t\t\tdraw[y+1][x] += draw[y][x];\n}\n\nint main() {\n\tint W, H, n;\n\twhile (cin >> W >> H >> n, W || H || n) {\n\t\tvector<int> block(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint b, k; cin >> b >> k;\n\t\t\tblock[b-1] = k;\n\t\t}\n\n\t\tvector< vector<int> > m(H, vector<int>(W));\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tvector< vector<int> > df(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 1; j*j <= block[i]; ++j) {\n\t\t\t\tif (block[i] % j == 0) {\n\t\t\t\t\tdf[i].push_back( j );\n\t\t\t\t\tif (j != block[i] / j) df[i].push_back( block[i] / j );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector< pair<P, P> > pos(n);\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tif (m[y][x])\n\t\t\t\t\tpos[m[y][x]-1] = pair<P, P>( P(x, y), P(x, y) );\n\n\t\tfor (int t = 0; t < W*H; ++t) {\n\t\t\tvector< vector<int> > state(H, vector<int>(W, 0));\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tdrawInit(W, H);\n\t\t\t\tfor (int j = 0; j < df[i].size(); ++j) {\n\t\t\t\t\tint w = df[i][j], h = block[i] / df[i][j];\n\n\t\t\t\t\tif (w <= W && h <= H) {\n\t\t\t\t\t\tP p1 = pos[i].first, p2 = pos[i].second;\n\t\t\t\t\t\tint x1 = p1.real(), y1 = p1.imag();\n\t\t\t\t\t\tint x2 = p2.real(), y2 = p2.imag();\n\t\t\t\t\t\tint posW = x2 - x1 + 1, posH = y2 - y1 + 1;\n\n\t\t\t\t\t\tif (w >= posW && h >= posH) {\n\t\t\t\t\t\t\tw -= posW, h -= posH;\n\t\t\t\t\t\t\tx1 = max(x1-w, 0),   y1 = max(y1-h, 0);\n\t\t\t\t\t\t\tx2 = min(x2+w+1, W), y2 = min(y2+h+1, H);\n\t\t\t\t\t\t\tdrawSet( P(x1, y1), P(x2, y2) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdrawDo();\n/*\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << draw[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}cout << endl;\n*/\n\t\t\t\tint cnt = 0, fx = -1, fy = -1, lx = -1, ly = -1;\n\t\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\t\tif (draw[y][x] && !m[y][x]) {\n\t\t\t\t\t\t\tif (fx == -1) fx = x, fy = y;\n\t\t\t\t\t\t\tlx = x, ly = y;\n\t\t\t\t\t\t\tstate[y][x] |= 1 << i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt == block[i]) {\n\t\t\t\t\tfor (int y = 0; y < H; ++y)\n\t\t\t\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\t\t\t\tif (draw[y][x]) state[y][x] = i+1;\n\n\t\t\t\t\tpos[i] = pair<P, P>( P(fx, fy), P(lx, ly) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (!m[y][x] && state[y][x] && state[y][x] == (state[y][x] & -state[y][x])) {\n\t\t\t\t\t\tint b = 0;\n\t\t\t\t\t\tfor (int k = 1; k != state[y][x]; k *= 2, ++b);\n\n\t\t\t\t\t\tP p1 = pos[b].first, p2 = pos[b].second;\n\t\t\t\t\t\tint minX = p1.real(), minY = p1.imag();\n\t\t\t\t\t\tint maxX = p2.real(), maxY = p2.imag();\n\n\t\t\t\t\t\tminX = min(minX, x), minY = min(minY, y);\n\t\t\t\t\t\tmaxX = max(maxX, x), maxY = max(maxY, y);\n\n\t\t\t\t\t\tpos[b] = pair<P, P>( P(minX, minY), P(maxX, maxY) );\n\n\t\t\t\t\t\tfor (int Y = minY; Y <= maxY; ++Y)\n\t\t\t\t\t\t\tfor (int X = minX; X <= maxX; ++X)\n\t\t\t\t\t\t\t\tm[Y][X] = b+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tif (m[y][x] == 0) flag = false;\n\n\t\tif (!flag) cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << m[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n#define repD(i, n) for(int i = n; i >= 0; i--)\n\nint cnt;\nint field[100][100];\nint check[100][100];\nint res[100][100];\nbool used[20];\nint K[20];\nint X, Y, n;\n\nvoid solve(int y, int x){\n\tif(y == Y){\n\t\tcnt++;\n\t\trep(i, Y)rep(j, X) res[i][j] = check[i][j];\n\t}else{\n\t\tif(check[y][x] >= 0){\n\t\t\tif(x == X-1) solve(y+1, 0);\n\t\t\telse solve(y, x+1);\n\t\t}else{\n\t\t\tint dy = Y - y;\n\t\t\tint dx = X- x;\n\t\t\tbool ok;\n\t\t\trep2(i, 1, dy + 1){\n\t\t\t\trep2(j, 1, dx + 1){\n\t\t\t\t\tok = true;\n\t\t\t\t\tint id = -1;\n\t\t\t\t\trep(k, i){\n\t\t\t\t\t\trep(l, j){\n\t\t\t\t\t\t\tif(check[y+k][x+l] >= 0) ok = false;\n\t\t\t\t\t\t\tif(field[y+k][x+l] > 0){\n\t\t\t\t\t\t\t\tif(!used[field[y+k][x+l]] && (id == -1 || field[y+k][x+l] == id)){\n\t\t\t\t\t\t\t\t\tid = field[y+k][x+l];\n\t\t\t\t\t\t\t\t}else ok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ok || id == -1 || K[id] != i * j) continue;\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = id;\n\t\t\t\t\tused[id] = true;\n\t\t\t\t\tsolve(y,x);\n\t\t\t\t\tused[id] = false;\n\t\t\t\t\trep(k,i)rep(l, j) check[y+k][x+l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nint main(){\n\twhile(cin >> X >> Y >> n && (X || Y || n)){\n\t\tint total = 0;\n\t\n\t\trep(i, n){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tcin >> K[b];\n\t\t\ttotal += K[b];\n\t\t}\n\t\tif(total != X * Y){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i, Y)rep(j, X){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t\tmemset(check, -1, sizeof(check));\n\t\tmemset(used, false, sizeof(used));\n\t\tcnt = 0;\n\t\tsolve(0, 0);\n\t\tif(cnt != 1) cout << \"NA\" << endl;\n\t\telse{\n\t\t\trep(i, Y){\n\t\t\t\trep(j,X){\n\t\t\t\t\tif(j != 0) cout << \" \";\n\t\t\t\t\tcout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\nbool flag = false;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n\n    if ( r0 < 0 || c0 < 0 ) return false;\n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 ); r0 < min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 ); c0 < min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            -- s;\n            if ( s >= n ) {\n                flag = true;\n                return;\n            }\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        if ( flag ) {\n            cout << \"NA\" << endl;\n            continue;\n        }\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint W, H, N; \nint b[16], k[16];\nint s[10][10];\nint ans[10][10];\nint used[10][10];\nclass DFSError {};\nvoid dfs(int idx){\n  if(idx == N) {\n    if(ans[0][0] != -1) throw DFSError();\n    REP(y, H)REP(x, W) ans[y][x] = used[y][x];\n    return;\n  }\n  /*\n  printf(\"idx = %d\\n\", idx);\n  REP(y, H){\n    REP(x, W){\n      cout << used[y][x];\n      if(x != W - 1) cout << \" \";\n      else cout << endl;\n    }\n  }\n  */\n  int tx = -1 , ty = -1;\n  REP(y, H)REP(x, W) if(s[y][x] == b[idx]) tx = x, ty = y;\n  //printf(\"idx = %d tx = %d ty = %d\\n\", idx, tx, ty);\n  assert(tx != -1);\n  for(int h = 1; h <= k[idx]; h++) if(k[idx] % h == 0){\n    int w = k[idx] / h;\n    for(int by = 0; by > -h; by--) for(int bx = 0; bx > -w; bx--){\n      int sx = tx + bx;\n      int sy = ty + by;\n      bool ok = true;\n      for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n        if(!valid(sx + x, sy + y, W, H) || used[sy + y][sx + x] != -1) ok = false;\n      }\n      if(ok){\n        int tmp[10][10];\n        memcpy(tmp, used, sizeof(used));\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n          used[sy + y][sx + x] = b[idx];\n        }\n        dfs(idx + 1);\n        memcpy(used, tmp, sizeof(used));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H >> N && W){\n    REP(i, N) cin >> b[i] >> k[i];\n    REP(y, H)REP(x, W) cin >> s[y][x];\n    try{\n      memset(used, -1, sizeof(used));\n      memset(ans, -1, sizeof(ans));\n      dfs(0);\n      REP(y, H){\n        REP(x, W){\n          cout << ans[y][x];\n          if(x != W - 1) cout << \" \";\n          else cout << endl;\n        }\n      }\n    }catch(...){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<class T>\nvector<T> divisor(T n){\n    vector<T> ret;\n    for(T i = 1; i * i <= n; i++) {\n        if(n % i == 0) {\n            ret.push_back(i);\n            if(i * i != n) ret.push_back(n / i);\n        }\n    }\n    sort(begin(ret), end(ret));\n    return(ret);\n}\n\nvoid solve(int w, int h, int n){\n    vector<int> ss(n+1);\n    for (int i = 0; i < n; ++i) {\n        int b, k;\n        cin >> b >> k;\n        ss[b] = k;\n    }\n\n    vector<vector<int>> G(h, vector<int>(w, 0));\n    vector<int> ys(n+1), xs(n+1);\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            cin >> G[i][j];\n            if(G[i][j]){\n                ys[G[i][j]] = i;\n                xs[G[i][j]] = j;\n            }\n        }\n    }\n    if(accumulate(ss.begin(),ss.end(), 0) != h*w){\n        puts(\"NA\");\n        return;\n    }\n    vector<vector<int>> a(n+1);\n    for (int i = 1; i <= n; ++i) {\n        a[i] = divisor(ss[i]);\n    }\n    vector<int> used(n+1);\n    int cnt = 0;\n    stack<pair<int, int>> s;\n    vector<vector<int>> ans;\n    auto dfs = [&](int y, int x, auto &&f) -> bool {\n        if(cnt >= 2) return 1;\n        if(y == h) {\n            if(cnt && G != ans) return 1;\n            if(!cnt) {\n                ans = G;\n                cnt++;\n            }\n            return 0;\n        }\n        if(G[y][x]) {\n            if(f(y+(x == w-1), (x+1)%w, f)) return 1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            if(!used[i]){\n                used[i] = 1;\n                for (auto &&sz : a[i]) {\n                    if(y+sz > h ||  x+ss[i]/sz > w) continue;\n                    int ok = 0;\n                    for (int j = 0; j < sz; ++j) {\n                        for (int k = 0; k < ss[i]/sz; ++k) {\n                            if(G[y+j][x+k] == i){\n                                ok = 1;\n                            }else if(G[y+j][x+k]){\n                                ok = 0;\n                                j = k = 1000;\n                            }\n                        }\n                    }\n                    if(!ok) continue;\n                    for (int j = 0; j < sz; ++j) {\n                        for (int k = 0; k < ss[i]/sz; ++k) {\n                            G[y+j][x+k] = i;\n                        }\n                    }\n                    if(f(y+(x == w-1), (x+1)%w, f)) return 1;\n                    for (int j = 0; j < sz; ++j) {\n                        for (int k = 0; k < ss[i]/sz; ++k) {\n                            if(ys[i] != y+j || xs[i] != x+k){\n                                G[y+j][x+k] = 0;\n                            }\n                        }\n                    }\n                }\n                used[i] = 0;\n            }\n        }\n        return 0;\n    };\n    if(dfs(0, 0, dfs) || !cnt) puts(\"NA\");\n    else {\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                if(j) printf(\" \");\n                cout << ans[i][j];\n            }\n            puts(\"\");\n        }\n    }\n}\n\nint main() {\n    int w, h, n;\n    while(cin >> w >> h >> n, w){\n        solve(w, h, n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <math.h>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Data{\n\tData(int arg_num1,int arg_num2){\n\t\tnum1 = arg_num1;\n\t\tnum2 = arg_num2;\n\t}\n\tint num1,num2;\n};\n\nstruct Info{\n\tint tmp_table[10][10];\n\tint state;\n};\n\nstruct Kanban{\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nint H,W,N;\nint table[16],POW[16];\nint ans_table[10][10];\nvector<Data> DATA[101];\nKanban kanban[16];\n\n\nvoid func(){\n\n\tint id,area,sum_area = 0;\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d\",&id,&area);\n\t\ttable[id] = area;\n\t\tsum_area += area;\n\t}\n\n\tInfo first;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&first.tmp_table[row][col]);\n\t\t\tif(first.tmp_table[row][col] > 0){\n\t\t\t\tkanban[first.tmp_table[row][col]].set(row,col);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(sum_area != H*W){\n\t\tprintf(\"NA\\n\");\n\t\treturn;\n\t}\n\n\tfirst.state = 0;\n\n\tint ans_num = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\tint finish = POW[N]-1;\n\tint kado_row,kado_col;\n\tbool FLG;\n\tint width,height;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().state == finish){\n\t\t\tif(ans_num == 1){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans_num = 1;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tans_table[row][col] = Q.front().tmp_table[row][col];\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tkado_row = -1;\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\t\tif((Q.front().tmp_table[row][col] == 0) || (Q.front().state & (1 << (Q.front().tmp_table[row][col]-1))) == 0){\n\t\t\t\t\t\tkado_row = row;\n\t\t\t\t\t\tkado_col = col;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(kado_row != -1)break;\n\t\t\t}\n\n\t\t\tfor(int loop = 1; loop <= N; loop++){\n\t\t\t\tif(Q.front().state & (1 << (loop-1)))continue;\n\n\n\t\t\t\tfor(int i = 0; i < DATA[table[loop]].size(); i++){\n\t\t\t\t\twidth = DATA[table[loop]][i].num1;\n\t\t\t\t\theight = DATA[table[loop]][i].num2;\n\n\t\t\t\t\tif(kado_row+height-1 >= H || kado_col+width-1 >= W)continue;\n\t\t\t\t\tif(kanban[loop].col < kado_col || kanban[loop].col > kado_col+width-1\n\t\t\t\t\t\t\t|| kanban[loop].row < kado_row || kanban[loop].row > kado_row+height-1)continue;\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tfor(int row = kado_row; row <= kado_row+height-1; row++){\n\t\t\t\t\t\tfor(int col = kado_col; col <= kado_col+width-1; col++){\n\t\t\t\t\t\t\tif(Q.front().tmp_table[row][col] != 0 && Q.front().tmp_table[row][col] != loop){\n\t\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!FLG)continue;\n\n\t\t\t\t\tInfo next_info;\n\t\t\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\t\t\tfor(int col = 0; col < W; col++)next_info.tmp_table[row][col] = Q.front().tmp_table[row][col];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int row = kado_row; row <= kado_row+height-1; row++){\n\t\t\t\t\t\tfor(int col = kado_col; col <= kado_col+width-1; col++){\n\t\t\t\t\t\t\tnext_info.tmp_table[row][col] = loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnext_info.state = Q.front().state+POW[loop-1];\n\t\t\t\t\tQ.push(next_info);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(ans_num == 1){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tprintf(\"%d\",ans_table[row][0]);\n\t\t\tfor(int col = 1; col < W; col++){\n\t\t\t\tprintf(\" %d\",ans_table[row][col]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n\n}\n\n\nint main(){\n\n\tfor(int num = 1; num <= 100; num++){\n\t\tfor(int k = 1; k <= num; k++){\n\t\t\tif(num%k == 0){\n\t\t\t\tDATA[num].push_back(Data(k,num/k));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 16; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&W,&H,&N);\n\t\tif(W == 0 && H == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair< pair<int,int>,pair<int,int> > NODE;\n#define NY first.first\n#define NX first.second\n#define SY second.first\n#define SX second.second\n\nint X,Y,n,ret;\nvector< vector<int> > solve;\nmap<int,vector<NODE> > able;\nvector< vector<int> > data(15,vector<int>(15));\nvector< vector<int> > none(15,vector<int>(15));\nvector< vector<int> > rec;\n\nvoid bt(int dp){\n\tif(ret>1)return;\n\tvector<vector<int> > tt = rec;\n\tbool flag;\n\tif(dp==n){\n\t\tflag = true;\n\t\trep(i,Y)rep(j,X)if(!rec[i][j])flag = false;\n\t\tif(flag){\n\t\t\tret++;\n\t\t\tsolve = rec;\n\t\t}\n\t\treturn;\n\t}\n\tmap<int,vector<NODE> >::iterator it = able.begin();\n\tfor(int i=0;i<dp;i++)it++;\n\t\n\tfor(int i=0;i<(*it).second.size();i++){\n\t\tflag = true;\n\t\trep(y,(*it).second[i].SY)rep(x,(*it).second[i].SX){\n\t\t\tif(rec[(*it).second[i].NY+y][(*it).second[i].NX+x])flag = false;\n\t\t\trec[(*it).second[i].NY+y][(*it).second[i].NX+x]=(*it).first;\n\t\t}\n\t\tif(flag)bt(dp+1);\n\t\trec = tt;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tmap<int,int> buy;\n\t\n\tint b,k;\n\tint name,cnt;\n\tpair<int,int> coord;\n\twhile(cin >> X >> Y >> n , X){\n\t\tret = 0;/*\trep(i,Y){\n\t\trep(j,X)cout << rec[i][j];\n\t\tcout << endl;\n\t}\n*/\n\t\table.clear();\n\t\tbuy.clear();\n\t\trep(i,Y)rep(j,X)data[i][j]=0;\n\t\trep(i,n){\n\t\t\tcin >> b >> k;\n\t\t\tbuy[b] = k;\n\t\t}\n\t\trep(i,Y)rep(j,X)cin >> data[i][j];\n\n\t\trep(i,Y)rep(j,X){\n\t\t\trep(y,Y)rep(x,X){\n\t\t\t\tif( j+x > X-1 || i+y > Y-1 )continue;\n\t\t\t\tcnt = 0;\n\t\t\t\trep(YY,i+1)rep(XX,j+1)\n\t\t\t\t\tif(data[y+YY][x+XX]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tname = data[y+YY][x+XX];\n\t\t\t\t\t\tcoord = make_pair(y,x);\n\t\t\t\t\t}\n\t\t\t\tif(cnt == 1 && (i+1)*(j+1) == buy[name] ){\n\t\t\t\t\table[name].push_back( make_pair(coord,make_pair(i+1,j+1)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tmap<int,vector<NODE> >::iterator it = able.begin();\n\t\twhile(it != able.end()){\n\t\t\tfor(int i=0;i<(*it).second.size();i++)\n\t\t\t\tcout << (*it).first << \"=\" << (*it).second[i].NX << \",\" << (*it).second[i].NY << \" -> \" << (*it).second[i].SX << \",\" << (*it).second[i].SY << endl;\n\t\t\t++it;\n\t\t}\n*/\n\t\trec = none;\n\t\tbt(0);\n\t\tif(ret==1){\n\t\t\trep(i,Y){\n\t\t\t\trep(j,X)cout << solve[i][j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,n,land[50][50],test[50][50],ans[50][50];\n\nbool search(int i0,int j0){\n//printf(\"i0=%d, j0=%d\\n\",i0,j0);\n//for(int a=0;a<h;a++){for(int b=0;b<w;b++)printf(\"%d \",test[a][b]);puts(\"\");}puts(\"\");\n\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\nif(i<0 || h<=i || j<0 || w<=j)\twhile(1);\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\nif(id<0 || n<id)\twhile(1)puts(\"@@@\");\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tans[i][j]=test[i][j];}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);}\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\nusing namespace std;\nint W,H,n;\nmap<int,int> area;\n\nstruct Info{\n\tint x,y,w,h;\n\tInfo(int x,int y,int w,int h) : x(x) , y(y) , w(w) , h(h) {}\n\tInfo(){x=y=w=h=-99999;}\n};\n\nmap<int,vector<Info> > info;\n\nint c[11][11];\nint ok = 0;\nint current[11][11];\nint answer[11][11];\n\nint dfs(map<int,vector<Info> >::iterator it){\n\tif( ok >= 2 ) return 0;\n\tif( it == info.end()){\n\t\tint bad = 0;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tif( current[i][j] == 0 ) bad = true;\n\t\t\t}\n\t\t}\n\t\tif( bad ) return 0;\n\t\tok++;\n\t\trep(i,11)rep(j,11) answer[i][j] = current[i][j];\n\t\treturn 0;\n\t}else{\n\t\tvector<Info> &v = it->second;\n\t\tfor(int i = 0 ; i < v.size() ; i++){\n\t\t\tint chk = 1;\n\t\t\tfor(int y = 0 ; y < v[i].h ; y++){\n\t\t\t\tfor(int x = 0 ; x < v[i].w ; x++){\n\t\t\t\t\tchk &= current[v[i].y+y][v[i].x+x] == 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !chk ) continue;\n\t\t\tfor(int y = 0 ; y < v[i].h ; y++){\n\t\t\t\tfor(int x = 0 ; x < v[i].w ; x++){\n\t\t\t\t\tcurrent[v[i].y+y][v[i].x+x] = it->first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tit++;\n\t\t\tdfs(it);\n\t\t\tit--;\n\t\t\tfor(int y = 0 ; y < v[i].h ; y++){\n\t\t\t\tfor(int x = 0 ; x < v[i].w ; x++){\n\t\t\t\t\tcurrent[v[i].y+y][v[i].x+x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\nint main(){\n\twhile(cin >> W >> H >> n && W){\n\t\tinfo.clear();\n\t\tfor(int i = 0 ; i < 11 ; i++)\n\t\t\tfor(int j = 0 ; j < 11 ; j++)\n\t\t\t\tanswer[i][j] = current[i][j] = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\t\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tarea[a] = b;\n\t\t}\n\t\trep(i,H)rep(j,W) cin >> c[i][j];\n\t\tfor(int sx = 1 ; sx <= W ; sx++){\n\t\t\tfor(int sy = 1 ; sy <= H ; sy++){\n\t\t\t\tint cnt = 0 , number = 0;\n\t\t\t\tfor(int i = 0 ; i <= H - sy ; i++){\n\t\t\t\t\tfor(int j = 0 ; j <= W - sx ; j++){\n\t\t\t\t\t\tint cnt = 0 , number;\n\t\t\t\t\t\tfor(int k = 0 ; k < sy ; k++){\n\t\t\t\t\t\t\tfor(int l = 0 ; l < sx ; l++){\n\t\t\t\t\t\t\t\tint C = c[i+k][j+l];\n\t\t\t\t\t\t\t\tif( C != 0 ){\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t\tnumber = C;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( cnt == 1 && area[number] == sx * sy ){\n\t\t\t\t\t\t\tinfo[number].push_back(Info(j,i,sx,sy));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tok = 0;\n\t\tdfs(info.begin());\n\t\tif( ok != 1 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\trep(i,H){\n\t\t\t\trep(j,W) cout << (j?\" \":\"\") << answer[i][j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\n\n\nint field[10][10];\nint ans[10][10];\nint kukaku[15];\nP start[15];\nint X,Y,n;\n\nvoid copy_field(){\n    for(int i=0;i<Y;i++){\n        for(int j=0;j<X;j++){\n            ans[i][j] = field[i][j];\n        }\n    }\n}\n\nvoid print_field(){\n    for(int i=0;i<Y;i++){\n        cout << ans[i][0];\n        for(int j=1;j<X;j++){\n            printf(\" %d\",ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint  dfs(int n_i){\n    if(n_i == n){\n        copy_field();\n        return 1;\n    }\n    int p = 0;\n    for(int tate=1;tate<=kukaku[n_i];tate++){\n        if (kukaku[n_i]%tate)continue;\n        int yoko = kukaku[n_i] / tate;\n        //printf(\"tate=%d yoko=%d\\n\",tate,yoko);\n        for(int y=start[n_i].first-tate+1; y<=start[n_i].first; y++){\n            for(int x=start[n_i].second-yoko+1; x<=start[n_i].second; x++){\n                //printf(\"n_i=%d x=%d y=%d\\n\",n_i,x,y);\n                if(!(0<=y&&y+tate-1<Y&&0<=x&&x+yoko-1<X)) continue;\n                bool can_paint = true;\n                for(int i=0;i<tate;i++){\n                    for(int j=0;j<yoko;j++){\n                        if(field[y+i][x+j]==0||field[y+i][x+j]==n_i+1){\n                            field[y+i][x+j] = n_i+1;\n                        }else{\n                            can_paint = false;\n                            break;\n                        }\n                    }\n                }\n                //printf(\"can_paint=%d\\n\",can_paint);\n                if(can_paint){\n                    p += dfs(n_i+1);\n                    if(p>1) return p;\n                }\n                for(int i=0;i<tate;i++){\n                    for(int j=0;j<yoko;j++){\n                        if(field[y+i][x+j]==n_i+1){\n                            field[y+i][x+j] = 0;\n                        }\n                    }\n                }\n                field[start[n_i].first][start[n_i].second] = n_i+1;\n            }\n        }\n    }\n    return p;\n}\n\n\nint main(){\n    while(1){\n        scanf(\"%d%d%d\",&X,&Y,&n);\n        if(!X)break;\n\n        for(int i=0;i<n;i++){\n            int d;\n            scanf(\"%d\",&d);\n            scanf(\"%d\",&kukaku[d-1]);\n        }\n\n        for(int i=0;i<Y;i++){\n            for(int j=0;j<X;j++){\n                scanf(\"%d\",&field[i][j]);\n                if(field[i][j]>0){\n                    start[field[i][j]-1] = P(i,j);\n                }\n            }\n        }\n        if(dfs(0)==1){\n            print_field();\n        }else{\n            printf(\"NA\\n\");\n        }\n\n        //break;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nstruct P{\n\tint x, y;\n};\n\nint W, H, n;\nint memo[16], res[10][10];\nP pos[16];\n\n//i番目を置くよー\nint rec(int map[10][10], int used, int x, int y){\n\tif(y == H){//できたよー\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tres[i][j] = map[i][j];\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\tint res = 0;\n\tif(map[y][x] != 0){//もう埋まっている\n\t\tres += rec(map, used, (x+1)%W, (x+1)%W?y:y+1);\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tif(used >> i & 1)continue;\n\t\tfor(int width=1;width<=memo[i];width++){\n\t\t\tif(memo[i] % width != 0)continue;\n\n\t\t\tint height = memo[i] / width, _map[10][10];\n\t\t\tif(x <= pos[i].x && pos[i].x <= x + width - 1 &&\n\t\t\t\t y <= pos[i].y && pos[i].y <= y + height - 1 &&\n\t\t\t\t x + width - 1 < W && y + height - 1 < H){\n\t\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\t\t\t_map[j][k] = map[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbool divided = true;\n\t\t\t\tfor(int j=0;j<height&&divided;j++){\n\t\t\t\t\tfor(int k=0;k<width&&divided;k++){\n\t\t\t\t\t\tif(_map[y+j][x+k] != 0)divided = false;//同じ所に入れない\n\t\t\t\t\t\t_map[y+j][x+k] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!divided)break;\n\n\t\t\t\tres += rec(_map, used | (1 << i), (x+width)%W, (x+width)%W?y:y+1);\n\t\t\t}\n\t\t}\t\n\t}\n\n\treturn res;\n}\n\nint main(){\n\twhile(std::cin >> W >> H >> n, W){\n\t\tfor(int i=n;i--;){\n\t\t\tint index;\n\t\t\tstd::cin >> index;\n\t\t\tstd::cin >> memo[index];\n\t\t}\n\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tint v;\n\t\t\t\tstd::cin >> v;\n\t\t\t\tif(v != 0){\n\t\t\t\t\tpos[v] = {x, y};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint map[10][10];\n\t\tfor(int i=0;i<100;i++){\n\t\t\tmap[i/10][i%10] = 0;\n\t\t}\n\n\t\tif(rec(map, 0, 0, 0) == 1){\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tstd::cout << res[i][0];\n\t\t\t\tfor(int j=1;j<W;j++){\n\t\t\t\t\tstd::cout << \" \" << res[i][j];\n\t\t\t\t}\n\t\t\t\tstd::cout << std::endl;\n\t\t\t}\n\t\t}else{\n\t\t\tstd::cout << \"NA\" << std::endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nqueue<pair<int, vector<vector<int> > > >Q;\nvector<vector<int>>X, P; int H, W, N, V1[20], V2[20];\npair<bool, vector<vector<int> > > hantei(vector<vector<int> >a1, int X1, int Y1, int H1, int W1, int N1) {\n\tbool OK = true; int G[30][30];\n\tfor (int i = 0; i < 900; i++)G[i / 30][i % 30] = 0;\n\tfor (int i = X1; i < X1 + H1; i++) {\n\t\tfor (int j = Y1; j < Y1 + W1; j++) {\n\t\t\tif (i >= H || j >= W) { OK = false; continue; }\n\t\t\tif (a1[i][j] != 0 || (X[i][j] != V1[N1] && X[i][j] >= 1))OK = false;\n\t\t\ta1[i][j] = V1[N1]; G[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (X[i][j] == V1[N1] && G[i][j] == 0)OK = false;\n\t\t}\n\t}\n\treturn make_pair(OK, a1);\n}\nint main() {\n\twhile (true) {\n\t\tX.clear(); P.clear(); H = 0; W = 0; N = 0;\n\t\tcin >> W >> H >> N; int D1 = 0; if (W == 0 && H == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; i++) { cin >> V1[i] >> V2[i]; D1 += V2[i]; }\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tvector<int>G, I; int a;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a; G.push_back(a); I.push_back(0);\n\t\t\t}\n\t\t\tX.push_back(G); P.push_back(I);\n\t\t}\n\t\tif (D1 != W*H) { cout << \"NA\" << endl; continue; }\n\t\tQ.push(make_pair(0, P)); vector<vector<int> >res; int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tvector<vector<int>>K = Q.front().second;\n\t\t\tint L = Q.front().first; Q.pop();\n\t\t\tif (Q.size() >= 140) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\twhile (!Q.empty())Q.pop();\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (L == N) { cnt++; res = K; continue; }\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 1; k <= V2[L]; k++) {\n\t\t\t\t\t\tif (V2[L] % k != 0)continue;\n\t\t\t\t\t\tpair<bool, vector<vector<int> > >res1 = hantei(K, i, j, k, V2[L] / k, L);\n\t\t\t\t\t\tif (res1.first == true) {\n\t\t\t\t\t\t\tQ.push(make_pair(L + 1, res1.second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0 || cnt >= 2)cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (j >= 1) { cout << ' '; }cout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\tE:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<20> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    Rect() {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else if(any_of(cur.begin(), cur.end(), [r,c](const Rect &re){return re.intersect(Rect(r,c,1,1));})) {\n        dfs(r, c+1, state, cur);\n    } else {\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint w, h;\nvector<int> area;\nvector<vector<int> > sum;\n\nint retNum;\nvector<vector<int> > ret;\n\nvoid solve(int y, int x, vector<vector<int> >& used)\n{\n    if(x > w){\n        ++ y;\n        x = 1;\n    }\n    if(y > h){\n        ++ retNum;\n        ret = used;\n        return;\n    }\n\n    if(used[y][x] != 0){\n        solve(y, x+1, used);\n        return;\n    }\n\n    for(int y1=y; y1<=h; ++y1){\n        for(int x1=x; x1<=w; ++x1){\n            bitset<16> bs = sum[y1][x1] & (~sum[y1][x-1]) & (~sum[y-1][x1]);\n            if(bs.count() != 1)\n                continue;\n\n            int k = 0;\n            while(!bs[k])\n                ++ k;\n            if(area[k] != (y1 - y + 1) * (x1 - x + 1))\n                continue;\n\n            bool ng = false;\n            vector<vector<int> > used1 = used;\n            for(int i=y; i<=y1; ++i){\n                for(int j=x; j<=x1; ++j){\n                    if(used1[i][j] != 0)\n                        ng = true;\n                    used1[i][j] = k;\n                }\n            }\n            if(!ng)\n                solve(y, x+1, used1);\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n\n        area.assign(n+1, 0);\n        for(int i=0; i<n; ++i){\n            int b, k;\n            cin >> b >> k;\n            area[b] = k;\n        }\n\n        sum.assign(h+1, vector<int>(w+1, 0));\n        for(int y=1; y<=h; ++y){\n            int tmp = 0;\n            for(int x=1; x<=w; ++x){\n                int a;\n                cin >> a;\n                if(a > 0)\n                    tmp |= (1 << a);\n                sum[y][x] = sum[y-1][x] | tmp;\n            }\n        }\n\n        retNum = 0;\n        vector<vector<int> > s(h+1, vector<int>(w+1, 0));\n        solve(1, 1, s);\n\n        if(retNum != 1){\n            cout << \"NA\" << endl;\n        }else{\n            for(int i=1; i<=h; ++i){\n                cout << ret[i][1];\n                for(int j=2; j<=w; ++j)\n                    cout << ' ' << ret[i][j];\n                cout << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nint T[11][11];\nint TC[11][11];\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[k] % w0 != 0 ) continue;\n        int h0 = K[k] / w0;\n        for ( int r0 = 0; r0 < h; ++ r0 ) {\n            for ( int c0 = 0; c0 < w; ++ c0 ) {\n                if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                    if ( canPut( r0, c0, w0, h0 ) ) {\n                        for ( int i = 0; i < h0; ++ i ) {\n                            for ( int j = 0; j < w0; ++ j ) {\n                                Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                            }\n                        }\n                        put( k, r0, c0, w0, h0 );\n                        solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                        for ( int i = 0; i < h0; ++ i ) {\n                            for ( int j = 0; j < w0; ++ j ) {\n                                T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                            }\n                        }\n                    }\n                    if ( cnt >= 2 ) return;\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint pos[15][15], ans[15][15], area[105], x, y;\nint tmp[15][15];\nbool used[105], one, more;\nvoid solve(int a, int b){\n    if(ans[a][b]){\n\ta++;\n\ta %= x;\n\tif(a == 0)b++;\n\tif(b == y){\n\t    if(one || more){\n\t\tmore = true;\n\t\tone = false;\n\t    }\n\t    else one = true;\n\t    for(int i = 0;i < x;i++)\n\t\tfor(int j = 0;j < y;j++)\n\t\t    tmp[i][j] = ans[i][j];\n\t    return ;\n\t}\n\tsolve(a, b);\n\treturn;\n    }\n    for(int p = 1;area[p];p++){\n\tif(used[p])continue;\n\tfor(int i = 1;i * i <= area[p];i++){\n\t    if(area[p] % i)continue;\n\t    int j = area[p] / i;\n\t    if(a + i <= x && b + j <= y){\n\t\tbool ok = true, found = false;\n\t\tfor(int k = a;k < a + i && ok;k++){\n\t\t    for(int l = b;l < b + j && ok;l++){\n\t\t\tif(pos[k][l] != 0 && pos[k][l] != p)ok = false;\n\t\t\tif(ans[k][l] != 0)ok = false;\n\t\t\tif(pos[k][l] == p)found = true;\n\t\t    }\n\t\t}\n\t\tif(ok && found){\n\t\t    for(int k = a;k < a + i && ok;k++){\n\t\t\tfor(int l = b;l < b + j && ok;l++){\n\t\t\t    ans[k][l] = p;\n\t\t\t}\n\t\t    }\n\t\t    solve(a, b);\n\t\t    for(int k = a;k < a + i && ok;k++){\n\t\t\tfor(int l = b;l < b + j && ok;l++){\n\t\t\t    ans[k][l] = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if(i == j)continue;\n\t    swap(i, j);\n\t    \n\t    if(a + i <= x && b + j <= y){\n\t\tbool ok = true, found = false;\n\t\tfor(int k = a;k < a + i && ok;k++){\n\t\t    for(int l = b;l < b + j && ok;l++){\n\t\t\tif(pos[k][l] != 0 && pos[k][l] != p)ok = false;\n\t\t\tif(ans[k][l] != 0)ok = false;\n\t\t\tif(pos[k][l] == p)found = true;\n\t\t    }\n\t\t}\n\t\tif(ok && found){\n\t\t    for(int k = a;k < a + i && ok;k++){\n\t\t\tfor(int l = b;l < b + j && ok;l++){\n\t\t\t    ans[k][l] = p;\n\t\t\t}\n\t\t    }\n\t\t    solve(a, b);\n\t\t    for(int k = a;k < a + i && ok;k++){\n\t\t\tfor(int l = b;l < b + j && ok;l++){\n\t\t\t    ans[k][l] = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    swap(i, j);\n\n\t}\n    }\n}\n\nint main(){\n    int n, a, b;\n    while(cin >> x >> y >> n, n){\n\tswap(x, y);\n\tone = more = false;\n\tfor(int i = 0;i < x;i++)\n\t    for(int j = 0;j < y;j++)\n\t\tans[i][j] = 0;\n\tfor(int i = 0;i < n;i++){\n\t    cin >> a >> b;\n\t    area[a] = b;\n\t}\n\tarea[n + 1] = 0;\n\tfor(int i = 0;i < x;i++)\n\t    for(int j = 0;j < y;j++)\n\t\tcin >> pos[i][j];\n\tsolve(0, 0);\n\tif(one){\n\t    for(int i = 0;i < x;i++){\n\t\tfor(int j = 0;j < y;j++){\n\t\t    if(j)cout << \" \";\n\t\t    cout  << tmp[i][j];\n\t\t}\n\t\tcout << endl;\n\t    }\n\t}\n\telse\n\t    cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nconst int MAX_NUM = 16;\nint w, h, n;\nint T[SIZE][SIZE];\nint TC[SIZE][SIZE];\nint K[MAX_NUM]; \nII U[MAX_NUM]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[SIZE][SIZE];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\n\nint n, w, h;\nint have[16];\npint pos[16];\nint field[16][16], answer[16][16];\n\n\nbool zero(int id, int x1, int y1, int x2, int y2)\n{\n  REP(x, x1, x2+1) REP(y, y1, y2+1) if(field[x][y] != 0 && field[x][y] != id) return false;\n\n  return true;\n}\n\nint rec(int id)\n{\n  if(n < id){\n    rep(x, w) rep(y, h) answer[x][y] = field[x][y];\n    return 1;\n  }\n\n  int res = 0;\n  \n  for(int x1 = pos[id].first; 0 <= x1; x1--) {\n    for(int y1 = pos[id].second; 0 <= y1; y1--) {\n      REP(x2, pos[id].first, w) REP(y2, pos[id].second, h) if((x2 - x1 + 1) * (y2 - y1 + 1) == have[id]) {\n\tif(!zero(id, x1, y1, x2, y2)) break;\n\t\n\tfor(int x = x1; x <= x2; x++) for(int y = y1; y <= y2; y++) field[x][y] = id;\n\n\tres += rec(id + 1);\n\n\tfor(int x = x1; x <= x2; x++) for(int y = y1; y <= y2; y++) if(mp(x, y) != pos[id]) field[x][y] = 0;\n      }\n    }\n  }\n\n  return res;\n}\n\nint main()\n{\n  while(cin >> w >> h >> n && w){\n\n    rep(i, n){\n      int b, k;\n      cin >> b >> k;\n      have[b] = k;\n    }\n\n    rep(y, h) rep(x, w){\n      cin >> field[x][y];\n      pos[field[x][y]] = mp(x, y);\n    }\n\n    if(rec(1) == 1) rep(y, h) rep(x, w) cout << answer[x][y] << (x + 1 == w ? \"\\n\" : \" \");\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nstruct P{int x, y;};\nint W, H, n;\nint memo[16], res[10][10];\nP pos[16];\nusing namespace std;\n\n//i?????????????????????//used??§??????????????§?????£?????????????????????????????????\n//?????????x??¨y??§???????????§????????§?????£???????????????????????????\nint rec(int map[10][10], int used, int x, int y){\n    if(y == H){//??§????????????\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                res[i][j] = map[i][j];\n            }\n        }\n        return 1;\n    }\n    int res = 0;\n    if(map[y][x] != 0){//??????????????£?????????\n        res += rec(map, used, (x+1)%W, (x+1)%W?y:y+1);\n    }\n    for(int i=1;i<=n;i++){//?????????i????????°??¶?????????\n        if(used >> i & 1)continue;//???????????¨?????????????¬?????????????\n        //memo?????£????????§?????????????????£?????????????????????\n        for(int width=1;width<=memo[i];width++){\n            //????????¢????????????????????¨???????¨???§?????£?????????\n        \t//??????????????§?????£??????????????§??????????????????????????????\n        \tif(memo[i] % width != 0)continue;\n            //????????§????????¢?????????????????¶??????????????????\n            int height = memo[i] / width, _map[10][10];\n           //position????????\\????????????????????????????????????-1??\\???????????°???y???????????????\n            //?????????????????????width????????????W,H??\\???????????°???\n            //map???????????\\????????????????????????????????¶???if??????????????\\??£???????????¨???????????????????????????\n            if(x <= pos[i].x &&\n            pos[i].x <= x + width - 1 &&\n                 y <= pos[i].y &&\n            pos[i].y <= y + height - 1 &&\n                 x + width - 1 < W &&\n                 y + height - 1 < H){\n            \t//?????????map???????????§?????£????????????????????????????????????\n                for(int j=0;j<H;j++){\n                    for(int k=0;k<W;k++){\n                        _map[j][k] = map[j][k];\n                    }\n                }\n                //_map[][]?????????????????¬?¨??????´??? map\n                bool divided = true;\n                for(int j=0;j<height&&divided;j++){\n                    for(int k=0;k<width&&divided;k++){\n                        if(_map[y+j][x+k] != 0)divided = false;//??????????????\\?????????\n                        _map[y+j][x+k] = i;\n                    }\n                }\n                //????????´????????\\????????¬????????????\n                if(!divided)break;\n                res += rec(_map, used | (1 << i), (x+width)%W, (x+width)%W?y:y+1);\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H >> n, W){\n    \tint index;int v;\n    \tfor(int i=n;i--;){cin >> index; cin >> memo[index];}\n    \tfor(int y=0;y<H;y++){for(int x=0;x<W;x++){cin >> v;if(v != 0){pos[v] = {x, y};}}}\n    \t//cin >> v;if(v != 0){pos[v] = {x, y};}}}\n        int map[10][10];\n        for(int i=0;i<100;i++){map[i/10][i%10] = 0;}\n\n        if(rec(map, 0, 0, 0) == 1){\n            for(int i=0;i<H;i++){\n                cout << res[i][0];\n                for(int j=1;j<W;j++){\n                    cout << \" \" << res[i][j];\n                }\n                cout << endl;\n            }\n        }else{\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,n,land[50][50],test[50][50],ans[50][50];\n\nbool search(int i0,int j0){\n//printf(\"i0=%d, j0=%d\\n\",i0,j0);\n//for(int a=0;a<h;a++){for(int b=0;b<w;b++)printf(\"%d \",test[a][b]);puts(\"\");}puts(\"\");\n\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\nif(i<0 || h<=i || j<0 || w<=j)\twhile(1);\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\nif(id<1 || n<id)\twhile(1);\n\t\t\t// try to put a rectangle\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\tif(test[yy][xx]!=0\n\t\t\t\t\t\t\t||(land[yy][xx]!=0 && land[yy][xx]!=id))\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\nif(yy<0 || h<=yy || xx<0 || w<=xx)\twhile(1);\n\t\t\t\t\t\t\ttest[yy][xx]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tans[i][j]=test[i][j];}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);}\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(i,H) rep(j,W) edge[i][j].clear();\n  int debug = 0;\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); debug++; }\n        if( debug >= 1000000 ) while(1);\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n  if( cy >= H ) while(1);\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n\n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next;\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ) goto Skip;\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip:;\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) ans[cy+y][cx+x] = 0;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { rep(j,W) cout << buf[i][j]; cout << endl; } \n  } else puts(\"NA\");\n}\n\nint main(){\n  while( cin >> W >> H >> n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    set<char> S;\n    rep(i,H) rep(j,W){\n      cin >> s[i][j];\n      if( S.count(s[i][j]) && s[i][j] != 0 ) while(1);\n      S.insert(s[i][j]);\n    }\n    if( sum != H*W ) {\n      puts(\"NA\");\n      continue;\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\nbool use[16];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j] && !use[ok[y][x][i][j]]) {\n\t\t\t\tuse[ok[y][x][i][j]] = true;\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t\tuse[ok[y][x][i][j]] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tout.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n\t\tfor(int i = 0; i < 16; i++)\n\t\t\tuse[i] = false;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = i; y <= k && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = j; x <= l && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt != 1) ok[i][j][k][l] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < v.size(); i++) sum += v[i];\n\t\tif(res == 1 && sum == X*Y) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nint T[11][11];\nint TC[11][11];\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[11][11];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[k] % w0 != 0 ) continue;\n        int h0 = K[k] / w0;\n        for ( int r0 = 0; r0 < h; ++ r0 ) {\n            for ( int c0 = 0; c0 < w; ++ c0 ) {\n                if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                    if ( put( k, r0, c0, w0, h0 ) ) {\n                        solve( k + 1 );\n                        for ( int i = 0; i < h0; ++ i ) {\n                            for ( int j = 0; j < w0; ++ j ) {\n                                T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                            }\n                        }\n                    }\n                    if ( cnt >= 2 ) return;\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint X, Y, n;\n\nstruct Memo\n{\n\tint b;\n\tint k;\n};\n\nstruct Point\n{\n\tint x;\n\tint y;\n};\n\nstruct Node\n{\n\tint idx;\n\tint a[10][10];\n};\n\nclass memo_greater\n{\npublic:\n\tbool operator() (const Memo m1, const Memo m2)\n\t{\n\t\treturn m1.k > m2.k;\n\t}\n};\n\nPoint P[15];\nMemo M[15];\nint A[10][10];\n\nbool is_able(int a[10][10], int x, int y, int w, int h, int idx)\n{\n\tfor(int j=y; j<y+h; j++)\n\t{\n\t\tfor(int i=x; i<x+w; i++)\n\t\t{\n\t\t\tif(i<0 || j<0 || i>=X || j>=Y) return false;\n\t\t\tif(a[j][i]!=0 && a[j][i]!=idx) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid set(int a[10][10], int x, int y, int w, int h, int idx)\n{\n\tfor(int j=y; j<y+h; j++)\n\t{\n\t\tfor(int i=x; i<x+w; i++)\n\t\t{\n\t\t\ta[j][i] = idx;\n\t\t}\n\t}\n}\n\nbool is_ans()\n{\n\tfor(int y=0; y<Y; y++)\n\t{\n\t\tfor(int x=0; x<X; x++)\n\t\t{\n\t\t\tif(A[y][x]==0)\n\t\t\t{\n\t\t\t\treturn false;\t\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool solve()\n{\n\tqueue<Node> que;\n\tint b, k, i, j, mem_size;\n\tPoint p;\n\n\tbool is_ok;\n\tmem_size = sizeof(int) * 100;\n\tsort(&M[0], &M[n-1], memo_greater());\n\tNode nn;\n\tnn.idx = 0;\n\tmemcpy(nn.a, A, mem_size);\n\n\tque.push(nn);\n\n\tis_ok = false;\n\twhile(!que.empty())\n\t{\n\t\tnn = que.front();\n\t\tque.pop();\n\n\t\tif(nn.idx==n)\n\t\t{\n\t\t\tif(!is_ok)\n\t\t\t{\n\t\t\t\tmemcpy(A, nn.a, mem_size);\n\t\t\t\tis_ok = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tb = M[nn.idx].b;\n\t\tk = M[nn.idx].k;\n\t\tp = P[b-1];\n\n\t\tfor(i=1; i<=k; i++)\n\t\t{\n\t\t\tif(k%i!=0) continue;\n\n\t\t\tj = k / i;\n\t\t\tfor(int dy=0; dy<j; dy++)\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<i; dx++)\n\t\t\t\t{\n\t\t\t\t\tif(is_able(nn.a, p.x-dx, p.y-dy, i, j, b))\n\t\t\t\t\t{\n\t\t\t\t\t\tNode node;\n\t\t\t\t\t\tmemcpy(node.a, nn.a, mem_size);\n\t\t\t\t\t\tset(node.a, p.x-dx, p.y-dy, i, j, b);\n\t\t\t\t\t\tnode.idx = nn.idx+1;\n\t\t\t\t\t\tque.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(is_ok) return true;\n\telse return false;\n}\n\nint main(int argc, char** argv)\n{\n\twhile( 1 )\n\t{\n\t\tcin >> X >> Y >> n;\n\t\tif(!(X || Y || n)) break;\n\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> M[i].b >> M[i].k;\n\t\t}\n\n\t\tfor(int y=0; y<Y; y++)\n\t\t{\n\t\t\tfor(int x=0; x<X; x++)\n\t\t\t{\n\t\t\t\tcin >> A[y][x];\n\t\t\t\tif(A[y][x] != 0)\n\t\t\t\t{\n\t\t\t\t\tP[A[y][x]-1].x = x;\n\t\t\t\t\tP[A[y][x]-1].y = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(solve())\n\t\t{\t\n\t\t\tfor(int y=0; y<Y; y++)\n\t\t\t{\n\t\t\t\tfor(int x=0; x<X; x++)\n\t\t\t\t{\n\t\t\t\t\tcout << A[y][x];\n\t\t\t\t\tif(x!=X-1) cout << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint X, Y, n;\nint id[10], k[10];\nint sx[11], sy[11];\nint bd[10][10];\n\nvector<pair<int,int> > area[101];\nint ans[10][10];\n\nint dfs(int u) {\n\tif (u == n) {\n\t\tmemcpy(ans, bd, sizeof ans);\n\t\treturn 1;\n\t}\n\tint h, w, tx, ty, lx, rx, uy, dy;\n\ttx = sx[id[u]];\n\tty = sy[id[u]];\n\tbd[ty][tx] = 0;\n\tint ret = 0;\n\tfor (int i=0; i<(int)area[k[u]].size(); ++i) {\n\t\th = area[k[u]][i].first;\n\t\tw = area[k[u]][i].second;\n\t\tlx = max(tx-w+1, 0);\n\t\trx = min(tx+w-1, X-1);\n\t\tuy = max(ty-h+1, 0);\n\t\tdy = min(ty+h-1, Y-1);\n\t\tif (rx-lx+1 < w || dy-uy+1 < h) continue;\n\t\tfor (int y=uy; y+h-1<=dy; ++y) {\n\t\t\tfor (int x=lx; x+w-1<=rx; ++x) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int y2=y; y2<y+h && ok; ++y2) {\n\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\tif (bd[y2][x2] != 0) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tfor (int y2=y; y2<y+h; ++y2) {\n\t\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\t\tbd[y2][x2] = id[u];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += dfs(u+1);\n\t\t\t\t\tfor (int y2=y; y2<y+h; ++y2) {\n\t\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\t\tbd[y2][x2] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (2 <= ret) return ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbd[ty][tx] = id[u];\n\treturn ret;\n}\n\nint main() {\n\tfor (int i=1; i<=10; ++i) {\n\t\tfor (int j=1; j<=10; ++j) {\n\t\t\tarea[i*j].push_back(make_pair(i, j));\n\t\t}\n\t}\n\twhile (cin >> X >> Y >> n, X) {\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> id[i] >> k[i];\n\t\t}\n\t\tfor (int i=0; i<Y; ++i) {\n\t\t\tfor (int j=0; j<X; ++j) {\n\t\t\t\tcin >> bd[i][j];\n\t\t\t\tif (bd[i][j] != 0) {\n\t\t\t\t\tsx[bd[i][j]] = j;\n\t\t\t\t\tsy[bd[i][j]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = dfs(0);\n\t\tif (res == 0 || 2 <= res) {\n\t\t\tcout << \"NA\\n\";\n\t\t} else {\n\t\t\tfor (int i=0; i<Y; ++i) {\n\t\t\t\tfor (int j=0; j<X; ++j) {\n\t\t\t\t\tcout << (j == 0 ? \"\" : \" \") << ans[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\nbool use[16];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j] && !use[ok[y][x][i][j]]) {\n\t\t\t\tuse[ok[y][x][i][j]] = true;\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t\tuse[ok[y][x][i][j]] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n\t\tfor(int i = 0; i < 16; i++)\n\t\t\tuse[i] = false;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = 0; y < Y && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = 0; x < X && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg)\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < v.size(); i++) sum += v[i];\n\t\tif(res == 1 && sum == X*Y) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define pb push_back\n\nint X,Y,N;\nint b[100], k[100];\nint c[10][10], f[10][10], ans[10][10];\nint cnt;\n\nvector<int> bx[101],by[101];\n\nbool isputs(int x, int y, int n, int a, int b)\n{\n\tif(x+bx[a][b] > X || y+by[a][b] > Y) return false;\n\n\tfor(int i=y; i<y+by[a][b]; i++)\n\tfor(int j=x; j<x+bx[a][b]; j++)\n\t{\n\t\tif(c[j][i]!=0 && c[j][i]!=n) return false;\n\t\tif(f[j][i]!=0) return false;\n\n\t\tf[j][i]=n;\n\t}\n\t\n\treturn true;\n}\n\nvoid dfs(int n)\n{\n\tif(cnt>=2) return;\n\t\n\tif(n==N) \n\t{\n\t\tcnt++;\n\t\tmemcpy(ans, f, sizeof(ans));\n\t\treturn;\n\t}\n\n\tint p=b[n], a=k[n];\n\tint t[10][10];\n\tmemcpy(t,f,sizeof(t));\n\n\tfor(int i=0; i<Y; i++)\n\tfor(int j=0; j<X; j++)\n\t{\n\t\tif(f[j][i]!=0) continue;\n\t\tfor(int l=0; l<bx[a].size(); l++)\t\n\t\t{\t\n\t\t\tif(isputs(j,i,p,a,l)) dfs(n+1);\n\n\t\t\tmemcpy(f,t,sizeof(f));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(int x=1; x<=10; x++)\n\tfor(int y=1; y<=10; y++)\n\t{\n\t\tint n=x*y;\n\t\tbx[n].pb(x);\n\t\tby[n].pb(y);\n\t}\n\n\twhile(cin >> X >> Y >> N, (X||Y||N))\n\t{\n\t\tvector<pair<int,int> > data;\n\n\t\tcnt=0;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin >> b[i] >> k[i];\n\t\t\tdata.push_back(make_pair(k[i],b[i]));\n\t\t}\n\n\t\tsort(data.begin(), data.end(), greater<pair<int,int> >());\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tb[i]=data[i].second;\n\t\t\tk[i]=data[i].first;\n\t\t}\n\t\n\n\t\n\t\tfor(int i=0; i<Y; i++)\n\t\tfor(int j=0; j<X; j++)\n\t\t\tcin >> c[j][i];\n\n\t\tmemset(f,0,sizeof(f));\n\t\t\n\t\tdfs(0);\n\t\tif(cnt == 1)\n\t\t{\n\t\t\tfor(int i=0; i<Y; i++)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<X; j++)\n\t\t\t\t\tcout << ans[j][i] << (j==X-1?\"\":\" \");\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse cout << \"NA\" << endl;\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\nbool use[16];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j] && !use[ok[y][x][i][j]]) {\n\t\t\t\tuse[ok[y][x][i][j]] = true;\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t\tuse[ok[y][x][i][j]] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tout.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n\t\tfor(int i = 0; i < 16; i++)\n\t\t\tuse[i] = false;\n\t\tfor(int i = 1; i < v.size(); i++) v[i] = -1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tif(v[i] < 0) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = 0; y < Y && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = 0; x < X && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(cnt != 1) ok[i][j][k][l] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < v.size(); i++) sum += v[i];\n\t\tbool flg = true;\n\t\tfor(int i = 0; i < out.size(); i++)\n\t\t\tfor(int j = 0; j < out[i].size(); j++)\n\t\t\t\tflg &= out[i][j] != 0;\n\t\tif(res == 1 && sum == X*Y && flg) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<20> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    Rect() : r(0), c(0), h(0), w(0) {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else {\n        bool conquered = false;\n        for(int i = 0; i < N; ++i) {\n            if(!state[i]) continue;\n            if(cur[i].intersect(Rect(r, c, 1, 1))) {\n                conquered = true;\n                break;\n            }\n        }\n        if(conquered) {\n            dfs(r, c+1, state, cur);\n            return;\n        }\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef bitset<15> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    Rect() {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\nvector<Rect> ans;\nvector<Rect> tags;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else if(any_of(cur.begin(), cur.end(), [r,c](const Rect &re){return re.intersect(Rect(r,c,1,1));})) {\n        dfs(r, c+1, state, cur);\n    } else {\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int i = 0; i < N; ++i) {\n                    if(i == b && !cand.intersect(tags[i])) goto next;\n                    if(i != b && cand.intersect(tags[i])) goto next;\n                }\n                // Check: it doesn't intersect with other rects\n                for(const auto rect : cur) {\n                    if(cand.intersect(rect)) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    tags.clear();\n    tags.resize(N);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            int v;\n            cin >> v;\n            if(v != 0) {\n                tags[v-1] = Rect(r, c, 1, 1);\n            }\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        vector<vector<int>> field(H, vector<int>(W, 0));\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Subdivide The Land\n//Level: 3\n//Category: 探索\n//Note:\n\n/**\n * パズル「四角に切れ」と同じ問題設定なので、おそらくNP完全である。\n * したがって、効率のよい探索を考える。\n *\n * 全てのマスがどれかの長方形に属していることより、盤面を左上から走査していき、どの番号の長方形に属すかを探索していけばよい。\n * こうすることで、そのマスを左上とした長方形に決め打つことができる。\n * 各番号では、その面積を与える長方形を全て試す。\n */\n#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<15> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    Rect() : r(0), c(0), h(0), w(0) {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else {\n        bool conquered = false;\n        for(int i = 0; i < N; ++i) {\n            if(!state[i]) continue;\n            if(cur[i].intersect(Rect(r, c, 1, 1))) {\n                conquered = true;\n                break;\n            }\n        }\n        if(conquered) {\n            dfs(r, c+1, state, cur);\n            return;\n        }\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(!state[i]) continue;\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n#define PUT 0\n#define REMOVE 1\n#define CHECK_PLANE 2\n\nint cnt;\nint m[10][10];\nint ans[10][10];\n\nbool is_origin[10][10];\nbool make_rect(int now,int x,int y,int width,int height,int flag,\n\t       int r,int c){\n  rep(i,height){\n    rep(j,width){\n      if ( flag == PUT )m[y+i][j+x]=now;\n      else if ( flag == REMOVE && is_origin[y+i][x+j] == false){\n\tm[y+i][j+x]=0;\n      }else if (flag == CHECK_PLANE){\n\tif ( m[y+i][j+x]!=0 && m[y+i][j+x]!=now)return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid solve(int num,int now,int *number,int *x,int *y,int *size,int r,int c){\n  if ( now == num){\n    cnt++;\n    rep(i,r)rep(j,c)ans[i][j]=m[i][j];\n    return;\n  }\n\n  if ( cnt > 1)return;\n  \n  int cur=number[now];\n  REP(k,1,size[now]+1){\n    if ( size[now]%k != 0)continue;\n    int h=k,w=size[now]/k;\n    int hstart=max(0,y[now]-h+1),wstart=max(0,x[now]-w+1);\n    REP(i,hstart,y[now]+1 && i+h <=r){\n      REP(j,wstart,x[now]+1 && j+w <=c){\n\tif ( make_rect(cur,j,i,w,h,CHECK_PLANE,r,c) ){\n\t  make_rect(cur,j,i,w,h,PUT,r,c);\n\t  solve(num,now+1,number,x,y,size,r,c);\n\t  make_rect(cur,j,i,w,h,REMOVE,r,c);\n\t}\n      }\n    }\n  }\n}\n\n\nmain(){\n  int c,r,n;\n  while(cin>>c>>r>>n && c){\n    pair<int,int> in[n];\n    int x[n],y[n],size[n],tmp[100+1],num[100+1];\n    rep(i,n)cin>>in[i].second>>in[i].first;\n    sort(in,in+n);\n    rep(i,n)tmp[in[i].second]=i,size[i]=in[i].first,num[i]=in[i].second;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif ( m[i][j] != 0){\n\t  x[tmp[m[i][j]]]=j;\n\t  y[tmp[m[i][j]]]=i;\n\t  is_origin[i][j]=true;\n\t}\n\tis_origin[i][j]=false;\n      }\n    }\n    cnt = 0;\n\n    solve(n,0,num,x,y,size,r,c);\n    if ( cnt == 1){\n      rep(i,r){\n\trep(j,c){\n\t  if ( j)cout << ' ';\n\t  cout <<ans[i][j];\n\t}\n\tcout << endl;\n      }\n    }else cout << \"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint stage_w,stage_h,total_buyers;\nint ans[50][50];\n\nvoid disp(int stage[50][50]){\n  for(int y = 0; y < stage_h; y++){\n    for(int x = 0; x < stage_w; x++){\n      printf(\"%d \",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nbool check(int stage[50][50]){\n  for(int y = 0; y < stage_h; y++){\n    for(int x = 0; x < stage_w; x++){\n      if(stage[y][x] == 0) return false;\n    }\n  }\n  memcpy(ans,stage,sizeof(int)*50*50);\n  return true;\n}\n\nint dfs(int id,int areas[50],P occupied[50],int stage[50][50]){\n  if(id > total_buyers){\n    return check(stage) ? 1 : 0;\n  }\n\n  int res = 0;\n  for(int w = 1; w <= areas[id]; w++){\n    int h = areas[id] / w;\n    if(h * w != areas[id]) continue;\n    int cx = occupied[id].first;\n    int cy = occupied[id].second;\n\n    for(int lx = cx - w + 1; lx <= cx; lx++){\n      if(lx < 0) continue;\n\n      int rx = lx + w - 1;\n\n      if(rx >= stage_w) continue;\n      for(int ly = cy - h + 1; ly <= cy; ly++){\n        if(ly < 0) continue;\n\n        int ry = ly + h - 1;\n        if(ry >= stage_h) continue;\n\n        int prev[50][50];\n        memcpy(prev,stage,sizeof(int)*50*50);\n        for(int x = lx; x <= rx; x++){\n          for(int y = ly; y <= ry; y++){\n            if(stage[y][x] == 0){\n              stage[y][x] = id;\n            }\n            else if(stage[y][x] != id){\n              goto fail;\n            }\n          }\n        }\n        res += dfs(id + 1,areas,occupied,stage);\n      fail:;\n        memcpy(stage,prev,sizeof(int)*50*50);\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n\n  while(~scanf(\"%d %d %d\",&stage_w,&stage_h,&total_buyers)){\n    if(stage_w == 0 && stage_h == 0) break;\n\n    int stage[50][50];\n    int areas[50];\n    for(int buyer_i = 0; buyer_i < total_buyers; buyer_i++){\n      int id;\n      int area;\n      scanf(\"%d %d\",&id,&area);\n      areas[id] = area;\n    }\n\n    P occupied[50];\n    for(int y = 0; y < stage_h; y++){\n      for(int x = 0; x < stage_w; x++){\n        scanf(\"%d\",&stage[y][x]);\n        if(stage[y][x] != 0){\n          occupied[stage[y][x]] = P(x,y);\n        }\n      }\n    }\n\n    if(dfs(1,areas,occupied,stage) == 1){\n      disp(ans);\n    }\n    else{\n      printf(\"NA\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n#define PUT 0\n#define REMOVE 1\n#define CHECK_PLANE 2\n\nint cnt;\nint m[10][10];\nint ans[10][10];\n\nbool is_origin[10][10];\nbool make_rect(int now,int x,int y,int width,int height,int flag,\n\t       int r,int c){\n  rep(i,height){\n    rep(j,width){\n      if ( flag == PUT )m[y+i][j+x]=now;\n      else if ( flag == REMOVE && is_origin[y+i][x+j] == false){\n\tm[y+i][j+x]=0;\n      }else if (flag == CHECK_PLANE){\n\tif ( m[y+i][j+x]!=0 && m[y+i][j+x]!=now)return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid solve(int num,int now,int *number,int *x,int *y,int *size,int r,int c){\n  if ( now == num){\n    cnt++;\n    rep(i,r)rep(j,c)ans[i][j]=m[i][j];\n    return;\n  }\n\n  if ( cnt > 1)return;\n  \n  int cur=number[now];\n  REP(k,1,size[now]+1){\n    if ( size[now]%k != 0)continue;\n    int h=k,w=size[now]/k;\n    int hstart=max(0,y[now]-h+1),wstart=max(0,x[now]-w+1);\n    REP(i,hstart,y[now]+1 && i+h <=r){\n      REP(j,wstart,x[now]+1 && j+w <=c){\n\tif ( make_rect(cur,j,i,w,h,CHECK_PLANE,r,c) ){\n\t  make_rect(cur,j,i,w,h,PUT,r,c);\n\t  solve(num,now+1,number,x,y,size,r,c);\n\t  make_rect(cur,j,i,w,h,REMOVE,r,c);\n\t}\n      }\n    }\n  }\n}\n\n\nmain(){\n  int c,r,n;\n  while(cin>>c>>r>>n && c){\n    pair<int,int> in[n];\n    int x[n],y[n],size[n],tmp[n+1],num[n+1];\n    rep(i,n)cin>>in[i].second>>in[i].first;\n    sort(in,in+n,greater<pair<int,int> >());\n    rep(i,n)tmp[in[i].second]=i,size[i]=in[i].first,num[i]=in[i].second;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif ( m[i][j] != 0){\n\t  x[tmp[m[i][j]]]=j;\n\t  y[tmp[m[i][j]]]=i;\n\t  is_origin[i][j]=true;\n\t}\n\tis_origin[i][j]=false;\n      }\n    }\n    cnt = 0;\n\n    solve(n,0,num,x,y,size,r,c);\n    if ( cnt == 1){\n      rep(i,r){\n\trep(j,c){\n\t  if ( j)cout << ' ';\n\t  cout <<ans[i][j];\n\t}\n\tcout << endl;\n      }\n    }else cout << \"NA\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nint T[20][20];\nint TC[20][20];\nint K[20]; \nII U[20]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[20][20];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                if ( K[k] % w0 != 0 ) continue;\n                int h0 = K[k] / w0;\n                if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                    for ( int i = 0; i < h; ++ i ) {\n                        for ( int j = 0; j < w; ++ j ) {\n                            T[i][j] = Tcopy[i][j];\n                        }\n                    }\n                    if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                    if ( cnt >= 2 ) return;\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nvoid output1() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\nvector< vector<int> > draw; int drawTimes;\nvoid drawInit(int W, int H) {\n\t++W, ++H;\n\n\tdrawTimes = 0;\n\tdraw.resize(H);\n\tfor (int i = 0; i < H; ++i) draw[i].resize(W);\n\n\tfor (int y = 0; y < H; ++y)\n\t\tfor (int x = 0; x < W; ++x)\n\t\t\tdraw[y][x] = 0;\n}\nvoid drawSet(P p1, P p2) {\n\t++drawTimes;\n\n\tdraw[p1.imag()][p1.real()] += 1;\n\tdraw[p1.imag()][p2.real()] += -1;\n\tdraw[p2.imag()][p1.real()] += -1;\n\tdraw[p2.imag()][p2.real()] += 1;\n}\nvoid drawDo() {\n\tfor (int y = 0; y < draw.size(); ++y)\n\t\tfor (int x = 0; x < draw[0].size()-1; ++x)\n\t\t\tdraw[y][x+1] += draw[y][x];\n\n\tfor (int x = 0; x < draw[0].size(); ++x)\n\t\tfor (int y = 0; y < draw.size()-1; ++y)\n\t\t\tdraw[y+1][x] += draw[y][x];\n}\n\nint main() {\n\tint W, H, n;\n\twhile (cin >> W >> H >> n, W || H || n) {\n\t\tvector<int> block(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint b, k; cin >> b >> k;\n\t\t\tblock[b-1] = k;\n\t\t}\n\n\t\tvector< vector<int> > m(H, vector<int>(W));\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tcin >> m[y][x];\n\n\t\tvector< vector<int> > df(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 1; j*j <= block[i]; ++j) {\n\t\t\t\tif (block[i] % j == 0) {\n\t\t\t\t\tdf[i].push_back( j );\n\t\t\t\t\tif (j != block[i] / j) df[i].push_back( block[i] / j );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector< pair<P, P> > pos(n);\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tif (m[y][x])\n\t\t\t\t\tpos[m[y][x]-1] = pair<P, P>( P(x, y), P(x, y) );\n\n\t\tint count = W * H - n;\n\t\tfor (int t = 0; t < W*H; ++t) {\n\t\t\tvector< vector<int> > state(H, vector<int>(W, 0));\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tdrawInit(W, H);\n\t\t\t\tfor (int j = 0; j < df[i].size(); ++j) {\n\t\t\t\t\tint w = df[i][j], h = block[i] / df[i][j];\n\n\t\t\t\t\tif (w <= W && h <= H) {\n\t\t\t\t\t\tP p1 = pos[i].first, p2 = pos[i].second;\n\t\t\t\t\t\tint x1 = p1.real(), y1 = p1.imag();\n\t\t\t\t\t\tint x2 = p2.real(), y2 = p2.imag();\n\t\t\t\t\t\tint posW = x2 - x1 + 1, posH = y2 - y1 + 1;\n\n\t\t\t\t\t\tif (w >= posW && h >= posH) {\n\t\t\t\t\t\t\tw -= posW, h -= posH;\n\t\t\t\t\t\t\tx1 = max(x1-w, 0),   y1 = max(y1-h, 0);\n\t\t\t\t\t\t\tx2 = min(x2+w+1, W), y2 = min(y2+h+1, H);\n\t\t\t\t\t\t\tdrawSet( P(x1, y1), P(x2, y2) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdrawDo();\n/*\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << draw[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}cout << endl;\n*/\n\t\t\t\tfor (int y = 0; y < H; ++y)\n\t\t\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\t\t\tif (draw[y][x])\n\t\t\t\t\t\t\tstate[y][x] |= 1 << i;\n\t\t\t}\n\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (!m[y][x] && state[y][x] && state[y][x] == (state[y][x] & -state[y][x])) {\n\t\t\t\t\t\tint b = 0;\n\t\t\t\t\t\tfor (int k = 1; k != state[y][x]; k *= 2, ++b);\n\n\t\t\t\t\t\tP p1 = pos[b].first, p2 = pos[b].second;\n\t\t\t\t\t\tint minX = p1.real(), minY = p1.imag();\n\t\t\t\t\t\tint maxX = p2.real(), maxY = p2.imag();\n\n\t\t\t\t\t\tminX = min(minX, x), minY = min(minY, y);\n\t\t\t\t\t\tmaxX = max(maxX, x), maxY = max(maxY, y);\n\n\t\t\t\t\t\tpos[b] = pair<P, P>( P(minX, minY), P(maxX, maxY) );\n\n\t\t\t\t\t\tfor (int Y = minY; Y <= maxY; ++Y) {\n\t\t\t\t\t\t\tfor (int X = minX; X <= maxX; ++X) {\n\t\t\t\t\t\t\t\tif (!m[Y][X]) {\n\t\t\t\t\t\t\t\t\t--count;\n\t\t\t\t\t\t\t\t\tm[Y][X] = b+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int y = 0; y < H; ++y)\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tif (m[y][x] == 0) flag = false;\n\n\t\tif (!flag) cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tif (x) cout << \" \";\n\t\t\t\t\tcout << m[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Subdivide The Land\n//Level: 3\n//Category: 探索\n//Note:\n\n/**\n * パズル「四角に切れ」と同じ問題設定なので、おそらくNP完全である。\n * したがって、効率のよい探索を考える。\n *\n * 全てのマスがどれかの長方形に属していることより、盤面を左上から走査していき、どの番号の長方形に属すかを探索していけばよい。\n * こうすることで、そのマスを左上とした長方形に決め打つことができる。\n * 各番号では、その面積を与える長方形を全て試す。\n */\n#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<15> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    //Rect() : r(0), c(0), h(0), w(0) {}\n    Rect() {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else {\n        bool conquered = false;\n        for(int i = 0; i < N; ++i) {\n            if(!state[i]) continue;\n            if(cur[i].intersect(Rect(r, c, 1, 1))) {\n                conquered = true;\n                break;\n            }\n        }\n        if(conquered) {\n            dfs(r, c+1, state, cur);\n            return;\n        }\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX 32\ntypedef pair<int,int> pi;\n\ninline bool isinside(int H, int W, pi p){\n  return 0<=p.first&&p.first<H && 0<=p.second&&p.second<W;\n}\n\nint cnt;\nint ans[MAX][MAX];\n\nvoid solve(int H, int W, int n, int area[], pi pos[], int M[][MAX], int now){\n\n  /*\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( j > 0 ) cout << ' ';\n      cout << M[i][j];\n    }\n    cout << endl;\n  }\n  cout << \" --------------- \" << endl;\n  */\n\n  if( now > n ){\n    ++cnt;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tans[i][j] = M[i][j];\n      }\n    }\n    return ;\n  }\n  int A = area[now];\n  if( A > 0 ){\n    for(int h = 1; h <= A; ++h){\n      if( A % h == 0 ){\n\tint w = A / h;\n\tfor(int i = 0; i < h; ++i){\n\t  for(int j = 0; j < w; ++j){\n\t    pi st(pos[now].first-i,pos[now].second-j);\n\t    pi ed(st.first+h-1,st.second+w-1);\n\t    if( isinside( H,W,st ) && isinside( H,W,ed ) ){\n\n\t      //\t      cout << \" NOW : \" << now << ' ' << st.first << ' ' << st.second << ' ' << h << ' ' << w << endl;\n\t      \n\t      int tM[MAX][MAX];\n\t      for(int ti = 0; ti < H; ++ti){\n\t\tfor(int tj = 0; tj < W; ++tj){\n\t\t  tM[ti][tj] = M[ti][tj];\n\t\t}\n\t      }\n\t      \n\t      for(int ti = 0; ti < h; ++ti){\n\t\tfor(int tj = 0; tj < w; ++tj){\n\t\t  if( M[st.first+ti][st.second+tj] != now && M[st.first+ti][st.second+tj] != 0 ) goto next;\n\t\t  M[st.first+ti][st.second+tj] = now;\n\t\t}\n\t      }\n\t      solve( H,W,n,area,pos,M,now+1 );\n\t      \n\t    next:;\n\t      for(int ti = 0; ti < H; ++ti){\n\t\tfor(int tj = 0; tj < W; ++tj){\n\t\t  M[ti][tj] = tM[ti][tj];\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }else{\n    solve( H,W,n,area,pos,M,now+1 );\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int H,W,n;\n    int area[MAX]={0,};\n    pi pos[MAX];\n    int M[MAX][MAX]={{0,},};\n    cin >> W >> H >> n;\n    if( H == 0 && W == 0 && n == 0 ) break;\n\n    for(int i = 0; i < n; ++i){\n      int b,k;\n      cin >> b >> k;\n      area[b]=k;\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> M[i][j];\n\tif( M[i][j] > 0 ){\n\t  pos[ M[i][j] ] = pi(i,j);\n\t}\n      }\n    }\n\n    cnt = 0;\n    solve( H,W,n,area,pos,M,1 );\n\n    if( cnt == 1 ){\n      for(int i = 0; i < H; ++i){\n\tfor(int j = 0; j < W; ++j){\n\t  if( j > 0 ) cout << ' ';\n\t  cout << ans[i][j];\n\t}\n\tcout << endl;\n      }\n    }else{\n      cout << \"NA\" << endl;\n    }\n    \n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w, h, n, b[20], k[20], px[20], py[20], ans;\n\nbool check(int id, const vector<vector<int> > &s, int sx, int sy, int gx, int gy){\n\tif( sx <= px[id] && px[id] <= gx && sy <= py[id] && py[id] <= gy ){\n\t\tbool flag = false;\n\t\n\t\tfor(int y = sy; y <= gy; y++){\n\t\t\tfor(int x = sx; x <= gx; x++){\n\t\t\t\tif( s[y][x] == id + 1 ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}else if( s[y][x] != 0 ){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\treturn false;\n}\n\nvoid fill_(int id, vector<vector<int> > &next, int sx, int sy, int gx, int gy){\n\tfor(int y = sy; y <= gy; y++){\n\t\tfor(int x = sx; x <= gx; x++){\n\t\t\tnext[y][x] = id + 1;\n\t\t}\n\t}\n}\n\nvoid debug(const vector<vector<int> > &s){\n\tcout << \"debug:\" << endl;\n\tfor(int y=0; y < h; y++){\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tif( x ) cout << \" \";\n\t\t\tcout << s[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// id := 購入者番号, id = [0,n)\nvoid dfs(int id, const vector<vector<int> > &s, bool out){\n\t\n\tif( id == n ){ // ぜんぶ調べた\n\t\tans++;\n\t\tif( out ){\n\t\t\tfor(int y=0; y < h; y++){\n\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\tif( x ) cout << \" \";\n\t\t\t\t\tcout << s[y][x];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}else{\n\t\t\n\t\tfor(int sy = 0; sy < h; sy++){\n\t\t\tfor(int sx = 0; sx < w; sx++){\n\t\t\t\tfor(int gy = sy; gy < h; gy++){\n\t\t\t\t\tfor(int gx = sx; gx < w; gx++){\n\t\t\t\t\t\tint width = gx - sx + 1, height = gy - sy + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( width * height == k[id] && check(id, s, sx, sy, gx, gy) ){\n\t\t\t\t\t\t\tvector<vector<int> > next = s;\n\t\t\t\t\t\t\tfill_(id, next, sx, sy, gx, gy);\n\t\t\t\t\t\t\tdfs(id + 1, next, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h >> n, w || h || n ){\n\t\tfor(int i = 0; i < n; i++) cin >> b[i] >> k[i];\n\t\t\n\t\tvector<vector<int> > s(h, vector<int>(w));\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tcin >> s[y][x];\n\t\t\t\tif( s[y][x] != 0 ){\n\t\t\t\t\tpx[s[y][x]-1] = x;\n\t\t\t\t\tpy[s[y][x]-1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tdfs(0, s, false);\n\t\tif( ans != 1 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tdfs(0, s, true);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define pb push_back\n\nint X,Y,N;\nint b[100], k[100];\nint c[10][10], f[10][10], ans[10][10];\nint cnt;\n\nvector<int> bx[101],by[101];\n\nbool isputs(int x, int y, int n, int a, int b)\n{\n\tif(x+bx[a][b] > X || y+by[a][b] > Y) return false;\n\n\tfor(int i=y; i<y+by[a][b]; i++)\n\tfor(int j=x; j<x+bx[a][b]; j++)\n\t{\n\t\tif(c[j][i]!=0 && c[j][i]!=n) return false;\n\t\tif(f[j][i]!=0) return false;\n\n\t\tf[j][i]=n;\n\t}\n\t\n\treturn true;\n}\n\nvoid dfs(int n)\n{\n\tif(cnt>=2) return;\n\t\n\tif(n==N) \n\t{\n\t\tcnt++;\n\t\tmemcpy(ans, f, sizeof(ans));\n\t\treturn;\n\t}\n\n\tint p=b[n], a=k[n];\n\tint t[10][10];\n\tmemcpy(t,f,sizeof(t));\n\n\tfor(int i=0; i<Y; i++)\n\tfor(int j=0; j<X; j++)\n\t{\n\t\tif(f[j][i]!=0) continue;\n\t\tfor(int l=0; l<bx[a].size(); l++)\t\n\t\t{\t\n\t\t\tif(isputs(j,i,p,a,l)) dfs(n+1);\n\n\t\t\tmemcpy(f,t,sizeof(f));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(int x=1; x<=10; x++)\n\tfor(int y=1; y<=10; y++)\n\t{\n\t\tint n=x*y;\n\t\tbx[n].pb(x);\n\t\tby[n].pb(y);\n\t}\n\n\twhile(cin >> X >> Y >> N, (X||Y||N))\n\t{\n\t\tvector<pair<int,int> > data;\n\n\t\tcnt=0;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tcin >> b[i] >> k[i];\n\t\t\tdata.push_back(make_pair(k[i],b[i]));\n\t\t}\n\n\t\tsort(data.begin(), data.end(), greater<pair<int,int> >());\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tb[i]=data[i].second;\n\t\t\tk[i]=data[i].first;\n\t\t}\n\t\n\n\t\n\t\tfor(int i=0; i<Y; i++)\n\t\tfor(int j=0; j<X; j++)\n\t\t\tcin >> c[j][i];\n\n\t\tmemset(f,0,sizeof(f));\n\t\t\n\t\tdfs(0);\n\t\tif(cnt == 1)\n\t\t{\n\t\t\tfor(int i=0; i<Y; i++)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<X; j++)\n\t\t\t\t\tcout << ans[j][i] << \" \";\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse cout << \"NA\" << endl;\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid output2() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n\n    if ( r0 < 0 || c0 < 0 ) return false;\n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            if ( T[U[i].first][U[i].second] != i + 1 ) return;\n        }\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 - 1 ); r0 < min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 - 1 ); c0 < min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint X, Y, n;\nint id[20], k[20], sx[20], sy[20];\nint bd[10][10], ans[10][10];\nvector<pair<int,int> > area[101];\n\nint dfs(int u) {\n\tif (u == n) {\n\t\tmemcpy(ans, bd, sizeof ans);\n\t\treturn 1;\n\t}\n\tint h, w, tx, ty, lx, rx, uy, dy;\n\ttx = sx[id[u]];\n\tty = sy[id[u]];\n\tbd[ty][tx] = 0;\n\tint ret = 0;\n\tfor (int i=0; i<(int)area[k[u]].size(); ++i) {\n\t\th = area[k[u]][i].first;\n\t\tw = area[k[u]][i].second;\n\t\tlx = max(tx-w+1, 0);\n\t\trx = min(tx+w-1, X-1);\n\t\tuy = max(ty-h+1, 0);\n\t\tdy = min(ty+h-1, Y-1);\n\t\tif (rx-lx+1 < w || dy-uy+1 < h) continue;\n\t\tfor (int y=uy; y+h-1<=dy; ++y) {\n\t\t\tfor (int x=lx; x+w-1<=rx; ++x) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int y2=y; y2<y+h && ok; ++y2) {\n\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\tif (bd[y2][x2] != 0) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( ! ok) continue;\n\t\t\t\tfor (int y2=y; y2<y+h; ++y2) {\n\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\tbd[y2][x2] = id[u];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret += dfs(u+1);\n\t\t\t\tfor (int y2=y; y2<y+h; ++y2) {\n\t\t\t\t\tfor (int x2=x; x2<x+w; ++x2) {\n\t\t\t\t\t\tbd[y2][x2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (2 <= ret) return 2;\n\t\t\t}\n\t\t}\n\t}\n\tbd[ty][tx] = id[u];\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int i=1; i<=10; ++i) {\n\t\tfor (int j=1; j<=10; ++j) {\n\t\t\tarea[i*j].push_back(make_pair(i, j));\n\t\t}\n\t}\n\twhile (cin >> X >> Y >> n, X) {\n\t\tint sum = 0;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> id[i] >> k[i];\n\t\t\tsum += k[i];\n\t\t}\n\t\tfor (int i=0; i<Y; ++i) {\n\t\t\tfor (int j=0; j<X; ++j) {\n\t\t\t\tcin >> bd[i][j];\n\t\t\t\tif (bd[i][j] != 0) {\n\t\t\t\t\tsx[bd[i][j]] = j;\n\t\t\t\t\tsy[bd[i][j]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = dfs(0);\n\t\tif (X * Y != sum || res == 0 || 2 <= res) {\n\t\t\tcout << \"NA\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i=0; i<Y; ++i) {\n\t\t\tfor (int j=0; j<X; ++j) {\n\t\t\t\tcout << (j == 0 ? \"\" : \" \") << ans[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint pos[15][15], ans[15][15], area[105], x, y;\nint tmp[15][15];\nbool used[105], one, more;\nvoid solve(int a, int b){\n    if(ans[a][b]){\n\ta++;\n\ta %= x;\n\tif(a == 0)b++;\n\tif(b == y){\n\t    if(one || more){\n\t\tmore = true;\n\t\tone = false;\n\t    }\n\t    else one = true;\n\t    for(int i = 0;i < x;i++)\n\t\tfor(int j = 0;j < y;j++)\n\t\t    tmp[i][j] = ans[i][j];\n\t    return ;\n\t}\n\tsolve(a, b);\n\treturn;\n    }\n    for(int p = 1;area[p];p++){\n\tif(used[p])continue;\n\tfor(int i = 1;i * i <= area[p];i++){\n\t    if(area[p] % i)continue;\n\t    int j = area[p] / i;\n\t    if(a + i <= x && b + j <= y){\n\t\tbool ok = true, found = false;\n\t\tfor(int k = a;k < a + i && ok;k++){\n\t\t    for(int l = b;l < b + j && ok;l++){\n\t\t\tif(pos[k][l] == 0)continue;\n\t\t\tif(pos[k][l] == p)found = true;\n\t\t\telse ok = false;\n\t\t    }\n\t\t}\n\t\tif(ok && found){\n\t\t    for(int k = a;k < a + i && ok;k++){\n\t\t\tfor(int l = b;l < b + j && ok;l++){\n\t\t\t    ans[k][l] = p;\n\t\t\t}\n\t\t    }\n\t\t    solve(a, b);\n\t\t    for(int k = a;k < a + i && ok;k++){\n\t\t\tfor(int l = b;l < b + j && ok;l++){\n\t\t\t    ans[k][l] = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if(i == j)continue;\n\t    swap(i, j);\n\t    \n\t    if(a + i <= x && b + j <= y){\n\t\tbool ok = true, found = false;\n\t\tfor(int k = a;k < a + i && ok;k++){\n\t\t    for(int l = b;l < b + j && ok;l++){\n\t\t\tif(pos[k][l] == 0)continue;\n\t\t\tif(pos[k][l] == p)found = true;\n\t\t\telse ok = false;\n\t\t    }\n\t\t}\n\t\tif(ok && found){\n\t\t    for(int k = a;k < a + i && ok;k++){\n\t\t\tfor(int l = b;l < b + j && ok;l++){\n\t\t\t    ans[k][l] = p;\n\t\t\t}\n\t\t    }\n\t\t    solve(a, b);\n\t\t    for(int k = a;k < a + i && ok;k++){\n\t\t\tfor(int l = b;l < b + j && ok;l++){\n\t\t\t    ans[k][l] = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    swap(i, j);\n\n\t}\n    }\n}\n\nint main(){\n    int n, a, b;\n    while(cin >> x >> y >> n, n){\n\tswap(x, y);\n\tone = more = false;\n\tfor(int i = 0;i < x;i++)\n\t    for(int j = 0;j < y;j++)\n\t\tans[i][j] = 0;\n\tfor(int i = 0;i < n;i++){\n\t    cin >> a >> b;\n\t    area[a] = b;\n\t}\n\tarea[n + 1] = 0;\n\tfor(int i = 0;i < x;i++)\n\t    for(int j = 0;j < y;j++)\n\t\tcin >> pos[i][j];\n\tsolve(0, 0);\n\tif(one){\n\t    for(int i = 0;i < x;i++){\n\t\tfor(int j = 0;j < y;j++){\n\t\t    if(j)cout << \" \";\n\t\t    cout  << tmp[i][j];\n\t\t}\n\t\tcout << endl;\n\t    }\n\t}\n\telse\n\t    cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair< pair<int,int>,pair<int,int> > NODE;\n#define NY first.first\n#define NX first.second\n#define SY second.first\n#define SX second.second\n\nint X,Y,n,ret;\nvector< vector<int> > solve;\nmap<int,vector<NODE> > able;\nvector< vector<int> > data(20,vector<int>(20));\nvector< vector<int> > none(20,vector<int>(20));\nvector< vector<int> > rec(20,vector<int>(20));\n\nvoid bt(int dp){\n\tif(ret>1)return;\n\tvector<vector<int> > tt = rec;\n\tbool flag;\n\tif(dp==n){\n\t\tflag = true;\n\t\trep(i,Y)rep(j,X)if(!rec[i][j])flag = false;\n\t\tif(flag){\n\t\t\tret++;\n\t\t\tsolve = rec;\n\t\t}\n\t\treturn;\n\t}\n\tmap<int,vector<NODE> >::iterator it = able.begin();\n\tfor(int i=0;i<dp;i++)it++;\n\tfor(int i=0;i<(*it).second.size();i++){\n\t\tflag = true;\n\t\trep(y,(*it).second[i].SY)rep(x,(*it).second[i].SX){\n\t\t\tif(rec[(*it).second[i].NY+y][(*it).second[i].NX+x])flag = false;\n\t\t\trec[(*it).second[i].NY+y][(*it).second[i].NX+x]=(*it).first;\n\t\t}\n\t\tif(flag)bt(dp+1);\n\t\trec = tt;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tmap<int,int> buy;\n\t\n\tint b,k;\n\tint name,cnt;\n\tpair<int,int> coord;\n\twhile(cin >> X >> Y >> n , X){\n\t\tret = 0;/*\trep(i,Y){\n\t\trep(j,X)cout << rec[i][j];\n\t\tcout << endl;\n\t}\n*/\n\t\table.clear();\n\t\tbuy.clear();\n\t\trep(i,Y)rep(j,X)data[i][j]=0;\n\t\trep(i,n){\n\t\t\tcin >> b >> k;\n\t\t\tbuy[b] = k;\n\t\t}\n\t\trep(i,Y)rep(j,X)cin >> data[i][j];\n\n\t\trep(i,Y)rep(j,X){\n\t\t\trep(y,Y)rep(x,X){\n\t\t\t\tif( j+x > X-1 || i+y > Y-1 )continue;\n\t\t\t\tcnt = 0;\n\t\t\t\trep(YY,i+1)rep(XX,j+1)\n\t\t\t\t\tif(data[y+YY][x+XX]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tname = data[y+YY][x+XX];\n\t\t\t\t\t\tcoord = make_pair(y,x);\n\t\t\t\t\t}\n\t\t\t\tif(cnt == 1 && (i+1)*(j+1) == buy[name] ){\n\t\t\t\t\table[name].push_back( make_pair(coord,make_pair(i+1,j+1)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tmap<int,vector<NODE> >::iterator it = able.begin();\n\t\twhile(it != able.end()){\n\t\t\tfor(int i=0;i<(*it).second.size();i++)\n\t\t\t\tcout << (*it).first << \"=\" << (*it).second[i].NX << \",\" << (*it).second[i].NY << \" -> \" << (*it).second[i].SX << \",\" << (*it).second[i].SY << endl;\n\t\t\t++it;\n\t\t}\n*/\n\t\trec = none;\n\t\tif(n == able.size() )bt(0);\n\t\tif(ret==1){\n\t\t\trep(i,Y){\n\t\t\t\trep(j,X)cout << solve[i][j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j]) {\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = 0; y < Y && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = 0; x < X && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg)\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tif(res == 1) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nstruct Data { short h,w,index; };\n\nshort H,W,n,b[20],k[20],s[20][20],ans[20][20],buf[20][20];\nvector<Data> edge[20][20];\nshort found;\n\nbool isValid(int x,int y){ return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void makeEdge(){\n  rep(y,H) rep(x,W) {\n    rep(i,n){\n      for(int hy=1;hy<=k[i];hy++){ \n        if( k[i] % hy ) continue;\n        int hx = k[i] / hy;\n        bool failed = false, check = false;          \n        for(int cy=y;cy<y+hy;cy++)for(int cx=x;cx<x+hx;cx++){\n            if( !isValid(cx,cy) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( !( s[cy][cx] == 0 || s[cy][cx] == b[i] ) ) {\n              failed = true;\n              goto Skip;\n            }\n            if( s[cy][cx] == b[i] ) check = true;\n          }\n        if( check ) { edge[y][x].push_back((Data){hy,hx,b[i]}); }\n      Skip:;\n        \n      }\n    }\n  }\n}\n\nbool BackTracking(int cx,int cy){\n  if( cx == W-1 && cy == H-1 && ans[cy][cx] != 0 ) {\n    ++found;\n    if( found == 1 ) rep(i,H) rep(j,W) buf[i][j] = ans[i][j];\n    return found >= 2;\n  }\n  \n  rep(i,(int)edge[cy][cx].size()){\n    int h = edge[cy][cx][i].h, w = edge[cy][cx][i].w, index = edge[cy][cx][i].index;\n    ii next = ii(-1,-1);\n    ii memo = ii(-1,-1);\n    rep(y,h) rep(x,w) {\n      if( ans[y+cy][x+cx] != 0 ){\n        memo = ii(x,y);\n        goto Skip2;\n      }\n      ans[cy+y][cx+x] = index;\n    }\n    next = ii(-1,-1);\n    rep(y,H) rep(x,W){\n      if( ans[y][x] == 0 ) {\n        next = ii(x,y);\n        goto Skip2;\n      }\n      if( x == W-1 && y == H-1 ) next = ii(W-1,H-1);\n    }\n  Skip2:;\n\n    if( next != ii(-1,-1) && BackTracking(next.first,next.second) ) return true;\n    rep(y,h) rep(x,w) {\n      if( x == memo.first && y == memo.second ) goto Skip3;\n      ans[cy+y][cx+x] = 0;\n    }\n  Skip3:;\n  }\n  return false;\n}\n\ninline void compute(){\n  makeEdge();\n  rep(i,H) rep(j,W) ans[i][j] = 0;\n  found = 0;\n  if( !BackTracking(0,0) && found == 1 ) {\n    rep(i,H) { \n      rep(j,W) {\n        if( j ) cout << \" \";\n        cout << buf[i][j]; \n      } \n      cout << endl; \n    }\n  } else puts(\"NA\");\n  rep(i,H) rep(j,W) edge[i][j].clear();\n}\n\nint main(){\n  while( cin >> W >> H >> n, W|H|n ){\n    int sum = 0;\n    rep(i,n) {\n      cin >> b[i] >> k[i];\n      sum += k[i];\n    }\n    rep(i,H) rep(j,W) cin >> s[i][j];\n    if( sum != H*W ) { puts(\"NA\"); continue; }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nint w, h, n;\nint T[SIZE][SIZE];\nint TC[SIZE][SIZE];\nint K[SIZE]; \nII U[SIZE]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[SIZE][SIZE];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\n\tbool isAnswer(){\n\t\tREP(y,Y)REP(x,X) if(board[y][x]==0)return false;\n\t\treturn true;\n\t}\n\n\tbool canset(int yl,int xl,int h,int w){\n\t\tFOR(y,yl,yl+h)FOR(x,xl,xl+w)if(board[y][x]!=0)return false; \n\t\treturn true;\n\t}\n\tvoid set(int yl,int xl,int h,int w,int v){\n\t\tFOR(y,yl,yl+h)FOR(x,xl,xl+w)board[y][x]=v;\n\t}\n\n\tint dfs(int i){\n\t\tif(i==N){\n\t\t\tif(isAnswer()){\n\t\t\t\tres=board;\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tint res=0;\n\t\tfor(int w=1;w<=X;w++)if(as[i]%w==0){\n\t\t\tint h=as[i]/w;\n\n\t\t\tfor(int y=ys[i]-h+1;y<=ys[i]+1;y++)for(int x=xs[i]-w+1;x<=xs[i]+1;x++)\n\t\t\t\tif((0<=x && x+w<=X) && (0<=y && y+h<=Y)){\n\t\t\t\t\tboard[ys[i]][xs[i]]=0;\t\n\t\t\t\t\tif(canset(y,x,h,w)){\n\t\t\t\t\t\tset(y,x,h,w,i+1);\n\t\t\t\t\t\tres+=dfs(i+1);\n\t\t\t\t\t\tset(y,x,h,w,0);\n\t\t\t\t\t}\n\t\t\t\t\tboard[ys[i]][xs[i]]=i+1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint X,Y,N;\n\tvector<int> xs,ys;\n\tvector<int> xes,yes;\n\n\tvector<int> as;\n\tvector<vector<int>> board;vector<vector<int>> res;\n\t\n\tvoid run(){\n\t\twhile(true){\n\t\t\tcin >> X >> Y >> N;\n\t\t\tif(X==0)break;\t\n\t\t\tas=vector<int>(N);\n\t\t\tREP(i,N){\n\t\t\t\tint j,v;cin >> j >> v;j--;\n\t\t\t\tas[j]=v;\n\t\t\t}\n\t\t\txs=vector<int>(N);ys=vector<int>(N);\n\t\t\txes=vector<int>(N);yes=vector<int>(N);\n\n\t\t\tboard=vector<vector<int>>(Y,vector<int>(X));\n\t\t\tREP(y,Y)REP(x,X){\n\t\t\t\tcin >> board[y][x];\n\t\t\t\tif(board[y][x]!=0){\n\t\t\t\t\txs[board[y][x]-1]=x;ys[board[y][x]-1]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dfs(0)==1){\n\t\t\t\tcout << toString(res)<<endl;\n\t\t\t}else{\n\t\t\t\tcout <<\"NA\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nVV(pii) v(101);\nvvint vv;\nint x,y,n;\nvector<pair<int,pii>> in;\nvvint ans;\nint cnt;\nvoid foo(int a){\n\tif(a==n){\n\t\tcnt++;\n\t\tans=vv;\n\t\treturn;\n\t}\n\tint yy=in[a].S.F;\n\tint xx=in[a].S.S;\n\tint tt=in[a].F;\n\trep(i,v[tt].size()){\n\t\tint ty=v[tt][i].F;\n\t\tint tx=v[tt][i].S;\n\t\treep(j,yy-ty+1,yy+1){\n\t\t\treep(k,xx-tx+1,xx+1){\n\t\t\t\tif(j<0||j+ty-1>=y||k<0||k+tx-1>=x) continue;\n\t\t\t\tbool f=true;\n\t\t\t\treep(jj,j,j+ty){\n\t\t\t\t\treep(kk,k,k+tx){\n\t\t\t\t\t\tif(vv[jj][kk]!=0&&vv[jj][kk]!=a+1){\n\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\treep(jj,j,j+ty){\n\t\t\t\t\t\treep(kk,k,k+tx){\n\t\t\t\t\t\t\tvv[jj][kk]=a+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfoo(a+1);\n\t\t\t\t\treep(jj,j,j+ty){\n\t\t\t\t\t\treep(kk,k,k+tx){\n\t\t\t\t\t\t\tvv[jj][kk]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvv[yy][xx]=a+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid mainmain(){\n\treep(i,1,11){\n\t\treep(j,1,11){\n\t\t\tv[i*j].PB(pii(i,j));\n\t\t\tv[i*j].PB(pii(j,i));\n\t\t}\n\t}\n\trep(i,101){\n\t\tsort(ALL(v[i]));\n\t\tv[i].erase(unique(ALL(v[i])),v[i].end());\n\t}\n\twhile(cin>>x>>y>>n,x||y||n){\n\t\tin=vector<pair<int,pii>>(n);\n\t\tinitvv(vv,y,x);\n\t\trep(i,n){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tcin>>in[t-1].F;\n\t\t}\n\t\trep(i,y){\n\t\t\trep(j,x){\n\t\t\t\tcin>>vv[i][j];\n\t\t\t\tif(vv[i][j]!=0){\n\t\t\t\t\tin[vv[i][j]-1].S.F=i;\n\t\t\t\t\tin[vv[i][j]-1].S.S=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tfoo(0);\n\t\tif(cnt==1){\n\t\t\trep(i,ans.size()){\n\t\t\t\trep(j,ans[i].size()){\n\t\t\t\t\tif(j) cout<<\" \";\n\t\t\t\t\tcout<<ans[i][j];\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint W, H, N; \nint b[16], k[16];\nint s[10][10];\nint ans[10][10];\nint used[10][10];\nint TX[20], TY[20];\nclass DFSError {};\nvoid dfs(int idx){\n  if(idx == N) {\n    if(ans[0][0] != -1) throw DFSError();\n    REP(y, H)REP(x, W) ans[y][x] = used[y][x];\n    return;\n  }\n  /*\n  printf(\"idx = %d\\n\", idx);\n  REP(y, H){\n    REP(x, W){\n      cout << used[y][x];\n      if(x != W - 1) cout << \" \";\n      else cout << endl;\n    }\n  }\n  */\n  int tx = TX[b[idx] - 1];\n  int ty = TY[b[idx] - 1];\n  //printf(\"idx = %d tx = %d ty = %d\\n\", idx, tx, ty);\n   \n  assert(idx < N);\n  assert(b[idx] >= 1 && b[idx] <= N);\n  assert(tx != -1);\n  for(int h = 1; h <= k[idx]; h++) if(k[idx] % h == 0){\n    int w = k[idx] / h;\n    for(int by = 0; by > -h; by--) for(int bx = 0; bx > -w; bx--){\n      int sx = tx + bx;\n      int sy = ty + by;\n      bool ok = true;\n      for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n        if(!valid(sx + x, sy + y, W, H) || used[sy + y][sx + x] != -1) ok = false;\n      }\n      if(ok){\n        int tmp[10][10];\n        memcpy(tmp, used, sizeof(used));\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n          used[sy + y][sx + x] = b[idx];\n        }\n        dfs(idx + 1);\n        memcpy(used, tmp, sizeof(used));\n      }\n    }\n  }\n}\n \nint main(){\n  while(cin >> W >> H >> N && (W | H | N)){\n    REP(i, N) cin >> b[i] >> k[i];\n    REP(y, H)REP(x, W) cin >> s[y][x];\n    try{\n      memset(used, -1, sizeof(used));\n      memset(ans, -1, sizeof(ans));\n      memset(TX, -1, sizeof(TX));\n      memset(TY, -1, sizeof(TY));\n      REP(y, H) REP(x, W) if(s[y][x] > 0) TX[s[y][x] - 1] = x, TY[s[y][x] - 1] = y;\n      REP(i, N)if(TX[i] == -1){\n        /*\n        cerr << W << \" \" << H << \" \" << N << endl;\n        REP(j, N) cerr << b[j] << \" \" << k[j] << endl;\n        REP(y, H) { REP(x, W) cerr << s[y][x] << \" \"; cerr << endl; }\n        assert(\"bord is dissapeared\" == \"\");\n        */\n        throw 0;\n      }\n      dfs(0);\n      if(ans[0][0] == -1) throw DFSError();\n      REP(y, H){\n        REP(x, W){\n          cout << ans[y][x];\n          if(x != W - 1) cout << \" \";\n          else cout << endl;\n        }\n      }\n    }catch(...){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint X, Y, n;\nint area[16];\nint used[10][10];\nint ok[10][10];\nint app[10][10];\nint T[16];\n\nint cnt;\n\nbool check(int sy, int sx, int ey, int ex, int k)\n{\n\tint t = T[k];\n\tfor (int i = sy; i < ey; i++){\n\t\tfor (int j = sx; j < ex; j++){\n\t\t\tif (used[i][j] != 0) return false;\n\t\t\tif (app[i][j] != 0 && app[i][j] != k) return false;\n\t\t\tif (app[i][j] == k) t--;\n\t\t}\n\t}\n\treturn t == 0;\n}\n\nvoid Fill(int sy, int sx, int ey, int ex, int k)\n{\n\t//if (k) printf(\"%d %d %d %d %d\\n\", k, sy, sx, ey, ex);\n\t\n\tfor (int i = sy; i < ey; i++){\n\t\tfor (int j = sx; j < ex; j++){\n\t\t\tused[i][j] = k;\n\t\t}\n\t}\n}\n\nvoid search(int k)\n{\n\tif (k > n){\n\t\tcnt++;\n\t\tmemcpy((int*)ok, (int*)used, sizeof(ok));\n\t\t\n\t\t/*for (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tprintf(\"%d \", ok[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t\t\n\t\treturn;\n\t}\n\tfor (int i = 0; i < Y; i++){\n\t\tfor (int j = 0; j < X; j++){\n\t\t\tfor (int h = 1; i + h <= Y; h++){\n\t\t\t\tfor (int w = 1; j + w <= X; w++){\n\t\t\t\t\tif (area[k] != h * w) continue;\n\t\t\t\t\tif (!check(i, j, i + h, j + w, k)) continue;\n\t\t\t\t\tFill(i, j, i + h, j + w, k);\n\t\t\t\t\tsearch(k + 1);\n\t\t\t\t\tFill(i, j, i + h, j + w, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tcnt = 0;\n\tsearch(1);\n\tif (cnt != 1) puts(\"NA\");\n\telse {\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tif (j) printf(\" \");\n\t\t\t\tprintf(\"%d\", ok[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d %d\", &X, &Y, &n), X){\n\t\tmemset(T, 0, sizeof(T));\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint b, k;\n\t\t\tscanf(\"%d %d\", &b, &k);\n\t\t\tarea[b] = k;\n\t\t}\n\t\tfor (int i = 0; i < Y; i++){\n\t\t\tfor (int j = 0; j < X; j++){\n\t\t\t\tscanf(\"%d\", &app[i][j]);\n\t\t\t\tT[app[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\nint R, C, N;\nint size[20];\nint table[12][12];\n\nint ans[12][12];\nint ans_num;\n\nvoid dfs(int depth) {\n//       REP(r, R) {\n//         cout << table[r][0];\n//         for(int c = 1; c < C; c++) cout << ' ' << table[r][c];\n//         cout << endl;\n//       }\n//       cout << endl;\n  \n  if( depth > N ) {\n    bool same = true;\n    REP(r, R) REP(c, C) if( ans[r][c] != table[r][c] ) same = false;\n    if( !same ) {\n      ans_num++;\n      REP(r, R) REP(c, C) ans[r][c] = table[r][c];\n    }\n    return;\n  }\n  if( ans_num >= 2 ) return;\n  if( size[depth] == 0 )\n    dfs(depth + 1);\n  else {\n    int r, c;\n    REP(i, R) REP(j, C) if( table[i][j] == depth ) {\n      r = i;\n      c = j;\n    }\n    \n    table[r][c] = 0;\n    for(int r1 = 0; r1 <= r; r1++)\n      for(int r2 = r; r2 < R; r2++)\n        if( size[depth] % (r2 - r1 + 1) == 0 )\n          for(int c1 = 0; c1 <= c; c1++)\n            for(int c2 = c; c2 < C; c2++)\n              if( (r2 - r1 + 1) * (c2 - c1 + 1) == size[depth] ) {\n\n                \n                bool go = true;\n                for(int i = r1; i <= r2; i++)\n                  for(int j = c1; j <= c2; j++)\n                    if( table[i][j] != 0 )\n                      go = false;\n                \n                if( go ) {\n                  for(int i = r1; i <= r2; i++)\n                    for(int j = c1; j <= c2; j++)\n                      table[i][j] = depth;\n                  \n                  dfs(depth + 1);\n                  \n                  for(int i = r1; i <= r2; i++)\n                    for(int j = c1; j <= c2; j++)\n                      table[i][j] = 0;\n                }\n              }\n    table[r][c] = depth;\n  }\n}\n\nint main() {\n  for(;;) {\n    cin >> C >> R >> N;\n    if( C == 0 && R == 0 && N == 0 ) break;\n    REP(i, N) {\n      int x, c; cin >> x >> c;\n      size[x] = c;\n    }\n    REP(r, R) REP(c, C) {\n      int v; cin >> v; table[r][c] = v;\n    }\n\n    ans_num = 0;\n    dfs(1);\n    if( ans_num == 1 ) {\n      REP(r, R) {\n        cout << ans[r][0];\n        for(int c = 1; c < C; c++) cout << ' ' << ans[r][c];\n        cout << endl;\n      }\n    }else\n      cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint W, H, N; \nint b[16], k[16];\nint s[10][10];\nint ans[10][10];\nint used[10][10];\nint TX[20], TY[20];\nclass DFSError {};\nvoid dfs(int idx){\n  if(idx == N) {\n    if(ans[0][0] != -1) throw DFSError();\n    REP(y, H)REP(x, W) ans[y][x] = used[y][x];\n    return;\n  }\n  /*\n  printf(\"idx = %d\\n\", idx);\n  REP(y, H){\n    REP(x, W){\n      cout << used[y][x];\n      if(x != W - 1) cout << \" \";\n      else cout << endl;\n    }\n  }\n  */\n  int tx = TX[b[idx]];\n  int ty = TY[b[idx]];\n  //printf(\"idx = %d tx = %d ty = %d\\n\", idx, tx, ty);\n  \n  assert(idx < N);\n  assert(b[idx] >= 1 && b[idx] <= N);\n  assert(tx != -1);\n  for(int h = 1; h <= k[idx]; h++) if(k[idx] % h == 0){\n    int w = k[idx] / h;\n    for(int by = 0; by > -h; by--) for(int bx = 0; bx > -w; bx--){\n      int sx = tx + bx;\n      int sy = ty + by;\n      bool ok = true;\n      for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n        if(!valid(sx + x, sy + y, W, H) || used[sy + y][sx + x] != -1) ok = false;\n      }\n      if(ok){\n        int tmp[10][10];\n        memcpy(tmp, used, sizeof(used));\n        for(int y = 0; y < h; y++) for(int x = 0; x < w; x++) {\n          used[sy + y][sx + x] = b[idx];\n        }\n        dfs(idx + 1);\n        memcpy(used, tmp, sizeof(used));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H >> N && W){\n    REP(i, N) cin >> b[i] >> k[i];\n    REP(y, H)REP(x, W) cin >> s[y][x];\n    try{\n      memset(used, -1, sizeof(used));\n      memset(ans, -1, sizeof(ans));\n      memset(TX, -1, sizeof(TX));\n      memset(TY, -1, sizeof(TY));\n      REP(y, H) REP(x, W) if(s[y][x] > 0) TX[s[y][x]] = x, TY[s[y][x]] = y;\n      dfs(0);\n      if(ans[0][0] == -1) throw DFSError();\n      REP(y, H){\n        REP(x, W){\n          cout << ans[y][x];\n          if(x != W - 1) cout << \" \";\n          else cout << endl;\n        }\n      }\n    }catch(...){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Subdivide The Land\n//Level: 3\n//Category: 探索\n//Note:\n\n/**\n * パズル「四角に切れ」と同じ問題設定なので、おそらくNP完全である。\n * したがって、効率のよい探索を考える。\n *\n * 全てのマスがどれかの長方形に属していることより、盤面を左上から走査していき、どの番号の長方形に属すかを探索していけばよい。\n * こうすることで、そのマスを左上とした長方形に決め打つことができる。\n * 各番号では、その面積を与える長方形を全て試す。\n */\n#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\n\ntypedef bitset<15> State;\n\nstruct Rect {\n    int r, c, h, w;\n\n    //Rect() : r(0), c(0), h(0), w(0) {}\n    Rect() {}\n    Rect(int r, int c, int h, int w) : r(r), c(c), h(h), w(w) {}\n\n    bool intersect(const Rect &other) const {\n        return (r < other.r+other.h) && (other.r < r+h) && (c < other.c+other.w) && (other.c < c+w);\n    }\n};\n\narray<array<int,16>,16> field;\nvector<Rect> ans;\nvector<int> area_of;\nint N, W, H;\n\nvoid dfs(int r, int c, State &state, vector<Rect> &cur) {\n    //cout << r << ' ' << c << endl;\n    if(r == H) {\n        if(ans.size() != 0) throw \"Multiple answer\";\n        ans = cur;\n    } else if(c == W) {\n        dfs(r+1, 0, state, cur);\n    } else {\n        bool conquered = false;\n        for(int i = 0; i < N; ++i) {\n            //if(!state[i]) continue;\n            if(cur[i].intersect(Rect(r, c, 1, 1))) {\n                conquered = true;\n                break;\n            }\n        }\n        if(conquered) {\n            dfs(r, c+1, state, cur);\n            return;\n        }\n        for(int b = 0; b < N; ++b) {\n            if(state[b]) continue;\n            const int area = area_of[b];\n            for(int w = 1; w <= area; ++w) {\n                if(area % w != 0) continue;\n                const int h = area / w;\n                const Rect cand(r, c, h, w);\n                bool has_b = false;\n                // Check: it is in field\n                if(r+h > H || c+w > W) goto next;\n                // Check: it contains tag b and it is only tag\n                for(int dr = 0; dr < h; ++dr) {\n                    for(int dc = 0; dc < w; ++dc) {\n                        if(field[r+dr][c+dc] != 0 && field[r+dr][c+dc] != b+1) goto next;\n                        if(field[r+dr][c+dc] == b+1) has_b = true;\n                    }\n                }\n                if(!has_b) goto next;\n                // Check: it doesn't intersect with other rects\n                for(int i = 0; i < N; ++i) {\n                    if(cand.intersect(cur[i])) goto next;\n                }\n                cur[b] = cand;\n                state[b] = true;\n                dfs(r, c+1, state, cur);\n                state[b] = false;\nnext:\n                ;\n            }\n        }\n    }\n}\n\nbool solve() {\n    cin >> W >> H >> N;\n    if(!W && !H && !N) return false;\n    area_of.clear();\n    area_of.resize(N, 0);\n    int area_sum = 0;\n    for(int i = 0; i < N; ++i) {\n        int b, k;\n        cin >> b >> k;\n        area_of[b-1] = k;\n        area_sum += k;\n    }\n    for(int r = 0; r < H; ++r) {\n        for(int c = 0; c < W; ++c) {\n            cin >> field[r][c];\n        }\n    }\n    try {\n        if(area_sum != W*H) {\n            throw \"Inconsistent input\";\n        }\n        State state;\n        vector<Rect> cur(N);\n        ans.clear();\n        dfs(0, 0, state, cur);\n        if(ans.size() == 0) {\n            throw \"No solution\";\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int dr = 0; dr < ans[i].h; ++dr) {\n                for(int dc = 0; dc < ans[i].w; ++dc) {\n                    field[ans[i].r+dr][ans[i].c+dc] = i+1;\n                }\n            }\n        }\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(c != 0) cout << \" \";\n                cout << field[r][c];\n            }\n            cout << endl;\n        }\n    } catch(const char *msg) {\n        //cout << msg << endl;\n        cout << \"NA\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 11;\nint w, h, n;\nint T[SIZE][SIZE];\nint TC[SIZE][SIZE];\nint K[SIZE]; \nII U[SIZE]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[SIZE][SIZE];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n        \n        if ( cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint w, h, n;\nint space[100];\nint iniField[20][20];\nint field[110][20][20];\nint ansField[20][20];\nint used[20];\n\nvoid PrintField(int field[20][20]) {\n  REP(y, h) {\n    REP(x, w) {\n      if (x != 0) { putchar(' '); }\n      printf(\"%d\", field[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\nint calc(int x, int y) {\n  int depth = y * w + x;\n  int ndepth = depth + 1;\n  if (y == h) {\n    memcpy(ansField, field[depth], sizeof(field[depth]));\n    return 1;\n  }\n  if (x == w) { return calc(0, y + 1); }\n  if (field[depth][y][x] != -1) {\n    memcpy(field[ndepth], field[depth], sizeof(field[depth]));\n    return calc(x + 1, y);\n  }\n  int ret = 0;\n  REP(i, n) {\n    if (used[i]) { continue; }\n    used[i] = i;\n    FOREQ(hh, 1, space[i]) {\n      memcpy(field[ndepth], field[depth], sizeof(field[depth]));\n      int ww = space[i] / hh;\n      bool exist = false;\n      if (hh * ww != space[i]) { continue; }\n      REP(yy, hh) {\n        REP(xx, ww) {\n          if (field[ndepth][yy + y][xx + x] != -1 ||\n              (iniField[yy + y][xx + x] != 0 &&\n               iniField[yy + y][xx + x] != i + 1)) { goto next; }\n          exist |= iniField[yy + y][xx + x] == i + 1;\n          field[ndepth][yy + y][xx + x] = i + 1;\n        }\n      }\n      if (!exist) { goto next; }\n      ret += calc(x + 1, y);\n      if (ret >= 2) { return ret; }\nnext:;\n    }\n    used[i] = 0;\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &w, &h, &n), w|h|n) {\n    MEMSET(used, 0);\n    MEMSET(iniField, 0x0f);\n    REP(i, n) {\n      int f, v;\n      scanf(\"%d %d\", &f, &v);\n      space[f - 1] = v;\n    }\n    REP(y, h) {\n      REP(x, w) {\n        scanf(\"%d\", &iniField[y][x]);\n      }\n    }\n    MEMSET(field, -1);\n    if (calc(0, 0) == 1) {\n      PrintField(ansField);\n    } else {\n      puts(\"NA\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-8;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nint w, h, n;\npint info[16];\nint land[10][10], ans_land[10][10];\npint sign_pos[16];\n\nbool can_put(int left, int top, int width, int height, int b)\n{\n\tint right = left + width - 1;\n\tint bottom = top + height - 1;\n\tif (left < 0 || top < 0 || right >= w || bottom >= h)\n\t\treturn false;\n\n\tfor (int y = top; y <= bottom; ++y)\n\t\tfor (int x = left; x <= right; ++x)\n\t\t\tif (land[y][x] != 0 && land[y][x] != b)\n\t\t\t\treturn false;\n\treturn true;\n}\nvoid put(int left, int top, int width, int height, int b)\n{\n\tint right = left + width - 1;\n\tint bottom = top + height - 1;\n\n\tfor (int y = top; y <= bottom; ++y)\n\t\tfor (int x = left; x <= right; ++x)\n\t\t\tland[y][x] = b;\n}\nbool ok()\n{\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tif (land[y][x] == 0)\n\t\t\t\treturn false;\n\treturn true;\n}\nint dfs(int depth)\n{\n\tif (depth == n)\n\t{\n\t\tif (ok())\n\t\t{\n\t\t\tmemcpy(ans_land, land, sizeof(ans_land));\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tint res = 0;\n\n\tint b = info[depth].first;\n\tint k = info[depth].second;\n\tint sx = sign_pos[b].first;\n\tint sy = sign_pos[b].second;\n\tfor (int height = 1; height <= k; ++height)\n\t{\n\t\tif (k % height)\n\t\t\tcontinue;\n\t\tint width = k / height;\n\t\tfor (int y = sy - height-1; y <= sy; ++y)\n\t\t{\n\t\t\tfor (int x = sx - width-1; x <= sx; ++x)\n\t\t\t{\n\t\t\t\tif (can_put(x, y, width, height, b))\n\t\t\t\t{\n\t\t\t\t\tput(x, y, width, height, b);\n\t\t\t\t\tres += dfs(depth + 1);\n\t\t\t\t\tput(x, y, width, height, 0);\n\t\t\t\t\tland[sy][sx] = b;\n\n\t\t\t\t\tif (res > 1)\n\t\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\nint main()\n{\n\twhile (scanf(\"%d%d%d\", &w, &h, &n), w|h|n)\n\t{\n\t\tmemset(info, 0, sizeof(info));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint b, k;\n\t\t\tscanf(\"%d%d\", &b, &k);\n\t\t\tinfo[i] = pint(b, k);\n\t\t}\n\t\tsort(info, info+n, greater<pint>());\n\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tscanf(\"%d\", &land[y][x]);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tif (land[y][x])\n\t\t\t\t\tsign_pos[land[y][x]] = pint(x, y);\n\n\t\tif (dfs(0) == 1)\n\t\t{\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w-1; ++x)\n\t\t\t\t\tprintf(\"%d \", ans_land[y][x]);\n\t\t\t\tprintf(\"%d\\n\", ans_land[y][w-1]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tvector<pii>\t\tvpii;\n\nvector<vpii> rect;\nint w,h,n,land[10][10],test[10][10],ans[10][10];\n\nbool search(int i0,int j0){\n\tfor(int i=i0;i<h;i++){\n\t\tfor(int j=(i==i0?j0:0);j<w;j++){\n\t\t\tint id=land[i][j];\n\t\t\tif(id==0)\tcontinue;\n\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<rect[id].size();k++){\n\t\t\t\tint rh=rect[id][k].first,rw=rect[id][k].second;\n\t\t\t\tfor(int y=i-rh+1;y<=i;y++){\n\t\t\t\t\tfor(int x=j-rw+1;x<=j;x++){\n\t\t\t\t\t\tif(!(0<=y && y+rh<=h && 0<=x && x+rw<=w))\tcontinue;\n\t\t\t\t\t\tbool canput=true;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++){\n\t\t\t\t\t\t\tif(test[yy][xx]!=0)\tcanput=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!canput)\tcontinue;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++)test[yy][xx]=id;\n\t\t\t\t\t\tcnt+=search(i,j+1);\n\t\t\t\t\t\tif(cnt>=2)\treturn false;\n\t\t\t\t\t\tfor(int yy=y;yy<y+rh;yy++)for(int xx=x;xx<x+rw;xx++)test[yy][xx]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (cnt==1)?true:false;\n\t\t}\n\t}\n\n\tbool suc=true;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\tif(test[i][j]==0)\tsuc=false;\n\t}\n\tif(suc){\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tans[i][j]=test[i][j];\n\t\t}\n\t\treturn true;\n\t}\n\telse\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&w,&h,&n),w;){\n\t\trect=vector<vpii>(n+1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint id,area;\n\t\t\tscanf(\"%d%d\",&id,&area);\n\t\t\tfor(int j=1;j<=area;j++){\n\t\t\t\tif(area%j==0)\trect[id].pb(mp(j,area/j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tscanf(\"%d\",&land[i][j]);\n\n\t\tif(search(0,0)){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++)\tprintf(\"%s%d\",(j?\" \":\"\"),ans[i][j]);\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair< pair<int,int>,pair<int,int> > NODE;\n#define NY first.first\n#define NX first.second\n#define SY second.first\n#define SX second.second\n\nint X,Y,n,ret;\nvector< vector<int> > solve;\nmap<int,vector<NODE> > able;\nvector< vector<int> > data(20,vector<int>(20));\nvector< vector<int> > none(20,vector<int>(20));\nvector< vector<int> > rec(20,vector<int>(20));\n\nvoid bt(int dp){\n\tif(ret>1)return;\n\tvector<vector<int> > tt = rec;\n\tbool flag;\n\tif(dp==n){\n\t\tflag = true;\n\t\trep(i,Y)rep(j,X)if(!rec[i][j])flag = false;\n\t\tif(flag){\n\t\t\tret++;\n\t\t\tsolve = rec;\n\t\t}\n\t\treturn;\n\t}\n\tmap<int,vector<NODE> >::iterator it = able.begin();\n\tfor(int i=0;i<dp && it != able.end();i++)it++;\n\tfor(int i=0;i<(*it).second.size();i++){\n\t\tflag = true;\n\t\trep(y,(*it).second[i].SY)rep(x,(*it).second[i].SX){\n\t\t\tif(rec[(*it).second[i].NY+y][(*it).second[i].NX+x])flag = false;\n\t\t\trec[(*it).second[i].NY+y][(*it).second[i].NX+x]=(*it).first;\n\t\t}\n\t\tif(flag)bt(dp+1);\n\t\trec = tt;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tmap<int,int> buy;\n\t\n\tint b,k;\n\tint name,cnt;\n\tpair<int,int> coord;\n\twhile(cin >> X >> Y >> n , X){\n\t\tret = 0;/*\trep(i,Y){\n\t\trep(j,X)cout << rec[i][j];\n\t\tcout << endl;\n\t}\n*/\n\t\table.clear();\n\t\tbuy.clear();\n\t\trep(i,Y)rep(j,X)data[i][j]=0;\n\t\trep(i,n){\n\t\t\tcin >> b >> k;\n\t\t\tbuy[b] = k;\n\t\t}\n\t\trep(i,Y)rep(j,X)cin >> data[i][j];\n\n\t\trep(i,Y)rep(j,X){\n\t\t\trep(y,Y)rep(x,X){\n\t\t\t\tif( j+x > X-1 || i+y > Y-1 )continue;\n\t\t\t\tcnt = 0;\n\t\t\t\trep(YY,i+1)rep(XX,j+1)\n\t\t\t\t\tif(data[y+YY][x+XX]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tname = data[y+YY][x+XX];\n\t\t\t\t\t\tcoord = make_pair(y,x);\n\t\t\t\t\t}\n\t\t\t\tif(cnt == 1 && (i+1)*(j+1) == buy[name] ){\n\t\t\t\t\table[name].push_back( make_pair(coord,make_pair(i+1,j+1)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tmap<int,vector<NODE> >::iterator it = able.begin();\n\t\twhile(it != able.end()){\n\t\t\tfor(int i=0;i<(*it).second.size();i++)\n\t\t\t\tcout << (*it).first << \"=\" << (*it).second[i].NX << \",\" << (*it).second[i].NY << \" -> \" << (*it).second[i].SX << \",\" << (*it).second[i].SY << endl;\n\t\t\t++it;\n\t\t}\n*/\n\t\trec = none;\n\t\tbt(0);\n\t\tif(ret==1){\n\t\t\trep(i,Y){\n\t\t\t\trep(j,X)cout << solve[i][j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 0\n\nint w,h,n;\nint field[16][16];\nint check[16][16],output[16][16];\nint ans;\nstruct state{\n\tint area,x,y;\n} memo[16];\n\nbool ok(int x, int y, int zx, int zy, int num){\n\trep(i,zy){\n\t\trep(j,zx){\n\t\t\tint tx = x + j;\n\t\t\tint ty = y + i;\n\t\t\tif( tx<0 || ty<0 || tx>=w || ty>=h || check[ty][tx]>0 )return false;\n\t\t\tif( field[ty][tx]!=0 && field[ty][tx]!=num )return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dfs(int cnt){\n#if DEB\n\tprintf(\"cnt:%d\\n\",cnt);\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tprintf(\"%d \",check[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\tputs(\"\");\n#endif\n\t\n\tif( cnt==n ){\n\t\tans++;\n\t\tif( ans>=2 ) return;\n\t\trep(i,h)rep(j,w)output[i][j]=check[i][j];\n\t\treturn;\n\t}\n\n\tfor(int i=1; i<=memo[cnt].area; i++){\n\t\tif( memo[cnt].area%i!=0 )continue;\n\t\tint j = memo[cnt].area / i;\n\t\tint si = memo[cnt].y - i + 1;\n\t\tint sj = memo[cnt].x - j + 1;\n\n#if DEB\n\t\tprintf(\"(i,j)=(%d,%d),  (si,sj)=(%d,%d)\\n\",i,j,si,sj);\n#endif\t\t\n\n\t\tfor(int ii=si; ii<=memo[cnt].y; ii++){\n\t\t\tif( ii<0 )continue;\n\t\t\tfor(int jj=sj; jj<=memo[cnt].x; jj++){\n\t\t\t\tif( jj<0 )continue;\n\t\t\t\tif( ok(jj, ii, j, i, cnt+1) ){\n#if DEB\n\t\t\t\t\tprintf(\"isok:: jj:%d , ii:%d, j:%d, i:%d\\n\",jj,ii,j,i);\n#endif \t\t\t\t\t\n\t\t\t\t\trep(k,i)rep(l,j)check[ii+k][jj+l]=cnt+1;\n\t\t\t\t\tdfs(cnt+1);\n\t\t\t\t\tif( ans>=2 ) return;\n\t\t\t\t\trep(k,i)rep(l,j)check[ii+k][jj+l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t\n\twhile(scanf(\"%d%d%d\",&w,&h,&n),w|h|n){\n\t\trep(i,16)rep(j,16)check[i][j]=output[i][j]=0;\n\t\tans = 0;\n\t\t\n\t\trep(i,n){\n\t\t\tint b,k; scanf(\"%d%d\",&b,&k);\n\t\t\tmemo[b-1].area = k;\n\t\t}\n\t\trep(i,h)rep(j,w)scanf(\"%d\",&field[i][j]);\n\t\trep(i,h)rep(j,w)if( field[i][j]>0 ){\n\t\t\tmemo[ field[i][j]-1 ].x = j;\n\t\t\tmemo[ field[i][j]-1 ].y = i;\n\t\t}\n\t\t\n\t\tdfs(0);\n\n\t\tif( ans==1 ){\n\t\t\trep(i,h){\n\t\t\t\trep(j,w){\n\t\t\t\t\tprintf(\"%d \",output[i][j]);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"NA\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nstruct P{\n\tint x, y;\n};\n\nint W, H, n;\nint made;\nint memo[16], res[15][15];\nP pos[16];\n\n//i番目を置くよー\nvoid rec(int map[15][15], int used, int x, int y){\n\tif(y == H){//できたよー\n\t\tmade++;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\tres[i][k] = map[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tif(map[y][x] != 0){\n\t\trec(map, used, (x+1)%W, (x+1)%W?y:y+1);\n\t}\n\n\tfor(int j=1;j<=n;j++){\n\t\tif(!(used >> j & 1)){\n\t\t\tfor(int width=1;width<=memo[j];width++){\n\t\t\t\tif(memo[j] % width != 0)continue;\n\n\t\t\t\tint height = memo[j] / width,\n\t\t\t\t\tx1 = x + width - 1,\n\t\t\t\t\ty1 = y + height - 1,\n\t\t\t\t\t_map[15][15];\n\t\t\t\tif(x <= pos[j].x && pos[j].x <= x1 &&\n\t\t\t\t\t y <= pos[j].y && pos[j].y <= y1 &&\n\t\t\t\t\t x1 < W && y1 < H){\n\t\t\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\t\t\tfor(int k=0;k<W;k++){\n\t\t\t\t\t\t\t_map[i][k] = map[i][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int i=0;i<height;i++){\n\t\t\t\t\t\tfor(int k=0;k<width;k++){\n\t\t\t\t\t\t\t_map[y+i][x+k] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trec(_map, used | (1 << j), (x+width)%W, (x+width)%W?y:y+1);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t}\n\n\treturn;\n}\n\nint main(){\n\twhile(std::cin >> W >> H >> n, W){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint index;\n\t\t\tstd::cin >> index;\n\t\t\tstd::cin >> memo[index];\n\t\t}\n\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tint v;\n\t\t\t\tstd::cin >> v;\n\t\t\t\tif(v != 0){\n\t\t\t\t\tpos[v] = {x, y};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint map[15][15];\n\t\tfor(int i=0;i<225;i++){\n\t\t\tmap[i/15][i%15] = 0;\n\t\t}\n\n\t\tmade = 0;\n\n\t\trec(map, 0, 0, 0);\n\n\t\tif(made == 1){\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tprintf(\"%d\", res[i][0]);\n\t\t\t\tfor(int j=1;j<W;j++){\n\t\t\t\t\tprintf(\" %d\", res[i][j]);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t}else{\n\t\t\tstd::cout << \"NA\" << std::endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nVVI T;\nVVI TC;\nint K[16]; \nII U[16]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    T = VVI( h, VI( w, 0 ) );\n    TC = VVI( h, VI( w, 0 ) );\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool canPut( int k, int r0, int c0, int w0, int h0 ) {\n    int r = U[k].first;\n    int c = U[k].second; \n    if ( ! ( r0 <= r && r <= r0 + h0 && c0 <= c && c <= c0 + w0 ) ) return false;\n    \n    if ( r0 + h0 - 1 >= h || c0 + w0 - 1 >= w ) return false;\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    return true;\n}\n\nvoid put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return;\n}\n\nvoid output2() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid solve( int depth ) {\n    if ( depth >= n ) {\n        cnt ++;\n        TC = T;\n        return;\n    }\n    if ( cnt >= 2 ) return;\n    \n    int r = U[depth].first;\n    int c = U[depth].second; \n    int Tcopy[11][11];\n    for ( int w0 = 1; w0 <= w; ++ w0 ) {\n        if ( K[depth] % w0 != 0 ) continue;\n        int h0 = K[depth] / w0;\n        for ( int r0 = max( 0, r - w0 ); r0 < min( h, r + w0 ); ++ r0 ) {\n            for ( int c0 = max( 0, c - h0 ); c0 < min( w, c + h0 ); ++ c0 ) {\n                if ( canPut( depth, r0, c0, w0, h0 ) ) {\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            Tcopy[r0+i][c0+j] = T[r0+i][c0+j];\n                        }\n                    }\n                    put( depth, r0, c0, w0, h0 );\n                    solve( depth + 1 );\n                    if ( cnt >= 2 ) return;\n                    for ( int i = 0; i < h0; ++ i ) {\n                        for ( int j = 0; j < w0; ++ j ) {\n                            T[r0+i][c0+j] = Tcopy[r0+i][c0+j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nqueue<pair<int, vector<vector<int> > > >Q;\nvector<vector<int>>X, P; int H, W, N, V1[20], V2[20];\npair<bool, vector<vector<int> > > hantei(vector<vector<int> >a1, int X1, int Y1, int H1, int W1, int N1) {\n\tbool OK = true; int G[30][30];\n\tfor (int i = 0; i < 900; i++)G[i / 30][i % 30] = 0;\n\tfor (int i = X1; i < X1 + H1; i++) {\n\t\tfor (int j = Y1; j < Y1 + W1; j++) {\n\t\t\tif (i >= H || j >= W) { OK = false; continue; }\n\t\t\tif (a1[i][j] != 0 || (X[i][j] != V1[N1] && X[i][j] >= 1))OK = false;\n\t\t\ta1[i][j] = V1[N1]; G[i][j] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (X[i][j] == V1[N1] && G[i][j] == 0)OK = false;\n\t\t}\n\t}\n\treturn make_pair(OK, a1);\n}\nint main() {\n\twhile (true) {\n\t\tX.clear(); P.clear(); H = 0; W = 0; N = 0;\n\t\tcin >> W >> H >> N; int D1 = 0; if (W == 0 && H == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; i++) { cin >> V1[i] >> V2[i]; D1 += V2[i]; }\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tvector<int>G, I; int a;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a; G.push_back(a); I.push_back(0);\n\t\t\t}\n\t\t\tX.push_back(G); P.push_back(I);\n\t\t}\n\t\tif (D1 != W*H) { cout << \"NA\" << endl; continue; }\n\t\tQ.push(make_pair(0, P)); vector<vector<int> >res; int cnt = 0;\n\t\twhile (!Q.empty()) {\n\t\t\tvector<vector<int>>K = Q.front().second;\n\t\t\tint L = Q.front().first; Q.pop();\n\t\t\tif (Q.size() >= 200) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\twhile (!Q.empty())Q.pop();\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tif (L == N) { cnt++; res = K; continue; }\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 1; k <= V2[L]; k++) {\n\t\t\t\t\t\tif (V2[L] % k != 0)continue;\n\t\t\t\t\t\tpair<bool, vector<vector<int> > >res1 = hantei(K, i, j, k, V2[L] / k, L);\n\t\t\t\t\t\tif (res1.first == true) {\n\t\t\t\t\t\t\tQ.push(make_pair(L + 1, res1.second));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cnt == 0 || cnt >= 2)cout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (j >= 1) { cout << ' '; }cout << res[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\tE:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\nusing namespace std;\n\nint X, Y, n;\nvector<vector<int>> s;\nvector<vector<int>> answer;\nvector<int> area;\n\n// id, 左上, 右下\nbool placeable(vector<vector<int>> field, int id, int y1, int x1, int y2, int x2) {\n    bool ok = false;\n    for(int i = y1; i <= y2; ++i) for(int j = x1; j <= x2; ++j) {\n        if(field[i][j] && field[i][j] != id) return false;\n        if(field[i][j] == id) ok = true;\n    }\n    return ok;\n}\nvector<vector<int>> place(vector<vector<int>> field, int id, int y1, int x1, int y2, int x2) {\n    for(int i = y1; i <= y2; ++i) for(int j = x1; j <= x2; ++j) field[i][j] = id;\n    return field;\n}\n\nbool in(int y, int x) {\n    return 0 <= y && y < Y && 0 <= x && x < X;\n}\n\nint dfs(vector<vector<int>> field, bitset<16> used) {\n    if(used.count() == n) {\n        answer = field;\n        return 1;\n    }\n\n    int y, x;\n    y = x = -1;\n    for(int i = 0; y == -1 && i < Y; ++i) for(int j = 0; x == -1 && j < X; ++j) if(!used[field[i][j]]) {\n        y = i;\n        x = j;\n    }\n\n    int result = 0;\n    for(int id = 1; id <= n; ++id) {\n        if(used[id]) continue;\n        if(field[y][x] && field[y][x] != id) continue;\n        int a = area[id];\n        for(int t = 0; t < a; ++t) {\n            int i = y + t;\n            int j = x + a / (t + 1) - 1;\n            if(!in(i, j)) continue;\n            if(!placeable(field, id, y, x, i, j)) continue;\n            result += dfs(place(field, id, y, x, i, j), used.set(id));\n            used.reset(id);\n        }\n    }\n    return result;\n}\n\nint main() {\n    while(cin >> X >> Y >> n, X | Y | n) {\n        area.clear();\n        area.resize(n + 1);\n        for(int i = 0; i < n; ++i) {\n            int b, k;\n            cin >> b >> k;\n            area[b] = k;\n        }\n        s.clear();\n        s.resize(Y, vector<int>(X));\n        for(auto& y: s) for(auto& x: y) cin >> x;\n\n        if(dfs(s, 0) == 1) {\n            for(int i = 0; i < Y; ++i) {\n                for(int j = 0; j < X; ++j) cout << (j ? \" \" : \"\") << answer[i][j];\n                cout << endl;\n            }\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair< pair<int,int>,pair<int,int> > NODE;\n#define NY first.first\n#define NX first.second\n#define SY second.first\n#define SX second.second\n\nint X,Y,n,ret;\nvector< vector<int> > solve;\nmap<int,vector<NODE> > able;\nvector< vector<int> > data(10,vector<int>(10));\nvector< vector<int> > none(10,vector<int>(10));\nvoid bt(int dp,vector<vector<int> > rec){\n\tvector<vector<int> > tt = rec;\n\tif(dp==n){\n\t\tbool flag = true;\n\t\trep(i,Y)rep(j,X)if(!rec[i][j])flag = false;\n\t\tif(flag){\n\t\t\tret++;\n\t\t\tsolve = rec;\n\t\t}\n\t\treturn;\n\t}\n\tmap<int,vector<NODE> >::iterator it = able.begin();\n\tfor(int i=0;i<dp;i++)it++;\n\t\n\tfor(int i=0;i<(*it).second.size();i++){\n\t\trep(y,(*it).second[i].SY)rep(x,(*it).second[i].SX){\n\t\t\trec[(*it).second[i].NY+y][(*it).second[i].NX+x]=(*it).first;\n\t\t}\n\t\tbt(dp+1,rec);\n\t\trec = tt;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tmap<int,int> buy;\n\t\n\tint b,k;\n\tint name,cnt;\n\tpair<int,int> coord;\n\twhile(cin >> X >> Y >> n , X){\n\t\tret = 0;/*\trep(i,Y){\n\t\trep(j,X)cout << rec[i][j];\n\t\tcout << endl;\n\t}\n*/\n\t\table.clear();\n\t\tbuy.clear();\n\t\trep(i,Y)rep(j,X)data[i][j]=0;\n\t\trep(i,n){\n\t\t\tcin >> b >> k;\n\t\t\tbuy[b] = k;\n\t\t}\n\t\trep(i,Y)rep(j,X)cin >> data[i][j];\n\n\t\trep(i,Y)rep(j,X){\n\t\t\trep(y,Y)rep(x,X){\n\t\t\t\tif( j+x > X-1 || i+y > Y-1 )continue;\n\t\t\t\tcnt = 0;\n\t\t\t\trep(YY,i+1)rep(XX,j+1)\n\t\t\t\t\tif(data[y+YY][x+XX]){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tname = data[y+YY][x+XX];\n\t\t\t\t\t\tcoord = make_pair(y,x);\n\t\t\t\t\t}\n\t\t\t\tif(cnt == 1 && (i+1)*(j+1) == buy[name] ){\n\t\t\t\t\table[name].push_back( make_pair(coord,make_pair(i+1,j+1)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tmap<int,vector<NODE> >::iterator it = able.begin();\n\t\twhile(it != able.end()){\n\t\t\tfor(int i=0;i<(*it).second.size();i++)\n\t\t\t\tcout << (*it).first << \"=\" << (*it).second[i].NX << \",\" << (*it).second[i].NY << \" -> \" << (*it).second[i].SX << \",\" << (*it).second[i].SY << endl;\n\t\t\t++it;\n\t\t}\n*/\n\t\tbt(0,none);\n\t\tif(ret==1){\n\t\t\trep(i,Y){\n\t\t\t\trep(j,X)cout << solve[i][j];\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n\nint X, Y, n;\nvector<int> v;\nvector<vector<int> > board;\nvector<vector<int> > ans;\nvector<vector<int> > out;\nint ok[10][10][10][10];\nbool use[16];\n\nint solve(int y, int x) {\n\tint res = 0;\n\tif(y >= Y) {\n\t\tout = ans;\n\t\treturn 1;\n\t}\n\tif(ans[y][x]) {\n\t\treturn solve(y+(x+1)/X, (x+1)%X);\n\t}\n\tfor(int i = y; i < Y; i++) {\n\t\tfor(int j = x; j < X; j++) {\n\t\t\tif(ok[y][x][i][j]) {\n\t\t\t\tuse[ok[y][x][i][j]] = true;\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = ok[y][x][i][j];\n\t\t\t\tres += solve(y+(x+1)/X, (x+1)%X);\n\t\t\t\tfor(int k = y; k <= i; k++)\n\t\t\t\t\tfor(int l = x; l <= j; l++)\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t\tuse[ok[y][x][i][j]] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> X >> Y >> n, X || Y || n) {\n\t\tv.clear(); board.clear(); ans.clear();\n\t\tv.resize(n+1);\n\t\tboard.resize(Y);\n\t\tans.resize(Y);\n\t\tfor(int i = 0; i < 10*10*10*10; i++)\n\t\t\tok[0][0][0][i] = 0;\n//\t\tfor(int i = 0; i < 16; i++)\n//\t\t\tuse[i] = false;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tv[b] = k;\n\t\t}\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tboard[i].resize(X);\n\t\t\tans[i].resize(X);\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++) {\n\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\tfor(int k = i; k < Y; k++) {\n\t\t\t\t\tfor(int l = j; l < X; l++) {\n\t\t\t\t\t\tfor(int m = 1; m < v.size(); m++) {\n\t\t\t\t\t\t\tif((k-i+1) * (l-j+1) == v[m]) {\n\t\t\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\t\t\tfor(int y = 0; y < Y && flg; y++) {\n\t\t\t\t\t\t\t\t\tfor(int x = 0; x < X && flg; x++) {\n\t\t\t\t\t\t\t\t\t\tif(i <= y && y <= k && j <= x && x <= l) {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] != 0 && board[y][x] != m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tif(board[y][x] == m)\n\t\t\t\t\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(flg)\n\t\t\t\t\t\t\t\t\tok[i][j][k][l] = m;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tres = solve(0,0);\n\t\tif(res == 1) {\n\t\t\tfor(int i = 0; i < out.size(); i++) {\n\t\t\t\tcout << out[i][0];\n\t\t\t\tfor(int j = 1; j < out[i].size(); j++) {\n\t\t\t\t\tcout << \" \" << out[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint w, h, n;\nint T[20][20];\nint TC[20][20];\nint K[20]; \nII U[20]; \nint cnt;\n\nvoid init() {\n    cnt = 0;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            T[i][j] = 0;\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << TC[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool put( int k, int r0, int c0, int w0, int h0 ) {\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            if ( r0+i >= h || c0+j >= w ) return false;\n            if ( T[r0+i][c0+j] != 0 ) return false;\n        }\n    }\n    for ( int i = 0; i < h0; ++ i ) {\n        for ( int j = 0; j < w0; ++ j ) {\n            T[r0+i][c0+j] = k + 1;\n        }\n    }\n    return true;\n}\n\nvoid solve( int k ) {\n    if ( k >= n ) {\n        cnt ++;\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                TC[i][j] = T[i][j];\n            }\n        }\n        return;\n    }\n    \n    int r = U[k].first;\n    int c = U[k].second; \n    int Tcopy[20][20];\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            Tcopy[i][j] = T[i][j];\n        }\n    }\n    for ( int r0 = 0; r0 < h; ++ r0 ) {\n        for ( int c0 = 0; c0 < w; ++ c0 ) {\n            for ( int w0 = 1; w0 <= w; ++ w0 ) {\n                for ( int h0 = 1; h0 <= h; ++ h0 ) {\n                    if ( w0 * h0 != K[k] ) continue;\n                    if ( r0 <= r && r < r0 + h0 && c0 <= c && c <= c0 + w0 ) {\n                        for ( int i = 0; i < h; ++ i ) {\n                            for ( int j = 0; j < w; ++ j ) {\n                                T[i][j] = Tcopy[i][j];\n                            }\n                        }\n                        if ( put( k, r0, c0, w0, h0 ) ) solve( k + 1 );\n                        if ( cnt >= 2 ) return;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < n; ++ i ) {\n        int b;\n        cin >> b;\n        b --;\n        cin >> K[b];\n    }\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            int s;\n            cin >> s;\n            if ( s > 0 ) {\n                -- s;\n                U[s] = II( i, j );\n            }\n        }\n    }\n}\n\nvoid output1() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << T[i][j];\n            if ( j + 1 < w ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    while ( cin >> w >> h >> n ) {\n        if ( w == 0 && h == 0 && n == 0 ) break;\n        init();\n        input();\n        solve( 0 );\n\n        if ( cnt == 0 || cnt > 1 ) {\n            cout << \"NA\" << endl;\n        } else {\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\nvector<vector<pii> > v;\nint tab[16][16];\nint m[16][16];\nint ans[16][16];\nint x, y, N;\n\nint search(int n) {\n\tif(n > N) {\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tans[i][j] = tab[i][j];\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\tint res = 0;\n\tint sx = -1, sy = -1;\n\tfor(int i = 0; i < y; i++) {\n\t\tfor(int j = 0; j < x; j++) {\n\t\t\tif(m[i][j] == n) {\n\t\t\t\t/*\n\t\t\t\tif(sx != -1 || sy != -1)\n\t\t\t\t\tabort();\n\t\t\t\t// */\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < v[n-1].size(); i++) {\n\t\tint wi, hi;\n\t\twi = v[n-1][i].second;\n\t\thi = v[n-1][i].first;\n\t\tfor(int by = 0; by < hi; by++) {\n\t\t\tfor(int bx = 0; bx < wi; bx++) {\n\t\t\t\tif(sy-by >= 0 && sx-bx >= 0 && sy-by + hi <= y && sx-bx + wi <= x) {\n\t\t\t\t\t/*\n\t\t\t\t\tcout << \"hoge:\" << n << endl;\n\t\t\t\t\tcout << \"i:\" << i << endl;\n\t\t\t\t\tcout << sy-by << \",\" << sx-bx << endl;\n\t\t\t\t\t// */\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\tif(tab[j][k] != 0 || (m[j][k] != 0 && m[j][k] != n)) {\n\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t//cout << sy << \",\" << sx << endl;\n\t\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\t\ttab[j][k] = n;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint tmp;\n\t\t\t\t\t\ttmp = search(n+1);\n\t\t\t\t\t\tres += tmp;\n\t\t\t\t\t\tfor(int j = sy-by; j < sy-by+hi && flg; j++) {\n\t\t\t\t\t\t\tfor(int k = sx-bx; k < sx-bx+wi && flg; k++) {\n\t\t\t\t\t\t\t\ttab[j][k] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << n << endl;\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> x >> y >> N, x || y || N) {\n\t\tv.clear();\n\t\tv.resize(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint b, k;\n\t\t\tcin >> b >> k;\n\t\t\tfor(int j = 1; j <= k; j++) {\n\t\t\t\tif(k % j == 0 && j <= y && k / j <= x) {\n\t\t\t\t\tv[b-1].push_back(pii(j,k/j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\t\tcout << v[i][j].first << \",\" << v[i][j].second << endl;\n\t\t\t} cout << endl;\n\t\t} cout << endl;\n\t\t// */\n\n\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tfor(int j = 0; j < 16; j++) {\n\t\t\t\ttab[i][j] = 0;\n\t\t\t\tm[i][j] = 0;\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tcin >> m[i][j];\n\t\t\t}\n\t\t}\n\n\t\tif(search(1) != 1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse {\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tcout << ans[i][0];\n\t\t\t\tfor(int j = 1; j < x; j++) {\n\t\t\t\t\tcout << \" \" << ans[i][j];\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "X,Y,n;k[16];s[10][10];sd[10][10];dd;sx[16],sy[16];bf[16];bn;E(bx,by,w,h){int y;for(;w--;)for(y=h;y--;)if(s[bx+w][by+y])return 0;return 1;}F(bx,by,w,h,b){int y;for(;w--;)for(y=h;y--;)s[bx+w][by+y]=b;}SB(bx,by,w,h,b){if(bx+w<=X&&by+h<=Y&&bx+w>sx[b]&&by+h>sy[b]&&E(bx,by,w,h)){F(bx,by,w,h,b);bf[b]=1;++bn==n?dd++&&main(puts(\"NA\")),memcpy(sd,s,sizeof(sd)):SP(bx,by+1);bn--;bf[b]=0;F(bx,by,w,h,0);}}SP(bx,by){int b,w,h;if(by==Y){by-=Y;if(++bx==X)return;}if(s[bx][by])SP(bx,by+1);elsefor(b=1;b<=n;b++)if(!bf[b]&&bx<=sx[b]&&by<=sy[b])for(w=1;h=k[b]/w,w<=h;w++)if(w*h==k[b]){SB(bx,by,w,h,b);w<h&&SB(bx,by,h,w,b);}}main(i,x,y){for(;scanf(\"%d%d%d\",&X,&Y,&n),X;){memset(bf,dd=bn=0,sizeof(bf));for(i=n;i--;k[x]=y)scanf(\"%d%d\",&x,&y);for(y=0;y<Y;y++)for(x=0;x<X;x++){s[x][y]=0;scanf(\"%d\",&i);if(i){sx[i]=x;sy[i]=y;}}SP(0,0);if(dd)for(y=0;y<Y;y++)for(x=0;x<X;x++)printf(\"%d%c\",sd[x][y],x<X-1?32:10);elseputs(\"NA\");}exit(0);}"
  },
  {
    "language": "C",
    "code": "// Aizu 0213: Subdivide The Land\n// 2017.9.24 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int id, x, y, k; } T;\nT tbl[16]; \nint X, Y, n;\nchar map[10][10];\nchar ans[10][10], cnt;\nint pair[101][5][2], plen[101];\n\nint cmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; }\n\nvoid mark(int c, int x, int y, int w, int h)\n{\n\tint yy;\n\tfor (yy = 0; yy < h; yy++) memset(map[y+yy]+x, c, w);\n}\n\nint check(int c, int x, int y, int w, int h)\n{\n\tint xx, yy;\n\tfor (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) \n\t\tif (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0;\n\treturn 1;\n}\n\nint combi(int i)\n{\n\tint x, y, x0, y0, id, x1, y1, h, w, j, k;\n\n\tif (i == n+1) {\n\t\tif (cnt) return 0;\n\t\tcnt = 1, memcpy(ans, map, sizeof(map));\n\t\treturn 1;\n\t}\n\tk = tbl[i].k;\n\tif (k == 1) return combi(i+1);\n\tx0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id;\n\n\tfor (j = 0; j < plen[k]; j++) {\n\t\tw = pair[k][j][0], h = pair[k][j][1];\n\t\tif (x0 >= 0) {\n\t\t\tx1 = x0 - w + 1, y1 = y0 - h + 1;\n\t\t\tif (x1 < 0) x1 = 0; if (y1 < 0) y1 = 0;\n\t\t\tfor (y = y1; y <= y0; y++) {\n\t\t\t\tif (y + h > Y) break;\n\t\t\t\tfor (x = x1; x <= x0; x++) {\n\t\t\t\t\tif (x + w > X) break;\n\t\t\t\t\tif (!check(id, x, y, w, h)) continue;\n\t\t\t\t\tmark(id, x, y, w, h);\n\t\t\t\t\tif (!combi(i+1)) return 0;\n\t\t\t\t\tmark(0, x, y, w, h);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (y = 0; y < Y; y++) {\n\t\t\t\tif (y + h > Y) break;\n\t\t\t\tfor (x = 0; x < X; x++) {\n\t\t\t\t\tif (x + w > X) break;\n\t\t\t\t\tif (!check(id, x, y, w, h)) continue;\n\t\t\t\t\tmark(id, x, y, w, h);\n\t\t\t\t\tif (!combi(i+1)) return 0;\n\t\t\t\t\tmark(0, x, y, w, h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main()\n{\n    int i, b, t, s, x, y, f;\n\n\tfor (x = 1; x <= 10; x++) for (y = 1; y <= 10; y++) {\n\t\tt = x * y;\n\t\tpair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y;\n\t}\n\n\twhile (scanf(\"%d%d%d\", &X, &Y, &n) && n > 0) {\n\t\tfor (s = f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &b, &t);\n\t\t\ttbl[b].k = t, tbl[b].id = b, tbl[b].x = tbl[b].y = -1;\n\t\t\ts += t; if (plen[t] == 0) f = 1;\n\t\t}\n\t\tfor (y = 0; y < Y; y++) for (x = 0; x < X; x++) {\n\t\t\tscanf(\"%d\", &b), map[y][x] = b;\n\t\t\tif (b > 0) tbl[b].x = x, tbl[b].y = y;\n\t\t}\n\t\tif (f || s != X*Y) { puts(\"NA\"); continue; }\n\t\tqsort(tbl+1, n, sizeof(T), cmp);\n\n\t\tcnt = 0;\n\t\tif (!combi(1)) puts(\"NA\");\n\t\telse for (y = 0; y < Y; y++) {\n\t\t\tprintf(\"%d\", ans[y][0]);\n\t\t\tfor (x = 1; x < X; x++) printf(\" %d\", ans[y][x]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0213: Subdivide The Land\n// 2017.9.24 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int id, x, y, k; } T;\nT tbl[16]; \nint X, Y, n;\nchar map[10][10];\nchar ans[10][10], cnt;\nint pair[101][13][2], plen[101];\n\nint cmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; }\n\nvoid mark(int c, int x, int y, int w, int h)\n{\n\tint yy;\n\tfor (yy = 0; yy < h; yy++) memset(map[y+yy]+x, c, w);\n}\n\nint check(int c, int x, int y, int w, int h)\n{\n\tint xx, yy;\n\tfor (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) \n\t\tif (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0;\n\treturn 1;\n}\n\nint combi(int i)\n{\n\tint x, y, x0, y0, id, x1, y1, h, w, j, k;\n\n\tif (i == n+1) {\n\t\tif (cnt) return 0;\n\t\tcnt = 1, memcpy(ans, map, sizeof(map));\n\t\treturn 1;\n\t}\n\tk = tbl[i].k;\n\tif (k == 1) return combi(i+1);\n\tx0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id;\n\n\tfor (j = 0; j < plen[k]; j++) {\n\t\tw = pair[k][j][0], h = pair[k][j][1];\n\t\tx1 = x0 - w + 1, y1 = y0 - h + 1;\n\t\tif (x1 < 0) x1 = 0; if (y1 < 0) y1 = 0;\n\t\tfor (y = y1; y <= y0; y++) for (x = x1; x <= x0; x++) {\n\t\t\tif (x + w > X || y + h > Y) goto Next;\n\t\t\tif (!check(id, x, y, w, h)) continue;\n\t\t\tmark(id, x, y, w, h);\n\t\t\tif (!combi(i+1)) return 0;\n\t\t\tmark(0, x, y, w, h);\n\t\t}\nNext:;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n    int i, b, t, s, x, y;\n\n\tfor (x = 1; x <= 100; x++) for (y = 1; y <= 100; y++)\n\t\tif ((t = x * y) <= 100) pair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y;\n\n\twhile (scanf(\"%d%d%d\", &X, &Y, &n) && n > 0) {\n\t\tfor (s = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &b, &t);\n\t\t\ttbl[b].k = t, tbl[b].id = b;\n\t\t\ts += t;\n\t\t}\n\t\tfor (y = 0; y < Y; y++) for (x = 0; x < X; x++) {\n\t\t\tscanf(\"%d\", &b), map[y][x] = b;\n\t\t\tif (b > 0) tbl[b].x = x, tbl[b].y = y;\n\t\t}\n\t\tif (s != X*Y) { puts(\"NA\"); continue; }\n\t\tqsort(tbl+1, n, sizeof(T), cmp);\n\n\t\tcnt = 0;\n\t\tif (!combi(1)) puts(\"NA\");\n\t\telse for (y = 0; y < Y; y++) {\n\t\t\tprintf(\"%d\", ans[y][0]);\n\t\t\tfor (x = 1; x < X; x++) printf(\" %d\", ans[y][x]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0213: Subdivide The Land\n// 2017.9.24 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define NOMARK 100\n\ntypedef struct { int id, x, y, k; } T;\nT tbl[16]; \nint X, Y, n;\nchar map[10][10];\nchar ans[10][10], cnt;\nint pair[101][5][2], plen[101];\n\nint cmp(T *a, T *b) { if (a->y - b->y) return a->y - b->y; return a->x - b->x; }\n\nvoid mark(int c, int x, int y, int w, int h)\n{\n\tint yy;\n\tfor (yy = 0; yy < h; yy++) memset(map[y+yy]+x, c, w);\n}\n\nint check(int c, int x, int y, int w, int h)\n{\n\tint xx, yy;\n\tfor (yy = 0; yy < h; yy++) for (xx = 0; xx < w; xx++) \n\t\tif (map[y+yy][x+xx] > 0 && map[y+yy][x+xx] != c) return 0;\n\treturn 1;\n}\n\nint combi(int i)\n{\n\tint x, y, x0, y0, id, x1, y1, h, w, j, k;\n\tchar tmp[10][10];\n\n\tif (i == n+1) {\n\t\tif (++cnt > 1) return 0;\n\t\tmemcpy(ans, map, sizeof(map));\n\t\treturn 1;\n\t}\n\tk = tbl[i].k;\n\tif (k == 1) return combi(i+1);\n\tx0 = tbl[i].x, y0 = tbl[i].y, id = tbl[i].id;\n\tfor (j = 0; j < plen[k]; j++) {\n\t\tw = pair[k][j][0], h = pair[k][j][1];\n\t\tif (x0 != NOMARK) {\n\t\t\tx1 = x0 - w + 1, y1 = y0 - h + 1;\n\t\t\tif (x1 < 0) x1 = 0; if (y1 < 0) y1 = 0;\n\t\t\tfor (y = y1; y <= y0 && y + h <= Y; y++) {\n\t\t\t\tfor (x = x1; x <= x0 && x + w <= X; x++) {\n\t\t\t\t\tif (!check(id, x, y, w, h)) continue;\n\t\t\t\t\tmemcpy(tmp, map, sizeof(tmp));\n\t\t\t\t\tmark(id, x, y, w, h);\n\t\t\t\t\tif (!combi(i+1)) return 0;\n\t\t\t\t\tmemcpy(map, tmp, sizeof(tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (y = 0; y + h <= Y; y++) {\n\t\t\t\tfor (x = 0; x + w <= X; x++) {\n\t\t\t\t\tif (!check(id, x, y, w, h)) continue;\n\t\t\t\t\tmemcpy(tmp, map, sizeof(tmp));\n\t\t\t\t\tmark(id, x, y, w, h);\n\t\t\t\t\tif (!combi(i+1)) return 0;\n\t\t\t\t\tmemcpy(map, tmp, sizeof(tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main()\n{\n    int i, b, t, s, x, y, f;\n\n\tfor (x = 1; x <= 10; x++) for (y = 1; y <= 10; y++) {\n\t\tt = x * y;\n\t\tpair[t][plen[t]][0] = x, pair[t][plen[t]++][1] = y;\n\t}\n\n\twhile (scanf(\"%d%d%d\", &X, &Y, &n) && n > 0) {\n\t\tfor (s = f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d\", &b, &t);\n\t\t\ttbl[b].k = t, tbl[b].id = b, tbl[b].x = tbl[b].y = NOMARK;\n\t\t\ts += t; if (plen[t] == 0) f = 1;\n\t\t}\n\t\tfor (y = 0; y < Y; y++) for (x = 0; x < X; x++) {\n\t\t\tscanf(\"%d\", &b), map[y][x] = b;\n\t\t\tif (b > 0) tbl[b].x = x, tbl[b].y = y;\n\t\t}\n\t\tif (f || s != X*Y) { puts(\"NA\"); continue; }\n\t\tqsort(tbl+1, n, sizeof(T), cmp);\n\n\t\tcnt = 0;\n\t\tcombi(1);\n\t\tif (cnt != 1) puts(\"NA\");\n\t\telse for (y = 0; y < Y; y++) {\n\t\t\tprintf(\"%d\", ans[y][0]);\n\t\t\tfor (x = 1; x < X; x++) printf(\" %d\", ans[y][x]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint x, y, n;\nint name[15], size[15];\nint ans, record[10][10];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid copy(int saki[][10], int moto[][10])\n{\n    int i, j;\n    \n    for (i = 0; i < y; i++){\n        for (j = 0; j < x; j++){\n            saki[i][j] = moto[i][j];\n        }\n    }\n}\n\nint canPlace(int w, int h, int sy, int sx, int now, int map[][10])\n{\n    int i, j;\n    int flag = 0;\n    \n    for (i = sy; i < sy + h; i++){\n        for (j = sx; j < sx + w; j++){\n            if (map[i][j] == name[now]){\n                flag = 1;\n            }\n            else if (map[i][j]){\n                return (0);\n            }\n        }\n    }\n    return (flag);\n}\n\nvoid place(int w, int h, int sy, int sx, int now, int map[][10])\n{\n    int i, j;\n    \n    for (i = sy; i < sy + h; i++){\n        for (j = sx; j < sx + w; j++){\n            map[i][j] = name[now];\n        }\n    }\n}\n\nint generateMap(int now, int map[][10])\n{\n    int i, j, k, t;\n    int my, mx;\n    int temp[10][10];\n    int check;\n    int w, h;\n    \n    \n    if (now == n){\n        copy(record, map);\n        ans++;\n        return (1);\n    }\n\n    check = 0;\n    for (t = 1; t <= size[now]; t++){\n        if (size[now] % t != 0){\n            continue;\n        }\n        w = size[now] / t;\n        h = t;\n        \n        for (i = 0; i <= y - h; i++){\n            for (j = 0; j <= x - w; j++){\n                if (canPlace(w, h, i, j, now, map)){\n                    copy(temp, map);\n                    place(w, h, i, j, now, temp);\n                    check |= generateMap(now + 1, temp);\n                }\n            }\n        }\n    }\n    \n    return (check);\n}\n\nint main(void)\n{\n    \n    int i, j;\n    int map[10][10];\n    \n    while (1){\n        scanf(\"%d%d%d\", &x, &y, &n);\n        \n        if (x + y + n == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%d%d\", &name[i], &size[i]);\n        }\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &map[i][j]);\n            }\n        }\n        \n        memset(record, 0, sizeof(record));\n        ans = 0;\n        \n        if (!generateMap(0, map) || ans != 1){\n            printf(\"NA\\n\");\n        }\n        else {\n            for (i = 0; i < y; i++){\n                for (j = 0; j < x; j++){\n                    printf(\"%d%c\", record[i][j], j == x - 1 ? '\\n' : ' ');\n                }\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "X,Y,n;k[16];s[10][10];sd[10][10];dd;sx[16],sy[16];bf[16];bn;E(bx,by,w,h){int y;for(;w--;)for(y=h;y--;)if(s[bx+w][by+y])return 0;return 1;}F(bx,by,w,h,b){int y;for(;w--;)for(y=h;y--;)s[bx+w][by+y]=b;}SB(bx,by,w,h,b){if(bx+w<=X&&by+h<=Y&&bx+w>sx[b]&&by+h>sy[b]&&E(bx,by,w,h)){F(bx,by,w,h,b);bf[b]=1;++bn==n?dd++&&main(puts(\"NA\")),memcpy(sd,s,sizeof(sd)):SP(bx,by+1);bn--;bf[b]=0;F(bx,by,w,h,0);}}SP(bx,by){int b,w,h;if(by==Y){by-=Y;if(++bx==X)return;}if(s[bx][by])SP(bx,by+1);else for(b=1;b<=n;b++)if(!bf[b]&&bx<=sx[b]&&by<=sy[b])for(w=1;h=k[b]/w,w<=h;w++)if(w*h==k[b]){SB(bx,by,w,h,b);w<h&&SB(bx,by,h,w,b);}}main(i,x,y){for(;scanf(\"%d%d%d\",&X,&Y,&n),X;){memset(bf,dd=bn=0,sizeof(bf));for(i=n;i--;k[x]=y)scanf(\"%d%d\",&x,&y);for(y=0;y<Y;y++)for(x=0;x<X;x++){s[x][y]=0;scanf(\"%d\",&i);if(i){sx[i]=x;sy[i]=y;}}SP(0,0);if(dd)for(y=0;y<Y;y++)for(x=0;x<X;x++)printf(\"%d%c\",sd[x][y],x<X-1?32:10);else puts(\"NA\");}exit(0);}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tmap = new int[h][w];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint s = scanner.nextInt();\n\t\t\t\t\tmap[i][j] = s;\n\t\t\t\t\tif (s > 0) {\n\t\t\t\t\t\tpos[s][0] = i;\n\t\t\t\t\t\tpos[s][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (count == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t\tSystem.out.print(j == w - 1 ? '\\n' : ' ');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tPriorityQueue<Point> pq = new PriorityQueue<Point>();\n\t\tpq.add(new Point(map, 1));\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPoint point = pq.poll();\n\t\t\tint[][] map = point.map;\n\t\t\tk = point.k;\n\t\t\tif (k == n + 1) {\n\t\t\t\tcount++;\n\t\t\t\tif (count == 2)\n\t\t\t\t\treturn;\n\t\t\t\tans = map;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s = size[k];\n\t\t\tfor (int r = 1; r <= s; r++) {\n\t\t\t\tif (s % r != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tint y = pos[k][0];\n\t\t\t\tint x = pos[k][1];\n\t\t\t\tfor (int ui = y + 1 - s / r; ui <= y; ui++) {\n\t\t\t\t\tif (ui < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tloop: for (int lj = x + 1 - r; lj <= x; lj++) {\n\t\t\t\t\t\tif (lj < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint di = ui + s / r;\n\t\t\t\t\t\tint rj = lj + r;\n\t\t\t\t\t\tif (di > h || rj > w)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int i = ui; i < di; i++) {\n\t\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\t\tif (map[i][j] != 0 && map[i][j] != k)\n\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint[][] tmp = new int[h][w];\n\t\t\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\t\t\ttmp[i] = Arrays.copyOf(map[i], w);\n\t\t\t\t\t\tfor (int i = ui; i < di; i++) {\n\t\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\t\tif (tmp[i][j] != k)\n\t\t\t\t\t\t\t\t\ttmp[i][j] = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpq.add(new Point(tmp, k + 1));\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tclass Point implements Comparable<Point> {\n\t\tint[][] map;\n\t\tint k;\n\n\t\tpublic Point(int[][] map, int k) {\n\t\t\tsuper();\n\t\t\tthis.map = map;\n\t\t\tthis.k = k;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn o.k - this.k;\n\t\t}\n\n\t}\n\n\tint count;\n\tint h, w, n;\n\tint[] size;\n\tint[][] map;\n\tint[][] pos;\n\tint[][] ans;\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport scala.languageFeature.postfixOps;\nimport sun.tools.jar.resources.jar;\nimport lombok.Data;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tm = new int[h][w];\n\t\t\t\n\t\t\tfor (int[] a : m)\n\t\t\t\tArrays.fill(a, -1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tm[i][j] = x;\n\t\t\t\t\tif (x > 0) {\n\t\t\t\t\t\tpos[x][0] = i;\n\t\t\t\t\t\tpos[x][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassign = new int[n + 1][4];\n\t\t\tc = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (c == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tif (k == n + 1) {\n\t\t\tc++;\n\t\t\tif (c == 2)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint a = m[i][j];\n\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = size[k];\n\t\tfor (int x = 1; x <= s; x++) {\n\t\t\tif (s % x != 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int lj = pos[k][1] + 1 - x; lj <= pos[k][1]; lj++) {\n\t\t\t\tif (lj < 0 || lj > w)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) {\n\t\t\t\t\tif (li < 0 || li > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint rj = lj + x;\n\t\t\t\t\tint ri = li + s / x;\n\t\t\t\t\tif (rj > w)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (ri > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != 0 && m[i][j] != k)\n\t\t\t\t\t\t\t\tcontinue loop;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = k * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\tif (c == 2)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint[][] m;\n\tint[] size;\n\tint[][] pos;\n\tint[][] assign;\n\tint w, h, n, c;\n\tint[][] ans;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Subdivide The Land\npublic class Main{\n\n\tstatic int[] size;\n\tstatic int[][] pos;\n\tstatic int[][] assign;\n\tstatic int w, h, n;\n\tstatic int c;\n\tstatic int[][] ans;\n\t\n\tstatic boolean col(int k1, int k2){\n\t\tif(assign[k2][0]<assign[k1][2]&&assign[k1][0]<assign[k2][2] && assign[k2][1]<assign[k1][3]&&assign[k1][1]<assign[k2][3])\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\t\n\tstatic void f(int k){\n\t\tif(k==n+1){\n\t\t\tc++;\n\t\t\tif(c==2)return;\n\t\t\tfor(int x=1;x<=n;x++){\n\t\t\t\tfor(int i=assign[x][0];i<assign[x][2];i++){\n\t\t\t\t\tfor(int j=assign[x][1];j<assign[x][3];j++){\n\t\t\t\t\t\tans[i][j] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(c>=2)return;\n\t\tint s = size[k];\n\t\tfor(int x=1;x<=s;x++){\n\t\t\tif(s%x!=0)continue;\n\t\t\tfor(int lj=pos[k][1]+1-x;lj<=pos[k][1];lj++){\n\t\t\t\tif(lj<0||lj>w)continue;\n\t\t\t\tfor(int li=pos[k][0]+1-s/x;li<=pos[k][0];li++){\n\t\t\t\t\tif(li<0||li>h)continue;\n\t\t\t\t\tint rj = lj+x;\n\t\t\t\t\tint ri = li+s/x;\n\t\t\t\t\tif(rj>w)continue;\n\t\t\t\t\tif(ri>h)continue;\n\t\t\t\t\tassign[k][0] = li;\n\t\t\t\t\tassign[k][1] = lj;\n\t\t\t\t\tassign[k][2] = ri;\n\t\t\t\t\tassign[k][3] = rj;\n\t\t\t\t\tboolean col = false;\n\t\t\t\t\tfor(int d=1;d<k;d++){\n\t\t\t\t\t\tif(col(d, k)){\n\t\t\t\t\t\t\tcol = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(col)continue;\n//\t\t\t\t\tSystem.out.println(\"ASSIGN: \" + k + \" (\"+li+\",\"+lj+\") (\"+ri+\",\"+rj+\")\");\n\t\t\t\t\tf(k+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif((w|h|n)==0)break;\n\t\t\tsize = new int[n+1];\n\t\t\tpos = new int[n+1][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tint[][] m = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tm[i][j] = x;\n\t\t\t\t\tif(x>0){\n\t\t\t\t\t\tpos[x][0] = i;\n\t\t\t\t\t\tpos[x][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassign = new int[n+1][4];\n\t\t\tc = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif(c!=1)System.out.println(\"NA\");\n\t\t\telse {\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(j>0)System.out.print(\" \");\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tm = new int[h][w];\n\t\t\t\n\t\t\tfor (int[] a : m)\n\t\t\t\tArrays.fill(a, -1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tm[i][j] = x;\n\t\t\t\t\tif (x > 0) {\n\t\t\t\t\t\tpos[x][0] = i;\n\t\t\t\t\t\tpos[x][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassign = new int[n + 1][4];\n\t\t\tc = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (c == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tif (k == n + 1) {\n\t\t\tc++;\n\t\t\tif (c == 2)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint a = m[i][j];\n\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = size[k];\n\t\tfor (int x = 1; x <= s; x++) {\n\t\t\tif (s % x != 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int lj = pos[k][1] + 1 - x; lj <= pos[k][1]; lj++) {\n\t\t\t\tif (lj < 0 || lj > w)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) {\n\t\t\t\t\tif (li < 0 || li > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint rj = lj + x;\n\t\t\t\t\tint ri = li + s / x;\n\t\t\t\t\tif (rj > w)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (ri > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != 0 && m[i][j] != k)\n\t\t\t\t\t\t\t\tcontinue loop;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = k * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\tif (c == 2)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint[][] m;\n\tint[] size;\n\tint[][] pos;\n\tint[][] assign;\n\tint w, h, n, c;\n\tint[][] ans;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tmap = new int[h][w];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint s = scanner.nextInt();\n\t\t\t\t\tmap[i][j] = s;\n\t\t\t\t\tif (s > 0) {\n\t\t\t\t\t\tpos[s][0] = i;\n\t\t\t\t\t\tpos[s][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (count == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t\tSystem.out.print(j == w - 1 ? '\\n' : ' ');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tif (k == n + 1) {\n\t\t\tcount++;\n\t\t\tif (count == 2)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint a = map[i][j];\n\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = size[k];\n\t\tfor (int r = 1; r <= s; r++) {\n\t\t\tif (s % r != 0)\n\t\t\t\tcontinue;\n\t\t\tint y = pos[k][0];\n\t\t\tint x = pos[k][1];\n\t\t\tfor (int ui = y + 1 - s / r; ui <= y; ui++) {\n\t\t\t\tif (ui < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int lj = x + 1 - r; lj <= x; lj++) {\n\t\t\t\t\tif (lj < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint di = ui + s / r;\n\t\t\t\t\tint rj = lj + r;\n\t\t\t\t\tif (di > h || rj > w)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int i = ui; i < di; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (map[i][j] != 0 && map[i][j] != k)\n\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = ui; i < di; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (map[i][j] != k)\n\t\t\t\t\t\t\t\tmap[i][j] = k * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\tif (count == 2)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tfor (int i = ui; i < di; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (map[i][j] != k)\n\t\t\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint count;\n\tint h, w, n;\n\tint[] size;\n\tint[][] map;\n\tint[][] pos;\n\tint[][] ans;\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport scala.languageFeature.postfixOps;\nimport sun.tools.jar.resources.jar;\nimport lombok.Data;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tm = new int[h][w];\n\t\t\t\n\t\t\tfor (int[] a : m)\n\t\t\t\tArrays.fill(a, -1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tm[i][j] = x;\n\t\t\t\t\tif (x > 0) {\n\t\t\t\t\t\tpos[x][0] = i;\n\t\t\t\t\t\tpos[x][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassign = new int[n + 1][4];\n\t\t\tc = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (c == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tif (k == n + 1) {\n\t\t\tc++;\n\t\t\tif (c == 2)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint a = m[i][j];\n\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = size[k];\n\t\tfor (int x = 1; x <= s; x++) {\n\t\t\tif (s % x != 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int lj = pos[k][1] + 1 - x; lj <= pos[k][1]; lj++) {\n\t\t\t\tif (lj < 0 || lj > w)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) {\n\t\t\t\t\tif (li < 0 || li > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint rj = lj + x;\n\t\t\t\t\tint ri = li + s / x;\n\t\t\t\t\tif (rj > w)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (ri > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != 0 && m[i][j] != k)\n\t\t\t\t\t\t\t\tcontinue loop;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = k * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\tif (c == 2)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint[][] m;\n\tint[] size;\n\tint[][] pos;\n\tint[][] assign;\n\tint w, h, n, c;\n\tint[][] ans;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.util.*;\npublic class Main {\n\t\n\tboolean [] used;\n\tboolean flg, dup;\n\tint n,w,h, deepsize;\n\tint [][] data, ans;\n\tint [] hash;\n\tC[][] cand;\n\tP [] point;\n\t\n\tclass C{\n\t\tHashSet<Integer> list;\n\n\t\tpublic C(HashSet<Integer> list) {\n\t\t\tthis.list = list;\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tint x,y;\n\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif((w|h|n) == 0) break;\n\t\t\thash = new int[n+1];\n\t\t\tdeepsize = n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\thash[b] = k;\n\t\t\t\tif(k == 1) deepsize--;\n\t\t\t}\n\t\t\tdata = new int[h][w];\n\t\t\tpoint = new P[n+1];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t\tif(data[i][j] > 0){\n\t\t\t\t\t\tpoint[data[i][j]] = new P(j, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tused = new boolean[n+1];\n\t\t\tflg = false;\n\t\t\tdup = true;\n\t\t\tans = new int[h][w];\n\t\t\tdfs(1);\n\t\t\tif(flg && dup){\n\t\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\tSystem.out.print(ans[i][j] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n + 1){\n\t\t\tif(flg){\n\t\t\t\tdup =false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tflg = true;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tans[i] = data[i].clone();\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t\tif(hash[deep] == 1){\n\t\t\tdfs(deep+1);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(data[i][j] != 0 && data[i][j] != deep) continue;\n\t\t\t\t\n\t\t\t\tfor(int k = i; k < h; k++){\n\t\t\t\t\tfor(int l = j; l < w; l++){\n\t\t\t\t\t\tint dis = calcdis(j, i, l, k);\n\t\t\t\t\t\tif(used[deep]) continue;\n\t\t\t\t\t\tif(dis == hash[deep]){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tboolean res = check(j,i,l,k, deep);\n\t\t\t\t\t\t\tif(! res) continue;\n\t\t\t\t\t\t\tset(j,i,l,k, deep);\n\t\t\t\t\t\t\tused[deep] = true;\n\t\t\t\t\t\t\tdfs(deep + 1);\n\t\t\t\t\t\t\tused[deep] = false;\n\t\t\t\t\t\t\tset(j,i,l,k,0);\n\t\t\t\t\t\t\tdata[point[deep].y][point[deep].x] = deep;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void disp(){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tSystem.out.print(data[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\n\tprivate void set(int x1, int y1, int x2, int y2, int num) {\n\t\t\n\t\tfor(int i = y1; i <= y2; i++){\n\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\tdata[i][j] = num;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate boolean check(int x1, int y1, int x2, int y2, int num) {\n\t\tboolean issameC = false;\n\t\tfor(int i = y1; i <= y2; i++){\n\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\tif(data[i][j] == num){\n\t\t\t\t\tissameC = true;\n\t\t\t\t}\n\t\t\t\telse if(data[i][j] != 0){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(issameC) return true;\n\t\treturn false;\n\t}\n\n\n\tprivate int calcdis(int x1, int y1, int x2, int y2) {\n\t\tint res = (Math.abs(x1 - x2) + 1) * (Math.abs(y1 - y2) + 1);\n\t\treturn res;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.util.*;\npublic class Main {\n\t\n\tboolean [] used;\n\tboolean flg, dup;\n\tint n,w,h, deepsize;\n\tint [][] data, ans;\n\tint [] hash;\n\tC[][] cand;\n\tP [] point;\n\t\n\tclass C{\n\t\tHashSet<Integer> list;\n\n\t\tpublic C(HashSet<Integer> list) {\n\t\t\tthis.list = list;\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tint x,y;\n\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif((w|h|n) == 0) break;\n\t\t\thash = new int[n+1];\n\t\t\tdeepsize = n;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\thash[b] = k;\n\t\t\t\tif(k == 1) deepsize--;\n\t\t\t}\n\t\t\tdata = new int[h][w];\n\t\t\tpoint = new P[n+1];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t\tif(data[i][j] > 0){\n\t\t\t\t\t\tpoint[data[i][j]] = new P(j, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tused = new boolean[n+1];\n\t\t\tflg = false;\n\t\t\tdup = true;\n\t\t\tans = new int[h][w];\n\t\t\tdfs(1);\n\t\t\tif(flg && dup){\n\t\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\tSystem.out.print(ans[i][0]);\n\t\t\t\t\tfor(int j = 1; j < w; j++){\n\t\t\t\t\t\tSystem.out.print(\" \" + ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n + 1){\n\t\t\tif(flg){\n\t\t\t\tdup =false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tflg = true;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tans[i] = data[i].clone();\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t\tif(hash[deep] == 1){\n\t\t\tdfs(deep+1);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(data[i][j] != 0 && data[i][j] != deep) continue;\n\t\t\t\t\n\t\t\t\tfor(int k = i; k < h; k++){\n\t\t\t\t\tfor(int l = j; l < w; l++){\n\t\t\t\t\t\tint dis = calcdis(j, i, l, k);\n\t\t\t\t\t\tif(used[deep]) continue;\n\t\t\t\t\t\tif(dis == hash[deep]){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tboolean res = check(j,i,l,k, deep);\n\t\t\t\t\t\t\tif(! res) continue;\n\t\t\t\t\t\t\tset(j,i,l,k, deep);\n\t\t\t\t\t\t\tused[deep] = true;\n\t\t\t\t\t\t\tdfs(deep + 1);\n\t\t\t\t\t\t\tused[deep] = false;\n\t\t\t\t\t\t\tset(j,i,l,k,0);\n\t\t\t\t\t\t\tdata[point[deep].y][point[deep].x] = deep;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void disp(){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tSystem.out.print(data[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\n\tprivate void set(int x1, int y1, int x2, int y2, int num) {\n\t\t\n\t\tfor(int i = y1; i <= y2; i++){\n\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\tdata[i][j] = num;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate boolean check(int x1, int y1, int x2, int y2, int num) {\n\t\tboolean issameC = false;\n\t\tfor(int i = y1; i <= y2; i++){\n\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\tif(data[i][j] == num){\n\t\t\t\t\tissameC = true;\n\t\t\t\t}\n\t\t\t\telse if(data[i][j] != 0){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(issameC) return true;\n\t\treturn false;\n\t}\n\n\n\tprivate int calcdis(int x1, int y1, int x2, int y2) {\n\t\tint res = (Math.abs(x1 - x2) + 1) * (Math.abs(y1 - y2) + 1);\n\t\treturn res;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic int[][] now;\n\tstatic int[][] map;\n\tstatic int[][] ans;\n\tstatic int x;\n\tstatic int y;\n\tstatic int n;\n\n\tstatic boolean ok;\n\tstatic boolean na;\n\n\tstatic HashMap<Integer,Integer> MAP = new HashMap<Integer,Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tMAP.clear();\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tok = false;\n\t\t\tna = false;\n\t\t\tif(x == 0 && y == 0 && n == 0) break;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tMAP.put(b, k);\n\t\t\t}\n\t\t\tmap = new int[y][x];\n\t\t\tnow = new int[y][x];\n\t\t\tans = new int[y][x];\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolv(0,0,0);\n\t\t\tif(!ok) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i = 0; i < y; i++) {\n\t\t\t\tSystem.out.print(ans[i][0]);\n\t\t\t\tfor(int j = 1; j < x; j++) {\n\t\t\t\t\tSystem.out.print(\" \" + ans[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\tstatic void solv(int y, int x, int cc) {\n\t\t/*\n\t\tSystem.out.println(\"==\");\n\t\tfor(int i = 0; i < Main.y; i++) {\n\t\t\tfor(int j = 0; j < Main.x; j++) {\n\t\t\t\tSystem.out.print(\" \" + now[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n\t\tif(na) return;\n\t\tif(x == Main.x) {\n\t\t\tx = 0;\n\t\t\ty++;\n\t\t}\n\t\tif(y == Main.y && !ok && !na && check(cc)) {\n\t\t\tok = true;\n\t\t\tfor(int i = 0; i < Main.y; i++) {\n\t\t\t\tans[i] = Arrays.copyOf(now[i], now[i].length);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse if(y == Main.y && ok && check(cc)) {\n\t\t\tok = false;\n\t\t\tna = true;\n\t\t\treturn;\n\t\t}\n\t\telse if(y == Main.y) {\n\t\t\treturn;\n\t\t}\n\t\tfor(int CX = 1; CX <= MAP.size(); CX++) {\n\t\t\tif((cc & (1 << (CX-1))) != 0) continue;\n\t\t\tIN:for(int i = MAP.get(CX); i >= 1; i--) {\n\t\t\t\tif(MAP.get(CX) % i != 0) continue;\n\t\t\t\tboolean check = false;\n\t\t\t\tfor(int k = 0; k < i; k++) {\n\t\t\t\t\tfor(int l = 0; l < MAP.get(CX)/i; l++) {\n\t\t\t\t\t\tint ty = y+k;\n\t\t\t\t\t\tint tx = x+l;\n\t\t\t\t\t\tif(ty < 0 || tx < 0 || ty >= Main.y || tx >= Main.x) continue IN;\n\t\t\t\t\t\tif(now[ty][tx] != 0 || (map[ty][tx] != CX && map[ty][tx] != 0)) continue IN;\n\t\t\t\t\t\tif(map[ty][tx] == CX) check = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!check) continue;\n\t\t\t\tfor(int k = 0; k < i; k++) {\n\t\t\t\t\tfor(int l = 0; l < MAP.get(CX)/i; l++) {\n\t\t\t\t\t\tint ty = y+k;\n\t\t\t\t\t\tint tx = x+l;\n\t\t\t\t\t\tnow[ty][tx] = CX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsolv(y,x+1,(cc | (1 << (CX-1))));\n\t\t\t\tfor(int k = 0; k < i; k++) {\n\t\t\t\t\tfor(int l = 0; l < MAP.get(CX)/i; l++) {\n\t\t\t\t\t\tint ty = y+k;\n\t\t\t\t\t\tint tx = x+l;\n\t\t\t\t\t\tnow[ty][tx] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolv(y,x+1,cc);\n\t}\n\t\n\tstatic boolean check(int a) {\n\t\tfor(int i = 0; i < MAP.size(); i++) {\n\t\t\tif((a & (1 << i)) == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tmap = new int[h][w];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint s = scanner.nextInt();\n\t\t\t\t\tmap[i][j] = s;\n\t\t\t\t\tif (s > 0) {\n\t\t\t\t\t\tpos[s][0] = i;\n\t\t\t\t\t\tpos[s][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (count == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t\tSystem.out.print(j == w - 1 ? '\\n' : ' ');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tPriorityQueue<Point> pq = new PriorityQueue<Point>();\n\t\tpq.add(new Point(map, 1));\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPoint point = pq.poll();\n\t\t\tint[][] map = point.map;\n\t\t\tk = point.k;\n\t\t\tif (k == n + 1) {\n\t\t\t\tcount++;\n\t\t\t\tif (count == 2)\n\t\t\t\t\treturn;\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tint a = map[i][j];\n\t\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s = size[k];\n\t\t\tfor (int r = 1; r <= s; r++) {\n\t\t\t\tif (s % r != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tint y = pos[k][0];\n\t\t\t\tint x = pos[k][1];\n\t\t\t\tfor (int ui = y + 1 - s / r; ui <= y; ui++) {\n\t\t\t\t\tif (ui < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tloop: for (int lj = x + 1 - r; lj <= x; lj++) {\n\t\t\t\t\t\tif (lj < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint di = ui + s / r;\n\t\t\t\t\t\tint rj = lj + r;\n\t\t\t\t\t\tif (di > h || rj > w)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int i = ui; i < di; i++) {\n\t\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\t\tif (map[i][j] != 0 && map[i][j] != k)\n\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint[][] tmp = new int[h][w];\n\t\t\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\t\t\ttmp[i] = Arrays.copyOf(map[i], w);\n\t\t\t\t\t\tfor (int i = ui; i < di; i++) {\n\t\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\t\tif (tmp[i][j] != k)\n\t\t\t\t\t\t\t\t\ttmp[i][j] = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpq.add(new Point(tmp, k + 1));\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Point implements Comparable<Point> {\n\t\tint[][] map;\n\t\tint k;\n\n\t\tpublic Point(int[][] map, int k) {\n\t\t\tsuper();\n\t\t\tthis.map = map;\n\t\t\tthis.k = k;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn o.k - this.k;\n\t\t}\n\n\t}\n\n\tint count;\n\tint h, w, n;\n\tint[] size;\n\tint[][] map;\n\tint[][] pos;\n\tint[][] ans;\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int W,H,n,ans;\n\tstatic int[] id;\n\tstatic int[][] field,memo;\n\tstatic int[][] ansfield;\n\tstatic int[][][] kukaku;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW=cin.nextInt();\n\t\t\tH=cin.nextInt();\n\t\t\tn=cin.nextInt();\n\t\t\tif(W+H+n==0)break;\n\t\t\tans=0;\n\t\t\tmemo = new int[n][2];\n\t\t\t\n\t\t\tfield= new int[H][W];\n\t\t\tansfield= new int[H][W];\n\t\t\tkukaku=new int[n][101][2];\n\t\t\tid=new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmemo[i][0]=cin.nextInt();\n\t\t\t\tid[i]=memo[i][0];\n\t\t\t\tmemo[i][1]=cin.nextInt();\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int j=1;j<=memo[i][1];j++){\n\t\t\t\t\tif(memo[i][1]%j==0){\n\t\t\t\t\t\tkukaku[i][cnt][0]=j;\n\t\t\t\t\t\tkukaku[i][cnt][1]=memo[i][1]/j;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tkukaku[i][100][0]=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tfield[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(0);\n\t\t\tif(ans==0||ans>1){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\toutputans();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\tstatic void bt(int step){\n\t\tif(step==n){\n\t\t\tif(ans==0){\n\t\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\t\tansfield[i][j]=field[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(field[i][j]==id[step]){\n\t\t\t\t\tfit(i,j,step);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic void fit(int x,int y,int step){\n\t\tfor(int i=0;i<kukaku[step][100][0];i++){\n\t\t\tfor(int k=x-kukaku[step][i][0]+1;k<=x;k++){\n\t\t\t\tif(k<0||k>=H)continue;\n\t\t\t\tfor(int h=y-kukaku[step][i][1]+1;h<=y;h++){\n\t\t\t\t\tif(h<0||h>=W)continue;\n\t\t\t\t\t\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\t//テ・ツァツ凝ァツつケテ」ツ?渓,h\n\t\t\t\t\tfor(int a=k;a<k+kukaku[step][i][0];a++){\n\t\t\t\t\t\tfor(int b=h;b<h+kukaku[step][i][1];b++){\n\t\t\t\t\t\t\tif(a<0||a>=H||b<0||b>=W){\n\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// (k,h)-(a,b)テ」ツつ段d[step]テ」ツ?ァテ・ツ。ツ療」ツつ?\n\t\t\t\t\t\t\tif(field[a][b]!=0&&field[a][b]!=id[step]){\n//\t\t\t\t\t\t\t\tSystem.out.println(a+\" \"+b+\" \"+id[step]);\n\t\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\toutput(); \n//\t\t\t\t\tSystem.out.println(kukaku[step][i][0]+\" \"+kukaku[step][i][1]);\n//\t\t\t\t\tSystem.out.println(k+\" \"+h);\n//\t\t\t\t\tSystem.out.println();\n\t\t\t\t\tif(!f)continue;\n\t\t\t\t\t// テ・ツ。ツ療」ツつ?\n\t\t\t\t\tfor(int a=k;a<k+kukaku[step][i][0];a++){\n\t\t\t\t\t\tfor(int b=h;b<h+kukaku[step][i][1];b++){\n\t\t\t\t\t\t\tfield[a][b]=id[step];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbt(step+1);\n\t\t\t\t\t// テヲツ按サテ」ツ??\n\t\t\t\t\tfor(int a=k;a<k+kukaku[step][i][0];a++){\n\t\t\t\t\t\tfor(int b=h;b<h+kukaku[step][i][1];b++){\n\t\t\t\t\t\t\tfield[a][b]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfield[x][y]=id[step];\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tSystem.out.print(field[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic void outputans(){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\n\t\t\t\tif(j==W-1){\n\t\t\t\t\tSystem.out.print(ansfield[i][j]);\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.print(ansfield[i][j]+\" \");\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport scala.languageFeature.postfixOps;\nimport sun.tools.jar.resources.jar;\nimport lombok.Data;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((w | h | n) == 0)\n\t\t\t\tbreak;\n\t\t\tsize = new int[n + 1];\n\t\t\tpos = new int[n + 1][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint k = scanner.nextInt();\n\t\t\t\tsize[b] = k;\n\t\t\t}\n\t\t\tm = new int[h][w];\n\t\t\t\n\t\t\tfor (int[] a : m)\n\t\t\t\tArrays.fill(a, -1);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint x = scanner.nextInt();\n\t\t\t\t\tm[i][j] = x;\n\t\t\t\t\tif (x > 0) {\n\t\t\t\t\t\tpos[x][0] = i;\n\t\t\t\t\t\tpos[x][1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassign = new int[n + 1][4];\n\t\t\tc = 0;\n\t\t\tans = new int[h][w];\n\t\t\tf(1);\n\t\t\tif (c == 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate void f(int k) {\n\t\tif (k == n + 1) {\n\t\t\tc++;\n\t\t\tif (c == 2)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint a = m[i][j];\n\t\t\t\t\tans[i][j] = a >= 100 ? a / 100 : a;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint s = size[k];\n\t\tfor (int x = 1; x <= s; x++) {\n\t\t\tif (s % x != 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int lj = pos[k][1] + 1 - x; lj <= pos[k][1]; lj++) {\n\t\t\t\tif (lj < 0 || lj > w)\n\t\t\t\t\tcontinue;\n\t\t\t\tloop: for (int li = pos[k][0] + 1 - s / x; li <= pos[k][0]; li++) {\n\t\t\t\t\tif (li < 0 || li > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint rj = lj + x;\n\t\t\t\t\tint ri = li + s / x;\n\t\t\t\t\tif (rj > w)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (ri > h)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != 0 && m[i][j] != k)\n\t\t\t\t\t\t\t\tcontinue loop;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = k * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf(k + 1);\n\t\t\t\t\tif (c == 2)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tfor (int i = li; i < ri; i++) {\n\t\t\t\t\t\tfor (int j = lj; j < rj; j++) {\n\t\t\t\t\t\t\tif (m[i][j] != k)\n\t\t\t\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tint[][] m;\n\tint[] size;\n\tint[][] pos;\n\tint[][] assign;\n\tint w, h, n, c;\n\tint[][] ans;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic int X;\n\tstatic int Y;\n\tstatic int N;\n\t\n\tstatic HashMap<Integer,Integer> BK;\n\t\n\tstatic int[][] S;\n\t\n\tstatic boolean NA;\n\tstatic boolean OK;\n\t\n\tstatic int[][] now;\n\tstatic int[][] ans;\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tX = sc.nextInt();\n\t\t\tY = sc.nextInt();\n\t\t\tN = sc.nextInt();\n\t\t\tif(X == 0 && Y == 0 && N == 0) break;\n\t\t\tBK = new HashMap<Integer,Integer>();\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tBK.put(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tS = new int[Y][X];\n\t\t\tNA = false;\n\t\t\tOK = false;\n\t\t\tnow = new int[Y][X];\n\t\t\tans = new int[Y][X];\n\t\t\tfor(int i = 0; i < Y; i++) {\n\t\t\t\tfor(int j = 0; j < X; j++) {\n\t\t\t\t\tS[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolv(0,0);\n\t\t\tif(NA || !OK) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i = 0; i < Y; i++ ) {\n\t\t\t\tSystem.out.print(ans[i][0]);\n\t\t\t\tfor(int j = 1; j < X; j++) {\n\t\t\t\t\tSystem.out.print(\" \" + ans[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\tstatic void solv(int y, int x) {\n\t\tif(NA) {\n\t\t\treturn;\n\t\t}\n\t\tif(x == X) {\n\t\t\tsolv(y+1,0);\n\t\t\treturn;\n\t\t}\n\t\tif(y == Y) {\n\t\t\tif(OK) {\n\t\t\t\tNA = true;\n\t\t\t\tOK = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!OK && !NA) {\n\t\t\t\tOK = true;\n\t\t\t\tfor(int i = 0; i < Y; i++) {\n\t\t\t\t\tans[i] = Arrays.copyOf(now[i], now[i].length);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(S[y][x] == 0) {\n\t\t\tsolv(y,x+1);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 1; i <= BK.get(S[y][x]); i++) {\n\t\t\tif(BK.get(S[y][x]) % i != 0) continue;\n\t\t\tfor(int j = -(BK.get(S[y][x])/i)+1; j <= 0; j++) { //???????????? x\n\t\t\t\tIN:for(int k = -i + 1; k <= 0; k++) { //???????????? y\n\t\t\t\t\tfor(int l = 0; l < i; l++) {\n\t\t\t\t\t\tfor(int m = 0; m < BK.get(S[y][x]) / i; m++) {\n\t\t\t\t\t\t\tint tox = m + j + x;\n\t\t\t\t\t\t\tint toy = l + k + y;\n\t\t\t\t\t\t\tif(tox < 0 || toy < 0 || tox >= X || toy >= Y) continue IN;\n\t\t\t\t\t\t\tif(now[toy][tox] != 0 || (S[toy][tox] != S[y][x] && S[toy][tox] != 0)) continue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l = 0; l < i; l++) {\n\t\t\t\t\t\tfor(int m = 0; m < BK.get(S[y][x]) / i; m++) {\n\t\t\t\t\t\t\tint tox = m + j + x;\n\t\t\t\t\t\t\tint toy = l + k + y;\n\t\t\t\t\t\t\tnow[toy][tox] = S[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsolv(y,x+1);\n\t\t\t\t\tfor(int l = 0; l < i; l++) {\n\t\t\t\t\t\tfor(int m = 0; m < BK.get(S[y][x]) / i; m++) {\n\t\t\t\t\t\t\tint tox = m + j + x;\n\t\t\t\t\t\t\tint toy = l + k + y;\n\t\t\t\t\t\t\tnow[toy][tox] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\t\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0213\n{\n    public class Program\n\n    {\n        public class Customer\n        {\n            public int ID { get; set; }\n            public int Area { get; set; }\n            public Point DefaultP { get; set; }\n\n            public Customer(int[] vs)\n            {\n                ID = vs[0];\n                Area = vs[1];\n            }\n        }\n\n        public class Point\n        {\n            public int I { get; set; }\n            public int J { get; set; }\n            public Point(int i, int j) { this.I = i; J = j; }\n        }\n\n        private static int[,] map;\n        private static List<Customer> customers;\n        private static int[,] ansMap;\n        private static int ansCnt;\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xyn = RIntAr();\n                if (xyn.Sum() == 0) break;\n                Init(xyn);\n                SetLot(0);\n                Print();\n            }\n        }\n\n        private static void Init(int[] xyn)\n        {\n            ansCnt = 0;\n            ansMap = new int[xyn[1], xyn[0]];\n            map = new int[xyn[1], xyn[0]];\n            customers = new List<Customer>(xyn[2]);\n            for (int i = 0; i < xyn[2]; i++)\n            {\n                customers.Add(new Customer(RIntAr()));\n            }\n\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                int[] vs = RIntAr();\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    map[i, j] = vs[j];\n                    if (vs[j] > 0)\n                    {\n                        Customer ctm = customers.Where(x => x.ID == vs[j]).First();\n                        ctm.DefaultP = new Point(i, j);\n                    }\n                }\n            }\n        }\n\n        private static bool SetLot(int k)\n        {\n            if (k == customers.Count())\n            {\n                ansCnt++;\n                if (ansCnt == 1)\n                {\n                    // １つ目の答えでは、答えを保持して処理継続\n                    Array.Copy(map, ansMap, map.Length);\n                    return false;\n                }\n                else\n                {\n                    // 答えが複数あれば打ち切り\n                    return true;\n                }\n            }\n            else\n            {\n                foreach (int width in GetDivisor(customers[k].Area).OrderBy(x => x))\n                {\n                    int height = customers[k].Area / width;\n                    foreach (Point p in GetCandidateP(customers[k], height, width))\n                    {\n                        SetMap(customers[k], p, height, width);\n                        if (SetLot(k + 1)) return true;\n                        UnsetMap(customers[k], p, height, width);\n                    }\n                }\n            }\n            return false;\n        }\n\n        /// <summary>\n        /// 整数の約数を列挙する(未ソート)\n        /// </summary>\n        /// <param name=\"n\">整数</param>\n        /// <returns>約数の列挙子</returns>\n        public static IEnumerable<int> GetDivisor(int n)\n        {\n            int boundary = (int)Math.Floor(Math.Sqrt(n));\n            for (int i = 1; i <= boundary; i++)\n            {\n                if (n % i == 0)\n                {\n                    yield return i;\n                    if (i != n / i) yield return n / i;\n                }\n            }\n        }\n\n        private static IEnumerable<Point> GetCandidateP(Customer cmt, int height, int width)\n        {\n            if (map.GetLength(0) < height || map.GetLength(1) < width)\n            {\n                yield break;\n            }\n\n            for (int i = 0; i < height; i++)\n            {\n                for (int j = 0; j < width; j++)\n                {\n                    int si = cmt.DefaultP.I - i;\n                    int sj = cmt.DefaultP.J - j;\n                    if (CanSet(cmt, si, sj, height, width)) yield return new Point(si, sj);\n                }\n            }\n        }\n\n        private static bool CanSet(Customer cmt, int si, int sj, int height, int width)\n        {\n            if (!IsInArea(si, sj) || !IsInArea(si + height - 1, sj + width - 1)) return false;\n\n            for (int i = 0; i < height; i++)\n            {\n                for (int j = 0; j < width; j++)\n                {\n                    if (map[si + i, sj + j] > 0 && map[si + i, sj + j] != cmt.ID) return false;\n                }\n            }\n            return true;\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < map.GetLength(0) && 0 <= j && j < map.GetLength(1);\n        }\n\n        private static void SetMap(Customer ctm, Point p, int height, int width, bool flg = true)\n        {\n            for (int i = 0; i < height; i++)\n            {\n                for (int j = 0; j < width; j++)\n                {\n                    if (p.I + i == ctm.DefaultP.I && p.J + j == ctm.DefaultP.J) continue;\n                    map[p.I + i, p.J + j] = flg ? ctm.ID : 0;\n                }\n            }\n        }\n\n        private static void UnsetMap(Customer ctm, Point p, int height, int width)\n        {\n            SetMap(ctm, p, height, width, false);\n        }\n\n        private static void Print()\n        {\n            if (ansCnt != 1)\n            {\n                Console.WriteLine(\"NA\");\n            }\n            else\n            {\n                for (int i = 0; i < ansMap.GetLength(0); i++)\n                {\n                    for (int j = 0; j < ansMap.GetLength(1); j++)\n                    {\n                        if (j > 0) Console.Write(' ');\n                        Console.Write(ansMap[i, j]);\n\n                    }\n                    Console.Write(Environment.NewLine);\n                }\n            }\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "100.times{puts \"NA\"}"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\ndef f m,l\n#p [m,l]\n#puts m.map{|i|i*\" \"}\n#puts \nd=0\n(n,v=l[0];v)?(1..v).flat_map{|i|\n  v%i==0&&(\n    j=v/i\n    y,x=$o[n]\n    (y-i+1..y).flat_map{|t|\n      t>=0&&m[t+i-1]&&(x-j+1..x).flat_map{|u|\n        u>=0&&m[t][u+j-1]&&\n        m[t,i].all?{|k|\n          k[u,j].all?{|z|z==0||z==n}\n        }&&(\n          d=m.map{|k|k.dup}\n          d[t,i]=d[t,i].map{|k|k[u,j]=[n]*j;k}\n          f d,l[1..-1]\n        )\n      }\n    }\n  )\n}.select{|i|i}:!m.flatten.index(0)&&[m]\nend\nwhile(x,y,n=g;x>0)\nl=(1..n).map{g}\n$o=[]\nm=(1..y).map{|i|j=0;g.each{|c|c>0&&$o[c]=[i-1,j];j+=1}}\na=f m,l\n#p a.size\n#p a\nputs a.size==1?a[0].map{|i|i*\" \"}:\"NA\"\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef divk(k)\n  for i in (1..k)\n    if k % i == 0\n      yield k / i, i\n    end\n  end\nend\n\ndef fit?(b, rect, grnds)\n  x1, y1, x2, y2 = rect\n\n  for y in (y1..y2)\n    for x in (x1..x2)\n      return false if grnds[y][x] > 0 && grnds[y][x] != b\n    end\n  end\n  true\nend\n\ndef gen_rects(b, k, x, y, grnds, w, h)\n  rects = []\n\n  divk(k) do |w0, h0|\n    next if w0 > w || h0 > h\n\n    for y0 in (0...h0)\n      y1 = y - y0\n      y2 = y + h0 - 1 - y0\n      next if y1 < 0 || y2 >= h\n\n      for x0 in (0...w0)\n        x1 = x - x0\n        x2 = x + w0 - 1 - x0\n        next if x1 < 0 || x2 >= w\n\n        rect = [x1, y1, x2, y2]\n\n        if fit?(b, rect, grnds)\n          rects << rect\n        end\n      end\n    end\n  end\n\n  rects\nend\n\ndef fill_common(b, rects, grnds, w, h)\n  counts = grnds.map{|hl| hl.map{0}}\n\n  for r in rects\n    x1, y1, x2, y2 = r\n    for y in (y1..y2)\n      for x in (x1..x2)\n        counts[y][x] += 1\n      end\n    end\n  end\n\n  changed = false\n  rnum = rects.length\n\n  for y in (0...h)\n    for x in (0...w)\n      if counts[y][x] == rnum && grnds[y][x] == 0\n        grnds[y][x] = b\n        changed = true\n      end\n    end\n  end\n\n  changed\nend\n\n### main\n\nwhile true\n  w, h, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if w + h + n == 0\n\n  buyers = []\n  ksum = 0\n\n  n.times.each do\n    b, k = gets.strip.split(' ').map{|s| s.to_i}\n    buyers[b - 1] = [b, k]\n    ksum += k\n  end\n\n#  if ksum != w * h\n#    h.times.each{gets}\n#    puts 'NA'\n#    next\n#  end\n\n  grnds = []\n\n  for y in (0...h)\n    hl = gets.strip.split(' ').map{|s| s.to_i}\n    grnds << hl\n  end\n\n  for y in (0...h)\n    for x in (0...w)\n      b = grnds[y][x]\n      if b > 0\n        b0 = buyers[b - 1]\n        b0[2] = gen_rects(b0[0], b0[1], x, y, grnds, w, h)\n      end\n    end\n  end\n  #p grnds\n  #p buyers\n\n  while ! buyers.empty?\n    changed = false\n\n    for b0 in buyers\n      for r in b0[2].clone\n        if ! fit?(b0[0], r, grnds)\n          b0[2].delete(r)\n          changed = true\n        end\n      end\n    end\n\n    for b0 in buyers.clone\n      changed = fill_common(b0[0], b0[2], grnds, w, h) || changed\n      rnum = b0[2].length\n      if rnum == 1\n        buyers.delete(b0)\n        changed = true\n      elsif rnum == 0\n        changed = false\n        break\n      end\n    end\n    #p buyers\n\n    break if ! changed\n  end\n\n  if buyers.length > 0\n    puts 'NA'\n  else\n    for hl in grnds\n      puts hl.join(' ')\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef divk(k)\n  for i in (1..k)\n    if k % i == 0\n      yield k / i, i\n    end\n  end\nend\n\ndef gen_rects(k, x, y, w, h)\n  rects = []\n\n  divk(k) do |w0, h0|\n    next if w0 > w || h0 > h\n\n    for y0 in (0...h0)\n      y1 = y - y0\n      y2 = y + h0 - 1 - y0\n      next if y1 < 0 || y2 >= h\n\n      for x0 in (0...w0)\n        x1 = x - x0\n        x2 = x + w0 - 1 - x0\n        next if x1 < 0 || x2 >= w\n\n        rects << [x1, y1, x2, y2]\n      end\n    end\n  end\n\n  rects\nend\n\ndef fit?(b, rect, grnds)\n  x1, y1, x2, y2 = rect\n\n  for y in (y1..y2)\n    for x in (x1..x2)\n      return false if grnds[y][x] > 0 && grnds[y][x] != b\n    end\n  end\n  true\nend\n\ndef fill_common(b, rects, grnds, w, h)\n  counts = grnds.map{|hl| hl.map{0}}\n\n  for r in rects\n    x1, y1, x2, y2 = r\n    for y in (y1..y2)\n      for x in (x1..x2)\n        counts[y][x] += 1\n      end\n    end\n  end\n\n  changed = false\n  rnum = rects.length\n\n  for y in (0...h)\n    for x in (0...w)\n      if counts[y][x] == rnum && grnds[y][x] == 0\n        grnds[y][x] = b\n        changed = true\n      end\n    end\n  end\n\n  changed\nend\n\n### main\n\nwhile true\n  w, h, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if w + h + n == 0\n\n  grnds = []\n  buyers = []\n\n  ksum = 0\n\n  for i in (1..n)\n    b, k = gets.strip.split(' ').map{|s| s.to_i}\n    buyers[b - 1] = [b, k]\n    ksum += k\n  end\n\n  if ksum != w * h\n    h.times.each{gets}\n    puts 'NA'\n    next\n  end\n\n  for y in (0...h)\n    hl = gets.strip.split(' ').map{|s| s.to_i}\n    grnds << hl\n\n    for x in (0...w)\n      if hl[x] > 0\n        b, k = buyers[hl[x] - 1]\n        buyers[hl[x] - 1][2] = gen_rects(k, x, y, w, h)\n      end\n    end\n  end\n  #p grnds\n  #p buyers\n\n  while ! buyers.empty?\n    changed = false\n\n    for b0 in buyers\n      for r in b0[2].clone\n        if ! fit?(b0[0], r, grnds)\n          b0[2].delete(r)\n          changed = true\n        end\n      end\n    end\n\n    for b0 in buyers.clone\n      changed = fill_common(b0[0], b0[2], grnds, w, h) || changed\n      rnum = b0[2].length\n      if rnum == 1\n        buyers.delete(b0)\n        changed = true\n      elsif rnum == 0\n        changed = false\n        break\n      end\n    end\n    #p buyers\n\n    break if ! changed\n  end\n\n  if buyers.length > 0\n    puts 'NA'\n  else\n    for hl in grnds\n      puts hl.join(' ')\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\ndef f m,l\n(n,v=l[0];v)?(1..v).flat_map{|i|v%i==0&&(j=v/i\ny,x=$o[n]\n(y-i+1..y).flat_map{|t|t>=0&&m[t+i-1]&&(x-j+1..x).flat_map{|u|u>=0&&m[t][u+j-1]&&m[t,i].all?{|k|k[u,j].all?{|z|z==0||z==n}}&&(d=m.map{|k|k.dup}\nd[t,i]=d[t,i].map{|k|k[u,j]=[n]*j;k}\nf d,l[1..-1])}})}.select{|i|i}:!m.flatten.index(0)&&[m]\nend\nwhile(x,y,n=g;x>0)\nl=(1..n).map{g}\n$o=[]\nm=(1..y).map{|i|j=0;g.each{|c|c>0&&$o[c]=[i-1,j];j+=1}}\na=f m,l\nputs a.size==1?a[0].map{|i|i*\" \"}:\"NA\"\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef fit?(b, x1, y1, x2, y2, grnds)\n  for y in (y1..y2)\n    for x in (x1..x2)\n      return false if grnds[y][x] > 0 && grnds[y][x] != b\n    end\n  end\n  true\nend\n\ndef divk(k)\n  for i in (1..k)\n    if k % i == 0\n      yield k / i, i\n    end\n  end\nend\n\ndef gen_rects(b, k, x, y, grnds, w, h)\n  rects = []\n\n  divk(k) do |w0, h0|\n    next if w0 > w || h0 > h\n\n    for y0 in (0...h0)\n      y1 = y - y0\n      y2 = y + h0 - 1 - y0\n      next if y1 < 0 || y2 >= h\n\n      for x0 in (0...w0)\n        x1 = x - x0\n        x2 = x + w0 - 1 - x0\n        next if x1 < 0 || x2 >= w\n\n        if fit?(b, x1, y1, x2, y2, grnds)\n          rects << [x1, y1, x2, y2]\n        end\n      end\n    end\n  end\n\n  rects\nend\n\ndef fill_rect(b, x1, y1, x2, y2, grnds)\n  for y in (y1..y2)\n    for x in (x1..x2)\n      grnds[y][x] = b\n    end\n  end\nend\n\ndef place_rec(id, n, buyers, grnds)\n  if id >= n\n    return [1, grnds.map{|hl| hl.map{|b| b}}]\n  end\n\n  count = 0\n  gans = nil\n\n  bi = buyers[id]\n  for r in bi[4]\n    if fit?(bi[0], *r, grnds)\n      fill_rect(bi[0], *r, grnds)\n      count0, gans0 = place_rec(id + 1, n, buyers, grnds)\n      fill_rect(0, *r, grnds)\n      grnds[bi[3]][bi[2]] = bi[0]\n\n      count += count0\n      if count > 1\n        return [count, nil]\n      elsif count0 == 1\n        gans = gans0\n      end\n    end\n  end\n\n  [count, gans]\nend\n\n### main\n\nwhile true\n  w, h, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if w + h + n == 0\n\n  buyers = []\n  ksum = 0\n\n  n.times.each do\n    b, k = gets.strip.split(' ').map{|s| s.to_i}\n    buyers[b - 1] = [b, k]\n    ksum += k\n  end\n\n  if ksum != w * h\n    h.times.each{gets}\n    puts 'NA'\n    next\n  end\n\n  grnds = h.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n\n  for y in (0...h)\n    for x in (0...w)\n      b = grnds[y][x]\n      if b > 0\n        b0 = buyers[b - 1]\n        b0[2] = x\n        b0[3] = y\n        b0[4] = gen_rects(b0[0], b0[1], x, y, grnds, w, h)\n      end\n    end\n  end\n  #p grnds\n  #p buyers\n\n  count, gans = place_rec(0, n, buyers, grnds)\n\n  if count != 1\n    puts 'NA'\n  else\n    for hl in gans\n      puts hl.join(' ')\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef divk(k)\n  for i in (1..k)\n    if k % i == 0\n      yield k / i, i\n    end\n  end\nend\n\ndef gen_rects(k, x, y, w, h)\n  rects = []\n\n  divk(k) do |w0, h0|\n    next if w0 > w || h0 > h\n\n    for y0 in (0...h0)\n      y1 = y - y0\n      y2 = y + h0 - 1 - y0\n      next if y1 < 0 || y2 >= h\n\n      for x0 in (0...w0)\n        x1 = x - x0\n        x2 = x + w0 - 1 - x0\n        next if x1 < 0 || x2 >= w\n\n        rects << [x1, y1, x2, y2]\n      end\n    end\n  end\n\n  rects\nend\n\ndef fit?(b, rect, grnds)\n  x1, y1, x2, y2 = rect\n\n  for y in (y1..y2)\n    for x in (x1..x2)\n      return false if grnds[y][x] > 0 && grnds[y][x] != b\n    end\n  end\n  true\nend\n\ndef fill_common(b, rects, grnds, w, h)\n  counts = grnds.map{|hl| hl.map{0}}\n  changed = false\n\n  for r in rects\n    x1, y1, x2, y2 = r\n    for y in (y1..y2)\n      for x in (x1..x2)\n        counts[y][x] += 1\n      end\n    end\n  end\n\n  rnum = rects.length\n\n  for y in (0...h)\n    for x in (0...w)\n      if counts[y][x] == rnum && grnds[y][x] != b\n        grnds[y][x] = b\n        changed = true\n      end\n    end\n  end\n\n  changed\nend\n\n### main\n\nwhile true\n  w, h, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if w + h + n == 0\n\n  grnds = []\n  buyers = []\n\n  for i in (1..n)\n    b, k = gets.strip.split(' ').map{|s| s.to_i}\n    buyers[b - 1] = [b, k]\n  end\n\n  for y in (0...h)\n    hl = gets.strip.split(' ').map{|s| s.to_i}\n    grnds << hl\n\n    for x in (0...w)\n      if hl[x] > 0\n        b, k = buyers[hl[x] - 1]\n        buyers[hl[x] - 1][2] = gen_rects(k, x, y, w, h)\n      end\n    end\n  end\n  #p grnds\n  #p buyers\n\n  while ! buyers.empty?\n    changed = false\n\n    for b0 in buyers\n      for r in b0[2].clone\n        if ! fit?(b0[0], r, grnds)\n          b0[2].delete(r)\n          changed = true\n        end\n      end\n    end\n\n    for b0 in buyers.clone\n      changed = fill_common(b0[0], b0[2], grnds, w, h) || changed\n      rnum = b0[2].length\n      if rnum == 1\n        buyers.delete(b0)\n        changed = true\n      end\n    end\n    #p buyers\n\n    break if ! changed\n  end\n\n  if buyers.length > 0\n    puts 'NA'\n  else\n    for hl in grnds\n      puts hl.join(' ')\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef divk(k)\n  for i in (1..k)\n    if k % i == 0\n      yield k / i, i\n    end\n  end\nend\n\ndef fit?(b, rect, grnds)\n  x1, y1, x2, y2 = rect\n\n  for y in (y1..y2)\n    for x in (x1..x2)\n      return false if grnds[y][x] > 0 && grnds[y][x] != b\n    end\n  end\n  true\nend\n\ndef gen_rects(b, k, x, y, grnds, w, h)\n  rects = []\n\n  divk(k) do |w0, h0|\n    next if w0 > w || h0 > h\n\n    for y0 in (0...h0)\n      y1 = y - y0\n      y2 = y + h0 - 1 - y0\n      next if y1 < 0 || y2 >= h\n\n      for x0 in (0...w0)\n        x1 = x - x0\n        x2 = x + w0 - 1 - x0\n        next if x1 < 0 || x2 >= w\n\n        rect = [x1, y1, x2, y2]\n\n        if fit?(b, rect, grnds)\n          rects << rect\n        end\n      end\n    end\n  end\n\n  rects\nend\n\ndef fill_common(b, rects, grnds, w, h)\n  counts = grnds.map{|hl| hl.map{0}}\n\n  for r in rects\n    x1, y1, x2, y2 = r\n    for y in (y1..y2)\n      for x in (x1..x2)\n        counts[y][x] += 1\n      end\n    end\n  end\n\n  changed = false\n  rnum = rects.length\n\n  for y in (0...h)\n    for x in (0...w)\n      if counts[y][x] == rnum && grnds[y][x] == 0\n        grnds[y][x] = b\n        changed = true\n      end\n    end\n  end\n\n  changed\nend\n\n### main\n\nwhile true\n  w, h, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if w + h + n == 0\n\n  buyers = []\n  ksum = 0\n\n  for i in (1..n)\n    b, k = gets.strip.split(' ').map{|s| s.to_i}\n    buyers[b - 1] = [b, k]\n    ksum += k\n  end\n\n  if ksum != w * h\n    h.times.each{gets}\n    puts 'NA'\n    next\n  end\n\n  grnds = []\n\n  for y in (0...h)\n    hl = gets.strip.split(' ').map{|s| s.to_i}\n    grnds << hl\n  end\n\n  for y in (0...h)\n    for x in (0...w)\n      if grnds[y][x] > 0\n        b, k = buyers[grnds[y][x] - 1]\n        buyers[b - 1][2] = gen_rects(b, k, x, y, grnds, w, h)\n      end\n    end\n  end\n  #p grnds\n  #p buyers\n\n  while ! buyers.empty?\n    changed = false\n\n    for b0 in buyers\n      for r in b0[2].clone\n        if ! fit?(b0[0], r, grnds)\n          b0[2].delete(r)\n          changed = true\n        end\n      end\n    end\n\n    for b0 in buyers.clone\n      changed = fill_common(b0[0], b0[2], grnds, w, h) || changed\n      rnum = b0[2].length\n      if rnum == 1\n        buyers.delete(b0)\n        changed = true\n      elsif rnum == 0\n        changed = false\n        break\n      end\n    end\n    #p buyers\n\n    break if ! changed\n  end\n\n  if buyers.length > 0\n    puts 'NA'\n  else\n    for hl in grnds\n      puts hl.join(' ')\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef divk(k)\n  for i in (1..k)\n    if k % i == 0\n      yield k / i, i\n    end\n  end\nend\n\ndef fit?(b, rect, grnds)\n  x1, y1, x2, y2 = rect\n\n  for y in (y1..y2)\n    for x in (x1..x2)\n      return false if grnds[y][x] > 0 && grnds[y][x] != b\n    end\n  end\n  true\nend\n\ndef gen_rects(b, k, x, y, grnds, w, h)\n  rects = []\n\n  divk(k) do |w0, h0|\n    next if w0 > w || h0 > h\n\n    for y0 in (0...h0)\n      y1 = y - y0\n      y2 = y + h0 - 1 - y0\n      next if y1 < 0 || y2 >= h\n\n      for x0 in (0...w0)\n        x1 = x - x0\n        x2 = x + w0 - 1 - x0\n        next if x1 < 0 || x2 >= w\n\n        rect = [x1, y1, x2, y2]\n\n        if fit?(b, rect, grnds)\n          rects << rect\n        end\n      end\n    end\n  end\n\n  rects\nend\n\ndef fill_common(b, rects, grnds, w, h)\n  return false if rects.length == 0\n\n  counts = grnds.map{|hl| hl.map{0}}\n\n  for r in rects\n    x1, y1, x2, y2 = r\n    for y in (y1..y2)\n      for x in (x1..x2)\n        counts[y][x] += 1\n      end\n    end\n  end\n\n  changed = false\n  rnum = rects.length\n\n  for y in (0...h)\n    for x in (0...w)\n      if counts[y][x] == rnum && grnds[y][x] == 0\n        grnds[y][x] = b\n        changed = true\n      end\n    end\n  end\n\n  changed\nend\n\n### main\n\nwhile true\n  w, h, n = gets.strip.split(' ').map{|s| s.to_i}\n  break if w + h + n == 0\n\n  buyers = []\n  ksum = 0\n\n  n.times.each do\n    b, k = gets.strip.split(' ').map{|s| s.to_i}\n    buyers[b - 1] = [b, k]\n    ksum += k\n  end\n\n  if ksum != w * h\n    h.times.each{gets}\n    puts 'NA'\n    next\n  end\n\n  grnds = h.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n\n  for y in (0...h)\n    for x in (0...w)\n      b = grnds[y][x]\n      if b > 0\n        b0 = buyers[b - 1]\n        b0[2] = gen_rects(b0[0], b0[1], x, y, grnds, w, h)\n        fill_common(b0[0], b0[2], grnds, w, h)\n      end\n    end\n  end\n  #p grnds\n  #p buyers\n\n  while ! buyers.empty?\n    changed = false\n\n    for b0 in buyers\n      for r in b0[2].clone\n        if ! fit?(b0[0], r, grnds)\n          b0[2].delete(r)\n          changed = true\n        end\n      end\n    end\n\n    for b0 in buyers.clone\n      changed = fill_common(b0[0], b0[2], grnds, w, h) || changed\n      rnum = b0[2].length\n      if rnum == 1\n        buyers.delete(b0)\n        changed = true\n      elsif rnum == 0\n        changed = false\n        break\n      end\n    end\n    #p buyers\n\n    break if ! changed\n  end\n\n  if ! buyers.empty?\n    puts 'NA'\n  else\n    for hl in grnds\n      puts hl.join(' ')\n    end\n  end\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.array;\nimport std.conv;\nimport std.algorithm : map, find, min;\n\nvoid fill(T)(T[][] target, int sy, int sx, int ty, int tx, T[][] v) {\n    foreach (i; sy .. ty) {\n        foreach (j; sx .. tx) {\n            target[i][j] = v[i - sy][j -sx];\n        }\n    }\n}\n\nvoid fill(T)(T[][] target, int sy, int sx, int ty, int tx, T v) {\n    foreach (i; sy .. ty) {\n        foreach (j; sx .. tx) {\n            target[i][j] = v;\n        }\n    }\n}\n\nint[][] copy(int[][] src, int sy, int sx, int ty, int tx) {\n    int[][] backup = new int[][src.length];\n    foreach (ref _; backup) _ = new int[src[0].length];\n    foreach (i; sy .. ty) {\n        foreach (j; sx .. tx) {\n            backup[i - sy][j - sx] = src[i][j];\n        }\n    }\n    return backup;\n}\n\nvoid main() {\n    int X, Y, n;\n    int[] memo;\n    int[][] F;\n    bool[] used;\n    bool[][] mark;\n    int count = 0;\n    bool exist(int sy, int sx, int ty, int tx, int v) {\n        foreach (y; sy .. ty) {\n            foreach (x; sx .. tx) {\n                if (F[y][x] == v) return true;\n            }\n        }\n        return false;\n    }\n    bool onlyExist(int sy, int sx, int ty, int tx, int[] vs) {\n        foreach (y; sy .. ty) {\n            foreach (x; sx .. tx) {\n                if (vs.find(F[y][x]).empty) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    int[][] answer;\n    void check() { // 答えになっているか\n        if (!exist(0, 0, Y, X, 0)) {\n            count++;\n        }\n        fill(answer, 0, 0, Y, X, F);\n    }\n    void solve(int y, int x) {\n        if (y == Y) {\n            check();\n            return; // 基底\n        }\n        if (x == X) {\n            solve(y + 1, 0);\n            return;\n        }\n        if (mark[y][x]) {\n            solve(y, x + 1);\n            return;\n        }\n        const DEBUG = false;\n        static if (DEBUG) {\n            writeln(\"solve: \", [y, x]);\n            writeln(\"used: \", used.map!(to!int).array);\n            foreach (L; F) {\n                writeln(L);\n            }\n            writeln(\"mark\");\n            foreach (m; mark) {\n                writeln(m.map!(to!int).array);\n            }\n        }\n        foreach (i; 1 .. n + 1) {\n            if (used[i]) continue;\n            foreach (dy; 1 .. memo[i] + 1) {\n                if (y + dy > Y) continue;\n                if (memo[i] % dy != 0) continue;\n                int dx = memo[i] / dy;\n                if (x + dx > X) continue;\n                if ( !( exist(y, x, y + dy, x + dx, i) &&\n                        onlyExist(y, x, y + dy, x + dx, [0, i]) ) ) continue;\n                fill(mark, y, x, y + dy, x + dx, true);\n                int[][] backup = copy(F, y, x, y + dy, x + dx);\n                fill(F, y, x, y + dy, x + dx, i);\n                used[i] = true;\n                solve(y, x);\n                fill(mark, y, x, y + dy, x + dx, false);\n                F.fill(y, x, y + dy, x + dx, backup);\n                delete(backup);\n                used[i] = false;\n            }\n        }\n    }\n    while (readf(\"%d %d %d\\n\", &X, &Y, &n), X || Y || n) {\n        memo = new int[n + 1];\n        foreach (i; 0 .. n) {\n            int index, c; readf(\"%d %d\\n\", &index, &c);\n            memo[index] = c;\n        }\n        F = new int[][Y];\n        foreach (ref _; F) {\n            _ = readln.chomp.split(\" \").map!(to!int).array;\n        }\n        mark = new bool[][Y];\n        foreach (ref _; mark) {\n            _ = new bool[X];\n        }\n        used = new bool[n + 1];\n        answer = new int[][Y]; foreach (ref _; answer) _ = new int[X];\n        count = 0;\n        solve(0, 0);\n        if (count == 1) {\n            foreach (l; answer) {\n                l.map!(to!string).join(\" \").writeln;\n            }\n        } else {\n            \"NA\".writeln;\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.array;\nimport std.conv;\nimport std.algorithm : map, find, min;\n\nvoid fill(int[][] target, int sy, int sx, int ty, int tx, int[][] v) {\n    foreach (i; sy .. ty) {\n        foreach (j; sx .. tx) {\n            target[i][j] = v[i - sy][j -sx];\n        }\n    }\n}\n\nvoid fill(T)(T[][] target, int sy, int sx, int ty, int tx, T v) {\n    foreach (i; sy .. ty) {\n        foreach (j; sx .. tx) {\n            target[i][j] = v;\n        }\n    }\n}\n\nint[][] copy(int[][] src, int sy, int sx, int ty, int tx) {\n    int[][] backup = new int[][src.length];\n    foreach (ref _; backup) _ = new int[src[0].length];\n    foreach (i; sy .. ty) {\n        foreach (j; sx .. tx) {\n            backup[i - sy][j - sx] = src[i][j];\n        }\n    }\n    return backup;\n}\n\nvoid main() {\n    int X, Y, n;\n    int[] memo;\n    int[][] F;\n    bool[] used;\n    bool[][] mark;\n    int count = 0;\n    bool exist(int sy, int sx, int ty, int tx, int v) {\n        foreach (y; sy .. ty) {\n            foreach (x; sx .. tx) {\n                if (F[y][x] == v) return true;\n            }\n        }\n        return false;\n    }\n    bool onlyExist(int sy, int sx, int ty, int tx, int[] vs) {\n        foreach (y; sy .. ty) {\n            foreach (x; sx .. tx) {\n                if (vs.find(F[y][x]).empty) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    int[][] answer;\n    void check() { // 答えになっているか\n        if (!exist(0, 0, Y, X, 0)) {\n            count++;\n        }\n        fill(answer, 0, 0, Y, X, F);\n    }\n    void solve(int y, int x) {\n        if (y == Y) {\n            check();\n            return; // 基底\n        }\n        if (x == X) {\n            solve(y + 1, 0);\n            return;\n        }\n        if (mark[y][x]) {\n            solve(y, x + 1);\n            return;\n        }\n        const DEBUG = false;\n        static if (DEBUG) {\n            writeln(\"solve: \", [y, x]);\n            writeln(\"used: \", used.map!(to!int).array);\n            foreach (L; F) {\n                writeln(L);\n            }\n            writeln(\"mark\");\n            foreach (m; mark) {\n                writeln(m.map!(to!int).array);\n            }\n        }\n        foreach (i; 1 .. n + 1) {\n            if (used[i]) continue;\n            foreach (dy; 1 .. memo[i] + 1) {\n                if (y + dy > Y) continue;\n                if (memo[i] % dy != 0) continue;\n                int dx = memo[i] / dy;\n                if (x + dx > X) continue;\n                if ( !( exist(y, x, y + dy, x + dx, i) &&\n                        onlyExist(y, x, y + dy, x + dx, [0, i]) ) ) continue;\n                fill(mark, y, x, y + dy, x + dx, true);\n                int[][] backup = copy(F, y, x, y + dy, x + dx);\n                fill(F, y, x, y + dy, x + dx, i);\n                used[i] = true;\n                solve(y, x);\n                fill(mark, y, x, y + dy, x + dx, false);\n                F.fill(y, x, y + dy, x + dx, backup);\n                delete(backup);\n                used[i] = false;\n            }\n        }\n    }\n    while (readf(\"%d %d %d\\n\", &X, &Y, &n), X || Y || n) {\n        memo = new int[n + 1];\n        foreach (i; 0 .. n) {\n            int index, c; readf(\"%d %d\\n\", &index, &c);\n            memo[index] = c;\n        }\n        F = new int[][Y];\n        foreach (ref _; F) {\n            _ = readln.chomp.split(\" \").map!(to!int).array;\n        }\n        mark = new bool[][Y];\n        foreach (ref _; mark) {\n            _ = new bool[X];\n        }\n        used = new bool[n + 1];\n        answer = new int[][Y]; foreach (ref _; answer) _ = new int[X];\n        count = 0;\n        solve(0, 0);\n        if (count == 1) {\n            foreach (l; answer) {\n                l.map!(to!string).join(\" \").writeln;\n            }\n        } else {\n            \"NA\".writeln;\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "\n\ndef putpiece(bitmap,unused,pieces,numans,pcsans,FINFLAG):\n    # print(bin(bitmap))\n    # print(unused,\"***\",pieces,\"***\",numans)\n    if FINFLAG:\n        return numans,pcsans\n    if not unused:\n        pcsans = pieces\n        return numans + 1, pcsans\n    if numans > 1:\n        return 2, pieces\n    b,k,y,x = unused[-1]\n    # print(set([ (k//i,k//(k//i)) for i in range(1,min(X+1,k+1))]))\n    for h,w in set([ (k//i,k//(k//i)) for i in range(1,min(X+1,k+1)) if not (k//i)*(k//(k//i)) - k]):\n        for pt,qt in product(range(max(0,y-h+1),min(Y-h+1,y+1)),range(max(0,x-w+1),min(X-w+1,x+1))):\n            rt,st = pt+h-1, qt+w-1\n            piece = 0\n            piece2 = 0\n            for i in range(st-qt+1): piece |= 1 << i\n            for j in range(rt-pt+1): piece2 |= piece << j*X\n            piece = piece2\n            piece = piece << X-st-1\n            piece = piece << (Y-rt-1)*X\n            mark = 1\n            mark = mark << X-x-1\n            mark = mark << (Y-y-1)*X\n            if not (bitmap&piece)^mark: numans,pcsans = putpiece(bitmap|piece,unused[:-1],pieces+[[b,k,pt,qt,rt,st]],numans,pcsans,False)\n            if numans > 1: return 2, pcsans\n        if numans > 1: return 2, pcsans\n    else:\n        return numans,pcsans\n\n\nfrom itertools import product\nwhile(True):\n    numans = 0\n    pcsans = []\n    X,Y,n = map(int,input().split())\n    if not X: break\n    bk = sorted([list(map(int,input().split())) for _ in range(n)])\n    ss = [list(map(int,input().split())) for _ in range(Y)]\n    yxs = sorted([ss[i][j],i,j] for i,j in product(range(Y),range(X)) if ss[i][j])\n    bkyx = [ bk[i]+yxs[i][1:] for i in range(n)]\n    # from pprint import pprint\n    # pprint(bk)\n    # pprint(ss)\n    filled = \"\".join([ \"\".join([\"1\" if ss[i][j] else \"0\" for j in range(X)]) for i in range(Y)])\n    # pprint(filled)\n    # pprint([filled[i*X:i*X+X] for i in range(Y)])\n    # pprint(bkyx)\n    nans,pcs = putpiece(int(filled,2),bkyx,[],0,0,False)\n    # print(nans,pcs)\n    if nans > 1:\n        print(\"NA\")\n    elif nans:\n        toprint = [[0]*X for _ in range(Y)]\n        for i,m,sy,sx,ey,ex in pcs:\n            for j in range(sy,ey+1): toprint[j][sx:ex+1] = [i]*(ex-sx+1)\n        for a in toprint: print(\" \".join(str(b) for b in a))\n    else:\n        print(\"NA\")\n    # print(\"***********************************::\")\n    # break\n\n\n# numans = 0\n# mapans = []\n\n# bitmap,[[b1,k1,x1,y1]],[[p,q,r,s]]\n\n\n# if not len([]):\n#  numans += 0\n#  mapans = p,q,r,s\n#  return None\n\n# pt,qt,rt,st\n\n# if not bitmap & bitpiece\n#  bitmap |= bitpeace\n#  putpiece(bitmap|bitpiece,[][:-1],[]+[pt,qt,rt,st])\n \n\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef main(land, b):\n    for h in range(H):\n        for w in range(W):\n            if land[h][w] == b:\n                if f1(land, h, w, b, data[land[h][w]]):\n                    return True\n            \ndef f1(land, h, w, b, k):\n    for q in range(1, k+1):\n        if k%q == 0:\n            if f2(land, h, w, q, k/q, b):\n                return True\n    else:\n        return\n        \ndef f2(land, h, w, r, c, b):\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h-_h and 0 <= w-_w:\n                if f3(land, h-_h, w-_w, r, c, b):\n                    return True\n    else:\n        return\n                \ndef f3(land, h, w, r, c, b):\n    _land = copy.deepcopy(land)\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1:\n                if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b:\n                    _land[h+_h][w+_w] = b\n                else:\n                    return\n            else:\n                return\n    else:\n        if b < n:\n            return main(_land, b+1)\n        else:\n            for line in _land:\n                print ' '.join(map(str, line))\n            return True\n\nwhile True:\n    W, H, n = map(int, raw_input().split())\n    if H == W == n == 0: break\n    data = {}\n    for i in range(n):\n        b, k = map(int, raw_input().split())\n        data[b] = k\n    land = [map(int, raw_input().split()) for i in range(H)]\n    if not main(land, 1):\n        print 'NA'"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef main(land, b):\n    for h in range(H):\n        for w in range(W):\n            if land[h][w] == b:\n                if f1(land, h, w, b, data[land[h][w]]):\n                    return True\n            \ndef f1(land, h, w, b, k):\n    for q in range(1, k+1):\n        if k%q == 0:\n            if f2(land, h, w, q, k/q, b):\n                return True\n    else:\n        return\n        \ndef f2(land, h, w, r, c, b):\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h-_h and 0 <= w-_w:\n                if f3(land, h-_h, w-_w, r, c, b):\n                    return True\n    else:\n        return\n                \ndef f3(land, h, w, r, c, b):\n    global ans, count\n    _land = copy.deepcopy(land)\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1:\n                if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b:\n                    _land[h+_h][w+_w] = b\n                else:\n                    return\n            else:\n                return\n    else:\n        if b < n:\n            return main(_land, b+1)\n        else:\n            if count == 0:\n                ans = _land\n                count = 1\n            else:\n                ans = None\n                return True\n\nwhile True:\n    W, H, n = map(int, raw_input().split())\n    if H == W == n == 0: break\n    data = {}\n    for i in range(n):\n        b, k = map(int, raw_input().split())\n        data[b] = k\n    land = [map(int, raw_input().split()) for i in range(H)]\n    ans = None\n    count = 0\n    main(land, 1)\n    if ans:\n        for line in ans:\n            print ' '.join(map(str, line))\n    else:\n        print 'NA'"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nfrom copy import deepcopy\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\nMemo = namedtuple('Memo', 'buyer lot x y')\nfrom itertools import product\n\n\n\ndef placeable(lots, buyer, x, y, w, h):\n    if x < 0 or len(lots[0]) < x + w or y < 0 or len(lots) < y + h:\n        return False\n    for i, j in product(range(y, y + h), range(x, x + w)):\n        if lots[i][j] not in (0, buyer):\n            return False\n    return True\n\n\ndef place(lots, buyer, x, y, w, h):\n    tmp = deepcopy(lots)\n    for i, j in product(range(y, y + h), range(x, x + w)):\n        tmp[i][j] = buyer\n    return tmp\n\n\ndef solve(lots, memos):\n    if len(memos) == 0:\n        global ans, count\n        ans = lots\n        count += 1\n        return\n    m = memos[0]\n\n    for w in range(1, m.lot + 1):\n        if m.lot % w:\n            continue\n        h = m.lot // w\n        for y, x in product(range(m.y - h + 1, m.y + 1), range(m.x - w + 1, m.x + 1)):\n            if not placeable(lots, m.buyer, x, y, w, h):\n                continue\n            solve(place(lots, m.buyer, x, y, w, h), memos[1:])\n\n\ndef search_sign(lots, w, h):\n    sign = {}\n    for y, x in product(range(h), range(w)):\n        if lots[y][x]:\n            sign[lots[y][x]] = Point(x, y)\n    return sign\n\n\ndef main():\n    while True:\n        w, h, n = map(int, readline().split())\n        if w == 0:\n            break\n        memos = [map(int, readline().split()) for _ in range(n)]\n        lots = [list(map(int, readline().split())) for _ in range(h)]\n        sign = search_sign(lots, w, h)\n        memos = [Memo(b, l, sign[b].x, sign[b].y) for b, l in memos]\n        global ans, count\n        ans, count = None, 0\n        solve(lots, memos)\n        if count == 1:\n            for ai in ans:\n                print(*ai)\n        else:\n            print('NA')\nmain()"
  },
  {
    "language": "Python",
    "code": "from itertools import product\n# from line_profiler import LineProfiler\n\n\ndef putpiece(X,Y,bitmap,unused,pieces,numans,pcsans):\n    if not unused: return numans + 1, pieces\n    if numans > 1: return 2, pieces\n    b,k,y,x = unused[-1]\n    for h,w in set([ (k//i,k//(k//i)) for i in range(1,min(X+1,k+1)) if not (k//i)*(k//(k//i)) - k]):\n        ps, pe, qs, qe = max(0,y-h+1), min(Y-h+1,y+1), max(0,x-w+1), min(X-w+1,x+1)\n        for pt,qt in product(range(ps,pe),range(qs,qe)):\n            rt,st = pt+h-1, qt+w-1\n            piece = ( sum([2**(st-qt+1)-1 << j*X for j in range(rt-pt+1)]) << X-st-1 ) << (Y-rt-1)*X\n            mark = ( 1 << X-x-1 ) << (Y-y-1)*X\n            if not (bitmap&piece)^mark:\n                numans,pcsans = putpiece(X,Y,bitmap|piece,unused[:-1],pieces+[[b,k,pt,qt,rt,st]],numans,pcsans)\n            if numans > 1: return 2, pcsans\n    else:\n        return numans,pcsans\n\ndef main():\n    while(True):\n        X,Y,n = map(int,input().split())\n        if not X: break\n        bk = sorted([list(map(int,input().split())) for _ in range(n)])\n        ss = [list(map(int,input().split())) for _ in range(Y)]\n        yxs = sorted([ss[i][j],i,j] for i,j in product(range(Y),range(X)) if ss[i][j])\n        bkyx = [ bk[i]+yxs[i][1:] for i in range(n)]\n        filled = \"\".join([ \"\".join([\"1\" if ss[i][j] else \"0\" for j in range(X)]) for i in range(Y)])\n        nans,pcs = putpiece(X,Y,int(filled,2),bkyx,[],0,0)\n        if nans > 1:\n            print(\"NA\")\n        elif nans:\n            toprint = [[0]*X for _ in range(Y)]\n            for i,_,sy,sx,ey,ex in pcs:\n                for j in range(sy,ey+1): toprint[j][sx:ex+1] = [i]*(ex-sx+1)\n            for a in toprint: print(\" \".join(str(b) for b in a))\n        else:\n            print(\"NA\")\n\nif __name__ == \"__main__\":\n    # prf = LineProfiler()\n    # prf.add_function(main)\n    # prf.add_function(putpiece)\n    # prf.runcall(main)\n    # prf.print_stats()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef main(land, b):\n    for h in range(H):\n        for w in range(W):\n            if land[h][w] == b:\n                if f1(land, h, w, b, data[land[h][w]]):\n                    return True\n            \ndef f1(land, h, w, b, k):\n    for q in range(1, k+1):\n        if k%q == 0:\n            if f2(land, h, w, q, k/q, b):\n                return True\n    else:\n        return\n        \ndef f2(land, h, w, r, c, b):\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h-_h and 0 <= w-_w:\n                if f3(land, h-_h, w-_w, r, c, b):\n                    return True\n    else:\n        return\n                \ndef f3(land, h, w, r, c, b):\n    _land = copy.deepcopy(land)\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1:\n                if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b:\n                    _land[h+_h][w+_w] = b\n                else:\n                    return\n            else:\n                return\n    else:\n        if b < n:\n            return main(_land, b+1)\n        else:\n            for line in _land:\n                print ' '.join(map(str, line))\n            return True\n\nwhile True:\n    W, H, n = map(int, raw_input().split())\n    if H == W == n == 0: break\n    data = {}\n    for i in range(n):\n        b, k = map(int, raw_input().split())\n        data[b] = k\n    land = [map(int, raw_input().split()) for i in range(H)]\n    main(land, 1)"
  },
  {
    "language": "Python",
    "code": "from itertools import product\n# from line_profiler import LineProfiler\n\n\ndef putpiece(X,Y,bitmap,unused,pieces,numans,pcsans,FINFLAG):\n    if FINFLAG:\n        return numans,pcsans\n    if not unused:\n        pcsans = pieces\n        return numans + 1, pcsans\n    if numans > 1:\n        return 2, pieces\n    b,k,y,x = unused[-1]\n    for h,w in set([ (k//i,k//(k//i)) for i in range(1,min(X+1,k+1)) if not (k//i)*(k//(k//i)) - k]):\n        for pt,qt in product(range(max(0,y-h+1),min(Y-h+1,y+1)),range(max(0,x-w+1),min(X-w+1,x+1))):\n            rt,st = pt+h-1, qt+w-1\n            piece = 2**(st-qt+1)-1\n            piece2 = 0\n            for j in range(rt-pt+1): piece2 |= piece << j*X\n            piece = ( piece2 << X-st-1 ) << (Y-rt-1)*X\n            mark = ( 1 << X-x-1 ) << (Y-y-1)*X\n            if not (bitmap&piece)^mark: numans,pcsans = putpiece(X,Y,bitmap|piece,unused[:-1],pieces+[[b,k,pt,qt,rt,st]],numans,pcsans,False)\n            if numans > 1: return 2, pcsans\n    else:\n        return numans,pcsans\n\ndef main():\n    while(True):\n        X,Y,n = map(int,input().split())\n        if not X: break\n        bk = sorted([list(map(int,input().split())) for _ in range(n)])\n        ss = [list(map(int,input().split())) for _ in range(Y)]\n        yxs = sorted([ss[i][j],i,j] for i,j in product(range(Y),range(X)) if ss[i][j])\n        bkyx = [ bk[i]+yxs[i][1:] for i in range(n)]\n        filled = \"\".join([ \"\".join([\"1\" if ss[i][j] else \"0\" for j in range(X)]) for i in range(Y)])\n        nans,pcs = putpiece(X,Y,int(filled,2),bkyx,[],0,0,False)\n        if nans > 1:\n            print(\"NA\")\n        elif nans:\n            toprint = [[0]*X for _ in range(Y)]\n            for i,_,sy,sx,ey,ex in pcs:\n                for j in range(sy,ey+1): toprint[j][sx:ex+1] = [i]*(ex-sx+1)\n            for a in toprint: print(\" \".join(str(b) for b in a))\n        else:\n            print(\"NA\")\n\nif __name__ == \"__main__\":\n    # prf = LineProfiler()\n    # prf.add_function(main)\n    # prf.add_function(putpiece)\n    # prf.runcall(main)\n    # prf.print_stats()\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef main(land, b):\n    for h in range(H):\n        for w in range(W):\n            if land[h][w] == b:\n                if f1(land, h, w, b, data[land[h][w]]):\n                    return\n            \ndef f1(land, h, w, b, k):\n    for q in range(1, k+1):\n        if k%q == 0:\n            if f2(land, h, w, q, k/q, b):\n                return True\n    else:\n        return\n        \ndef f2(land, h, w, r, c, b):\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h-_h and 0 <= w-_w:\n                if f3(land, h-_h, w-_w, r, c, b):\n                    return True\n    else:\n        return\n                \ndef f3(land, h, w, r, c, b):\n    _land = copy.deepcopy(land)\n    for _h in range(r):\n        for _w in range(c):\n            if 0 <= h+_h <= H-1 and 0 <= w+_w <= W-1:\n                if _land[h+_h][w+_w] == 0 or _land[h+_h][w+_w] == b:\n                    _land[h+_h][w+_w] = b\n                else:\n                    return\n            else:\n                return\n    else:\n        if b < n:\n            return main(_land, b+1)\n        else:\n            for line in _land:\n                print ' '.join(map(str, line))\n            return True\n\nwhile True:\n    W, H, n = map(int, raw_input().split())\n    if H == W == n == 0: break\n    data = {}\n    for i in range(n):\n        b, k = map(int, raw_input().split())\n        data[b] = k\n    land = [map(int, raw_input().split()) for i in range(H)]\n    main(land, 1)"
  },
  {
    "language": "Python",
    "code": "from itertools import product\n# from line_profiler import LineProfiler\n\n\ndef putpiece(X,Y,bitmap,unused,pieces,numans,pcsans):\n    if not unused: return numans + 1, pieces\n    if numans > 1: return 2, pieces\n    b,k,y,x = unused[-1]\n    for h,w in set([ (k//i,k//(k//i)) for i in range(1,min(X+1,k+1)) if not (k//i)*(k//(k//i)) - k]):\n        ps, pe, qs, qe = max(0,y-h+1), min(Y-h+1,y+1), max(0,x-w+1), min(X-w+1,x+1)\n        for pt,qt in product(range(ps,pe),range(qs,qe)):\n            rt,st = pt+h-1, qt+w-1\n            piece = ( sum([2**(st-qt+1)-1 << j*X for j in range(rt-pt+1)]) << X-st-1 ) << (Y-rt-1)*X\n            mark = ( 1 << X-x-1 ) << (Y-y-1)*X\n            if not (bitmap&piece)^mark:\n                numans,pcsans = putpiece(X,Y,bitmap|piece,unused[:-1],pieces+[[b,k,pt,qt,rt,st]],numans,pcsans)\n            if numans > 1: return 2, pcsans\n    else:\n        return numans,pcsans\n\ndef main():\n    while(True):\n        X,Y,n = map(int,input().split())\n        if not X: break\n        bk = sorted([list(map(int,input().split())) for _ in range(n)])\n        ss = [list(map(int,input().split())) for _ in range(Y)]\n        yxs = sorted([ss[i][j],i,j] for i,j in product(range(Y),range(X)) if ss[i][j])\n        bkyx = [ bk[i]+yxs[i][1:] for i in range(n)]\n        filled = \"\".join([ \"\".join([\"1\" if ss[i][j] else \"0\" for j in range(X)]) for i in range(Y)])\n        nans,pcs = putpiece(X,Y,int(filled,2),bkyx,[],0,0)\n        if nans > 1:\n            print(\"NA\")\n        elif nans:\n            toprint = [[0]*X for _ in range(Y)]\n            for i,_,sy,sx,ey,ex in pcs:\n                for j in range(sy,ey+1): toprint[j][sx:ex+1] = [i]*(ex-sx+1)\n            for a in toprint: print(\" \".join(str(b) for b in a))\n        else:\n            print(\"NA\")\n\nif __name__ == \"__main__\":\n    # prf = LineProfiler()\n    # prf.add_function(main)\n    # prf.add_function(putpiece)\n    # prf.runcall(main)\n    # prf.print_stats()\n    main()\n"
  }
]