[
  {
    "language": "Fortran",
    "code": "program reachable_cells\n  implicit none\n  integer :: n, a(501,501) = 0, i, j, k, dp(500,500) = 0, ans = 0\n  character(500) :: s\n  read(*,*) n\n  a(:,n+1) = -1\n  a(n+1,:) = -1\n  do i = 1, n\n    read(*,*) s\n    do j = 1, n\n      if (s(j:j) == \"#\") then\n        a(i,j) = -1\n        cycle\n      end if\n      a(i,j) = ichar(s(j:j))-48\n    end do\n  end do\n  do k = 0, 2*(n-1)\n    do i = n, max(n-k,1), -1\n      j = 2*n-i-k\n      if (j < 1 .or. n < j) cycle\n      if (a(i,j) < 0) cycle\n      if (dp(i+1,j) > 0) dp(i,j) = dp(i,j)+dp(i+1,j)\n      if (dp(i,j+1) > 0) dp(i,j) = dp(i,j)+dp(i,j+1)\n      if (dp(i+1,j) > 0 .and. dp(i,j+1) > 0 .and. dp(i+1,j+1) > 0) dp(i,j) = dp(i,j)-dp(i+1,j+1)\n      ans = ans+a(i,j)*dp(i,j)\n      dp(i,j) = dp(i,j)+a(i,j)\n    end do\n  end do\n  write(*,'(i0)') ans\nend program reachable_cells"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1<<29)\nusing namespace std;\nconst int N=505;\nchar s[N];\nint n,cnt[N];\nll ans;\nint a[N][N],sum[N][N];\nint l[N][N],r[N][N];\nint tl[N][N],tr[N][N];\nvoid recalc(int i){\n\tFor(j,1,n) sum[i][j]=sum[i][j-1]+a[i][j];\n}\nint S(int i,int l,int r){\n\treturn sum[i][r]-(l?sum[i][l-1]:0);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFor(j,1,n) a[i][j]=(s[j]=='#'?0:s[j]-48);\n\t\trecalc(i);\n\t}\n\tFor(i,1,n) For(j,1,n)\n\t\tl[i][j]=n+1,r[i][j]=0;\n\tRep(x,n,1){\n\t\tFor(i,1,n) For(j,1,n)\n\t\t\ttl[i][j]=n+1,tr[i][j]=0;\n\t\tFor(y,x,n)\n\t\t\tif (y==x){\n\t\t\t\tRep(j,n,1) if(a[y][j]){\n\t\t\t\t\ttl[y][j]=j;\n\t\t\t\t\ttr[y][j]=max(j,j==n?0:tr[y][j+1]);\n\t\t\t\t\tans+=1ll*a[y][j]*S(y,tl[y][j]+1,tr[y][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tRep(j,n,1) if (a[x][j]){\n\t\t\t\t\ttl[y][j]=min(l[y][j],j==n?n+1:tl[y][j+1]);\n\t\t\t\t\ttr[y][j]=max(r[y][j],j==n?0:tr[y][j+1]);\n\t\t\t\t}\n\t\t\t\tFor(j,1,n) cnt[j]=0;\n\t\t\t\tFor(j,1,n) if (tl[y][j]<=tr[y][j]){\n\t\t\t\t\t++cnt[tl[y][j]];\n\t\t\t\t\t--cnt[tr[y][j]+1];\n\t\t\t\t}\n\t\t\t\tFor(j,1,n){\n\t\t\t\t\tcnt[j]+=cnt[j-1];\n\t\t\t\t\tif (!cnt[j]&&a[y][j])\n\t\t\t\t\t\ta[y][j]=0,recalc(y);\n\t\t\t\t}\n\t\t\t\tFor(j,1,n)\n\t\t\t\t\tif (tl[y][j]<=tr[y][j])\n\t\t\t\t\t\tans+=1ll*a[x][j]*S(y,tl[y][j],tr[y][j]);\n\t\t\t}\n\t\tFor(i,1,n) For(j,1,n)\n\t\t\tl[i][j]=tl[i][j],r[i][j]=tr[i][j];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nchar f[505][505];\nbitset<500*500*9+5>B[2][505];\nll ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\tint cur = 0,nxt = 1;\n\tfor(int i=0;i<2*n-1;i++){\n\t\trep(i,n) B[nxt][i].reset();\n\t\tfor(int j=max(0,i-n+1);j<=min(i,n-1);j++){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t\tif(y) B[nxt][x] |= B[cur][x];\n\t\t\t\tif(x) B[nxt][x] |= B[cur][x-1];\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[nxt][x].count());\n\t\t\t\trep(a,f[x][y]-'0') B[nxt][x][9*(x*n+y)+a] = 1;\n\t\t\t}\n\t\t}\n\t\tswap(cur,nxt);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a ? gcd (b % a, a) : b; }\n\nconst int N = 500;\n\nint n;\nint m;\nll ans = 0;\nint g[N][N];\nii q[N * N];\nint used[N][N];\nint was[N][N];\nint cur;\nint l, r;\n\nint go (int i, int j) {\n\tif (i >= n || j >= n || g[i][j] == 0 || was[i][j]) re 0;\n\twas[i][j] = 1;\n\tint cr = r;\n\tq[r++] = mp (i, j);\n\tused[i][j] = 1;\n\twhile (l < r) {\n\t\tint x = q[l].fi;\n\t\tint y = q[l].se;\n//\t\tprintf (\"add %d %d\\n\", x, y);\n\t\tcur += g[x][y];\n\t\tl++;\n\t\tfor (int t = 0; t < 2; t++) {\n\t\t\tint nx = x - int (t == 0);\n\t\t\tint ny = y - int (t == 1);\n\t\t\tif (nx >= 0 && ny >= 0 && !used[nx][ny] && g[nx][ny] > 0) {\n\t\t\t\tq[r++] = mp (nx, ny);\n\t\t\t\tused[nx][ny] = 1;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf (\"%d %d = %d\\n\", i, j, cur);\n\tans += (ll)(cur - g[i][j]) * g[i][j];\n\tgo (i, j + 1);\n\tgo (i + 1, j);\n\twhile (r > cr) {\n\t\tr--;\n\t\tint x = q[r].fi;\n\t\tint y = q[r].se;\n//\t\tprintf (\"del %d %d\\n\", x, y);\n\t\tcur -= g[x][y]; \n\t\tused[x][y] = 0;\n\t}\n\tl = r;\n//\tprintf (\"%d %d = %d\\n\", i, j, cur);\n\tre 0;\n}\n\nint main () {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (s[j] == '#')\n\t\t\t\tg[i][j] = 0;\n\t\t\telse\n\t\t\t\tg[i][j] = s[j] - '0';\t\n\t}\t\n\tl = r = 0;\n\tcur = 0;\n\tans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (!was[i][j] && g[i][j] > 0)\n\t\t\t\tgo (i, j);\n\tcout << ans << endl;\n\tcerr << clock () << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#define M 1502\n#define wall 10\nusing namespace std;\nstruct loc {\n\tint x, y;\n};\nchar a[M][M];\nint chk[M][M];\nint ans,n;\nvoid dfs(loc cur,loc s,int val) {\n\tchk[cur.x][cur.y] = val;\n\tif (cur.x != s.x || cur.y != s.y) ans += a[cur.x][cur.y] * a[s.x][s.y];\n\tloc next;\n\tnext.x = cur.x + 1; next.y = cur.y;\n\tif (a[next.x][next.y]!=wall && chk[next.x][next.y] != val && next.x<n) dfs(next, s,val);\n\tnext.x = cur.x; next.y = cur.y + 1;\n\tif (a[next.x][next.y] != wall && chk[next.x][next.y] != val && next.y<n) dfs(next, s,val);\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tint i, j,k,l;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tscanf(\" %c\", &a[i][j]);\n\t\t\tif (a[i][j] == '#') a[i][j] = wall;\n\t\t\telse a[i][j] -= '0';\n\t\t\tchk[i][j] = -1;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tloc cur;\n\t\t\tcur.x = i; cur.y = j;\n\t\t\tif(a[i][j]!=wall) dfs(cur,cur,i*n+j);\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[510][510];\nint Up[510][510], Down[510][510];\nint B[510][510], E[510][510], BB[510], EE[510], S[510];\nint T[510][510], v[510];\nint n, w[510][510], L[510], R[510];\nlong long res;\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", p[i] + 1);\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif(p[i][j]>='0' && p[i][j]<='9')w[i][j] = p[i][j] - '0';\n\t\t\telse w[i][j] = -1;\n\t\t}\n\t}\n\tfor (i = 0; i <= n + 1; i++)for (j = 0; j <= n + 1; j++)if (i == 0 || i > n || j == 0 || j > n)w[i][j] = -1;\n\tfor (i = n; i >= 1; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (w[i][j] == -1)continue;\n\t\t\tDown[i][j] = i;\n\t\t\tDown[i][j] = max(Down[i][j], Down[i][j + 1]);\n\t\t\tDown[i][j] = max(Down[i][j], Down[i + 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tUp[i][j] = n + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tUp[i][j] = i;\n\t\t\tif(w[i][j-1] != -1)Up[i][j] = min(Up[i][j], Up[i][j - 1]);\n\t\t\tif(w[i-1][j] != -1)Up[i][j] = min(Up[i][j], Up[i - 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint pv = 0, s = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tpv = j;\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\ts = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT[i][j] = pv + 1;\n\t\t\tres += s*w[i][j];\n\t\t\ts += w[i][j];\n\t\t\tint b = T[i][j], e = j;\n\t\t\tif (i != 1) {\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\tfor (k = b; k <= e; k++) {\n\t\t\t\t\tif (w[i - 1][k] != -1) {\n\t\t\t\t\t\tB[i][j] = min(B[i][j], T[i - 1][k]);\n\t\t\t\t\t\tE[i][j] = max(E[i][j], k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) BB[j] = B[i][j], EE[j] = E[i][j];\n\t\tfor (j = i - 1; j >= 1; j--) {\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tS[k] = S[k - 1];\n\t\t\t\tif (Down[j][k] >= i) {\n\t\t\t\t\tS[k] += w[j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 1) {\n\t\t\t\t\tif (Up[j][k]<=j-1)v[k] = 1;\n\t\t\t\t\telse v[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tif (Up[i][k]<=j) {\n\t\t\t\t\tres += (S[EE[k]] - S[BB[k] - 1])*w[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == 1)break;\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tL[k] = L[k - 1];\n\t\t\t\tif (v[k])L[k] = k;\n\t\t\t}\n\t\t\tR[n + 1] = n + 1;\n\t\t\tfor (k = n; k >= 1; k--) {\n\t\t\t\tR[k] = R[k + 1];\n\t\t\t\tif (v[k])R[k] = k;\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tint b = BB[k], e = EE[k];\n\t\t\t\tif (Up[i][k] >= j)continue;\n\t\t\t\tBB[k] = B[j][R[b]], EE[k] = E[j][L[e]];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nconst int maxn = 1510;\n\nint n, m, col[maxn][maxn], a[maxn][maxn], tag[maxn][maxn], qx[maxn * maxn], qy[maxn * maxn];\nbool vis[maxn * maxn];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstatic char s[maxn];\n\t\tscanf(\"%s\", s + 1);\n\t\tfor (int j = 1; j <= n; ++j) a[i][j] = (s[j] == '#' ? 0 : s[j] - '0');\n\t}\n\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) if(a[i][j]) {\n\t\tif(col[i - 1][j] && col[i - 1][j + 1] != col[i - 1][j]) col[i][j] = col[i - 1][j];\n\t\telse {\n\t\t\tif(col[i][j - 1]) col[i][j] = col[i][j - 1];\n\t\t\telse col[i][j] = ++m;\n\t\t}\n\t}\n#ifdef DEBUG\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) printf(\"%d%c\", col[i][j], \" \\n\"[j == n]);\n\t}\n#endif\n\tlong long ans = 0;\n\tfor (int i = n; i; --i) for (int C, j = n; j; --j) if(a[i][j] && !vis[C = col[i][j]]) {\n\t\tvis[C = col[i][j]] = 1;\n\t\tint x = i, y = j; long long sum = 0; int fnt, rar;\n\t\tfor(;;) {\n\t\t\tfnt = rar = 0;\n#ifdef DEBUG\n\t\t\tprintf(\"bfs(%d, %d)\\n\", x, y);\n#endif\n\t\t\tqx[rar] = x; qy[rar] = y; ++rar; sum += a[x][y]; tag[x][y] = C;\n\t\t\twhile(fnt != rar) {\n\t\t\t\tint x = qx[fnt], y = qy[fnt]; ++fnt;\n#ifdef DEBUG\n\t\t\t\tprintf(\"\\t%d %d\\n\", x, y);\n#endif\n\t\t\t\tif(tag[x][y + 1] != C && a[x][y + 1]) qx[rar] = x, qy[rar] = y + 1, ++rar, tag[x][y + 1] = C, sum += a[x][y + 1];\n\t\t\t\tif(tag[x + 1][y] != C && a[x + 1][y]) qx[rar] = x + 1, qy[rar] = y, ++rar, tag[x + 1][y] = C, sum += a[x + 1][y];\n\t\t\t}\n\t\t\tans += (sum - a[x][y]) * a[x][y];\n#ifdef DEBUG\n\t\t\tprintf(\"sum = %\"LLFORMAT\"d\\n\", sum);\n\t\t\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) printf(\"%d%c\", tag[i][j], \" \\n\"[j == n]);\n#endif\n\t\t\tif(col[x - 1][y] == C) --x;\n\t\t\telse if(col[x][y - 1] == C) --y;\n\t\t\telse break;\n\t\t}\n\t}\n\tprintf(\"%\"LLFORMAT\"d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=1505;\nint n,a[N][N];\nshort L[N],R[N];\nshort cnt[N],S[N];\nchar s[N];\nll ans;\n//120692274455805\nvoid Mx(short &x,short y){\n\tx<y?x=y:233;\n}\nvoid Mn(short &x,short y){\n\tx>y?x=y:233;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFor(j,1,n) a[i][j]=(s[j]=='#'?0:s[j]-'0');\n\t}\n\tRep(i,n,1){\n\t\tFor(j,1,n)\n\t\t\tS[j]=S[j-1]+a[i][j];\n\t\tRep(j,n+1,1)\n\t\t\tif (a[i][j]){\n\t\t\t\tL[j]=j;\n\t\t\t\tR[j]=(R[j+1]?R[j+1]:j);\n\t\t\t\tans+=a[i][j]*(S[R[j]]-S[j]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tL[j]=n+1,R[j]=0;\n\t\tRep(j,i-1,1){\n\t\t\tmemset(cnt,0,2*(n+1));\n\t\t\tRep(k,n,1)\n\t\t\t\tif (a[j][k]){\n\t\t\t\t\tL[k]=(L[k]==n+1?L[k+1]:L[k]);\n\t\t\t\t\tR[k]=(R[k+1]==0?R[k]:R[k+1]);\n\t\t\t\t\tif (R[k]){\n\t\t\t\t\t\tcnt[L[k]]++; cnt[R[k]+1]--;\n\t\t\t\t\t\tans+=a[j][k]*(S[R[k]]-S[L[k]-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tL[k]=n+1,R[k]=0;\n\t\t\tFor(k,1,n){\n\t\t\t\tcnt[k]+=cnt[k-1];\n\t\t\t\tif (!cnt[k]&&a[i][k]){\n\t\t\t\t\tFor(L,k,n) S[L]-=a[i][k]; \n\t\t\t\t\ta[i][k]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n//#include <bits/stdc++.h>\n#include <stack>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <stack>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef int LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nlong long ans = 0;\nlong long sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE];\nint val[SIZE][SIZE];\nLL times = 0,times2=0;\ninline LL dfs(int y, int x) {\n//\ttimes++;\n\tif (y > N or x > N or A[y][x] == 0 or reached[y][x]) return 0;\n\treached[y][x] = true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs252(int yy, int xx) {\n\tstack<pr> st;\n\tst.emplace(yy, xx);\n\tint ret = 0;\n\twhile (!st.empty()) {\n\t\tint y=st.top().first, x=st.top().second;\n\t\tif (val[y][x] == 0) {\n\t\t\tval[y][x] = -1;\n\t\t\treached[y][x] = 0;\n\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) st.emplace(y, x+1);\n\t\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) st.emplace(y + 1, x);\n\t\t}\n\t\telse {\n\t\t\tval[y][x] = val[y][x + 1] + val[y + 1][x];\n//\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) ret+=val[y][x + 1];\n\t//\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) ret+=val[y][x+1];\n\t\t\tst.pop();\n\t\t}\n\t}\n//\treached[y][x] = 0;\n//\treturn  (( ? dfs2(y, x + 1) : 0) + ( : 0) + A[y][x]);\n\treturn val[yy][xx];\n\n}\n\ninline LL dfs2(int y, int x) {\n\t//times++;\n\treached[y][x] = 0;\n\treturn  (((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0) ? dfs2(y, x + 1) : 0 )+ ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x]) ? dfs2(y + 1, x) : 0) + A[y][x]);\n}\nlong long solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i, 1, N) {\n\t\t//cout << \"A\";\n\t\tsum += dfs(x, i);\n\t\t//cout << \"B\";\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tsum -= A[x][i];\n\t\tans += (long long)sum* (long long)A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tif (A[x + 1][i] == 0) continue;\n\t\tif (reached[x + 1][i] == 0) continue;\n\t\tif (reached[x][i]) continue;\n\n\t\tsum -= dfs2(x + 1, i);\n\t//\tcout << \"C\" << endl;\n\n\t}\n//\tcout << times << \" \" << times2 << endl;\n\treturn ans;\n}\nlong long solve() {\n\tcin >> N;\n\tEFOR(i, 1, N) {\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1] - '0';\n\t\t}\n\t}\n//\tN = 300;\n//\tEFOR(i, 1, N) EFOR(j, 1, N) A[i][j] = 9;\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int inc(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=1005,M=1e7+5;\nchar s[N];int a[N][N],f[N][N],rt[N][N],n,res;\nint ls[M],rs[M],sz[M],nd;\nint merge(int x,int y,int l,int r){\n\tif(!x||!y)return x|y;\n\tif(l==r)return sz[++nd]=sz[x]|sz[y],nd;\n\tint t=++nd,mid=(l+r)>>1;\n\tls[t]=merge(ls[x],ls[y],l,mid),rs[t]=merge(rs[x],rs[y],mid+1,r);\n\tsz[t]=sz[ls[t]]+sz[rs[t]];\n\treturn t;\n}\nvoid ins(int &p,int q,int l,int r,int x,int v){\n\tp=++nd,ls[p]=ls[q],rs[p]=rs[q],sz[p]=sz[q]+v;if(l==r)return;\n\tint mid=(l+r)>>1;\n\tx<=mid?ins(ls[p],ls[p],l,mid,x,v):ins(rs[p],rs[p],mid+1,r,x,v);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfp(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tfp(j,1,n)a[i][j]=s[j]=='#'?0:s[j]-'0';\n\t}\n\tfd(k,n,1){\n\t\tfor(R int i=k,j=n;i<=n;++i,--j)if(a[i][j]){\n\t\t\tif(a[i+1][j])rt[i][j]=merge(rt[i][j],rt[i+1][j],1,n*n);\n\t\t\tif(a[i][j+1])rt[i][j]=merge(rt[i][j],rt[i][j+1],1,n*n);\n\t\t\tres+=a[i][j]*sz[rt[i][j]];\n//\t\t\tprintf(\"%d %d %d\\n\",i,j,sz[rt[i][j]]);\n\t\t}\n\t\tfor(R int i=k,j=n;i<=n;++i,--j)if(a[i][j])ins(rt[i][j],rt[i][j],1,n*n,(i-1)*n+j,a[i][j]);\n\t}\n\tfd(k,n-1,1){\n\t\tfor(R int i=k,j=1;i;--i,++j)if(a[i][j]){\n\t\t\tif(a[i+1][j])rt[i][j]=merge(rt[i][j],rt[i+1][j],1,n*n);\n\t\t\tif(a[i][j+1])rt[i][j]=merge(rt[i][j],rt[i][j+1],1,n*n);\n\t\t\tres+=a[i][j]*sz[rt[i][j]];\n//\t\t\tprintf(\"%d %d %d\\n\",i,j,sz[rt[i][j]]);\n\t\t}\n\t\tfor(R int i=k,j=1;i;--i,++j)if(a[i][j])ins(rt[i][j],rt[i][j],1,n*n,(i-1)*n+j,a[i][j]);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar a[M][M];\nint f[M][M],l[M][M],r[M][M];\n\nint main () {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) scanf(\"%s\",a[i]+1);\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) \n\t\tif(isdigit(a[i][j])) {\n\t\t\tbool t[2]={isdigit(a[i+1][j]),isdigit(a[i][j+1])};\n\t\t\tif(!t[0]&&!t[1]) {\n\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\t\tfor1(i+1,n,k) l[j][k]=n+1,r[j][k]=0;\n\t\t\t}\n\t\t\telse if(!t[0]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[j][i]=j,r[j][i]=r[j+1][i];\n\t\t\t\tfor1(i+1,n,k) l[j][k]=l[j+1][k],r[j][k]=r[j+1][k];\n\t\t\t}\n\t\t\telse if(!t[1]) {\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint las=0;\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[j][i]=j,r[j][i]=r[j+1][i];\n\t\t\t\t\nint flag = 1;\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[j+1][k]<=r[j][k]&&flag) tot-=f[k][l[j+1][k]];\nflag = l[j+1][k]>r[j][k];\n\t\t\t\t\tl[j][k]=min(l[j][k],l[j+1][k]);\n\t\t\t\t\tr[j][k]=max(r[j][k],r[j+1][k]); \n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t\tans+=f[i][j]*(a[i][j]-'0');\n\t\t\tf[i][j]+=a[i][j]-'0';\n\t\t}\n\t\telse l[j][i]=n+1,r[j][i]=0;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define GET(x,y) *(map+((y-1)*(n+1))+(x-1))\n#define NUM(x,y) ((GET(x,y))-'0')\n\nint n;\nchar* map;\n\nint isOK(int Xx,int Xy,int Yx,int Yy)\n{\n  if( (Xx==Yx)&&(Xy==Yy) ) return 1;\n  if(Xx>Yx) return 0; \n  if(Xy>Yy) return 0; \n  if( '#' == GET(Xx, Xy) ) return 0;\n  if( isOK(Xx+1, Xy, Yx, Yy) ) return 1;\n  if( isOK(Xx, Xy+1, Yx, Yy) ) return 1;\n  return 0;\n}\n\nint calc(int Xx,int Xy,int Yx,int Yy)\n{\n  int x,y;\n  int ok=isOK(Xx,Xy,Yx,Yy);\n//  printf(\"%d,%d,%d,%d=%d/\", Xx,Xy,Yx,Yy, ok);\n  return ok*NUM(Xx,Xy)*NUM(Yx,Yy);\n}\n\nint main(void)\n{\n  int i;\n  int sum=0;\n  int Xx,Xy,Yx,Yy;\n  scanf(\"%d\",&n); \n//  printf (\"%d\\n\",n);\n  map = malloc((n+1)*(n+1));\n\n  for(i=0;i<n;i++)\n    scanf(\"%s\",(map+(n+1)*i)); \n//  for(i=0;i<n;i++)\n//    printf(\"%s\\n\",(map+(n+1)*i));\n\n  for(Xx=1;Xx<=n;Xx++)\n  {\n    for(Xy=1;Xy<=n;Xy++)\n    {\n      if( '#' == GET(Xx, Xy) ) continue;\n      for(Yx=1;Yx<=n;Yx++)\n      {\n        for(Yy=1;Yy<=n;Yy++)\n        {\n          if( (Xx>=Yx) && (Xy>=Yy) ) continue;\n          if( '#' == GET(Yx, Yy) )\n          {\n//            if( (Xx == Yx) || (Xy == Yy ) ) break; \n            continue;\n          }\n          sum += calc(Xx,Xy,Yx,Yy);\n        }\n      }      \n    }\n  }\n  printf( \"%d\", sum );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// doot diddly donger cuckerino Hahahahahah\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int LL;\ntypedef unsigned int UINT;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PII;\ntypedef pair<string, int> PSI;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef vector<bool> VB;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef tuple<int, int, int> TPL;\ntypedef priority_queue<int> pqueue;\ntypedef priority_queue<int, VI, greater<int>> pdqueue;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, 1, 0, -1, -1, 1, -1, 1};\nconst int dxhorse[] = {-2, -2, -1, -1, 1, 1, 2, 2};\nconst int dyhorse[] = {1, -1, 2, -2, 2, -2, 1, -1};\n\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define endl \"\\n\"\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define F first\n#define S second\n#define SZ(x)           (x).size()\n#define MAX(a, b)      ((a)>(b)?(a):(b))\n#define MIN(a, b)      ((a)<(b)?(a):(b))\n#define ALL(a)         std::begin(a), std::end(a)\n#define Fill(n, x)      memset(n,x,sizeof n);\n#define IN_REP         int _t; cin >> _t ; while(_t--)\n#define IOS            ios::sync_with_stdio(false);cin.tie(NULL)\n#define FOR(i, a, b)    for(int i=(a);i<(b);i++)\n#define REP(i, n)       FOR(i,0,n)\n#define FORR(i, n)      for(int i=(n);i>=0;i--)\n#define EPS (double) 1e-9\n#define MOD (1000*1000*1000 + 7)\n#define INF 1011111111\n#define LLINF 1000111000111000111LL\nint n;\nVS c;\nVVI a;\nvector<VB> v;\n\nbool reachable(int x1, int y1, int x2, int y2) {\n    if (x2 < x1 || y2 < y1 || x1 < 0 || x2 < 0 || y1 >= n || y2 >= n || x1 >= n || x2 >= n || y1 < 0 || y2 < 0) {\n        return false;\n    }\n    if (c[x1][y1] == '#') return false;\n    if (x1 == x2 && y1 == y2)return true;\n    return reachable(x1 + 1, y1, x2, y2) || reachable(x1, y1 + 1, x2, y2);\n}\n\nvoid pre() {\n    IOS;\n    freopen(\"/home/whiteknife/Workspace/CLionProjects/untitled/in\", \"r\", stdin);\n    cin >> n;\n    a.resize(n, VI(n));\n    c.resize(n);\n    v.resize(n, VB(n));\n    REP(i, n)cin >> c[i];\n    REP(i, n)REP(j, n)a[i][j] = ((c[i][j] == '#') ? 0 : (c[i][j] - '0'));\n    REP(i, n)REP(j, n) v[i][j] = false;\n    //    REP(i, n) {\n//        REP(j, n)cout << a[i][j] << \" \";\n//        cout << endl;\n//    }\n\n\n//    FORR(i, n) {\n//        FORR(j, n) {\n//            if (!v[i][j]) {\n//                for (int k = i; k >= 0; --k) {\n//                    for (int l = j; l >= 0; --l) {\n//                        if (c[k][l] == '#')\n//                            goto ok;\n//                        else {\n//                            v[k][l] = true;\n//                        }\n//                    }\n//                }\n//            }\n//            ok:\n//        }\n//    }\n}\n\nint main() {\n    pre();\n    LL ans = 0;\n    REP(i, n) {\n        REP(j, n) {\n            if (c[i][j] == '#')continue;\n            FOR(k, i, n) {\n                FOR(l, j, n) {\n//                    cerr << \"HERE\" << endl;\n//                    cerr << i << \" \" << j << \" \" << k << \" \" << l << endl;\n                    if (i == k && j == l)continue;\n//                    if (reachable(i, j, k, l))cerr << \"YESSSSSSSSS\" << endl;\n                    if (reachable(i, j, k, l)) ans += a[i][j] * a[k][l];\n                }\n            }\n        }\n    }\n//    cerr << \"OVER\" << endl;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[510][510];\nint Up[510][510], Down[510][510], TP[510][510];\nint B[510][510], E[510][510], BB[510], EE[510], S[510];\nint T[510][510], v[510];\nint n, w[510][510], L[510], R[510], DEBUG = 0, Res[510][510];\nlong long res;\nint main() {\n\tsrand(1879);\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tif (!DEBUG) {\n\t\t\tscanf(\"%s\", p[i] + 1);\n\t\t}\n\t\telse {\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tif (rand() % 5==0)p[i][j] = '#';\n\t\t\t\telse p[i][j] = rand() % 5 + 1 + '0';\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (p[i][j] >= '0' && p[i][j] <= '9')w[i][j] = p[i][j] - '0';\n\t\t\telse w[i][j] = -1;\n\t\t}\n\t}\n\tfor (i = 0; i <= n + 1; i++)for (j = 0; j <= n + 1; j++)if (i == 0 || i > n || j == 0 || j > n)w[i][j] = -1;\n\tfor (i = n; i >= 1; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (w[i][j] == -1)continue;\n\t\t\tDown[i][j] = i;\n\t\t\tDown[i][j] = max(Down[i][j], Down[i][j + 1]);\n\t\t\tDown[i][j] = max(Down[i][j], Down[i + 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tUp[i][j] = n + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tUp[i][j] = i;\n\t\t\tif (w[i][j - 1] != -1)Up[i][j] = min(Up[i][j], Up[i][j - 1]);\n\t\t\tif (w[i - 1][j] != -1)Up[i][j] = min(Up[i][j], Up[i - 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint pv = 0, s = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tpv = j;\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\ts = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT[i][j] = pv + 1;\n\t\t\tRes[i][j] += s;\n\t\t\tres += s*w[i][j];\n\t\t\ts += w[i][j];\n\t\t\tint b = T[i][j], e = j;\n\t\t\tif (i != 1) {\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\tfor (k = b; k <= e; k++) {\n\t\t\t\t\tif (w[i - 1][k] != -1) {\n\t\t\t\t\t\tB[i][j] = min(B[i][j], T[i - 1][k]);\n\t\t\t\t\t\tE[i][j] = max(E[i][j], k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) BB[j] = B[i][j], EE[j] = E[i][j];\n\t\tfor (j = i - 1; j >= 1; j--) {\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tS[k] = S[k - 1];\n\t\t\t\tif (Down[j][k] >= i) {\n\t\t\t\t\tS[k] += w[j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 1) {\n\t\t\t\t\tif (Up[j][k] <= j-1 && Down[j][k] >= i)v[k] = 1;\n\t\t\t\t\telse v[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tif (Up[i][k] <= j) {\n\t\t\t\t\tRes[i][k] += (S[EE[k]] - S[BB[k] - 1]);\n\t\t\t\t\tres += (S[EE[k]] - S[BB[k] - 1])*w[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == 1)break;\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tL[k] = L[k - 1];\n\t\t\t\tif (v[k])L[k] = k;\n\t\t\t}\n\t\t\tR[n + 1] = n + 1;\n\t\t\tfor (k = n; k >= 1; k--) {\n\t\t\t\tR[k] = R[k + 1];\n\t\t\t\tif (v[k])R[k] = k;\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tint b = BB[k], e = EE[k];\n\t\t\t\tif (Up[i][k] >= j) {\n\t\t\t\t\tBB[k] = 1e8, EE[k] = -1e8;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tBB[k] = B[j][R[b]], EE[k] = E[j][L[e]];\n\t\t\t}\n\t\t}\n\t}\n\tint cc = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] != -1) {\n\t\t\t\tTP[i][j] = ++cc;\n\t\t\t\tint s = -w[i][j];\n\t\t\t\tfor (int k = i; k >= 1; k--) {\n\t\t\t\t\tfor (int l = j; l >= 1; l--) {\n\t\t\t\t\t\tif (TP[k][l]!=cc)continue;\n\t\t\t\t\t\ts += w[k][l];\n\t\t\t\t\t\tif (w[k - 1][l] != -1)TP[k - 1][l] = cc;\n\t\t\t\t\t\tif (w[k][l - 1] != -1)TP[k][l - 1] = cc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Res[i][j] != s) {\n\t\t\t\t\tprintf(\"??\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n    const int l=1<<20;\n    char buf[l],*s,*t,c;\n    inline void gc(){\n        if(s==t){\n            t=(s=buf)+fread(buf,1,l,stdin);\n            c=s==t?EOF:*s++;\n        }else c=*s++;\n    }\n    template<class IT>inline void gi(IT &x){\n        x=0;gc();while(c<'0'||c>'9')gc();\n        while('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n    }\n    char buf0[20];int a;\n    template<class IT>inline void pi(IT x){\n        if(x<0){putchar('-');x=-x;}\n        do buf0[++a]=x%10+48;while(x/=10);\n        while(a)putchar(buf0[a--]);\n        putchar('\\n');\n    }\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=505;\nint a[N][N],f[N][N];\nshort l[N][N],r[N][N];\nchar c[N];\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n,i,j,k,t;short m;ll ans=0ll;\n    scanf(\"%d\",&n);\n    rep(i,1,n){\n\t\tscanf(\"%s\",c+1);\n\t\trep(j,1,n)a[i][j]=((c[j]=='#')?0:(c[j]^48));\n\t}\n\tper(i,n,1)per(j,n,1){\n\t\tif(a[i][j]){\n\t\t\tif(a[i+1][j]){\n\t\t\t\tif(a[i][j+1]){\n\t\t\t\t\tl[j][i]=j;r[j][i]=r[j+1][i];\n\t\t\t\t\tt=f[i][j+1]+f[i+1][j];m=0;\n\t\t\t\t\trep(k,i+1,n){\n\t\t\t\t\t\tif(r[j][k]>=l[j+1][k]&&l[j+1][k]>m)t-=f[k][l[j+1][k]];\n\t\t\t\t\t\tcmax(m,r[j][k]);\n\t\t\t\t\t\tcmin(l[j][k],l[j+1][k]);\n\t\t\t\t\t\tcmax(r[j][k],r[j+1][k]);\n\t\t\t\t\t}\n\t\t\t\t\tf[i][j]=t;\n\t\t\t\t}else{\n\t\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(a[i][j+1]){\n\t\t\t\t\tmemcpy(l[j]+i,l[j+1]+i,(n-i+1)<<1);\n\t\t\t\t\tmemcpy(r[j]+i,r[j+1]+i,(n-i+1)<<1);\n\t\t\t\t\tl[j][i]=j;\n\t\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\t}else l[j][i]=r[j][i]=j;\n\t\t\t}\n\t\t\tans+=a[i][j]*f[i][j];\n\t\t\tf[i][j]+=a[i][j];\n\t\t}else{\n\t\t\tmemset(l[j]+i,0x3f,(n-i+1)<<1);\n\t\t\tmemset(r[j]+i,0   ,(n-i+1)<<1);\n\t\t}\n\t\t//printf(\"(%d,%d) f=%d\\n\",i,j,f[i][j]);\n\t\t//rep(k,i,n)printf(\"(%d,[%d,%d])\\n\",k,l[j][k],r[j][k]);\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 64\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t\twhile(wek.size() < (v/d)+2) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid ustaw(int v,int a)\n\t{\n\t\tfor(int i=v;i<v+a;i++) ustaw(i);\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[505];\nll ans;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n    int A = 0;\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[x].upper(9*A+9);\n\t\t\t\tif(x) oruj(B[x],B[x-1]);\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].licz());\n\t\t\t\tB[x].ustaw(9*A,f[x][y]-'0');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].zeruj();\n\t\t\t\tB[x].upper(9*A+9);\n\t\t\t}\n\t\t\tA++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//無理。\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nconst int MN = 1550;\nint N;\nusing B = array<ull, MN/64+1>;\nint g[MN][MN];\n\n\nB used[MN][MN];\n\nnamespace std {\nbool operator<(const B &l, const B &r) {\n    for (int i = 0; i < MN / 64 + 1; i++) {\n        if (l[i] != r[i]) return l[i] < r[i];\n    }\n    return false;\n}\nbool operator>(const B &l, const B &r) {\n    return r < l;\n}\n\nbool operator==(const B &l, const B &r) {\n    for (int i = 0; i < MN / 64 + 1; i++) {\n        if (l[i] != r[i]) return false;\n    }\n    return true;\n}\n}\n\nbool sam(const B& l, const B& r) {\n    for (int i = 0; i < MN/64+1; i++) {\n        if (l[i] & r[i]) return true;\n    }\n    return false;\n}\n\nbool gt(const B& b, int id) {\n    return (b[id/64] & (1ULL << (id%64))) != 0;\n}\n\nvoid st(B& b, int id) {\n    b[id/64] |= 1ULL << (id % 64);\n}\n\nint L, R, D, U;\nvoid dfs_up(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    //if (g[a][b] == 0 || used[a][b][id]) return;\n    if (g[a][b] == 0 || gt(used[a][b], id)) return;\n    st(used[a][b], id);\n    //used[a][b][id] = true;\n    dfs_up(a-1, b, id); dfs_up(a, b-1, id);\n}\n\nvoid dfs_dw(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    if (g[a][b] == 0 || gt(used[a][b], id)) return;\n    st(used[a][b], id);\n//    if (g[a][b] == 0 || used[a][b][id]) return;\n//    used[a][b][id] = true;\n    dfs_dw(a+1, b, id); dfs_dw(a, b+1, id);\n}\n\nll ans = 0;\n\nusing P = pair<B, int>;\n\nV<P> uni(V<P> v) {\n    sort(v.begin(), v.end());\n    V<P> res;\n    for (auto &p: v) {\n        if (res.size() && res.back().first == p.first) {\n            res.back().second += p.second;\n            continue;\n        }\n        res.push_back(p);\n    }\n    return res;\n}\nvoid solve(int l, int r, int d, int u) {\n    if (r < l || u < d) return;\n    if (l == r && d == u) return;\n    L = l; R = r; D = d; U = u;\n    for (int x = l; x <= r; x++) {\n        for (int y = d; y <= u; y++) {\n            used[x][y] = B();\n        }\n    }\n    if (r-l > u-d) {\n        int m = (l+r)/2;\n        for (int y = d; y <= u; y++) {\n            dfs_up(m, y, y);\n        }\n        for (int y = u; y >= d; y--) {\n            dfs_dw(m+1, y, y);\n        }\n        V<P> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (x <= m) mp1.push_back(P(used[x][y], g[x][y]));\n                else mp2.push_back(P(used[x][y], g[x][y]));\n            }\n        }\n        mp1 = uni(mp1); mp2 = uni(mp2);\n\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                //if ((p1.first & p2.first).count()) ans += ll(p1.second) * p2.second;\n                if (sam(p1.first, p2.first)) ans += ll(p1.second) * p2.second;\n            }\n        }\n        solve(l, m, d, u);\n        solve(m+1, r, d, u);\n    } else {\n        int m = (d+u)/2;\n\n        for (int x = l; x <= r; x++) {\n            dfs_up(x, m, x);\n        }\n        for (int x = r; x >= l; x--) {\n            dfs_dw(x, m+1, x);\n        }\n\n        using P = pair<B, int>;\n        V<P> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (y <= m) mp1.push_back(P(used[x][y], g[x][y]));\n                else mp2.push_back(P(used[x][y], g[x][y]));\n            }\n        }\n        mp1 = uni(mp1); mp2 = uni(mp2);\n/*        map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (y <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }*/\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if (sam(p1.first, p2.first)) ans += ll(p1.second) * p2.second;\n            }\n        }\n        solve(l, r, d, m);\n        solve(l, r, m+1, u);\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(20) << fixed;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        string s;\n        cin >> s;\n        for (int j = 1; j <= N; j++) {\n            int d = 0;\n            if (isdigit(s[j-1])) d = s[j-1] - '0';\n            g[i][j] = d;\n            //ans -= d*d;\n        }\n    }\n    solve(1, N, 1, N);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    while(wek.size() < (v/d)+2)) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trepn(x,9) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+1);\n\t\t\t\tif(x) repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[510][510];\nint Up[510][510], Down[510][510];\nint B[510][510], E[510][510], BB[510], EE[510], S[510];\nint T[510][510], v[510];\nint n, w[510][510], L[510], R[510];\nlong long res;\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", p[i] + 1);\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (p[i][j] >= '0' && p[i][j] <= '9')w[i][j] = p[i][j] - '0';\n\t\t\telse w[i][j] = -1;\n\t\t}\n\t}\n\tfor (i = 0; i <= n + 1; i++)for (j = 0; j <= n + 1; j++)if (i == 0 || i > n || j == 0 || j > n)w[i][j] = -1;\n\tfor (i = n; i >= 1; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (w[i][j] == -1)continue;\n\t\t\tDown[i][j] = i;\n\t\t\tDown[i][j] = max(Down[i][j], Down[i][j + 1]);\n\t\t\tDown[i][j] = max(Down[i][j], Down[i + 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tUp[i][j] = n + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tUp[i][j] = i;\n\t\t\tif (w[i][j - 1] != -1)Up[i][j] = min(Up[i][j], Up[i][j - 1]);\n\t\t\tif (w[i - 1][j] != -1)Up[i][j] = min(Up[i][j], Up[i - 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint pv = 0, s = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tpv = j;\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\ts = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT[i][j] = pv + 1;\n\t\t\tres += s*w[i][j];\n\t\t\ts += w[i][j];\n\t\t\tint b = T[i][j], e = j;\n\t\t\tif (i != 1) {\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\tfor (k = b; k <= e; k++) {\n\t\t\t\t\tif (w[i - 1][k] != -1) {\n\t\t\t\t\t\tB[i][j] = min(B[i][j], T[i - 1][k]);\n\t\t\t\t\t\tE[i][j] = max(E[i][j], k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) BB[j] = B[i][j], EE[j] = E[i][j];\n\t\tfor (j = i - 1; j >= 1; j--) {\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tS[k] = S[k - 1];\n\t\t\t\tif (Down[j][k] >= i) {\n\t\t\t\t\tS[k] += w[j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 1) {\n\t\t\t\t\tif (B[j][k] <= E[j][k])v[k] = 1;\n\t\t\t\t\telse v[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tif ((Up[i][k] <= j)) {\n\t\t\t\t\tres += (S[EE[k]] - S[BB[k] - 1])*w[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == 1)break;\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tL[k] = L[k - 1];\n\t\t\t\tif (v[k])L[k] = k;\n\t\t\t}\n\t\t\tR[n + 1] = n + 1;\n\t\t\tfor (k = n; k >= 1; k--) {\n\t\t\t\tR[k] = R[k + 1];\n\t\t\t\tif (v[k])R[k] = k;\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tint b = BB[k], e = EE[k];\n\t\t\t\tif (Up[i][k] >= j) {\n\t\t\t\t\tBB[k] = 1e8, EE[k] = -1e8;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tBB[k] = B[j][R[b]], EE[k] = E[j][L[e]];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <string>\n#define pb push_back\ntemplate <typename T1, typename T2> inline void umin(T1 &x, const T2 &y) { y < x ? (x = y) : 0; }\ntemplate <typename T1, typename T2> inline void umax(T1 &x, const T2 &y) { y > x ? (x = y) : 0; }\nint lp[2005][2005], rp[2005][2005], ul[2005], ur[2005], tmp[2005][2005];\nint sum_can[2005], sum_l[2005][2005], sum_r[2005][2005], sum_in[2005][2005];\nint bottom[2005], top[2005], que[2005], can_go[2005], unique[2005];\nint bel_mn[2005][2005], ans;\nbool del[2005];\nstd::vector<int> vec[2005];\ninline int calc_meet(int l, int r)\n{\n\tint pos = bel_mn[l][r];\n\tif (pos <= bottom[l] && pos <= bottom[r])\n\t\treturn pos;\n\treturn 1e9;\n}\ninline int calc_cnt(int l, int r, int lim = 1e9)\n{\n\tlim = std::min({lim, bottom[l], bottom[r]});\n\tif (calc_meet(l, r) > lim)\n\t\treturn 0;\n\treturn sum_can[lim] - sum_l[lim][l] - sum_r[lim][r] + sum_in[l][r];\n}\ntemplate <typename mapT>\nvoid work(const mapT &inp)\n{\n\tmapT str = inp;\n\tint n = str.size(), m = str[0].size();\n\tif (n < m)\n\t{\n\t\tmapT str_new(m, std::string(n, '#'));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tstr_new[j][i] = str[i][j];\n\t\t}\n\t\tstr = str_new;\n\t\tstd::swap(n, m);\n\t}\n\tif (m == 1)\n\t{\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (str[i][0] == '#')\n\t\t\t\tcur = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += (str[i][0] - '0') * cur;\n\t\t\t\tcur += str[i][0] - '0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint hu = n >> 1, hd = n - hu;\n\tmapT up(str.begin(), str.begin() + hu), down(str.begin() + hu, str.end());\n\twork(up);\n\twork(down);\n\tup.pb(down[0]);\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tlp[i][j] = 1e9;\n\t\t\trp[i][j] = -1e9;\n\t\t}\n\t}\n\t// lp & rp\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (down[0][i] != '#')\n\t\t\tlp[0][i] = rp[0][i] = i;\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (down[i][j] == '#')\n\t\t\t\tcontinue;\n\t\t\tif (i)\n\t\t\t{\n\t\t\t\tumin(lp[i][j], lp[i - 1][j]);\n\t\t\t\tumax(rp[i][j], rp[i - 1][j]);\n\t\t\t}\n\t\t\tif (j)\n\t\t\t{\n\t\t\t\tumin(lp[i][j], lp[i][j - 1]);\n\t\t\t\tumax(rp[i][j], rp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t// top\n\tfor (int i = 0; i <= hu; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (up[i][j] == '#')\n\t\t\t{\n\t\t\t\ttmp[i][j] = 1e9;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp[i][j] = i;\n\t\t\tif (i)\n\t\t\t\tumin(tmp[i][j], tmp[i - 1][j]);\n\t\t\tif (j)\n\t\t\t\tumin(tmp[i][j], tmp[i][j - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\ttop[i] = tmp[hu][i];\n\t// bottom\n\tfor (int i = hd - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (down[i][j] == '#')\n\t\t\t{\n\t\t\t\ttmp[i][j] = -1e9;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp[i][j] = i;\n\t\t\tif (i + 1 < hd)\n\t\t\t\tumax(tmp[i][j], tmp[i + 1][j]);\n\t\t\tif (j + 1 < m)\n\t\t\t\tumax(tmp[i][j], tmp[i][j + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tbottom[i] = tmp[0][i];\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tbel_mn[i][j] = 1e9;\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (lp[i][j] <= rp[i][j])\n\t\t\t\tumin(bel_mn[lp[i][j]][rp[i][j]], i);\n\t\t}\n\t}\n\tfor (int l = 0; l < m; l++)\n\t{\n\t\tfor (int r = m - 1; r >= l; r--)\n\t\t{\n\t\t\tif (l)\n\t\t\t\tumin(bel_mn[l][r], bel_mn[l - 1][r]);\n\t\t\tif (r + 1 < m)\n\t\t\t\tumin(bel_mn[l][r], bel_mn[l][r + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tsum_can[i] = 0;\n\t\tmemset(sum_l[i], 0, m << 2);\n\t\tmemset(sum_r[i], 0, m << 2);\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tmemset(sum_in[i], 0, m << 2);\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tif (i)\n\t\t{\n\t\t\tsum_can[i] = sum_can[i - 1];\n\t\t\tmemcpy(sum_l[i], sum_l[i - 1], m << 2);\n\t\t\tmemcpy(sum_r[i], sum_r[i - 1], m << 2);\n\t\t}\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (lp[i][j] > rp[i][j])\n\t\t\t\tcontinue;\n\t\t\tint val = down[i][j] - '0';\n\t\t\tsum_can[i] += val;\n\t\t\tif (lp[i][j])\n\t\t\t\tsum_l[i][lp[i][j] - 1] += val;\n\t\t\tif (rp[i][j] + 1 < m)\n\t\t\t\tsum_r[i][rp[i][j] + 1] += val;\n\t\t\tif (lp[i][j] && rp[i][j] + 1 < m)\n\t\t\t\tsum_in[lp[i][j] - 1][rp[i][j] + 1] += val;\n\t\t}\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = m - 2; j >= 0; j--)\n\t\t\tsum_l[i][j] += sum_l[i][j + 1];\n\t\tfor (int j = 1; j < m; j++)\n\t\t\tsum_r[i][j] += sum_r[i][j - 1];\n\t}\n\tfor (int l = m - 1; l >= 0; l--)\n\t{\n\t\tfor (int r = l; r < m; r++)\n\t\t{\n\t\t\tif (l + 1 < m)\n\t\t\t\tsum_in[l][r] += sum_in[l + 1][r];\n\t\t\tif (r)\n\t\t\t\tsum_in[l][r] += sum_in[l][r - 1];\n\t\t\tif (l + 1 < m && r)\n\t\t\t\tsum_in[l][r] -= sum_in[l + 1][r - 1];\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tcan_go[i] = calc_cnt(i, i);\n\tfor (int i = 0; i < hu; i++)\n\t\tvec[i].clear();\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tdel[i] = top[i] >= hu;\n\t\tif (!del[i])\n\t\t\tvec[top[i]].pb(i);\n\t}\n\tfor (int i = m - 1; i >= 0; i--)\n\t{\n\t\tif (up[hu][i] == '#')\n\t\t{\n\t\t\tul[i] = 1e9;\n\t\t\tur[i] = -1e9;\n\t\t\tcontinue;\n\t\t}\n\t\tul[i] = ur[i] = i;\n\t\tif (i + 1 < m)\n\t\t\tumax(ur[i], ur[i + 1]);\n\t}\n\tfor (int i = hu - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (up[i][j] == '#')\n\t\t\t{\n\t\t\t\tul[j] = 1e9;\n\t\t\t\tur[j] = -1e9;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + 1 < m)\n\t\t\t{\n\t\t\t\tumin(ul[j], ul[j + 1]);\n\t\t\t\tumax(ur[j], ur[j + 1]);\n\t\t\t}\n\t\t}\n\t\tint cur = 0, cl = 0, cr = -1, he = 0, ta = 0;\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (ul[j] > ur[j])\n\t\t\t\tcontinue;\n\t\t\twhile (cr < ur[j])\n\t\t\t{\n\t\t\t\tint x = ++cr;\n\t\t\t\tif (del[x])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (he < ta)\n\t\t\t\t{\n\t\t\t\t\tcur -= unique[que[ta - 1]];\n\t\t\t\t\tunique[que[ta - 1]] -= calc_cnt(que[ta - 1], x);\n\t\t\t\t\tcur += unique[que[ta - 1]];\n\t\t\t\t\tif (bottom[que[ta - 1]] <= bottom[x])\n\t\t\t\t\t\tta--;\n\t\t\t\t}\n\t\t\t\twhile (he < ta && bottom[que[ta - 1]] <= bottom[x])\n\t\t\t\t{\n\t\t\t\t\tta--;\n\t\t\t\t\tcur -= unique[que[ta - 1]];\n\t\t\t\t\tunique[que[ta - 1]] -= calc_cnt(que[ta - 1], x);\n\t\t\t\t\tunique[que[ta - 1]] += calc_cnt(que[ta - 1], x, bottom[que[ta]]);\n\t\t\t\t\tcur += unique[que[ta - 1]];\n\t\t\t\t}\n\t\t\t\tque[ta++] = x;\n\t\t\t\tunique[x] = can_go[x];\n\t\t\t\tcur += unique[x];\n\t\t\t}\n\t\t\twhile (cl < ul[j])\n\t\t\t{\n\t\t\t\tint x = cl++;\n\t\t\t\tif (del[x])\n\t\t\t\t\tcontinue;\n\t\t\t\tcur -= unique[x];\n\t\t\t\tif (he < ta && que[he] == x)\n\t\t\t\t\the++;\n\t\t\t}\n\t\t\tans += (up[i][j] - '0') * cur;\n\t\t}\n\t\tfor (int x : vec[i])\n\t\t\tdel[x] = true;\n\t}\n}\nchar str[2005];\nint main()\n{\n\t// freopen(\"AGC028-F.in\", \"r\", stdin);\n\tint n;\n\tscanf(\"%d\", &n);\n\tstd::vector<std::string> inp;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%s\", str);\n\t\tinp.pb(std::string(str));\n\t}\n\twork(inp);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4.1\")\n\n#ifdef LOCAL\n//#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for (int i = ((int)(n) - 1); i >= 0; --i)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr);\n#else\n#define eprintf(args...) ;\n#endif\n\nconst int mod = (int)1e9 + 7;\n\nvoid add (int &a, int b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\n\nvoid sub (int &a, int b)\n{\n    a -= b;\n    if (a < 0)\n        a += mod;\n}\n\nint mult (int a, int b)\n{\n    return (ll)a * b % mod;\n}\n\nint n;\nvector<string> grid;\n\n#ifdef LOCAL\n//#define TEST\n#endif // LOCAL\n\n#ifndef TEST\nbool read ()\n{\n    if (!(cin >> n))\n        return false;\n\n    grid.resize(n);\n    forn (i, n)\n        cin >> grid[i];\n\n    return true;\n}\n#else\nbool read ()\n{\n    n = 500;\n    static mt19937 rng;\n\n    grid = vector<string>(n, string(n, '#'));\n    forn (i, n) forn (j, n)\n        grid[i][j] = rng() % 9 + '1';\n\n    return true;\n}\n#endif\n\nusing ull = unsigned long long;\nconst int bits = 64;\n\nstruct bitarr\n{\n    vector<ull> v;\n    int n;\n\n    bitarr () {}\n\n    bitarr (int len)\n    {\n        v.resize((len + bits) / bits);\n        n = len;\n    }\n\n    void operator |= (const bitarr &o)\n    {\n        assert(n == o.n);\n        assert(sz(v) == sz(o.v));\n        forn (i, sz(v))\n            v[i] |= o.v[i];\n    }\n\n    void reset ()\n    {\n        fill(all(v), ull(0));\n    }\n\n    void set (int pos)\n    {\n        v[pos >> 6] |= (1ULL << (pos & 63));\n    }\n\n    int bitcount () const\n    {\n        int ans = 0;\n        forn (i, sz(v))\n            ans += __builtin_popcountll(v[i]);\n        return ans;\n    }\n};\n\nll solve ()\n{\n    const int digs = 9;\n\n    vi cnt (digs);\n    vvi id (n, vi(n, -1));\n\n    forn (i, n) forn (j, n)\n    {\n        const int cur = grid[i][j] - '1';\n        if (0 <= cur && cur < digs)\n        {\n            id[i][j] = cnt[cur];\n            cnt[cur]++;\n        }\n    }\n\n    vector<vector<vector<bitarr>>> dp (2, vector<vector<bitarr>>(n, vector<bitarr>(digs)));\n    forn (c, 2) forn (i, n) forn (j, digs)\n        dp[c][i][j] = bitarr(cnt[j]);\n\n    int cur = 0;\n\n    auto in = [&] (int x, int y) -> bool\n    {\n        return 0 <= x && x < n && 0 <= y && y < n && grid[x][y] != '#';\n    };\n\n    ll ans = 0;\n    ford (sum, 2 * n - 1)\n    {\n        const int prev = (cur ^ 1);\n\n        forn (i, n)\n        {\n            const int j = sum - i;\n            if (0 <= j && j < n)\n            {\n                forn (d, digs)\n                    dp[cur][i][d].reset();\n\n                if (in(i, j))\n                {\n                    const int here = grid[i][j] - '1';\n                    assert(0 <= here && here < digs);\n\n                    dp[cur][i][here].set(id[i][j]);\n\n                    forn (iter, 2)\n                    if (in (i + (iter == 0), j + (iter == 1)))\n                    {\n                        forn (d, digs)\n                            dp[cur][i][d] |= dp[prev][i + (iter == 0)][d];\n                    }\n\n                    forn (d, digs)\n                        ans += (d + 1) * (here + 1) * dp[cur][i][d].bitcount();\n                    ans -= (here + 1) * (here + 1);\n                }\n            }\n        }\n\n        cur ^= 1;\n    }\n\n    return ans;\n}\n\nint32_t main()\n{\n#ifdef LOCAL\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif // ONLINE_JUDGE\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n#ifdef TEST\n    assert(read());\n    auto ans = solve();\n    cerr << ans << endl;\n    return 0;\n#endif // TEST\n\n    while (read())\n    {\n        auto ans = solve();\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn=511;\nint n,a[maxn][maxn],sum;\nint mk[maxn][maxn],curmk;\nll ans;\nvoid dfs(int x,int y)\n{\n\tmk[x][y]=curmk;sum+=a[x][y];\n\tif(!mk[x+1][y]&&a[x+1][y])dfs(x+1,y);\n\tif(!mk[x][y+1]&&a[x][y+1])dfs(x,y+1);\n}\nvoid dfs3(int x,int y)\n{\n\tmk[x][y]=0;sum-=a[x][y];\n\tif(mk[x][y+1]&&mk[x][y+1]!=curmk&&mk[x-1][y+1]==0)dfs3(x,y+1);\n\tif(mk[x+1][y])dfs3(x+1,y);\n}\nvoid debug()\n{\n\tcerr<<\"mk:\"<<endl;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcerr<<mk[i][j]<<\" \";\n\t\t}\n\t\tcerr<<endl;\n\t}\n}\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tchar c=getreal();\n\t\t\tif(c!='#')a[i][j]=c-'0';\n\t\t}\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tsum=0;\n\t\tmemset(mk,0,sizeof(mk));\n\t\tint lst=-1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(lst==-1)\n\t\t\t\t{\n\t\t\t\t\tcurmk=1;\n\t\t\t\t\tdfs(i,j);\n\t\t\t\t\tlst=j;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurmk=j;\n\t\t\t\t\tif(!mk[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tdfs(i,j);\n\t\t\t\t\t}\n\t\t\t\t\tmk[i][j]=j;\n\t\t\t\t\tdfs3(i,lst);\n\t\t\t\t\tlst=j;\n\t\t\t\t}\n\t\t\t\tll csum=sum;\n\t\t\t\tans+=a[i][j]*(sum-a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int LL\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nLL ans = 0;\nLL sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE]; \nLL dfs(int y,int x) {\n\tif (y > N or x > N) return 0;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x]) {\n\t\treturn 0;\n\t}\n\treached[y][x]=true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs2(int y, int x) {\n\tif (y > N or x > N) return 0;\n//\tcout << y << \" \" << x << endl;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x] == 0) return 0;\n\tif (reached[y - 1][x]) return 0;\n\t//cout << y << \" \" << x << endl;\n\treached[y][x] = 0;\n\tLL ret = 0;\n\tret += dfs2(y, x + 1);\n\tret += dfs2(y + 1, x);\n\n\treturn ret + A[y][x];\n}\nLL solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i,1, N) {\n\t\tsum+=dfs(x, i);\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tans +=( sum - A[x][i] )* A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tsum-=dfs2(x+1, i)+A[x][i];\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N;\n\tEFOR(i,1,N){\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1]-'0';\n\t\t}\n\t}\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[505];\nll ans;\n\nint main(){\n\tscanf(\"%d\",&n); //n = 450; srand((unsigned)time(NULL));\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);/*for(int j=0;j<n;j++){\n\t    int a = rand()%10;\n\t    if(a == 0) f[i][j] = '#';\n\t    else f[i][j] = '0'+a;\n\t}*/\n\trep(i,n) B[i] = bity(n*n*9+5);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=max(0,i-n+1);j<=min(i,n-1);j++){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t\tif(x) oruj(B[x],B[x-1]);\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].licz());\n\t\t\t\trep(a,f[x][y]-'0') B[x].ustaw(9*(x*n+y)+a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nconst int maxn = 550;\n\nint n, m, a[maxn][maxn], fl[maxn][maxn][maxn], fr[maxn][maxn][maxn], s[maxn][maxn];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstatic char str[maxn];\n\t\tscanf(\"%s\", str + 1);\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\ta[i][j] = (str[j] == '#' ? 0 : str[j] - '0'), s[i][j] = s[i][j - 1] + a[i][j];\n\t\t\tfor (int k = 1; k <= n; ++k) fl[i][j][k] = n, fr[i][j][k] = 0;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = n; i; --i) for (int j = n; j; --j) if(a[i][j]) {\n\t\tfl[i][j][i] = fr[i][j][i] = j;\n\t\tif(a[i + 1][j]) for (int k = i + 1; k <= n; ++k) fl[i][j][k] = min(fl[i][j][k], fl[i + 1][j][k]), fr[i][j][k] = max(fr[i][j][k], fr[i + 1][j][k]);\n\t\tif(a[i][j + 1]) for (int k = i; k <= n; ++k) fl[i][j][k] = min(fl[i][j][k], fl[i][j + 1][k]), fr[i][j][k] = max(fr[i][j][k], fr[i][j + 1][k]);\n\t\tint sum = 0;\n\t\tfor (int k = i; k <= n; ++k) {\n\t\t\tif(fl[i][j][k] > fr[i][j][k]) break;\n\t\t\tsum += s[k][fr[i][j][k]] - s[k][fl[i][j][k] - 1];\n\t\t}\n\t\tans += (long long) a[i][j] * (sum - a[i][j]);\n\n\t\tfunction<void(int, int)> del = [&](int x, int y) {\n\t\t\tif(x >= 1 && y >= 1 && x <= n && y <= n && !a[x][y - 1] && !a[x - 1][y]) {\n\t\t\t\tfor (int i = y; i <= n; ++i) s[x][i] -= a[x][y];\n\t\t\t\ta[x][y] = 0;\n\t\t\t\tdel(x, y + 1); del(x + 1, y);\n\t\t\t}\n\t\t\treturn;\n\t\t};\n\t\tdel(i, j);\n\t}\n\tprintf(\"%\"LLFORMAT\"d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[510][510];\nint Up[510][510], Down[510][510];\nint B[510][510], E[510][510], BB[510], EE[510], S[510];\nint T[510][510], v[510];\nint n, w[510][510], L[510], R[510];\nlong long res;\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", p[i] + 1);\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif(p[i][j]>='0' && p[i][j]<='9')w[i][j] = p[i][j] - '0';\n\t\t\telse w[i][j] = -1;\n\t\t}\n\t}\n\tfor (i = 0; i <= n + 1; i++)for (j = 0; j <= n + 1; j++)if (i == 0 || i > n || j == 0 || j > n)w[i][j] = -1;\n\tfor (i = n; i >= 1; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (w[i][j] == -1)continue;\n\t\t\tDown[i][j] = i;\n\t\t\tDown[i][j] = max(Down[i][j], Down[i][j + 1]);\n\t\t\tDown[i][j] = max(Down[i][j], Down[i + 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tUp[i][j] = n + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tUp[i][j] = i;\n\t\t\tif(w[i][j-1] != -1)Up[i][j] = min(Up[i][j], Up[i][j - 1]);\n\t\t\tif(w[i-1][j] != -1)Up[i][j] = min(Up[i][j], Up[i - 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint pv = 0, s = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tpv = j;\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\ts = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT[i][j] = pv + 1;\n\t\t\tres += s*w[i][j];\n\t\t\ts += w[i][j];\n\t\t\tint b = T[i][j], e = j;\n\t\t\tif (i != 1) {\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\tfor (k = b; k <= e; k++) {\n\t\t\t\t\tif (w[i - 1][k] != -1) {\n\t\t\t\t\t\tB[i][j] = min(B[i][j], T[i - 1][k]);\n\t\t\t\t\t\tE[i][j] = max(E[i][j], k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) BB[j] = B[i][j], EE[j] = E[i][j];\n\t\tfor (j = i - 1; j >= 1; j--) {\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tS[k] = S[k - 1];\n\t\t\t\tif (Down[j][k] >= i) {\n\t\t\t\t\tS[k] += w[j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 1) {\n\t\t\t\t\tif (B[j][k] <= E[j][k])v[k] = 1;\n\t\t\t\t\telse v[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tif (BB[k] <= EE[k]) {\n\t\t\t\t\tres += (S[EE[k]] - S[BB[k] - 1])*w[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == 1)break;\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tL[k] = L[k - 1];\n\t\t\t\tif (v[k])L[k] = k;\n\t\t\t}\n\t\t\tR[n + 1] = n + 1;\n\t\t\tfor (k = n; k >= 1; k--) {\n\t\t\t\tR[k] = R[k + 1];\n\t\t\t\tif (v[k])R[k] = k;\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tint b = BB[k], e = EE[k];\n\t\t\t\tif (Up[i][k] >= j)continue;\n\t\t\t\tBB[k] = B[j][R[b]], EE[k] = E[j][L[e]];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bitset {\n  vector<unsigned int> a;\n  Bitset() {}\n  Bitset(const vector<unsigned int>& a) : a(a) {}\n\n  Bitset f(const Bitset &o) {\n    vector<unsigned int> vec(max(o.a.size(), a.size()));\n    for (int i = 0; i < vec.size(); i++) {\n      unsigned int x = 0, y = 0;\n      if (i < a.size()) x = a[i];\n      if (i < o.a.size()) y = o.a[i];\n      vec[i] = (x | y);\n    }\n    return Bitset(vec);\n  }\n\n  int count() {\n    int ret = 0;\n    for (auto x : a) {\n      ret += __builtin_popcount(x);\n    }\n    return ret;\n  }\n\n  void reset() {\n    for (auto& x : a) {\n      x = 0;\n    }\n  }\n\n  void set(int v) {\n    int p = v / 32;\n    while (a.size() <= p) a.push_back(0);\n    a[p] |= (1 << (v % 64));\n  }\n}a[2][501][10];\n\nint main(int argc, char *argv[]) {\n  std::ios_base::sync_with_stdio(false);\n  vector<int> c(11);\n  int n;\n  cin >> n;\n  long long ans = 0;\n  for (int i = 0, now = 0; i < n; i++, now ^= 1) {\n    for (int j = 1; j <= n; j++) {\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k].reset();\n      }\n    }\n    string s;\n    cin >> s;\n    for (int j = 1; j <= n; j++) {\n      if (s[j - 1] == '#') continue;\n      int v = s[j - 1] - '0';\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k] = a[now][j - 1][k].f(a[now ^ 1][j][k]);\n        ans += a[now][j][k].count() * k * v;\n      }\n      a[now][j][v].set(c[v]++);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v){\n\t//\tint new_sz = v/d+2;\n\t\twek.resize((v/d)+2, 0);//while(wek.size() < new_sz) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[505];\nll ans;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n) B[i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[x].upper(9*(x*n+y)+9);\n\t\t\t\tif(x) oruj(B[x],B[x-1]);\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].licz());\n\t\t\t\trep(a,f[x][y]-'0') B[x].ustaw(9*(x*n+y)+a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].zeruj();\n\t\t\t\tB[x].upper(9*(x*n+y)+9);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <string>\n#define pb push_back\ntemplate <typename T1, typename T2> inline void umin(T1 &x, const T2 &y) { y < x ? (x = y) : 0; }\ntemplate <typename T1, typename T2> inline void umax(T1 &x, const T2 &y) { y > x ? (x = y) : 0; }\nint lp[2005][2005], rp[2005][2005], ul[2005], ur[2005], tmp[2005][2005];\nint sum_can[2005], sum_l[2005][2005], sum_r[2005][2005], sum_in[2005][2005];\nint bottom[2005], top[2005], que[2005], can_go[2005], unique[2005], bel_mn[2005][2005];\nstd::vector<int> vec[2005];\nbool del[2005];\nlong long ans;\ninline int calc_meet(int l, int r)\n{\n\tint pos = bel_mn[l][r];\n\tif (pos <= bottom[l] && pos <= bottom[r])\n\t\treturn pos;\n\treturn 1e9;\n}\ninline int calc_cnt(int l, int r, int lim = 1e9)\n{\n\tlim = std::min({lim, bottom[l], bottom[r]});\n\tif (calc_meet(l, r) > lim)\n\t\treturn 0;\n\treturn sum_can[lim] - sum_l[lim][l] - sum_r[lim][r] + sum_in[l][r];\n}\ntemplate <typename mapT>\nvoid work(const mapT &inp)\n{\n\tmapT str = inp;\n\tint n = str.size(), m = str[0].size();\n\tif (n < m)\n\t{\n\t\tmapT str_new(m, std::string(n, '#'));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tstr_new[j][i] = str[i][j];\n\t\t}\n\t\tstr = str_new;\n\t\tstd::swap(n, m);\n\t}\n\tif (m == 1)\n\t{\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (str[i][0] == '#')\n\t\t\t\tcur = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += (str[i][0] - '0') * cur;\n\t\t\t\tcur += str[i][0] - '0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint hu = n >> 1, hd = n - hu;\n\tmapT up(str.begin(), str.begin() + hu), down(str.begin() + hu, str.end());\n\twork(up);\n\twork(down);\n\tup.pb(down[0]);\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tlp[i][j] = 1e9;\n\t\t\trp[i][j] = -1e9;\n\t\t}\n\t}\n\t// lp & rp\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (down[0][i] != '#')\n\t\t\tlp[0][i] = rp[0][i] = i;\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (down[i][j] == '#')\n\t\t\t\tcontinue;\n\t\t\tif (i)\n\t\t\t{\n\t\t\t\tumin(lp[i][j], lp[i - 1][j]);\n\t\t\t\tumax(rp[i][j], rp[i - 1][j]);\n\t\t\t}\n\t\t\tif (j)\n\t\t\t{\n\t\t\t\tumin(lp[i][j], lp[i][j - 1]);\n\t\t\t\tumax(rp[i][j], rp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t// top\n\tfor (int i = 0; i <= hu; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (up[i][j] == '#')\n\t\t\t{\n\t\t\t\ttmp[i][j] = 1e9;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp[i][j] = i;\n\t\t\tif (i)\n\t\t\t\tumin(tmp[i][j], tmp[i - 1][j]);\n\t\t\tif (j)\n\t\t\t\tumin(tmp[i][j], tmp[i][j - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\ttop[i] = tmp[hu][i];\n\t// bottom\n\tfor (int i = hd - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (down[i][j] == '#')\n\t\t\t{\n\t\t\t\ttmp[i][j] = -1e9;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp[i][j] = i;\n\t\t\tif (i + 1 < hd)\n\t\t\t\tumax(tmp[i][j], tmp[i + 1][j]);\n\t\t\tif (j + 1 < m)\n\t\t\t\tumax(tmp[i][j], tmp[i][j + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tbottom[i] = tmp[0][i];\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tbel_mn[i][j] = 1e9;\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (lp[i][j] <= rp[i][j])\n\t\t\t\tumin(bel_mn[lp[i][j]][rp[i][j]], i);\n\t\t}\n\t}\n\tfor (int l = 0; l < m; l++)\n\t{\n\t\tfor (int r = m - 1; r >= l; r--)\n\t\t{\n\t\t\tif (l)\n\t\t\t\tumin(bel_mn[l][r], bel_mn[l - 1][r]);\n\t\t\tif (r + 1 < m)\n\t\t\t\tumin(bel_mn[l][r], bel_mn[l][r + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tsum_can[i] = 0;\n\t\tmemset(sum_l[i], 0, m << 2);\n\t\tmemset(sum_r[i], 0, m << 2);\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tmemset(sum_in[i], 0, m << 2);\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tif (i)\n\t\t{\n\t\t\tsum_can[i] = sum_can[i - 1];\n\t\t\tmemcpy(sum_l[i], sum_l[i - 1], m << 2);\n\t\t\tmemcpy(sum_r[i], sum_r[i - 1], m << 2);\n\t\t}\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (lp[i][j] > rp[i][j])\n\t\t\t\tcontinue;\n\t\t\tint val = down[i][j] - '0';\n\t\t\tsum_can[i] += val;\n\t\t\tif (lp[i][j])\n\t\t\t\tsum_l[i][lp[i][j] - 1] += val;\n\t\t\tif (rp[i][j] + 1 < m)\n\t\t\t\tsum_r[i][rp[i][j] + 1] += val;\n\t\t\tif (lp[i][j] && rp[i][j] + 1 < m)\n\t\t\t\tsum_in[lp[i][j] - 1][rp[i][j] + 1] += val;\n\t\t}\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = m - 2; j >= 0; j--)\n\t\t\tsum_l[i][j] += sum_l[i][j + 1];\n\t\tfor (int j = 1; j < m; j++)\n\t\t\tsum_r[i][j] += sum_r[i][j - 1];\n\t}\n\tfor (int l = m - 1; l >= 0; l--)\n\t{\n\t\tfor (int r = l; r < m; r++)\n\t\t{\n\t\t\tif (l + 1 < m)\n\t\t\t\tsum_in[l][r] += sum_in[l + 1][r];\n\t\t\tif (r)\n\t\t\t\tsum_in[l][r] += sum_in[l][r - 1];\n\t\t\tif (l + 1 < m && r)\n\t\t\t\tsum_in[l][r] -= sum_in[l + 1][r - 1];\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tcan_go[i] = calc_cnt(i, i);\n\tfor (int i = 0; i < hu; i++)\n\t\tvec[i].clear();\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tdel[i] = top[i] >= hu;\n\t\tif (!del[i])\n\t\t\tvec[top[i]].pb(i);\n\t}\n\tfor (int i = m - 1; i >= 0; i--)\n\t{\n\t\tif (up[hu][i] == '#')\n\t\t{\n\t\t\tul[i] = 1e9;\n\t\t\tur[i] = -1e9;\n\t\t\tcontinue;\n\t\t}\n\t\tul[i] = ur[i] = i;\n\t\tif (i + 1 < m)\n\t\t\tumax(ur[i], ur[i + 1]);\n\t}\n\tfor (int i = hu - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (up[i][j] == '#')\n\t\t\t{\n\t\t\t\tul[j] = 1e9;\n\t\t\t\tur[j] = -1e9;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + 1 < m)\n\t\t\t{\n\t\t\t\tumin(ul[j], ul[j + 1]);\n\t\t\t\tumax(ur[j], ur[j + 1]);\n\t\t\t}\n\t\t}\n\t\tint cur = 0, cl = 0, cr = -1, he = 0, ta = 0;\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (ul[j] > ur[j])\n\t\t\t\tcontinue;\n\t\t\twhile (cr < ur[j])\n\t\t\t{\n\t\t\t\tint x = ++cr;\n\t\t\t\tif (del[x])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (he < ta)\n\t\t\t\t{\n\t\t\t\t\tcur -= unique[que[ta - 1]];\n\t\t\t\t\tunique[que[ta - 1]] -= calc_cnt(que[ta - 1], x);\n\t\t\t\t\tcur += unique[que[ta - 1]];\n\t\t\t\t\tif (bottom[que[ta - 1]] <= bottom[x])\n\t\t\t\t\t\tta--;\n\t\t\t\t}\n\t\t\t\twhile (he < ta && bottom[que[ta - 1]] <= bottom[x])\n\t\t\t\t{\n\t\t\t\t\tta--;\n\t\t\t\t\tcur -= unique[que[ta - 1]];\n\t\t\t\t\tunique[que[ta - 1]] -= calc_cnt(que[ta - 1], x);\n\t\t\t\t\tunique[que[ta - 1]] += calc_cnt(que[ta - 1], x, bottom[que[ta]]);\n\t\t\t\t\tcur += unique[que[ta - 1]];\n\t\t\t\t}\n\t\t\t\tque[ta++] = x;\n\t\t\t\tunique[x] = can_go[x];\n\t\t\t\tcur += unique[x];\n\t\t\t}\n\t\t\twhile (cl < ul[j])\n\t\t\t{\n\t\t\t\tint x = cl++;\n\t\t\t\tif (del[x])\n\t\t\t\t\tcontinue;\n\t\t\t\tcur -= unique[x];\n\t\t\t\tif (he < ta && que[he] == x)\n\t\t\t\t\the++;\n\t\t\t}\n\t\t\tans += (up[i][j] - '0') * cur;\n\t\t}\n\t\tfor (int x : vec[i])\n\t\t\tdel[x] = true;\n\t}\n}\nchar str[2005];\nint main()\n{\n\t// freopen(\"AGC028-F.in\", \"r\", stdin);\n\tint n;\n\tscanf(\"%d\", &n);\n\tstd::vector<std::string> inp;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%s\", str);\n\t\tinp.pb(std::string(str));\n\t}\n\twork(inp);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n//#include <bits/stdc++.h>\n#include <stack>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n \n// C\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <stack>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n \n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n \nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef int LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n \n////////////////////////////////////////////////////////////////////////////////////////////\n \n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n \n}\nlong long ans = 0;\nlong long sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE];\nint val[SIZE][SIZE];\nLL times = 0,times2=0;\ninline LL dfs(int y, int x) {\n//\ttimes++;\n\tif (y > N or x > N or A[y][x] == 0 or reached[y][x]) return 0;\n\treached[y][x] = true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs252(int yy, int xx) {\n\tstack<pr> st;\n\tst.emplace(yy, xx);\n\tint ret = 0;\n\twhile (!st.empty()) {\n\t\tint y=st.top().first, x=st.top().second;\n\t\tif (val[y][x] == 0) {\n\t\t\tval[y][x] = -1;\n\t\t\treached[y][x] = 0;\n\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) st.emplace(y, x+1);\n\t\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) st.emplace(y + 1, x);\n\t\t}\n\t\telse {\n\t\t\tval[y][x] = val[y][x + 1] + val[y + 1][x];\n//\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) ret+=val[y][x + 1];\n\t//\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) ret+=val[y][x+1];\n\t\t\tst.pop();\n\t\t}\n\t}\n//\treached[y][x] = 0;\n//\treturn  (( ? dfs2(y, x + 1) : 0) + ( : 0) + A[y][x]);\n\treturn val[yy][xx];\n \n}\n \ninline LL dfs2(int y, int x) {\n\t//times++;\n\treached[y][x] = 0;\n\treturn  (((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0) ? dfs2(y, x + 1) : 0 )+ ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x]) ? dfs2(y + 1, x) : 0) + A[y][x]);\n}\nlong long solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i, 1, N) {\n\t\t//cout << \"A\";\n\t\tsum += dfs(x, i);\n\t\t//cout << \"B\";\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tsum -= A[x][i];\n\t\tans += (long long)sum* (long long)A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tif (A[x + 1][i] == 0) continue;\n\t\tif (reached[x + 1][i] == 0) continue;\n\t\tif (reached[x][i]) continue;\n \n\t\tsum -= dfs2(x + 1, i);\n\t//\tcout << \"C\" << endl;\n \n\t}\n//\tcout << times << \" \" << times2 << endl;\n\treturn ans;\n}\nlong long solve() {\n\tcin >> N;\n\tEFOR(i, 1, N) {\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1] - '0';\n\t\t}\n\t}\n//\tN = 300;\n//\tEFOR(i, 1, N) EFOR(j, 1, N) A[i][j] = 9;\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n \n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 64\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v){\n\t//\tint new_sz = v/d+2;\n\t\twek.resize((v/d)+2, 0);//while(wek.size() < new_sz) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[505];\nll ans;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n) B[i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[x].upper(9*(x*n+y)+9);\n\t\t\t\tif(x) oruj(B[x],B[x-1]);\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].licz());\n\t\t\t\trep(a,f[x][y]-'0') B[x].ustaw(9*(x*n+y)+a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].zeruj();\n\t\t\t\tB[x].upper(9*(x*n+y)+9);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\ntemplate<typename T>\nvector<T> createMatrix(int n, T def) {\n  return vector<T>(n * n, def);\n  //return vector<vector<T>>(n, vector<T>(n, def));\n}\n\nint main() {\n\n        int n; cin >> n;\n        auto wall = createMatrix(n, false);\n        auto a = createMatrix(n, (int) 0);\n        auto b = createMatrix(n, (int) 0);\n        \n        for (int i = 0; i < n; ++i) {\n            string s; while (s.empty()) cin >> s;\n            for (int j = 0; j < n; ++j) {\n                char ch = s[j];\n                if (ch == '#')\n                    wall[i*n+j] = true;\n                else {\n                    a[i*n+j] = b[i*n+j] = ch - '0';\n                }\n            }\n        }\n        int64 res = 0;\n        vector<int> perm(n * n);\n        for (int i = 0; i < n * n; ++i) perm[i] = i;\n        for (int i = 0, j = n * n - 1; i < j; ++i, --j) {\n            int t = perm[i];\n            perm[i] = perm[j];\n            perm[j] = t;\n        }\n        auto seen = createMatrix(n, (int) 0);\n        auto best = createMatrix(n, (int) 0);\n        auto via = createMatrix(n, (int) 0);\n        vector<int> qr(n * n);\n        vector<int> qc(n * n);\n        vector<int> pr(2 * n);\n        vector<int> pc(2 * n);\n        int generation = 0;\n        int iters = 0;\n        for (int ss : perm) {\n            int sr = ss / n;\n            int sc = ss % n;\n            if (b[sr*n+sc] == 0) {\n              wall[sr*n+sc] = true;\n              continue;\n            }\n            ++iters;\n            int plen = 0;\n            {\n                ++generation;\n                int qt = 0;\n                int qh = 1;\n                qr[0] = sr;\n                qc[0] = sc;\n                best[sr*n+sc] = 0;\n                seen[sr*n+sc] = generation;\n                int globalBest = 0;\n                int globalBr = sr;\n                int globalBc = sc;\n                while (qt < qh) {\n                    int r = qr[qt];\n                    int c = qc[qt];\n                    int cbest = best[r*n+c];\n                    if (cbest > globalBest) {\n                        globalBest = cbest;\n                        globalBr = r;\n                        globalBc = c;\n                    }\n                    ++qt;\n                    if (r + 1 < n) {\n                        int nr = r + 1;\n                        int nc = c;\n                        if (!wall[nr*n+nc]) {\n                            int extra = b[nr*n+nc] > 0 ? 1 : 0;\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest + extra) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest + extra;\n                                via[nr*n+nc] = 1;\n                            }\n                        }\n                    }\n                    if (c + 1 < n) {\n                        int nr = r;\n                        int nc = c + 1;\n                        if (!wall[nr*n+nc]) {\n                            int extra = b[nr*n+nc] > 0 ? 1 : 0;\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest + extra) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest + extra;\n                                via[nr*n+nc] = 2;\n                            }\n                        }\n                    }\n                }\n                int r = globalBr;\n                int c = globalBc;\n                while (r != sr || c != sc) {\n                    pr[plen] = r;\n                    pc[plen] = c;\n                    ++plen;\n                    if (via[r*n+c] == 1) {\n                        --r;\n                    } else {\n                        --c;\n                    }\n                }\n            }\n            pr[plen] = sr;\n            pc[plen] = sc;\n            ++plen;\n            {\n                ++generation;\n                int qt = 0;\n                int qh = 1;\n                qr[0] = sr;\n                qc[0] = sc;\n                best[sr*n+sc] = 0;\n                seen[sr*n+sc] = generation;\n                int globalBest = 0;\n                int globalBr = sr;\n                int globalBc = sc;\n                while (qt < qh) {\n                    int r = qr[qt];\n                    int c = qc[qt];\n                    int cbest = best[r*n+c];\n                    if (cbest > globalBest) {\n                        globalBest = cbest;\n                        globalBr = r;\n                        globalBc = c;\n                    }\n                    ++qt;\n                    if (r - 1 >= 0) {\n                        int nr = r - 1;\n                        int nc = c;\n                        if (!wall[nr*n+nc]) {\n                            int extra = b[nr*n+nc] > 0 ? 1 : 0;\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest + extra) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest + extra;\n                                via[nr*n+nc] = 1;\n                            }\n                        }\n                    }\n                    if (c - 1 >= 0) {\n                        int nr = r;\n                        int nc = c - 1;\n                        if (!wall[nr*n+nc]) {\n                            int extra = b[nr*n+nc] > 0 ? 1 : 0;\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest + extra) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest + extra;\n                                via[nr*n+nc] = 2;\n                            }\n                        }\n                    }\n                }\n                int r = globalBr;\n                int c = globalBc;\n                int splen = plen;\n                while (r != sr || c != sc) {\n                    pr[plen] = r;\n                    pc[plen] = c;\n                    ++plen;\n                    if (via[r*n+c] == 1) {\n                        ++r;\n                    } else {\n                        ++c;\n                    }\n                }\n                for (int i = splen, j = plen - 1; i < j; ++i, --j) {\n                    int t = pr[i];\n                    pr[i] = pr[j];\n                    pr[j] = t;\n                    t = pc[i];\n                    pc[i] = pc[j];\n                    pc[j] = t;\n                }\n            }\n            {\n                ++generation;\n                int sofar = 0;\n                for (int i = 0; i < plen; ++i) {\n                    seen[pr[i]*n+pc[i]] = generation;\n                    res -= a[pr[i]*n+pc[i]] * b[pr[i]*n+pc[i]];\n                    sofar += b[pr[i]*n+pc[i]];\n                    b[pr[i]*n+pc[i]] = 0;\n                    best[pr[i]*n+pc[i]] = sofar;\n                }\n                int qt = 0;\n                int qh = 0;\n                int nextPath = 0;\n                while (qt < qh || nextPath < plen) {\n                    if (qt == qh) {\n                        qr[qh] = pr[nextPath];\n                        qc[qh] = pc[nextPath];\n                        ++nextPath;\n                        ++qh;\n                    }\n                    int r = qr[qt];\n                    int c = qc[qt];\n                    int cbest = best[r*n+c];\n                    res += cbest * a[r*n+c];\n                    ++qt;\n                    if (r - 1 >= 0) {\n                        int nr = r - 1;\n                        int nc = c;\n                        if (!wall[nr*n+nc]) {\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest;\n                            }\n                        }\n                    }\n                    if (c - 1 >= 0) {\n                        int nr = r;\n                        int nc = c - 1;\n                        if (!wall[nr*n+nc]) {\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest;\n                                via[nr*n+nc] = 2;\n                            }\n                        }\n                    }\n                    if (nextPath < plen && r + c == pr[nextPath] + pc[nextPath]) {\n                        --qt;\n                        qr[qt] = pr[nextPath];\n                        qc[qt] = pc[nextPath];\n                        ++nextPath;\n                    }\n                }\n            }\n            wall[sr*n+sc] = true;\n        }\n        cout << res << endl;\n   }                                        \n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[N][N],r[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;i++)scanf(\"%s\",A[i]+1);\n\tfor (register int i=0;i<=n;i++)\n\t\tfor (register int j=0;j<=n;j++)u[i][j]=A[i][j]>='0'&&A[i][j]<='9'?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;x++)\n\t\tfor (register int i=x;i;i--){\n\t\t\tfor (register int j=1;j<=n;j++)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (register int j=n+1;j;j--){\n\t\t\t\tif (A[i][j]>='0'&&A[i][j]<='9'){\n\t\t\t\t\tif (i<x){\n\t\t\t\t\t\tl[i][j]=min(l[i][j+1],l[i+1][j]);\n\t\t\t\t\t\tr[i][j]=max(r[i][j+1],r[i+1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse l[i][j]=j,r[i][j]=j;\n\t\t\t\t}\n\t\t\t\telse l[i][j]=1e9,r[i][j]=-1;\n\t\t\t\tif (l[i][j]<=r[i][j])ans+=(A[i][j]-'0')*(S[r[i][j]]-S[l[i][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t}\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing vl = vector<ll>;\nusing vi = vector<int>;\n\n#define rng(i, a, b) for(int i = (a); i < (b); ++i)\n#define rep(n) for(int _ = 0, __ = (int)n; _ < __; _++)\n#define stp(i, a, b, c) for (int i = (a); i < (b); i += (c))\n#define FOR(x, cont) for (auto &x: cont)\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) (int)(x).size()\n#define pq(T,COMP) priority_queue<T, vector<T>, COMP>\nauto bet = [](const ll x, const ll y, const ll i) {\n    return x <= i && i <= y;\n};\nusing pii = pair<int,int>;\nusing vb = vector<bool>;\n\nvi get_prime(int n) {\n    vi minp(n+1);\n    vi p;\n    for (int i = 2; i <= n; i++) {\n        if (!minp[i]) {\n            minp[i] = i;\n            p.pb(i);\n        }\n        FOR(x, p) {\n            if (x <= minp[i] && x * i <= n)\n                minp[x * i] = x;\n        }\n    }\n    return p;\n}\n\nconst int mod = 1e9 + 7;\n\nvoid add_mod(ll &x, const ll &y) {\n    x += y;\n    if (x >= mod) x -= mod;\n}\nvoid sub_mod(ll &x, const ll &y) {\n    x -= y;\n    if (x < 0) x += mod;\n}\n\n\n// AGC028 F Reachable Cells\n// 不能O(1)转移，考虑O(n)转移\n// 理解 tourist 代码 https://agc028.contest.atcoder.jp/submissions/3398112\n// L[i][j][k]:从(i,j)能走到的第k行的最左端是列的编号（k >= i）\n// R[i][j][k]:.....................右..................\n// L[i][j][k]:初始值为n\n// R[i][j][k]:初始值为0\n// 需要注意的是：并不是L[i][j][k]和R[i][j][k]之间所有的非'#'点都是可以到达的。\nconst int N = 505;\nint L[N][N][N], R[N][N][N];\nint row[N][N];\n\nint main() {\n#ifdef LOCAL\n    freopen(\"main.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n    vector<string> b(n);\n    rng (i, 0, n) cin >> b[i];\n    vector<vector<int>> a(n, vector<int>(n));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            a[i][j] = b[i][j] == '#' ? 0 : b[i][j] - '0';\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = 0; j < n; j++) {\n            sum += a[i][j];\n            row[i][j] = sum;\n        }\n    }\n\n    ll ans = 0;\n    function<void(int,int)> put=[&](int x, int y) {\n        if (x >= 0 && x < n && y >= 0 && y < n && a[x][y] > 0) {\n            // 若某个点上边被堵住了，左边也被堵住了，那么对于这个点左上侧的点来说，这个点是不可到达的\n            if (x == 0 || a[x-1][y] == 0)\n                if (y == 0 || a[x][y - 1] == 0) {\n                    rng (k, y, n) row[x][k] -= a[x][y];\n                    a[x][y] = 0;\n                    put(x + 1, y);\n                    put(x, y + 1);\n                }\n        }\n    };\n\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = n -1 ; j >= 0; --j) {\n            if (a[i][j] > 0) {\n//                cout <<\"POINT: \" << i << ' ' << j << endl;\n                // 初始化\n                rng(k, i, n) {\n                    L[i][j][k] = n;\n                    R[i][j][k] = 0;\n                }\n                L[i][j][i] = j;\n                R[i][j][i] = j;\n                // end 初始化\n                if (i < n - 1 && a[i + 1][j] > 0) {\n                    rng (k, i + 1, n) {\n                        L[i][j][k] = min(L[i][j][k], L[i + 1][j][k]);\n                        R[i][j][k] = max(R[i][j][k], R[i + 1][j][k]);\n                    }\n                }\n                if (j < n - 1 && a[i][j + 1] > 0) {\n                    rng (k, i, n) {\n                        L[i][j][k] = min(L[i][j][k], L[i][j + 1][k]);\n                        R[i][j][k] = max(R[i][j][k], R[i][j + 1][k]);\n                    }\n                }\n                int sum = 0;\n                rng (k, i, n) {\n                    if (L[i][j][k] <= R[i][j][k]) {\n//                        cout << k << \": \" << L[i][j][k] << ' ' << R[i][j][k] << endl;\n                        sum += L[i][j][k] == 0 ? row[k][R[i][j][k]] : row[k][R[i][j][k]] - row[k][L[i][j][k] - 1];\n                    }\n                }\n                ans += a[i][j] * (sum - a[i][j]);\n//                cout << \"ans: \" << ans << endl;\n                put(i, j);\n            }\n        }\n    }\n\n    cout << ans << '\\n';\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1<<29)\nusing namespace std;\nconst int N=1505;\nchar s[N];\nint n,cnt[N];\nll ans;\nint a[N][N],sum[N][N];\nint tl[N][N],tr[N][N];\nvoid recalc(int i){\n\tFor(j,1,n) sum[i][j]=sum[i][j-1]+a[i][j];\n}\nint S(int i,int l,int r){\n\treturn sum[i][r]-sum[i][l-1];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFor(j,1,n) a[i][j]=(s[j]=='#'?0:s[j]-48);\n\t\trecalc(i);\n\t}\n\tFor(i,1,n) For(j,1,n+1)\n\t\ttl[i][j]=n+1,tr[i][j]=0;\n\tFor(y,1,n) Rep(j,n,1) if(a[y][j]){\n\t\ttl[y][j]=j; tr[y][j]=max(j,tr[y][j+1]);\n\t\tans+=a[y][j]*S(y,tl[y][j]+1,tr[y][j]);\n\t}\n\tRep(x,n,1) For(y,x+1,n){\n\t\tRep(j,n,1)\n\t\t\tif (a[x][j]){\n\t\t\t\ttl[y][j]=min(tl[y][j],tl[y][j+1]);\n\t\t\t\ttr[y][j]=max(tr[y][j],tr[y][j+1]);\n\t\t\t}\n\t\t\telse tl[y][j]=n+1,tr[y][j]=0;\n\t\tFor(j,1,n) cnt[j]=0;\n\t\tFor(j,1,n) if (tl[y][j]<=tr[y][j]){\n\t\t\tans+=a[x][j]*(sum[y][tr[y][j]]-sum[y][tl[y][j]-1]);\n\t\t\t++cnt[tl[y][j]]; --cnt[tr[y][j]+1];\n\t\t}\n\t\tbool flag=0;\n\t\tFor(j,1,n){\n\t\t\tcnt[j]+=cnt[j-1];\n\t\t\tif (!cnt[j]&&a[y][j])\n\t\t\t\ta[y][j]=0,flag=1;\n\t\t}\n\t\tif (flag) recalc(y);\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void upi(int&a,const int&b){a>b?a=b:0;}\nconst int N=1505;\nint n,i,j,x,a[N][N];\nchar c[N][N];\nlong long ans;\nint L[N][N],R[N][N],B[N],tB[N][N],Mp[N][N],tMp[N][N],Rch[N];\nint s1[N][N],s2[N][N],s3[N][N],Lu[N][N],Ru[N][N],T[N],tT[N][N],sm,only[N];\nint q[N],xb,lp,rp,q2[N],t,w;\ninline int Brh(int x,int y,int l){l=min(l,min(B[x],B[y]));return l<Mp[x][y]?0:s1[l][n]-s1[l][y-1]-s2[l][x+1]+s3[x+1][y-1];}\ninline void upd(int w){\n\tx=Brh(q2[w],q[rp],min(B[q2[w]],B[q[rp]]))-(q2[w+1]?Brh(q2[w],q[rp],B[q2[w+1]]):0);\n\tsm-=x;only[q2[w]]-=x;\n}\nvoid solve(int lb,int rb){\n\tif(lb==rb)return;int mid=lb+rb>>1;solve(lb,mid);solve(mid+1,rb);\n\tfor(i=mid+1;i<=rb+1;++i)for(j=0;j<=n+1;++j)L[i][j]=N,R[i][j]=0,tB[i][j]=0;\n\tfor(i=mid+1;i<=rb;++i)memset(s1[i],0,n+2<<2),memset(s2[i],0,n+2<<2);for(i=1;i<=n;++i)memset(s3[i]+i,0,n-i+1<<2);\n\tfor(i=1;i<=n;++i)for(j=i;j<=n;++j)tMp[i][j]=N;\n\tfor(j=1;j<=n;++j)if(a[mid+1][j])L[mid+1][j]=a[mid+1][j-1]?L[mid+1][j-1]:j,R[mid+1][j]=j;\n\tfor(i=mid+2;i<=rb;++i)for(j=1;j<=n;++j)if(a[i][j])\n\t\tL[i][j]=min(L[i-1][j],L[i][j-1]),R[i][j]=max(R[i-1][j],R[i][j-1]);\n\tfor(i=rb;i>=mid+1;--i)for(j=n;j;--j)if(a[i][j])tB[i][j]=max(i,max(tB[i+1][j],tB[i][j+1]));memcpy(B,tB[mid+1],n+2<<2);\n\n\tfor(i=mid+1;i<=rb;++i)for(j=1;j<=n;++j)if(R[i][j])upi(tMp[L[i][j]][R[i][j]],i);\n\tfor(i=1;i<n;++i)for(j=n;j>i;--j)upi(tMp[i][j-1],tMp[i][j]);\n\tfor(i=1;i<n;++i)for(j=i+1;j<=n;++j)upi(tMp[i+1][j],tMp[i][j]);\n\tfor(i=1;i<n;++i)for(j=i;j<=n;++j)if(a[mid+1][i] && a[mid+1][j])\n\t\tMp[i][j]=tMp[i][j]<=min(B[i],B[j])?tMp[i][j]:N;\n\tfor(i=mid+1;i<=rb;++i)for(j=1;j<=n;++j)if(R[i][j])\n\t\ts1[i][R[i][j]]+=a[i][j],s2[i][L[i][j]]+=a[i][j],s3[L[i][j]][R[i][j]]+=a[i][j];\n\tfor(i=mid+1;i<=rb;++i){\n\t\tfor(j=2;j<=n;++j)s1[i][j]+=s1[i][j-1];for(j=n-1;j;--j)s2[i][j]+=s2[i][j+1];\n\t\tif(i>mid+1)for(j=1;j<=n;++j)s1[i][j]+=s1[i-1][j],s2[i][j]+=s2[i-1][j];\n\t}\n\tfor(i=1;i<n;++i)for(j=i+1;j<=n;++j)s3[i][j]+=s3[i][j-1];\n\tfor(i=n-1;i;--i)for(j=i+1;j<=n;++j)s3[i][j]+=s3[i+1][j];\n\tfor(i=1;i<=n;++i)if(a[mid+1][i])Rch[i]=Brh(i,i,rb);\n\n\tfor(i=lb-1;i<=mid+1;++i)for(j=0;j<=n+1;++j)Lu[i][j]=N,Ru[i][j]=0,tT[i][j]=N;\n\tfor(j=n;j;--j)if(a[mid+1][j])Ru[mid+1][j]=a[mid+1][j+1]?Ru[mid+1][j+1]:j,Lu[mid+1][j]=j;\n\tfor(i=mid;i>=lb;--i)for(j=n;j;--j)if(a[i][j])\n\t\tLu[i][j]=min(Lu[i+1][j],Lu[i][j+1]),Ru[i][j]=max(Ru[i+1][j],Ru[i][j+1]);\n\tfor(i=lb;i<=mid+1;++i)for(j=1;j<=n;++j)if(a[i][j])tT[i][j]=min(i,min(tT[i-1][j],tT[i][j-1]));memcpy(T,tT[mid+1],n+2<<2);\n\t\n\tfor(i=mid;i>=lb;--i){\n\t\tlp=t=1;xb=rp=w=sm=0;for(j=1;j<=n;++j)if(T[j]<=i)q[++xb]=j;\n\t\tfor(j=1;j<=n;++j)if(Ru[i][j]){\n\t\t\tfor(;rp<xb && q[rp+1]<=Ru[i][j];){\n\t\t\t\t++rp;sm+=only[q[rp]]=Rch[q[rp]];for(;t<=w && B[q2[w]]<=B[q[rp]];--w)upd(w);\n\t\t\t\tif(t<=w)upd(t);q2[++w]=q[rp];q2[w+1]=0;\n\t\t\t}\n\t\t\tfor(;lp<=rp && q[lp]<Lu[i][j];)sm-=only[q[lp++]];for(;t<=w && q2[t]<Lu[i][j];++t);\n\t\t\tans+=a[i][j]*sm;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)scanf(\"%s\",c[i]+1);\n\tfor(i=1;i<=n;++i)for(j=n,x=0;j;--j){\n\t\ta[i][j]=c[i][j]=='#'?0:c[i][j]-'0';\n\t\tif(a[i][j])ans+=x*a[i][j],x+=a[i][j];else x=0;\n\t}\n\tsolve(1,n);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define fi first\n#define se second\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define eef(i,x)for(int i=head[x],y=e[i].to;y;i=e[i].next,y=e[i].to)\nint read(){char c=getchar();int d=0,f=1;for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;for(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());return d*f;}\nchar Read(){char c=getchar();while(c<'0'||c>'9')c=getchar();return c;}\nint getdigit(char c){return (c<'0'||c>'9')?-1e9:(c-'0');}\ntypedef pair<int,int>PII;\ntypedef long long LL;\nconst double pi=acos(-1);\nconst int N=1510,mod=1e9+7;\nint n,ans,dp[N][N],c1[N][N],c2[N][N];\nchar a[N][N];\nint main(){\n\tn=read();\n\tref(i,1,n)scanf(\"%s\",a[i]+1);\n\tref(i,1,n){\n\t\tif(i==1){\n\t\t\tref(j,1,n)dp[i][j]=max(0,dp[i][j-1]+getdigit(a[i][j]));\n\t\t\tref(j,1,n)c1[j][1]=j;\n\t\t\tcontinue;\n\t\t}\n\t\tref(j,1,n){\n\t\t\tbool w1=getdigit(a[i][j-1])>=0,w2=getdigit(a[i-1][j])>=0;\n\t\t\tbool W1=getdigit(a[i-1][j-1])>=0,W2=getdigit(a[i-2][j])>=0;\n\t\t\tref(k,1,i){\n\t\t\t\tint C1=0;\n\t\t\t\tif(k==i)C1=j;else{\n\t\t\t\t\tif(w1)C1=c1[j-1][k];\n\t\t\t\t\tif(w2)C1=max(C1,c1[j][k]);\n\t\t\t\t}\n\t\t\t\tc1[j][k]=C1;\n\t\t\t}\n\t\t\tref(k,1,i-1){\n\t\t\t\tint C2=1e9;\n\t\t\t\tif(k==i-1)C2=j;\n\t\t\t\tif(W1)C2=c2[j-1][k];\n\t\t\t\tif(W2&&k!=i-1)C2=min(C2,c2[j][k]);\n\t\t\t\tc2[j][k]=C2;\n\t\t\t}\n\t\t}\n\t\tref(j,1,n)if(getdigit(a[i][j])>=0){\n\t\t\tint v=getdigit(a[i][j]);\n\t\t\tbool w1=getdigit(a[i][j-1])>=0,w2=getdigit(a[i-1][j])>=0;\n\t\t\tif(j==1){\n\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t}else if(j>1){\n\t\t\t\tif(!w1&&!w2)dp[i][j]=0;else\n\t\t\t\tif( w1&&!w2)dp[i][j]=dp[i][j-1];else\n\t\t\t\tif(!w1&& w2)dp[i][j]=dp[i-1][j];else\n\t\t\t\tif( w1&& w2){\n\t\t\t\t\tint s=dp[i-1][j]+dp[i][j-1],la=1e9;\n\t\t\t\t\tdef(k,i-1,1){\n\t\t\t\t\t\tif(c1[j-1][k]>=c2[j][k]&&la>c1[j-1][k])\n\t\t\t\t\t\t\ts-=dp[k][c1[j-1][k]];\n\t\t\t\t\t\tla=c2[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]=s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j]+=v;\n\t\t}\n\t}\n\tref(i,1,n)ref(j,1,n){\n\t\tint v=getdigit(a[i][j]);\n\t\tif(v>=0)ans+=(dp[i][j]-v)*v;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include <bits/stdc++.h>\n//#include \"stdafx.h\"\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef int LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nlong long ans = 0;\nLL sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE];\ninline LL dfs(int y, int x) {\n\tif (y > N or x > N or A[y][x] == 0 or reached[y][x]) return 0;\n\treached[y][x] = true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\ninline LL dfs2(int y, int x) {\n\t//\tcout << y << \" \" << x << endl;\n\n\t//cout << y << \" \" << x << endl;\n\treached[y][x] = 0;\n\t//LL ret = 0;\n\t//if (x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)\n\t//\tret += dfs2(y, x + 1);\n\t//if (y + 1 <= N and A[y + 1][x] and reached[y + 1][x])\n\t//\tret += dfs2(y + 1, x);\n\treturn  (((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0) ? dfs2(y, x + 1) : 0 )+ ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x]) ? dfs2(y + 1, x) : 0) + A[y][x]);\n\t//return ret + A[y][x];\n}\nLL solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i, 1, N) {\n\t\tsum += dfs(x, i);\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tans += (sum - A[x][i])* A[x][i];\n\t\t//cout << ans << endl;\n\t\tsum -= A[x][i];\n\t\treached[x][i] = false;\n\t\tif (A[x + 1][i] == 0) continue;\n\t\tif (reached[x + 1][i] == 0) continue;\n\t\tif (reached[x][i]) continue;\n\t\tsum -= dfs2(x + 1, i);\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N;\n\tEFOR(i, 1, N) {\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1] - '0';\n\t\t}\n\t}\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint val[N][N],b[N][N],S[N],n,u[N][N],l[N],r[N];\nchar A[N][N];\nbool flag[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9',b[i][j]=A[i][j]-'0';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=x?b[x][j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x][j]){\n\t\t\t\tl[j]=j-1;\n\t\t\t\tr[j]=max(r[j+1],j);\n\t\t\t\tval[x][j]+=(S[r[j]]-S[l[j]]-b[x][j]);\n\t\t\t}\n\t\t\telse l[j]=n+1,r[j]=0;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?b[x][j]:0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tl[j]=min(l[j+1],l[j]);\n\t\t\t\t\tr[j]=max(r[j+1],r[j]);\n\t\t\t\t\tval[i][j]+=(S[r[j]]-S[l[j]]);\n\t\t\t\t}\n\t\t\t\telse l[j]=n+1,r[j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)ans+=val[i][j]*b[i][j];\n\tprintf(\"%lld\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) if(a[i][j]) {\n\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\tif(!(t[0]|t[1])) {\n\t\t\tl[i][j]=r[i][j]=j;\n\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t}\n\t\telse if(t[0]&&!t[1]) {\n\t\t\tl[i][j]=r[i][j]=j;\n\t\t\tf[i][j]=f[i+1][j];\n\t\t}\n\t\telse if(!t[0]&&t[1]) {\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t}\n\t\telse {\n\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\n\t\t\tint las_r=0;\t\t\n\t\t\tfor1(i+1,n,k) {\n\t\t\t\tif(r[k][j]>=l[k][j+1]&&l[k][j+1]>las_r) {\n\t\t\t\t\ttot-=f[k][l[k][j+1]];\n\t\t\t\t\tlas_r=r[k][j];\n\t\t\t\t}\n\t\t\t\tif(!(l[k][j]+r[k][j])||l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\tf[i][j]=tot;\n\t\t}\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\t//bitsetに賭ける\n\tint i,j,n;cin>>n;\n\tbitset<250000>one;\n\tbitset<250000>two;\n\tbitset<250000>yon;\n\tbitset<250000>hat;\n\tvector<string>math(n+1);\n\tllint ans=0;\n\tfor(i=0;i<n;i++){\n\t\tcin>>math[i];math[i].pub('#');\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(math[i][j]=='#'){continue;}\n\t\t\tif((math[i][j]-'0')&1){one[i*n+j]=1;}\n\t\t\tif((math[i][j]-'0')&2){two[i*n+j]=1;}\n\t\t\tif((math[i][j]-'0')&4){yon[i*n+j]=1;}\n\t\t\tif((math[i][j]-'0')&8){hat[i*n+j]=1;}\n\t\t}\n\t}\n\tfor(j=0;j<=n;j++){math[n].pub('#');}\n\tbitset<250000>kara;\n\tvector<bitset<250000>>tou(n+1);\n\tfor(i=n-1;i>=0;i--){\n\t\tfor(j=n-1;j>=0;j--){\n\t\t\tif(math[i][j]=='#'){tou[j]=kara;continue;}\n\t\t\ttou[j]|=tou[j+1];\n\t\t\tans+=(math[i][j]-'0')*1*((tou[j]&one).count());\n\t\t\tans+=(math[i][j]-'0')*2*((tou[j]&two).count());\n\t\t\tans+=(math[i][j]-'0')*4*((tou[j]&yon).count());\n\t\t\tans+=(math[i][j]-'0')*8*((tou[j]&hat).count());\n\t\t\ttou[j][i*n+j]=1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 505;\nusing Bs = bitset<N * N>;\n\nBs bss[2][N];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<string> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tlong long ans = 0;\n\tfor (int d = 1; d <= 9; ++d) {\n\t\tfor (int sum = n + n - 2, _ = 0; sum >= 0; --sum, _ ^= 1) {\n\t\t\tint l = max(0, sum - n + 1);\n\t\t\tint r = min(n - 1, sum);\n\t\t\tfor (int i = l; i <= r; ++i) {\n\t\t\t\tbss[_][i] = {};\n\t\t\t\tint j = sum - i;\n\t\t\t\tif (a[i][j] == '#') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (i + 1 < n) {\n\t\t\t\t\tbss[_][i] |= bss[_ ^ 1][i + 1];\n\t\t\t\t\tif (a[i + 1][j] == '0' + d) {\n\t\t\t\t\t\tbss[_][i].flip((i + 1) * n + j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j + 1 < n) {\n\t\t\t\t\tbss[_][i] |= bss[_ ^ 1][i];\n\t\t\t\t\tif (a[i][j + 1] == '0' + d) {\n\t\t\t\t\t\tbss[_][i].flip(i * n + (j + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += ((long long)a[i][j] - '0') * d * bss[_][i].count();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\ntemplate<typename T>\nvector<vector<T>> createMatrix(int n, T def) {\n  return vector<vector<T>>(n, vector<T>(n, def));\n}\n\nint main() {\n\n        int n; cin >> n;\n        auto wall = createMatrix(n, false);\n        auto a = createMatrix(n, (int) 0);\n        auto b = createMatrix(n, (int) 0);\n        \n        for (int i = 0; i < n; ++i) {\n            string s; while (s.empty()) cin >> s;\n            for (int j = 0; j < n; ++j) {\n                char ch = s[j];\n                if (ch == '#')\n                    wall[i][j] = true;\n                else {\n                    a[i][j] = b[i][j] = ch - '0';\n                }\n            }\n        }\n        int64 res = 0;\n        vector<int> perm(n * n);\n        for (int i = 0; i < n * n; ++i) perm[i] = i;\n        for (int i = 0; i < n * n; ++i) {\n            int j = rand() % (i + 1);\n            int t = perm[i];\n            perm[i] = perm[j];\n            perm[j] = t;\n        }\n        auto seen = createMatrix(n, (int) 0);\n        auto best = createMatrix(n, (int) 0);\n        auto via = createMatrix(n, (int) 0);\n        vector<int> qr(n * n);\n        vector<int> qc(n * n);\n        vector<int> pr(2 * n);\n        vector<int> pc(2 * n);\n        int generation = 0;\n        int iters = 0;\n        for (int ss : perm) {\n            int sr = ss / n;\n            int sc = ss % n;\n            if (b[sr][sc] == 0) continue;\n            ++iters;\n            int plen = 0;\n            {\n                ++generation;\n                int qt = 0;\n                int qh = 1;\n                qr[0] = sr;\n                qc[0] = sc;\n                best[sr][sc] = 0;\n                seen[sr][sc] = generation;\n                int globalBest = 0;\n                int globalBr = sr;\n                int globalBc = sc;\n                while (qt < qh) {\n                    int r = qr[qt];\n                    int c = qc[qt];\n                    int cbest = best[r][c];\n                    if (cbest > globalBest) {\n                        globalBest = cbest;\n                        globalBr = r;\n                        globalBc = c;\n                    }\n                    ++qt;\n                    if (r + 1 < n) {\n                        int nr = r + 1;\n                        int nc = c;\n                        if (!wall[nr][nc]) {\n                            int extra = b[nr][nc] > 0 ? 1 : 0;\n                            if (seen[nr][nc] < generation || best[nr][nc] < cbest + extra) {\n                                if (seen[nr][nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr][nc] = generation;\n                                best[nr][nc] = cbest + extra;\n                                via[nr][nc] = 1;\n                            }\n                        }\n                    }\n                    if (c + 1 < n) {\n                        int nr = r;\n                        int nc = c + 1;\n                        if (!wall[nr][nc]) {\n                            int extra = b[nr][nc] > 0 ? 1 : 0;\n                            if (seen[nr][nc] < generation || best[nr][nc] < cbest + extra) {\n                                if (seen[nr][nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr][nc] = generation;\n                                best[nr][nc] = cbest + extra;\n                                via[nr][nc] = 2;\n                            }\n                        }\n                    }\n                }\n                int r = globalBr;\n                int c = globalBc;\n                while (r != sr || c != sc) {\n                    pr[plen] = r;\n                    pc[plen] = c;\n                    ++plen;\n                    if (via[r][c] == 1) {\n                        --r;\n                    } else {\n                        --c;\n                    }\n                }\n            }\n            pr[plen] = sr;\n            pc[plen] = sc;\n            ++plen;\n            {\n                ++generation;\n                int qt = 0;\n                int qh = 1;\n                qr[0] = sr;\n                qc[0] = sc;\n                best[sr][sc] = 0;\n                seen[sr][sc] = generation;\n                int globalBest = 0;\n                int globalBr = sr;\n                int globalBc = sc;\n                while (qt < qh) {\n                    int r = qr[qt];\n                    int c = qc[qt];\n                    int cbest = best[r][c];\n                    if (cbest > globalBest) {\n                        globalBest = cbest;\n                        globalBr = r;\n                        globalBc = c;\n                    }\n                    ++qt;\n                    if (r - 1 >= 0) {\n                        int nr = r - 1;\n                        int nc = c;\n                        if (!wall[nr][nc]) {\n                            int extra = b[nr][nc] > 0 ? 1 : 0;\n                            if (seen[nr][nc] < generation || best[nr][nc] < cbest + extra) {\n                                if (seen[nr][nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr][nc] = generation;\n                                best[nr][nc] = cbest + extra;\n                                via[nr][nc] = 1;\n                            }\n                        }\n                    }\n                    if (c - 1 >= 0) {\n                        int nr = r;\n                        int nc = c - 1;\n                        if (!wall[nr][nc]) {\n                            int extra = b[nr][nc] > 0 ? 1 : 0;\n                            if (seen[nr][nc] < generation || best[nr][nc] < cbest + extra) {\n                                if (seen[nr][nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr][nc] = generation;\n                                best[nr][nc] = cbest + extra;\n                                via[nr][nc] = 2;\n                            }\n                        }\n                    }\n                }\n                int r = globalBr;\n                int c = globalBc;\n                int splen = plen;\n                while (r != sr || c != sc) {\n                    pr[plen] = r;\n                    pc[plen] = c;\n                    ++plen;\n                    if (via[r][c] == 1) {\n                        ++r;\n                    } else {\n                        ++c;\n                    }\n                }\n                for (int i = splen, j = plen - 1; i < j; ++i, --j) {\n                    int t = pr[i];\n                    pr[i] = pr[j];\n                    pr[j] = t;\n                    t = pc[i];\n                    pc[i] = pc[j];\n                    pc[j] = t;\n                }\n            }\n            {\n                ++generation;\n                int sofar = 0;\n                for (int i = 0; i < plen; ++i) {\n                    seen[pr[i]][pc[i]] = generation;\n                    res -= a[pr[i]][pc[i]] * b[pr[i]][pc[i]];\n                    sofar += b[pr[i]][pc[i]];\n                    b[pr[i]][pc[i]] = 0;\n                    best[pr[i]][pc[i]] = sofar;\n                }\n                int qt = 0;\n                int qh = 0;\n                int nextPath = 0;\n                while (qt < qh || nextPath < plen) {\n                    if (qt == qh) {\n                        qr[qh] = pr[nextPath];\n                        qc[qh] = pc[nextPath];\n                        ++nextPath;\n                        ++qh;\n                    }\n                    int r = qr[qt];\n                    int c = qc[qt];\n                    int cbest = best[r][c];\n                    res += cbest * a[r][c];\n                    ++qt;\n                    if (r - 1 >= 0) {\n                        int nr = r - 1;\n                        int nc = c;\n                        if (!wall[nr][nc]) {\n                            if (seen[nr][nc] < generation || best[nr][nc] < cbest) {\n                                if (seen[nr][nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr][nc] = generation;\n                                best[nr][nc] = cbest;\n                            }\n                        }\n                    }\n                    if (c - 1 >= 0) {\n                        int nr = r;\n                        int nc = c - 1;\n                        if (!wall[nr][nc]) {\n                            if (seen[nr][nc] < generation || best[nr][nc] < cbest) {\n                                if (seen[nr][nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr][nc] = generation;\n                                best[nr][nc] = cbest;\n                                via[nr][nc] = 2;\n                            }\n                        }\n                    }\n                    if (nextPath < plen && r + c == pr[nextPath] + pc[nextPath]) {\n                        --qt;\n                        qr[qt] = pr[nextPath];\n                        qc[qt] = pc[nextPath];\n                        ++nextPath;\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n   }\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[510][510];\nint Up[510][510], Down[510][510];\nint B[510][510], E[510][510], BB[510], EE[510], S[510];\nint T[510][510], v[510];\nint n, w[510][510], L[510], R[510];\nlong long res;\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", p[i] + 1);\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (p[i][j] >= '0' && p[i][j] <= '9')w[i][j] = p[i][j] - '0';\n\t\t\telse w[i][j] = -1;\n\t\t}\n\t}\n\tfor (i = 0; i <= n + 1; i++)for (j = 0; j <= n + 1; j++)if (i == 0 || i > n || j == 0 || j > n)w[i][j] = -1;\n\tfor (i = n; i >= 1; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (w[i][j] == -1)continue;\n\t\t\tDown[i][j] = i;\n\t\t\tDown[i][j] = max(Down[i][j], Down[i][j + 1]);\n\t\t\tDown[i][j] = max(Down[i][j], Down[i + 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tUp[i][j] = n + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tUp[i][j] = i;\n\t\t\tif (w[i][j - 1] != -1)Up[i][j] = min(Up[i][j], Up[i][j - 1]);\n\t\t\tif (w[i - 1][j] != -1)Up[i][j] = min(Up[i][j], Up[i - 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint pv = 0, s = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tpv = j;\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\ts = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT[i][j] = pv + 1;\n\t\t\tres += s*w[i][j];\n\t\t\ts += w[i][j];\n\t\t\tint b = T[i][j], e = j;\n\t\t\tif (i != 1) {\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\tfor (k = b; k <= e; k++) {\n\t\t\t\t\tif (w[i - 1][k] != -1) {\n\t\t\t\t\t\tB[i][j] = min(B[i][j], T[i - 1][k]);\n\t\t\t\t\t\tE[i][j] = max(E[i][j], k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) BB[j] = B[i][j], EE[j] = E[i][j];\n\t\tfor (j = i - 1; j >= 1; j--) {\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tS[k] = S[k - 1];\n\t\t\t\tif (Down[j][k] >= i) {\n\t\t\t\t\tS[k] += w[j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 1) {\n\t\t\t\t\tif (Up[j][k] <= j-1)v[k] = 1;\n\t\t\t\t\telse v[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tif (Up[i][k] <= j) {\n\t\t\t\t\tres += (S[EE[k]] - S[BB[k] - 1])*w[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == 1)break;\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tL[k] = L[k - 1];\n\t\t\t\tif (v[k])L[k] = k;\n\t\t\t}\n\t\t\tR[n + 1] = n + 1;\n\t\t\tfor (k = n; k >= 1; k--) {\n\t\t\t\tR[k] = R[k + 1];\n\t\t\t\tif (v[k])R[k] = k;\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tint b = BB[k], e = EE[k];\n\t\t\t\tif (Up[i][k] >= j) {\n\t\t\t\t\tBB[k] = 1e8, EE[k] = -1e8;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tBB[k] = B[j][R[b]], EE[k] = E[j][L[e]];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nconst int MN = 550;\nint N;\nusing B = bitset<MN>;\nint g[MN][MN];\n\n\nB used[MN][MN];\n\nint L, R, D, U;\nvoid dfs_up(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    if (g[a][b] == 0 || used[a][b][id]) return;\n    used[a][b][id] = true;\n    dfs_up(a-1, b, id); dfs_up(a, b-1, id);\n}\n\nvoid dfs_dw(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    if (g[a][b] == 0 || used[a][b][id]) return;\n    used[a][b][id] = true;\n    dfs_dw(a+1, b, id); dfs_dw(a, b+1, id);\n}\n\nll ans = 0;\n\nvoid solve(int l, int r, int d, int u) {\n    if (r < l || u < d) return;\n    if (l == r && d == u) return;\n    L = l; R = r; D = d; U = u;\n    for (int x = l; x <= r; x++) {\n        for (int y = d; y <= u; y++) {\n            used[x][y] = B();\n        }\n    }\n    if (r-l > u-d) {\n        int m = (l+r)/2;\n        for (int y = d; y <= u; y++) {\n            dfs_up(m, y, y);\n        }\n        for (int y = u; y >= d; y--) {\n            dfs_dw(m+1, y, y);\n        }\n        unordered_map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (x <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if ((p1.first & p2.first).count()) ans += ll(p1.second) * p2.second;\n            }\n        }\n        solve(l, m, d, u);\n        solve(m+1, r, d, u);\n    } else {\n        int m = (d+u)/2;\n\n        for (int x = l; x <= r; x++) {\n            dfs_up(x, m, x);\n        }\n        for (int x = r; x >= l; x--) {\n            dfs_dw(x, m+1, x);\n        }\n        unordered_map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (y <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if ((p1.first & p2.first).count()) ans += ll(p1.second) * p2.second;\n            }\n        }\n        solve(l, r, d, m);\n        solve(l, r, m+1, u);\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(20) << fixed;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        string s;\n        cin >> s;\n        for (int j = 1; j <= N; j++) {\n            int d = 0;\n            if (isdigit(s[j-1])) d = s[j-1] - '0';\n            g[i][j] = d;\n            //ans -= d*d;\n        }\n    }\n    solve(1, N, 1, N);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nconst int MN = 550;\nint N;\nusing B = bitset<MN>;\nint g[MN][MN];\n\n\nB used[MN][MN];\n\nint L, R, D, U;\nvoid dfs_up(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    if (g[a][b] == 0 || used[a][b][id]) return;\n    used[a][b][id] = true;\n    dfs_up(a-1, b, id); dfs_up(a, b-1, id);\n}\n\nvoid dfs_dw(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    if (g[a][b] == 0 || used[a][b][id]) return;\n    used[a][b][id] = true;\n    dfs_dw(a+1, b, id); dfs_dw(a, b+1, id);\n}\n\nint ans = 0;\n\nvoid solve(int l, int r, int d, int u) {\n    if (r < l || u < d) return;\n    if (l == r && d == u) return;\n    L = l; R = r; D = d; U = u;\n    for (int x = l; x <= r; x++) {\n        for (int y = d; y <= u; y++) {\n            used[x][y] = B();\n        }\n    }\n    if (r-l > u-d) {\n        int m = (l+r)/2;\n        for (int y = d; y <= u; y++) {\n            dfs_up(m, y, y);\n        }\n        for (int y = u; y >= d; y--) {\n            dfs_dw(m+1, y, y);\n        }\n        unordered_map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (x <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if ((p1.first & p2.first).count()) ans += p1.second * p2.second;\n            }\n        }\n        solve(l, m, d, u);\n        solve(m+1, r, d, u);\n    } else {\n        int m = (d+u)/2;\n\n        for (int x = l; x <= r; x++) {\n            dfs_up(x, m, x);\n        }\n        for (int x = r; x >= l; x--) {\n            dfs_dw(x, m+1, x);\n        }\n        unordered_map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (y <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if ((p1.first & p2.first).count()) ans += p1.second * p2.second;\n            }\n        }\n        solve(l, r, d, m);\n        solve(l, r, m+1, u);\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(20) << fixed;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        string s;\n        cin >> s;\n        for (int j = 1; j <= N; j++) {\n            int d = 0;\n            if (isdigit(s[j-1])) d = s[j-1] - '0';\n            g[i][j] = d;\n            //ans -= d*d;\n        }\n    }\n    solve(1, N, 1, N);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\nconst int N = 1505, inf = 0x3f3f3f3f;\nint n;short l[N][N],r[N][N];\nint dfn[N][N],pos[N][N];char s[N][N];\nll f[N][N],res;\n#define umax(a,b) (a=a>b?a:b)\n#define umin(a,b) (a=a<b?a:b)\nint main() {\n\tmemset(s,'#',sizeof(s));read(n);rep(i,1,n)scanf(\"%s\",s[i]+1);\n\tmemset(l,inf,sizeof(l));\n\tper(i,n,1){\n\t\trep(j,1,n){\n\t\t\tif(s[i][j]!='#')l[i][j]=r[i][j]=j;else l[i][j]=inf,r[i][j]=0;\n\t\t\tl[i+1][j]=inf,r[i+1][j]=0;\n\t\t}\n\t\tper(j,i,1){\n\t\tshort *R=r[j+1],*L=l[j+1];\n\t\tif(j<i)memcpy(r[j],r[j+1],sizeof(r[j+1])),memcpy(l[j],l[j+1],sizeof(l[j+1]));\n\t\tper(k,n,1)if(s[j][k]=='#')l[j][k]=inf,r[j][k]=0;\n\t\telse{\n\t\t//\tif(j<i){r[j][k]=max(r[j][k+1],R[k]);l[j][k]=min(l[j][k+1],L[k]);}\n\t\t//\telse\n\t\t\t{umax(r[j][k],r[j][k+1]);umin(l[j][k],l[j][k+1]);}\n\t\t\tif(dfn[j][k]==i+1&&R[k]<pos[j][k])f[j][k]-=f[i+1][pos[j][k]];\n\t\t\tif(R[k]>=l[j][k+1])dfn[j][k]=i,pos[j][k]=l[j][k+1];\n\t\t}\n\t\t}\n\t\tper(j,n,1)if(s[i][j]!='#'){\n\t\t//\tprintf(\"%d %d:%lld %lld\\n\",i,j,f[i][j],f[i+1][j]+f[i][j+1]+f[i][j]);\n\t\t\tf[i][j]+=f[i+1][j]+f[i][j+1];ll c=s[i][j]-'0';\n\t\t\tres+=c*f[i][j];f[i][j]+=c;\n\t\t}\n\t}\n\tcout<<res;return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//freopen(\"a.in\",\"r\",stdin);\n//freopen(\"zj.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]>r[k][j+1]) break;\n\t\t\t//\tif(i==2&&j==1) cout<<\"-_-\"<<las_r<<\" \"<<k<<\" \"<<l[k][j+1]<<endl;\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]];\n\t\t\t\t\tlas_r=r[k][j];\n\t\t\t\t\t//if(l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t\t\tl[k][j]=min(l[k][j],l[k][j+1]);\n\t\t\t\t\tr[k][j]=max(r[k][j],r[k][j+1]);\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\telse l[i][j]=n+1,r[i][j]=0;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\t/*\n\tfor1(1,n,i) {\n\t\tfor1(1,n,j) cout<<f[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\t*/\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nconst int maxn = 550;\n\nint n, m, a[maxn][maxn], fl[maxn][maxn][maxn], fr[maxn][maxn][maxn], s[maxn][maxn];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstatic char str[maxn];\n\t\tscanf(\"%s\", str + 1);\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\ta[i][j] = (str[j] == '#' ? 0 : str[j] - '0'), s[i][j] = s[i][j - 1] + a[i][j];\n\t\t\tfor (int k = 1; k <= n; ++k) fl[i][j][k] = n, fr[i][j][k] = 0;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = n; i; --i) for (int j = n; j; --j) if(a[i][j]) {\n\t\tfl[i][j][i] = fr[i][j][i] = j;\n\t\tif(a[i + 1][j]) for (int k = i + 1; k <= n; ++k) fl[i][j][k] = min(fl[i][j][k], fl[i + 1][j][k]), fr[i][j][k] = max(fr[i][j][k], fr[i + 1][j][k]);\n\t\tif(a[i][j + 1]) for (int k = i; k <= n; ++k) fl[i][j][k] = min(fl[i][j][k], fl[i][j + 1][k]), fr[i][j][k] = max(fr[i][j][k], fr[i][j + 1][k]);\n\t\tint sum = 0;\n\t\tfor (int k = i; k <= n; ++k) {\n\t\t\tif(fl[i][j][k] > fr[i][j][k]) break;\n\t\t\tsum += s[k][fr[i][j][k]] - s[k][fl[i][j][k] - 1];\n\t\t}\n\t\tans += (long long) a[i][j] * (sum - a[i][j]);\n\n\t\tfunction<void(int, int)> del = [&](int x, int y) {\n\t\t\tif(!a[x][y - 1] && !a[x - 1][y]) {\n\t\t\t\tfor (int i = y; i <= n; ++i) s[x][i] -= a[x][y];\n\t\t\t\ta[x][y] = 0;\n\t\t\t\tif(a[x][y + 1]) del(x, y + 1);\n\t\t\t\tif(a[x + 1][y]) del(x + 1, y);\n\t\t\t}\n\t\t\treturn;\n\t\t};\n\t\tdel(i, j);\n\t}\n\tprintf(\"%\"LLFORMAT\"d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=1505;\nchar s[N];int a[N][N],f[N][N],rpos[N][N],mn[2][N][N],mx[2][N][N],n,t;\nll res;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfp(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tfp(j,1,n)a[i][j]=s[j]=='#'?0:s[j]-'0';\n\t}\n\tfd(i,n,1){\n\t\tfd(j,n,1)if(a[i][j]){\n\t\t\tf[i][j]=f[i+1][j]+f[i][j+1]+a[i][j];\n\t\t\trpos[i][j]=max({rpos[i+1][j],rpos[i][j+1],i});\n\t\t\tmn[t][j][i]=j;\n\t\t\tfp(k,i+1,rpos[i+1][j])mn[t][j][k]=mn[t^1][j][k];\n\t\t\tfp(k,max(rpos[i+1][j],i)+1,rpos[i][j+1])mn[t][j][k]=mn[t][j+1][k];\n\t\t\tmx[t][j][i]=j;\n\t\t\tfp(k,i,rpos[i][j+1])mx[t][j][k]=mx[t][j+1][k];\n\t\t\tfp(k,max(rpos[i][j+1],i)+1,rpos[i+1][j])mx[t][j][k]=mx[t^1][j][k];\n\t\t\tint d=i+1,r=min(rpos[i+1][j],rpos[i][j+1]);\n\t\t\twhile(d<=r){\n\t\t\t\tif(mx[t^1][j][d]>=mn[t][j+1][d]){\n\t\t\t\t\tf[i][j]-=f[d][mn[t][j+1][d]];\n\t\t\t\t\td=rpos[d][mn[t][j+1][d]];\n\t\t\t\t}\n\t\t\t\t++d;\n\t\t\t}\n\t\t\tres+=1ll*a[i][j]*(f[i][j]-a[i][j]);\n\t\t}\n\t\tt^=1;\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC diagnostic ignored \"-Wunused-result\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int N = 502;\n//const ll INF = (ll)1e18 + 41;\nconst int INF = (int)1e9 + 41;\nconst ll MD = (ll)1e9 + 7;\nbool D = false;\n\nint sum[N][N], a[N][N];\nint max_depth[N][N];\nshort int r[N][N][N];\nshort int l[N][N][N];\n\nvoid solve() {\n    int n, m;\n    cin >> n;\n    m = n;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            a[i][j] = 0;\n            max_depth[i][j] = i;\n            sum[i][j] = 0;\n            short int *r2 = r[i][j];\n            short int *l2 = l[i][j];\n            auto val_l = (short int)N;\n            auto val_r = (short int)-1;\n            for (int h = 0; h <= n; h++) {\n                l2[h] = val_l;\n                r2[h] = val_r;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < m; j++) {\n            if (s[j] == '#') a[i][j] = 0;\n            else a[i][j] = s[j] - '0';\n        }\n    }\n    ll ans = 0;\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = m - 1; j >= 0; j--) {\n            if (a[i][j] == 0) {\n                max_depth[i][j] = -1;\n                continue;\n            }\n\n            short int *left = r[i + 1][j];\n            short int *_left = l[i + 1][j];\n            short int *rait = l[i][j + 1];\n            short int *_rait = r[i][j + 1];\n            short int *meL = l[i][j];\n            short int *meR = r[i][j];\n\n            meL[i] = (short int)j;\n            meR[i] = max(meL[i], _rait[i]);\n            for (int h = i + 1; h < n; h++) {\n                meL[h] = min(_left[h], rait[h]);\n                meR[h] = max(left[h], _rait[h]);\n            }\n            max_depth[i][j] = max(i, max(max_depth[i + 1][j], max_depth[i][j + 1]));\n\n            int cur_sum = sum[i][j + 1] + sum[i + 1][j];\n            int h = i;\n            //cout << i << \" \" << j << endl;\n            if (i == 1 && j == 0) {\n                j = i * j;\n            }\n            while (h < n) {\n                while (h < n && left[h] < rait[h]) h++;\n                if (h >= n) continue;\n\n                cur_sum -= sum[h][rait[h]];\n                h = max_depth[h][rait[h]] + 2;\n            }\n\n            sum[i][j] = cur_sum + a[i][j];\n            ans += a[i][j] * cur_sum;\n        }\n    }\n\n    cout << ans << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int tst = 1;\n    //scanf(\"%d\", &tst);\n    //cin >> tst;\n#ifdef MADE_BY_SERT\n    //freopen(\"a.in\", \"r\", stdin);\n    D = true;\n    tst = 4;\n    while (tst--) {\n        solve();\n    }\n#else\n    while (tst--) solve();\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[510][510];\nint Up[510][510], Down[510][510];\nint B[510][510], E[510][510], BB[510], EE[510], S[510];\nint T[510][510], v[510];\nint n, w[510][510], L[510], R[510];\nlong long res;\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", p[i] + 1);\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (p[i][j] >= '0' && p[i][j] <= '9')w[i][j] = p[i][j] - '0';\n\t\t\telse w[i][j] = -1;\n\t\t}\n\t}\n\tfor (i = 0; i <= n + 1; i++)for (j = 0; j <= n + 1; j++)if (i == 0 || i > n || j == 0 || j > n)w[i][j] = -1;\n\tfor (i = n; i >= 1; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (w[i][j] == -1)continue;\n\t\t\tDown[i][j] = i;\n\t\t\tDown[i][j] = max(Down[i][j], Down[i][j + 1]);\n\t\t\tDown[i][j] = max(Down[i][j], Down[i + 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tUp[i][j] = n + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tUp[i][j] = i;\n\t\t\tif (w[i][j - 1] != -1)Up[i][j] = min(Up[i][j], Up[i][j - 1]);\n\t\t\tif (w[i - 1][j] != -1)Up[i][j] = min(Up[i][j], Up[i - 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint pv = 0, s = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tpv = j;\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\ts = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT[i][j] = pv + 1;\n\t\t\tres += s*w[i][j];\n\t\t\ts += w[i][j];\n\t\t\tint b = T[i][j], e = j;\n\t\t\tif (i != 1) {\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\tfor (k = b; k <= e; k++) {\n\t\t\t\t\tif (w[i - 1][k] != -1) {\n\t\t\t\t\t\tB[i][j] = min(B[i][j], T[i - 1][k]);\n\t\t\t\t\t\tE[i][j] = max(E[i][j], k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) BB[j] = B[i][j], EE[j] = E[i][j];\n\t\tfor (j = i - 1; j >= 1; j--) {\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tS[k] = S[k - 1];\n\t\t\t\tif (Down[j][k] >= i) {\n\t\t\t\t\tS[k] += w[j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 1) {\n\t\t\t\t\tif (Up[j][k] <= j-1 && Down[j][k] >= i)v[k] = 1;\n\t\t\t\t\telse v[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tif (Up[i][k] <= j) {\n\t\t\t\t\tres += (S[EE[k]] - S[BB[k] - 1])*w[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == 1)break;\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tL[k] = L[k - 1];\n\t\t\t\tif (v[k])L[k] = k;\n\t\t\t}\n\t\t\tR[n + 1] = n + 1;\n\t\t\tfor (k = n; k >= 1; k--) {\n\t\t\t\tR[k] = R[k + 1];\n\t\t\t\tif (v[k])R[k] = k;\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tint b = BB[k], e = EE[k];\n\t\t\t\tif (Up[i][k] >= j) {\n\t\t\t\t\tBB[k] = 1e8, EE[k] = -1e8;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tBB[k] = B[j][R[b]], EE[k] = E[j][L[e]];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bitset {\n  vector<unsigned long long> a;\n  Bitset() {}\n  Bitset(const vector<unsigned long long>& a) : a(a) {}\n\n  Bitset f(const Bitset &o) {\n    vector<unsigned long long> vec(max(o.a.size(), a.size()));\n    for (int i = 0; i < vec.size(); i++) {\n      unsigned long long x = 0, y = 0;\n      if (i < a.size()) x = a[i];\n      if (i < o.a.size()) y = o.a[i];\n      vec[i] = (x | y);\n    }\n    return Bitset(vec);\n  }\n\n  int count() {\n    int ret = 0;\n    for (auto x : a) {\n      ret += __builtin_popcountll(x);\n    }\n    return ret;\n  }\n\n  void reset() {\n    for (auto& x : a) {\n      x = 0;\n    }\n  }\n\n  void set(int v) {\n    int p = v / 64;\n    while (a.size() <= p) a.push_back(0);\n    a[p] |= (1ULL << (v % 64));\n  }\n}a[2][501][10];\n\nint main(int argc, char *argv[]) {\n  std::ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  long long ans = 0;\n  for (int i = 0, now = 0; i < n; i++, now ^= 1) {\n    for (int j = 1; j <= n; j++) {\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k].reset();\n      }\n    }\n    string s;\n    cin >> s;\n    for (int j = 1; j <= n; j++) {\n      if (s[j - 1] == '#')\n        continue;\n      int v = s[j - 1] - '0';\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k] = a[now][j - 1][k].f(a[now ^ 1][j][k]);\n        ans += a[now][j][k].count() * k * v;\n      }\n      a[now][j][v].set(i * n + j - 1);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    while(wek.size() < (v/d)+2) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trepn(x,9) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+1);\n\t\t\t\tif(x) repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ncs int N = 505;\nint n; char S[N][N];\nint sm[N][N], dn[N][N]; \nint mn[2][N][N], mx[2][N][N];\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) scanf(\"%s\",S[i]+1);\n \tint now=0, nxt=1; ll Ans=0;\n \tfor(int i=n,x; i; i--){\n\t\tfor(int j=n; j; j--)\n\t \tif(S[i][j]!='#'){ \n\t \t\tx=S[i][j]-'0';\n\t \t\tsm[i][j]=sm[i+1][j]+sm[i][j+1]+x;\n\t \t\tdn[i][j]=max(max(dn[i+1][j],dn[i][j+1]),i);\n\t \t\tmn[nxt][j][i]=j;\n\t \t\tfor(int k=i+1; k<=dn[i+1][j]; k++) mn[nxt][j][k]=mn[now][j][k];\n\t \t\tfor(int k=max(dn[i+1][j],i)+1; k<=dn[i][j+1]; k++) mn[nxt][j][k]=mn[nxt][j+1][k];\n\t \t\tmx[nxt][j][i]=j;\n\t \t\tfor(int k=i; k<=dn[i][j+1]; k++) mx[nxt][j][k]=mx[nxt][j+1][k];\n\t \t\tfor(int k=max(dn[i][j+1],i)+1; k<=dn[i+1][j]; k++) mx[nxt][j][k]=mx[now][j][k];\n\t \t\tint u=i+1, lm=min(dn[i][j+1],dn[i+1][j]);\n\t \t\twhile(u<=lm){\n\t \t\t\tif(mn[nxt][j+1][u]<=mx[now][j][u]){\n\t \t\t\t\tsm[i][j]-=sm[u][mn[nxt][j+1][u]];\n\t \t\t\t\tu=dn[u][mn[nxt][j+1][u]];\n\t \t\t\t} ++u;\n\t \t\t} Ans+=(ll)x*(sm[i][j]-x);\n\t\t} swap(now,nxt);\n\t} cout<<Ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nconst int MN = 550;\nint N;\nusing B = bitset<MN>;\nint g[MN][MN];\n\n\nB used[MN][MN];\n\nvoid dfs_up(int a, int b, int id) {\n    if (g[a][b] == 0 || used[a][b][id]) return;\n    used[a][b][id] = true;\n    dfs_up(a-1, b, id); dfs_up(a, b-1, id);\n}\n\nvoid dfs_dw(int a, int b, int id) {\n    if (g[a][b] == 0 || used[a][b][id]) return;\n    used[a][b][id] = true;\n    dfs_dw(a+1, b, id); dfs_dw(a, b+1, id);\n}\n\nint ans = 0;\n\nvoid solve(int l, int r, int d, int u) {\n    if (r < l || u < d) return;\n    if (l == r && d == u) return;\n    for (int x = l; x <= r; x++) {\n        for (int y = d; y <= u; y++) {\n            used[x][y] = B();\n        }\n    }\n    if (r-l > u-d) {\n        int m = (l+r)/2;\n        for (int y = d; y <= u; y++) {\n            dfs_up(m, y, y);\n        }\n        for (int y = u; y >= d; y--) {\n            dfs_dw(m+1, y, y);\n        }\n        unordered_map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (x <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if ((p1.first & p2.first).count()) ans += p1.second * p2.second;\n            }\n        }\n        solve(l, m, d, u);\n        solve(m+1, r, d, u);\n    } else {\n        int m = (d+u)/2;\n\n        for (int x = l; x <= r; x++) {\n            dfs_up(x, m, x);\n        }\n        for (int x = r; x >= l; x--) {\n            dfs_dw(x, m+1, x);\n        }\n        unordered_map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (y <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if ((p1.first & p2.first).count()) ans += p1.second * p2.second;\n            }\n        }\n        solve(l, r, d, m);\n        solve(l, r, m+1, u);\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(20) << fixed;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        string s;\n        cin >> s;\n        for (int j = 1; j <= N; j++) {\n            int d = 0;\n            if (isdigit(s[j-1])) d = s[j-1] - '0';\n            g[i][j] = d;\n            //ans -= d*d;\n        }\n    }\n    solve(1, N, 1, N);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[N][N],r[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;i++)scanf(\"%s\",A[i]+1);\n\tfor (register int i=0;i<=n;i++)\n\t\tfor (register int j=0;j<=n;j++)u[i][j]=A[i][j]>='0'&&A[i][j]<='9'?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;x++){\n\t\tfor (register int i=x;i;i--){\n\t\t\tfor (register int j=1;j<=n;j++)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (register int j=n+1;j;j--){\n\t\t\t\tif (A[i][j]>='0'&&A[i][j]<='9'){\n\t\t\t\t\tif (i<x){\n\t\t\t\t\t\tl[i][j]=min(l[i][j+1],l[i+1][j]);\n\t\t\t\t\t\tr[i][j]=max(r[i][j+1],r[i+1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse l[i][j]=min(j,l[i][j+1]),r[i][j]=max(j,r[i][j+1]);\n\t\t\t\t}\n\t\t\t\telse l[i][j]=1e9,r[i][j]=-1;\n\t\t\t\tif (l[i][j]<=r[i][j])ans+=(A[i][j]-'0')*(S[r[i][j]]-S[l[i][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_map>\n#include <bitset>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1505;\nconst ull H = 2342311;\nconst ull MOD = 1e9 + 7;\n\nint brred, brstup;\nint p[2][MAX][MAX];\n\nll sum_sq(int r, int s1, int s2, int st) {\n  ll ret=0;\n  FOR(j, s1, s2+1)\n    ret += p[st][r][j] * p[st][r][j];\n  return ret;\n}\n\nll calc_single(int r, int s1, int s2, int st) {\n  ll sum=0, ret=0;\n  FOR(j, s1, s2+1) {\n    if (!p[st][r][j]) {\n      sum = 0;\n      continue;\n    }\n\n    ret += p[st][r][j] * sum;\n    sum += p[st][r][j];\n  }\n\n  return ret;\n}\n\null Bgor[MAX][MAX][MAX/64+1], Bdol[MAX][MAX][MAX/64+1];\nint SZ;\n\nvoid reset(ull B[MAX][MAX][MAX/64+1], int r1, int r2, int s1, int s2) {\n  FOR(i, r1, r2+1) FOR(j, s1, s2+1) REP(k, SZ)\n    B[i][j][k] = 0;\n}\n\nvoid andaj(ull a[], ull b[], ull c[]) {\n  REP(i, SZ) c[i] = a[i] & b[i];\n}\n\nvoid oraj(ull a[], ull b[], ull c[]) {\n  REP(i, SZ) c[i] = a[i] | b[i];\n}\n\nvoid kopiraj(ull a[], ull b[]) {\n  REP(i, SZ) b[i] = a[i];\n}\n\nvoid stavi(ull a[], int ind) {\n  a[ind/64] |= ((ull) 1) << (ind % 64);\n}\n\nbool notempty(ull a[]) {\n  REP(i, SZ) if (a[i]) return true;\n  return false;\n}\n\null get_h(ull a[]) {\n  ull r=0;\n  REP(i, SZ) r = ((r*H)%MOD + (a[i]%MOD))%MOD;\n  return r;\n}\n\nvoid go_down(int r1, int r2, int s1, int s2, int st) {\n  reset(Bgor, r1, r2, s1, s2);\n\n  for (int i=r2; i>=r1; i--) {\n    for (int j=s2; j>=s1; j--) {\n      if (!p[st][i][j]) continue;\n      if (i != r2 && j != s2) oraj(Bgor[i+1][j], Bgor[i][j+1], Bgor[i][j]);\n      else if (i != r2) kopiraj(Bgor[i+1][j], Bgor[i][j]);\n      else if (j != s2) kopiraj(Bgor[i][j+1], Bgor[i][j]);\n\n      if (i == r2) stavi(Bgor[i][j], j-s1);\n    }\n  }\n}\n\nvoid go_up(int r1, int r2, int s1, int s2, int st) {\n  reset(Bdol, r1, r2, s1, s2);\n\n  FOR(i, r1, r2+1) {\n    FOR(j, s1, s2+1) {\n      if (!p[st][i][j]) continue;\n      if (i != r1 && j != s1) oraj(Bdol[i-1][j], Bdol[i][j-1], Bdol[i][j]);\n      else if (i != r1) kopiraj(Bdol[i-1][j], Bdol[i][j]);\n      else if (j != s1) kopiraj(Bdol[i][j-1], Bdol[i][j]);\n\n      if (i == r1) stavi(Bdol[i][j], j-s1);\n    }\n  }\n}\n\null tmp[MAX/64+1];\nll spoji(int r1, int mid, int r2, int s1, int s2, int st) {\n  unordered_map <ull, ll> Sum_dol, Sum_gor;\n  unordered_map <ull, P> Pred_dol, Pred_gor;\n\n  FOR(i, r1, mid+1) {\n    FOR(j, s1, s2+1) {\n      ull h = get_h(Bgor[i][j]);\n      Pred_gor[h] = P(i, j);\n      Sum_gor[h] += p[st][i][j];\n    }\n  }\n\n  FOR(i, mid, r2+1) {\n    FOR(j, s1, s2+1) {\n      ull h = get_h(Bdol[i][j]);\n      Pred_dol[h] = P(i, j);\n      Sum_dol[h] += p[st][i][j];\n    }\n  }\n\n  ll ret=0;\n  for (auto gor = Pred_gor.begin(); gor != Pred_gor.end(); gor++) {\n    for (auto dol = Pred_dol.begin(); dol != Pred_dol.end(); dol++) {\n      andaj(Bgor[gor->Y.X][gor->Y.Y], Bdol[dol->Y.X][dol->Y.Y], tmp);\n      if (notempty(tmp))\n        ret += Sum_gor[gor->X] * Sum_dol[dol->X];\n    }\n  }\n\n  return ret;\n}\n\nll calc(int r1, int r2, int s1, int s2, int st) {\n  if (r1 > r2 || s1 > s2) return 0;\n  if (r2-r1 < s2-s1)\n    return calc(s1, s2, r1, r2, 1^st);\n\n  if (r1 == r2)\n    return calc_single(r1, s1, s2, st);\n\n  int mid = (r1 + r2) / 2;\n  SZ = (s2 - s1 + 64) / 64;\n\n  go_down(r1, mid, s1, s2, st);\n  go_up(mid, r2, s1, s2, st);\n\n  ll ret = spoji(r1, mid, r2, s1, s2, st);\n\n  ret -= sum_sq(mid, s1, s2, st);\n\n  ret += calc(r1, mid-1, s1, s2, st);\n  ret += calc(mid+1, r2, s1, s2, st);\n\n  return ret;\n}\n\nchar s[MAX][MAX];\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n\n  REP(i, n) {\n    scanf(\" %s\", s[i]);\n    REP(j, n)\n      p[0][i][j] = p[1][j][i] = (s[i][j] == '#' ? 0 : (int) (s[i][j] - '0'));\n  }\n\n  printf(\"%lld\\n\", calc(0, n-1, 0, n-1, 0));\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include <bits/stdc++.h>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int LL\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 600;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nLL ans = 0;\nLL sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE];\nLL dfs(int y,int x) {\n\tif (y > N or x > N) return 0;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x]) {\n\t\treturn 0;\n\t}\n\treached[y][x]=true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs2(int y, int x) {\n\tif (y > N or x > N) return 0;\n//\tcout << y << \" \" << x << endl;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x] == 0) return 0;\n\tif (reached[y - 1][x]) return 0;\n\t//cout << y << \" \" << x << endl;\n\treached[y][x] = 0;\n\tLL ret = 0;\n\tret += dfs2(y, x + 1);\n\tret += dfs2(y + 1, x);\n\n\treturn ret + A[y][x];\n}\nLL solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i,1, N) {\n\t\tsum+=dfs(x, i);\n\t\tans +=( sum - A[x][i] )* A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tsum-=dfs2(x+1, i)+A[x][i];\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N;\n\tEFOR(i,1,N){\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1]-'0';\n\t\t}\n\t}\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n//\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,g[505][505],s[505][505],mx[505];\nbool e[505][505];\nLL res;\nint readchar(){\n\tchar c=getchar();\n\twhile(c==' ' || c=='\\n') c=getchar();\n\tif(c=='#') return 0;\n\treturn c-'0';\n}\nnamespace DSU{\n\tint fa[250005],rk[250005];\n\tvoid init(){\n\t\tint i;\n\t\tmemset(rk,0,sizeof(rk));\n\t\tfor(i=0;i<=n*n;++i) fa[i]=i;\n\t}\n\tint ancestor(int x){\n\t\tif(fa[x]!=x) fa[x]=ancestor(fa[x]);\n\t\treturn fa[x];\n\t}\n\tvoid unite(int u,int v){\n\t\tu=ancestor(u);\n\t\tv=ancestor(v);\n\t\tif(rk[u]<rk[v])\n\t\t\tfa[u]=v;\n\t\telse if(rk[u]>rk[v])\n\t\t\tfa[v]=u;\n\t\telse{\n\t\t\tfa[u]=v;\n\t\t\t++rk[v];\n\t\t}\n\t}\n\tbool con(int u,int v){\n\t\treturn ancestor(u)==ancestor(v);\n\t}\n};\nvoid add(int x,int y){\n\te[x][y]=1;\n\tif(e[x-1][y]) DSU::unite(x*n+y,(x-1)*n+y);\n\tif(e[x][y-1]) DSU::unite(x*n+y-1,x*n+y);\n\tif(e[x+1][y]) DSU::unite(x*n+y,(x+1)*n+y);\n\tif(e[x][y+1]) DSU::unite(x*n+y+1,x*n+y);\n\tif(x<n-1 && g[x+1][y] && !e[x+1][y]) add(x+1,y);\n\tif(y<n-1 && g[x][y+1] && !e[x][y+1]) add(x,y+1);\n}\nint getlower(int x,int y){\n\tint cx=x,cy=y,ret=(y?s[x][y-1]:0);\n\tmx[y]=x;\n\twhile(1){\n\t\twhile(1){\n\t\t\tif(cx+1<n && e[cx+1][cy]){\n\t\t\t\t++cx;\n\t\t\t\tmx[y]=cx;\n\t\t\t\tret+=(cy?s[cx][cy-1]:0);\n\t\t\t}\n\t\t\telse if(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cy+1<n){\n\t\t\t++cy;\n\t\t\tif(e[cx][cy] && DSU::con(cx*n+cy,x*n+y)){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(e[cx][cy]) break;\n\t\t}\n\t\tif(!found) break;\n\t}\n\treturn ret;\n}\nint getupper(int x,int y){\n\tint cx=x,cy=y,ret=0;\n\twhile(1){\n\t\twhile(1){\n\t\t\tif(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse if(cx+1<n && e[cx+1][cy]){\n\t\t\t\tret+=s[cx][cy];\n\t\t\t\t++cx;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cx<n-1){\n\t\t\tret+=s[cx][cy];\n\t\t\t++cx;\n\t\t\tif(cx>mx[y]) break;\n\t\t\tif(e[cx][cy] && DSU::con(cx*n+cy,x*n+y)){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(e[cx][cy]) break;\n\t\t}\n\t\tif(!found || cx>mx[y]) break;\n\t}\n\tif(cx<=mx[y]) ret+=s[cx][cy];\n\treturn ret;\n}\nvoid solveline(int x){\n\tint i,j,k;\n\tmemcpy(s,g,sizeof(g));\n\tfor(i=0;i<n;++i){\n\t\tfor(j=1;j<n;++j){\n\t\t\ts[i][j]+=s[i][j-1];\n\t\t}\n\t}\n\tDSU::init();\n\tfor(i=x;i<n;++i) memset(e[i],0,sizeof(e[i]));\n\tfor(i=0;i<n;++i){\n\t\tif(!g[x][i]) continue;\n\t\tadd(x,i);\n\t\tres-=(LL)g[x][i]*(LL)getlower(x,i);\n\t}\n\tDSU::init();\n\tfor(i=x;i<n;++i) memset(e[i],0,sizeof(e[i]));\n\tfor(i=n-1;i>=0;--i){\n\t\tif(!g[x][i]) continue;\n\t\tadd(x,i);\n\t\tres+=(LL)g[x][i]*(LL)(getupper(x,i)-g[x][i]);\n\t}\n}\nvoid del(int x,int y){\n\tif((!x || !g[x-1][y]) && (!y || !g[x][y-1])){\n\t\tg[x][y]=0;\n\t\tif(x<n-1 && g[x+1][y]) del(x+1,y);\n\t\tif(y<n-1 && g[x][y+1]) del(x,y+1);\n\t}\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\tg[i][j]=readchar();\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\te[i][j]=(!!g[i][j]);\n\t\t}\n\t}\n    for(i=n-1;i>=0;--i){\n\t\tsolveline(i);\n\t\tfor(j=0;j<n;++j){\n\t\t\tif(g[i][j]) del(i,j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <string>\n#define pb push_back\ntemplate <typename T1, typename T2> inline void umin(T1 &x, const T2 &y) { y < x ? (x = y) : 0; }\ntemplate <typename T1, typename T2> inline void umax(T1 &x, const T2 &y) { y > x ? (x = y) : 0; }\nint lp[2005][2005], rp[2005][2005], ul[2005], ur[2005], tmp[2005][2005];\nint sum_can[2005], sum_l[2005][2005], sum_r[2005][2005], sum_in[2005][2005];\nint bottom[2005], top[2005], que[2005], can_go[2005], unique[2005], bel_mn[2005][2005];\nstd::vector<int> vec[2005];\nbool del[2005];\nlong long ans;\ninline int calc_meet(int l, int r)\n{\n\tint pos = bel_mn[l][r];\n\tif (pos <= bottom[l] && pos <= bottom[r])\n\t\treturn pos;\n\treturn 1e9;\n}\ninline int calc_cnt(int l, int r, int lim = 1e9)\n{\n\tlim = std::min({lim, bottom[l], bottom[r]});\n\tif (calc_meet(l, r) > lim)\n\t\treturn 0;\n\treturn sum_can[lim] - sum_l[lim][l] - sum_r[lim][r] + sum_in[l][r];\n}\ntemplate <typename mapT>\nvoid work(const mapT &inp)\n{\n\tmapT str = inp;\n\tint n = str.size(), m = str[0].size();\n\tif (n < m)\n\t{\n\t\tmapT str_new(m, std::string(n, '#'));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tstr_new[j][i] = str[i][j];\n\t\t}\n\t\tstr = str_new;\n\t\tstd::swap(n, m);\n\t}\n\tif (m == 1)\n\t{\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (str[i][0] == '#')\n\t\t\t\tcur = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += (str[i][0] - '0') * cur;\n\t\t\t\tcur += str[i][0] - '0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint hu = n >> 1, hd = n - hu;\n\tmapT up(str.begin(), str.begin() + hu), down(str.begin() + hu, str.end());\n\twork(up);\n\twork(down);\n\tup.pb(down[0]);\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tlp[i][j] = 1e9;\n\t\t\trp[i][j] = -1e9;\n\t\t}\n\t}\n\t// lp & rp\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (down[0][i] != '#')\n\t\t\tlp[0][i] = rp[0][i] = i;\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (down[i][j] == '#')\n\t\t\t\tcontinue;\n\t\t\tif (i)\n\t\t\t{\n\t\t\t\tumin(lp[i][j], lp[i - 1][j]);\n\t\t\t\tumax(rp[i][j], rp[i - 1][j]);\n\t\t\t}\n\t\t\tif (j)\n\t\t\t{\n\t\t\t\tumin(lp[i][j], lp[i][j - 1]);\n\t\t\t\tumax(rp[i][j], rp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t// top\n\tfor (int i = 0; i <= hu; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (up[i][j] == '#')\n\t\t\t{\n\t\t\t\ttmp[i][j] = 1e9;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp[i][j] = i;\n\t\t\tif (i)\n\t\t\t\tumin(tmp[i][j], tmp[i - 1][j]);\n\t\t\tif (j)\n\t\t\t\tumin(tmp[i][j], tmp[i][j - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\ttop[i] = tmp[hu][i];\n\t// bottom\n\tfor (int i = hd - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (down[i][j] == '#')\n\t\t\t{\n\t\t\t\ttmp[i][j] = -1e9;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp[i][j] = i;\n\t\t\tif (i + 1 < hd)\n\t\t\t\tumax(tmp[i][j], tmp[i + 1][j]);\n\t\t\tif (j + 1 < m)\n\t\t\t\tumax(tmp[i][j], tmp[i][j + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tbottom[i] = tmp[0][i];\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tbel_mn[i][j] = 1e9;\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (lp[i][j] <= rp[i][j])\n\t\t\t\tumin(bel_mn[lp[i][j]][rp[i][j]], i);\n\t\t}\n\t}\n\tfor (int l = 0; l < m; l++)\n\t{\n\t\tfor (int r = m - 1; r >= l; r--)\n\t\t{\n\t\t\tif (l)\n\t\t\t\tumin(bel_mn[l][r], bel_mn[l - 1][r]);\n\t\t\tif (r + 1 < m)\n\t\t\t\tumin(bel_mn[l][r], bel_mn[l][r + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tsum_can[i] = 0;\n\t\tmemset(sum_l[i], 0, m << 2);\n\t\tmemset(sum_r[i], 0, m << 2);\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tmemset(sum_in[i], 0, m << 2);\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tif (i)\n\t\t{\n\t\t\tsum_can[i] = sum_can[i - 1];\n\t\t\tmemcpy(sum_l[i], sum_l[i - 1], m << 2);\n\t\t\tmemcpy(sum_r[i], sum_r[i - 1], m << 2);\n\t\t}\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (lp[i][j] > rp[i][j])\n\t\t\t\tcontinue;\n\t\t\tint val = down[i][j] - '0';\n\t\t\tsum_can[i] += val;\n\t\t\tif (lp[i][j])\n\t\t\t\tsum_l[i][lp[i][j] - 1] += val;\n\t\t\tif (rp[i][j] + 1 < m)\n\t\t\t\tsum_r[i][rp[i][j] + 1] += val;\n\t\t\tif (lp[i][j] && rp[i][j] + 1 < m)\n\t\t\t\tsum_in[lp[i][j] - 1][rp[i][j] + 1] += val;\n\t\t}\n\t}\n\tfor (int i = 0; i < hd; i++)\n\t{\n\t\tfor (int j = m - 2; j >= 0; j--)\n\t\t\tsum_l[i][j] += sum_l[i][j + 1];\n\t\tfor (int j = 1; j < m; j++)\n\t\t\tsum_r[i][j] += sum_r[i][j - 1];\n\t}\n\tfor (int l = m - 1; l >= 0; l--)\n\t{\n\t\tfor (int r = l; r < m; r++)\n\t\t{\n\t\t\tif (l + 1 < m)\n\t\t\t\tsum_in[l][r] += sum_in[l + 1][r];\n\t\t\tif (r)\n\t\t\t\tsum_in[l][r] += sum_in[l][r - 1];\n\t\t\tif (l + 1 < m && r)\n\t\t\t\tsum_in[l][r] -= sum_in[l + 1][r - 1];\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tcan_go[i] = calc_cnt(i, i);\n\tfor (int i = 0; i < hu; i++)\n\t\tvec[i].clear();\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tdel[i] = top[i] >= hu;\n\t\tif (!del[i])\n\t\t\tvec[top[i]].pb(i);\n\t}\n\tfor (int i = m - 1; i >= 0; i--)\n\t{\n\t\tif (up[hu][i] == '#')\n\t\t{\n\t\t\tul[i] = 1e9;\n\t\t\tur[i] = -1e9;\n\t\t\tcontinue;\n\t\t}\n\t\tul[i] = ur[i] = i;\n\t\tif (i + 1 < m)\n\t\t\tumax(ur[i], ur[i + 1]);\n\t}\n\tfor (int i = hu - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (up[i][j] == '#')\n\t\t\t{\n\t\t\t\tul[j] = 1e9;\n\t\t\t\tur[j] = -1e9;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (j + 1 < m)\n\t\t\t{\n\t\t\t\tumin(ul[j], ul[j + 1]);\n\t\t\t\tumax(ur[j], ur[j + 1]);\n\t\t\t}\n\t\t}\n\t\tint cur = 0, cl = 0, cr = -1, he = 0, ta = 0;\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (ul[j] > ur[j])\n\t\t\t\tcontinue;\n\t\t\twhile (cr < ur[j])\n\t\t\t{\n\t\t\t\tint x = ++cr;\n\t\t\t\tif (del[x])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (he < ta)\n\t\t\t\t{\n\t\t\t\t\tcur -= unique[que[ta - 1]];\n\t\t\t\t\tunique[que[ta - 1]] -= calc_cnt(que[ta - 1], x);\n\t\t\t\t\tcur += unique[que[ta - 1]];\n\t\t\t\t\tif (bottom[que[ta - 1]] <= bottom[x])\n\t\t\t\t\t{\n\t\t\t\t\t\tta--;\n\t\t\t\t\t\twhile (he < ta)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcur -= unique[que[ta - 1]];\n\t\t\t\t\t\t\tunique[que[ta - 1]] -= calc_cnt(que[ta - 1], x);\n\t\t\t\t\t\t\tunique[que[ta - 1]] += calc_cnt(que[ta - 1], x, bottom[que[ta]]);\n\t\t\t\t\t\t\tcur += unique[que[ta - 1]];\n\t\t\t\t\t\t\tif (bottom[que[ta - 1]] <= bottom[x])\n\t\t\t\t\t\t\t\tta--;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tque[ta++] = x;\n\t\t\t\tunique[x] = can_go[x];\n\t\t\t\tcur += unique[x];\n\t\t\t}\n\t\t\twhile (cl < ul[j])\n\t\t\t{\n\t\t\t\tint x = cl++;\n\t\t\t\tif (del[x])\n\t\t\t\t\tcontinue;\n\t\t\t\tcur -= unique[x];\n\t\t\t\tif (he < ta && que[he] == x)\n\t\t\t\t\the++;\n\t\t\t}\n\t\t\tans += (up[i][j] - '0') * cur;\n\t\t}\n\t\tfor (int x : vec[i])\n\t\t\tdel[x] = true;\n\t}\n}\nchar str[2005];\nint main()\n{\n\t// freopen(\"AGC028-F.in\", \"r\", stdin);\n\tint n;\n\tscanf(\"%d\", &n);\n\tstd::vector<std::string> inp;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%s\", str);\n\t\tinp.pb(std::string(str));\n\t}\n\twork(inp);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\nconst int Q=1505;\nchar a[Q][Q];\nint f[Q][Q],l[Q][Q],r[Q][Q];\nint n;\nint Ok(int x,int y)\n{return (x<=n)&(y<=n)&(a[x][y]!='#');}\nint main()\n{\n    ll als=0;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%s\",a[i]+1);\n    for(int i=n;i;--i)\n        for(int j=n;j;--j){\n            if(!Ok(i,j)){\n                l[i][j]=n+1,r[i][j]=-1;\n                continue;\n            }\n            int D=Ok(i+1,j),R=Ok(i,j+1);\n            int val=a[i][j]-'0';\n            if(!(D|R)){\n                f[i][j]=val;\n                l[i][j]=r[i][j]=j;\n                for(int k=i+1;k<=n&&r[k][j]>=0;k++)\n                    l[k][j]=n+1,r[k][j]=-1;\n            }\n            else if(D&R){\n                f[i][j]=f[i+1][j]+f[i][j+1]+val;\n                for(int k=i+1,mxr=0;k<=n;k++){\n                    int &lv=l[k][j+1],&rv=r[k][j+1];\n                    if(lv>mxr&&lv<=r[k][j])f[i][j]-=f[k][lv];\n                    mxr=max(mxr,r[k][j]);\n                    l[k][j]=min(l[k][j],lv);\n                    r[k][j]=max(r[k][j],rv);\n                }\n                l[i][j]=j;\n                r[i][j]=r[i][j+1];\n            }\n            else if(D){\n                f[i][j]=f[i+1][j]+val;\n                l[i][j]=r[i][j]=j;\n            }\n            else{\n                f[i][j]=f[i][j+1]+val;\n                \n                for(int k=i;k<=n;k++)\n                    l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];l[i][j]=j;\n            }\n            als+=1LL*val*(f[i][j]-val);\n        }\n    printf(\"%lld\\n\",als);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 13.10.2018 16:23:29       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505;\n\nshort L[N][N][N];\nshort R[N][N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<string> board(n);\n  for (int i = 0; i < n; i++) {\n    cin >> board[i];\n  }\n  vector<vector<int>> a(n, vector<int>(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      a[i][j] = (board[i][j] == '#' ? 0 : (int) (board[i][j] - '0'));\n    }\n  }\n  vector<vector<int>> row(n, vector<int>(n + 1));\n  for (int i = 0; i < n; i++) {\n    row[i][0] = 0;\n    for (int j = 0; j < n; j++) {\n      row[i][j + 1] = row[i][j] + a[i][j];\n    }\n  }\n  long long ans = 0;\n  function<void(int,int)> put = [&](int i, int j) {\n    if (0 <= i && i < n && 0 <= j && j < n && a[i][j] > 0) {\n      if (i == 0 || a[i - 1][j] == 0) {\n        if (j == 0 || a[i][j - 1] == 0) {\n          for (int k = j; k < n; k++) {\n            row[i][k + 1] -= a[i][j];\n          }\n          a[i][j] = 0;\n          put(i + 1, j);\n          put(i, j + 1);\n        }\n      }\n    }\n  };\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = n - 1; j >= 0; j--) {\n      if (a[i][j] == 0) {\n        continue;\n      }\n      for (int k = i; k < n; k++) {\n        L[i][j][k] = n;\n        R[i][j][k] = 0;\n      }\n      L[i][j][i] = j;\n      R[i][j][i] = j;\n      if (i < n - 1 && a[i + 1][j] != 0) {\n        for (int k = i + 1; k < n; k++) {\n          L[i][j][k] = min(L[i][j][k], L[i + 1][j][k]);\n          R[i][j][k] = max(R[i][j][k], R[i + 1][j][k]);\n        }\n      }\n      if (j < n - 1 && a[i][j + 1] != 0) {\n        for (int k = i; k < n; k++) {\n          L[i][j][k] = min(L[i][j][k], L[i][j + 1][k]);\n          R[i][j][k] = max(R[i][j][k], R[i][j + 1][k]);\n        }\n      }\n      int sum = 0;\n      for (int k = i; k < n; k++) {\n        if (L[i][j][k] <= R[i][j][k]) {\n          sum += row[k][R[i][j][k] + 1] - row[k][L[i][j][k]];\n        }\n      }\n      ans += a[i][j] * (sum - a[i][j]);\n      put(i, j);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <cassert>\n#define SIZE 1505\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstruct BIT\n{\n\tint bit[SIZE];\n\tint sz;\n\t\n\tvoid init(int S)\n\t{\n\t\tsz=S;\n\t\tfor(int i=0;i<sz;i++) bit[i]=0;\n\t}\n\tvoid add(int k,int x)\n\t{\n\t\tk++;\n\t\twhile(k<sz)\n\t\t{\n\t\t\tbit[k]+=x;\n\t\t\tk+=k&-k;\n\t\t}\n\t}\n\tint get(int k)\n\t{\n\t\tk++;\n\t\tint ret=0;\n\t\twhile(k>0)\n\t\t{\n\t\t\tret+=bit[k];\n\t\t\tk-=k&-k;\n\t\t}\n\t\treturn ret;\n\t}\n\tint get(int s,int t)\n\t{\n\t\treturn get(t)-get(s-1);\n\t}\n};\nBIT bit[SIZE];\nchar str[SIZE];\nbool use[SIZE][SIZE];\nint rt[SIZE][SIZE];\nint l1[SIZE][SIZE],r1[SIZE][SIZE];\nint l2[SIZE][SIZE],r2[SIZE][SIZE];\nint nxt[SIZE][SIZE],back[SIZE][SIZE];\nint ds[SIZE][SIZE],dt[SIZE][SIZE];\nint last[SIZE];\nint sd[SIZE];\nbool active[SIZE];\nll ans;\n\nint get(int y,int s,int t)\n{\n\treturn rt[y][t]-(s==0?0:rt[y][s-1]);\n}\nvoid solve(vector <string> mp)\n{\n\tif(mp.size()==1)\n\t{\n\t\tint sum=0;\n\t\tfor(int i=0;i<mp[0].size();i++)\n\t\t{\n\t\t\tif(mp[0][i]=='#') sum=0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tans+=sum*(mp[0][i]-'0');\n\t\t\t\tsum+=(mp[0][i]-'0');\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif(mp.size()<mp[0].size())\n\t{\n\t\tvector <string> nw;\n\t\tfor(int i=0;i<mp[0].size();i++)\n\t\t{\n\t\t\tstring S=\"\";\n\t\t\tfor(int j=0;j<mp.size();j++) S+=mp[j][i];\n\t\t\tnw.push_back(S);\n\t\t}\n\t\t//printf(\"%d\\n\",nw.size());\n\t\t//for(int i=0;i<nw.size();i++) printf(\"%s\\n\",nw[i].c_str());\n\t\t//return;\n\t\tsolve(nw);\n\t\treturn;\n\t}\n\tint h=mp.size(),w=mp[0].size();\n\t/*\n\tputs(\"\");\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++) printf(\"%c\",mp[i][j]);\n\t\tputs(\"\");\n\t}*/\n\tll AA=ans;\n\tint m1=h/2-1,m2=m1+1;\n\tfor(int i=m1;i>=0;i--)\n\t{\n\t\tfor(int j=w-1;j>=0;j--)\n\t\t{\n\t\t\tif(mp[i][j]=='#') use[i][j]=false;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==m1) use[i][j]=true;\n\t\t\t\telse if(j+1<w&&use[i][j+1]) use[i][j]=true;\n\t\t\t\telse if(use[i+1][j]) use[i][j]=true;\n\t\t\t\telse use[i][j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=m2;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(mp[i][j]=='#') use[i][j]=false;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==m2) use[i][j]=true;\n\t\t\t\telse if(j-1>=0&&use[i][j-1]) use[i][j]=true;\n\t\t\t\telse if(use[i-1][j]) use[i][j]=true;\n\t\t\t\telse use[i][j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\trt[i][j]=use[i][j]?mp[i][j]-'0':0;\n\t\t\tif(j>0) rt[i][j]+=rt[i][j-1];\n\t\t}\n\t}\n\tfor(int i=m1;i>=0;i--)\n\t{\n\t\tif(i==m1)\n\t\t{\n\t\t\tint now=-1;\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(mp[i][j]=='#')\n\t\t\t\t{\n\t\t\t\t\tl1[j][i]=r1[j][i]=-1;\n\t\t\t\t\tnow=-1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(now==-1) now=j;\n\t\t\t\t\tl1[j][i]=now;\n\t\t\t\t\tr1[j][i]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint to=w;\n\t\t\tint now=w-1;\n\t\t\tfor(int j=w-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(l1[j][i+1]==-1) l1[j][i]=r1[j][i]=-1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnow=min(now,r1[j][i+1]);\n\t\t\t\t\tfor(;now>=l1[j][i+1];now--)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!use[i+1][now]||!use[i][now]) continue;\n\t\t\t\t\t\telse if(to>now)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tto=now;\n\t\t\t\t\t\t\twhile(to>0&&mp[i][to-1]!='#') to--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(to>r1[j][i+1]) l1[j][i]=r1[j][i]=-1;\n\t\t\t\t\telse l1[j][i]=to;\n\t\t\t\t}\n\t\t\t}\n\t\t\tto=-1;\n\t\t\tnow=0;\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(l1[j][i+1]==-1) l1[j][i]=r1[j][i]=-1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnow=max(now,l1[j][i+1]);\n\t\t\t\t\tfor(;now<=r1[j][i+1];now++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!use[i+1][now]||!use[i][now]) continue;\n\t\t\t\t\t\telse to=now;\n\t\t\t\t\t}\n\t\t\t\t\tif(to<l1[j][i+1]) l1[j][i]=r1[j][i]=-1;\n\t\t\t\t\telse r1[j][i]=to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=m2;i<h;i++)\n\t{\n\t\tif(i==m2)\n\t\t{\n\t\t\tint now=-1;\n\t\t\tfor(int j=w-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(mp[i][j]=='#')\n\t\t\t\t{\n\t\t\t\t\tl2[j][i]=r2[j][i]=-1;\n\t\t\t\t\tnow=-1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(now==-1) now=j;\n\t\t\t\t\tl2[j][i]=j;\n\t\t\t\t\tr2[j][i]=now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint to=w;\n\t\t\tint now=w-1;\n\t\t\tfor(int j=w-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(l2[j][i-1]==-1) l2[j][i]=r2[j][i]=-1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnow=min(now,r2[j][i-1]);\n\t\t\t\t\tfor(;now>=l2[j][i-1];now--)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!use[i-1][now]||!use[i][now]) continue;\n\t\t\t\t\t\telse to=now;\n\t\t\t\t\t}\n\t\t\t\t\tif(to>r2[j][i-1]) l2[j][i]=r2[j][i]=-1;\n\t\t\t\t\telse l2[j][i]=to;\n\t\t\t\t}\n\t\t\t}\n\t\t\tto=-1;\n\t\t\tnow=0;\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(l2[j][i-1]==-1) l2[j][i]=r2[j][i]=-1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnow=max(now,l2[j][i-1]);\n\t\t\t\t\tfor(;now<=r2[j][i-1];now++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!use[i-1][now]||!use[i][now]) continue;\n\t\t\t\t\t\telse if(to<now)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tto=now;\n\t\t\t\t\t\t\twhile(to+1<w&&mp[i][to+1]!='#') to++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(to<l2[j][i-1]) l2[j][i]=r2[j][i]=-1;\n\t\t\t\t\telse r2[j][i]=to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}/*\n\tfor(int i=0;i<w;i++)\n\t{\n\t\tfor(int j=0;j<=m1;j++) printf(\"[%d %d] \",l1[i][j],r1[i][j]);puts(\"\");\n\t\tfor(int j=m2;j<h;j++) printf(\"[%d %d] \",l2[i][j],r2[i][j]);puts(\"\");\n\t}*/\n\tfor(int i=m2;i<h;i++) last[i]=-1;\n\tfor(int i=0;i<w;i++)\n\t{\n\t\tfor(int j=m2;j<h;j++)\n\t\t{\n\t\t\tif(l2[i][j]==-1) break;\n\t\t\tback[i][j]=last[j];\n\t\t\tnxt[i][j]=-1;\n\t\t\tif(last[j]!=-1) nxt[last[j]][j]=i;\n\t\t\tlast[j]=i;\n\t\t}\n\t}\n\tfor(int i=0;i<w;i++) bit[i].init(w+2);\n\tfor(int i=0;i<w;i++)\n\t{\n\t\tfor(int j=m2;j<h;j++)\n\t\t{\n\t\t\tif(l2[i][j]==-1) break;\n\t\t\tif(nxt[i][j]!=-1)\n\t\t\t{\n\t\t\t\tint to=nxt[i][j];\n\t\t\t\tif(l2[to][j]<=r2[i][j])\n\t\t\t\t{\n\t\t\t\t\tbit[i].add(to,get(j,l2[to][j],r2[i][j]));\n\t\t\t\t\tbit[to].add(i,get(j,l2[to][j],r2[i][j]));\n\t\t\t\t}\n\t\t\t\t//assert(l2[i][j]<=l2[to][j]);\n\t\t\t\t//assert(r2[i][j]<=r2[to][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=m1;i>=0;i--)\n\t{\n\t\tfor(int j=w-1;j>=0;j--)\n\t\t{\n\t\t\tif(!use[i][j]) ds[i][j]=dt[i][j]=-1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tds[i][j]=w,dt[i][j]=-1;\n\t\t\t\tif(i==m1) ds[i][j]=dt[i][j]=j;\n\t\t\t\tif(j+1<w&&use[i][j+1])\n\t\t\t\t{\n\t\t\t\t\tds[i][j]=min(ds[i][j],ds[i][j+1]);\n\t\t\t\t\tdt[i][j]=max(dt[i][j],dt[i][j+1]);\n\t\t\t\t}\n\t\t\t\tif(i+1<=m1&&use[i+1][j])\n\t\t\t\t{\n\t\t\t\t\tds[i][j]=min(ds[i][j],ds[i+1][j]);\n\t\t\t\t\tdt[i][j]=max(dt[i][j],dt[i+1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector <P> die;\n\tfor(int i=0;i<w;i++)\n\t{\n\t\tfor(int j=m1;j>=0;j--)\n\t\t{\n\t\t\tif(l1[i][j]==-1)\n\t\t\t{\n\t\t\t\tdie.push_back(P(j,i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsd[i]=0;\n\t\tfor(int j=m2;j<h;j++)\n\t\t{\n\t\t\tif(l2[i][j]==-1) break;\n\t\t\tsd[i]+=get(j,l2[i][j],r2[i][j]);\n\t\t}\n\t\tactive[i]=true;\n\t\t//printf(\"* %d\\n\",sd[i]);\n\t}\n\tsort(die.begin(),die.end(),greater <P>());\n\tint pos=0;\n\tfor(int i=m1;i>=0;i--)\n\t{\n\t\twhile(pos<die.size()&&die[pos].first==i)\n\t\t{\n\t\t\tint v=die[pos++].second;\n\t\t\tactive[v]=false;\n\t\t\tfor(int j=m2;j<h;j++)\n\t\t\t{\n\t\t\t\tif(l2[v][j]==-1) break;\n\t\t\t\tint f=back[v][j],s=nxt[v][j];\n\t\t\t\tif(f!=-1)\n\t\t\t\t{\n\t\t\t\t\tnxt[f][j]=-1;\n\t\t\t\t\tif(l2[v][j]<=r2[f][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tbit[f].add(v,-get(j,l2[v][j],r2[f][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s!=-1)\n\t\t\t\t{\n\t\t\t\t\tback[s][j]=-1;\n\t\t\t\t\tif(l2[s][j]<=r2[v][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tbit[s].add(v,-get(j,l2[s][j],r2[v][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f!=-1&&s!=-1)\n\t\t\t\t{\n\t\t\t\t\tnxt[f][j]=s;\n\t\t\t\t\tback[s][j]=f;\n\t\t\t\t\tif(l2[s][j]<=r2[f][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tbit[f].add(s,get(j,l2[s][j],r2[f][j]));\n\t\t\t\t\t\tbit[s].add(f,get(j,l2[s][j],r2[f][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l=0,r=0;\n\t\tint sum=0;\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(!use[i][j]) continue;\n\t\t\twhile(r<=dt[i][j])\n\t\t\t{\n\t\t\t\tif(active[r])\n\t\t\t\t{\n\t\t\t\t\tsum+=sd[r];\n\t\t\t\t\tsum-=bit[r].get(l,r);\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t\twhile(l<ds[i][j])\n\t\t\t{\n\t\t\t\tif(active[l])\n\t\t\t\t{\n\t\t\t\t\tsum-=sd[l];\n\t\t\t\t\tsum+=bit[l].get(l,r);\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tans+=(mp[i][j]-'0')*sum;\n\t\t\t//printf(\"%d %d : [%d %d] %d\\n\",i,j,ds[i][j],dt[i][j],sum);\n\t\t}\n\t}\n\t//printf(\"%lld\\n\",ans-AA);\n\tvector <string> S,T;\n\tfor(int i=0;i<=m1;i++) S.push_back(mp[i]);\n\tfor(int i=m2;i<h;i++) T.push_back(mp[i]);\n\tsolve(S);\n\tsolve(T);\n}\nbool NOW[SIZE][SIZE];\nvoid naive(vector <string> mp)\n{\n\tint n=mp.size(),m=mp[0].size();\n\tll ret=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(mp[i][j]=='#') continue;\n\t\t\tfor(int x=i;x<n;x++)\n\t\t\t{\n\t\t\t\tfor(int y=j;y<m;y++)\n\t\t\t\t{\n\t\t\t\t\tif(mp[x][y]=='#') NOW[x][y]=false;\n\t\t\t\t\telse if(x==i&&y==j) NOW[x][y]=true;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(x>i&&NOW[x-1][y]) NOW[x][y]=true;\n\t\t\t\t\t\telse if(y>j&&NOW[x][y-1]) NOW[x][y]=true;\n\t\t\t\t\t\telse NOW[x][y]=false;\n\t\t\t\t\t}\n\t\t\t\t\tif((x!=i||y!=j)&&NOW[x][y]) ret+=(mp[i][j]-'0')*(mp[x][y]-'0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector <string> mp;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%s\",&str);\n\t\tstring S=str;\n\t\tmp.push_back(S);\n\t}\n\tans=0;\n\tsolve(mp);\n\tprintf(\"%lld\\n\",ans);\n\t//naive(mp);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[N][N],r[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%s\",A[i]+1);\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=0;j<=n;j++)u[i][j]=A[i][j]>='0'&&A[i][j]<='9'?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (int x=1;x<=n;x++){\n\t\tfor (int i=x;i;i--){\n\t\t\tfor (int j=1;j<=n;j++)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (int j=n+1;j;j--){\n\t\t\t\tl[i][j]=1<<30;r[i][j]=-1;\n\t\t\t\tif (A[i][j]>='0'&&A[i][j]<='9'){\n\t\t\t\t\tif (i<x){\n\t\t\t\t\t\tl[i][j]=min(l[i][j],l[i+1][j]);\n\t\t\t\t\t\tr[i][j]=max(r[i][j],r[i+1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse l[i][j]=r[i][j]=j;\n\t\t\t\t\tl[i][j]=min(l[i][j],l[i][j+1]);\n\t\t\t\t\tr[i][j]=max(r[i][j],r[i][j+1]);\n\t\t\t\t}\n\t\t\t\tif (l[i][j]<=r[i][j])ans+=(A[i][j]-'0')*(S[r[i][j]]-S[l[i][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) if(a[i][j]) {\n\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\tif(!(t[0]|t[1])) {\n\t\t\tl[i][j]=r[i][j]=j;\n\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t}\n\t\telse if(t[0]&&!t[1]) {\n\t\t\tl[i][j]=r[i][j]=j;\n\t\t\tf[i][j]=f[i+1][j];\n\t\t}\n\t\telse if(!t[0]&&t[1]) {\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t}\n\t\telse {\n\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\n\t\t\tint las_r=0;\t\t\n\t\t\tfor1(i+1,n,k) {\n\t\t\t\tif(r[k][j]>=l[k][j+1]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]];\n\t\t\t\tif(!(l[k][j]+r[k][j])||l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t\tlas_r=r[k][j];\n\t\t\t}\n\t\t\tf[i][j]=tot;\n\t\t}\n\t\t//cout<<i<<\" \"<<j<<\" \"<<f[i][j]<<endl;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<int>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define mem(a) memset((a),0,sizeof(a))\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nconst int N=1504,inf=1e9;\nint wx[N>>1][N],wu[N>>1][N],WX[N],WU[N],lef[N>>1][N],rig[N>>1][N],mn[N][N],mx[N>>1][N],q[N];\nint s1[N>>1],sum,s2[N>>1][N],s3[N>>1][N],s4[N][N],F[N>>1][N],G[N>>1][N],s[N][N],mtp[N][N],only[N];\nchar a[N][N];\nll ans;\nint brh(int a,int b,int l){\n\tif(mtp[a][b]>l)return 0;\n\tl=min(l,min(WX[a],WX[b])); if(l<0)return 0; //cout<<a<<\" \"<<b<<\" fjzzq \" <<l<<endl;\n\tassert(l);\n\treturn s1[l]-s2[l][a+1]-s3[l][b-1]+s4[a+1][b-1];\n}\nvoid add(int a,int b){\n\tonly[a]+=b; sum+=b;\n}\nvoid Solve(int A,int B,int C){//注意数组清空 \n\t//{cout<<A<<\" \"<<B<<\" \"<<C<<endl;For(i,1,A){For(j,1,C)wri(F[i][j]); puts(\"\");}For(i,1,B){For(j,1,C)wri(G[i][j]); puts(\"\");}}\n\t//mem(wx); mem(wu); mem(lef); mem(rig); mem(mn); mem(mx); mem(q); mem(s1); mem(s2);\n\t//if(A==23&&B==22&&C==23)cout<<ans<<endl;\n\tRep(i,B,1)Rep(j,C,1)if(G[i][j]){\n\t\twx[i][j]=i;\n\t\tif(i<B)wx[i][j]=max(wx[i][j],wx[i+1][j]);\n\t\tif(j<C)wx[i][j]=max(wx[i][j],wx[i][j+1]);\n\t}else wx[i][j]=-inf;\n\tFor(i,1,A)For(j,1,C)if(F[i][j]){\n\t\twu[i][j]=i;\n\t\tif(i>1)wu[i][j]=min(wu[i-1][j],wu[i][j]);\n\t\tif(j>1)wu[i][j]=min(wu[i][j-1],wu[i][j]);\n\t}else wu[i][j]=inf;\n\tFor(i,1,C){WX[i]=wx[1][i]; WU[i]=wu[A][i];}\n\t//For(i,1,C)wri(WX[i]); puts(\"\");\n\tFor(i,1,B)For(j,1,C)if(G[i][j]){\n\t\tlef[i][j]=i==1?j:inf;\n\t\trig[i][j]=i==1?j:-inf;\n\t\tif(i>1){\n\t\t\tlef[i][j]=min(lef[i][j],lef[i-1][j]);\n\t\t\trig[i][j]=max(rig[i][j],rig[i-1][j]);\n\t\t}\n\t\tif(j>1){\n\t\t\tlef[i][j]=min(lef[i][j],lef[i][j-1]);\n\t\t\trig[i][j]=max(rig[i][j],rig[i][j-1]);\n\t\t}\n\t}else {lef[i][j]=inf; rig[i][j]=-inf;}\n\tFor(i,1,C)For(j,1,C)mn[i][j]=inf;\n\tFor(i,1,B)For(j,1,C)if(lef[i][j]<=rig[i][j])mn[lef[i][j]][rig[i][j]]=min(mn[lef[i][j]][rig[i][j]],i);\n\tFor(i,1,C)Rep(j,C,i){\n\t\tif(i>1)mn[i][j]=min(mn[i-1][j],mn[i][j]);\n\t\tif(j<C)mn[i][j]=min(mn[i][j+1],mn[i][j]);\n\t}\n\tFor(i,1,C){\n\t\tmtp[i][i]=1;\n\t\tFor(j,i+1,C)mtp[i][j]=mn[i][j]>min(WX[i],WX[j])?inf:mn[i][j];\n\t}\n\tRep(i,A,1)Rep(j,C,1)if(F[i][j]){\n\t\tmn[i][j]=i==A&&G[1][j]?j:inf;\n\t\tmx[i][j]=i==A&&G[1][j]?j:-inf;\n\t\tif(i<A){\n\t\t\tmn[i][j]=min(mn[i+1][j],mn[i][j]);\n\t\t\tmx[i][j]=max(mx[i+1][j],mx[i][j]);\n\t\t}\n\t\tif(j<C){\n\t\t\tmn[i][j]=min(mn[i][j+1],mn[i][j]);\n\t\t\tmx[i][j]=max(mx[i][j+1],mx[i][j]);\n\t\t}\n\t}else {mn[i][j]=inf; mx[i][j]=-inf;}\n\tFor(i,1,B)For(j,1,C)if(lef[i][j]<=rig[i][j]){\n\t\ts1[i]+=G[i][j];\n\t\ts2[i][lef[i][j]]+=G[i][j];\n\t\ts3[i][rig[i][j]]+=G[i][j];\n\t\ts4[lef[i][j]][rig[i][j]]+=G[i][j];\n\t}\n\tFor(i,1,B){\n\t\ts1[i]+=s1[i-1];\n\t\tFor(j,1,C)s3[i][j]+=s3[i-1][j]+s3[i][j-1]-s3[i-1][j-1];\n\t\tRep(j,C,1)s2[i][j]+=s2[i-1][j]+s2[i][j+1]-s2[i-1][j+1];\n\t}\n\tRep(i,C,1)For(j,i,C){\n\t\ts4[i][j]+=s4[i+1][j]+s4[i][j-1]-s4[i+1][j-1];\n\t}\n\t//cout<<brh(4,8,11)<<\" \"<<mtp[4][8]<<\" \"<<WX[4]<<\" \"<<WX[8]<<endl;\n\tFor(i,1,A){\n\t\tint l=1,r=0; sum=0; \n\t\tint L=1,R=0;\n\t\tFor(j,1,C)if(mn[i][j]<=mx[i][j]){\n\t\t\tassert(L<=mn[i][j]&&R<=mx[i][j]);\n\t\t\tFor(k,R+1,mx[i][j])if(WU[k]<=i&&G[1][k]){\n\t\t\t\tint o=r;\n\t\t\t\twhile(l<=r&&q[l]<L)l++;\n\t\t\t\twhile(l<=o&&WX[q[o]]<=WX[k])o--;\n\t\t\t\tif(l<=r)add(q[r],-brh(q[r],k,WX[q[r]]));\n\t\t\t\tFor(i,max(o,l),r-1)add(q[i],brh(q[i],k,WX[q[i+1]])-brh(q[i],k,WX[q[i]]));\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<sum<<\" \"<<mn[i][j]<<\" \"<<mx[i][j]<<\" \"<<brh(k,k,B)<<endl;\n\t\t\t\t//cout<<k<<\" \"<<sum<<\" \"<<only[1]<<\" \"<<only[k]<<\" \"<<WU[1]<<endl;\n\t\t\t\tq[r=o+1]=k; only[k]=brh(k,k,B); sum+=only[k];\n\t\t\t}\n\t\t\t//cout<<sum<<\" \"<<mn[i][j]<<\" \"<<mx[i][j]<<\" \"<<i<<\" \"<<j<<\" \"<<\" \"<<endl;\n\t\t\tFor(k,L,mn[i][j]-1)if(WU[k]<=i&&G[1][k])sum-=only[k];\n\t\t\tL=mn[i][j]; R=mx[i][j];\n\t\t\tans+=sum*F[i][j];\n\t\t\t//if(i>10)cout<<i<<\" \"<<j<<\" \"<<sum<<\" \"<<mn[i][j]<<\" \"<<mx[i][j]<<\" \"<<only[6]<<\" \"<<brh(6,6,3)<<endl;\n\t\t}\n\t}\n\tFor(i,1,B){s1[i]=0; For(j,1,C)s2[i][j]=s3[i][j]=0;} \n\tFor(i,1,C)For(j,i,C)s4[i][j]=0;//exit(0);\n\t//if(A==23&&B==22&&C==23)cout<<ans<<endl;\n\t//if(ans){cout<<ans<<endl; exit(0);}\n}\nvoid solve(int l,int r,int u,int d){\n\tif(l==r&&u==d)return;\n\tif(r-l>=d-u){\n\t\tint mid=(l+r)>>1;\n\t\tFor(i,l,mid)For(j,u,d)F[i-l+1][j-u+1]=s[i][j];\n\t\tFor(i,mid+1,r)For(j,u,d)G[i-mid][j-u+1]=s[i][j];\n\t\tSolve(mid-l+1,r-mid,d-u+1);  //cout<<ans<<\" \"<<mid-l+1<<\" \"<<r-mid<<\" \"<<d-u+1<<endl;\n\t\tsolve(l,mid,u,d); solve(mid+1,r,u,d);\n\t}else{\n\t\tint mid=(u+d)>>1;\n\t\tFor(i,u,mid)For(j,l,r)F[i-u+1][j-l+1]=s[j][i];\n\t\tFor(i,mid+1,d)For(j,l,r)G[i-mid][j-l+1]=s[j][i];\n\t\tSolve(mid-u+1,d-mid,r-l+1); //cout<<ans<<\" \"<<mid-u+1<<\" \"<<d-mid<<\" \"<<r-l+1<<endl;\n\t\tsolve(l,r,u,mid); solve(l,r,mid+1,d);\n\t}\n}\nint main(){\n\tint n=read();\n\tFor(i,1,n){\n\t\tscanf(\"%s\",a[i]+1);\n\t\tFor(j,1,n)s[i][j]=a[i][j]=='#'?0:a[i][j]-'0';\n\t}\n\tsolve(1,n,1,n);\n\tcout<<ans<<endl;\n}\n/*\n6\n111111\n##11#1\n1##1#1\n11##11\n111111\n1#11#1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint sumv[505][505],rpos[505][505];\nint minn[2][505][505],maxn[2][505][505];\n\nchar str[505][505];\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) scanf(\"%s\",str[i]+1);\n  int cur=0;\n  ll ans=0;\n  for(int i=n;i>0;i--) {\n  \tcur^=1;\n  \tfor(int j=n;j>0;j--)\n  \t  if (str[i][j]!='#') {\n  \t  \t  sumv[i][j]=sumv[i][j+1]+sumv[i+1][j]+str[i][j]-'0';\n  \t  \t  rpos[i][j]=max(max(rpos[i][j+1],rpos[i+1][j]),i);\n  \t  \t  minn[cur][j][i]=j;\n  \t  \t  for(int k=i+1;k<=rpos[i+1][j];k++) minn[cur][j][k]=minn[cur^1][j][k];\n  \t  \t  for(int k=max(rpos[i+1][j],i)+1;k<=rpos[i][j+1];k++) minn[cur][j][k]=minn[cur][j+1][k];\n  \t  \t  maxn[cur][j][i]=j;\n  \t  \t  for(int k=i;k<=rpos[i][j+1];k++) maxn[cur][j][k]=maxn[cur][j+1][k];\n  \t  \t  for(int k=max(rpos[i][j+1],i)+1;k<=rpos[i+1][j];k++) maxn[cur][j][k]=maxn[cur^1][j][k];\n  \t  \t  int d=i+1,r=min(rpos[i][j+1],rpos[i+1][j]);\n  \t  \t  while (d<=r) {\n  \t  \t  \t    if (maxn[cur^1][j][d]>=minn[cur][j+1][d]) {\n  \t  \t  \t    \t    sumv[i][j]-=sumv[d][minn[cur][j+1][d]];\n  \t  \t  \t    \t    d=rpos[d][minn[cur][j+1][d]];\n\t\t\t\t\t  }\n  \t  \t  \t    d++;\n\t\t\t  }\n\t\t  ans+=(ll)(str[i][j]-'0')*(sumv[i][j]-(str[i][j]-'0'));\n\t\t}\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace whatever{\n\tint readu(){\n\t\tchar ch=getchar();\n\t\twhile(!isdigit(ch))\n\t\t\tch=getchar();\n\t\tint value=ch-'0';\n\t\tch=getchar();\n\t\twhile(isdigit(ch)){\n\t\t\tvalue=value*10+ch-'0';\n\t\t\tch=getchar();\n\t\t}\n\t\treturn value;\n\t}\n\tvoid writeull(long long n){\n\t\tif(n<10)\n\t\t\tputchar(n+'0');\n\t\telse{\n\t\t\twriteull(n/10);\n\t\t\tputchar(n%10+'0');\n\t\t}\n\t}\n\tstruct set_type{\n\t\tunsigned long long *data;\n\t\tint size;\n\t\tvoid clear(){\n\t\t\tmemset(data, 0, sizeof(unsigned long long)*size);\n\t\t}\n\t\tvoid resize(int k){\n\t\t\tsize=(k+63)/64;\n\t\t\tsize=(size+3)/4*4;\n\t\t\tdata=new unsigned long long [size];\n\t\t\tclear();\n\t\t}\n\t\tvoid operator=(const set_type &b){\n\t\t\tassert(size%4==0);\n\t\t\tassert(size==b.size);\n\t\t\tmemcpy(data, b.data, sizeof(unsigned long long)*size);\n\t\t}\n\t\tvoid operator|=(const set_type &b){\n\t\t\tassert(size%4==0);\n\t\t\tassert(size==b.size);\n\t\t\tfor(int i=0; i<size; i+=4){\n\t\t\t\tdata[i]|=b.data[i];\n\t\t\t\tdata[i+1]|=b.data[i+1];\n\t\t\t\tdata[i+2]|=b.data[i+2];\n\t\t\t\tdata[i+3]|=b.data[i+3];\n\t\t\t}\n\t\t}\n\t\tint count(){\n\t\t\tassert(size%4==0);\n\t\t\tint result=0;\n\t\t\tfor(int i=0; i<size; i+=4){\n\t\t\t\tresult+=__builtin_popcountll(data[i]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+1]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+2]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+3]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvoid set(unsigned index){\n\t\t\tassert(size%4==0);\n\t\t\tassert(index<size*64);\n\t\t\tdata[index/64]|=(1ull<<(index%64));\n\t\t}\n\t};\n\tvoid run(){\n\t\tint n=readu();\n\t\tstatic char a[500][502];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tgets(a[i]);\n\t\tstatic int cnt[10];\n\t\tstatic int index[500][500];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tif(a[i][j]!='#'){\n\t\t\t\t\tassert(isdigit(a[i][j]));\n\t\t\t\t\tindex[i][j]=cnt[a[i][j]-'0']++;\n\t\t\t\t}\n\t\tstatic set_type set_data[2][500][10];\n\t\tfor(int i=0; i<2; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tfor(int k=0; k<10; ++k)\n\t\t\t\t\tset_data[i][j][k].resize(cnt[k]);\n\t\tset_type (*cur_set_data)[10]=set_data[0];\n\t\tset_type (*next_set_data)[10]=set_data[1];\n\t\tlong long result=0;\n\t\tcerr<<\"clock(): \"<<clock()/double(CLOCKS_PER_SEC)<<endl;\n\t\tfor(int r=n-1; r>=0; --r){\n\t\t\tfor(int c=n-1; c>=0; --c){\n\t\t\t\tif(isdigit(a[r][c])){\n\t\t\t\t\tfor(int i=0; i<10; ++i){\n\t\t\t\t\t\tnext_set_data[c][i]=cur_set_data[c][i];\n\t\t\t\t\t\tif(c<n-1)\n\t\t\t\t\t\t\tnext_set_data[c][i]|=next_set_data[c+1][i];\n\t\t\t\t\t\tresult+=(long long)next_set_data[c][i].count()*i*(a[r][c]-'0');\n\t\t\t\t\t\tif(i==a[r][c]-'0')\n\t\t\t\t\t\t\tnext_set_data[c][i].set(index[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int i=0; i<10; ++i)\n\t\t\t\t\t\tnext_set_data[c][i].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur_set_data, next_set_data);\n\t\t}\n\t\tcerr<<\"clock(): \"<<clock()/double(CLOCKS_PER_SEC)<<endl;\n\t\twriteull(result);\n\t\tputchar('\\n');\n\t}\n}\nint main(){\n\twhatever::run();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char *s) {\n  return to_string((string)s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate<typename A, typename B> string to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate<typename A> string to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() {\n  cerr << endl;\n}\n\ntemplate<typename Head, typename... Tail> void debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\nconst int inf = 0x3f3f3f3f;\n\nvoid cmax(int &x, int y) {\n  if (x < y) {\n    x = y;\n  }\n}\n\nvoid cmin(int &x, int y) {\n  if (x > y) {\n    x = y;\n  }\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  cin >> n;\n  vector<string> board(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> board[i];\n  }\n  long long answer = 0;\n\n  function<void(vector<string>)> solve = [&](vector<string> board) {\n    int n = board.size(), m = board[0].size();\n    \n    if (n < m) {\n      vector<string> rotated(m, string(n, ' '));\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n          rotated[j][i] = board[i][j];\n        }\n      }\n      swap(n, m);\n      board = rotated;\n    }\n    \n    if (m == 1) {\n      int sum = 0;\n      for (int i = 0; i < n; ++i) {\n        if (board[i][0] == '#') {\n          sum = 0;\n        } else {\n          answer += (board[i][0] - '0') * sum;\n          sum += board[i][0] - '0';\n        }\n      }\n      return;\n    }\n\n    vector<string> u = vector<string> (board.begin(), board.begin() + (n >> 1));\n    vector<string> d = vector<string> (board.begin() + (n >> 1), board.end());\n    solve(u);\n    solve(d);\n    u.push_back(d[0]);\n\n    int nu = n >> 1, nd = n + 1 >> 1;\n    vector<vector<int>> left(nd, vector<int> (m, inf));\n    vector<vector<int>> right(nd, vector<int> (m, -inf));\n    vector<int> top(m);\n    vector<int> bottom(m);\n    for (int i = 0; i < m; ++i) {\n      if (d[0][i] != '#') {\n        left[0][i] = right[0][i] = i;\n      }\n    }\n    for (int i = 0; i < nd; ++i) {\n      for (int j = 0; j < m; ++j) {\n        if (d[i][j] != '#') {\n          if (i) {\n            cmin(left[i][j], left[i - 1][j]);\n            cmax(right[i][j], right[i - 1][j]);\n          }\n          if (j) {\n            cmin(left[i][j], left[i][j - 1]);\n            cmax(right[i][j], right[i][j - 1]);\n          }\n        }\n      }\n    }\n\n    {\n      vector<vector<int>> temp(nd, vector<int> (m, -inf));\n      for (int i = nd - 1; ~i; --i) {\n        for (int j = m - 1; ~j; --j) {\n          if (d[i][j] != '#') {\n            temp[i][j] = i;\n            if (i + 1 < nd) {\n              cmax(temp[i][j], temp[i + 1][j]);\n            }\n            if (j + 1 < m) {\n              cmax(temp[i][j], temp[i][j + 1]);\n            }\n          }\n        }\n      }\n      for (int i = 0; i < m; ++i) {\n        bottom[i] = temp[0][i];\n      }\n    }\n\n    {\n      vector<vector<int>> temp(nu + 1, vector<int> (m, inf));\n      for (int i = 0; i <= nu; ++i) {\n        for (int j = 0; j < m; ++j) {\n          if (u[i][j] != '#') {\n            temp[i][j] = i;\n            if (i) {\n              cmin(temp[i][j], temp[i - 1][j]);\n            }\n            if (j) {\n              cmin(temp[i][j], temp[i][j - 1]);\n            }\n          }\n        }\n      }\n      for (int i = 0; i < m; ++i) {\n        top[i] = temp[nu][i];\n      }\n    }\n\n    vector<vector<int>> mp(m, vector<int> (m, inf));\n    for (int i = 0; i < nd; ++i) {\n      for (int j = 0; j < m; ++j) {\n        if (left[i][j] <= right[i][j]) {\n          cmin(mp[left[i][j]][right[i][j]], i);\n        }\n      }\n    }\n    for (int l = 0; l < m; ++l) {\n      for (int r = m - 1; ~r; --r) {\n        if (l) {\n          cmin(mp[l][r], mp[l - 1][r]);\n        }\n        if (r + 1 < m) {\n          cmin(mp[l][r], mp[l][r + 1]);\n        }\n      }\n    }\n\n    auto meeting_point = [&](int a, int b) {\n      int p = mp[a][b];\n      return p <= min(bottom[a], bottom[b]) ? p : inf;\n    };\n\n    vector<int> sum1(nd);\n    vector<vector<int>> sum2(nd, vector<int> (m));\n    vector<vector<int>> sum3(nd, vector<int> (m));\n    vector<vector<int>> sum4(m, vector<int> (m));\n\n    for (int i = 0; i < nd; ++i) {\n      if (i) {\n        sum1[i] = sum1[i - 1];\n        for (int j = 0; j < m; ++j) {\n          sum2[i][j] = sum2[i - 1][j];\n          sum3[i][j] = sum3[i - 1][j];\n        }\n      }\n      for (int j = 0; j < m; ++j) {\n        if (left[i][j] <= right[i][j]) {\n          sum1[i] += d[i][j] - '0';\n          if (left[i][j]) {\n            sum2[i][left[i][j] - 1] += d[i][j] - '0';\n          }\n          if (right[i][j] + 1 < m) {\n            sum3[i][right[i][j] + 1] += d[i][j] - '0';\n          }\n          if (left[i][j] && right[i][j] + 1 < m) {\n            sum4[left[i][j] - 1][right[i][j] + 1] += d[i][j] - '0';\n          }\n        }\n      }\n    }\n    for (int i = 0; i < nd; ++i) {\n      for (int j = m - 1; j; --j) {\n        sum2[i][j - 1] += sum2[i][j];\n      }\n      for (int j = 1; j < m; ++j) {\n        sum3[i][j] += sum3[i][j - 1];\n      }\n    }\n    for (int l = m - 1; ~l; --l) {\n      for (int r = l; r < m; ++r) {\n        if (l + 1 < m) {\n          sum4[l][r] += sum4[l + 1][r];\n        }\n        if (r) {\n          sum4[l][r] += sum4[l][r - 1];\n        }\n        if (l + 1 < m && r) {\n          sum4[l][r] -= sum4[l + 1][r - 1];\n        }\n      }\n    }\n\n    auto both_reachable = [&](int a, int b, int l) {\n      if (meeting_point(a, b) > l) {\n        return 0;\n      } else {\n        return sum1[l] - sum2[l][a] - sum3[l][b] + sum4[a][b];\n      }\n    };\n\n    vector<int> reachable(m);\n    for (int i = 0; i < m; ++i) {\n      reachable[i] = both_reachable(i, i, bottom[i]);\n    }\n\n    vector<vector<int>> event(nu);\n    vector<bool> ban(m);\n    for (int i = 0; i < m; ++i) {\n      if (top[i] >= nu) {\n        ban[i] = true;\n      } else {\n        event[top[i]].push_back(i);\n      }\n    }\n    vector<int> l(m), r(m);\n    for (int i = m - 1; ~i; --i) {\n      if (d[0][i] == '#') {\n        l[i] = inf;\n        r[i] = -inf;\n      } else {\n        l[i] = i;\n        r[i] = max(i, i + 1 < m ? r[i + 1] : -inf);\n      }\n    }\n    for (int row = nu - 1; ~row; --row) {\n      for (int i = m - 1; ~i; --i) {\n        if (u[row][i] == '#') {\n          l[i] = inf;\n          r[i] = -inf;\n        } else if (i + 1 < m) {\n          cmin(l[i], l[i + 1]);\n          cmax(r[i], r[i + 1]);\n        }\n      }\n      vector<int> has(m);\n      vector<int> st(m);\n      int sum = 0, stl = 0, str = 0, myl = 0, myr = -1;\n      \n      auto insert = [&](int x) {\n        if (!ban[x]) {\n          if (stl < str) {\n            sum -= has[st[str - 1]];\n            has[st[str - 1]] -= both_reachable(st[str - 1], x, min(bottom[st[str - 1]], bottom[x]));\n            sum += has[st[str - 1]];\n            if (bottom[st[str - 1]] <= bottom[x]) {\n              --str;\n              while (stl < str) {\n                sum -= has[st[str - 1]];\n                has[st[str - 1]] -= both_reachable(st[str - 1], x, min(bottom[st[str - 1]], bottom[x])) - both_reachable(st[str - 1], x, min(bottom[st[str]], bottom[x]));\n                sum += has[st[str - 1]];\n                if (bottom[st[str - 1]] <= bottom[x]) {\n                  --str;\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n          st[str++] = x;\n          has[x] = reachable[x];\n          sum += has[x];\n        }\n      };\n\n      auto erase = [&](int x) {\n        if (!ban[x]) {\n          sum -= has[x];\n          if (stl < str && st[stl] == x) {\n            ++stl;\n          }\n        }\n      };\n\n      for (int i = 0; i < m; ++i) {\n        if (l[i] <= r[i]) {\n          while (myr < r[i]) {\n            insert(++myr);\n          }\n          while (myl < l[i]) {\n            erase(myl++);\n          }\n          answer += (u[row][i] - '0') * sum;\n        }\n      }\n      for (auto p : event[row]) {\n        ban[p] = true;\n      }\n    }\n  };\n\n  solve(board);\n  cout << answer << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;++x)\n#define Red(x,y,z) for(int x=y;x>=z;--x)\nusing namespace std;\nconst int MAXN=1505;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\n//inline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;ny=1;while(nc=gc(),(nc<48||nc>57)&&nc!=EOF)if(nc==45)ny=-1;if(nc<0)return nc;\n\tx=nc-48;while(nc=gc(),47<nc&&nc<58&&nc!=EOF)x=(x<<3)+(x<<1)+(nc^48);return x*ny;\n}\nint Sumv[MAXN][MAXN],rpos[MAXN][MAXN],Mn[2][MAXN][MAXN],Mx[2][MAXN][MAXN],n;ll ans;\nchar S[MAXN][MAXN];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read();\n\tRep(i,1,n)scanf(\"%s\",S[i]+1);\n\tfor(int i=n,cur=1;i>=1;i--,cur^=1)Red(j,n,1)if(S[i][j]!='#'){\n\t\tSumv[i][j]=Sumv[i+1][j]+Sumv[i][j+1]+(S[i][j]^48),rpos[i][j]=max(max(rpos[i+1][j],rpos[i][j+1]),i);\n\t\tMn[cur][j][i]=j;\n\t\tRep(k,i+1,rpos[i+1][j])Mn[cur][j][k]=Mn[cur^1][j][k];\n\t\tRep(k,max(rpos[i+1][j],i)+1,rpos[i][j+1])Mn[cur][j][k]=Mn[cur][j+1][k];\n\t\tMx[cur][j][i]=j;\n\t\tRep(k,i,rpos[i][j+1])Mx[cur][j][k]=Mx[cur][j+1][k];\n\t\tRep(k,max(rpos[i][j+1],i)+1,rpos[i+1][j])Mx[cur][j][k]=Mx[cur^1][j][k];\n\t\tfor(int d=i+1,r=min(rpos[i][j+1],rpos[i+1][j]);d<=r;d++){\n\t\t\tif(Mx[cur^1][j][d]>=Mn[cur][j+1][d])\n\t\t\t\tSumv[i][j]-=Sumv[d][Mn[cur][j+1][d]],d=rpos[d][Mn[cur][j+1][d]];\n\t\t}ans=(ans+1ll*(Sumv[i][j]-(S[i][j]^48))*(S[i][j]^48));\n\t}cout<<ans<<\"\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v){\n\t\tint new_sz = v/d+2;\n\t\twhile(wek.size() < new_sz) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[505];\nll ans;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n) B[i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[x].upper(9*(x*n+y)+9);\n\t\t\t\tif(x) oruj(B[x],B[x-1]);\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].licz());\n\t\t\t\trep(a,f[x][y]-'0') B[x].ustaw(9*(x*n+y)+a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].zeruj();\n\t\t\t\tB[x].upper(9*(x*n+y)+9);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]];\n\t\t\t\t\tlas_r=r[k][j];\n\t\t\t\t\tl[k][j]=min(l[k][j],l[k][j+1]);\n\t\t\t\t\tr[k][j]=max(r[k][j],r[k][j+1]);\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bitset {\n  vector<unsigned long long> a;\n  Bitset() {}\n  Bitset(const vector<unsigned long long>& a) : a(a) {}\n\n  Bitset f(const Bitset &o) {\n    vector<unsigned long long> vec(max(o.a.size(), a.size()));\n    for (int i = 0; i < vec.size(); i++) {\n      unsigned long long x = 0, y = 0;\n      if (i < a.size()) x = a[i];\n      if (i < o.a.size()) y = o.a[i];\n      vec[i] = (x | y);\n    }\n    return Bitset(vec);\n  }\n\n  int count() {\n    int ret = 0;\n    for (auto x : a) {\n      ret += __builtin_popcountll(x);\n    }\n    return ret;\n  }\n\n  void reset() {\n    for (auto& x : a) {\n      x = 0;\n    }\n  }\n\n  void set(int v) {\n    int p = v / 64;\n    while (a.size() <= p) a.push_back(0);\n    a[p] |= (1ULL << (v % 64));\n  }\n}a[2][501][10];\nint b[505][505];\n\nint main(int argc, char *argv[]) {\n  std::ios_base::sync_with_stdio(false);\n  vector<int> c(11);\n  int n;\n  cin >> n;\n  long long ans = 0;\n  for (int i = 0, now = 0; i < n; i++, now ^= 1) {\n    for (int j = 1; j <= n; j++) {\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k].reset();\n      }\n    }\n    string s;\n    cin >> s;\n    for (int j = 1; j <= n; j++) {\n      if (s[j - 1] == '#') continue;\n      int v = s[j - 1] - '0';\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k] = a[now][j - 1][k].f(a[now ^ 1][j][k]);\n        ans += a[now][j][k].count() * k * v;\n      }\n      a[now][j][v].set(c[v]++);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n//#include <bits/stdc++.h>\n#include <stack>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef int LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nlong long ans = 0;\nlong long sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE];\nint val[SIZE][SIZE];\nLL times = 0,times2=0;\nLL dfs(int y, int x) {\n\ttimes++;\n\tif (y > N or x > N or A[y][x] == 0 or reached[y][x]) return 0;\n\treached[y][x] = true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs22(int yy, int xx) {\n\tstack<pr> st;\n\tst.emplace(yy, xx);\n\tint ret = 0;\n\twhile (!st.empty()) {\n\t\tint y=st.top().first, x=st.top().second;\n\t\tif (val[y][x] == 0) {\n\t\t\tval[y][x] = -1;\n\t\t\treached[y][x] = 0;\n\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) st.emplace(y, x+1);\n\t\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) st.emplace(y + 1, x);\n\t\t}\n\t\telse {\n\t\t\tval[y][x] = val[y][x + 1] + val[y + 1][x];\n//\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) ret+=val[y][x + 1];\n\t//\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) ret+=val[y][x+1];\n\t\t\tst.pop();\n\t\t}\n\t}\n//\treached[y][x] = 0;\n//\treturn  (( ? dfs2(y, x + 1) : 0) + ( : 0) + A[y][x]);\n\treturn val[yy][xx];\n\n}\n\nLL dfs2(int y, int x) {\n\ttimes++;\n\treached[y][x] = 0;\n\treturn  (((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0) ? dfs2(y, x + 1) : 0 )+ ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x]) ? dfs2(y + 1, x) : 0) + A[y][x]);\n}\nlong long solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i, 1, N) {\n\t\t//cout << \"A\";\n\t\tsum += dfs(x, i);\n\t\t//cout << \"B\";\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tsum -= A[x][i];\n\t\tans += (long long)sum* (long long)A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tif (A[x + 1][i] == 0) continue;\n\t\tif (reached[x + 1][i] == 0) continue;\n\t\tif (reached[x][i]) continue;\n\n\t\tsum -= dfs2(x + 1, i);\n\t//\tcout << \"C\" << endl;\n\n\t}\n\tcout << times << \" \" << times2 << endl;\n\treturn ans;\n}\nlong long solve() {\n/*\tcin >> N;\n\tEFOR(i, 1, N) {\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1] - '0';\n\t\t}\n\t}*/\n\tN = 500;\n\tEFOR(i, 1, N) EFOR(j, 1, N) A[i][j] = 9;\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\n\nconst int MX = 500, WORDS = (MX * MX + 63) >> 6;\n\npair<int, int> bit(int x, int y) {\n\tint f = max(MX - 1 - x, MX - 1 - y);\n\tint z = f * f;\n\tif (MX - 1 - x == f) z += MX - 1 - y;\n\telse z += f + 1 + MX - 1 - x;\n\treturn {z >> 6, z & 63};\n}\n\nchar s[MX][MX + 1];\nuint64_t reach[MX + 1][WORDS];\nuint64_t mask[WORDS][4];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) ignore = scanf(\" %s\", s[i]);\n\t//for (int i = 0; i < n; i++) fill(s[i], s[i] + n, '7');\n\t\n\tfor (int x = 0; x < n; x++)\n\t\tfor (int y = 0; y < n; y++) {\n\t\t\tif (s[x][y] == '#') continue;\n\t\t\tint a = s[x][y] - '0', p, q;\n\t\t\ttie(p, q) = bit(x, y);\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmask[p][k] |= ((a >> k) & 1ULL) << q;\n\t\t\t}\n\t\t}\n\t\n\tlong long ans = 0;\n\tfor (int d = 2 * (n - 1); d >= 0; d--) {\n\t\tfor (int x = 0, y = d; x <= d; x++, y--) {\n\t\t\tif (y >= n || x >= n || s[x][y] == '#') {\n\t\t\t\tif (x < n) memset(reach[x], 0, sizeof reach[x]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint sum0 = 0, sum1 = 0, sum2 = 0, sum3 = 0;\n\t\t\tuint64_t* r1 = reach[x];\n\t\t\tuint64_t* r2 = reach[x + 1];\n\t\t\tfor (int i = 0; i < WORDS; i++) {\n\t\t\t\tr1[i] |= r2[i];\n\t\t\t\tif (r1[i] > 0) {\n\t\t\t\t\tsum0 += __builtin_popcountll(r1[i] & mask[i][0]);\n\t\t\t\t\tsum1 += __builtin_popcountll(r1[i] & mask[i][1]);\n\t\t\t\t\tsum2 += __builtin_popcountll(r1[i] & mask[i][2]);\n\t\t\t\t\tsum3 += __builtin_popcountll(r1[i] & mask[i][3]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans += (sum0 + sum1 * 2 + sum2 * 4 + sum3 * 8) * (s[x][y] - '0');\n\t\t\t\n\t\t\tint p, q;\n\t\t\ttie(p, q) = bit(x, y);\n\t\t\treach[x][p] |= (1ULL << q);\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// doot diddly donger cuckerino Hahahahahah\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int LL;\ntypedef unsigned int UINT;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PII;\ntypedef pair<string, int> PSI;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef vector<bool> VB;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef tuple<int, int, int> TPL;\ntypedef priority_queue<int> pqueue;\ntypedef priority_queue<int, VI, greater<int>> pdqueue;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, 1, 0, -1, -1, 1, -1, 1};\nconst int dxhorse[] = {-2, -2, -1, -1, 1, 1, 2, 2};\nconst int dyhorse[] = {1, -1, 2, -2, 2, -2, 1, -1};\n\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define endl \"\\n\"\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define F first\n#define S second\n#define SZ(x)           (x).size()\n#define MAX(a, b)      ((a)>(b)?(a):(b))\n#define MIN(a, b)      ((a)<(b)?(a):(b))\n#define ALL(a)         std::begin(a), std::end(a)\n#define Fill(n, x)      memset(n,x,sizeof n);\n#define IN_REP         int _t; cin >> _t ; while(_t--)\n#define IOS            ios::sync_with_stdio(false);cin.tie(NULL)\n#define FOR(i, a, b)    for(int i=(a);i<(b);i++)\n#define REP(i, n)       FOR(i,0,n)\n#define FORR(i, n)      for(int i=(n);i>=0;i--)\n#define EPS (double) 1e-9\n#define MOD (1000*1000*1000 + 7)\n#define INF 1011111111\n#define LLINF 1000111000111000111LL\nint n;\nVS c;\nVVI a;\nmap<PII, VPII> mp;\n\nbool reachable(int x1, int y1, int x2, int y2) {\n    if (x2 < x1 || y2 < y1 || x1 < 0 || x2 < 0 || y1 >= n || y2 >= n || x1 >= n || x2 >= n || y1 < 0 || y2 < 0) {\n        return false;\n    }\n    if (c[x1][y1] == '#') return false;\n    if (x1 == x2 && y1 == y2)return true;\n    return reachable(x1 + 1, y1, x2, y2) || reachable(x1, y1 + 1, x2, y2);\n}\n\nvoid pre() {\n    IOS;\n    freopen(\"/home/whiteknife/Workspace/CLionProjects/untitled/in\", \"r\", stdin);\n    cin >> n;\n    a.resize(n, VI(n, 0));\n    c.resize(n);\n//    v.resize(n, VB(n, false));\n    REP(i, n)cin >> c[i];\n    REP(i, n)REP(j, n)if (c[i][j] != '#') a[i][j] = (c[i][j] - '0');\n    FOR(i, 0, n) {\n        FOR(j, 0, n) {\n            FOR(k, i, n) {\n                FOR(l, j, n) {\n                    if ((i == k && j == l)) continue;\n                    if (reachable(i, j, k, l))mp[MP(i, j)].PB(MP(k, l));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    pre();\n    LL ans = 0;\n    REP(i, n) {\n        REP(j, n) {\n            if (c[i][j] == '#')continue;\n            FOR(k, i, n) {\n                FOR(l, j, n) {\n                    if (i == k && j == l)continue;\n                    if (find(ALL(mp[MP(i, j)]), MP(k, l)) != mp[MP(i, j)].end()) ans += a[i][j] * a[k][l];\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,g[505][505],s[505][505],mx;\nbool e[505][505];\nLL res;\nint readchar(){\n\tchar c=getchar();\n\twhile(c==' ' || c=='\\n') c=getchar();\n\tif(c=='#') return 0;\n\treturn c-'0';\n}\nnamespace DSU{\n\tint fa[250005],rk[250005];\n\tvoid init(){\n\t\tint i;\n\t\tmemset(rk,0,sizeof(rk));\n\t\tfor(i=0;i<=n*n;++i) fa[i]=i;\n\t}\n\tint ancestor(int x){\n\t\tif(fa[x]!=x) fa[x]=ancestor(fa[x]);\n\t\treturn fa[x];\n\t}\n\tvoid unite(int u,int v){\n\t\tu=ancestor(u);\n\t\tv=ancestor(v);\n\t\tif(rk[u]<rk[v])\n\t\t\tfa[u]=v;\n\t\telse if(rk[u]>rk[v])\n\t\t\tfa[v]=u;\n\t\telse{\n\t\t\tfa[u]=v;\n\t\t\t++rk[v];\n\t\t}\n\t}\n\tbool con(int u,int v){\n\t\treturn ancestor(u)==ancestor(v);\n\t}\n};\nvoid add(int x,int y){\n\te[x][y]=1;\n\tif(e[x-1][y]) DSU::unite(x*n+y,(x-1)*n+y);\n\tif(e[x][y-1]) DSU::unite(x*n+y-1,x*n+y);\n\tif(e[x+1][y]) DSU::unite(x*n+y,(x+1)*n+y);\n\tif(e[x][y+1]) DSU::unite(x*n+y+1,x*n+y);\n\tif(x<n-1 && g[x+1][y] && !e[x+1][y]) add(x+1,y);\n\tif(y<n-1 && g[x][y+1] && !e[x][y+1]) add(x,y+1);\n}\nint getlower(int x,int y){\n\tint cx=x,cy=y,ret=(y?s[x][y-1]:0);\n\tmx=x;\n\twhile(1){\n\t\twhile(1){\n\t\t\tif(cx+1<n && e[cx+1][cy]){\n\t\t\t\t++cx;\n\t\t\t\tmx=cx;\n\t\t\t\tret+=(cy?s[cx][cy-1]:0);\n\t\t\t}\n\t\t\telse if(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cy+1<n){\n\t\t\t++cy;\n\t\t\tif(e[cx][cy] && DSU::con(cx*n+cy,x*n+y)){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(e[cx][cy]) break;\n\t\t}\n\t\tif(!found) break;\n\t}\n\treturn ret;\n}\nint getupper(int x,int y){\n\tint cx=x,cy=y,ret=0;\n\tint lct=0;\n\twhile(1){\n\t\t++lct;\n\t\twhile(1){\n\t\t\tif(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse if(cx+1<n && e[cx+1][cy]){\n\t\t\t\tret+=s[cx][cy];\n\t\t\t\t++cx;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cx<n-1){\n\t\t\tret+=s[cx][cy];\n\t\t\t++cx;\n\t\t\tif(cx>mx) break;\n\t\t\tif(e[cx][cy] && DSU::con(cx*n+cy,x*n+y)){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(e[cx][cy]) break;\n\t\t}\n\t\tif(!found || cx>mx) break;\n\t}\n\tif(cx<=mx) ret+=s[cx][cy];\n\treturn ret;\n}\nvoid solveline(int x){\n\tint i,j,k;\n\tmemcpy(s,g,sizeof(g));\n\tfor(i=0;i<n;++i){\n\t\tfor(j=1;j<n;++j){\n\t\t\ts[i][j]+=s[i][j-1];\n\t\t}\n\t}\n\tDSU::init();\n\tfor(i=x;i<n;++i) memset(e[i],0,sizeof(e[i]));\n\tfor(i=n-1;i>=0;--i){\n\t\tif(!g[x][i]) continue;\n\t\tadd(x,i);\n\t\tres-=(LL)g[x][i]*(LL)getlower(x,i);\n\t\tres+=(LL)g[x][i]*(LL)(getupper(x,i)-g[x][i]);\n\t}\n}\nvoid del(int x,int y){\n\tif((!x || !g[x-1][y]) && (!y || !g[x][y-1])){\n\t\tg[x][y]=0;\n\t\tif(x<n-1 && g[x+1][y]) del(x+1,y);\n\t\tif(y<n-1 && g[x][y+1]) del(x,y+1);\n\t}\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\tg[i][j]=readchar();\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\te[i][j]=(!!g[i][j]);\n\t\t}\n\t}\n    for(i=n-1;i>=0;--i){\n\t\tsolveline(i);\n\t\tfor(j=0;j<n;++j){\n\t\t\tif(g[i][j]) del(i,j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 64\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t\twhile(wek.size() < (v/d)+2) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid ustaw(int v,int a)\n\t{\n\t\tfor(int i=v;i<v+a;i++) ustaw(i);\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[505];\nll ans;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[x].upper(9*(x*n+y)+9);\n\t\t\t\tif(x) oruj(B[x],B[x-1]);\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].licz());\n\t\t\t\tB[x].ustaw(9*(x*n+y),f[x][y]-'0');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].zeruj();\n\t\t\t\tB[x].upper(9*(x*n+y)+9);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include <bits/stdc++.h>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int LL\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nLL ans = 0;\nLL sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE]; \nLL dfs(int y,int x) {\n\tif (y > N or x > N or A[y][x] == 0 or reached[y][x]) return 0;\n\treached[y][x]=true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs2(int y, int x) {\n//\tcout << y << \" \" << x << endl;\n\n\t//cout << y << \" \" << x << endl;\n\treached[y][x] = 0;\n\tLL ret = 0;\n\tif(x+1<=N and A[y][x+1] and reached[y][x+1] and reached[y-1][x+1]==0)\n\tret += dfs2(y, x + 1);\n\tif(y+1<=N and A[y+1][x] and reached[y+1][x])\n\tret += dfs2(y + 1, x);\n\n\treturn ret + A[y][x];\n}\nLL solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i,1, N) {\n\t\tsum+=dfs(x, i);\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tans +=( sum - A[x][i] )* A[x][i];\n\t\t//cout << ans << endl;\n\t\tsum -= A[x][i];\n\t\treached[x][i] = false;\n\t\tif (A[x+1][i] == 0) continue;\n\t\tif (reached[x+1][i] == 0) continue;\n\t\tif (reached[x][i]) continue;\n\t\tsum-=dfs2(x+1, i);\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N;\n\tEFOR(i,1,N){\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1]-'0';\n\t\t}\n\t}\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1505,p=1000000007;\nint read(){\n\tint f=1,g=0;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,f[N][N],d[N][N];\ntypedef unsigned short us;\nus a[N][N],l[N][N],r[N][N];\nll ans;\nchar ch[N];\ninline void chkmin(us &x,us y){if (x>y) x=y;}\ninline void chkmax(us &x,us y){if (x<y) x=y;}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\" %s\",ch+1);\n\t\tfor (int j=1;j<=n;j++)\n\t\ta[i][j]=(ch[j]=='#') ? 0 : (ch[j]-'0');\n\t}\n\tmemset(l,0x3f,sizeof(l));\n\tfor (int i=n;i;i--)\n\tfor (int j=n;j;j--)\n\tif (a[i][j]){\n\t\tint t=f[i+1][j]+f[i][j+1];\n\t\td[i][j]=max(max(d[i][j+1],d[i+1][j]),i);\n\t\tif (!a[i][j+1]){l[j][i]=r[j][i]=j;}\n\t\telse if (!a[i+1][j]){\n\t\t\tmemcpy(l[j]+i,l[j+1]+i,(n-i+1)*2);\n\t\t\tmemcpy(r[j]+i,r[j+1]+i,(n-i+1)*2);\n\t\t\tl[j][i]=j;\n\t\t}\n\t\telse{\n\t\t\tl[j][i]=j;r[j][i]=r[j+1][i];\n\t\t\tus las=0;\n\t\t\tfor (int x=i+1;x<=d[i][j];x++){\n\t\t\t\tif ((l[j+1][x]<=r[j][x])&&(las<l[j+1][x])) t-=f[x][l[j+1][x]];\n\t\t\t\tchkmax(las,r[j][x]);\n\t\t\t\tchkmin(l[j][x],l[j+1][x]);chkmax(r[j][x],r[j+1][x]);\n\t\t\t}\n\t\t}\n\t\tans+=a[i][j]*t;\n\t\tf[i][j]=a[i][j]+t;\n\t}\n\telse{memset(l[j]+i,0x3f,(n-i+1)*2);memset(r[j]+i,0,(n-i+1)*2);}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1505;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nchar s[MAXN][MAXN]; int n, a[MAXN][MAXN];\nint l[MAXN][MAXN], r[MAXN][MAXN], res[MAXN][MAXN];\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", s[i] + 1);\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (s[i][j] == '#') a[i][j] = 0;\n\t\t\telse a[i][j] = s[i][j] - '0';\n\t}\n\tll finalans = 0;\n\tfor (int i = n; i >= 1; i--)\n\tfor (int j = n; j >= 1; j--) {\n\t\tif (a[i][j] != 0) {\n\t\t\tif (a[i + 1][j] == 0 && a[i][j + 1] == 0) l[j][i] = r[j][i] = j;\n\t\t\telse if (a[i + 1][j] == 0) {\n\t\t\t\tfor (int k = i; k <= n; k++) {\n\t\t\t\t\tl[j][k] = l[j + 1][k];\n\t\t\t\t\tr[j][k] = r[j + 1][k];\n\t\t\t\t} l[j][i] = j;\n\t\t\t\tres[i][j] = res[i][j + 1];\n\t\t\t} else if (a[i][j + 1] == 0) {\n\t\t\t\tl[j][i] = r[j][i] = j;\n\t\t\t\tres[i][j] = res[i + 1][j];\n\t\t\t} else {\n\t\t\t\tint Max = 0, ans = res[i + 1][j] + res[i][j + 1];\n\t\t\t\tl[j][i] = j, r[j][i] = r[j + 1][i];\n\t\t\t\tfor (int k = i + 1; k <= n; k++) {\n\t\t\t\t\tif (r[j][k] >= l[j + 1][k] && l[j + 1][k] > Max) ans -= res[k][l[j + 1][k]];\n\t\t\t\t\tchkmax(Max, r[j][k]);\n\t\t\t\t\tchkmax(r[j][k], r[j + 1][k]);\n\t\t\t\t\tchkmin(l[j][k], l[j + 1][k]);\n\t\t\t\t}\n\t\t\t\tres[i][j] = ans;\n\t\t\t}\n\t\t\tfinalans += a[i][j] * res[i][j];\n\t\t\tres[i][j] += a[i][j];\n\t\t} else {\n\t\t\tfor (int k = i; k <= n; k++)\n\t\t\t\tl[j][k] = n + 1, r[j][k] = 0;\n\t\t}\n\t}\n\tcout << finalans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 64\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    while(wek.size() < (v/d)+2) wek.pb(0);\n\t}\n\tvoid upp(int v){\n\t    while(wek.size() < v) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[1505][1505];\nbity B[10][1505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n); //n = 950; srand((unsigned)time(NULL));\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\t//repn(x,9) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+1);\n\t\t\t    repn(w,9) B[w][x].upp(B[w][x-1].wek.size());\n\t\t\t\tif(x){\n\t\t\t\t    repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\t}\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t    repn(w,9) B[w][x].upp(B[w][x-1].wek.size());\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S[2020];\nshort L[1500][1500],R[1500][1500];\nint dp[1500][1500];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y,x2,y2; string s;\n\t\n\tcin>>N;\n\tFOR(y,N) {\n\t\tcin>>S[y];\n\t\tFORR(c,S[y]) {\n\t\t\tif(c!='#') c-='0';\n\t\t\telse c=0;\n\t\t}\n\t}\n\tll ret=0;\n\tfor(y=N-1;y>=0;y--) {\n\t\tL[y][N]=N;\n\t\tR[y][N]=-1;\n\t\tfor(x=N-1;x>=0;x--) {\n\t\t\tint down=(y<N-1) && (S[y+1][x]>0);\n\t\t\tint right=(x<N-1) && (S[y][x+1]>0);\n\t\t\t\n\t\t\tif(S[y][x]==0) {\n\t\t\t\tfor(y2=y;y2<N;y2++) {\n\t\t\t\t\tL[y][x]=N;\n\t\t\t\t\tR[y][x]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[y][x]=dp[y+1][x]+dp[y][x+1];\n\t\t\t\tL[y][x]=x;\n\t\t\t\tif(down&&right) {\n\t\t\t\t\tR[y][x]=R[y][x+1];\n\t\t\t\t\t\n\t\t\t\t\tint r=0;\n\t\t\t\t\tfor(y2=y+1;y2<N;y2++) {\n\t\t\t\t\t\tif(L[y2][x+1]<=R[y2][x] && r<L[y2][x+1]) {\n\t\t\t\t\t\t\tdp[y][x]-=dp[y2][L[y2][x+1]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr=R[y2][x];\n\t\t\t\t\t\tR[y2][x]=max(R[y2][x],R[y2][x+1]);\n\t\t\t\t\t\tL[y2][x]=min(L[y2][x],L[y2][x+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(down) {\n\t\t\t\t\tR[y][x]=x;\n\t\t\t\t}\n\t\t\t\telse if(right) {\n\t\t\t\t\tR[y][x]=R[y][x+1];\n\t\t\t\t\tfor(y2=y+1;y2<N;y2++) {\n\t\t\t\t\t\tL[y2][x]=L[y2][x+1];\n\t\t\t\t\t\tR[y2][x]=R[y2][x+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tR[y][x]=x;\n\t\t\t\t\tfor(y2=y+1;y2<N;y2++) {\n\t\t\t\t\t\tL[y2][x]=N;\n\t\t\t\t\t\tR[y2][x]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret+=S[y][x]*dp[y][x];\n\t\t\t\tdp[y][x]+=S[y][x];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//freopen(\"a.in\",\"r\",stdin);\n//freopen(\"zj.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]>r[k][j+1]) break;\n\t\t\t//\tif(i==2&&j==1) cout<<\"-_-\"<<las_r<<\" \"<<k<<\" \"<<l[k][j+1]<<endl;\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]],las_r=r[k][j+1];\n\t\t\t\t\tif(las_r>=l[k][j+1]) las_r=max(las_r,r[k][j+1]);\n\t\t\t\t\t//if(l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t\t\tl[k][j]=min(l[k][j],l[k][j+1]);\n\t\t\t\t\tr[k][j]=max(r[k][j],r[k][j+1]);\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\telse l[i][j]=n+1,r[i][j]=0;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\t/*\n\tfor1(1,n,i) {\n\t\tfor1(1,n,j) cout<<f[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\t*/\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,g[505][505],s[505][505],mx[505];\nbool e[505][505];\nLL res;\nint readchar(){\n\tchar c=getchar();\n\twhile(c==' ' || c=='\\n') c=getchar();\n\tif(c=='#') return 0;\n\treturn c-'0';\n}\nnamespace DSU{\n\tint fa[250005],rk[250005];\n\tvoid init(){\n\t\tint i;\n\t\tmemset(rk,0,sizeof(rk));\n\t\tfor(i=0;i<=n*n;++i) fa[i]=i;\n\t}\n\tint ancestor(int x){\n\t\tif(fa[x]!=x) fa[x]=ancestor(fa[x]);\n\t\treturn fa[x];\n\t}\n\tvoid unite(int u,int v){\n\t\tu=ancestor(u);\n\t\tv=ancestor(v);\n\t\tif(rk[u]<rk[v])\n\t\t\tfa[u]=v;\n\t\telse if(rk[u]>rk[v])\n\t\t\tfa[v]=u;\n\t\telse{\n\t\t\tfa[u]=v;\n\t\t\t++rk[v];\n\t\t}\n\t}\n\tbool con(int u,int v){\n\t\treturn 1;\n\t\treturn ancestor(u)==ancestor(v);\n\t}\n};\nvoid add(int x,int y){\n\te[x][y]=1;\n\tif(e[x-1][y]) DSU::unite(x*n+y,(x-1)*n+y);\n\tif(e[x][y-1]) DSU::unite(x*n+y-1,x*n+y);\n\tif(e[x+1][y]) DSU::unite(x*n+y,(x+1)*n+y);\n\tif(e[x][y+1]) DSU::unite(x*n+y+1,x*n+y);\n\tif(x<n-1 && g[x+1][y] && !e[x+1][y]) add(x+1,y);\n\tif(y<n-1 && g[x][y+1] && !e[x][y+1]) add(x,y+1);\n}\nint getlower(int x,int y){\n\tint cx=x,cy=y,ret=(y?s[x][y-1]:0);\n\tmx[y]=x;\n\twhile(1){\n\t\twhile(1){\n\t\t\tif(cx+1<n && e[cx+1][cy]){\n\t\t\t\t++cx;\n\t\t\t\tmx[y]=cx;\n\t\t\t\tret+=(cy?s[cx][cy-1]:0);\n\t\t\t}\n\t\t\telse if(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cy+1<n){\n\t\t\t++cy;\n\t\t\tif(e[cx][cy] && DSU::con(cx*n+cy,x*n+y)){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(e[cx][cy]) break;\n\t\t}\n\t\tif(!found) break;\n\t}\n\treturn ret;\n}\nint getupper(int x,int y){\n\tint cx=x,cy=y,ret=0;\n\twhile(1){\n\t\twhile(1){\n\t\t\tif(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse if(cx+1<n && e[cx+1][cy]){\n\t\t\t\tret+=s[cx][cy];\n\t\t\t\t++cx;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cx<n-1){\n\t\t\tret+=s[cx][cy];\n\t\t\t++cx;\n\t\t\tif(cx>mx[y]) break;\n\t\t\tif(e[cx][cy] && DSU::con(cx*n+cy,x*n+y)){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(e[cx][cy]) break;\n\t\t}\n\t\tif(!found || cx>mx[y]) break;\n\t}\n\tif(cx<=mx[y]) ret+=s[cx][cy];\n\treturn ret;\n}\nvoid solveline(int x){\n\tint i,j,k;\n\tmemcpy(s,g,sizeof(g));\n\tfor(i=0;i<n;++i){\n\t\tfor(j=1;j<n;++j){\n\t\t\ts[i][j]+=s[i][j-1];\n\t\t}\n\t}\n\tDSU::init();\n\tfor(i=x;i<n;++i) memset(e[i],0,sizeof(e[i]));\n\tfor(i=0;i<n;++i){\n\t\tif(!g[x][i]) continue;\n\t\tadd(x,i);\n\t\tres-=(LL)g[x][i]*(LL)getlower(x,i);\n\t}\n\tDSU::init();\n\tfor(i=x;i<n;++i) memset(e[i],0,sizeof(e[i]));\n\tfor(i=n-1;i>=0;--i){\n\t\tif(!g[x][i]) continue;\n\t\tadd(x,i);\n\t\tres+=(LL)g[x][i]*(LL)(getupper(x,i)-g[x][i]);\n\t}\n}\nvoid del(int x,int y){\n\tif((!x || !g[x-1][y]) && (!y || !g[x][y-1])){\n\t\tg[x][y]=0;\n\t\tif(x<n-1 && g[x+1][y]) del(x+1,y);\n\t\tif(y<n-1 && g[x][y+1]) del(x,y+1);\n\t}\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\tg[i][j]=readchar();\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\te[i][j]=(!!g[i][j]);\n\t\t}\n\t}\n    for(i=n-1;i>=0;--i){\n\t\tsolveline(i);\n\t\tfor(j=0;j<n;++j){\n\t\t\tif(g[i][j]) del(i,j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<string> board;\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    board.push_back(s);\n  }\n\n  vector<vector<set<int>>> memo;\n  for (int i = 0; i < n; i++) {\n    vector<set<int>> row;\n    for (int j = 0; j < n; j++) {\n      set<int> s;\n      row.push_back(s);\n    }\n    memo.push_back(row);\n  }\n\n  for (int i = n-1; i >= 0; i--) {\n    for (int j = n-1; j >= 0; j--) {\n      set<int> empty;\n      if (board[i][j] == '#') {\n        memo[i][j] = empty;\n      } else {\n        set<int> r,d;\n        if (j == n-1) {\n          r = empty;\n        } else {\n          r = memo[i][j+1];\n          if (board[i][j+1] != '#') {\n            r.insert(i*n+(j+1));\n          }\n        }\n        if (i == n-1) {\n          d = empty;\n        } else {\n          d = memo[i+1][j];\n          if (board[i+1][j] != '#') {\n            d.insert((i+1)*n+j);\n          }\n        }\n\n        for (auto i : d) {\n          r.insert(i);\n        }\n        memo[i][j] = r;\n      }\n    }\n  }\n\n  long long int result = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      int sum = 0;\n      for (auto p : memo[i][j]) {\n        sum += board[p/n][p%n] - '0';\n      }\n      result += (board[i][j]-'0') * sum;\n    }\n  }\n\n  cout << result << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[N][N],r[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;i++)scanf(\"%s\",A[i]+1);\n\tfor (register int i=0;i<=n;i++)\n\t\tfor (register int j=0;j<=n;j++)u[i][j]=A[i][j]>='0'&&A[i][j]<='9'?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;x++)\n\t\tfor (register int i=x;i;i--){\n\t\t\tfor (register int j=1;j<=n;j++)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (register int j=n+1;j;j--){\n\t\t\t\tif (A[i][j]>='0'&&A[i][j]<='9'){\n\t\t\t\t\tif (i<x){\n\t\t\t\t\t\tl[i][j]=min(l[i][j+1],l[i+1][j]);\n\t\t\t\t\t\tr[i][j]=max(r[i][j+1],r[i+1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse l[i][j]=j,r[i][j]=j;\n\t\t\t\t\tif (l[i][j]<=r[i][j])ans+=(A[i][j]-'0')*(S[r[i][j]]-S[l[i][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t\t}\n\t\t\t\telse l[i][j]=1e9,r[i][j]=-1;\n\t\t\t}\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v){\n\t    wek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trep(x,10) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+5);\n\t\t\t\tif(x) rep(w,10) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trep(w,10) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(w,10) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_map>\n#include <bitset>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1505;\nconst ull H = 2342311;\n\nint brred, brstup;\nint p[2][MAX][MAX];\n\nll sum_sq(int r, int s1, int s2, int st) {\n  ll ret=0;\n  FOR(j, s1, s2+1)\n    ret += p[st][r][j] * p[st][r][j];\n  return ret;\n}\n\nll calc_single(int r, int s1, int s2, int st) {\n  ll sum=0, ret=0;\n  FOR(j, s1, s2+1) {\n    if (!p[st][r][j]) {\n      sum = 0;\n      continue;\n    }\n\n    ret += p[st][r][j] * sum;\n    sum += p[st][r][j];\n  }\n\n  return ret;\n}\n\null Bgor[MAX][MAX][MAX/64+1], Bdol[MAX][MAX][MAX/64+1];\nint SZ;\n\nvoid reset(ull B[MAX][MAX][MAX/64+1], int r1, int r2, int s1, int s2) {\n  FOR(i, r1, r2+1) FOR(j, s1, s2+1) REP(k, SZ)\n    B[i][j][k] = 0;\n}\n\nvoid andaj(ull a[], ull b[], ull c[]) {\n  REP(i, SZ) c[i] = a[i] & b[i];\n}\n\nvoid oraj(ull a[], ull b[], ull c[]) {\n  REP(i, SZ) c[i] = a[i] | b[i];\n}\n\nvoid kopiraj(ull a[], ull b[]) {\n  REP(i, SZ) b[i] = a[i];\n}\n\nvoid stavi(ull a[], int ind) {\n  a[ind/64] |= ((ull) 1) << (ind % 64);\n}\n\nbool notempty(ull a[]) {\n  REP(i, SZ) if (a[i]) return true;\n  return false;\n}\n\null get_h(ull a[]) {\n  ull r=0;\n  REP(i, SZ) r = r*H + a[i];\n  return r;\n}\n\nvoid go_down(int r1, int r2, int s1, int s2, int st) {\n  reset(Bgor, r1, r2, s1, s2);\n\n  for (int i=r2; i>=r1; i--) {\n    for (int j=s2; j>=s1; j--) {\n      if (!p[st][i][j]) continue;\n      if (i != r2 && j != s2) oraj(Bgor[i+1][j], Bgor[i][j+1], Bgor[i][j]);\n      else if (i != r2) kopiraj(Bgor[i+1][j], Bgor[i][j]);\n      else if (j != s2) kopiraj(Bgor[i][j+1], Bgor[i][j]);\n\n      if (i == r2) stavi(Bgor[i][j], j-s1);\n    }\n  }\n}\n\nvoid go_up(int r1, int r2, int s1, int s2, int st) {\n  reset(Bdol, r1, r2, s1, s2);\n\n  FOR(i, r1, r2+1) {\n    FOR(j, s1, s2+1) {\n      if (!p[st][i][j]) continue;\n      if (i != r1 && j != s1) oraj(Bdol[i-1][j], Bdol[i][j-1], Bdol[i][j]);\n      else if (i != r1) kopiraj(Bdol[i-1][j], Bdol[i][j]);\n      else if (j != s1) kopiraj(Bdol[i][j-1], Bdol[i][j]);\n\n      if (i == r1) stavi(Bdol[i][j], j-s1);\n    }\n  }\n}\n\null tmp[MAX/64+1];\nll spoji(int r1, int mid, int r2, int s1, int s2, int st) {\n  unordered_map <ull, ll> Sum_dol, Sum_gor;\n  unordered_map <ull, P> Pred_dol, Pred_gor;\n\n  FOR(i, r1, mid+1) {\n    FOR(j, s1, s2+1) {\n      ull h = get_h(Bgor[i][j]);\n      Pred_gor[h] = P(i, j);\n      Sum_gor[h] += p[st][i][j];\n    }\n  }\n\n  FOR(i, mid, r2+1) {\n    FOR(j, s1, s2+1) {\n      ull h = get_h(Bdol[i][j]);\n      Pred_dol[h] = P(i, j);\n      Sum_dol[h] += p[st][i][j];\n    }\n  }\n\n  ll ret=0;\n  for (auto gor = Pred_gor.begin(); gor != Pred_gor.end(); gor++) {\n    for (auto dol = Pred_dol.begin(); dol != Pred_dol.end(); dol++) {\n      andaj(Bgor[gor->Y.X][gor->Y.Y], Bdol[dol->Y.X][dol->Y.Y], tmp);\n      if (notempty(tmp))\n        ret += Sum_gor[gor->X] * Sum_dol[dol->X];\n    }\n  }\n\n  return ret;\n}\n\nll calc(int r1, int r2, int s1, int s2, int st) {\n  if (r1 > r2 || s1 > s2) return 0;\n  if (r2-r1 < s2-s1)\n    return calc(s1, s2, r1, r2, 1^st);\n\n  if (r1 == r2)\n    return calc_single(r1, s1, s2, st);\n\n  int mid = (r1 + r2) / 2;\n  SZ = (s2 - s1 + 64) / 64;\n\n  go_down(r1, mid, s1, s2, st);\n  go_up(mid, r2, s1, s2, st);\n\n  ll ret = spoji(r1, mid, r2, s1, s2, st);\n\n  ret -= sum_sq(mid, s1, s2, st);\n\n  ret += calc(r1, mid-1, s1, s2, st);\n  ret += calc(mid+1, r2, s1, s2, st);\n\n  return ret;\n}\n\nchar s[MAX][MAX];\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n\n  REP(i, n) {\n    scanf(\" %s\", s[i]);\n    REP(j, n)\n      p[0][i][j] = p[1][j][i] = (s[i][j] == '#' ? 0 : (int) (s[i][j] - '0'));\n  }\n\n  printf(\"%lld\\n\", calc(0, n-1, 0, n-1, 0));\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar a[M][M];\nint f[M][M],l[M][M],r[M][M];\n\nint main () {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) scanf(\"%s\",a[i]+1);\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) \n\t\tif(isdigit(a[i][j])) {\n\t\t\tbool t[2]={isdigit(a[i+1][j]),isdigit(a[i][j+1])};\n\t\t\tif(!t[0]&&!t[1]) {\n\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\t\tfor1(i+1,n,k) l[j][k]=n+1,r[j][k]=0;\n\t\t\t}\n\t\t\telse if(!t[0]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[j][i]=j,r[j][i]=r[j+1][i];\n\t\t\t\tfor1(i+1,n,k) l[j][k]=l[j+1][k],r[j][k]=r[j+1][k];\n\t\t\t}\n\t\t\telse if(!t[1]) {\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint las=0;\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[j][i]=j,r[j][i]=r[j+1][i];\n\t\t\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[j+1][k]<=r[j][k]&&l[j+1][k]>las) tot-=f[k][l[j+1][k]];\n\t\t\t\t\tlas=max(las,r[j][k]);\n\t\t\t\t\tl[j][k]=min(l[j][k],l[j+1][k]);\n\t\t\t\t\tr[j][k]=max(r[j][k],r[j+1][k]); \n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t\tans+=f[i][j]*(a[i][j]-'0');\n\t\t\tf[i][j]+=a[i][j]-'0';\n\t\t}\n\t\telse l[j][i]=n+1,r[j][i]=0;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nbool CanReach(const std::vector<std::vector<char>>& board, int x1, int y1, int x2, int y2) {\n\tif (x1 > x2||y1 > y2)return false;\n\tif (x1 == x2 && y1 == y2)return true;\n\tif (board[y1][x1] == '#')return false;\n\tif (!CanReach(board, x1 + 1, y1, x2, y2))return CanReach(board, x1, y1 + 1, x2, y2);\n\treturn true;\n}\n\nint main() {\n\n\tint N;\n\tstd::cin >> N;\n\tstd::vector<std::vector<char>> board(N, std::vector<char>(N));\n\tfor (auto&v : board) {\n\t\tgetchar();\n\t\tfor (auto&w : v)w = getchar();\n\t}\n\tint sum = 0;\n\tfor (int x = 0; x < N; ++x) {\n\t\tfor (int y = 0; y < N; ++y) {\n\t\t\tfor (int x2 = x, y2 = y + 1; x2 < N; ++x2, y2 = 0) {\n\t\t\t\tfor (; y2 < N; ++y2) {\n\t\t\t\t\tif (board[y2][x2]!='#'&&CanReach(board, x, y, x2, y2)) {\n\t\t\t\t\t\tsum += (board[y][x] - '0')*(board[y2][x2] - '0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << sum << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar a[M][M];\nint f[M][M],l[M][M],r[M][M];\n\nint main () {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) scanf(\"%s\",a[i]+1);\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) \n\t\tif(isdigit(a[i][j])) {\n\t\t\tbool t[2]={isdigit(a[i+1][j]),isdigit(a[i][j+1])};\n\t\t\tif(!t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(!t[0]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse if(!t[1]) {\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint las=0;\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las) tot-=f[k][l[k][j+1]];\n\t\t\t\t\tlas=max(las,r[k][j]);\n\t\t\t\t\tl[k][j]=min(l[k][j],l[k][j+1]);\n\t\t\t\t\tr[k][j]=max(r[k][j],r[k][j+1]); \n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t\tans+=f[i][j]*(a[i][j]-'0');\n\t\t\tf[i][j]+=a[i][j]-'0';\n\t\t}\n\t\telse l[i][j]=n+1,r[i][j]=0;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[2][N],r[2][N],flag[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int i=x;i;--i){\n\t\t\tint t=i&1;\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tif (i<x){\n\t\t\t\t\t\tl[t][j]=min(l[t][j+1],l[t^1][j]);\n\t\t\t\t\t\tr[t][j]=max(r[t][j+1],r[t^1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse l[t][j]=j,r[t][j]=max(j,r[t][j+1]);\n\t\t\t\t\tif (l[t][j]<=r[t][j])ans+=(A[i][j]-'0')*(S[r[t][j]]-S[l[t][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t\t}\n\t\t\t\telse l[t][j]=1e9,r[t][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nusing bn=bitset<nax*nax>;\nconst int d=63;\n\nint n;\n\nstruct bity\n{\n\tvll wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n\nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nchar wcz[nax];\nint tab[nax][nax];\n\nbity oso[nax][10];\n\nll wyn;\n\nint ile[nax];\nint num[nax][nax];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%s\", wcz+1);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (wcz[j]=='#')\n\t\t\t{\n\t\t\t\ttab[i][j]=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttab[i][j]=wcz[j]-'0';\n\t\t\t\tile[tab[i][j]]++;\n\t\t\t\tnum[i][j]=ile[tab[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=9; j++)\n\t\t\toso[i][j]=bity(ile[j]);\n\tfor (int i=n; i; i--)\n\t{\n\t\tfor (int j=n; j; j--)\n\t\t{\n\t\t\tif (tab[i][j]==-1)\n\t\t\t{\n\t\t\t\tfor (int l=1; l<=9; l++)\n\t\t\t\t\toso[j][l].zeruj();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int l=1; l<10; l++)\n\t\t\t\toruj(oso[j][l], oso[j+1][l]);\n\t\t\t//~ oso[j]|=oso[j+1];\n\t\t\tfor (int l=1; l<10; l++)\n\t\t\t{\n\t\t\t\t//~ if (oso[j][l].licz())\n\t\t\t\t\t//~ debug() << i << \" \" << j << \" to \" << l << \" \" << oso[j][l].licz();\n\t\t\t\twyn+=l*tab[i][j]*oso[j][l].licz();\n\t\t\t}\n\t\t\t//~ oso[j][num(i, j)]=1;\n\t\t\toso[j][tab[i][j]].ustaw(num[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint vy[4] = { 1, 0, -1, 0 };\nint vx[4] = { 0, 1, 0, -1 };\n\nvector<string> board;\n\nint N;\n\nbool inside(int y, int x)\n{\n\treturn y >= 0 && x >= 0 && y < N && x < N;\n}\n\n\n\nint main() {\n\tcin >> N;\n\n\tvector<string> board(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> board[i];\n\t}\n\t\n\tvector<vector<int>> numBoard(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\n\t\t\t//if (rand() % 5 == 0) numBoard[i][j] == -1;\n\t\t\t//else numBoard[i][j] = 1;\n\t\t\tif (board[i][j] == '#') numBoard[i][j] = -1;\n\t\t\telse numBoard[i][j] = (int)(board[i][j] - '0');\n\t\t}\n\t}\n\n\tvector<vector<int>> maxLen(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (numBoard[sy][sx] == -1) continue;\n\t\t\tmaxLen[sy][sx] = 1;\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = sy + vy[k];\n\t\t\t\tint nx = sx + vx[k];\n\t\t\t\tif (inside(ny, nx) && maxLen[ny][nx] >= 1) {\n\t\t\t\t\tmaxLen[sy][sx] = max(maxLen[sy][sx], maxLen[ny][nx] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<int> q;\n\tvector<vector<int>> startUsed(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\n\tvector<vector<int>> used(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint myTurn = 1;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1 && maxLen[sy][sx] > 3)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 2; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t\tmyTurn++;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcerr << \"reset \"  << (q.size() - N * N) << endl;\n\n\n\n\tlong ans = 0;\n\tlong nowSum = 0;\n\n\tmyTurn++;\n\n\twhile (!q.empty())\n\t{\n\t\tint start = q.front(); q.pop();\n\n\t\tif (start == -1)\n\t\t{\n\t\t\tmyTurn++;\n\t\t\tnowSum = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<int> q2;\n\t\tint sy = start >> 12;\n\t\tint sx = start & 0xFFF;\n\t\tused[sy][sx] = myTurn;\n\t\tq2.push(start);\n\n\n\t\twhile (!q2.empty())\n\t\t{\n\t\t\tint now = q2.front(); q2.pop();\n\t\t\tint y = now >> 12;\n\t\t\tint x = now & 0xFFF;\n\t\t\tnowSum += numBoard[y][x];\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t{\n\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tans += numBoard[sy][sx] * nowSum;\n\t}\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (numBoard[i][j] != -1) ans -= numBoard[i][j] * numBoard[i][j];\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nusing bn=bitset<nax*nax>;\n\nint n;\n\nbn pus;\nbn oso[nax];\nbn lezy[10];\n\nchar wcz[nax];\nint tab[nax][nax];\n\nint num(int a, int b)\n{\n\treturn (a-1)*n+b-1;\n}\n\nll wyn;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%s\", wcz+1);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (wcz[j]=='#')\n\t\t\t{\n\t\t\t\ttab[i][j]=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttab[i][j]=wcz[j]-'0';\n\t\t\t\tlezy[tab[i][j]][num(i, j)]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n; i; i--)\n\t{\n\t\tfor (int j=n; j; j--)\n\t\t{\n\t\t\tif (tab[i][j]==-1)\n\t\t\t{\n\t\t\t\toso[j]=pus;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toso[j]|=oso[j+1];\n\t\t\tfor (int l=1; l<=9; l++)\n\t\t\t\twyn+=l*tab[i][j]*(oso[j]&lezy[l]).count();\n\t\t\toso[j][num(i, j)]=1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n//#include <bits/stdc++.h>\n#include <stack>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <stack>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef int LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nlong long ans = 0;\nlong long sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE];\nint val[SIZE][SIZE];\nLL times = 0,times2=0;\ninline LL dfs(int y, int x) {\n//\ttimes++;\n\tif (y > N or x > N or A[y][x] == 0 or reached[y][x]) return 0;\n\treached[y][x] = true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs252(int yy, int xx) {\n\tstack<pr> st;\n\tst.emplace(yy, xx);\n\tint ret = 0;\n\twhile (!st.empty()) {\n\t\tint y=st.top().first, x=st.top().second;\n\t\tif (val[y][x] == 0) {\n\t\t\tval[y][x] = -1;\n\t\t\treached[y][x] = 0;\n\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) st.emplace(y, x+1);\n\t\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) st.emplace(y + 1, x);\n\t\t}\n\t\telse {\n\t\t\tval[y][x] = val[y][x + 1] + val[y + 1][x];\n//\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) ret+=val[y][x + 1];\n\t//\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) ret+=val[y][x+1];\n\t\t\tst.pop();\n\t\t}\n\t}\n//\treached[y][x] = 0;\n//\treturn  (( ? dfs2(y, x + 1) : 0) + ( : 0) + A[y][x]);\n\treturn val[yy][xx];\n\n}\n\ninline LL dfs2(int y, int x) {\n\t//times++;\n\treached[y][x] = 0;\n\treturn  (((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0) ? dfs2(y, x + 1) : 0 )+ ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x]) ? dfs2(y + 1, x) : 0) + A[y][x]);\n}\nlong long solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i, 1, N) {\n\t\t//cout << \"A\";\n\t\tsum += dfs(x, i);\n\t\t//cout << \"B\";\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tsum -= A[x][i];\n\t\tans += (long long)sum* (long long)A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tif (A[x + 1][i] == 0) continue;\n\t\tif (reached[x + 1][i] == 0) continue;\n\t\tif (reached[x][i]) continue;\n\n\t\tsum -= dfs2(x + 1, i);\n\t//\tcout << \"C\" << endl;\n\n\t}\n//\tcout << times << \" \" << times2 << endl;\n\treturn ans;\n}\nlong long solve() {\n\tcin >> N;\n\tEFOR(i, 1, N) {\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1] - '0';\n\t\t}\n\t}\n//\tN = 300;\n//\tEFOR(i, 1, N) EFOR(j, 1, N) A[i][j] = 9;\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// doot diddly donger cuckerino Hahahahahah\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int LL;\ntypedef unsigned int UINT;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PII;\ntypedef pair<string, int> PSI;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef vector<bool> VB;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef tuple<int, int, int> TPL;\ntypedef priority_queue<int> pqueue;\ntypedef priority_queue<int, VI, greater<int>> pdqueue;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, 1, 0, -1, -1, 1, -1, 1};\nconst int dxhorse[] = {-2, -2, -1, -1, 1, 1, 2, 2};\nconst int dyhorse[] = {1, -1, 2, -2, 2, -2, 1, -1};\n\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define endl \"\\n\"\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define F first\n#define S second\n#define SZ(x)           (x).size()\n#define MAX(a, b)      ((a)>(b)?(a):(b))\n#define MIN(a, b)      ((a)<(b)?(a):(b))\n#define ALL(a)         std::begin(a), std::end(a)\n#define Fill(n, x)      memset(n,x,sizeof n);\n#define IN_REP         int _t; cin >> _t ; while(_t--)\n#define IOS            ios::sync_with_stdio(false);cin.tie(NULL)\n#define FOR(i, a, b)    for(int i=(a);i<(b);i++)\n#define REP(i, n)       FOR(i,0,n)\n#define FORR(i, n)      for(int i=(n);i>=0;i--)\n#define EPS (double) 1e-9\n#define MOD (1000*1000*1000 + 7)\n#define INF 1011111111\n#define LLINF 1000111000111000111LL\nint n;\nVS c;\nVVI a;\nmap<PII, VPII> mp;\n\nbool reachable(int x1, int y1, int x2, int y2) {\n    if (x2 < x1 || y2 < y1 || x1 < 0 || x2 < 0 || y1 >= n || y2 >= n || x1 >= n || x2 >= n || y1 < 0 || y2 < 0) {\n        return false;\n    }\n    if (c[x1][y1] == '#') return false;\n    if (x1 == x2 && y1 == y2)return true;\n    return reachable(x1 + 1, y1, x2, y2) || reachable(x1, y1 + 1, x2, y2);\n}\n\nvoid pre() {\n    IOS;\n//    freopen(\"/home/whiteknife/Workspace/CLionProjects/untitled/in\", \"r\", stdin);\n    cin >> n;\n    a.resize(n, VI(n, 0));\n    c.resize(n);\n//    v.resize(n, VB(n, false));\n    REP(i, n)cin >> c[i];\n    REP(i, n)REP(j, n)if (c[i][j] != '#') a[i][j] = (c[i][j] - '0');\n    FOR(i, 1, n) {\n        FOR(j, 1, n) {\n            vector<VB> v(n, VB(n, false));\n            if (c[i][j] == '#') {\n                v[i][j] = false;\n                continue;\n            }\n            if (!v[i][j]) {\n                FOR(k, i, n) {\n                    FOR(l, j, n) {\n                        if ((i == k && j == l) || v[k][l]) continue;\n                        if (c[k][l] == '#') {\n                            v[k][l] = false;\n                        } else {\n                            v[k][l] = true;\n                            mp[MP(i, j)].PB(MP(k, l));\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    pre();\n    LL ans = 0;\n    REP(i, n) {\n        REP(j, n) {\n            if (c[i][j] == '#')continue;\n            FOR(k, i, n) {\n                FOR(l, j, n) {\n                    if (i == k && j == l)continue;\n                    if (find(ALL(mp[MP(i, j)]), MP(k, l)) != mp[MP(i, j)].end()) ans += a[i][j] * a[k][l];\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"-O3\",\"-funroll-all-loops\")\n#pragma GCC target(\"avx\",\"tune=native\",\"sse4\",\"sse\")\n#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nint n,c=0,T=0;\nchar a[505][505];\npii u[2][505][505];\ninline pii operator + (pii a,pii b)\n{return pii(min(a.fi,b.fi),max(a.se,b.se));}\nint vis[505][505];\ninline void dfs(int x,int y)\n{\n\tif(vis[x][y]==T||!isdigit(a[x][y]))\n\t\treturn;\n\tvis[x][y]=T; dfs(x,y+1); dfs(x+1,y);\n}\nint su[505][505];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tll aa=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%s\",a[i]+1);\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(isdigit(a[i][j]))\n\t\t\t{\n\t\t\t\tint u=a[i][j]-'0';\n\t\t\t\taa-=u*u;\n\t\t\t}\n\t\t}\n\t}\n\tpii GG(2e9,-2e9);\n\tfor(int i=0;i<=n+1;++i)\n\tfor(int j=0;j<=n+1;++j)\n\t\tu[0][i][j]=u[1][j][i]=GG;\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tT=i; c^=1;\n\t\tfor(int j=1;j<=n;++j) dfs(i,j);\n\t\tfor(int k=i;k<=n;++k)\n\t\t\tfor(int w=1;w<=n;++w)\n\t\t\t\tif(vis[k][w]==T)\n\t\t\t\t\tsu[k][w]=su[k][w-1]+a[k][w]-'0';\n\t\t\t\telse su[k][w]=su[k][w-1];\n\t\tfor(int j=n;j>=1;--j)\n\t\t{\n\t\t\tpii*ucj=u[c][j],*ucp=u[c][j+1],*rcj=u[c^1][j];\n\t\t\tif(!isdigit(a[i][j]))\n\t\t\t{\n\t\t\t\tfor(int k=i;k<=n;++k)\n\t\t\t\t\tucj[k]=GG;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tucj[i]=pii(j,j)+ucp[i];\n\t\t\tll ap=0;\n\t\t\tif(ucj[i].fi<=ucj[i].se)\n\t\t\t\tap+=su[i][ucj[i].se]-su[i][ucj[i].fi-1];\n\t\t\tfor(int k=i+1;k<=n;++k)\n\t\t\t{\n\t\t\t\tucj[k]=rcj[k]+ucp[k];\n\t\t\t\tif(ucj[k].fi<=ucj[k].se)\n\t\t\t\tap+=su[k][ucj[k].se]-su[k][ucj[k].fi-1];\n\t\t\t}\n\t\t\taa+=ap*(a[i][j]-'0');\n\t\t}\n\t}\n\tcout<<aa<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trep(x,10) rep(i,n) B[x][i] = bity(C[x]+5);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t\tif(x) rep(w,10) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trep(w,10) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(w,10) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include <bits/stdc++.h>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef int LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nLL ans = 0;\nLL sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE]; \nLL dfs(int y,int x) {\n\tif (y > N or x > N or A[y][x] == 0 or reached[y][x]) return 0;\n\treached[y][x]=true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs2(int y, int x) {\n//\tcout << y << \" \" << x << endl;\n\n\t//cout << y << \" \" << x << endl;\n\treached[y][x] = 0;\n\tLL ret = 0;\n\tif(x+1<=N and A[y][x+1] and reached[y][x+1] and reached[y-1][x+1]==0)\n\tret += dfs2(y, x + 1);\n\tif(y+1<=N and A[y+1][x] and reached[y+1][x])\n\tret += dfs2(y + 1, x);\n\n\treturn ret + A[y][x];\n}\nLL solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i,1, N) {\n\t\tsum+=dfs(x, i);\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tans +=( sum - A[x][i] )* A[x][i];\n\t\t//cout << ans << endl;\n\t\tsum -= A[x][i];\n\t\treached[x][i] = false;\n\t\tif (A[x+1][i] == 0) continue;\n\t\tif (reached[x+1][i] == 0) continue;\n\t\tif (reached[x][i]) continue;\n\t\tsum-=dfs2(x+1, i);\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N;\n\tEFOR(i,1,N){\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1]-'0';\n\t\t}\n\t}\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace whatever{\n\tint readu(){\n\t\tchar ch=getchar();\n\t\twhile(!isdigit(ch))\n\t\t\tch=getchar();\n\t\tint value=ch-'0';\n\t\tch=getchar();\n\t\twhile(isdigit(ch)){\n\t\t\tvalue=value*10+ch-'0';\n\t\t\tch=getchar();\n\t\t}\n\t\treturn value;\n\t}\n\tvoid writeull(long long n){\n\t\tif(n<10)\n\t\t\tputchar(n+'0');\n\t\telse{\n\t\t\twriteull(n/10);\n\t\t\tputchar(n%10+'0');\n\t\t}\n\t}\n\tstruct set_type{\n\t\tunsigned long long *data;\n\t\tint size;\n\t\tvoid clear(){\n\t\t\tmemset(data, 0, sizeof(unsigned long long)*size);\n\t\t}\n\t\tvoid resize(int k){\n\t\t\tsize=(k+63)/64;\n\t\t\tsize=(size+3)/4*4;\n\t\t\tdata=new unsigned long long [size];\n\t\t\tclear();\n\t\t}\n\t\tvoid operator=(const set_type &b){\n\t\t\tassert(size%4==0);\n\t\t\tassert(size==b.size);\n\t\t\tmemcpy(data, b.data, sizeof(unsigned long long)*size);\n\t\t}\n\t\tvoid operator|=(const set_type &b){\n\t\t\tassert(size%4==0);\n\t\t\tassert(size==b.size);\n\t\t\tfor(int i=0; i<size; i+=4){\n\t\t\t\tdata[i]|=b.data[i];\n\t\t\t\tdata[i+1]|=b.data[i+1];\n\t\t\t\tdata[i+2]|=b.data[i+2];\n\t\t\t\tdata[i+3]|=b.data[i+3];\n\t\t\t}\n\t\t}\n\t\tint count(){\n\t\t\tassert(size%4==0);\n\t\t\tint result=0;\n\t\t\tfor(int i=0; i<size; i+=4){\n\t\t\t\tresult+=__builtin_popcountll(data[i]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+1]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+2]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+3]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvoid set(unsigned index){\n\t\t\tassert(size%4==0);\n\t\t\tassert(index<size*64);\n\t\t\tdata[index/64]|=(1ull<<(index%64));\n\t\t}\n\t};\n\tvoid run(){\n\t\tint n=readu();\n\t\tstatic char a[500][502];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tgets(a[i]);\n\t\tstatic int cnt[10];\n\t\tstatic int index[500][500];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tif(a[i][j]!='#'){\n\t\t\t\t\tassert(isdigit(a[i][j]));\n\t\t\t\t\tindex[i][j]=cnt[a[i][j]-'0']++;\n\t\t\t\t}\n\t\tstatic set_type set_data[2][500][10];\n\t\tfor(int i=0; i<2; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tfor(int k=0; k<10; ++k)\n\t\t\t\t\tset_data[i][j][k].resize(cnt[k]);\n\t\tset_type (*cur_set_data)[10]=set_data[0];\n\t\tset_type (*next_set_data)[10]=set_data[1];\n\t\tlong long result=0;\n\t\tcerr<<\"clock(): \"<<clock()/double(CLOCKS_PER_SEC)<<endl;\n\t\tfor(int r=n-1; r>=0; --r){\n\t\t\tfor(int c=n-1; c>=0; --c){\n\t\t\t\tif(isdigit(a[r][c])){\n\t\t\t\t\tfor(int i=0; i<10; ++i){\n\t\t\t\t\t\tnext_set_data[c][i]=cur_set_data[c][i];\n\t\t\t\t\t\tif(c<n-1)\n\t\t\t\t\t\t\tnext_set_data[c][i]|=next_set_data[c+1][i];\n\t\t\t\t\t\tresult+=(long long)next_set_data[c][i].count()*i*(a[r][c]-'0');\n\t\t\t\t\t\tif(i==a[r][c]-'0')\n\t\t\t\t\t\t\tnext_set_data[c][i].set(index[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int i=0; i<10; ++i)\n\t\t\t\t\t\tnext_set_data[c][i].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur_set_data, next_set_data);\n\t\t}\n\t\tcerr<<\"clock(): \"<<clock()/double(CLOCKS_PER_SEC)<<endl;\n\t\twriteull(result);\n\t\tputchar('\\n');\n\t}\n}\nint main(){\n\twhatever::run();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdlib.h>\n#include <math.h>\nusing namespace std;\n\nint main (void){\n\tint n,i,j,a[1505][1505],s[1505][1505],d[1505][1505],x[1505][1505]={0},y[1505][1505]={0},sum=0;\n\tchar c[1501][1501];\n\tcin >> n;\n\tfor(i=1;i<=n;i++){\n\t\tcin >> c[i];\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(c[i][j]=='1') a[i][j+1]=1;\n\t\t\tif(c[i][j]=='2') a[i][j+1]=2;\n\t\t\tif(c[i][j]=='3') a[i][j+1]=3;\n\t\t\tif(c[i][j]=='4') a[i][j+1]=4;\n\t\t\tif(c[i][j]=='5') a[i][j+1]=5;\n\t\t\tif(c[i][j]=='6') a[i][j+1]=6;\n\t\t\tif(c[i][j]=='7') a[i][j+1]=7;\n\t\t\tif(c[i][j]=='8') a[i][j+1]=8;\n\t\t\tif(c[i][j]=='9') a[i][j+1]=9;\n\t\t\tif(c[i][j]=='#') a[i][j+1]=0;\n\t\t}\n\t\ta[i][n+1]=0;\n\t\ta[n+1][i]=0;\n\t}\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=n;j>=1;j--){\n\t\t\tif(a[i+1][j]!=0&&a[i][j+1]!=0){\n\t\t\t\tx[i][j]=i;\n\t\t\t\ty[i][j]=j;\n\t\t\t\td[i][j]=0;\n\t\t\t}\n\t\t\tif(a[i][j]==0){\n\t\t\t\ts[i][j]=0;\n\t\t\t\td[i][j]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(a[i+1][j]==0&&a[i][j+1]==0){\n\t\t\t\ts[i][j]=0;\n\t\t\t\td[i][j]=0;\n\t\t\t}\n\t\t\tif(a[i+1][j]!=0&&a[i][j+1]==0){\n\t\t\t\ts[i][j]=s[i+1][j]+a[i+1][j];\n\t\t\t\tif(x[i][j]==0){\n\t\t\t\t\tx[i][j]=x[i+1][j];\n\t\t\t\t\ty[i][j]=y[i+1][j];\n\t\t\t\t}\n\t\t\t\tif(x[i][j]==i+1&&y[i][j]==j){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t} else {\n\t\t\t\t\td[i][j]=d[i+1][j]+a[i+1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a[i+1][j]==0&&a[i][j+1]!=0){\n\t\t\t\ts[i][j]=s[i][j+1]+a[i][j+1];\n\t\t\t\tif(x[i][j]==0){\n\t\t\t\t\tx[i][j]=x[i][j+1];\n\t\t\t\t\ty[i][j]=y[i][j+1];\n\t\t\t\t}\n\t\t\t\tif(x[i][j]==i&&y[i][j]==j+1){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t} else {\n\t\t\t\t\td[i][j]=d[i][j+1]+a[i][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a[i+1][j]!=0&&a[i][j+1]!=0){\n\t\t\t\tif(x[i+1][j]==x[i][j+1]&&y[i+1][j]==y[i][j+1]){\n\t\t\t\t\ts[i][j]=d[i+1][j]+d[i][j+1]+a[i+1][j]+a[i][j+1]+a[x[i][j]][y[i][j]]+s[x[i][j]][y[i][j]];\n\t\t\t\t} else {\n\t\t\t\t\ts[i][j]=s[i+1][j]+s[i][j+1]+a[i+1][j]+a[i][j+1];\n\t\t\t\t} \n\t\t\t}\n\t\t\td[i][j]=0;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tsum+=a[i][j]*s[i][j];\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) if(a[i][j]) {\n\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\tif(!(t[0]|t[1])) {\n\t\t\tl[i][j]=r[i][j]=j;\n\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t}\n\t\telse if(t[0]&&!t[1]) {\n\t\t\tl[i][j]=r[i][j]=j;\n\t\t\tf[i][j]=f[i+1][j];\n\t\t}\n\t\telse if(!t[0]&&t[1]) {\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t}\n\t\telse {\n\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\n\t\t\tint las_r=0;\t\t\n\t\t\tfor1(i+1,n,k) {\n\t\t\t\tif(r[k][j]>=l[k][j+1]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]];\n\t\t\t\tif(!(l[k][j]+r[k][j])||l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t\tlas_r=max(las_r,r[k][j]);\n\t\t\t}\n\t\t\tf[i][j]=tot;\n\t\t}\n\t\t//cout<<i<<\" \"<<j<<\" \"<<f[i][j]<<endl;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nusing bn=bitset<nax*nax>;\nconst int d=63;\n\nint n;\n\nstruct bity\n{\n\tvll wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n\nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nchar wcz[nax];\nint tab[nax][nax];\n\nbity oso[nax][10];\n\nll wyn;\n\nint ile[nax];\nint num[nax][nax];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%s\", wcz+1);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (wcz[j]=='#')\n\t\t\t{\n\t\t\t\ttab[i][j]=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttab[i][j]=wcz[j]-'0';\n\t\t\t\tile[tab[i][j]]++;\n\t\t\t\tnum[i][j]=ile[tab[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=9; j++)\n\t\t\toso[i][j]=bity(ile[j]);\n\tfor (int i=n; i; i--)\n\t{\n\t\tfor (int j=n; j; j--)\n\t\t{\n\t\t\tif (tab[i][j]==-1)\n\t\t\t{\n\t\t\t\tfor (int l=1; l<=9; l++)\n\t\t\t\t\toso[j][l].zeruj();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int l=1; l<10; l++)\n\t\t\t\toruj(oso[j][l], oso[j+1][l]);\n\t\t\t//~ oso[j]|=oso[j+1];\n\t\t\tfor (int l=1; l<10; l++)\n\t\t\t{\n\t\t\t\t//~ if (oso[j][l].licz())\n\t\t\t\t\t//~ debug() << i << \" \" << j << \" to \" << l << \" \" << oso[j][l].licz();\n\t\t\t\twyn+=l*tab[i][j]*oso[j][l].licz();\n\t\t\t}\n\t\t\t//~ oso[j][num(i, j)]=1;\n\t\t\toso[j][tab[i][j]].ustaw(num[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint vy[4] = { 1, 0, -1, 0 };\nint vx[4] = { 0, 1, 0, -1 };\n\nvector<string> board;\n\nint N;\n\nbool inside(int y, int x)\n{\n\treturn y >= 0 && x >= 0 && y < N && x < N;\n}\n\n\n\nint main() {\n\tcin >> N;\n\n\tvector<string> board(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> board[i];\n\t}\n\t\n\tvector<vector<int>> numBoard(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint activeBlock = 0;\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\n\t\t\t//if (rand() % 5 == 0) numBoard[i][j] == -1;\n\t\t\t//else numBoard[i][j] = 1;\n\t\t\tif (board[i][j] == '#') numBoard[i][j] = -1;\n\t\t\telse {\n\t\t\t\tnumBoard[i][j] = (int)(board[i][j] - '0');\n\t\t\t\tactiveBlock++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int>> maxLen(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (numBoard[sy][sx] == -1) continue;\n\t\t\tmaxLen[sy][sx] = 1;\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = sy + vy[k];\n\t\t\t\tint nx = sx + vx[k];\n\t\t\t\tif (inside(ny, nx) && maxLen[ny][nx] >= 1) {\n\t\t\t\t\tmaxLen[sy][sx] = max(maxLen[sy][sx], maxLen[ny][nx] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<int> q;\n\tvector<vector<int>> startUsed(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\n\tvector<vector<int>> used(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint myTurn = 1;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1 && maxLen[sy][sx] > 0)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 3; k >= 2; k--)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t\tmyTurn++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcerr << \"reset \" << ((int)q.size() - activeBlock) << endl;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcerr << \"reset \"  << ((int)q.size() - activeBlock) << endl;\n\n\n\n\tlong ans = 0;\n\tlong nowSum = 0;\n\n\tmyTurn++;\n\tlong add = 0;\n\n\twhile (!q.empty())\n\t{\n\t\tint start = q.front(); q.pop();\n\n\t\tif (start == -1)\n\t\t{\n\t\t\tmyTurn++;\n\t\t\tnowSum = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<int> q2;\n\t\tint sy = start >> 12;\n\t\tint sx = start & 0xFFF;\n\t\tused[sy][sx] = myTurn;\n\t\tq2.push(start);\n\n\n\t\twhile (!q2.empty())\n\t\t{\n\t\t\tint now = q2.front(); q2.pop();\n\t\t\tint y = now >> 12;\n\t\t\tint x = now & 0xFFF;\n\t\t\tnowSum += numBoard[y][x];\n\t\t\tadd++;\n\n\t\t\tint ny = y + 1;\n\t\t\tint nx = x + 1;\n\n\t\t\tif (ny < N && numBoard[ny][x] != -1 && used[ny][x] != myTurn)\n\t\t\t{\n\t\t\t\tused[ny][x] = myTurn;\n\t\t\t\tq2.push((ny << 12) + x);\n\t\t\t}\n\n\t\t\tif (nx < N && numBoard[y][nx] != -1 && used[y][nx] != myTurn)\n\t\t\t{\n\t\t\t\tused[y][nx] = myTurn;\n\t\t\t\tq2.push((y << 12) + nx);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t{\n\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\n\t\tans += numBoard[sy][sx] * nowSum;\n\t}\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (numBoard[i][j] != -1) ans -= numBoard[i][j] * numBoard[i][j];\n\t\t}\n\t}\n\n\tcerr << add << endl;\n\n\tcout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbitset<250001> a[2][501][10];\n\nint main(int argc, char *argv[]) {\n  std::ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  long long ans = 0;\n  for (int i = 0, now = 0; i < n; i++, now ^= 1) {\n    for (int j = 1; j <= n; j++) {\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k].reset();\n      }\n    }\n    string s;\n    cin >> s;\n    for (int j = 1; j <= n; j++) {\n      if (s[j - 1] == '#') continue;\n      int v = s[j - 1] - '0';\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k] = (a[now][j - 1][k] | a[now ^ 1][j][k]);\n        ans += a[now][j][k].count() * k * v;\n      }\n      a[now][j][v].set(i * n + j - 1);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nchar f[505][505];\nbitset<500*500*9+5>B[505];\nll ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t\tif(x) B[x] |= B[x-1];\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].count());\n\t\t\t\trep(a,f[x][y]-'0') B[x][9*(x*n+y)+a] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].reset();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ===== 2018/10/13 23:28:52 =====\n\n// ../../../lib/template/includes.hpp\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n// ../../../lib/template/cin.cpp\n\ntemplate <typename T, int M, int N> struct tuple_getter {\n  static void get(std::istream &is, T &x) {\n    is >> std::get<M>(x);\n    tuple_getter<T, M + 1, N>::get(is, x);\n  }\n};\n\ntemplate <typename T, int N> struct tuple_getter<T, N, N> {\n  static void get(std::istream &is, T &x) { is >> std::get<N>(x); }\n};\n\ntemplate <typename... Args>\nstd::istream &operator>>(std::istream &is, std::tuple<Args...> &t) {\n  tuple_getter<std::tuple<Args...>, 0, sizeof...(Args) - 1>::get(is, t);\n  return is;\n}\n\ntemplate <typename T, typename U>\nstd::istream &operator>>(std::istream &is, std::pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate <typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &v) {\n  for (T &x : v) is >> x;\n  return is;\n}\n\n// ../../../lib/template/const_value.hpp\n\nnamespace sub {\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_integral<T>::value, T>::type\ninf_sub() {\n  return std::numeric_limits<T>::max() / 2 - 1000;\n}\n\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_floating_point<T>::value, T>::type\ninf_sub() {\n  return std::min(std::numeric_limits<T>::max() / 2 - 1000, T(1e50));\n}\n}  // namespace sub\n\ntemplate <typename T> constexpr T inf() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return sub::inf_sub<T>();\n}\n\ntemplate <typename T> constexpr T zero() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return T(0);\n}\n\nconst long double pi = acos(-1.0);\n\n// ../../../lib/template/cout.cpp\n\ntemplate <typename T, int M, int N> struct tuple_printer {\n  static void print(std::ostream &os, const T &x) {\n    os << std::get<M>(x) << \" \";\n    tuple_printer<T, M + 1, N>::print(os, x);\n  }\n};\n\ntemplate <typename T, int N> struct tuple_printer<T, N, N> {\n  static void print(std::ostream &os, const T &x) { os << std::get<N>(x); }\n};\n\ntemplate <typename... Args>\nstd::ostream &operator<<(std::ostream &os, const std::tuple<Args...> &t) {\n  tuple_printer<std::tuple<Args...>, 0, sizeof...(Args) - 1>::print(os, t);\n  return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \" \";\n    os << *it;\n  }\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::set<T> &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \" \";\n    os << *it;\n  }\n  return os;\n}\n\n// ../../../lib/template/initialize.cpp\n\nstruct yes_no : std::numpunct<char> {\n  string_type do_truename() const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\nstruct Initialize {\n  Initialize() {\n    std::locale loc(std::locale(), new yes_no);\n    std::cout << std::boolalpha << std::setprecision(11) << std::fixed;\n    std::cout.imbue(loc);\n  }\n};\n\nconst Initialize initialize;\n\n// ../../../lib/template/macros.hpp\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\n// ../../../lib/template/misc.hpp\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\n\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\n// ../../../lib/template/range.hpp\n\nclass range {\n  class index_type {\n    int x;\n\n  public:\n    index_type(int x_) : x(x_) {}\n    int operator*() const { return x; }\n    bool operator!=(index_type &r) { return x < r.x; }\n    void operator++() { ++x; }\n  };\n  index_type i, n;\n\npublic:\n  range(int n_) : i(0), n(n_) {}\n  range(int i_, int n_) : i(i_), n(n_) {}\n  index_type &begin() { return i; }\n  index_type &end() { return n; }\n};\n\n// ../../../lib/template/typedef.hpp\n\nusing ll = long long;\nusing ld = long double;\n\n// ../../../lib/template/template.cpp\n\nusing namespace std;\n\n// F.cpp\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nll dp1[512][512];\nint lef[512][512];\nint rig[512][512];\nll memo[512][512];\n\nint main() {\n  int N;\n  cin >> N;\n  vector<string> s(N);\n  REP(i,N) cin >> s[i];\n\n  REP(ii,N) {\n    vector<int> sum(N + 1);\n    REP(j,N) sum[j+1] = sum[j] + (s[ii][j] - '0');\n    for (int i = ii; i < N; ++i)\n      REP(j,N) {\n        lef[i][j] = 100000000;\n        rig[i][j] = -1000000;\n      }\n    {\n      const int i = ii;\n      REP(j,N) {\n        if (s[i][j] == '#') continue;\n        lef[i][j+1] = j;\n        rig[i+1][j] = j;\n      }\n    }\n    for (int i = ii; i < N; ++i) {\n      REP(j,N) {\n        if (s[i][j] == '#') continue;\n        if (j < N - 1) chmin(lef[i][j+1], lef[i][j]);\n        if (j < N - 1) chmax(rig[i][j+1], rig[i][j]);\n        if (i < N - 1) chmin(lef[i+1][j], lef[i][j]);\n        if (i < N - 1) chmax(rig[i+1][j], rig[i][j]);\n        if (i > 0 && j > 0 && s[i-1][j] != '#' && s[i][j-1] != '#' &&\n            lef[i-1][j] <= rig[i][j-1]) {\n          dp1[i][j] -= (sum[rig[i][j-1] + 1] - sum[lef[i-1][j]]);\n        }\n      }\n    }\n  }\n\n  ll res = 0;\n  REP(i,N) REP(j,N) {\n    if (s[i][j] == '#') continue;\n    res += dp1[i][j] * (s[i][j] - '0');\n    if (i < N - 1) dp1[i+1][j] += dp1[i][j] + (s[i][j] - '0');\n    if (j < N - 1) dp1[i][j+1] += dp1[i][j] + (s[i][j] - '0');\n  }\n  cout << res << endl;\n  return 0;\n}\n// ===== 2018/10/13 23:28:52 =====\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint vy[4] = { 1, 0, -1, 0 };\nint vx[4] = { 0, 1, 0, -1 };\n\nvector<string> board;\n\nint N;\n\nbool inside(int y, int x)\n{\n\treturn y >= 0 && x >= 0 && y < N && x < N;\n}\n\n\n\nint main() {\n\tcin >> N;\n\n\tvector<string> board(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> board[i];\n\t}\n\t\n\tvector<vector<int>> numBoard(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (board[i][j] == '#') numBoard[i][j] = -1;\n\t\t\telse numBoard[i][j] = (int)(board[i][j] - '0');\n\t\t}\n\t}\n\n\tqueue<int> q;\n\tvector<vector<int>> startUsed(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 2; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector<vector<int>> used(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tint myTurn = 1;\n\n\tlong ans = 0;\n\tlong nowSum = 0;\n\n\twhile (!q.empty())\n\t{\n\t\tint start = q.front(); q.pop();\n\n\t\tif (start == -1)\n\t\t{\n\t\t\tmyTurn++;\n\t\t\tnowSum = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<int> q2;\n\t\tint sy = start >> 12;\n\t\tint sx = start & 0xFFF;\n\t\tused[sy][sx] = myTurn;\n\t\tq2.push(start);\n\n\n\t\twhile (!q2.empty())\n\t\t{\n\t\t\tint now = q2.front(); q2.pop();\n\t\t\tint y = now >> 12;\n\t\t\tint x = now & 0xFFF;\n\t\t\tnowSum += numBoard[y][x];\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t{\n\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tans += numBoard[sy][sx] * nowSum;\n\t}\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (numBoard[i][j] != -1) ans -= numBoard[i][j] * numBoard[i][j];\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace whatever{\n\tint readu(){\n\t\tchar ch=getchar();\n\t\twhile(!isdigit(ch))\n\t\t\tch=getchar();\n\t\tint value=ch-'0';\n\t\tch=getchar();\n\t\twhile(isdigit(ch)){\n\t\t\tvalue=value*10+ch-'0';\n\t\t\tch=getchar();\n\t\t}\n\t\treturn value;\n\t}\n\tvoid writeull(long long n){\n\t\tif(n<10)\n\t\t\tputchar(n+'0');\n\t\telse{\n\t\t\twriteull(n/10);\n\t\t\tputchar(n%10+'0');\n\t\t}\n\t}\n\tstruct set_type{\n\t\tunsigned long long *data;\n\t\tint size;\n\t\tvoid clear(){\n\t\t\tmemset(data, 0, sizeof(unsigned long long)*size);\n\t\t}\n\t\tvoid resize(int k){\n\t\t\tsize=(k+63)/64;\n\t\t\tsize=(size+3)/4*4;\n\t\t\tdata=new unsigned long long [size];\n\t\t\tclear();\n\t\t}\n\t\tvoid operator=(const set_type &b){\n\t\t\tassert(size==b.size);\n\t\t\tmemcpy(data, b.data, sizeof(unsigned long long)*size);\n\t\t}\n\t\tvoid operator|=(const set_type &b){\n\t\t\tassert(size==b.size);\n\t\t\tfor(int i=0; i<size; i+=4){\n\t\t\t\tdata[i]|=b.data[i];\n\t\t\t\tdata[i+1]|=b.data[i+1];\n\t\t\t\tdata[i+2]|=b.data[i+2];\n\t\t\t\tdata[i+3]|=b.data[i+3];\n\t\t\t}\n\t\t}\n\t\tint count(){\n\t\t\tint result=0;\n\t\t\tfor(int i=0; i<size; i+=4){\n\t\t\t\tresult+=__builtin_popcountll(data[i]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+1]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+2]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+3]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvoid set(unsigned index){\n\t\t\tassert(index<size*64);\n\t\t\tdata[index/64]|=(1ull<<(index%64));\n\t\t}\n\t};\n\tvoid run(){\n\t\tint n=readu();\n\t\tstatic char a[500][502];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tgets(a[i]);\n\t\tstatic int cnt[10];\n\t\tstatic int index[500][500];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tif(a[i][j]!='#'){\n\t\t\t\t\tassert(isdigit(a[i][j]));\n\t\t\t\t\tindex[i][j]=cnt[a[i][j]-'0']++;\n\t\t\t\t}\n\t\tstatic set_type set_data[2][500][10];\n\t\tfor(int i=0; i<2; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tfor(int k=0; k<10; ++k)\n\t\t\t\t\tset_data[i][j][k].resize(cnt[k]);\n\t\tset_type (*cur_set_data)[10]=set_data[0];\n\t\tset_type (*next_set_data)[10]=set_data[1];\n\t\tlong long result=0;\n\t\tcerr<<\"clock(): \"<<clock()/double(CLOCKS_PER_SEC)<<endl;\n\t\tfor(int r=n-1; r>=0; --r){\n\t\t\tfor(int c=n-1; c>=0; --c){\n\t\t\t\tif(isdigit(a[r][c])){\n\t\t\t\t\tfor(int i=0; i<10; ++i){\n\t\t\t\t\t\t//next_set_data[c][i]=cur_set_data[c][i];\n\t\t\t\t\t\tif(c<n-1)\n\t\t\t\t\t\t\tnext_set_data[c][i]|=next_set_data[c+1][i];\n\t\t\t\t\t\tresult+=(long long)next_set_data[c][i].count()*i*(a[r][c]-'0');\n\t\t\t\t\t\tif(i==a[r][c]-'0')\n\t\t\t\t\t\t\tnext_set_data[c][i].set(index[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int i=0; i<10; ++i)\n\t\t\t\t\t\tnext_set_data[c][i].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur_set_data, next_set_data);\n\t\t}\n\t\tcerr<<\"clock(): \"<<clock()/double(CLOCKS_PER_SEC)<<endl;\n\t\twriteull(result);\n\t\tputchar('\\n');\n\t}\n}\nint main(){\n\twhatever::run();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint vy[4] = { 0, 1, 0, -1 };\nint vx[4] = { 1, 0, -1, 0 };\n\nvector<string> board;\n\nint N;\n\nbool inside(int y, int x)\n{\n\treturn y >= 0 && x >= 0 && y < N && x < N;\n}\n\n\n\nint main() {\n\tcin >> N;\n\n\tvector<string> board(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> board[i];\n\t}\n\t\n\tvector<vector<int>> numBoard(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint activeBlock = 0;\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\n\t\t\t//if (rand() % 5 == 0) numBoard[i][j] == -1;\n\t\t\t//else numBoard[i][j] = 1;\n\t\t\tif (board[i][j] == '#') numBoard[i][j] = -1;\n\t\t\telse {\n\t\t\t\tnumBoard[i][j] = (int)(board[i][j] - '0');\n\t\t\t\tactiveBlock++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int>> maxLen(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (numBoard[sy][sx] == -1) continue;\n\t\t\tmaxLen[sy][sx] = 1;\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = sy + vy[k];\n\t\t\t\tint nx = sx + vx[k];\n\t\t\t\tif (inside(ny, nx) && maxLen[ny][nx] >= 1) {\n\t\t\t\t\tmaxLen[sy][sx] = max(maxLen[sy][sx], maxLen[ny][nx] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<int> q;\n\tvector<vector<int>> startUsed(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\n\tvector<vector<int>> used(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint myTurn = 1;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1 && maxLen[sy][sx] > 0)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 2; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t\tmyTurn++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcerr << \"reset \" << ((int)q.size() - activeBlock) << endl;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcerr << \"reset \"  << ((int)q.size() - activeBlock) << endl;\n\n\n\n\tlong ans = 0;\n\tlong nowSum = 0;\n\n\tmyTurn++;\n\tlong add = 0;\n\n\twhile (!q.empty())\n\t{\n\t\tint start = q.front(); q.pop();\n\n\t\tif (start == -1)\n\t\t{\n\t\t\tmyTurn++;\n\t\t\tnowSum = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<int> q2;\n\t\tint sy = start >> 12;\n\t\tint sx = start & 0xFFF;\n\t\tused[sy][sx] = myTurn;\n\t\tq2.push(start);\n\n\n\t\twhile (!q2.empty())\n\t\t{\n\t\t\tint now = q2.front(); q2.pop();\n\t\t\tint y = now >> 12;\n\t\t\tint x = now & 0xFFF;\n\t\t\tnowSum += numBoard[y][x];\n\t\t\tadd++;\n\n\t\t\tint ny = y + 1;\n\t\t\tint nx = x + 1;\n\n\t\t\tif (ny < N && numBoard[ny][x] != -1 && used[ny][x] != myTurn)\n\t\t\t{\n\t\t\t\tused[ny][x] = myTurn;\n\t\t\t\tq2.push((ny << 12) + x);\n\t\t\t}\n\n\t\t\tif (nx < N && numBoard[y][nx] != -1 && used[y][nx] != myTurn)\n\t\t\t{\n\t\t\t\tused[y][nx] = myTurn;\n\t\t\t\tq2.push((y << 12) + nx);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t{\n\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\n\t\tans += numBoard[sy][sx] * nowSum;\n\t}\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (numBoard[i][j] != -1) ans -= numBoard[i][j] * numBoard[i][j];\n\t\t}\n\t}\n\n\tcerr << add << endl;\n\n\tcout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nusing bn=bitset<nax*nax>;\n\nint n;\n\nbn pus;\nbn oso[nax];\nbn lezy[5];\n\nchar wcz[nax];\nint tab[nax][nax];\n\nint num(int a, int b)\n{\n\treturn (a-1)*n+b-1;\n}\n\nll wyn;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%s\", wcz+1);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (wcz[j]=='#')\n\t\t\t{\n\t\t\t\ttab[i][j]=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttab[i][j]=wcz[j]-'0';\n\t\t\t\tfor (int l=0; l<4; l++)\n\t\t\t\t{\n\t\t\t\t\tif (tab[i][j]&(1<<l))\n\t\t\t\t\t{\n\t\t\t\t\t\tlezy[l][num(i, j)]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n; i; i--)\n\t{\n\t\tfor (int j=n; j; j--)\n\t\t{\n\t\t\tif (tab[i][j]==-1)\n\t\t\t{\n\t\t\t\toso[j]=pus;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\toso[j]|=oso[j+1];\n\t\t\tfor (int l=0; l<4; l++)\n\t\t\t\twyn+=(1<<l)*tab[i][j]*(oso[j]&lezy[l]).count();\n\t\t\toso[j][num(i, j)]=1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 505;\nusing Bs = bitset<N * N>;\n\nBs bss[2][N];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<string> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tlong long ans = 0;\n\tfor (int d = 1; d <= 9; d *= 2) {\n\t\tfor (int sum = n + n - 2, _ = 0; sum >= 0; --sum, _ ^= 1) {\n\t\t\tint l = max(0, sum - n + 1);\n\t\t\tint r = min(n - 1, sum);\n\t\t\tfor (int i = l; i <= r; ++i) {\n\t\t\t\tbss[_][i] = {};\n\t\t\t\tint j = sum - i;\n\t\t\t\tif (a[i][j] == '#') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (i + 1 < n) {\n\t\t\t\t\tbss[_][i] |= bss[_ ^ 1][i + 1];\n\t\t\t\t\tif (a[i + 1][j] != '#' && (a[i + 1][j] - '0' & d)) {\n\t\t\t\t\t\tbss[_][i].flip((i + 1) * n + j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j + 1 < n) {\n\t\t\t\t\tbss[_][i] |= bss[_ ^ 1][i];\n\t\t\t\t\tif (a[i][j + 1] != '#' && (a[i][j + 1] - '0' & d)) {\n\t\t\t\t\t\tbss[_][i].flip(i * n + (j + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += ((long long)a[i][j] - '0') * d * bss[_][i].count();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=510;\nint N,u[MaxN][MaxN],l[MaxN][MaxN],r[MaxN][MaxN];\nchar A[MaxN][MaxN];\nint S[MaxN];\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nbool d(char c){return c>='0'&&c<='9';}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)scanf(\"%s\",A[i]+1);\n\tfor(int i=0;i<=N;i++)\n\t\tfor(int j=0;j<=N;j++)u[i][j]=d(A[i][j])?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor(int x=1;x<=N;x++){\n\t\tfor(int i=x;i;i--){\n\t\t\tfor(int j=1;j<=N;j++)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor(int j=N+1;j;j--){\n\t\t\t\tl[i][j]=1<<30;r[i][j]=-1;\n\t\t\t\tif(d(A[i][j])){\n\t\t\t\t\tif(i<x){\n\t\t\t\t\t\tl[i][j]=min(l[i][j],l[i+1][j]);\n\t\t\t\t\t\tr[i][j]=max(r[i][j],r[i+1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse l[i][j]=r[i][j]=j;\n\t\t\t\t\tl[i][j]=min(l[i][j],l[i][j+1]);\n\t\t\t\t\tr[i][j]=max(r[i][j],r[i][j+1]);\n\t\t\t\t}\n\t\t\t\tif(l[i][j]<=r[i][j])ans+=(A[i][j]-'0')*(S[r[i][j]]-S[l[i][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,g[505][505],s[505][505],mx[505];\nbool e[505][505];\nLL res;\nint readchar(){\n\tchar c=getchar();\n\twhile(c==' ' || c=='\\n') c=getchar();\n\tif(c=='#') return 0;\n\treturn c-'0';\n}\nvoid add(int x,int y){\n\te[x][y]=1;\n\tif(x<n-1 && g[x+1][y] && !e[x+1][y]) add(x+1,y);\n\tif(y<n-1 && g[x][y+1] && !e[x][y+1]) add(x,y+1);\n}\nint getlower(int x,int y){\n\tint cx=x,cy=y,ret=(y?s[x][y-1]:0);\n\tmx[y]=x;\n\twhile(1){\n\t\twhile(1){\n\t\t\tif(cx+1<n && e[cx+1][cy]){\n\t\t\t\t++cx;\n\t\t\t\tmx[y]=cx;\n\t\t\t\tret+=(cy?s[cx][cy-1]:0);\n\t\t\t}\n\t\t\telse if(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cy+1<n){\n\t\t\t++cy;\n\t\t\tif(e[cx][cy]){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!found) break;\n\t}\n\treturn ret;\n}\nint getupper(int x,int y){\n\tint cx=x,cy=y,ret=0;\n\twhile(1){\n\t\twhile(1){\n\t\t\tif(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse if(cx+1<n && e[cx+1][cy]){\n\t\t\t\tret+=s[cx][cy];\n\t\t\t\t++cx;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cx<n-1){\n\t\t\tret+=s[cx][cy];\n\t\t\t++cx;\n\t\t\tif(cx>mx[y]) break;\n\t\t\tif(e[cx][cy]){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!found || cx>mx[y]) break;\n\t}\n\tif(cx<=mx[y]) ret+=s[cx][cy];\n\treturn ret;\n}\nvoid solveline(int x){\n\tint i,j,k;\n\tmemcpy(s,g,sizeof(g));\n\tfor(i=0;i<n;++i){\n\t\tfor(j=1;j<n;++j){\n\t\t\ts[i][j]+=s[i][j-1];\n\t\t}\n\t}\n\tfor(i=x;i<n;++i) memset(e[i],0,sizeof(e[i]));\n\tfor(i=0;i<n;++i){\n\t\tif(!g[x][i]) continue;\n\t\tadd(x,i);\n\t\tres-=(LL)g[x][i]*(LL)getlower(x,i);\n\t}\n\tfor(i=x;i<n;++i) memset(e[i],0,sizeof(e[i]));\n\tfor(i=n-1;i>=0;--i){\n\t\tif(!g[x][i]) continue;\n\t\tadd(x,i);\n\t\tres+=(LL)g[x][i]*(LL)(getupper(x,i)-g[x][i]);\n\t}\n}\nvoid del(int x,int y){\n\tif((!x || !g[x-1][y]) && (!y || !g[x][y-1])){\n\t\tg[x][y]=0;\n\t\tif(x<n-1 && g[x+1][y]) del(x+1,y);\n\t\tif(y<n-1 && g[x][y+1]) del(x,y+1);\n\t}\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\tg[i][j]=readchar();\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\te[i][j]=(!!g[i][j]);\n\t\t}\n\t}\n    for(i=n-1;i>=0;--i){\n\t\tsolveline(i);\n\t\tfor(j=0;j<n;++j){\n\t\t\tif(g[i][j]) del(i,j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_map>\n#include <bitset>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1505;\nconst ull H = 3137;\n\nint brred, brstup;\nint p[2][MAX][MAX];\n\nll sum_sq(int r, int s1, int s2, int st) {\n  ll ret=0;\n  FOR(j, s1, s2+1)\n    ret += p[st][r][j] * p[st][r][j];\n  return ret;\n}\n\nll calc_single(int r, int s1, int s2, int st) {\n  ll sum=0, ret=0;\n  FOR(j, s1, s2+1) {\n    if (!p[st][r][j]) {\n      sum = 0;\n      continue;\n    }\n\n    ret += p[st][r][j] * sum;\n    sum += p[st][r][j];\n  }\n\n  return ret;\n}\n\null Bgor[MAX][MAX][MAX/64+1], Bdol[MAX][MAX][MAX/64+1];\nint SZ;\n\nvoid reset(ull B[MAX][MAX][MAX/64+1], int r1, int r2, int s1, int s2) {\n  FOR(i, r1, r2+1) FOR(j, s1, s2+1) REP(k, SZ)\n    B[i][j][k] = 0;\n}\n\nvoid andaj(ull a[], ull b[], ull c[]) {\n  REP(i, SZ) c[i] = a[i] & b[i];\n}\n\nvoid oraj(ull a[], ull b[], ull c[]) {\n  REP(i, SZ) c[i] = a[i] | b[i];\n}\n\nvoid kopiraj(ull a[], ull b[]) {\n  REP(i, SZ) b[i] = a[i];\n}\n\nvoid stavi(ull a[], int ind) {\n  a[ind/64] |= ((ull) 1) << (ind % 64);\n}\n\nbool notempty(ull a[]) {\n  REP(i, SZ) if (a[i]) return true;\n  return false;\n}\n\null get_h(ull a[]) {\n  ull r=0;\n  REP(i, SZ) r = r*H + a[i];\n  return r;\n}\n\nvoid go_down(int r1, int r2, int s1, int s2, int st) {\n  reset(Bgor, r1, r2, s1, s2);\n\n  for (int i=r2; i>=r1; i--) {\n    for (int j=s2; j>=s1; j--) {\n      if (!p[st][i][j]) continue;\n      if (i != r2 && j != s2) oraj(Bgor[i+1][j], Bgor[i][j+1], Bgor[i][j]);\n      else if (i != r2) kopiraj(Bgor[i+1][j], Bgor[i][j]);\n      else if (j != s2) kopiraj(Bgor[i][j+1], Bgor[i][j]);\n\n      if (i == r2) stavi(Bgor[i][j], j-s1);\n    }\n  }\n}\n\nvoid go_up(int r1, int r2, int s1, int s2, int st) {\n  reset(Bdol, r1, r2, s1, s2);\n\n  FOR(i, r1, r2+1) {\n    FOR(j, s1, s2+1) {\n      if (!p[st][i][j]) continue;\n      if (i != r1 && j != s1) oraj(Bdol[i-1][j], Bdol[i][j-1], Bdol[i][j]);\n      else if (i != r1) kopiraj(Bdol[i-1][j], Bdol[i][j]);\n      else if (j != s1) kopiraj(Bdol[i][j-1], Bdol[i][j]);\n\n      if (i == r1) stavi(Bdol[i][j], j-s1);\n    }\n  }\n}\n\null tmp[MAX/64+1];\nll spoji(int r1, int mid, int r2, int s1, int s2, int st) {\n  unordered_map <ull, ll> Sum_dol, Sum_gor;\n  unordered_map <ull, P> Pred_dol, Pred_gor;\n\n  FOR(i, r1, mid+1) {\n    FOR(j, s1, s2+1) {\n      ull h = get_h(Bgor[i][j]);\n      Pred_gor[h] = P(i, j);\n      Sum_gor[h] += p[st][i][j];\n    }\n  }\n\n  FOR(i, mid, r2+1) {\n    FOR(j, s1, s2+1) {\n      ull h = get_h(Bdol[i][j]);\n      Pred_dol[h] = P(i, j);\n      Sum_dol[h] += p[st][i][j];\n    }\n  }\n\n  ll ret=0;\n  for (auto gor = Pred_gor.begin(); gor != Pred_gor.end(); gor++) {\n    for (auto dol = Pred_dol.begin(); dol != Pred_dol.end(); dol++) {\n      andaj(Bgor[gor->Y.X][gor->Y.Y], Bdol[dol->Y.X][dol->Y.Y], tmp);\n      if (notempty(tmp))\n        ret += Sum_gor[gor->X] * Sum_dol[dol->X];\n    }\n  }\n\n  return ret;\n}\n\nll calc(int r1, int r2, int s1, int s2, int st) {\n  if (r1 > r2 || s1 > s2) return 0;\n  if (r2-r1 < s2-s1)\n    return calc(s1, s2, r1, r2, 1^st);\n\n  if (r1 == r2)\n    return calc_single(r1, s1, s2, st);\n\n  int mid = (r1 + r2) / 2;\n  SZ = (s2 - s1 + 64) / 64;\n\n  go_down(r1, mid, s1, s2, st);\n  go_up(mid, r2, s1, s2, st);\n\n  ll ret = spoji(r1, mid, r2, s1, s2, st);\n\n  ret -= sum_sq(mid, s1, s2, st);\n\n  ret += calc(r1, mid-1, s1, s2, st);\n  ret += calc(mid+1, r2, s1, s2, st);\n\n  return ret;\n}\n\nchar s[MAX][MAX];\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n\n  REP(i, n) {\n    scanf(\" %s\", s[i]);\n    REP(j, n)\n      p[0][i][j] = p[1][j][i] = (s[i][j] == '#' ? 0 : (int) (s[i][j] - '0'));\n  }\n\n  printf(\"%lld\\n\", calc(0, n-1, 0, n-1, 0));\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 13.10.2018 16:23:29       \n**/                        \n#pragma GCC optimize(\"-Ofast\")\n\n#undef _GLIBCXX_DEBUG\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int N = 1505;\n \nshort L[2][N][N];\nshort R[2][N][N];\nint a[N][N];\nint row[N][N];\nint up[N][N];\nstring board[N];\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<string> board(n);\n  for (int i = 0; i < n; i++) {\n    cin >> board[i];\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      a[i][j] = (board[i][j] == '#' ? 0 : (int) (board[i][j] - '0'));\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    row[i][0] = 0;\n    for (int j = 0; j < n; j++) {\n      row[i][j + 1] = row[i][j] + a[i][j];\n    }\n  }\n  long long ans = 0;\n  function<void(int,int)> put = [&](int i, int j) {\n    if (0 <= i && i < n && 0 <= j && j < n && a[i][j] > 0) {\n      if (i == 0 || a[i - 1][j] == 0) {\n        if (j == 0 || a[i][j - 1] == 0) {\n          for (int k = j; k < n; k++) {\n            row[i][k + 1] -= a[i][j];\n          }\n          a[i][j] = 0;\n          put(i + 1, j);\n          put(i, j + 1);\n        }\n      }\n    }\n  };\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = n - 1; j >= 0; j--) {\n      if (a[i][j] == 0) {\n        continue;\n      }\n      int sum = 0;\n      if (i < n - 1 && a[i + 1][j] != 0 && j < n - 1 && a[i][j + 1] != 0) {\n        L[i & 1][j][i] = j;\n        R[i & 1][j][i] = R[i & 1][j + 1][i];\n        sum += row[i][R[i & 1][j][i] + 1] - row[i][L[i & 1][j][i]];\n        up[i][j] = max(up[i + 1][j], up[i][j + 1]);\n        int to = min(up[i + 1][j], up[i][j + 1]);\n        memcpy(L[i & 1][j] + (i + 1), L[(i + 1) & 1][j] + (i + 1), sizeof(short) * (to - (i + 1) + 1));\n        memcpy(R[i & 1][j] + (i + 1), R[i & 1][j + 1] + (i + 1), sizeof(short) * (to - (i + 1) + 1));\n        for (int k = i + 1; k <= to; k++) {\n          sum += row[k][R[i & 1][j][k] + 1] - row[k][L[i & 1][j][k]];\n        }\n        if (up[i + 1][j] < up[i][j + 1]) {\n          memcpy(L[i & 1][j] + (to + 1), L[i & 1][j + 1] + (to + 1), sizeof(short) * (up[i][j] - (to + 1) + 1));\n          memcpy(R[i & 1][j] + (to + 1), R[i & 1][j + 1] + (to + 1), sizeof(short) * (up[i][j] - (to + 1) + 1));\n          for (int k = to + 1; k <= up[i][j]; k++) {\n            sum += row[k][R[i & 1][j][k] + 1] - row[k][L[i & 1][j][k]];\n          }\n        }\n        if (up[i + 1][j] > up[i][j + 1]) {\n          memcpy(L[i & 1][j] + (to + 1), L[(i + 1) & 1][j] + (to + 1), sizeof(short) * (up[i][j] - (to + 1) + 1));\n          memcpy(R[i & 1][j] + (to + 1), R[(i + 1) & 1][j] + (to + 1), sizeof(short) * (up[i][j] - (to + 1) + 1));\n          for (int k = to + 1; k <= up[i][j]; k++) {\n            sum += row[k][R[i & 1][j][k] + 1] - row[k][L[i & 1][j][k]];\n          }\n        }\n      } else {\n        if (i < n - 1 && a[i + 1][j] != 0) {\n          L[i & 1][j][i] = j;\n          R[i & 1][j][i] = j;\n          up[i][j] = up[i + 1][j];\n          memcpy(L[i & 1][j] + (i + 1), L[(i + 1) & 1][j] + (i + 1), sizeof(short) * (up[i][j] - (i + 1) + 1));\n          memcpy(R[i & 1][j] + (i + 1), R[(i + 1) & 1][j] + (i + 1), sizeof(short) * (up[i][j] - (i + 1) + 1));\n        } else {\n          if (j < n - 1 && a[i][j + 1] != 0) {\n            L[i & 1][j][i] = j;\n            R[i & 1][j][i] = R[i & 1][j + 1][i];\n            up[i][j] = up[i][j + 1];\n            memcpy(L[i & 1][j] + (i + 1), L[i & 1][j + 1] + (i + 1), sizeof(short) * (up[i][j] - (i + 1) + 1));\n            memcpy(R[i & 1][j] + (i + 1), R[i & 1][j + 1] + (i + 1), sizeof(short) * (up[i][j] - (i + 1) + 1));\n          } else {\n            L[i & 1][j][i] = j;\n            R[i & 1][j][i] = j;\n            up[i][j] = i;\n          }\n        }\n        for (int k = i; k <= up[i][j]; k++) {\n          sum += row[k][R[i & 1][j][k] + 1] - row[k][L[i & 1][j][k]];\n        }\n      }\n      ans += a[i][j] * (sum - a[i][j]);\n      put(i, j);\n    }\n  }\n  cout << ans << '\\n';\n  cerr << \"time = \" << clock() << \" ms\" << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint sumv[1505][1505],rpos[1505][1505];\nint minn[2][1505][1505],maxn[2][1505][1505];\n\nchar str[1505][1505];\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) scanf(\"%s\",str[i]+1);\n  int cur=0;\n  ll ans=0;\n  for(int i=n;i>0;i--) {\n  \tcur^=1;\n  \tfor(int j=n;j>0;j--)\n  \t  if (str[i][j]!='#') {\n  \t  \t  sumv[i][j]=sumv[i][j+1]+sumv[i+1][j]+str[i][j]-'0';\n  \t  \t  rpos[i][j]=max(max(rpos[i][j+1],rpos[i+1][j]),i);\n  \t  \t  minn[cur][j][i]=j;\n  \t  \t  for(int k=i+1;k<=rpos[i+1][j];k++) minn[cur][j][k]=minn[cur^1][j][k];\n  \t  \t  for(int k=max(rpos[i+1][j],i)+1;k<=rpos[i][j+1];k++) minn[cur][j][k]=minn[cur][j+1][k];\n  \t  \t  maxn[cur][j][i]=j;\n  \t  \t  for(int k=i;k<=rpos[i][j+1];k++) maxn[cur][j][k]=maxn[cur][j+1][k];\n  \t  \t  for(int k=max(rpos[i][j+1],i)+1;k<=rpos[i+1][j];k++) maxn[cur][j][k]=maxn[cur^1][j][k];\n  \t  \t  int d=i+1,r=min(rpos[i][j+1],rpos[i+1][j]);\n  \t  \t  while (d<=r) {\n  \t  \t  \t    if (maxn[cur^1][j][d]>=minn[cur][j+1][d]) {\n  \t  \t  \t    \t    sumv[i][j]-=sumv[d][minn[cur][j+1][d]];\n  \t  \t  \t    \t    d=rpos[d][minn[cur][j+1][d]];\n\t\t\t\t\t  }\n  \t  \t  \t    d++;\n\t\t\t  }\n\t\t  ans+=(ll)(str[i][j]-'0')*(sumv[i][j]-(str[i][j]-'0'));\n\t\t}\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint val[N<<11|1],b[N<<11|1],S[N],n,u[N<<11|1],l[N],r[N],flag[N<<11|1];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i<<11|j]=A[i][j]>='0'&&A[i][j]<='9',b[i<<11|j]=A[i][j]-'0';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i<<11|j]=flag[i<<11|j]?min(i,min(u[(i-1)<<11|j],u[i<<11|(j-1)])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x<<11|j]<=x?b[x<<11|j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x<<11|j]){\n\t\t\t\tl[j]=j-1;\n\t\t\t\tr[j]=r[j+1]==-1?j:r[j+1];\n\t\t\t\tval[x<<11|j]+=S[r[j]]-S[l[j]]-b[x<<11|j];\n\t\t\t}\n\t\t\telse l[j]=1e9,r[j]=-1;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x<<11|j]<=i?b[x<<11|j]:0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i<<11|j]){\n\t\t\t\t\tl[j]=min(l[j+1],l[j]);\n\t\t\t\t\tr[j]=max(r[j+1],r[j]);\n\t\t\t\t\tif (l[j]<=r[j])val[i<<11|j]+=(S[r[j]]-S[l[j]]);\n\t\t\t\t} \n\t\t\t\telse l[j]=1e9,r[j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)ans+=val[i<<11|j]*b[i<<11|j];\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef long long s64;\ntypedef unsigned long long u64;\ntypedef unsigned int u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define rep0(i,l,r) for(int i=l;i<r;++i)\n#define gc (c=getchar())\nint read()\n{\n\tchar c;\n\twhile(gc<'-');\n\tif(c=='-')\n\t{\n\t\tint x=gc-'0';\n\t\twhile(gc>='0')x=x*10+c-'0';\n\t\treturn -x;\n\t}\n\tint x=c-'0';\n\twhile(gc>='0')x=x*10+c-'0';\n\treturn x;\n}\n#undef gc\n\nconst int N=500+5;\nchar a[N][N];\nint dp[N][N];\nint cl[N][N],cr[N][N];\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);//freopen(\"1.out\",\"w\",stdout);\n#endif\n\tint n;\n\tcin>>n;\n\trep(i,1,n)scanf(\"%s\",a[i]+1);\n\ts64 ans=0;\n\tper(j,n,1)\n\tif(isdigit(a[n][j]))\n\t{\n\t\tcl[j][n]=cr[j][n]=j;\n\t\tif(isdigit(a[n][j+1]))\n\t\t{\n\t\t\tcr[j][n]=cr[j+1][n];\n\t\t\tdp[n][j]=dp[n][j+1];\n\t\t}\n\t\tans+=(a[n][j]-'0')*dp[n][j];\n\t\tdp[n][j]+=a[n][j]-'0';\n\t}\n\tper(i,n-1,1)\n\tper(j,n,1)\n\tif(isdigit(a[i][j]))\n\t{\n\t\tbool b1=isdigit(a[i][j+1]),b2=isdigit(a[i+1][j]);\n\t\tif(!b1&&!b2)\n\t\t{\n\t\t\tcl[j][i]=cr[j][i]=j;\n\t\t\trep(k,i+1,n){cl[j][k]=n+1;cr[j][k]=0;}\n\t\t}else\n\t\tif(!b1&&b2)\n\t\t{\n\t\t\tdp[i][j]=dp[i+1][j];\n\t\t\tcl[j][i]=cr[j][i]=j;\n\t\t}else\n\t\tif(b1&&!b2)\n\t\t{\n\t\t\tdp[i][j]=dp[i][j+1];\n\t\t\tcl[j][i]=j;cr[j][i]=cr[j+1][i];\n\t\t\trep(k,i+1,n){cl[j][k]=cl[j+1][k];cr[j][k]=cr[j+1][k];}\n\t\t}else\n\t\t{\n\t\t\tif(i==1&&j==2)\n\t\t\t\tint yyx=1;\n\t\t\tint ndp=dp[i+1][j]+dp[i][j+1];\n\t\t\tint last=0;\n\t\t\tcl[j][i]=j;cr[j][i]=cr[j+1][i];\n\t\t\trep(k,i+1,n)\n\t\t\t{\n\t\t\t\tif(cr[j][k]>=cl[j+1][k]&&last<cl[j+1][k])\n\t\t\t\t\tndp-=dp[k][cl[j+1][k]];\n\t\t\t\tlast=cr[j][k];\n\t\t\t\tchmin(cl[j][k],cl[j+1][k]);\n\t\t\t\tchmax(cr[j][k],cr[j+1][k]);\n\t\t\t}\n\t\t\tdp[i][j]=ndp;\n\t\t}\n\t\tans+=(a[i][j]-'0')*dp[i][j];\n\t\tdp[i][j]+=a[i][j]-'0';\n\t}\n//\trep(i,1,n)\n//rep(j,1,n)printf(\"%d%c\",dp[i][j],\" \\n\"[j==n]);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include <stack>\nusing namespace std;\nint lcm(int n, int m) {\n\tint a, b, tmp, r;\n\ta = n, b = m;\n\tif (a < b) {\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\tr = a % b;\n\twhile (r != 0) {\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}\nint min(int n, int m) {\n\tif (m < n) return m;\n\telse return n;\n}\n\n\n\nint main() {\n\n\tstruct point {\n\t\tint x, y;\n\t};\n\tint dx[2] = { -1,0 };\n\tint dy[2] = { 0,-1 };\n\tint n, i, j,z;\n\tcin >> n;\n\tchar a[500][500];\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tlong long tans=0;\n\tqueue<point> q;\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tfor(j = n-1; j >=0; j-- ){\n\t\t\tpoint k;\n\t\t\tk.x = i; k.y = j;\n\t\t\tif (a[k.x][k.y] != '#'&&(k.x)*(k.x)+(k.y)*(k.y)!=0) {\n\t\t\t\tpoint h;\n\t\t\t\tfor (z = 0; z <= 1; z++) {\n\t\t\t\t\th.x = k.x + dx[i];\n\t\t\t\t\th.y = k.y + dy[i];\n\t\t\t\t\n\t\t\t\t\tif (a[h.x][h.y] != '#' && (h.x)*(h.x) + (h.y)*(h.y) != 0) {\n\t\t\t\t\t\tlong long ans=0;\n\t\t\t\t\t\tlong long sem;\n\t\t\t\t\t\tpoint w;\n\t\t\t\t\t\tw = h;\n\t\t\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\t\t\th = q.front();\n\t\t\t\t\t\t\tpoint l;\n\t\t\t\t\t\t\tans =ans+ a[h.x][h.y];\n\t\t\t\t\t\t\tfor (z = 0; z <= 1; z++) {\n\t\t\t\t\t\t\t\tl.x = h.x + dx[i];\n\t\t\t\t\t\t\t\tl.y = h.y + dy[i];\n\n\t\t\t\t\t\t\t\tif (a[l.x][l.y] != '#') {\n\t\t\t\t\t\t\t\t\tq.push(l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\t\th = q.front();\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsem = ans * a[w.x][w.y];\n\t\t\t\t\t\ttans = tans + sem;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << tans;\n\n\n\n\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nbitset<250000>ch[250000];\nint N,M;\nvector<string>V;\nint MP[1500][1500][10],emt[10];\nll to=0;\nvoid ree(int r,int c)\n{\n    printf(\"to:: %lld\\n\",to);\n    //for(int i=0;i<10;i++)printf(\"%d :: %d\\n\",i,MP[r][c][i]);\n    int*cnt=MP[r][c];--cnt[V[r][c]-'0'];\n   // for(int i=0;i<10;i++)printf(\"%d :: %d & %d\\n\",i,cnt[i],MP[r][c][i]);\n    for(int i=0;i<10;i++)\n        to+=((V[r][c]-'0'+i>9)+1)*cnt[i];\n    /*for(int i=0;i<10;i++)\n        for(int j=i;j<10;j++)\n            to+=((i+j>9)+1)*cnt[i]*(ll)(i==j?cnt[i]-1:cnt[j]);\n            */\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin>>N;\n    V.resize(N);\n    for(auto&I:V)cin>>I;\n    for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n            for(int k=0;k<2;k++)\n                if(V[i][j]!='#')\n                {\n                    int r=i,c=j;\n                    if(k&1)r++;\n                    else c++;\n                    if(V[r][c]!='#')\n                        ch[i*500+j].set(r*500+c);\n                }\n    for(int k=0;k<250000;k++)\n        for(int i=0;i<k;i++)\n            if(ch[i].test(k))\n                ch[i]|=ch[k];\n    for(int k=0,nm;k<250000;k++)\n    {\n        nm=V[k/500][k%500]-'0';\n        for(int i=ch[k]._Find_first();i<ch[k].size();i=ch[k]._Find_next(i))\n            to+=(V[i/500][i%500]-'0'+nm>9)+1;\n    }\n    cout<<to;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\ntemplate<typename T>\nvector<T> createMatrix(int n, T def) {\n  return vector<T>(n * n, def);\n  //return vector<vector<T>>(n, vector<T>(n, def));\n}\n\nint main() {\n\n        int n; cin >> n;\n        auto wall = createMatrix(n, false);\n        auto a = createMatrix(n, (int) 0);\n        auto b = createMatrix(n, (int) 0);\n        \n        for (int i = 0; i < n; ++i) {\n            string s; while (s.empty()) cin >> s;\n            for (int j = 0; j < n; ++j) {\n                char ch = s[j];\n                if (ch == '#')\n                    wall[i*n+j] = true;\n                else {\n                    a[i*n+j] = b[i*n+j] = ch - '0';\n                }\n            }\n        }\n        int64 res = 0;\n        vector<int> perm(n * n);\n        for (int i = 0; i < n * n; ++i) perm[i] = i;\n        for (int i = 0; i < n * n; ++i) {\n            int j = rand() % (i + 1);\n            int t = perm[i];\n            perm[i] = perm[j];\n            perm[j] = t;\n        }\n        auto seen = createMatrix(n, (int) 0);\n        auto best = createMatrix(n, (int) 0);\n        auto via = createMatrix(n, (int) 0);\n        vector<int> qr(n * n);\n        vector<int> qc(n * n);\n        vector<int> pr(2 * n);\n        vector<int> pc(2 * n);\n        int generation = 0;\n        int iters = 0;\n        for (int ss : perm) {\n            int sr = ss / n;\n            int sc = ss % n;\n            if (b[sr*n+sc] == 0) continue;\n            ++iters;\n            int plen = 0;\n            {\n                ++generation;\n                int qt = 0;\n                int qh = 1;\n                qr[0] = sr;\n                qc[0] = sc;\n                best[sr*n+sc] = 0;\n                seen[sr*n+sc] = generation;\n                int globalBest = 0;\n                int globalBr = sr;\n                int globalBc = sc;\n                while (qt < qh) {\n                    int r = qr[qt];\n                    int c = qc[qt];\n                    int cbest = best[r*n+c];\n                    if (cbest > globalBest) {\n                        globalBest = cbest;\n                        globalBr = r;\n                        globalBc = c;\n                    }\n                    ++qt;\n                    if (r + 1 < n) {\n                        int nr = r + 1;\n                        int nc = c;\n                        if (!wall[nr*n+nc]) {\n                            int extra = b[nr*n+nc] > 0 ? 1 : 0;\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest + extra) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest + extra;\n                                via[nr*n+nc] = 1;\n                            }\n                        }\n                    }\n                    if (c + 1 < n) {\n                        int nr = r;\n                        int nc = c + 1;\n                        if (!wall[nr*n+nc]) {\n                            int extra = b[nr*n+nc] > 0 ? 1 : 0;\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest + extra) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest + extra;\n                                via[nr*n+nc] = 2;\n                            }\n                        }\n                    }\n                }\n                int r = globalBr;\n                int c = globalBc;\n                while (r != sr || c != sc) {\n                    pr[plen] = r;\n                    pc[plen] = c;\n                    ++plen;\n                    if (via[r*n+c] == 1) {\n                        --r;\n                    } else {\n                        --c;\n                    }\n                }\n            }\n            pr[plen] = sr;\n            pc[plen] = sc;\n            ++plen;\n            {\n                ++generation;\n                int qt = 0;\n                int qh = 1;\n                qr[0] = sr;\n                qc[0] = sc;\n                best[sr*n+sc] = 0;\n                seen[sr*n+sc] = generation;\n                int globalBest = 0;\n                int globalBr = sr;\n                int globalBc = sc;\n                while (qt < qh) {\n                    int r = qr[qt];\n                    int c = qc[qt];\n                    int cbest = best[r*n+c];\n                    if (cbest > globalBest) {\n                        globalBest = cbest;\n                        globalBr = r;\n                        globalBc = c;\n                    }\n                    ++qt;\n                    if (r - 1 >= 0) {\n                        int nr = r - 1;\n                        int nc = c;\n                        if (!wall[nr*n+nc]) {\n                            int extra = b[nr*n+nc] > 0 ? 1 : 0;\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest + extra) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest + extra;\n                                via[nr*n+nc] = 1;\n                            }\n                        }\n                    }\n                    if (c - 1 >= 0) {\n                        int nr = r;\n                        int nc = c - 1;\n                        if (!wall[nr*n+nc]) {\n                            int extra = b[nr*n+nc] > 0 ? 1 : 0;\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest + extra) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest + extra;\n                                via[nr*n+nc] = 2;\n                            }\n                        }\n                    }\n                }\n                int r = globalBr;\n                int c = globalBc;\n                int splen = plen;\n                while (r != sr || c != sc) {\n                    pr[plen] = r;\n                    pc[plen] = c;\n                    ++plen;\n                    if (via[r*n+c] == 1) {\n                        ++r;\n                    } else {\n                        ++c;\n                    }\n                }\n                for (int i = splen, j = plen - 1; i < j; ++i, --j) {\n                    int t = pr[i];\n                    pr[i] = pr[j];\n                    pr[j] = t;\n                    t = pc[i];\n                    pc[i] = pc[j];\n                    pc[j] = t;\n                }\n            }\n            {\n                ++generation;\n                int sofar = 0;\n                for (int i = 0; i < plen; ++i) {\n                    seen[pr[i]*n+pc[i]] = generation;\n                    res -= a[pr[i]*n+pc[i]] * b[pr[i]*n+pc[i]];\n                    sofar += b[pr[i]*n+pc[i]];\n                    b[pr[i]*n+pc[i]] = 0;\n                    best[pr[i]*n+pc[i]] = sofar;\n                }\n                int qt = 0;\n                int qh = 0;\n                int nextPath = 0;\n                while (qt < qh || nextPath < plen) {\n                    if (qt == qh) {\n                        qr[qh] = pr[nextPath];\n                        qc[qh] = pc[nextPath];\n                        ++nextPath;\n                        ++qh;\n                    }\n                    int r = qr[qt];\n                    int c = qc[qt];\n                    int cbest = best[r*n+c];\n                    res += cbest * a[r*n+c];\n                    ++qt;\n                    if (r - 1 >= 0) {\n                        int nr = r - 1;\n                        int nc = c;\n                        if (!wall[nr*n+nc]) {\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest;\n                            }\n                        }\n                    }\n                    if (c - 1 >= 0) {\n                        int nr = r;\n                        int nc = c - 1;\n                        if (!wall[nr*n+nc]) {\n                            if (seen[nr*n+nc] < generation || best[nr*n+nc] < cbest) {\n                                if (seen[nr*n+nc] < generation) {\n                                    qr[qh] = nr;\n                                    qc[qh] = nc;\n                                    ++qh;\n                                }\n                                seen[nr*n+nc] = generation;\n                                best[nr*n+nc] = cbest;\n                                via[nr*n+nc] = 2;\n                            }\n                        }\n                    }\n                    if (nextPath < plen && r + c == pr[nextPath] + pc[nextPath]) {\n                        --qt;\n                        qr[qt] = pr[nextPath];\n                        qc[qt] = pc[nextPath];\n                        ++nextPath;\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n   }                                        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]>r[k][j+1]) break;\n\t\t\t\t//\tif(i==2&&j==1) cout<<\"-_-\"<<las_r<<\" \"<<l[k][j+1]<<endl;\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) {\n\t\t\t\t\t\ttot-=f[k][l[k][j+1]];\n\t\t\t\t\t\tlas_r=max(las_r,r[k][j+1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\telse l[i][j]=n+1,r[i][j]=0;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\t/*\n\tfor1(1,n,i) {\n\t\tfor1(1,n,j) cout<<f[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\t*/\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint vy[4] = { 0, 1, -1, 0 };\nint vx[4] = { 1, 0, 0, -1 };\n\nvector<string> board;\n\nint N;\n\nbool inside(int y, int x)\n{\n\treturn y >= 0 && x >= 0 && y < N && x < N;\n}\n\n\n\nint main() {\n\tcin >> N;\n\n\tvector<string> board(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> board[i];\n\t}\n\t\n\tvector<vector<int>> numBoard(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint activeBlock = 0;\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\n\t\t\t//if (rand() % 5 == 0) numBoard[i][j] == -1;\n\t\t\t//else numBoard[i][j] = 1;\n\t\t\tif (board[i][j] == '#') numBoard[i][j] = -1;\n\t\t\telse {\n\t\t\t\tnumBoard[i][j] = (int)(board[i][j] - '0');\n\t\t\t\tactiveBlock++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int>> maxLen(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (numBoard[sy][sx] == -1) continue;\n\t\t\tmaxLen[sy][sx] = 1;\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = sy + vy[k];\n\t\t\t\tint nx = sx + vx[k];\n\t\t\t\tif (inside(ny, nx) && maxLen[ny][nx] >= 1) {\n\t\t\t\t\tmaxLen[sy][sx] = max(maxLen[sy][sx], maxLen[ny][nx] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<int> q;\n\tvector<vector<int>> startUsed(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\n\tvector<vector<int>> used(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint myTurn = 1;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1 && maxLen[sy][sx] > 0)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 2; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t\tmyTurn++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcerr << \"reset \" << ((int)q.size() - activeBlock) << endl;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcerr << \"reset \"  << ((int)q.size() - activeBlock) << endl;\n\n\n\n\tlong ans = 0;\n\tlong nowSum = 0;\n\n\tmyTurn++;\n\tlong add = 0;\n\n\twhile (!q.empty())\n\t{\n\t\tint start = q.front(); q.pop();\n\n\t\tif (start == -1)\n\t\t{\n\t\t\tmyTurn++;\n\t\t\tnowSum = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<int> q2;\n\t\tint sy = start >> 12;\n\t\tint sx = start & 0xFFF;\n\t\tused[sy][sx] = myTurn;\n\t\tq2.push(start);\n\n\n\t\twhile (!q2.empty())\n\t\t{\n\t\t\tint now = q2.front(); q2.pop();\n\t\t\tint y = now >> 12;\n\t\t\tint x = now & 0xFFF;\n\t\t\tnowSum += numBoard[y][x];\n\t\t\tadd++;\n\n\t\t\tint ny = y + 1;\n\t\t\tint nx = x + 1;\n\n\t\t\tif (ny < N && numBoard[ny][x] != -1 && used[ny][x] != myTurn)\n\t\t\t{\n\t\t\t\tused[ny][x] = myTurn;\n\t\t\t\tq2.push((ny << 12) + x);\n\t\t\t}\n\n\t\t\tif (nx < N && numBoard[y][nx] != -1 && used[y][nx] != myTurn)\n\t\t\t{\n\t\t\t\tused[y][nx] = myTurn;\n\t\t\t\tq2.push((y << 12) + nx);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t{\n\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\n\t\tans += numBoard[sy][sx] * nowSum;\n\t}\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (numBoard[i][j] != -1) ans -= numBoard[i][j] * numBoard[i][j];\n\t\t}\n\t}\n\n\tcerr << add << endl;\n\n\tcout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// doot diddly donger cuckerino Hahahahahah\n \n#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int LL;\ntypedef unsigned int UINT;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PII;\ntypedef pair<string, int> PSI;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef vector<bool> VB;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef tuple<int, int, int> TPL;\ntypedef priority_queue<int> pqueue;\ntypedef priority_queue<int, VI, greater<int>> pdqueue;\n \nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, 1, 0, -1, -1, 1, -1, 1};\nconst int dxhorse[] = {-2, -2, -1, -1, 1, 1, 2, 2};\nconst int dyhorse[] = {1, -1, 2, -2, 2, -2, 1, -1};\n \n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define endl \"\\n\"\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define F first\n#define S second\n#define SZ(x)           (x).size()\n#define MAX(a, b)      ((a)>(b)?(a):(b))\n#define MIN(a, b)      ((a)<(b)?(a):(b))\n#define ALL(a)         std::begin(a), std::end(a)\n#define Fill(n, x)      memset(n,x,sizeof n);\n#define IN_REP         int _t; cin >> _t ; while(_t--)\n#define IOS            ios::sync_with_stdio(false);cin.tie(NULL)\n#define FOR(i, a, b)    for(int i=(a);i<(b);i++)\n#define REP(i, n)       FOR(i,0,n)\n#define FORR(i, n)      for(int i=(n);i>=0;i--)\n#define EPS (double) 1e-9\n#define MOD (1000*1000*1000 + 7)\n#define INF 1011111111\n#define LLINF 1000111000111000111LL\nint n;\nVS c;\nVVI a;\nmap<PII, VPII> mp;\n \nbool reachable(int x1, int y1, int x2, int y2) {\n    if (x2 < x1 || y2 < y1 || x1 < 0 || x2 < 0 || y1 >= n || y2 >= n || x1 >= n || x2 >= n || y1 < 0 || y2 < 0) {\n        return false;\n    }\n    if (c[x1][y1] == '#') return false;\n    if (x1 == x2 && y1 == y2)return true;\n    return reachable(x1 + 1, y1, x2, y2) || reachable(x1, y1 + 1, x2, y2);\n}\n \nvoid pre() {\n    IOS;\n    //freopen(\"/home/whiteknife/Workspace/CLionProjects/untitled/in\", \"r\", stdin);\n    cin >> n;\n    a.resize(n, VI(n, 0));\n    c.resize(n);\n//    v.resize(n, VB(n, false));\n    REP(i, n)cin >> c[i];\n    REP(i, n)REP(j, n)if (c[i][j] != '#') a[i][j] = (c[i][j] - '0');\n    FOR(i, 0, n) {\n        FOR(j, 0, n) {\n            FOR(k, i, n) {\n                FOR(l, j, n) {\n                    if ((i == k && j == l)) continue;\n                    if (reachable(i, j, k, l))mp[MP(i, j)].PB(MP(k, l));\n                }\n            }\n        }\n    }\n}\n \nint main() {\n    pre();\n    LL ans = 0;\n    REP(i, n) {\n        REP(j, n) {\n            if (c[i][j] == '#')continue;\n            FOR(k, i, n) {\n                FOR(l, j, n) {\n                    if (i == k && j == l)continue;\n                    if (find(ALL(mp[MP(i, j)]), MP(k, l)) != mp[MP(i, j)].end()) ans += a[i][j] * a[k][l];\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[2][N],r[2][N],flag[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tint t=x&1;\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=x?A[x][j]-'0':0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x][j]){\n\t\t\t\tl[t][j]=j;\n\t\t\t\tr[t][j]=max(r[t][j+1],j);\n\t\t\t\tif (l[t][j]<=r[t][j])ans+=(A[x][j]-'0')*(S[r[t][j]]-S[l[t][j]-1]-A[x][j]+'0');\n\t\t\t}\n\t\t\telse l[t][j]=1e9,r[t][j]=-1;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tint t=i&1;\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tl[t][j]=min(l[t][j+1],l[t^1][j]);\n\t\t\t\t\tr[t][j]=max(r[t][j+1],r[t^1][j]);\n\t\t\t\t\tif (l[t][j]<=r[t][j])ans+=(A[i][j]-'0')*(S[r[t][j]]-S[l[t][j]-1]);\n\t\t\t\t}\n\t\t\t\telse l[t][j]=1e9,r[t][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n \n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n \nint main () {\n//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]];\n\t\t\t\t\tlas_r=r[k][j];\n\t\t\t\t//\tl[k][j]=min(l[k][j],l[k][j+1]);\n\t\t\t\t//\tr[k][j]=max(r[k][j],r[k][j+1]);\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    while(wek.size() < (v/d)+2) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trepn(x,9) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(C[f[x][y]-'0']);\n\t\t\t\tif(x) repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nconst int maxn = 550;\n\nint n, m, a[maxn][maxn], s[maxn][maxn];\nshort fl[maxn][maxn][maxn], fr[maxn][maxn][maxn];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstatic char str[maxn];\n\t\tscanf(\"%s\", str + 1);\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\ta[i][j] = (str[j] == '#' ? 0 : str[j] - '0'), s[i][j] = s[i][j - 1] + a[i][j];\n\t\t\tfor (int k = 1; k <= n; ++k) fl[i][j][k] = n, fr[i][j][k] = 0;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = n; i; --i) for (int j = n; j; --j) if(a[i][j]) {\n\t\tfl[i][j][i] = fr[i][j][i] = j;\n\t\tif(a[i + 1][j]) for (int k = i + 1; k <= n; ++k) fl[i][j][k] = min(fl[i][j][k], fl[i + 1][j][k]), fr[i][j][k] = max(fr[i][j][k], fr[i + 1][j][k]);\n\t\tif(a[i][j + 1]) for (int k = i; k <= n; ++k) fl[i][j][k] = min(fl[i][j][k], fl[i][j + 1][k]), fr[i][j][k] = max(fr[i][j][k], fr[i][j + 1][k]);\n\t\tint sum = 0;\n\t\tfor (int k = i; k <= n; ++k) {\n\t\t\tif(fl[i][j][k] > fr[i][j][k]) break;\n\t\t\tsum += s[k][fr[i][j][k]] - s[k][fl[i][j][k] - 1];\n\t\t}\n\t\tans += (long long) a[i][j] * (sum - a[i][j]);\n\n\t\tfunction<void(int, int)> del = [&](int x, int y) {\n\t\t\tif(!a[x][y]) return;\n\t\t\tif(!a[x][y - 1] && !a[x - 1][y]) {\n\t\t\t\tfor (int i = y; i <= n; ++i) s[x][i] -= a[x][y];\n\t\t\t\ta[x][y] = 0;\n\t\t\t\tdel(x, y + 1);\n\t\t\t\tdel(x + 1, y);\n\t\t\t}\n\t\t\treturn;\n\t\t};\n\t\tdel(i, j);\n\t}\n\tprintf(\"%\"LLFORMAT\"d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nvector<int> C[N],D[N];\nint val[N][N],b[N][N],S[N],n,u[N][N],l[N],r[N];\nchar A[N][N];\nbool flag[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9',b[i][j]=A[i][j]-'0';\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)\n\t\t\tif (flag[i][j])C[i].push_back(j);\n\t\t\telse D[i].push_back(j);\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=x?b[x][j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x][j]){\n\t\t\t\tl[j]=j-1;\n\t\t\t\tr[j]=max(r[j+1],j);\n\t\t\t\tval[x][j]+=(S[r[j]]-S[l[j]]-b[x][j]);\n\t\t\t}\n\t\t\telse l[j]=n+1,r[j]=0;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?b[x][j]:0);\n\t\t\tfor (int j:D[i])l[j]=n+1,r[j]=0;\n\t\t\tfor (int j:C[i]){\n\t\t\t\tval[i][j]+=S[r[j]=max(r[j+1],r[j])];\n\t\t\t\tval[i][j]-=S[l[j]=min(l[j+1],l[j])];\n\t\t\t}\n\t\t}\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)ans+=val[i][j]*b[i][j];\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nconst int MN = 550;\nint N;\nusing B = bitset<MN>;\nint g[MN][MN];\n\n\nB used[MN][MN];\n\nint L, R, D, U;\nvoid dfs_up(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    if (g[a][b] == 0 || used[a][b][id]) return;\n    used[a][b][id] = true;\n    dfs_up(a-1, b, id); dfs_up(a, b-1, id);\n}\n\nvoid dfs_dw(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    if (g[a][b] == 0 || used[a][b][id]) return;\n    used[a][b][id] = true;\n    dfs_dw(a+1, b, id); dfs_dw(a, b+1, id);\n}\n\nint ans = 0;\n\nvoid solve(int l, int r, int d, int u) {\n    if (r < l || u < d) return;\n    if (l == r && d == u) return;\n    L = l; R = r; D = d; U = u;\n    for (int x = l; x <= r; x++) {\n        for (int y = d; y <= u; y++) {\n            used[x][y] = B();\n        }\n    }\n    if (r-l > u-d) {\n        int m = (l+r)/2;\n        for (int y = d; y <= u; y++) {\n            dfs_up(m, y, y);\n        }\n        for (int y = u; y >= d; y--) {\n            dfs_dw(m+1, y, y);\n        }\n        unordered_map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (x <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if ((p1.first & p2.first).count()) ans += p1.second * p2.second;\n            }\n        }\n        solve(l, m, d, u);\n        solve(m+1, r, d, u);\n    } else {\n        int m = (d+u)/2;\n\n        for (int x = l; x <= r; x++) {\n            dfs_up(x, m, x);\n        }\n        for (int x = r; x >= l; x--) {\n            dfs_dw(x, m+1, x);\n        }\n        unordered_map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (y <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if ((p1.first & p2.first).count()) ans += p1.second * p2.second;\n            }\n        }\n        solve(l, r, d, m);\n        solve(l, r, m+1, u);\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(20) << fixed;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        string s;\n        cin >> s;\n        for (int j = 1; j <= N; j++) {\n            int d = 0;\n            if (isdigit(s[j-1])) d = s[j-1] - '0';\n            g[i][j] = d;\n            //ans -= d*d;\n        }\n    }\n    solve(1, N, 1, N);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint b[N][N],S[N],n,u[N][N],l[2][N],r[2][N],flag[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9',b[i][j]=A[i][j]-'0';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tint t=x&1;\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=x?b[x][j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x][j]){\n\t\t\t\tl[t][j]=j;\n\t\t\t\tr[t][j]=max(r[t][j+1],j);\n\t\t\t\tif (l[t][j]<=r[t][j])ans+=b[x][j]*(S[r[t][j]]-S[l[t][j]-1]-b[x][j]);\n\t\t\t}\n\t\t\telse l[t][j]=1e9,r[t][j]=-1;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tint t=i&1;\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?b[x][j]:0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tl[t][j]=min(l[t][j+1],l[t^1][j]);\n\t\t\t\t\tr[t][j]=max(r[t][j+1],r[t^1][j]);\n\t\t\t\t\tif (l[t][j]<=r[t][j])ans+=b[i][j]*(S[r[t][j]]-S[l[t][j]-1]);\n\t\t\t\t}\n\t\t\t\telse l[t][j]=1e9,r[t][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef double dbl;\n\n/*\nconst ll SZ = 2e9;\nchar buf[SZ];\nll csz;\nvoid *operator new(size_t sz) {\n    assert(csz + sz < SZ);\n    void *res = buf + csz;\n    csz += sz;\n    return res;\n}\nvoid operator delete(void*) {}\nvoid operator delete(void*, size_t) {}*/\n\nnamespace mod {\n    typedef long long ll;\n    const int MOD = (int)1e9 + 7;\n\n    void add(int &a, ll b) {\n        a = (a + b) % MOD;\n    }\n\n    int mul(int a, int b) {\n        return 1LL * a * b % MOD;\n    }\n\n    int bin(int a, ll n) {\n        int res = 1;\n        while (n) {\n            if (n & 1) res = 1LL * res * a % MOD;\n            a = 1LL * a * a % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    int inv(int x) {\n        return bin(x, MOD - 2);\n    }\n\n    vector<int> fct, ofct, rev;\n\n    void ensureFact(int n) {\n        if ((int)fct.size() > n) return;\n        int old = fct.size();\n        fct.resize(n + 1);\n        ofct.resize(n + 1);\n        rev.resize(n + 1);\n        if (old == 0) {\n            fct[0] = ofct[0] = 1;\n            rev[0] = 0;\n            old++;\n        }\n        for (int i = old; i <= n; i++) {\n            fct[i] = mul(fct[i - 1], i);\n            if (i == 1) rev[i] = 1;\n            else rev[i] = (MOD - mul(MOD / i, rev[MOD % i])) % MOD;\n            ofct[i] = mul(ofct[i - 1], rev[i]);\n        }\n    }\n\n    int getC(int n, int k) {\n        if (n < k || k < 0) return 0;\n        ensureFact(n);\n        return mul(fct[n], mul(ofct[k], ofct[n - k]));\n    }\n}\nusing namespace mod;\n\nconst int N = 500;\n\nll fast(vector<string> a) {\n    int n = a.size();\n\n    vector<vector<bitset<N>>> c(2 * n, vector<bitset<N>>(10));\n    //vector<vector<bitset<N>>> d(2 * n, vector<bitset<N>>(10));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i][j] == '#') a[i][j] = '0';\n            c[i + j][a[i][j] - '0'][j] = 1;\n        }\n    }\n    for (int i = 0; i < 2 * n; i++) c[i][0] = ~c[i][0];\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i][j] == '0') continue;\n            bitset<N> cur;\n            cur[j] = 1;\n            for (int sum = i + j + 1; sum < 2 * n - 1; sum++) {\n                unsigned long long *bb = (unsigned long long *)&cur;\n                unsigned long long *bbb = (unsigned long long *)&c[sum][0];\n\n                int mn = j + max(0, sum - (i + j) - (n - 1 - i));\n                int mx = min(n - 1, j + (sum - (i + j)));\n\n                //cur = (cur | (cur << 1)) & c[sum][0];\n                for (int l = mx / 64; l >= mn / 64; l--) {\n                  bb[l] |= bb[l] << 1;\n                  if (l) bb[l] |= bb[l - 1] >> 63;\n                  bb[l] &= bbb[l];\n                }\n\n\n                //int mn = 0, mx = n - 1;\n\n                int any = 0;\n\n                for (int t = 1; t <= 9; t++) {\n                    //int cnt = (cur & c[sum][t]).count();\n                    unsigned long long *b = (unsigned long long *)&c[sum][t];\n\n                    int cnt = 0;\n                    for (int l = mn / 64; l <= mx / 64; l++) {\n                        cnt += __builtin_popcountll(b[l] & bb[l]);\n                    }\n                    ans += (a[i][j] - '0') * cnt * t;\n                    any += cnt;\n                }\n                if (!any) break;\n            }\n        }\n    }\n    return ans;\n}\n\nvoid test() {\n    int n = 500;\n    vector<string> a(n, string(n, '9'));\n    cout << fast(a) << endl;\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n    exit(0);\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n    //test();\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<string> a(n);\n        for (int i = 0; i < n; i++) {\n          static char buf[111111];\n          scanf(\"%s\", buf);\n          a[i] = buf;\n        }\n\n        cout << fast(a) << endl;\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=1505;\nint n,ans,cnt[N];\nint a[N][N],S[N][N];\nint L[N][N],R[N][N];\nchar s[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFor(j,1,n) a[i][j]=(s[j]=='#'?0:s[j]-'0');\n\t\tFor(j,1,n) S[i][j]=S[i][j-1]+a[i][j];\n\t}\n\tFor(i,1,n) Rep(j,n+1,1)\n\t\tif (!a[i][j]) L[i][j]=n+1,R[i][j]=0;\n\t\telse{\n\t\t\tL[i][j]=j;\n\t\t\tR[i][j]=max(R[i][j+1],j);\n\t\t\tans+=a[i][j]*(S[i][R[i][j]]-S[i][j]); \n\t\t}\n\tRep(x,n,1) For(y,x+1,n){\n\t\tRep(j,n,1)\n\t\t\tif (a[x][j]){\n\t\t\t\tL[y][j]=min(L[y][j],L[y][j+1]);\n\t\t\t\tR[y][j]=max(R[y][j],R[y][j+1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tL[y][j]=n+1;\n\t\t\t\tR[y][j]=0;\n\t\t\t}\n\t\tFor(j,1,n) cnt[j]=0;\n\t\tFor(j,1,n)\n\t\t\tif (L[y][j]<=R[y][j]){\n\t\t\t\tans+=a[x][j]*(S[y][R[y][j]]-S[y][L[y][j]-1]);\n\t\t\t\t++cnt[L[y][j]];\n\t\t\t\t--cnt[R[y][j]+1];\n\t\t\t}\n\t\tFor(j,1,n){\n\t\t\tcnt[j]+=cnt[j-1];\n\t\t\tif (!cnt[j])\n\t\t\t\ta[y][j]=0;\n\t\t}\n\t\tFor(j,1,n)\n\t\t\tS[y][j]=S[y][j-1]+a[y][j];\n\t}\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "https://atcoder.jp/contests/agc028/tasks/agc028_f2"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\n#define N 514\nstring ma[N];\nint dp[N][N];//どこまで戻れるか\nint mx[N][N],mn[N][N];//ある層への最高・最低着地点（毎回計算する）\nlint num[N],sum[N];\nint main()\n{\n\tlint out=0;\n\tint n;\n\tcin>>n;\n\trep(i,n) cin>>ma[i];\n\trep(i,n) rep(j,n){\n\t\tdp[i][j]=N*2;\n\t\tif(ma[i][j]=='#') continue;\n\t\tdp[i][j]=i+j;\n\t\tif(i>0) dp[i][j]=min(dp[i][j],dp[i-1][j]);\n\t\tif(j>0) dp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t}\n\tfor(int i=n*2-2;i>=0;i--){\n\t\t//cout<<i<<endl;\n\t\trep(j,n+5) rep(k,n+5) mx[j][k]=-N,mn[j][k]=N;\n\t\tfor(int j=n-1;j>=0;j--) for(int k=n-1;k>=0;k--){\n\t\t\tif(j+k==i) mx[j][k]=mn[j][k]=j;\n\t\t\tif(j+k<i){\n\t\t\t\tif(ma[j][k]!='#'){\n\t\t\t\t\tif(j<n-1) mx[j][k]=max(mx[j][k],mx[j+1][k]),mn[j][k]=min(mn[j][k],mn[j+1][k]);\n\t\t\t\t\tif(k<n-1) mx[j][k]=max(mx[j][k],mx[j][k+1]),mn[j][k]=min(mn[j][k],mn[j][k+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<i<<j<<k<<mx[j][k]<<mn[j][k]<<endl;\n\t\t}\n\t\tfor(int j=i-1;j>=0;j--){\n\t\t\tmemset(num,0,sizeof(num));\n\t\t\tmemset(sum,0,sizeof(sum));\n\t\t\trep(k,n){\n\t\t\t\tint l=i-k;\n\t\t\t\tif(l>=0 && l<n && dp[k][l]<=j && ma[k][l]!='#') num[k]=(ma[k][l]-'0');\n\t\t\t\tsum[k+1]=sum[k]+num[k];\n\t\t\t}\n\t\t\trep(k,n){\n\t\t\t\tint l=j-k;\n\t\t\t\tif(l>=0 && l<n && mx[k][l]>=mn[k][l] && ma[k][l]!='#'){\n\t\t\t\t\t//cout<<i<<' '<<k<<' '<<l<<' '<<mx[k][l]<<' '<<mn[k][l]<<' '<<(sum[mx[k][l]+1]-sum[mn[k][l]])<<endl;\n\t\t\t\t\tout+=(ma[k][l]-'0')*(sum[mx[k][l]+1]-sum[mn[k][l]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nstruct state { int y, x; };\nstatic const int dx[] = {1, 0}, dy[] = {0, 1};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<string> s(n);\n\trep(i, n) {\n\t\tcin >> s[i];\n\t}\n\tvector<vector<long long>> sum(n, vector<long long> (n));\n\tfor (int i = n - 1; i >= 0; i --) {\n\t\tfor (int j = n - 1; j >= 0; j --) {\n\t\t\tif (s[i][j] == '#') continue;\n\t\t\tint a = s[i][j] - '0';\n\t\t\tif (i == n - 1 && j == n - 1) {\n\t\t\t\tsum[i][j] = a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == n - 1 || s[i + 1][j] == '#') {\n\t\t\t\tif (s[i][j + 1] == '#') {\n\t\t\t\t\tsum[i][j] = a;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tsum[i][j] = sum[i][j + 1] + a;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (j == n - 1 || s[i][j + 1] == '#') {\n\t\t\t\tif (s[i + 1][j] == '#') {\n\t\t\t\t\tsum[i][j] = a;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tsum[i][j] = sum[i + 1][j] + a;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (s[i + 1][j] == '#' && s[i][j + 1] == '#') {\n\t\t\t\tsum[i][j] = a;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\t/*\n\t\t\telse if (s[i + 1][j] != '#' && s[i][j + 1] != '#' && s[i + 1][j + 1] != '#') {\n\t\t\t\tsum[i][j] = sum[i + 1][j] + sum[i][j + 1] - sum[i + 1][j + 1] + a;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*/\n\t\t\tvector<vector<int>> used(n, vector<int> (n, -1));\n\t\t\tqueue<state> q;\n\t\t\tq.push({i, j});\n\t\t\tused[i][j] = 0;\n\t\t\tlong long sm = a;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tstate p = q.front(); q.pop();\n\t\t\t\tfor (int d = 0; d < 2; d ++) {\n\t\t\t\t\tint xx = p.x + dx[d], yy = p.y + dy[d];\n\t\t\t\t\tif (xx < 0 || xx >= n || yy < 0 || yy >= n) continue;\n\t\t\t\t\tif (used[yy][xx] != -1 || s[yy][xx] == '#') continue;\n\t\t\t\t\tsm += s[yy][xx] - '0';\n\t\t\t\t\tused[yy][xx] = used[p.y][p.x] + 1;\n\t\t\t\t\tq.push({yy, xx});\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i][j] = sm;\n\t\t}\n\t}\n\tlong long ans = 0;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (s[i][j] == '#') continue;\n\t\t\tlong long add = (sum[i][j] - (s[i][j] - '0')) * (long long) (s[i][j] - '0');\n\t\t\tans += add;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[505];\nll ans;\n\nint main(){\n\tscanf(\"%d\",&n); //n = 450; srand((unsigned)time(NULL));\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);/*for(int j=0;j<n;j++){\n\t    int a = rand()%10;\n\t    if(a == 0) f[i][j] = '#';\n\t    else f[i][j] = '0'+a;\n\t}*/\n\trep(i,n) B[i] = bity(n*n*9+5);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t\tif(x) oruj(B[x],B[x-1]);\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].licz());\n\t\t\t\trep(a,f[x][y]-'0') B[x].ustaw(9*(x*n+y)+a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <inttypes.h>\n#include <limits.h>\nusing namespace std;\n\nusing ll=int64_t;\n//#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#ifdef MAROON_LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\" SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int Nmax=510;\nint bot[Nmax][Nmax],l[Nmax],r[Nmax],imos[Nmax];\n\nsigned main(){\n\tint n=read();\n\tvector<string> g(n);\n\tREP(i,n)\n\t\tg[i]=readString();\n\t\n\tfor(int i=n-1;i>=0;i--)for(int j=n-1;j>=0;j--){\n\t\tif(g[i][j]!='#'){\n\t\t\tbot[i][j]=i;\n\t\t\tif(i+1<n&&g[i+1][j]!='#')\n\t\t\t\tchmax(bot[i][j],bot[i+1][j]);\n\t\t\tif(j+1<n&&g[i][j+1]!='#')\n\t\t\t\tchmax(bot[i][j],bot[i][j+1]);\n\t\t}else\n\t\t\tbot[i][j]=-1;\n\t}\n\t\n\tll ans=0;\n\tREP(top,n){\n\t\tFOR(i,top,n){\n\t\t\tREP(j,n)\n\t\t\t\timos[j]=0;\n\t\t\tREP(j,n)\n\t\t\t\tif(g[i][j]!='#'){\n\t\t\t\t\tif(i==top){\n\t\t\t\t\t\tr[j]=j;\n\t\t\t\t\t\tl[j]=j;\n\t\t\t\t\t}\n\t\t\t\t\tif(j>0){\n\t\t\t\t\t\tchmax(r[j],r[j-1]);\n\t\t\t\t\t\tchmin(l[j],l[j-1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(l[j]<=r[j]){\n\t\t\t\t\t\tint z=g[i][j]-'0';\n\t\t\t\t\t\timos[l[j]]+=z;\n\t\t\t\t\t\timos[r[j]+1]-=z;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tr[j]=-inf;\n\t\t\t\t\tl[j]=inf;\n\t\t\t\t}\n\t\t\tREP(j,n){\n\t\t\t\tif(bot[top][j]>=i)\n\t\t\t\t\tans+=imos[j]*(g[top][j]-'0');\n\t\t\t\timos[j+1]+=imos[j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n)REP(j,n)if(g[i][j]!='#')\n\t\tans-=(g[i][j]-'0')*(g[i][j]-'0');\n\t\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint vy[4] = { 1, 0, -1, 0 };\nint vx[4] = { 0, 1, 0, -1 };\n\nvector<string> board;\n\nint N;\n\nbool inside(int y, int x)\n{\n\treturn y >= 0 && x >= 0 && y < N && x < N;\n}\n\n\n\nint main() {\n\tcin >> N;\n\n\tvector<string> board(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> board[i];\n\t}\n\t\n\tvector<vector<int>> numBoard(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\n\t\t\t//if (rand() % 3 == 0) numBoard[i][j] == -1;\n\t\t\t//else numBoard[i][j] = 1;\n\t\t\tif (board[i][j] == '#') numBoard[i][j] = -1;\n\t\t\telse numBoard[i][j] = (int)(board[i][j] - '0');\n\t\t}\n\t}\n\n\tvector<vector<int>> maxLen(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (numBoard[sy][sx] == -1) continue;\n\t\t\tmaxLen[sy][sx] = 1;\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = sy + vy[k];\n\t\t\t\tint nx = sx + vx[k];\n\t\t\t\tif (inside(ny, nx) && maxLen[ny][nx] >= 1) {\n\t\t\t\t\tmaxLen[sy][sx] = max(maxLen[sy][sx], maxLen[ny][nx] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<int> q;\n\tvector<vector<int>> startUsed(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1 && maxLen[sy][sx] > 5)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 2; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//cerr << \"reset\" << endl;\n\n\n\tvector<vector<int>> used(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tint myTurn = 1;\n\n\tlong ans = 0;\n\tlong nowSum = 0;\n\n\twhile (!q.empty())\n\t{\n\t\tint start = q.front(); q.pop();\n\n\t\tif (start == -1)\n\t\t{\n\t\t\tmyTurn++;\n\t\t\tnowSum = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<int> q2;\n\t\tint sy = start >> 12;\n\t\tint sx = start & 0xFFF;\n\t\tused[sy][sx] = myTurn;\n\t\tq2.push(start);\n\n\n\t\twhile (!q2.empty())\n\t\t{\n\t\t\tint now = q2.front(); q2.pop();\n\t\t\tint y = now >> 12;\n\t\t\tint x = now & 0xFFF;\n\t\t\tnowSum += numBoard[y][x];\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t{\n\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tans += numBoard[sy][sx] * nowSum;\n\t}\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (numBoard[i][j] != -1) ans -= numBoard[i][j] * numBoard[i][j];\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 2000;\n\nint n;\nstring stmp[MAXN];\nint a[MAXN][MAXN];\nll go[MAXN][MAXN];\nint gd[MAXN][MAXN];\nint gr[MAXN][MAXN];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> stmp[i];\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (stmp[i][j] == '#')\n\t\t\t\ta[i][j] = 0;\n\t\t\telse\n\t\t\t\ta[i][j] = stmp[i][j] - '0';\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tif (a[i][j] == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i + 1 < n && j + 1 < n && a[i + 1][j] != 0 && a[i][j + 1] != 0) {\n\t\t\t\tgo[i][j] += go[i + 1][j];\n\t\t\t\tgo[i][j] += go[i][j + 1];\n\t\t\t\t//TODO: optimize\n\t\t\t\tfor (int k = i + 1; k < n && gd[j + 1][k] != -1; ++k) {\n\t\t\t\t\tif (gr[j][gd[j + 1][k]] == k)\n\t\t\t\t\t\tgo[i][j] -= go[k][gd[j + 1][k]];\n\t\t\t\t}\n\t\t\t\tgd[j][i] = j;\n\t\t\t\tfor (int x = j + 1; x < n && gr[j + 1][x] != -1; ++x)\n\t\t\t\t\tgr[j][x] = gr[j + 1][x];\n\t\t\t\tint st = i + 1;\n\t\t\t\twhile (st < n && gd[j][st] != -1)\n\t\t\t\t\t++st;\n\t\t\t\twhile (st < n && gd[j + 1][st] != -1)\n\t\t\t\t\tgd[j][st] = gd[j + 1][st], ++st;\n\t\t\t\tgr[j][j] = i;\n\t\t\t}\n\t\t\telse if (i + 1 < n && a[i + 1][j] != 0) {\n\t\t\t\tgo[i][j] += go[i + 1][j];\n\t\t\t\tgd[j][i] = j;\n\t\t\t\tgr[j][j] = i;\n\t\t\t}\n\t\t\telse if (j + 1 < n && a[i][j + 1] != 0) {\n\t\t\t\tgo[i][j] += go[i][j + 1];\n\t\t\t\tmemcpy(gr[j] + j + 1, gr[j + 1] + j + 1, sizeof(gr[0][0]) * (n - j - 1));\n\t\t\t\tmemcpy(gd[j] + i + 1, gd[j + 1] + i + 1, sizeof(gr[0][0]) * (n - i - 1));\n\t\t\t\tgd[j][i] = j;\n\t\t\t\tgr[j][j] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmemset(gr[j] + j + 1, -1, sizeof(gr[0][0]) * (n - j - 1));\n\t\t\t\tmemset(gd[j] + i + 1, -1, sizeof(gr[0][0]) * (n - i - 1));\n\t\t\t\tgd[j][i] = j;\n\t\t\t\tgr[j][j] = i;\n\t\t\t}\n\t\t\tans += go[i][j] * a[i][j];\n\t\t\tgo[i][j] += a[i][j];\n\t\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcout << go[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[N][N],r[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;i++)scanf(\"%s\",A[i]+1);\n\tfor (register int i=0;i<=n;i++)\n\t\tfor (register int j=0;j<=n;j++)u[i][j]=A[i][j]>='0'&&A[i][j]<='9'?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;x++){\n\t\tfor (register int i=x;i;i--){\n\t\t\tfor (register int j=1;j<=n;j++)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (register int j=n+1;j;j--){\n\t\t\t\tif (A[i][j]>='0'&&A[i][j]<='9'){\n\t\t\t\t\tif (i<x){\n\t\t\t\t\t\tl[i][j]=min(l[i][j+1],l[i+1][j]);\n\t\t\t\t\t\tr[i][j]=max(r[i][j+1],r[i+1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse l[i][j]=j,r[i][j]=max(j,r[i][j+1]);\n\t\t\t\t}\n\t\t\t\telse l[i][j]=1e9,r[i][j]=-1;\n\t\t\t\tif (l[i][j]<=r[i][j])ans+=(A[i][j]-'0')*(S[r[i][j]]-S[l[i][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include <bits/stdc++.h>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int LL\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nLL ans = 0;\nLL sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE]; \nLL dfs(int y,int x) {\n\tif (y > N or x > N) return 0;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x]) {\n\t\treturn 0;\n\t}\n\treached[y][x]=true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs2(int y, int x) {\n\tif (y > N or x > N) return 0;\n//\tcout << y << \" \" << x << endl;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x] == 0) return 0;\n\tif (reached[y - 1][x]) return 0;\n\t//cout << y << \" \" << x << endl;\n\treached[y][x] = 0;\n\tLL ret = 0;\n\tret += dfs2(y, x + 1);\n\tret += dfs2(y + 1, x);\n\n\treturn ret + A[y][x];\n}\nLL solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i,1, N) {\n\t\tsum+=dfs(x, i);\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tans +=( sum - A[x][i] )* A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tsum-=dfs2(x+1, i)+A[x][i];\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N;\n\tif (N >= 300) return 0;\n\tEFOR(i,1,N){\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1]-'0';\n\t\t}\n\t}\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    while(wek.size() < (v/d)+2) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trepn(x,9) rep(i,n) B[x][i] = bity(C[x]);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(C[f[x][y]-'0']);\n\t\t\t\tif(x) repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint val[N<<11|1],b[N<<11|1],S[N],n,u[N<<11|1],l[N],r[N],flag[N<<11|1];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i<<11|j]=A[i][j]>='0'&&A[i][j]<='9',b[i<<11|j]=A[i][j]-'0';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i<<11|j]=flag[i<<11|j]?min(i,min(u[(i-1)<<11|j],u[i<<11|(j-1)])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x<<11|j]<=x?b[x<<11|j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x<<11|j]){\n\t\t\t\tl[j]=j-1;\n\t\t\t\tr[j]=r[j+1]==-1?j:r[j+1];\n\t\t\t\tval[x<<11|j]+=S[r[j]]-S[l[j]]-b[x<<11|j];\n\t\t\t}\n\t\t\telse l[j]=n,r[j]=-1;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tint j;\n\t\t\tfor (j=1;j+7<=n;j+=8){\n\t\t\t\tS[j]=S[j]+(u[x<<11|j]<=i?b[x<<11|j]:0);\n\t\t\t\tS[j+1]=S[j]+(u[x<<11|j]<=i?b[x<<11|(j+1)]:0);\n\t\t\t\tS[j+2]=S[j-1]+(u[x<<11|j]<=i?b[x<<11|(j+2)]:0);\n\t\t\t\tS[j+3]=S[j-2]+(u[x<<11|j]<=i?b[x<<11|(j+3)]:0);\n\t\t\t\tS[j+4]=S[j-3]+(u[x<<11|j]<=i?b[x<<11|(j+4)]:0);\n\t\t\t\tS[j+5]=S[j-4]+(u[x<<11|j]<=i?b[x<<11|(j+5)]:0);\n\t\t\t\tS[j+6]=S[j-5]+(u[x<<11|j]<=i?b[x<<11|(j+6)]:0);\n\t\t\t\tS[j+7]=S[j-6]+(u[x<<11|j]<=i?b[x<<11|(j+7)]:0);\n\t\t\t}\n\t\t\tfor (;j<=n;j++)S[j]=S[j-1]+(u[x<<11|j]<=i?b[x<<11|j]:0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i<<11|j]){\n\t\t\t\t\tl[j]=min(l[j+1],l[j]);\n\t\t\t\t\tr[j]=max(r[j+1],r[j]);\n\t\t\t\t\tif (l[j]<=r[j])val[i<<11|j]+=(S[r[j]]-S[l[j]]);\n\t\t\t\t} \n\t\t\t\telse l[j]=n,r[j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)ans+=val[i<<11|j]*b[i<<11|j];\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nusing pi = pair< int, int >;\n\n\nint N;\nstring S[500];\nint dp[500][500];\n\nint in[500][500];\nbool used[500][500];\n\nint del_bfs(int y, int x) {\n  queue< pi > que;\n  que.emplace(y, x);\n  int ret = S[y][x] - '0';\n  while(que.size()) {\n    auto p = que.front();\n    que.pop();\n    if(p.first + 1 < N && S[p.first + 1][p.second] != '#') {\n      if(--in[p.first + 1][p.second] == 0) {\n        ret += S[p.first + 1][p.second] - '0';\n        que.emplace(p.first + 1, p.second);\n      }\n    }\n    if(p.second + 1 < N && S[p.first][p.second + 1] != '#') {\n      if(--in[p.first][p.second + 1] == 0) {\n        ret += S[p.first][p.second + 1] - '0';\n        que.emplace(p.first, p.second + 1);\n      }\n    }\n  }\n  return ret;\n}\n\nint add_bfs(int y, int x) {\n  queue< pi > que;\n  que.emplace(y, x);\n  int ret = 0;\n  ret += S[y][x] - '0';\n  while(que.size()) {\n    auto p = que.front();\n    que.pop();\n    if(p.first + 1 < N && S[p.first + 1][p.second] != '#') {\n      if(++in[p.first + 1][p.second] == 1) {\n        ret += S[p.first + 1][p.second] - '0';\n        que.emplace(p.first + 1, p.second);\n      }\n    }\n    if(p.second + 1 < N && S[p.first][p.second + 1] != '#') {\n      if(++in[p.first][p.second + 1] == 1) {\n        ret += S[p.first][p.second + 1] - '0';\n        que.emplace(p.first, p.second + 1);\n      }\n    }\n  }\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> S[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  int64 all = 0;\n  for(int i = 0; i < N; i++) {\n    vector< int > lis{-1};\n    for(int j = 0; j < N; j++) {\n      if(S[i][j] == '#') lis.emplace_back(j);\n    }\n    lis.emplace_back(N);\n    for(int j = 0; j + 1 < lis.size(); j++) {\n      int l = lis[j] + 1, r = lis[j + 1] - 1;\n      if(l > r) continue;\n      int64 sub = add_bfs(i, l);\n\n      all += (sub - (S[i][l] - '0')) * (S[i][l] - '0');\n\n      for(int k = l + 1; k <= r + 1; k++) {\n        if(i + 1 < N && S[i + 1][k - 1] != '#') {\n          --in[i + 1][k - 1];\n          sub -= del_bfs(i + 1, k - 1);\n        }\n        sub -= S[i][k - 1] - '0';\n        if(k <= r) {\n          all += (sub - (S[i][k] - '0')) * (S[i][k] - '0');\n        }\n      }\n    }\n  }\n  cout << all << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": " #pragma GCC target(\"avx\")  // CPU 処理並列化\n #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[1510][1510];\nint p[1510][1510];\nint ks[1510][1510];\nint L[1510][1510];\nint R[1510][1510];\nint fr[1510][1510];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",in[i]);\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\tif(in[i][j]=='#')continue;\n\t\tp[i][j]=in[i][j]-'0';\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\tfr[i][j]=a;\n\t\tif(p[i][j]==0){\n\t\t\tfor(int k=0;k<=i;k++){\n\t\t\t\tL[j][k]=a;\n\t\t\t\tR[j][k]=-1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfr[i][j]=i;\n\t\tif(i)fr[i][j]=min(fr[i][j],fr[i-1][j]);\n\t\tif(j)fr[i][j]=min(fr[i][j],fr[i][j-1]);\n\t\tif(i)ks[i][j]+=ks[i-1][j];\n\t\tif(j)ks[i][j]+=ks[i][j-1];\n\t\tif(i&&p[i-1][j]&&j&&p[i][j-1]){\n\t\t\tL[j][i]=L[j-1][i];\n\t\t\tR[j][i]=j;\n\t\t\tint r=a;\n\t\t\tfor(int k=i-1;k>=fr[i][j];k--){\n\t\t\t\tif(R[j-1][k]>=L[j][k]&&r>R[j-1][k]){\n\t\t\t\t\tks[i][j]-=ks[k][R[j-1][k]];\n\t\t\t\t}\n\t\t\t\tr=min(r,L[j][k]);\n\t\t\t\tL[j][k]=min(L[j][k],L[j-1][k]);\n\t\t\t\tR[j][k]=max(R[j][k],R[j-1][k]);\n\t\t\t}\n\t\t}else if(i&&p[i-1][j]){ // ue ga aiteru\n\t\t\tL[j][i]=R[j][i]=j;\n\t\t}else if(j&&p[i][j-1]){ // hidari ga aiteru\n\t\t\tfor(int k=0;k<=i;k++){\n\t\t\t\tL[j][k]=L[j-1][k];\n\t\t\t\tR[j][k]=R[j-1][k];\n\t\t\t}\n\t\t\tR[j][i]=j;\n\n\t\t}else{\n\t\t\tL[j][i]=R[j][i]=j;\n\t\t}\n\n\t\tret+=ks[i][j]*p[i][j];\n\t\tks[i][j]+=p[i][j];\n\t\t// printf(\"%d \",ks[i][j]);\n\t\t// if(j==a-1)printf(\"\\n\");\n\t}\n\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  cin >> n;\n  vector<string> board(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> board[i];\n  }\n  vector<vector<int>> sum(n, vector<int> (n + 1));\n  \n  auto recalc_sum = [&](int x) {\n    for (int i = 0; i < n; ++i) {\n      sum[x][i + 1] = sum[x][i] + (board[x][i] == '#' ? 0 : board[x][i] - '0');\n    }\n  };\n\n  auto calc_sum = [&](int x, int l, int r) {\n    return sum[x][r + 1] - sum[x][l];\n  };\n\n  for (int i = 0; i < n; ++i) {\n    recalc_sum(i);\n  }\n\n  vector<vector<int>> l(n, vector<int> (n, n)), r(n, vector<int> (n, -1));\n  long long answer = 0;\n  for (int x = n - 1; ~x; --x) {\n    vector<vector<int>> tl(n, vector<int> (n, n)), tr(n, vector<int> (n, -1));\n    for (int z = x; z < n; ++z) {\n      if (z == x) {\n        for (int y = n - 1; ~y; --y) {\n          if (board[x][y] != '#') {\n            tl[z][y] = y;\n            tr[z][y] = max(y, y + 1 < n ? tr[z][y + 1] : -1);\n            answer += (board[x][y] - '0') * calc_sum(z, tl[z][y] + 1, tr[z][y]);\n          }\n        }\n      } else {\n        for (int y = n - 1; ~y; --y) {\n          if (board[x][y] != '#') {\n            tl[z][y] = min(l[z][y], y + 1 < n ? tl[z][y + 1] : n);\n            tr[z][y] = max(r[z][y], y + 1 < n ? tr[z][y + 1] : -1);\n          }\n        }\n        vector<int> visit(n + 1);\n        for (int y = 0; y < n; ++y) {\n          if (tl[z][y] <= tr[z][y]) {\n            ++visit[tl[z][y]];\n            --visit[tr[z][y] + 1];\n          }\n        }\n        for (int y = 0; y < n; ++y) {\n          if (y) {\n            visit[y] += visit[y - 1];\n          }\n          if (!visit[y]) {\n            if (board[z][y] != '#') {\n              board[z][y] = '#';\n              recalc_sum(z);\n            }\n          }\n        }\n        for (int y = 0; y < n; ++y) {\n          if (tl[z][y] <= tr[z][y]) {\n            answer += (board[x][y] - '0') * calc_sum(z, tl[z][y], tr[z][y]);\n          }\n        }\n      }\n    }\n    l = tl;\n    r = tr;\n  }\n\n  cout << answer << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 64\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v){\n\t    wek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trep(x,10) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+5);\n\t\t\t\tif(x) rep(w,10) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trep(w,10) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(w,10) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\n#define N 514\nstring ma[N];\nint dp[N][N];//どこまで戻れるか\nint mx[N][N],mn[N][N];//ある層への最高・最低着地点（毎回計算する）\nlint num[N],sum[N];\nint main()\n{\n\tlint out=0;\n\tint n;\n\tcin>>n;\n\trep(i,n) cin>>ma[i];\n\trep(i,n) rep(j,n){\n\t\tdp[i][j]=N*2;\n\t\tif(ma[i][j]=='#') continue;\n\t\tdp[i][j]=i+j;\n\t\tif(i>0) dp[i][j]=min(dp[i][j],dp[i-1][j]);\n\t\tif(j>0) dp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t}\n\tfor(int i=n*2-2;i>=0;i--){\n\t\t//cout<<i<<endl;\n\t\trep(j,n+5) rep(k,min(n,i-j)+5) mx[j][k]=-N,mn[j][k]=N;\n\t\tfor(int j=n-1;j>=0;j--) for(int k=n-1;k>=0;k--){\n\t\t\tif(j+k==i) mx[j][k]=mn[j][k]=j;\n\t\t\tif(j+k<i){\n\t\t\t\tif(ma[j][k]!='#'){\n\t\t\t\t\tif(j<n-1) mx[j][k]=max(mx[j][k],mx[j+1][k]),mn[j][k]=min(mn[j][k],mn[j+1][k]);\n\t\t\t\t\tif(k<n-1) mx[j][k]=max(mx[j][k],mx[j][k+1]),mn[j][k]=min(mn[j][k],mn[j][k+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<i<<j<<k<<mx[j][k]<<mn[j][k]<<endl;\n\t\t}\n\t\tfor(int j=i-1;j>=0;j--){\n\t\t\tmemset(num,0,sizeof(num));\n\t\t\tmemset(sum,0,sizeof(sum));\n\t\t\trep(k,n){\n\t\t\t\tint l=i-k;\n\t\t\t\tif(l>=0 && l<n && dp[k][l]<=j && ma[k][l]!='#') num[k]=(ma[k][l]-'0');\n\t\t\t\tsum[k+1]=sum[k]+num[k];\n\t\t\t}\n\t\t\trep(k,n){\n\t\t\t\tint l=j-k;\n\t\t\t\tif(l>=0 && l<n && mx[k][l]>=mn[k][l] && ma[k][l]!='#'){\n\t\t\t\t\t//cout<<i<<' '<<k<<' '<<l<<' '<<mx[k][l]<<' '<<mn[k][l]<<' '<<(sum[mx[k][l]+1]-sum[mn[k][l]])<<endl;\n\t\t\t\t\tout+=(ma[k][l]-'0')*(sum[mx[k][l]+1]-sum[mn[k][l]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S[2020];\nint preT[1515][1515],preD[1515][1515];\nint curT[1515][1515],curD[1515][1515];\nint pT[1515],pD[1515];\nint cT[1515],cD[1515];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y,x2,y2; string s;\n\t\n\tcin>>N;\n\tFOR(y,N) {\n\t\tcin>>S[y];\n\t\tFORR(c,S[y]) {\n\t\t\tif(c!='#') c-='0';\n\t\t\telse c=0;\n\t\t}\n\t}\n\tll ret=0;\n\tFOR(x,N) {\n\t\tFOR(y,N) {\n\t\t\tFOR(x2,x+1) {\n\t\t\t\tcurT[x2][y]=N;\n\t\t\t\tcurD[x2][y]=-1;\n\t\t\t\tif(S[y][x]) {\n\t\t\t\t\tif(x==x2) curT[x][y]=curD[x][y]=y;\n\t\t\t\t\tif(x2<x && S[y][x-1]) {\n\t\t\t\t\t\tcurT[x2][y]=min(curT[x2][y],preT[x2][y]);\n\t\t\t\t\t\tcurD[x2][y]=max(curD[x2][y],preD[x2][y]);\n\t\t\t\t\t}\n\t\t\t\t\tif(y && S[y-1][x]) {\n\t\t\t\t\t\tcurT[x2][y]=min(curT[x2][y],curT[x2][y-1]);\n\t\t\t\t\t\tcurD[x2][y]=max(curD[x2][y],curD[x2][y-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(x2=x;x2>=0;x2--) {\n\t\t\tfor(y=N-1;y>=0;y--) {\n\t\t\t\tif(S[y][x2]==0) cT[y]=N,cD[y]=-1;\n\t\t\t\telse cT[y]=cD[y]=y;\n\t\t\t\tif(x2<x && S[y][x2+1]) {\n\t\t\t\t\tcT[y]=min(cT[y],pT[y]);\n\t\t\t\t\tcD[y]=max(cD[y],pD[y]);\n\t\t\t\t}\n\t\t\t\tif(y<N-1 && S[y+1][x2]) {\n\t\t\t\t\tcT[y]=min(cT[y],cT[y+1]);\n\t\t\t\t\tcD[y]=max(cD[y],cD[y+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(y,N) {\n\t\t\t\tFOR(y2,N) {\n\t\t\t\t\tif(cT[y2]<=y && cD[y2]>=y && curT[x2][y]<=y2 && curD[x2][y]>=y2) ret+=S[y2][x2]*S[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tswap(cT,pT);\n\t\t\tswap(cD,pD);\n\t\t}\n\t\t\n\t\tswap(preT,curT);\n\t\tswap(preD,curD);\n\t}\n\tFOR(y,N) FOR(x,N) ret-=S[y][x]*S[y][x];\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint b[N][N],S[N],n,u[N][N],l[N],r[N];\nchar A[N][N];\nbool flag[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9',b[i][j]=A[i][j]-'0';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=x?b[x][j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x][j]){\n\t\t\t\tl[j]=j-1;\n\t\t\t\tr[j]=max(r[j+1],j);\n\t\t\t\tans+=b[x][j]*(S[r[j]]-S[l[j]]-b[x][j]);\n\t\t\t}\n\t\t\telse l[j]=1e9,r[j]=-1;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?b[x][j]:0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tl[j]=min(l[j+1],l[j]);\n\t\t\t\t\tr[j]=max(r[j+1],r[j]);\n\t\t\t\t\tif (l[j]<=r[j])ans+=b[i][j]*(S[r[j]]-S[l[j]]);\n\t\t\t\t}\n\t\t\t\telse l[j]=1e9,r[j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n\n#define _SILENCE_CXX17_C_HEADER_DEPRECATION_WARNING\n#include <bits/stdc++.h>\n\n#include<unordered_set>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n#define PRINT(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,p) scanf(\"%d %d %d %d\",&n,&m,&o,&p)\n#define SINT5(n,m,o,p,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&p,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 1000000009;\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\t\n#define sc  second\n\n\n\nll  a[2048][2048] = {};\nbool p[2048][2048];\n\nint main() {\n\tint n;\n\tcin >> n;\n\tFILL0(a);\n\trep(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j, n) {\n\t\t\tif (s[j] == '#') a[i][j] = INF;\n\t\t\telse             a[i][j] = s[j] - '0';\n\t\t}\n\t}\n\tll ret = 0;\n\n\n\tRep(y, n) {\n\t\tll r = 0;\n\t\tFILL0(p);\n\t\tqueue<Pi> Q;\n\t\tRep(x, n) {\n\t\t\tif (a[y][x] == INF) {\n\t\t\t\tr = 0;\n\t\t\t\tFILL0(p);\n\t\t\t\t//printf(\"  0 \");\n\t\t\t} else {\n\t\t\t\tQ.push({ y + 1, x });\n\t\t\t\tQ.push({ y, x + 1 });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint i = Q.front().first;\n\t\t\t\t\tint j = Q.front().second; Q.pop();\n\t\t\t\t\tif (i >= n || j >= n) continue;\n\t\t\t\t\tif (a[i][j] == INF) continue;\n\t\t\t\t\tif (p[i][j]) continue;\n\t\t\t\t\tp[i][j] = true;\n\t\t\t\t\tr += a[i][j];\n\t\t\t\t\tQ.push({ i + 1, j });\n\t\t\t\t\tQ.push({ i, j + 1 });\n\t\t\t\t}\n\t\t\t\t//printf(\"%3lld \", r);\n\t\t\t\tret += a[y][x] * r;\n\t\t\t}\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tcout << ret << endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\n#define N 514\nstring ma[N];\nint dp[N][N];//どこまで戻れるか\nint mx[N][N],mn[N][N];//ある層への最高・最低着地点（毎回計算する）\nlint num[N],sum[N];\nint main()\n{\n\tlint out=0;\n\tint n;\n\tcin>>n;\n\trep(i,n) cin>>ma[i];\n\trep(i,n) rep(j,n){\n\t\tdp[i][j]=N;\n\t\tif(ma[i][j]=='#') continue;\n\t\tdp[i][j]=i+j;\n\t\tif(i>0) dp[i][j]=min(dp[i][j],dp[i-1][j]);\n\t\tif(j>0) dp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t}\n\tfor(int i=n*2-2;i>=0;i--){\n\t\t//cout<<i<<endl;\n\t\trep(j,n+5) rep(k,n+5) mx[j][k]=-N,mn[j][k]=N;\n\t\tfor(int j=n-1;j>=0;j--) for(int k=n-1;k>=0;k--){\n\t\t\tif(j+k==i) mx[j][k]=mn[j][k]=j;\n\t\t\tif(j+k<i){\n\t\t\t\tif(ma[j][k]!='#'){\n\t\t\t\t\tif(j<n-1) mx[j][k]=max(mx[j][k],mx[j+1][k]),mn[j][k]=min(mn[j][k],mn[j+1][k]);\n\t\t\t\t\tif(k<n-1) mx[j][k]=max(mx[j][k],mx[j][k+1]),mn[j][k]=min(mn[j][k],mn[j][k+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<i<<j<<k<<mx[j][k]<<mn[j][k]<<endl;\n\t\t}\n\t\tfor(int j=i-1;j>=0;j--){\n\t\t\tmemset(num,0,sizeof(num));\n\t\t\tmemset(sum,0,sizeof(sum));\n\t\t\trep(k,n){\n\t\t\t\tint l=i-k;\n\t\t\t\tif(l>=0 && l<n && dp[k][l]<=j && ma[k][l]!='#') num[k]=(ma[k][l]-'0');\n\t\t\t\tsum[k+1]=sum[k]+num[k];\n\t\t\t}\n\t\t\trep(k,n){\n\t\t\t\tint l=j-k;\n\t\t\t\tif(l>=0 && l<n && mx[k][l]>=mn[k][l] && ma[k][l]!='#'){\n\t\t\t\t\t//cout<<i<<' '<<k<<' '<<l<<' '<<mx[k][l]<<' '<<mn[k][l]<<' '<<(sum[mx[k][l]+1]-sum[mn[k][l]])<<endl;\n\t\t\t\t\tout+=(ma[k][l]-'0')*(sum[mx[k][l]+1]-sum[mn[k][l]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline void upi(int&a,const int&b){a>b?a=b:0;}\nconst int N=1505;\nint n,i,j,x,a[N][N];\nchar c[N][N];\nlong long ans;\nint L[N][N],R[N][N],B[N],tB[N][N],Mp[N][N],tMp[N][N],Rch[N];\nint s1[N][N],s2[N][N],s3[N][N],Lu[N][N],Ru[N][N],T[N],tT[N][N],sm,only[N];\nint q[N],xb,lp,rp,q2[N],t,w;\ninline int Brh(int x,int y,int l){l=min(l,min(B[x],B[y]));return l<Mp[x][y]?0:s1[l][n]-s1[l][y-1]-s2[l][x+1]+s3[x+1][y-1];}\ninline void upd(int w){\n\tx=Brh(q2[w],q[rp],min(B[q2[w]],B[q[rp]]))-(q2[w+1]?Brh(q2[w],q[rp],B[q2[w+1]]):0);\n\tsm-=x;only[q2[w]]-=x;\n}\nvoid solve(int lb,int rb){\n\tif(lb==rb)return;int mid=lb+rb>>1;solve(lb,mid);solve(mid+1,rb);\n\tfor(i=mid+1;i<=rb+1;++i)for(j=0;j<=n+1;++j)L[i][j]=N,R[i][j]=0,tB[i][j]=0;\n\tfor(i=mid+1;i<=rb;++i)memset(s1[i],0,n+2<<2),memset(s2[i],0,n+2<<2);for(i=1;i<=n;++i)memset(s3[i]+i,0,n-i+1<<2);\n\tfor(i=1;i<=n;++i)for(j=i;j<=n;++j)tMp[i][j]=N;\n\tfor(j=1;j<=n;++j)if(a[mid+1][j])L[mid+1][j]=a[mid+1][j-1]?L[mid+1][j-1]:j,R[mid+1][j]=j;\n\tfor(i=mid+2;i<=rb;++i)for(j=1;j<=n;++j)if(a[i][j])\n\t\tL[i][j]=min(L[i-1][j],L[i][j-1]),R[i][j]=max(R[i-1][j],R[i][j-1]);\n\tfor(i=rb;i>=mid+1;--i)for(j=n;j;--j)if(a[i][j])tB[i][j]=max(i,max(tB[i+1][j],tB[i][j+1]));memcpy(B,tB[mid+1],n+2<<2);\n\n\tfor(i=mid+1;i<=rb;++i)for(j=1;j<=n;++j)if(R[i][j])upi(tMp[L[i][j]][R[i][j]],i);\n\tfor(i=1;i<n;++i)for(j=n;j>i;--j)upi(tMp[i][j-1],tMp[i][j]);\n\tfor(i=1;i<n;++i)for(j=i+1;j<=n;++j)upi(tMp[i+1][j],tMp[i][j]);\n\tfor(i=1;i<n;++i)for(j=i;j<=n;++j)if(a[mid+1][i] && a[mid+1][j])\n\t\tMp[i][j]=tMp[i][j]<=min(B[i],B[j])?tMp[i][j]:N;\n\tfor(i=mid+1;i<=rb;++i)for(j=1;j<=n;++j)if(R[i][j])\n\t\ts1[i][R[i][j]]+=a[i][j],s2[i][L[i][j]]+=a[i][j],s3[L[i][j]][R[i][j]]+=a[i][j];\n\tfor(i=mid+1;i<=rb;++i){\n\t\tfor(j=2;j<=n;++j)s1[i][j]+=s1[i][j-1];for(j=n-1;j;--j)s2[i][j]+=s2[i][j+1];\n\t\tif(i>mid+1)for(j=1;j<=n;++j)s1[i][j]+=s1[i-1][j],s2[i][j]+=s2[i-1][j];\n\t}\n\tfor(i=1;i<n;++i)for(j=i+1;j<=n;++j)s3[i][j]+=s3[i][j-1];\n\tfor(i=n-1;i;--i)for(j=i+1;j<=n;++j)s3[i][j]+=s3[i+1][j];\n\tfor(i=1;i<=n;++i)if(a[mid+1][i])Rch[i]=Brh(i,i,rb);\n\n\tfor(i=lb-1;i<=mid+1;++i)for(j=0;j<=n+1;++j)Lu[i][j]=N,Ru[i][j]=0,tT[i][j]=N;\n\tfor(j=n;j;--j)if(a[mid+1][j])Ru[mid+1][j]=a[mid+1][j+1]?Ru[mid+1][j+1]:j,Lu[mid+1][j]=j;\n\tfor(i=mid;i>=lb;--i)for(j=n;j;--j)if(a[i][j])\n\t\tLu[i][j]=min(Lu[i+1][j],Lu[i][j+1]),Ru[i][j]=max(Ru[i+1][j],Ru[i][j+1]);\n\tfor(i=lb;i<=mid+1;++i)for(j=1;j<=n;++j)if(a[i][j])tT[i][j]=min(i,min(tT[i-1][j],tT[i][j-1]));memcpy(T,tT[mid+1],n+2<<2);\n\t\n\tfor(i=mid;i>=lb;--i){\n\t\tlp=t=1;xb=rp=w=sm=0;for(j=1;j<=n;++j)if(T[j]<=i)q[++xb]=j;\n\t\tfor(j=1;j<=n;++j)if(Ru[i][j]){\n\t\t\tfor(;rp<xb && q[rp+1]<=Ru[i][j];){\nif(lb==1 && rb==n && rp==4)\n++j,--j;\n\t\t\t\t++rp;sm+=only[q[rp]]=Rch[q[rp]];for(;t<=w && B[q2[w]]<=B[q[rp]];--w)upd(w);\n\t\t\t\tif(t<=w)upd(w);q2[++w]=q[rp];q2[w+1]=0;\n\t\t\t}\n\t\t\tfor(;lp<=rp && q[lp]<Lu[i][j];)sm-=only[q[lp++]];for(;t<=w && q2[t]<Lu[i][j];++t);\nif(sm<0)\n++i,--i;\n\t\t\tans+=a[i][j]*sm;\n//if(lb==1 && rb==n)printf(\"%d %d:%d\\n\",i,j,sm);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)scanf(\"%s\",c[i]+1);\n\tfor(i=1;i<=n;++i)for(j=n,x=0;j;--j){\n\t\ta[i][j]=c[i][j]=='#'?0:c[i][j]-'0';\n\t\tif(a[i][j])ans+=x*a[i][j],x+=a[i][j];else x=0;\n\t}\n\tsolve(1,n);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include <bits/stdc++.h>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int LL\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nLL ans = 0;\nLL sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE]; \nLL dfs(int y,int x) {\n\tif (y > N or x > N) return 0;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x]) {\n\t\treturn 0;\n\t}\n\treached[y][x]=true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs2(int y, int x) {\n\tif (y > N or x > N) return 0;\n//\tcout << y << \" \" << x << endl;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x] == 0) return 0;\n\tif (reached[y - 1][x]) return 0;\n\t//cout << y << \" \" << x << endl;\n\treached[y][x] = 0;\n\tLL ret = 0;\n\tret += dfs2(y, x + 1);\n\tret += dfs2(y + 1, x);\n\n\treturn ret + A[y][x];\n}\nLL solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i,1, N) {\n\t\tsum+=dfs(x, i);\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tans +=( sum - A[x][i] )* A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tsum-=dfs2(x+1, i)+A[x][i];\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N;\n\tif (N >= 300) return 0;\n\tEFOR(i,1,N){\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1]-'0';\n\t\t}\n\t}\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]>r[k][j+1]) break;\n\t\t\t//\tif(i==2&&j==1) cout<<\"-_-\"<<las_r<<\" \"<<k<<\" \"<<l[k][j+1]<<endl;\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]],las_r=r[k][j+1];\n\t\t\t\t\tif(las_r>=l[k][j+1]) las_r=max(las_r,r[k][j+1]);\n\t\t\t\t\tif(l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\telse l[i][j]=n+1,r[i][j]=0;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\t/*\n\t\n\tfor1(1,n,i) {\n\t\tfor1(1,n,j) cout<<f[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\t*/\n\t\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 505;\nusing Bs = bitset<N * N>;\n\nBs bss[2][N];\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tint n = nxt();\n\tvector<string> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tlong long ans = 0;\n\tfor (int d = 1; d <= 9; d *= 2) {\n\t\tfor (int sum = n + n - 2, _ = 0; sum >= 0; --sum, _ ^= 1) {\n\t\t\tint l = max(0, sum - n + 1);\n\t\t\tint r = min(n - 1, sum);\n\t\t\tfor (int i = l; i <= r; ++i) {\n\t\t\t\tint j = sum - i;\n\t\t\t\tif (i == n - 1 && j == n - 1) {\n\t\t\t\t\tbss[_][i] = {};\n\t\t\t\t}\n\t\t\t\tif (a[i][j] == '#') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool fst = true;\n\t\t\t\tif (i + 1 < n && a[i + 1][j] != '#') {\n\t\t\t\t\tbss[_][i] = bss[_ ^ 1][i + 1];\n\t\t\t\t\tfst = false;\n\t\t\t\t}\n\t\t\t\tif (j + 1 < n && a[i][j + 1] != '#') {\n\t\t\t\t\tif (!fst) {\n\t\t\t\t\t\tbss[_][i] |= bss[_ ^ 1][i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbss[_][i] = bss[_ ^ 1][i];\n\t\t\t\t\t\tfst = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fst) {\n\t\t\t\t\tbss[_][i] = {};\n\t\t\t\t}\n\t\t\t\tans += ((long long)a[i][j] - '0') * d * bss[_][i].count();\n\t\t\t\tif ((a[i][j] - '0') & d) {\n\t\t\t\t\tbss[_][i].flip(i * n + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint val[N<<11|1],b[N<<11|1],S[N],n,u[N<<11|1],l[N],r[N],flag[N<<11|1];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i<<11|j]=A[i][j]>='0'&&A[i][j]<='9',b[i<<11|j]=A[i][j]-'0';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i<<11|j]=flag[i<<11|j]?min(i,min(u[(i-1)<<11|j],u[i<<11|(j-1)])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x<<11|j]<=x?b[x<<11|j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x<<11|j]){\n\t\t\t\tl[j]=j-1;\n\t\t\t\tr[j]=r[j+1]==-1?j:r[j+1];\n\t\t\t\tval[x<<11|j]+=S[r[j]]-S[l[j]]-b[x<<11|j];\n\t\t\t}\n\t\t\telse l[j]=n,r[j]=-1;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tint j;\n\t\t\tfor (j=1;j+7<=n;j+=8){\n\t\t\t\tS[j]=S[j]+(u[x<<11|j]<=i?b[x<<11|j]:0);\n\t\t\t\tS[j+1]=S[j]+(u[x<<11|(j+1)]<=i?b[x<<11|(j+1)]:0);\n\t\t\t\tS[j+2]=S[j-1]+(u[x<<11|(j+2)]<=i?b[x<<11|(j+2)]:0);\n\t\t\t\tS[j+3]=S[j-2]+(u[x<<11|(j+3)]<=i?b[x<<11|(j+3)]:0);\n\t\t\t\tS[j+4]=S[j-3]+(u[x<<11|(j+4)]<=i?b[x<<11|(j+4)]:0);\n\t\t\t\tS[j+5]=S[j-4]+(u[x<<11|(j+5)]<=i?b[x<<11|(j+5)]:0);\n\t\t\t\tS[j+6]=S[j-5]+(u[x<<11|(j+6)]<=i?b[x<<11|(j+6)]:0);\n\t\t\t\tS[j+7]=S[j-6]+(u[x<<11|(j+7)]<=i?b[x<<11|(j+7)]:0);\n\t\t\t}\n\t\t\tfor (;j<=n;j++)S[j]=S[j-1]+(u[x<<11|j]<=i?b[x<<11|j]:0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i<<11|j]){\n\t\t\t\t\tl[j]=min(l[j+1],l[j]);\n\t\t\t\t\tr[j]=max(r[j+1],r[j]);\n\t\t\t\t\tif (l[j]<=r[j])val[i<<11|j]+=(S[r[j]]-S[l[j]]);\n\t\t\t\t} \n\t\t\t\telse l[j]=n,r[j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)ans+=val[i<<11|j]*b[i<<11|j];\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nconst int maxn = 550;\n\nint n, m, a[maxn][maxn], fl[maxn][maxn][maxn], fr[maxn][maxn][maxn], s[maxn][maxn];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstatic char str[maxn];\n\t\tscanf(\"%s\", str + 1);\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\ta[i][j] = (str[j] == '#' ? 0 : str[j] - '0'), s[i][j] = s[i][j - 1] + a[i][j];\n\t\t\tfor (int k = 1; k <= n; ++k) fl[i][j][k] = n, fr[i][j][k] = 0;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = n; i; --i) for (int j = n; j; --j) if(a[i][j]) {\n\t\tfl[i][j][i] = fr[i][j][i] = j;\n\t\tif(a[i + 1][j]) for (int k = i + 1; k <= n; ++k) fl[i][j][k] = min(fl[i][j][k], fl[i + 1][j][k]), fr[i][j][k] = max(fr[i][j][k], fr[i + 1][j][k]);\n\t\tif(a[i][j + 1]) for (int k = i; k <= n; ++k) fl[i][j][k] = min(fl[i][j][k], fl[i][j + 1][k]), fr[i][j][k] = max(fr[i][j][k], fr[i][j + 1][k]);\n\t\tint sum = 0;\n\t\tfor (int k = i; k <= n; ++k) {\n\t\t\tif(fl[i][j][k] > fr[i][j][k]) break;\n\t\t\tsum += s[k][fr[i][j][k]] - s[k][fl[i][j][k] - 1];\n\t\t}\n\t\tans += (long long) a[i][j] * (sum - a[i][j]);\n\n\t\tfunction<void(int, int)> del = [&](int x, int y) {\n\t\t\tif(!a[x][y]) return;\n\t\t\tif(!a[x][y - 1] && !a[x - 1][y]) {\n\t\t\t\tfor (int i = y; i <= n; ++i) s[x][i] -= a[x][y];\n\t\t\t\ta[x][y] = 0;\n\t\t\t\tdel(x, y + 1);\n\t\t\t\tdel(x + 1, y);\n\t\t\t}\n\t\t\treturn;\n\t\t};\n\t\tdel(i, j);\n\t}\n\tprintf(\"%\"LLFORMAT\"d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXN = 1500;\n\nbool canreachd[MAXN][MAXN]; int minreachd[MAXN][MAXN], maxreachd[MAXN][MAXN]; // u[x][y] or d[hu+x][y] for x==0 -> leftmost/rightmost cell of d[0] that this square can reach\nint top[MAXN][MAXN]; // u[x][y] or d[hu+x][y] for x==0 -> topmost row that can reach this square\nint bot[MAXN][MAXN]; // d[x][y] -> bottommost row that this square can reach\n\nbool isreachable[MAXN][MAXN]; int minreachedby[MAXN][MAXN], maxreachedby[MAXN][MAXN]; // d[x][y] -> leftmost/rightmost cell of d[0] that can reach this square\n\nint firstjoin[MAXN][MAXN]; // row of topmost cell that is reachable from d[0][y1] and d[0][y2]\nll sumtotal[MAXN]; // sum of squares on d[x] reachable from d[0]\nll sumbefore[MAXN][MAXN]; // sum of squares on d[x] reachable from d[0], but not from d[0][y'] for y'>=y\nll sumafter[MAXN][MAXN]; // sum of squares on d[x] reachable from d[0], but not from d[0][y'] for y'<=y\nll sumbetween[MAXN][MAXN]; // sum of squares reachable from d[0], but not from d[0][y'] for y'<=y1 or y'>=y2\n\nll calc(int y1, int y2, int xlim) {\n\tll ret;\n\tif (xlim < firstjoin[y1][y2]) {\n\t\tret = 0;\n\t} else {\n\t\t// total number of squares (x<=xlim) that can be reached from somewhere\n\t\t// - squares (x<=xlim) that can only be reached from y < y2\n\t\t// - squares (x<=xlim) that can only be reached from y > y1\n\t\t// + squares (x<=xlim) that can only be reached from y1 < y < y2 -> when can only happen when x < firstjoin[y1][y2]\n\t\tret = sumtotal[xlim] - sumbefore[xlim][y2] - sumafter[xlim][y1] + sumbetween[y1][y2];\n\t\t//printf(\"\\t\\t(%lld-%lld-%lld+%lld)\\n\", sumtotal[xlim], sumbefore[xlim][y2], sumafter[xlim][y1], sumbetween[y1][y2]);\n\t}\n\t//printf(\"\\tcalc(%d,%d,%d)=%lld [%d<%d]\\n\", y1, y2, xlim, ret, xlim, firstjoin[y1][y2]);\n\treturn ret;\n}\n\nll cnt[MAXN], sum;\nint q[MAXN], qtail, qhead;\n\nvoid add(int y) {\n\tcnt[y] = calc(y, y, bot[0][y]); sum += cnt[y];\n\tint xlim = -1;\n\twhile (qtail < qhead && bot[0][q[qhead - 1]] <= bot[0][y]) {\n\t\tint yy = q[--qhead];\n\t\tll delta = calc(yy, y, bot[0][yy]) - calc(yy, y, xlim);\n\t\tcnt[yy] -= delta; sum -= delta; xlim = bot[0][yy];\n\t}\n\tif (qtail < qhead) {\n\t\tint yy = q[qhead - 1];\n\t\tll delta = calc(yy, y, bot[0][y]) - calc(yy, y, xlim);\n\t\tcnt[yy] -= delta; sum -= delta;\n\t}\n\tq[qhead++] = y;\n}\nvoid rem(int y) {\n\tsum -= cnt[y]; cnt[y] = 0;\n\tif (qtail < qhead) { assert(q[qtail] >= y); if (q[qtail] == y) ++qtail; }\n}\n\nint reachable[MAXN], nreachable;\n\nll bf(const vector<string> &u, const vector<string> &d, int x, int y) {\n\tint hu = SZ(u), hd = SZ(d), w = SZ(u[0]); assert(SZ(d[0]) == w);\n\tvector<vector<bool>> can(hu + hd, vector<bool>(w, false));\n\tqueue<pair<int, int>> q; ll ret = 0;\n\tcan[x][y] = true; q.push(MP(x, y));\n\twhile (!q.empty()) {\n\t\tint x = q.front().first, y = q.front().second; q.pop();\n\t\tif (x >= hu) ret += d[x - hu][y] - '0';\n\t\tif (x + 1 < hu + hd && !(x + 1 < hu&&u[x + 1][y] == '#') && !(x + 1 >= hu&&d[x + 1 - hu][y] == '#') && !can[x + 1][y]) {\n\t\t\tcan[x + 1][y] = true; q.push(MP(x + 1, y));\n\t\t}\n\t\tif (y + 1 < w && !(x < hu&&u[x][y + 1] == '#') && !(x >= hu&&d[x - hu][y + 1] == '#') && !can[x][y + 1]) {\n\t\t\tcan[x][y + 1] = true; q.push(MP(x, y + 1));\n\t\t}\n\t}\n\treturn ret;\n}\nll bf(const vector<string> &g, int x, int y) {\n\tint h = SZ(g), w = SZ(g[0]);\n\tvector<vector<bool>> can(h, vector<bool>(w, false));\n\tqueue<pair<int, int>> q; ll ret = -(g[x][y] - '0');\n\tcan[x][y] = true; q.push(MP(x, y));\n\twhile (!q.empty()) {\n\t\tint x = q.front().first, y = q.front().second; q.pop();\n\t\tret += g[x][y] - '0';\n\t\tif (x + 1 < h && g[x + 1][y] != '#' && !can[x + 1][y]) {\n\t\t\tcan[x + 1][y] = true; q.push(MP(x + 1, y));\n\t\t}\n\t\tif (y + 1 < w && g[x][y + 1] != '#' && !can[x][y + 1]) {\n\t\t\tcan[x][y + 1] = true; q.push(MP(x, y + 1));\n\t\t}\n\t}\n\treturn ret;\n}\n\n// keep track of set of top cells of d that are reachable from u[x][y] and of sum of different cells in d that are reachable from them\nll solve(const vector<string> &u, const vector<string> &d) {\n\tint hu = SZ(u), hd = SZ(d), w = SZ(u[0]); assert(SZ(d[0]) == w);\n\t//printf(\"solving:\\n\"); REP(x, hu) printf(\"%s\\n\", u[x].c_str()); REP(y, w) printf(\"-\"); puts(\"\"); REP(x, hd) printf(\"%s\\n\", d[x].c_str());\n\n\tfor (int x = hu; x >= 0; --x) for (int y = w - 1; y >= 0; --y) {\n\t\tcanreachd[x][y] = false, minreachd[x][y] = w, maxreachd[x][y] = -1; if (x < hu && u[x][y] == '#' || x == hu && d[0][y] == '#') continue;\n\t\tif (x == hu) { canreachd[x][y] = true; minreachd[x][y] = maxreachd[x][y] = y; }\n\t\tif (x + 1 <= hu && canreachd[x + 1][y]) { canreachd[x][y] = true; minreachd[x][y] = min(minreachd[x][y], minreachd[x + 1][y]); maxreachd[x][y] = max(maxreachd[x][y], maxreachd[x + 1][y]); }\n\t\tif (y + 1 <  w  && canreachd[x][y + 1]) { canreachd[x][y] = true; minreachd[x][y] = min(minreachd[x][y], minreachd[x][y + 1]); maxreachd[x][y] = max(maxreachd[x][y], maxreachd[x][y + 1]); }\n\t}\n\tREPE(x, hu) REP(y, w) {\n\t\ttop[x][y] = hu; if (x < hu && u[x][y] == '#' || x == hu && d[0][y] == '#') continue;\n\t\tif (x < hu) top[x][y] = x;\n\t\tif (x - 1 >= 0) top[x][y] = min(top[x][y], top[x - 1][y]);\n\t\tif (y - 1 >= 0) top[x][y] = min(top[x][y], top[x][y - 1]);\n\t}\n\tfor (int x = hd - 1; x >= 0; --x) for (int y = w - 1; y >= 0; --y) {\n\t\tbot[x][y] = -1; if (d[x][y] == '#') continue;\n\t\tbot[x][y] = x;\n\t\tif (x + 1 < hd) bot[x][y] = max(bot[x][y], bot[x + 1][y]);\n\t\tif (y + 1 < w ) bot[x][y] = max(bot[x][y], bot[x][y + 1]);\n\t}\n\tREP(x, hd) REP(y, w) {\n\t\tisreachable[x][y] = false, minreachedby[x][y] = w, maxreachedby[x][y] = -1; if (d[x][y] == '#') continue;\n\t\tif (x == 0) { isreachable[x][y] = true; minreachedby[x][y] = maxreachedby[x][y] = y; }\n\t\tif (x - 1 >= 0 && isreachable[x - 1][y]) { isreachable[x][y] = true; minreachedby[x][y] = min(minreachedby[x][y], minreachedby[x - 1][y]); maxreachedby[x][y] = max(maxreachedby[x][y], maxreachedby[x - 1][y]); }\n\t\tif (y - 1 >= 0 && isreachable[x][y - 1]) { isreachable[x][y] = true; minreachedby[x][y] = min(minreachedby[x][y], minreachedby[x][y - 1]); maxreachedby[x][y] = max(maxreachedby[x][y], maxreachedby[x][y - 1]); }\n\t}\n\t//REP(x, hd) REP(y, w) printf(\"(%d,%d): %d %d %d\\n\", x, y, isreachable[x][y] ? 1 : 0, minreachedby[x][y], maxreachedby[x][y]);\n\tREP(x, hd) sumtotal[x] = 0;\n\tREP(x, hd) REP(y, w) if (isreachable[x][y]) sumtotal[x] += d[x][y] - '0';\n\tFOR(x, 1, hd) sumtotal[x] += sumtotal[x - 1];\n\tREP(x, hd) REP(y, w) sumbefore[x][y] = 0;\n\tREP(x, hd) REP(y, w) if (isreachable[x][y] && maxreachedby[x][y] + 1 < w) sumbefore[x][maxreachedby[x][y] + 1] += d[x][y] - '0';\n\tREP(x, hd) FOR(y, 1, w) sumbefore[x][y] += sumbefore[x][y - 1];\n\tFOR(x, 1, hd) REP(y, w) sumbefore[x][y] += sumbefore[x - 1][y];\n\tREP(x, hd) REP(y, w) sumafter[x][y] = 0;\n\tREP(x, hd) REP(y, w) if (isreachable[x][y] && minreachedby[x][y] - 1 >= 0) sumafter[x][minreachedby[x][y] - 1] += d[x][y] - '0';\n\tREP(x, hd) for (int y = w - 2; y >= 0; --y) sumafter[x][y] += sumafter[x][y + 1];\n\tFOR(x, 1, hd) REP(y, w) sumafter[x][y] += sumafter[x - 1][y];\n\tREP(y1, w) REP(y2, w) sumbetween[y1][y2] = 0;\n\tREP(x, hd) REP(y, w) if (isreachable[x][y] && minreachedby[x][y] - 1 >= 0 && maxreachedby[x][y] + 1 < w) sumbetween[minreachedby[x][y] - 1][maxreachedby[x][y] + 1] += d[x][y] - '0';\n\tFOR(dy, 1, w) REP(y1, w-dy) { int y2 = y1 + dy; sumbetween[y1][y2] += sumbetween[y1 + 1][y2] + sumbetween[y1][y2 - 1] - sumbetween[y1 + 1][y2 - 1]; }\n\tREP(y1, w) REP(y2, w) firstjoin[y1][y2] = hd;\n\tREP(x, hd) REP(y, w) if (isreachable[x][y]) firstjoin[minreachedby[x][y]][maxreachedby[x][y]] = min(firstjoin[minreachedby[x][y]][maxreachedby[x][y]], x);\n\tfor (int dy = w - 1; dy >= 1; --dy) REP(y1, w - dy) { int y2 = y1 + dy; firstjoin[y1 + 1][y2] = min(firstjoin[y1 + 1][y2], firstjoin[y1][y2]); firstjoin[y1][y2 - 1] = min(firstjoin[y1][y2 - 1], firstjoin[y1][y2]); }\n\tREP(y1, w) REP(y2, w) if (bot[0][y1] < firstjoin[y1][y2] || bot[0][y2] < firstjoin[y1][y2]) firstjoin[y1][y2] = hd;\n\n\tll ret = 0;\n\tREP(x, hu) {\n\t\tint l = 0, r = 0; qhead = qtail = 0; sum = 0; REP(y, w) cnt[y] = 0;\n\t\tnreachable = 0; REP(y, w) if (top[hu][y] <= x) reachable[nreachable++] = y;\n\t\t//printf(\"reachable%d:\", x); REP(i, nreachable) printf(\" %d\", reachable[i]); puts(\"\");\n\t\tREP(y, w) {\n\t\t\tif (!canreachd[x][y]) continue;\n\t\t\twhile (r < nreachable && maxreachd[x][y] >= reachable[r]) add(reachable[r++]);\n\t\t\twhile (l < r && minreachd[x][y] > reachable[l]) rem(reachable[l++]);\n\t\t\t//printf(\"\\t%d: %d..%d [%d..%d)\\n\", y, minreachd[x][y], maxreachd[x][y], l, r);\n\t\t\tassert(l < r && reachable[l] == minreachd[x][y] && reachable[r - 1] == maxreachd[x][y]);\n\t\t\tret += (u[x][y] - '0')*sum;\n\t\t\t//ll chk = bf(u, d, x, y); if (chk != sum) { printf(\"err(%d,%d): have=%lld want=%lld\\n\", x, y, sum, chk); exit(0); }\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<string> rot(const vector<string> &g) {\n\tint h = SZ(g), w = SZ(g[0]); vector<string> ret(w, string(h, '?')); REP(x, h) REP(y, w) ret[y][x] = g[x][y]; return ret;\n}\n\nll solve(const vector<string> &g) {\n\tint h = SZ(g), w = SZ(g[0]);\n\tif (h < w) return solve(rot(g));\n\tif (h == 1) return 0;\n\tint hu = h / 2, hd = h - hu;\n\tvector<string> u(hu, string(w, '?')); REP(x, hu) REP(y, w) u[x][y] = g[x][y];\n\tvector<string> d(hd, string(w, '?')); REP(x, hd) REP(y, w) d[x][y] = g[hu + x][y];\n\treturn solve(u, d) + solve(u) + solve(d);\n}\n\n\nint n;\nchar g[MAXN][MAXN + 1];\n\nll solve() {\n\tvector<string> g(n, string(n, '?')); REP(x, n) REP(y, n) g[x][y] = ::g[x][y];\n\treturn solve(g);\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &n); REP(x, n) scanf(\"%s\", g[x]);\n\tprintf(\"%lld\\n\", solve());\n}\n\nvoid verify() {\n\tll have = solve();\n\tll want = 0; REP(x, n) REP(y, n) if (g[x][y] != '#') { vector<string> gg(n, string(n, '?')); REP(i, n) REP(j, n) gg[i][j] = g[i][j]; want += (ll)(g[x][y] - '0')*bf(gg, x, y); }\n\tif (have == want) { printf(\".\"); return; }\n\tprintf(\"err: have=%lld want=%lld\\n\", have, want);\n\tREP(x, n) printf(\"%s\\n\", g[x]);\n\texit(0);\n}\n\nvoid stress1() {\n\tREP(rep, 100000) {\n\t\tint freq = 2 + rand() % 5;\n\t\tn = 1 + rand() % 40; REP(x, n) { REP(y, n) g[x][y] = rand() % freq == 0 ? '#' : '1' + rand() % 9; g[x][n] = '\\0'; }\n\t\tverify();\n\t}\n}\n\nvoid stress2() {\n\tREP(rep, 10) {\n\t\tn = MAXN; REP(x, n) { REP(y, n) g[x][y] = rand() % 4 == 0 ? '#' : '1' + rand() % 9; g[x][n] = '\\0'; }\n\t\tsolve();\n\t\tprintf(\".\");\n\t}\n}\n\n\nvoid stress3() {\n\tREP(rep, 1) {\n\t\tn = MAXN; REP(x, n) { REP(y, n) g[x][y] = '9'; g[x][n] = '\\0'; }\n\t\tprintf(\"%lld\\n\", solve());\n\t\tll want = 0; REP(x, n) REP(y, n) { ll cur = (ll)(n - x)*(n - y) - 1; want += (ll)cur * 9 * 9; }\n\t\tprintf(\"want=%lld\\n\", want);\n\t}\n}\n\nvoid test() {\n\tscanf(\"%d\", &n); REP(x, n) scanf(\"%s\", g[x]);\n\tverify();\n}\n\n\nint main() {\n\trun();\n\t//stress1();\n\t//stress2();\n\t//stress3();\n\t//test();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int M = 1505;\n\nint n, l[M][M], r[M][M], gr[M][M];\nbool reach[M][M];\nchar g[M][M];\nll ans;\n\nvoid go(int i, int k) {\n  int s = 0;\n  int left = 0, right = -1;\n  for (int j = 0; j < n; ++j) {\n  // cout << l[k][j] << ' ' << r[k][j] << endl;\n    if (r[k][j] == -1)\n      continue;\n    while (right < r[k][j]) {\n      right++;\n      if (reach[k][right])\n        s += g[k][right];\n    } while (left < l[k][j]) {\n      if (reach[k][left])\n        s -= g[k][left];\n      left++;\n    }\n    ans += g[i][j]*s;\n  }\n  // cout << ans << endl;\n}\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  cin >> n;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j) {\n      cin >> g[i][j];\n      if (g[i][j] != '#')\n        g[i][j] -= '0';\n    }\n\n  for (int i = 0; i < n; ++i)\n    for (int j = n-1; j >= 0; --j) {\n      if (g[i][j] == '#')\n        gr[i][j] = -1;\n      else\n        gr[i][j] = max(j, gr[i][j+1]);\n    }\n\n  for (int i = 0; i < n; ++i) {\n    memset(l, 0, sizeof(l));\n    memset(r, 0, sizeof(r));\n    memset(reach, 0, sizeof(reach));\n    for (int j = 0; j < n; ++j) {\n      if (g[i][j] == '#') {\n        r[i][j] = -1;\n        l[i][j] = n;\n        reach[i][j] = 0;\n      } else {\n        l[i][j] = j;\n        r[i][j] = gr[i][j];\n        reach[i][j] = 1;\n      }\n    }\n    go(i, i);\n    for (int k = i; k < n-1; ++k) {\n      //update row k to row k+1\n      for (int j = 0; j < n; ++j)\n        if (g[k+1][j] != '#')\n          reach[k+1][j] = reach[k][j];\n      for (int j = 0; j < n-1; ++j)\n        if (g[k+1][j+1] != '#')\n          reach[k+1][j+1] |= reach[k+1][j];\n      int right = -1, left = 0, best = -1, sz = 0;\n      for (int j = 0; j < n; ++j) {\n        if (r[k][j] == -1) {\n          r[k+1][j] = -1;\n          continue;\n        }\n        while (right < r[k][j]) {\n          right++;\n          if (!reach[k][right])\n            continue;\n          if (g[k+1][right] != '#') {\n            best = gr[k+1][right];\n            sz++;\n          }\n        } while (left < l[k][j]) {\n          if (!reach[k][left]) {\n            left++;\n            continue;\n          }\n          if (g[k+1][left] != '#')\n            sz--;\n          left++;\n        }\n        if (sz == 0)\n          r[k+1][j] = -1;\n        else\n          r[k+1][j] = best;\n      }\n      right = n-1, left = n, best = n, sz = 0;\n      for (int j = n-1; j >= 0; --j) {\n        if (r[k][j] == -1) {\n          l[k+1][j] = n;\n          continue;\n        }\n        while (left > l[k][j]) {\n          left--;\n          if (!reach[k][left])\n            continue;\n          if (g[k+1][left] != '#') {\n            best = left;\n            sz++;\n          }\n        } while (right > r[k][j]) {\n          if (!reach[k][right]) {\n            right--;\n            continue;\n          }\n          if (g[k+1][right] != '#')\n            sz--;\n          right--;\n        }\n        if (sz == 0)\n          l[k+1][j] = n;\n        else\n          l[k+1][j] = best;\n      }\n      go(i, k+1);\n    }\n  }\n\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      if (g[i][j] != '#')\n        ans -= g[i][j]*g[i][j];\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    wek.resize((v/d)+2);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trepn(x,9) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+1);\n\t\t\t\tif(x) repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include \"optimization.h\"\n\nusing namespace std;\n\n#define vec vector\n#define ALL(x) begin(x), end(x)\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< long long, long long > pll;\n\nconst int inf = 1000 * 1000 * 1000;\nconst ll inf64 = 1e18;\n\nconst int N = 505;\n\nint n;\nint a[N][N];\nbitset< N > can[2 * N];\nbitset< N > mask[2 * N][10];\n\nint main() {\n\n#ifdef debug\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n\n    scanf(\"%d\", &n);\n\n    for(int i = 0;i < n;i++) {\n        for(int j = 0;j < n;j++) {\n            char symb;\n            scanf(\" %c\", &symb);\n            a[i][j] = symb == '#' ? -1 : symb - '0';\n        }\n    }\n\n    for(int i = 0;i < n;i++) {\n        for(int j = 0;j < n;j++) {\n            if(a[i][j] == -1) {\n                can[i + j][j] = 0;\n            }else {\n                can[i + j][j] = 1;\n                mask[i + j][ a[i][j] ][j] = 1;\n            }\n        }\n    }\n\n    ll res = 0;\n\n    for(int x = 1;x <= 9;x++)   {\n        for(int i = 0;i < n;i++) {\n            for(int j = 0;j < n;j++) {\n                if(a[i][j] == -1) continue;\n                bitset< N > cur;\n                cur[j] = 1;\n                int cnt = 0;\n                for(int c = i + j + 1;c <= n-1+n-1;c++) {\n                    cur = cur | (cur << 1);\n                    cur &= can[c];\n                    cnt += (cur & mask[c][x]).count();\n                }\n                res += 1ll * a[i][j] * cnt * x;\n            }\n        }\n    }\n\n    cout << res << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tint n;\n\tstring a[505];\n\tcin>>n;\n\tfor(int i=0; i<n; i++){\n\t\tcin>>a[i];\n\t}\n\tint c1[505][505], c2[505][505], d[505][505];\n\tint s[505][505];\n\tll ans=0;\n\tfor(int i=0; i<n; i++){\n\t\tbool b[505][505]={};\n\t\tfor(int j=0; j<n; j++) if(a[i][j]=='#') b[i][j]=1;\n\t\tfor(int k=i+1; k<n; k++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(a[k][j]=='#'){\n\t\t\t\t\tb[k][j]=1; continue;\n\t\t\t\t}\n\t\t\t\tif(b[k-1][j] && (j==0 || b[k][j-1])) b[k][j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=i; k<n; k++){\n\t\t\ts[k][0]=0;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\ts[k][j+1]=s[k][j];\n\t\t\t\tif(!b[k][j]) s[k][j+1]+=(a[k][j]-'0');\n\t\t\t}\n\t\t}\n\t\tfor(int k=i; k<n; k++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(b[k][j]){\n\t\t\t\t\tif(j>0) c1[k][j]=c1[k][j-1];\n\t\t\t\t\telse c1[k][j]=-1;\n\t\t\t\t}else c1[k][j]=j;\n\t\t\t}\n\t\t\tfor(int j=n-1; j>=0; j--){\n\t\t\t\tif(b[k][j]){\n\t\t\t\t\tif(j<n-1) c2[k][j]=c2[k][j+1];\n\t\t\t\t\telse c2[k][j]=n;\n\t\t\t\t}else c2[k][j]=j;\n\t\t\t\tif(!b[k][j]){\n\t\t\t\t\tif(j==n-1 || b[k][j+1]) d[k][j]=j;\n\t\t\t\t\telse d[k][j]=d[k][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(a[i][j]=='#') continue;\n\t\t\tint l=j, r=d[i][j];\n\t\t\tll sum=s[i][r+1]-s[i][l+1];\n\t\t\tfor(int k=i+1; k<n; k++){\n\t\t\t\tif(b[k][l]){\n\t\t\t\t\tl=c2[k][l];\n\t\t\t\t}\n\t\t\t\tif(b[k][r]){\n\t\t\t\t\tr=c1[k][r];\n\t\t\t\t}else{\n\t\t\t\t\tr=d[k][r];\n\t\t\t\t}\n\t\t\t\tif(l>r) break;\n\t\t\t\tsum+=s[k][r+1]-s[k][l];\n\t\t\t}\n\t\t\tans+=sum*(a[i][j]-'0');\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 64\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v){\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid ustaw(int v,int a)\n\t{\n\t\tfor(int i=v;i<v+a;i++) ustaw(i);\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[505];\nll ans;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n) B[i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[x].upper(9*(x*n+y)+9);\n\t\t\t\tif(x) oruj(B[x],B[x-1]);\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].licz());\n\t\t\t\tB[x].ustaw(9*(x*n+y),f[x][y]-'0');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].zeruj();\n\t\t\t\tB[x].upper(9*(x*n+y)+9);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2,3,\"Ofast\",\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define db double\n#define in inline\nnamespace fast_io\n{\n    char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0,ny;\n    in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\n    in int read()\n    {\n        int x=0;ny=1;while(nc=gc(),(nc<48||nc>57)&&nc!=EOF)if(nc==45)ny=-1;Bi=1;if(nc<0)return nc;\n        x=nc-48;while(nc=gc(),47<nc&&nc<58&&nc!=EOF)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*ny;\n    }\n    in db gf() {int a=read(),y=ny,b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi)*y:a);}\n    in int gs(char *s) {char c,*t=s;while(c=gc(),c<=32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}\n    in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}\n    in void flush() {if(C>1<<22) ot();}\n    template <typename T>\n    in void write(T x,char t)\n    {\n        int y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);\n        if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();\n    }\n    in void write(char *s) {int l=strlen(s);for(int i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\\n';flush();}\n};\nusing namespace fast_io;\nconst int N=1.5e3+5;\nint n,s[N][N],p[N][N],mn[2][N][N],mx[2][N][N];ll ans;\nchar ch[N][N];\nint main()\n{\n\tn=read();for(int i=1;i<=n;i++) gs(ch[i]+1);\n\tfor(int i=n,t=1;i;t^=1,i--) for(int j=n;j;j--) if(ch[i][j]^'#')\n\t{\n\t\ts[i][j]=s[i][j+1]+s[i+1][j]+ch[i][j]-'0';\n\t\tp[i][j]=max(max(p[i][j+1],p[i+1][j]),i);\n\t\tmn[t][j][i]=j;\n\t\tfor(int k=i+1;k<=p[i+1][j];k++) mn[t][j][k]=mn[t^1][j][k];\n\t\tfor(int k=max(p[i+1][j],i)+1;k<=p[i][j+1];k++) mn[t][j][k]=mn[t][j+1][k];\n\t\tmx[t][j][i]=j;\n\t\tfor(int k=i;k<=p[i][j+1];k++) mx[t][j][k]=mx[t][j+1][k];\n\t\tfor(int k=max(p[i][j+1],i)+1;k<=p[i+1][j];k++) mx[t][j][k]=mx[t^1][j][k];\n\t\tint l=i+1,r=min(p[i][j+1],p[i+1][j]);\n\t\twhile(l<=r)\n\t\t{\n\t\t\tif(mx[t^1][j][l]>=mn[t][j+1][l]) s[i][j]-=s[l][mn[t][j+1][l]],l=p[l][mn[t][j+1][l]];\n\t\t\tl++;\n\t\t}\n\t\tans+=1ll*(ch[i][j]-'0')*(s[i][j]-(ch[i][j]-'0'));\n\t}\n\twrite(ans,'\\n');\n\treturn ot(),0;\n}\n//Author: disangan233"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int INF=2147483647;\nint n,m,A[2][1505][1505],U[1505][1505],D[1505][1505];\nint f[1505][1505],Left[1505][1505],Right[1505][1505],Min[1505][1505],Max[1505][1505],Top[1505],Bot[1505],Mpoint[1505][1505],Reach[1505];\nint Min_Mpoint[1505][1505],Sum_n[1505],Sum_l[1505][1505],Sum_r[1505][1505],Sum_lr[1505][1505];\nint q[1505],Only[1505],st,en,sum;\nll ans;\nchar s[1505][1505];\nvoid calc_LR(int n1,int n2,int m)\n{\n\tfor(int i=1;i<=n2;i++)\n\tfor(int j=1;j<=m;j++)\n\t{\n\t\tLeft[i][j]=INF,Right[i][j]=-INF;\n\t\tif(D[i][j])\n\t\t{\n\t\t\tif(i==1)Left[i][j]=Right[i][j]=j;\n\t\t\tif(i>1)\n\t\t\t{\n\t\t\t\tLeft[i][j]=min(Left[i][j],Left[i-1][j]);\n\t\t\t\tRight[i][j]=max(Right[i][j],Right[i-1][j]);\n\t\t\t}\n\t\t\tif(j>1)\n\t\t\t{\n\t\t\t\tLeft[i][j]=min(Left[i][j],Left[i][j-1]);\n\t\t\t\tRight[i][j]=max(Right[i][j],Right[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tMax[n1+1][m+1]=-INF;\n\tfor(int i=m;i>=1;i--)\n\t{\n\t\tif(D[1][i])Min[n1+1][i]=i,Max[n1+1][i]=max(i,Max[n1+1][i+1]);\n\t\telse Min[n1+1][i]=INF,Max[n1+1][i]=-INF;\n\t}\n\tfor(int i=n1;i>=1;i--)\n\tfor(int j=m;j>=1;j--)\n\t{\n\t\tMin[i][j]=INF,Max[i][j]=-INF;\n\t\tif(U[i][j])\n\t\t{\n\t\t\tMin[i][j]=min(Min[i][j],Min[i+1][j]);\n\t\t\tMax[i][j]=max(Max[i][j],Max[i+1][j]);\n\t\t\tif(j<m)\n\t\t\t{\n\t\t\t\tMin[i][j]=min(Min[i][j],Min[i][j+1]);\n\t\t\t\tMax[i][j]=max(Max[i][j],Max[i][j+1]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid calc_TB(int n1,int n2,int m)\n{\n\tfor(int i=1;i<=n1;i++)\n\tfor(int j=1;j<=m;j++)\n\t{\n\t\tf[i][j]=INF;\n\t\tif(U[i][j])\n\t\t{\n\t\t\tf[i][j]=i;\n\t\t\tif(i>1)f[i][j]=min(f[i][j],f[i-1][j]);\n\t\t\tif(j>1)f[i][j]=min(f[i][j],f[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tTop[i]=INF;\n\t\tif(D[1][i])\n\t\t{\n\t\t\tif(i>1)Top[i]=min(Top[i],Top[i-1]);\n\t\t\tTop[i]=min(Top[i],f[n1][i]);\n\t\t}\n\t}\n\tfor(int i=n2;i>=1;i--)\n\tfor(int j=m;j>=1;j--)\n\t{\n\t\tf[i][j]=-INF;\n\t\tif(D[i][j])\n\t\t{\n\t\t\tf[i][j]=i;\n\t\t\tif(i<n2)f[i][j]=max(f[i][j],f[i+1][j]);\n\t\t\tif(j<m)f[i][j]=max(f[i][j],f[i][j+1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)Bot[i]=f[1][i];\n}\nvoid calc_Mp(int n,int m)\n{\n\tfor(int i=0;i<=m+1;i++)\n\t  for(int j=0;j<=m+1;j++)\n\t    Min_Mpoint[i][j]=INF;\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=m;j++)\n\t    if(Left[i][j]!=INF)\n\t      Min_Mpoint[Left[i][j]][Right[i][j]]=min(Min_Mpoint[Left[i][j]][Right[i][j]],i);\n\tfor(int i=1;i<=m;i++)\n\t  for(int j=m;j>=1;j--)\n\t    Min_Mpoint[i][j]=min(Min_Mpoint[i][j],min(Min_Mpoint[i-1][j],Min_Mpoint[i][j+1]));\n\tfor(int i=1;i<=m;i++)\n\t  for(int j=i;j<=m;j++)\n\t    Mpoint[i][j]=Min_Mpoint[i][j]<=min(Bot[i],Bot[j])?Min_Mpoint[i][j]:INF;\n}\nvoid pre_Both(int n,int m)\n{\n\tSum_n[0]=0;\n\tfor(int i=0;i<=n+1;i++)\n\t  for(int j=0;j<=m+1;j++)\n\t    Sum_l[i][j]=Sum_r[i][j]=0;\n\tfor(int i=0;i<=m+1;i++)\n\t  for(int j=0;j<=m+1;j++)\n\t    Sum_lr[i][j]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tSum_n[i]=Sum_n[i-1];\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(Left[i][j]<=Right[i][j])\n\t\t\t{\n\t\t\t\tSum_n[i]+=D[i][j];\n\t\t\t\tSum_l[i][Left[i][j]]+=D[i][j],Sum_r[i][Right[i][j]]+=D[i][j];\n\t\t\t\tSum_lr[Left[i][j]][Right[i][j]]+=D[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)Sum_r[i][j]+=Sum_r[i-1][j]+Sum_r[i][j-1]-Sum_r[i-1][j-1];\n\t\tfor(int j=m;j>=1;j--)Sum_l[i][j]+=Sum_l[i-1][j]+Sum_l[i][j+1]-Sum_l[i-1][j+1];\n\t}\n\tfor(int i=m;i>=1;i--)\n\t  for(int j=1;j<=m;j++)\n\t    Sum_lr[i][j]+=Sum_lr[i+1][j]+Sum_lr[i][j-1]-Sum_lr[i+1][j-1];\n}\nint ask_Both(int i,int j,int l)\n{\n\tl=min(l,min(Bot[i],Bot[j]));\n\tif(l<Mpoint[i][j])return 0;\n\treturn Sum_n[l]-Sum_l[l][i+1]-Sum_r[l][j-1]+Sum_lr[i+1][j-1];\n}\nvoid ins(int y)\n{\n\tOnly[y]=Reach[y];\n\tsum+=Only[y];\n\tint last=0;\n\twhile(st<=en&&Bot[q[en]]<=Bot[y])\n\t{\n\t\tsum-=Only[q[en]];\n\t\tOnly[q[en]]-=ask_Both(q[en],y,min(Bot[q[en]],Bot[y]));\n\t\tOnly[q[en]]+=ask_Both(q[en],y,min(last,Bot[y]));\n\t\tsum+=Only[q[en]];\n\t\tlast=Bot[q[en]];\n\t\ten--;\n\t}\n\tif(st<=en)\n\t{\n\t\tsum-=Only[q[en]];\n\t\tOnly[q[en]]-=ask_Both(q[en],y,min(Bot[q[en]],Bot[y]));\n\t\tOnly[q[en]]+=ask_Both(q[en],y,min(last,Bot[y]));\n\t\tsum+=Only[q[en]];\n\t}\n\tq[++en]=y;\n}\nvoid del(int y)\n{\n\tif(q[st]==y)st++;\n\tsum-=Only[y];\n}\nvoid solve(bool rev,int ln,int rn,int lm,int rm)\n{\n\tif(ln>rn||lm>rm)return;\n\tif(ln==rn&&lm==rm)return;\n\tif(rn-ln<rm-lm)\n\t{\n\t\tswap(ln,lm);\n\t\tswap(rn,rm);\n\t\trev^=1;\n\t}\n\tint mid=(ln+rn)/2;\n\tsolve(rev,ln,mid,lm,rm);\n\tsolve(rev,mid+1,rn,lm,rm);\n\tint n1=mid-ln+1,n2=rn-mid,m=rm-lm+1;\n\tfor(int i=ln;i<=mid;i++)\n\t  for(int j=lm;j<=rm;j++)\n\t    U[i-ln+1][j-lm+1]=A[rev][i][j]=='#'?0:A[rev][i][j]-'0';\n\tfor(int i=mid+1;i<=rn;i++)\n\t  for(int j=lm;j<=rm;j++)\n\t    D[i-mid][j-lm+1]=A[rev][i][j]=='#'?0:A[rev][i][j]-'0';\n\tcalc_LR(n1,n2,m);\n\tcalc_TB(n1,n2,m);\n\tcalc_Mp(n2,m);\n\tpre_Both(n2,m);\n\tfor(int i=1;i<=m;i++)Reach[i]=ask_Both(i,i,Bot[i]);\n\tfor(int i=1;i<=n1;i++)\n\t{\n\t\tst=1,en=0;\n\t\tsum=0;\n\t\tint nowl=1,nowr=0;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(Max[i][j]<Min[i][j])continue;\n\t\t\tfor(int k=nowr+1;k<=Max[i][j];k++)\n\t\t\t\tif(i>=Top[k])ins(k);\n\t\t\tfor(int k=nowl;k<Min[i][j];k++)\n\t\t\t\tif(i>=Top[k])del(k);\n\t\t\tnowr=Max[i][j],nowl=Min[i][j];\n\t\t\tans+=sum*U[i][j];\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t  scanf(\"%s\",s[i]+1);\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t    A[0][i][j]=s[i][j],A[1][i][j]=s[j][i];\n\tsolve(0,1,n,1,n);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) if(a[i][j]) {\n\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\tif(!(t[0]|t[1])) {\n\t\t\tl[i][j]=r[i][j]=j;\n\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t}\n\t\telse if(t[0]&&!t[1]) {\n\t\t\tl[i][j]=r[i][j]=j;\n\t\t\tf[i][j]=f[i+1][j];\n\t\t}\n\t\telse if(!t[0]&&t[1]) {\n\t\t\tf[i][j]=f[i][j+1];\n\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t}\n\t\telse {\n\t\t\tf[i][j]=f[i+1][j]+f[i][j+1];\n\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\n\t\t\tint las_r=0;\t\t\n\t\t\tfor1(i+1,n,k) {\n\t\t\t\tif(r[k][j]>=l[k][j+1]&&l[k][j+1]>las_r) {\n\t\t\t\t\tf[i][j]-=f[k][l[k][j+1]];\n\t\t\t//\t\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<l[k][j+1]<<endl;\n\t\t\t\t\tlas_r=r[k][j];\n\t\t\t\t}\n\t\t\t\tif(l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t//\tif(i==1&&j==1) \n\t\t\t//cout<<l[k][j]<<\" \"<<r[k][j]<<\" \"<<l[k][j+1]<<\" \"<<r[k][j+1]<<endl;\n\t\t\t}\n\t\t}\n\t\t\n//\t\tcout<<i<<\" \"<<j<<\" \"<<f[i][j]<<endl;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\n// --- BEGIN SNIPPET UNION FIND ---\n\nstruct union_find {\n  vi A;\n  vector<array<lli,10>> cntDiag;\n  vector<vector<tpl<lli,lli>>> OPEN;\n  vector<vector<tpl<lli,lli,lli>>> CLOSE;\n\n  union_find(lli n = 0) : A(n), cntDiag(n), OPEN(n), CLOSE(n) {\n    iota(all(A), 0);\n    FOR(i,n) FOR(j,10) cntDiag[i][j] = 0;\n  }\n\n  lli addNode() {\n    A.pb(A.size());\n    return A.size()-1;\n  }\n\n  lli find(lli a) {\n    return A[a] == a ? a : A[a] = find(A[a]);\n  }\n\n  void unite(lli a, lli b) {\n    a = find(a); b = find(b);\n    if(a==b) return;\n    A[a] = b;\n    FOR(j,10) cntDiag[b][j] += cntDiag[a][j];\n    if(OPEN[a].size()<OPEN[b].size()) {\n      swap(OPEN[a],OPEN[b]);\n      swap(CLOSE[a],CLOSE[b]);\n    }\n    OPEN[b].insert(end(OPEN[b]),all(OPEN[a]));\n    CLOSE[b].insert(end(CLOSE[b]),all(CLOSE[a]));\n  }\n};\n\n// --- END SNIPPET UNION FIND ---\n\n// --- BEGIN SNIPPET BINARY INDEXED TREE ---\n\nstruct BIT {\n  vi A;\n  BIT()=default;\n  BIT(lli n) : A(n+1){ }\n\n  lli get(lli i){\n    i += 1;\n    lli r = 0;\n    for(; i > 0; i -= i &-i){\n      r += A[i];\n    }\n    return r;\n  }\n\n  lli getR(lli l, lli r) {\n    lli ans = get(r);\n    if(l) ans -= get(l-1);\n    return ans;\n  }\n\n  void add(lli i, lli v){\n    i += 1;\n    for(; i < (lli)A.size(); i += i & -i){\n      A[i] += v;\n    }\n  }\n};\n\n// --- END SNIPPET BINARY INDEXED TREE ---\n\n\nconst lli N = 1500;\n\nlli n;\nlli A[N][N];\n\nlli dp[N+1][N+1][10];\nlli ans;\n\ninline void iterIPJ(lli ipj, function<void(lli,lli)> f) {\n  lli fromI = max(0ll,ipj-(n-1));\n  lli toI = min(n-1,ipj);\n  FORU(i,fromI,toI) {\n    lli j = ipj-i;\n    f(i,j);\n  }\n}\n\nstruct st {\n  lli color;\n  lli from, to;\n  void reset(){\n    color=from=to=-1;\n  }\n  void combine(union_find& uf, st const& o) {\n    if(o.color == -1) return;\n    if(color == -1) {\n      *this = o;\n      return;\n    }\n    from = min(from,o.from);\n    to = max(to,o.to);\n    uf.unite(color,o.color);\n  }\n};\n\nst S[N][N];\n\nvoid solve(lli l, lli r) {\n  if(l >= r) return;\n  lli ipj0 = (l+r)/2;\n  solve(l,ipj0-1);\n  solve(ipj0+1,r);\n\n  FORU(ipj,l,r) {\n    iterIPJ(ipj,[&](lli i, lli j) {\n      S[i][j].reset();\n    });\n  }\n\n  // lli rdiag_ans = 0;\n  // lli rlans = 0;\n\n  // iterIPJ(ipj0,[&](int i, int j) {\n  //   int dxL[4]={-1,0};\n  //   int dyL[4]={0,-1};\n  //   int dxR[4]={1,0};\n  //   int dyR[4]={0,1};\n  //   vvi EE(n,vi(n,0));\n  //   lli totL=0,totR=0;\n  //   function<void(int,int)> dfsL = [&](int i, int j) {\n  //     if(i<0||j<0||i==n||j==n) return;\n  //     if(i+j<l||i+j>r) return;\n  //     if(A[i][j]==0) return;\n  //     if(EE[i][j]) return;\n  //     EE[i][j]=1;\n  //     totL += A[i][j];\n  //     FOR(d,2) dfsL(i+dxL[d],j+dyL[d]);\n  //   };\n  //   function<void(int,int)> dfsR = [&](int i, int j) {\n  //     if(i<0||j<0||i==n||j==n) return;\n  //     if(i+j<l||i+j>r) return;\n  //     if(A[i][j]==0) return;\n  //     if(EE[i][j]) return;\n  //     EE[i][j]=1;\n  //     totR += A[i][j];\n  //     FOR(d,2) dfsR(i+dxR[d],j+dyR[d]);\n  //   };\n  //   dfsL(i,j);\n  //   EE.assign(n,vi(n,0));\n  //   dfsR(i,j);\n  //   rdiag_ans += A[i][j]*(totL-A[i][j]);\n  //   rdiag_ans += A[i][j]*(totR-A[i][j]);\n  //   cerr << rdiag_ans << endl;\n  // });\n\n  // FORU(ipj,l,ipj0-1) iterIPJ(ipj,[&](int i, int j) {\n  //   int dxR[4]={1,0};\n  //   int dyR[4]={0,1};\n  //   vvi EE(n,vi(n,0));\n  //   lli totR=0;\n  //   function<void(int,int)> dfsR = [&](int i, int j) {\n  //     if(i<0||j<0||i==n||j==n) return;\n  //     if(i+j<l||i+j>r) return;\n  //     if(A[i][j]==0) return;\n  //     if(EE[i][j]) return;\n  //     EE[i][j]=1;\n  //     if(i+j>ipj0) totR += A[i][j];\n  //     FOR(d,2) dfsR(i+dxR[d],j+dyR[d]);\n  //   };\n  //   dfsR(i,j);\n  //   rlans += A[i][j]*totR;\n  // });\n\n  lli diag_ans = 0;\n\n  union_find ufL(n), ufR(n);\n  iterIPJ(ipj0,[&](lli i, lli j){\n    if(A[i][j]) {\n      S[i][j].color = S[i][j].from = S[i][j].to = i;\n      ufL.cntDiag[i][A[i][j]] += 1;\n      ufR.cntDiag[i][A[i][j]] += 1;\n    }\n  });\n\n  FORD(ipj,ipj0-1,l) {\n    // iterIPJ(ipj,[&](lli i, lli j) {\n    //   if(A[i][j]) {\n    //     if(i+1<n && S[i+1][j].color != -1) {\n    //       FOR(d,10) diag_ans += A[i][j]*d*ufL.cntDiag[ufL.find(S[i+1][j].color)][d];\n    //       cerr << mt(i,j) << \" \" << diag_ans << endl;\n    //     }\n    //     if(j+1<n && S[i][j+1].color!=-1 && (i+1>=n||S[i+1][j].color==-1||ufL.find(S[i+1][j].color)!=ufL.find(S[i][j+1].color))) {\n    //       FOR(d,10) diag_ans += A[i][j]*d*ufL.cntDiag[ufL.find(S[i][j+1].color)][d];\n    //       cerr << mt(i,j) << \" \" << diag_ans << endl;\n    //     }\n    //   }\n    // });\n    iterIPJ(ipj,[&](lli i, lli j) {\n      if(A[i][j]) {\n        if(i+1<n) S[i][j].combine(ufL,S[i+1][j]);\n        if(j+1<n) S[i][j].combine(ufL,S[i][j+1]);\n        if(S[i][j].color != -1) {\n          S[i][j].color = ufL.find(S[i][j].color);\n\n          ufL.OPEN[S[i][j].color].eb(S[i][j].from, A[i][j]);\n          ufL.CLOSE[S[i][j].color].eb(S[i][j].to, S[i][j].from, A[i][j]);\n        }\n      }\n    });\n  }\n\n  FORU(ipj,ipj0+1,r) {\n    // iterIPJ(ipj,[&](lli i, lli j) {\n    //   if(A[i][j]) {\n    //     if(i>0 && S[i-1][j].color != -1) {\n    //       FOR(d,10) diag_ans += A[i][j]*d*ufR.cntDiag[ufR.find(S[i-1][j].color)][d];\n    //       cerr << mt(i,j) << \" \" << diag_ans << endl;\n    //     }\n    //     if(j>0 && S[i][j-1].color!=-1 && (i==0||S[i-1][j].color==-1||ufR.find(S[i-1][j].color)!=ufR.find(S[i][j-1].color))) {\n    //       FOR(d,10) diag_ans += A[i][j]*d*ufR.cntDiag[ufR.find(S[i][j-1].color)][d];\n    //       cerr << mt(i,j) << \" \" << diag_ans << endl;\n    //     }\n    //   }\n    // });\n\n    iterIPJ(ipj,[&](lli i, lli j) {\n      if(A[i][j]) {\n        if(i-1>=0) S[i][j].combine(ufR,S[i-1][j]);\n        if(j-1>=0) S[i][j].combine(ufR,S[i][j-1]);\n        if(S[i][j].color != -1) {\n          S[i][j].color = ufR.find(S[i][j].color);\n\n          ufR.OPEN[S[i][j].color].eb(S[i][j].from, A[i][j]);\n          ufR.CLOSE[S[i][j].color].eb(S[i][j].to, S[i][j].from, A[i][j]);\n        }\n      }\n    });\n  }\n\n\n  FOR(i,n) if(ufL.find(i) == i) {\n    sort(all(ufL.OPEN[i]));\n    reverse(all(ufL.OPEN[i]));\n    sort(all(ufL.CLOSE[i]));\n    reverse(all(ufL.CLOSE[i]));\n  }\n  FOR(i,n) if(ufR.find(i) == i) {\n    sort(all(ufR.OPEN[i]));\n    reverse(all(ufR.OPEN[i]));\n    sort(all(ufR.CLOSE[i]));\n    reverse(all(ufR.CLOSE[i]));\n  }\n\n  vi szL(n,0), szR(n,0);\n  vi ixL(n), ixR(n);\n  vector<array<BIT,10>> bitL(n), bitR(n);\n  FOR(i,n) {\n    int il = ufL.find(i);\n    int ir = ufR.find(i);\n    ixL[i] = szL[il];\n    ixR[i] = szR[ir];\n    szL[il]++;\n    szR[ir]++;\n  }\n  FOR(i,n) if(ufL.find(i) == i) {\n    FOR(d,10) bitL[i][d] = BIT(szL[i]);\n  }\n  FOR(i,n) if(ufR.find(i) == i) {\n    FOR(d,10) bitR[i][d] = BIT(szR[i]);\n  }\n\n  lli lans = 0;\n\n  map<tpl<int,int>, int> M;\n  iterIPJ(ipj0,[&](lli i, lli j) {\n    if(!A[i][j]) return;\n    lli il = ufL.find(i), ir = ufR.find(i);\n    while(!ufL.OPEN[il].empty() && ufL.OPEN[il].back().x() == i) {\n      bitL[il][ufL.OPEN[il].back().y()].add(ixL[i],1);\n      ufL.OPEN[il].pop_back();\n    }\n    while(!ufR.OPEN[ir].empty() && ufR.OPEN[ir].back().x() == i) {\n      bitR[ir][ufR.OPEN[ir].back().y()].add(ixR[i],1);\n      ufR.OPEN[ir].pop_back();\n    }\n    int last = M.count(mt(il,ir))?M[mt(il,ir)]:-1;\n    array<lli, 10> oL, oR, cL, cR;\n    FOR(d,10) oL[d] = bitL[il][d].getR(0, szL[il]-1);\n    FOR(d,10) oR[d] = bitR[ir][d].getR(0, szR[ir]-1);\n    FOR(d,10) cL[d] = bitL[il][d].getR(last == -1 ? 0 : ixL[last]+1, ixL[i]);\n    FOR(d,10) cR[d] = bitR[ir][d].getR(last == -1 ? 0 : ixR[last]+1, ixR[i]);\n    FOR(d,10) FOR(d2,10) lans += d*d2*(oL[d]*cR[d2]+cL[d]*oR[d2]-cL[d]*cR[d2]);\n    FOR(d,10) {\n      diag_ans += d*A[i][j]*oL[d];\n      diag_ans += d*A[i][j]*oR[d];\n    }\n    M[mt(il,ir)] = i;\n    while(!ufL.CLOSE[il].empty() && ufL.CLOSE[il].back().x() == i) {\n      bitL[il][ufL.CLOSE[il].back().z()].add(ixL[ufL.CLOSE[il].back().y()],-1);\n      ufL.CLOSE[il].pop_back();\n    }\n    while(!ufR.CLOSE[ir].empty() && ufR.CLOSE[ir].back().x() == i) {\n      bitR[ir][ufR.CLOSE[ir].back().z()].add(ixR[ufR.CLOSE[ir].back().y()],-1);\n      ufR.CLOSE[ir].pop_back();\n    }\n  });\n\n  ans += diag_ans;\n  ans += lans;\n\n  // cerr << mt(l,r) << \" \" << ipj0 << \" \" << diag_ans << \" \" << lans << \" real = \" << rdiag_ans << \" \" << rlans << endl;\n  // assert(rdiag_ans == diag_ans);\n  // assert(rlans == lans);\n}\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  cin>>n;\n  FOR(i,n) {\n    FOR(j,n) {\n      // A[i][j] = rand()%4;\n      // cout << A[i][j] << ' ';\n      char c; cin>>c;\n      if(c == '#') A[i][j] = 0;\n      else A[i][j] = c-'0';\n    }\n    // cout << endl;\n  }\n  ans = 0;\n  solve(0,2*n-2);\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = 505;\nint n;\nchar c[maxn][maxn];\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%s\", c[i]);\n  }\n  return true;\n}\n\nchar used[maxn][maxn];\nint ls[maxn], rs[maxn];\nint len[maxn][maxn];\nint nxt[maxn];\nint prv[maxn];\nint s[maxn];\n\nvoid solve() {\n  long long res = 0;\n  for (int i0 = 0; i0 < n; i0++) {\n    memset(used, 0, sizeof(used));\n    for (int i = n - 1; i >= 0; i--) {\n      if (c[i0][i] == '#') {\n        ls[i] = n;\n        rs[i] = 0;\n        continue;\n      }\n      ls[i] = i;\n      rs[i] = i + 1;\n      used[i0][i] = true;\n      if (i + 1 < n && c[i0][i + 1] != '#') {\n        rs[i] = rs[i + 1];\n      }\n    }\n    s[0] = 0;\n    for (int j = 0; j < n; j++) {\n      s[j + 1] = s[j] + (used[i0][j] ? c[i0][j] - '0' : 0);\n    }\n    for (int i = 0; i < n; i++) {\n      if (ls[i] < rs[i]) {\n        res += (c[i0][i] - '0') * (s[rs[i]] - s[ls[i]]);\n        res -= (c[i0][i] - '0') * (c[i0][i] - '0');\n      }\n    }\n    for (int i = i0; i + 1 < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (c[i + 1][j] == '#') {\n          continue;\n        }\n        if (used[i][j] || (j > 0 && used[i + 1][j - 1])) {\n          used[i + 1][j] = true;\n        }\n      }\n      nxt[n] = n;\n      for (int j = n - 1; j >= 0; j--) {\n        if (c[i][j] == '#' || c[i + 1][j] == '#') {\n          nxt[j] = nxt[j + 1];\n        } else {\n          nxt[j] = j;\n        }\n      }\n      prv[0] = -1;\n      for (int j = 0; j < n; j++) {\n        if (c[i][j] == '#' || c[i + 1][j] == '#') {\n          prv[j + 1] = prv[j];\n        } else {\n          prv[j + 1] = j;\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        if (ls[j] < rs[j]) {\n          ls[j] = nxt[ls[j]];\n          rs[j] = prv[rs[j]] + 1;\n        }\n      }\n      nxt[n] = n;\n      for (int j = n - 1; j >= 0; j--) {\n        nxt[j] = (c[i + 1][j] == '#' ? j : nxt[j + 1]);\n      }\n      for (int j = 0; j < n; j++) {\n        if (ls[j] < rs[j]) {\n          rs[j] = nxt[rs[j]];\n        }\n      }\n      s[0] = 0;\n      for (int j = 0; j < n; j++) {\n        s[j + 1] = s[j] + (used[i + 1][j] ? c[i + 1][j] - '0' : 0);\n      }\n      for (int j = 0; j < n; j++) {\n        if (ls[j] < rs[j]) {\n          res += (c[i0][j] - '0') * (s[rs[j]] - s[ls[j]]);\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nstatic mt19937 _g(time(nullptr));\n \ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\nint N;\nvector<vector<char>> A;\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> N;\n    A.assign(N,vector<char>(N));\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            cin >> A[i][j];\n        }\n        \n    }\n    \n}\n\nbool isWall(pii x){\n    return A[x.first][x.second]=='#';\n}\n\nbool isIn(pii x){\n    return (0<=x.first and x.first<N and 0<=x.second and x.second<N);\n}\n\nint bfs(int i,int j){\n    int res=0;\n    queue<pii> q;\n    vector<vector<bool>> seen(N,vector<bool>(N,false));\n    q.emplace(i,j);\n    while(!q.empty()){\n        pii now=q.front();\n        q.pop();\n        for (int k = 0; k < 2; k++)\n        {\n            pii next=now;\n            next.first += dx[k];\n            next.second += dy[k];\n            if(!isIn(next)) continue;\n            if(isWall(next)) continue;\n            if(seen[next.first][next.second]) continue;\n            res += (A[next.first][next.second]-'0');\n            seen[next.first][next.second] = true;\n            q.push(next);\n        }\n    }\n    return res;\n}\n\nint solve(){\n    // DBG(A)\n    int ans=0;\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            if(isWall({i,j})) continue;\n            ans += (A[i][j]-'0')*bfs(i,j);\n        }\n        \n    }\n    cout << ans << endl;   \n\n    // vector<vector<int>> dp(N,vector<int>(N));\n    // for (int i = N-1; i >= 0; i--)\n    // {\n    //     for (int j = N-1; j >= 0; j--)\n    //     {\n    //         dp[i][j] = A[i][j]-'0';\n    //         dp[i][j] = dp[i][j+1]+dp[i+1][j] + ;\n    //     }\n    // }\n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn=511;\nint n,a[maxn][maxn],sum;\nint mk[maxn][maxn],curmk;\nll ans;\nvoid dfs(int x,int y)\n{\n\tmk[x][y]=curmk;sum+=a[x][y];\n\tif(!mk[x+1][y]&&a[x+1][y])dfs(x+1,y);\n\tif(!mk[x][y+1]&&a[x][y+1])dfs(x,y+1);\n}\nvoid dfs2(int x,int y)\n{\n\tassert(mk[x][y]>0);\n\tmk[x][y]=curmk;\n\tif(a[x+1][y])dfs2(x+1,y);\n\telse if(a[x][y+1])dfs2(x,y+1);\n}\nvoid dfs3(int x,int y)\n{\n\tassert(mk[x][y]!=curmk);\n\tmk[x][y]=0;sum-=a[x][y];\n\tif(mk[x][y+1]&&mk[x][y+1]!=curmk&&mk[x-1][y+1]==0)dfs3(x,y+1);\n\tif(mk[x+1][y])dfs3(x+1,y);\n}\nvoid debug()\n{\n\tcerr<<\"mk:\"<<endl;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcerr<<mk[i][j]<<\" \";\n\t\t}\n\t\tcerr<<endl;\n\t}\n}\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tchar c=getreal();\n\t\t\tif(c!='#')a[i][j]=c-'0';\n\t\t}\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tsum=0;\n\t\tmemset(mk,0,sizeof(mk));\n\t\tint lst=-1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\tif(lst==-1)\n\t\t\t\t{\n\t\t\t\t\tcurmk=1;\n\t\t\t\t\tdfs(i,j);\n\t\t\t\t\tlst=j;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurmk=j;\n\t\t\t\t\tif(!mk[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tdfs(i,j);\n\t\t\t\t\t}\n\t\t\t\t\tdfs2(i,j);\n\t\t\t\t\tdfs3(i,lst);\n\t\t\t\t\tlst=j;\n\t\t\t\t}\n\t\t\t\tll csum=sum;\n\t\t\t\tans+=a[i][j]*(sum-a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n//#include <bits/stdc++.h>\n#include \"stdafx.h\"\n#include <stack>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef int LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nlong long ans = 0;\nlong long sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE];\nint val[SIZE][SIZE];\nLL times = 0,times2=0;\ninline LL dfs(int y, int x) {\n//\ttimes++;\n\tif (y > N or x > N or A[y][x] == 0 or reached[y][x]) return 0;\n\treached[y][x] = true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs252(int yy, int xx) {\n\tstack<pr> st;\n\tst.emplace(yy, xx);\n\tint ret = 0;\n\twhile (!st.empty()) {\n\t\tint y=st.top().first, x=st.top().second;\n\t\tif (val[y][x] == 0) {\n\t\t\tval[y][x] = -1;\n\t\t\treached[y][x] = 0;\n\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) st.emplace(y, x+1);\n\t\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) st.emplace(y + 1, x);\n\t\t}\n\t\telse {\n\t\t\tval[y][x] = val[y][x + 1] + val[y + 1][x];\n//\t\t\tif ((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0)) ret+=val[y][x + 1];\n\t//\t\tif ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x])) ret+=val[y][x+1];\n\t\t\tst.pop();\n\t\t}\n\t}\n//\treached[y][x] = 0;\n//\treturn  (( ? dfs2(y, x + 1) : 0) + ( : 0) + A[y][x]);\n\treturn val[yy][xx];\n\n}\n\ninline LL dfs2(int y, int x) {\n\t//times++;\n\treached[y][x] = 0;\n\treturn  (((x + 1 <= N and A[y][x + 1] and reached[y][x + 1] and reached[y - 1][x + 1] == 0) ? dfs2(y, x + 1) : 0 )+ ((y + 1 <= N and A[y + 1][x] and reached[y + 1][x]) ? dfs2(y + 1, x) : 0) + A[y][x]);\n}\nlong long solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i, 1, N) {\n\t\t//cout << \"A\";\n\t\tsum += dfs(x, i);\n\t\t//cout << \"B\";\n\t\t//EFOR(j,x,N)\n\t\t//\tEFOR()\n\t\tsum -= A[x][i];\n\t\tans += (long long)sum* (long long)A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tif (A[x + 1][i] == 0) continue;\n\t\tif (reached[x + 1][i] == 0) continue;\n\t\tif (reached[x][i]) continue;\n\n\t\tsum -= dfs2(x + 1, i);\n\t//\tcout << \"C\" << endl;\n\n\t}\n//\tcout << times << \" \" << times2 << endl;\n\treturn ans;\n}\nlong long solve() {\n\tcin >> N;\n\tEFOR(i, 1, N) {\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1] - '0';\n\t\t}\n\t}\n//\tN = 300;\n//\tEFOR(i, 1, N) EFOR(j, 1, N) A[i][j] = 9;\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bitset {\n  vector<unsigned long long> a;\n  Bitset() {}\n  Bitset(const vector<unsigned long long>& a) : a(a) {}\n\n  Bitset f(const Bitset &o) {\n    vector<unsigned long long> vec(max(o.a.size(), a.size()));\n    for (int i = 0; i < vec.size(); i++) {\n      unsigned long long x = 0, y = 0;\n      if (i < a.size()) x = a[i];\n      if (i < o.a.size()) y = o.a[i];\n      vec[i] = (x | y);\n    }\n    return Bitset(vec);\n  }\n\n  int count() {\n    int ret = 0;\n    for (auto x : a) {\n      ret += __builtin_popcountll(x);\n    }\n    return ret;\n  }\n\n  void reset() {\n    for (auto& x : a) {\n      x = 0;\n    }\n  }\n\n  void set(int v) {\n    int p = v / 64;\n    while (a.size() <= p) a.push_back(0);\n    a[p] |= (1ULL << (v % 64));\n  }\n}a[2][501][10];\n\nint main(int argc, char *argv[]) {\n  std::ios_base::sync_with_stdio(false);\n  vector<int> c(11);\n  int n;\n  cin >> n;\n  long long ans = 0;\n  for (int i = 0, now = 0; i < n; i++, now ^= 1) {\n    for (int j = 1; j <= n; j++) {\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k].reset();\n      }\n    }\n    string s;\n    cin >> s;\n    for (int j = 1; j <= n; j++) {\n      if (s[j - 1] == '#') continue;\n      int v = s[j - 1] - '0';\n      for (int k = 1; k <= 9; k++) {\n        a[now][j][k] = a[now][j - 1][k].f(a[now ^ 1][j][k]);\n        ans += a[now][j][k].count() * k * v;\n      }\n      a[now][j][v].set(c[v]++);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 64\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    while(wek.size() < (v/d)+2) wek.pb(0);\n\t}\n\tvoid upp(int v){\n\t    while(wek.size() < v) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[1505][1505];\nbity B[10][1505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n); //n = 950; srand((unsigned)time(NULL));\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\t//repn(x,9) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+1);\n\t\t\t    repn(w,9) B[w][x].upp(B[w][x-1].wek.size());\n\t\t\t\tif(x){\n\t\t\t\t    repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\t}\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t    repn(w,9) B[w][x].upp(B[w][x-1].wek.size());\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nchar ch[555][555];\n\nint n, F[501][501][501], Sm[501][501], V[501][501];\n\nlong long ans = 0;\n\nint main() {\n    scanf(\"%d\", &n);\n    memset(ch, '#', sizeof ch);\n    for(int i = 1; i <= n; i++) scanf(\"%s\", ch[i] + 1);\n    for(int i = 1; i <= n + 1; i++)\n        for(int j = 1; j <= n + 1; j++)\n            if(i > n || j > n) ch[i][j] = '#';\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++) {\n            V[i][j] = ch[i][j] - '0';\n            if(ch[i][j] == '#') V[i][j] = 0;\n            Sm[i][j] = Sm[i][j - 1] + V[i][j];\n        }\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            for(int k = 1; k <= n; k++)\n                F[i][j][k] = n + 1;\n    for(int i = n; i >= 1; i--)\n        for(int j = n; j >= 1; j--) if(ch[i][j] != '#'){\n            if(ch[i][j + 1] != '#') for(int k = 1; k <= n; k++) {\n                F[i][j][k] = min(F[i][j][k], F[i][j + 1][k]);\n            }\n            if(ch[i + 1][j] != '#') for(int k = 1; k <= n; k++) {\n                F[i][j][k] = min(F[i][j][k], F[i + 1][j][k]);\n            }\n            if(F[i][j][i] == j + 1 && (F[i][j][i + 1] <= j || i == n)) F[i][j][i]--, ans -= V[i][j] * V[i][j];\n            for(int k = 1; k <= n; k++) ans += V[i][j] * (Sm[k][n] - Sm[k][F[i][j][k] - 1]);\n        }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (3,\"unroll-all-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace whatever{\n\tint readu(){\n\t\tchar ch=getchar();\n\t\twhile(!isdigit(ch))\n\t\t\tch=getchar();\n\t\tint value=ch-'0';\n\t\tch=getchar();\n\t\twhile(isdigit(ch)){\n\t\t\tvalue=value*10+ch-'0';\n\t\t\tch=getchar();\n\t\t}\n\t\treturn value;\n\t}\n\tvoid writeull(long long n){\n\t\tif(n<10)\n\t\t\tputchar(n+'0');\n\t\telse{\n\t\t\twriteull(n/10);\n\t\t\tputchar(n%10+'0');\n\t\t}\n\t}\n\tstruct set_type{\n\t\tunsigned *data;\n\t\tint size;\n\t\tvoid clear(){\n\t\t\tmemset(data, 0, sizeof(unsigned)*size);\n\t\t}\n\t\tvoid resize(int k){\n\t\t\tsize=(k+31)/32;\n\t\t\tdata=new unsigned[size];\n\t\t\tclear();\n\t\t}\n\t\tvoid operator=(const set_type &b){\n\t\t\tassert(size==b.size);\n\t\t\tmemcpy(data, b.data, sizeof(unsigned)*size);\n\t\t}\n\t\tvoid operator|=(const set_type &b){\n\t\t\tassert(size==b.size);\n\t\t\tfor(int i=0; i<size; ++i)\n\t\t\t\tdata[i]|=b.data[i];\n\t\t}\n\t\tint count(){\n\t\t\tint result=0;\n\t\t\tfor(int i=size-1; i!=-1; --i)\n\t\t\t\tresult+=__builtin_popcount(data[i]);\n\t\t\treturn result;\n\t\t}\n\t\tvoid set(unsigned index){\n\t\t\tassert(index<size*32);\n\t\t\tdata[index/32]|=(1u<<(index%32));\n\t\t}\n\t};\n\tvoid run(){\n\t\tint n=readu();\n\t\tstatic char a[500][502];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tgets(a[i]);\n\t\tstatic int cnt[10];\n\t\tstatic int index[500][500];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tif(a[i][j]!='#'){\n\t\t\t\t\tassert(isdigit(a[i][j]));\n\t\t\t\t\tindex[i][j]=cnt[a[i][j]-'0']++;\n\t\t\t\t}\n\t\tstatic set_type set_data[2][500][10];\n\t\tfor(int i=0; i<2; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tfor(int k=0; k<10; ++k)\n\t\t\t\t\tset_data[i][j][k].resize(cnt[k]);\n\t\tset_type (*cur_set_data)[10]=set_data[0];\n\t\tset_type (*next_set_data)[10]=set_data[1];\n\t\tlong long result=0;\n\t\tfor(int r=n-1; r>=0; --r){\n\t\t\tfor(int c=n-1; c>=0; --c){\n\t\t\t\tif(isdigit(a[r][c])){\n\t\t\t\t\tfor(int i=0; i<10; ++i){\n\t\t\t\t\t\tnext_set_data[c][i]=cur_set_data[c][i];\n\t\t\t\t\t\tif(c<n-1)\n\t\t\t\t\t\t\tnext_set_data[c][i]|=next_set_data[c+1][i];\n\t\t\t\t\t\tresult+=(long long)next_set_data[c][i].count()*i*(a[r][c]-'0');\n\t\t\t\t\t\tif(i==a[r][c]-'0')\n\t\t\t\t\t\t\tnext_set_data[c][i].set(index[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int i=0; i<10; ++i)\n\t\t\t\t\t\tnext_set_data[c][i].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur_set_data, next_set_data);\n\t\t}\n\t\twriteull(result);\n\n\t}\n}\nint main(){\n\twhatever::run();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1<<29)\nusing namespace std;\nconst int N=505;\nchar s[N];\nint n,cnt[N];\nll ans;\nint a[N][N],sum[N][N];\nint l[N][N],r[N][N];\nint tl[N][N],tr[N][N];\nvoid recalc(int i){\n\tFor(j,1,n) sum[i][j]=sum[i][j-1]+a[i][j];\n}\nint S(int i,int l,int r){\n\treturn sum[i][r]-sum[i][l-1];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFor(j,1,n) a[i][j]=(s[j]=='#'?0:s[j]-48);\n\t\trecalc(i);\n\t}\n\tFor(i,1,n) For(j,1,n)\n\t\tl[i][j]=n+1,r[i][j]=0;\n\tRep(x,n,1){\n\t\tFor(i,x,n) For(j,1,n)\n\t\t\ttl[i][j]=n+1,tr[i][j]=0;\n\t\tFor(y,x,n)\n\t\t\tif (y==x){\n\t\t\t\tRep(j,n,1) if(a[x][j]){\n\t\t\t\t\ttl[y][j]=j;\n\t\t\t\t\ttr[y][j]=max(j,j==n?0:tr[y][j+1]);\n\t\t\t\t\tans+=a[y][j]*S(y,tl[y][j]+1,tr[y][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tRep(j,n,1) if (a[x][j]){\n\t\t\t\t\ttl[y][j]=min(l[y][j],j==n?n+1:tl[y][j+1]);\n\t\t\t\t\ttr[y][j]=max(r[y][j],j==n?0:tr[y][j+1]);\n\t\t\t\t}\n\t\t\t\tFor(j,1,n) cnt[j]=0;\n\t\t\t\tFor(j,1,n) if (tl[y][j]<=tr[y][j]){\n\t\t\t\t\t++cnt[tl[y][j]];\n\t\t\t\t\t--cnt[tr[y][j]+1];\n\t\t\t\t}\n\t\t\t\tbool flag=0;\n\t\t\t\tFor(j,1,n){\n\t\t\t\t\tcnt[j]+=cnt[j-1];\n\t\t\t\t\tif (!cnt[j]&&a[y][j])\n\t\t\t\t\t\ta[y][j]=0,flag=1;\n\t\t\t\t}\n\t\t\t\tif (flag) recalc(y);\n\t\t\t\tFor(j,1,n)\n\t\t\t\t\tif (tl[y][j]<=tr[y][j])\n\t\t\t\t\t\tans+=a[x][j]*S(y,tl[y][j],tr[y][j]);\n\t\t\t}\n\t\tFor(i,x,n) For(j,1,n)\n\t\t\tl[i][j]=tl[i][j],r[i][j]=tr[i][j];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N, m;\nll ans;\n\nint meet[1500][1500], lo[1500][1500], hi[1500][1500], bot[1500][1500];\nint cum[1500], ri[1500][1500], le[1500][1500], tot[1500][1500];\n// ri: row <= r, right < b\n// le: row <= r, left > a \n// tot: a < left <= right < b\n\nvector<string> transpose(vector<string> A) {\n    vector<string> a(sz(A[0]));\n    F0R(i,sz(A)) F0R(j,sz(A[0])) a[j] += A[i][j];\n    return a;\n}\n\nint meetPoint(int a, int b) {\n    int x = meet[a][b]; if (x > min(bot[m+1][a],bot[m+1][b])) return MOD;\n    return x;\n}\n\nint bothReach(int a, int b, int r) {\n    if (meetPoint(a,b) > r) return 0;\n    ckmin(r,min(bot[m+1][a],bot[m+1][b]));\n    // ps(\"HUH\",r,cum[r],ri[r][b],le[r][a],tot[a][b]);\n    return cum[r]-ri[r][b]-le[r][a]+tot[a][b];\n}\n\nint reach(int a) { return bothReach(a,a,MOD); }\n\nvoid initLo(const vector<string>& A) {\n    FOR(i,m+1,sz(A)) F0R(j,sz(A[0])) {\n        lo[i][j] = MOD, hi[i][j] = -MOD;\n        if (A[i][j] == '#') continue;\n        if (i == m+1) lo[i][j] = hi[i][j] = j;\n        if (i > m+1) ckmin(lo[i][j],lo[i-1][j]), ckmax(hi[i][j],hi[i-1][j]);\n        if (j) ckmin(lo[i][j],lo[i][j-1]), ckmax(hi[i][j],hi[i][j-1]);\n    }\n    FORd(i,m+1,sz(A)) F0Rd(j,sz(A[0])) {\n        bot[i][j] = -MOD; if (A[i][j] == '#') continue;\n        bot[i][j] = i;\n        if (j+1 < sz(A[0])) ckmax(bot[i][j],bot[i][j+1]);\n        if (i+1 < sz(A)) ckmax(bot[i][j],bot[i+1][j]);\n        // ps(i,j,bot[i][j]);\n    }\n    // exit(0);\n    F0R(i,sz(A[0])) FOR(j,i,sz(A[0])) {\n        meet[i][j] = MOD;\n        tot[i][j] = 0;\n    }\n    FOR(i,m+1,sz(A)) F0R(j,sz(A[0])) if (lo[i][j] != MOD) {\n        ckmin(meet[lo[i][j]][hi[i][j]],i);\n        if (lo[i][j] > 0 && hi[i][j]+1 < sz(A[0])) tot[lo[i][j]-1][hi[i][j]+1] += A[i][j]-'0';\n    }\n    F0R(i,sz(A[0])) FORd(j,i+1,sz(A[0])) {\n        ckmin(meet[i+1][j],meet[i][j]); ckmin(meet[i][j-1],meet[i][j]);\n    }\n    F0Rd(i,sz(A[0])) FOR(j,i+1,sz(A[0])) {\n        tot[i][j] += tot[i+1][j]+tot[i][j-1];\n        if (i+2 <= j) tot[i][j] -= tot[i+1][j-1];\n    }\n    // ps(meet[0][0],meet[0][1],meet[1][1]);\n    cum[m] = 0; F0R(j,sz(A[0])) ri[m][j] = le[m][j] = 0;\n    FOR(i,m+1,sz(A)) {\n        cum[i] = cum[i-1];\n        F0R(j,sz(A[0])) ri[i][j] = le[i][j] = 0;\n        F0R(j,sz(A[0])) if (lo[i][j] != MOD) {\n            cum[i] += A[i][j]-'0';\n            if (hi[i][j]+1 < sz(A[0])) ri[i][hi[i][j]+1] += A[i][j]-'0';\n            if (lo[i][j]-1 >= 0) le[i][lo[i][j]-1] += A[i][j]-'0';\n        }\n        FOR(j,1,sz(A[0])) ri[i][j] += ri[i][j-1];\n        F0Rd(j,sz(A[0])-1) le[i][j] += le[i][j+1];\n        // ps(\"WUT\",i,ri[i][3], le[i][0]);\n        F0R(j,sz(A[0])) {\n            ri[i][j] += ri[i-1][j];\n            le[i][j] += le[i-1][j];\n        }\n    }\n    /*ps(reach(0), reach(1), bothReach(0,1,1), bothReach(0,1,2), bothReach(0,1,0));\n    exit(0);*/\n    /*FOR(i,m+1,sz(A)) F0R(j,sz(A[0])) {\n        ps(i,j,bot[i][j],lo[i][j],hi[i][j]);\n    }*/\n    //ps(bothReach(0,0,MOD)); exit(0);\n    //ps(reach(0),reach(2),reach(3),bot[2][0],bot[2][2],bot[2][3]); exit(0);\n    //ps(bothReach(0,2,3),bothReach(0,2,2),bothReach(0,3,3), bothReach(2,3,2)); exit(0);\n}\n\nint MN[1500][1500], MX[1500][1500], HI[1500][1500];\n\nvoid initHi(const vector<string>& A) {\n    F0Rd(i,m+1) F0Rd(j,sz(A[0])) {\n        MN[i][j] = MOD, MX[i][j] = -MOD;\n        if (A[i][j] == '#') continue;\n        if (i == m) MN[i][j] = MX[i][j] = j;\n        if (i+1 <= m) ckmin(MN[i][j],MN[i+1][j]), ckmax(MX[i][j],MX[i+1][j]);\n        if (j+1 < sz(A[0])) ckmin(MN[i][j],MN[i][j+1]), ckmax(MX[i][j],MX[i][j+1]);\n    }\n    // ps(MN[0][0],MX[0][0],MN[0][1],MX[0][1]); exit(0);\n    F0R(i,m+1) F0R(j,sz(A[0])) {\n        HI[i][j] = MOD; if (A[i][j] == '#') continue;\n        HI[i][j] = i;\n        if (i) ckmin(HI[i][j],HI[i-1][j]);\n        if (j) ckmin(HI[i][j],HI[i][j-1]);\n    }\n    // ps(HI[0][0],HI[0][1]);\n}\n\nll cur;\ndeque<array<int,3>> yes; // pos, low point, cans\nint dumb[1500];\n\nvoid ad(int x) {\n    if (lo[m+1][x] == MOD) return;\n    array<int,3> tmp = {x,bot[m+1][x],reach(x)}; cur += tmp[2];\n    int lst = 0;\n    while (sz(yes)) {\n        int t = bothReach(yes.back()[0],tmp[0],MOD)-bothReach(yes.back()[0],tmp[0],lst);\n        cur -= t; yes.back()[2] -= t; lst = yes.back()[1];\n        if (yes.back()[1] <= tmp[1]) dumb[yes.back()[0]] = yes.back()[2], yes.pop_back();\n        else break;\n    }\n    yes.pb(tmp);\n}\n\nvoid del(int x) {\n    if (lo[m+1][x] == MOD) return;\n    if (sz(yes) && yes.front()[0] == x) {\n        assert(dumb[x] == -1);\n        cur -= yes.front()[2]; yes.pop_front();\n        return;\n    } else {\n        assert(dumb[x] != -1); \n        cur -= dumb[x];\n    }\n}\n\nvoid solve(vector<string> A) {\n    if (sz(A) < sz(A[0])) A = transpose(A);\n    if (sz(A) == 1) return;\n    m = (sz(A)-1)/2;\n    initLo(A); initHi(A);\n    F0R(i,m+1) {\n        int l = 0, r = -1; cur = 0;\n        while (sz(yes)) yes.pop_back();\n        F0R(j,sz(A[0])) dumb[j] = -1;\n        F0R(j,sz(A[0])) if (MX[i][j] != -MOD) {\n            while (r < MX[i][j]) {\n                r ++; \n                if (HI[m][r] <= i) ad(r);\n            }\n            while (l < MN[i][j]) {\n                if (HI[m][l] <= i) del(l);\n                l ++;\n            }\n            ans += (A[i][j]-'0')*cur;\n        }\n    }\n    auto x = vector<string>(A.begin(),A.begin()+m+1);\n    auto y = vector<string>(A.begin()+m+1,A.end());\n    solve(x); solve(y);\n}\n\nint main() {\n    setIO(); re(N);\n    vector<string> A(N); re(A);\n    solve(A); ps(ans);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    while(wek.size() < (v/d)+2)) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trepn(x,9) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(C[f[x][y]-'0']);\n\t\t\t\tif(x) repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 500;\nconst int oo = 0x3f3f3f3f;\n\nint n;\nint a[N + 5][N + 5];\nint f[N + 5][N + 5];\nchar st[N + 5][N + 5];\nint L[N + 5][N + 5], R[N + 5][N + 5];\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; ++i) {\n        scanf(\"%s\", st[i] + 1);\n        for(int j = 1; j <= n; ++j) {\n            a[i][j] = (st[i][j] == '#') ? 0 : st[i][j] - '0';\n        }\n    }\n\n    long long ans = 0;\n    for(int j = n; j >= 1; --j) if(a[n][j] > 0) {\n        L[n][j] = j; \n\n        if(a[n][j + 1] > 0) {\n            f[n][j] = f[n][j + 1];\n            R[n][j] = R[n][j + 1];\n        } else {\n            R[n][j] = j;\n        }\n\n        ans += a[n][j] * f[n][j];\n        f[n][j] += a[n][j];\n    }\n\n    for(int i = n - 1; i >= 1; --i) {\n        for(int j = n; j >= 1; --j) if(a[i][j] > 0) {\n            bool r = (a[i][j + 1] > 0), d = (a[i + 1][j] > 0);\n\n            if(!r && !d) {\n                L[i][j] = R[i][j] = j;\n                for(int k = i + 1; k <= n; ++k) L[k][j] = oo, R[k][j] = -oo;\n            } else if(r && !d) {\n                L[i][j] = j;\n                R[i][j] = R[i][j + 1];\n                f[i][j] = f[i][j + 1];\n                for(int k = i + 1; k <= n; ++k) L[k][j] = L[k][j + 1], R[k][j] = R[k][j + 1];\n            } else if(!r && d) {\n                f[i][j] = f[i + 1][j];\n                L[i][j] = R[i][j] = j;\n            } else {\n                L[i][j] = j; R[i][j] = R[i][j + 1];\n                f[i][j] = f[i + 1][j] + f[i][j + 1];\n\n                int lim = 0;\n                for(int k = i + 1; k <= n; ++k) {\n                    if(R[k][j] >= L[k][j + 1] && L[k][j + 1] > lim) {\n                        f[i][j] -= f[k][L[k][j + 1]];\n                    }\n                    lim = R[k][j];\n                    L[k][j] = min(L[k][j], L[k][j + 1]);\n                    R[k][j] = max(R[k][j], R[k][j + 1]);\n                }\n            }\n            \n            ans += a[i][j] * f[i][j];\n            f[i][j] += a[i][j];\n        }\n    }\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define fi first\n#define se second\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define eef(i,x)for(int i=head[x],y=e[i].to;y;i=e[i].next,y=e[i].to)\nint read(){char c=getchar();int d=0,f=1;for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;for(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());return d*f;}\nchar Read(){char c=getchar();while(c<'0'||c>'9')c=getchar();return c;}\nint getdigit(char c){return (c<'0'||c>'9')?-1e9:(c-'0');}\ntypedef pair<int,int>PII;\ntypedef long long LL;\nconst double pi=acos(-1);\nconst int N=1510,mod=1e9+7;\nint n,c1[N][N],c2[N][N];LL ans,dp[N][N];\nchar a[N][N];\nint main(){\n\tn=read();\n\tref(i,1,n)scanf(\"%s\",a[i]+1);\n\tref(i,1,n){\n\t\tif(i==1){\n\t\t\tref(j,1,n)dp[i][j]=max(0LL,dp[i][j-1]+getdigit(a[i][j]));\n\t\t\tref(j,1,n)c1[j][1]=j;\n\t\t\tcontinue;\n\t\t}\n\t\tref(j,1,n){\n\t\t\tbool w1=getdigit(a[i][j-1])>=0,w2=getdigit(a[i-1][j])>=0;\n\t\t\tbool W1=getdigit(a[i-1][j-1])>=0,W2=getdigit(a[i-2][j])>=0;\n\t\t\tref(k,1,i){\n\t\t\t\tint C1=0;\n\t\t\t\tif(k==i)C1=j;else{\n\t\t\t\t\tif(w1)C1=c1[j-1][k];\n\t\t\t\t\tif(w2)C1=max(C1,c1[j][k]);\n\t\t\t\t}\n\t\t\t\tc1[j][k]=C1;\n\t\t\t}\n\t\t\tref(k,1,i-1){\n\t\t\t\tint C2=1e9;\n\t\t\t\tif(k==i-1)C2=j;\n\t\t\t\tif(W1)C2=c2[j-1][k];\n\t\t\t\tif(W2&&k!=i-1)C2=min(C2,c2[j][k]);\n\t\t\t\tc2[j][k]=C2;\n\t\t\t}\n\t\t}\n\t\tref(j,1,n)if(getdigit(a[i][j])>=0){\n\t\t\tint v=getdigit(a[i][j]);\n\t\t\tbool w1=getdigit(a[i][j-1])>=0,w2=getdigit(a[i-1][j])>=0;\n\t\t\tif(j==1){\n\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t}else if(j>1){\n\t\t\t\tif(!w1&&!w2)dp[i][j]=0;else\n\t\t\t\tif( w1&&!w2)dp[i][j]=dp[i][j-1];else\n\t\t\t\tif(!w1&& w2)dp[i][j]=dp[i-1][j];else\n\t\t\t\tif( w1&& w2){\n\t\t\t\t\tLL s=dp[i-1][j]+dp[i][j-1],la=1e9;\n\t\t\t\t\tdef(k,i-1,1){\n\t\t\t\t\t\tif(c1[j-1][k]>=c2[j][k]&&la>c1[j-1][k])\n\t\t\t\t\t\t\ts-=dp[k][c1[j-1][k]];\n\t\t\t\t\t\tla=c2[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]=s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j]+=v;\n\t\t}\n\t}\n\tref(i,1,n)ref(j,1,n){\n\t\tint v=getdigit(a[i][j]);\n\t\tif(v>=0)ans+=(dp[i][j]-v)*v;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\ttypedef long long ll;\n\tconst int N=509;\n\tll ans;int n,maxn[2][N][N],minn[2][N][N],sum[N][N],pos[N][N];char s[N][N];\n\tint main(){\n\t\tn=read<int>();\n\t\tfor(int i=1;i<=n;i++) scanf(\"%s\",s[i]+1);\n\n\t\tint cur=0;\n\t\tfor(int i=n;i;i--){\n\t\t\tint pre=cur;cur^=1;\n\t\t\tfor(int j=n;j;j--) if(s[i][j]!='#'){\n\t\t\t\tsum[i][j]=sum[i][j+1]+sum[i+1][j]+s[i][j]-'0';\n\t\t\t\tpos[i][j]=max(max(pos[i][j+1],pos[i+1][j]),i);\n\n\t\t\t\tminn[cur][j][i]=j;\n\t\t\t\tfor(int k=i+1;k<=pos[i+1][j];k++) minn[cur][j][k]=minn[pre][j][k];\n\t\t\t\tfor(int k=max(pos[i+1][j],i)+1;k<=pos[i][j+1];k++) minn[cur][j][k]=minn[cur][j+1][k];\n\t\t\t\t\n\t\t\t\tmaxn[cur][j][i]=j;\n\t\t\t\tfor(int k=i;k<=pos[i][j+1];k++) maxn[cur][j][k]=maxn[cur][j+1][k];\n\t\t\t\tfor(int k=max(pos[i][j+1],i)+1;k<=pos[i+1][j];k++) maxn[cur][j][k]=maxn[pre][j][k];\n\n\t\t\t\tint d=i+1,r=min(pos[i+1][j],pos[i][j+1]);\n\t\t\t\twhile(d<=r){\n\t\t\t\t\tif(maxn[pre][j][d]>=minn[cur][j+1][d]){\n\t\t\t\t\t\tsum[i][j]-=sum[d][minn[cur][j+1][d]];\n\t\t\t\t\t\td=pos[d][minn[cur][j+1][d]];\n\t\t\t\t\t}\n\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tans+=1LL*(s[i][j]-'0')*(sum[i][j]-s[i][j]+'0');\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define N 505\ninline int min(int x,int y){return x<y?x:y;}\ninline int max(int x,int y){return x<y?y:x;}\nint A[N],B[N][N],C[N][N],D[N][N],E[N][N],F[N][N],X,a[N][N],b[N][N],d[N],e[N],f[N][N],g[N],h,i,j,k,o,p,q[N],t;char c[N][N],s[N][N];long long x;\ninline int get(int x,int y,int z){return f[x][y]<=z?z=min(z,min(d[x],d[y])),A[z]-B[z][x+1]-C[z][y-1]+D[x+1][y-1]:0;}\ninline void solve(int m,int n)\n{\n    for(i=1;i<=m;i++)a[i][0]=a[i][n+1]=n+1,b[i][0]=b[i][n+1]=E[i][n+1]=0,E[i][0]=m+1;\n    for(j=1;j<=n;j++)a[0][j]=a[m+1][j]=n+1,b[0][j]=b[m+1][j]=E[m+1][j]=0,E[0][j]=m+1;\n    for(i=0;i<=n;i++)memset(D[i+1],0,n+1<<2),memset(F[i]+1,0x3f,n+1<<2);\n    for(h=m+2>>1,memset(A+h-1,0,m-h+2<<2),i=h-1;i<=m;i++)memset(B[i]+1,0,n+1<<2),memset(C[i],0,n+1<<2);\n    for(j=1;j<=n;j++)!c[h][j]?a[h][j]=n+1,b[h][j]=0:a[h][b[h][j]=j]=min(a[h][j-1],j);\n    for(i=h+1;i<=m;i++)for(j=1;j<=n;j++)c[i][j]?a[i][j]=min(a[i-1][j],a[i][j-1]),b[i][j]=max(b[i-1][j],b[i][j-1]):(a[i][j]=n+1,b[i][j]=0);\n    for(i=m;i>=h;i--)for(j=n;j;j--)E[i][j]=c[i][j]?max(max(E[i+1][j],E[i][j+1]),i):0;\n    for(memcpy(d+1,E[h]+1,n<<2),i=1;i<=h;i++)for(j=1;j<=n;j++)E[i][j]=c[i][j]?min(min(E[i-1][j],E[i][j-1]),i):m+1;\n    for(memcpy(e+1,E[h]+1,n<<2),i=m;h<=i;i--)for(j=1;j<=n;j++)if(a[i][j]<=b[i][j])A[i]+=c[i][j],B[i][a[i][j]]+=c[i][j],C[i][b[i][j]]+=c[i][j],D[a[i][j]][b[i][j]]+=c[i][j],F[a[i][j]][b[i][j]]=i;\n    for(i=h;i<=m;i++)for(j=1;j<=n;j++)C[i][j]+=C[i-1][j]+C[i][j-1]-C[i-1][j-1];\n    for(i=h;i<=m;A[i]+=A[i-1],i++)for(j=n;j;j--)B[i][j]+=B[i-1][j]+B[i][j+1]-B[i-1][j+1];\n    for(i=n;i;i--)for(j=1;j<=n;j++)D[i][j]+=D[i+1][j]+D[i][j-1]-D[i+1][j-1];\n    for(i=1;i<=n;i++)for(j=n;j;j--)F[i][j]=min(min(F[i-1][j],F[i][j+1]),F[i][j]);\n    for(i=1;i<=n;i++)for(j=i;j<=n;j++)f[i][j]=F[i][j]<=min(d[i],d[j])?F[i][j]:m+1;\n    for(j=n;j;j--)!c[h][j]?a[h][j]=n+1,b[h][j]=0:b[h][a[h][j]=j]=max(b[h][j+1],j);\n    for(i=h;--i;)for(j=n;j;j--)c[i][j]?a[i][j]=min(a[i+1][j],a[i][j+1]),b[i][j]=max(b[i+1][j],b[i][j+1]):(a[i][j]=n+1,b[i][j]=0);\n    for(i=1;i<h;i++)for(j=1,k=t=1,X=o=p=0;j<=n;j++)if(a[i][j]<=b[i][j])\n    {\n        while(k<=b[i][j])\n        if(e[k]<=i)\n        {\n            for(q[p]=0;o<p&&d[q[p]]<d[k];p--)X-=g[q[p-1]],X+=g[q[p-1]]-=get(q[p-1],k,min(d[q[p-1]],d[k]))-get(q[p-1],k,min(d[q[p]],d[k]));\n            X+=g[q[++p]=k]=get(k,k,m),p++,k++;\n        }\n        else k++;\n        while(t<a[i][j])e[t]<=i?X-=g[t]:0,t++;\n        while(o<p&&q[o]<a[i][j])o++;\n        x+=X*c[i][j];\n    }\n}\nvoid dfs(int l,int r,int L,int R)\n{\n    if(l==r&&L==R)return;\n    else if(r-l<R-L)\n    {\n        for(i=0;i<=R-L;i++)for(j=0;j<=r-l;j++)c[i+1][j+1]=s[j+l][i+L];\n        solve(R-L+1,r-l+1),dfs(l,r,L,L+R-1>>1),dfs(l,r,L+R+1>>1,R);\n    }\n    else\n    {\n        for(i=0;i<=r-l;i++)memcpy(c[i+1]+1,s[i+l]+L,R-L+1<<2);\n        solve(r-l+1,R-L+1),dfs(l,l+r-1>>1,L,R),dfs(l+r+1>>1,r,L,R);\n    }\n}\nint n;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)for(scanf(\"%s\",s[i]+1),j=1;j<=n;j++)s[i][j]=s[i][j]=='#'?0:s[i][j]^48;\n    dfs(1,n,1,n),printf(\"%lld\\n\",x);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint val[N][N],b[N][N],S[N],n,u[N][N],l[N],r[N];\nchar A[N][N];\nbool flag[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9',b[i][j]=A[i][j]-'0';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=x?b[x][j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x][j]){\n\t\t\t\tl[j]=j-1;\n\t\t\t\tr[j]=max(r[j+1],j);\n\t\t\t\tval[x][j]+=(S[r[j]]-S[l[j]]-b[x][j]);\n\t\t\t}\n\t\t\telse l[j]=1e9,r[j]=-1;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?b[x][j]:0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tl[j]=min(l[j+1],l[j]);\n\t\t\t\t\tr[j]=max(r[j+1],r[j]);\n\t\t\t\t\tif (l[j]<=r[j])val[i][j]+=(S[r[j]]-S[l[j]]);\n\t\t\t\t}\n\t\t\t\telse l[j]=1e9,r[j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)ans+=val[i][j]*b[i][j];\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[2][N],r[2][N],flag[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int i=x;i;--i){\n\t\t\tint t=i&1;\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tl[t][j]=min(l[t][j+1],i==x?j:l[t^1][j]);\n\t\t\t\t\tr[t][j]=max(r[t][j+1],i==x?j:r[t^1][j]);\n\t\t\t\t\tif (l[t][j]<=r[t][j])ans+=(A[i][j]-'0')*(S[r[t][j]]-S[l[t][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t\t}\n\t\t\t\telse l[t][j]=1e9,r[t][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nmax=1e3+3;\nint n,v[nmax][nmax],d[nmax][nmax],p1,sol;\nchar s;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n;\n    for(int i=1;i<=n;++i)\n    {\n        for(int j=1;j<=n;++j)\n        {\n            cin>>s;\n            if(s=='#') continue;\n            v[i][j]=s-'0';\n        }\n    }\n    for(int i=1;i<=n;++i)\n    {\n        for(int j=1;j<=n;++j)\n        {\n            if(!v[i][j]) continue;\n            memset(d,0,sizeof(d));\n            d[i][j]=1;\n            p1=v[i][j];\n            for(int t1=i;t1<=n;++t1)\n            {\n                for(int t2=j;t2<=n;++t2)\n                {\n                    if(t1==i&&t2==j) continue;\n                    if(!v[t1][t2]) continue;\n                    d[t1][t2]=max(d[t1-1][t2],d[t1][t2-1]);\n                    if(d[t1][t2]) sol+=p1*v[t1][t2];\n                }\n            }\n        }\n    }\n    cout<<sol;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 505;\n\nint n;\nchar buf[N];\nint a[N][N];\nint row[N][N];\nint L[2][N][N];\nint R[2][N][N];\n\nvoid del(int x,int y) {\n\tif (x > 0 && x <= n && y > 0 && y <= n && a[x][y]) {\n\t\tif (x == 1 || a[x - 1][y] == 0) {\n\t\t\tif (y == 1 || a[x][y - 1] == 0) {\n\t\t\t\tfor (int i = y; i <= n; ++i) {\n\t\t\t\t\trow[x][i] -= a[x][y];\n\t\t\t\t}\n\t\t\t\ta[x][y] = 0;\n\t\t\t\tdel(x + 1, y);\n\t\t\t\tdel(x, y + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%s\", buf + 1);\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\ta[i][j] = (buf[j] == '#' ? 0 : buf[j] - '0');\n\t\t}\n\t}\n\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\trow[i][j] = row[i][j - 1] + a[i][j];\n\t\t}\n\t}\n\t\n\tlong long ans = 0;\n\tmemset(L, 69, sizeof L);\n\tfor (int i = n; i > 0; --i) {\n\t\tfor (int j = n; j > 0; --j) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tL[1][j][i] = j;\n\t\t\tR[1][j][i] = j;\n\t\t\tif (i < n && a[i + 1][j]) {\n\t\t\t\tfor (int k = i + 1; k <= n; ++k) {\n\t\t\t\t\tL[1][j][k] = min(L[1][j][k], L[0][j][k]);\n\t\t\t\t\tR[1][j][k] = max(R[1][j][k], R[0][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j < n && a[i][j + 1]) {\n\t\t\t\tfor (int k = i; k <= n; ++k) {\n\t\t\t\t\tL[1][j][k] = min(L[1][j][k], L[1][j + 1][k]);\n\t\t\t\t\tR[1][j][k] = max(R[1][j][k], R[1][j + 1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint val = 0;\n\t\t\tfor (int k = i; k <= n; ++k) {\n\t\t\t\tif (L[1][j][k] <= R[1][j][k]) {\n\t\t\t\t\tval += row[k][R[1][j][k]] - row[k][L[1][j][k] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (long long) (a[i][j]) * (val - a[i][j]);\n\t\t\tdel(i, j);\n\t\t}\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tfor (int k = i; k <= n; ++k) {\n\t\t\t\tL[0][j][k] = L[1][j][k];\n\t\t\t\tR[0][j][k] = R[1][j][k];\n\t\t\t\tL[1][j][k] = 1e9;\n\t\t\t\tR[1][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define Reachable(a) (BothReachable((a),(a),HL))\nusing namespace std;\ntemplate<class T> void read(T &x)\n{\n    x=0; int f=1,ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=getchar();}\n    x*=f;\n}\ntemplate<class T> inline bool Cmin(T &x,T y) {return x>y?x=y,1:0;}\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;}\ntypedef long long ll;\nconst int inf=1e9;\nconst int maxn=1500+50;\nint n;\nchar s[maxn][maxn];\nll an;\nint has[maxn];\nint Top[maxn];\nint sum1[maxn];\nint Bottom[maxn];\nint f[maxn][maxn];\nint L[maxn][maxn];\nint U[maxn][maxn];\nint Min[maxn][maxn];\nint Max[maxn][maxn];\nint Left[maxn][maxn];\nint sum2[maxn][maxn];\nint sum3[maxn][maxn];\nint sum4[maxn][maxn];\nint Right[maxn][maxn];\nint MeetingPoint[maxn][maxn];\nint a[2][maxn][maxn];\nvoid calc_Top(int H,int W)\n{\n    for(int i=1;i<=H;++i) for(int j=1;j<=W;++j)\n    {\n        f[i][j]=inf; \n        if(U[i][j])\n        { \n            f[i][j]=i;\n            if(i!=1) Cmin(f[i][j],f[i-1][j]);\n            if(j!=1) Cmin(f[i][j],f[i][j-1]);\n        }\n    }\n    for(int j=1;j<=W;++j) Top[j]=f[H][j];\n}\nvoid calc_Bottom(int H,int W)\n{\n    for(int i=H;i>=1;--i) for(int j=W;j>=1;--j)\n    {\n        f[i][j]=-inf;\n        if(L[i][j])\n        {\n            f[i][j]=i;\n            if(i!=H) Cmax(f[i][j],f[i+1][j]);\n            if(j!=W) Cmax(f[i][j],f[i][j+1]);\n        }\n    }\n    for(int j=1;j<=W;++j) Bottom[j]=f[1][j];\n}\nvoid init_MeetingPoint(int H,int W)\n{\n    for(int i=1;i<=W;++i) for(int j=1;j<=W;++j) f[i][j]=inf;\n    for(int i=1;i<=H;++i) for(int j=1;j<=W;++j)\n    {\n        if(Left[i][j]<=Right[i][j]) Cmin(f[Left[i][j]][Right[i][j]],i);\n    }\n    for(int len=W;len>1;--len) for(int l=1,r=len;r<=W;++l,++r)\n    {\n        Cmin(f[l+1][r],f[l][r]),Cmin(f[l][r-1],f[l][r]);\n    }\n    for(int a=1;a<=W;++a) for(int b=a;b<=W;++b)\n    {\n        MeetingPoint[a][b]=f[a][b]>min(Bottom[a],Bottom[b])?inf:f[a][b];\n    }\n}\nvoid init_BothReachable(int H,int W)\n{\n    for(int i=1;i<=H;++i) sum1[i]=0;\n    for(int i=1;i<=H;++i) for(int j=1;j<=W;++j) sum2[i][j]=0;\n    for(int i=1;i<=H;++i) for(int j=1;j<=W;++j) sum3[i][j]=0;\n    for(int i=1;i<=W;++i) for(int j=1;j<=W;++j) sum4[i][j]=0;\n    for(int i=1;i<=H;++i) for(int j=1;j<=W;++j)\n    {\n        if(Left[i][j]<=Right[i][j])\n        {\n            sum1[i]+=L[i][j];\n            if(Right[i][j]!=W) sum2[i][Right[i][j]+1]+=L[i][j];\n            if(Left[i][j]!=1) sum3[i][Left[i][j]-1]+=L[i][j];\n            if(Right[i][j]!=W&&Left[i][j]!=1) sum4[Left[i][j]-1][Right[i][j]+1]+=L[i][j];\n        }\n    }\n    for(int i=1;i<=H;++i)\n    {\n        sum1[i]+=sum1[i-1];\n        for(int j=1;j<=W;++j) sum2[i][j]+=sum2[i][j-1];\n        for(int j=W-1;j>=1;--j) sum3[i][j]+=sum3[i][j+1];\n        for(int j=1;j<=W;++j)\n        {\n            sum2[i][j]+=sum2[i-1][j];\n            sum3[i][j]+=sum3[i-1][j];\n        }\n    }\n    for(int len=2;len<=W;++len) for(int l=1,r=len;r<=W;++l,++r)\n    {\n        sum4[l][r]+=sum4[l+1][r]+sum4[l][r-1]-sum4[l+1][r-1];\n    }\n}\ninline int BothReachable(int a,int b,int r)\n{\n    Cmin(r,min(Bottom[a],Bottom[b]));\n    if(MeetingPoint[a][b]>r) return 0;\n    return sum1[r]-sum2[r][b]-sum3[r][a]+sum4[a][b];\n}\nvoid divide(int Hl,int Hr,int Wl,int Wr,int k)\n{\n    if(Hr-Hl+1<Wr-Wl+1) swap(Hl,Wl),swap(Hr,Wr),k^=1;\n    if(Hl==Hr) return;\n    int H=Hr-Hl+1,W=Wr-Wl+1;\n    int HU=H>>1,HL=H-HU;\n    for(int i=1;i<=HU;++i) for(int j=1;j<=W;++j) U[i][j]=a[k][Hl+i-1][Wl+j-1];\n    for(int i=1;i<=HL;++i) for(int j=1;j<=W;++j) L[i][j]=a[k][Hl+HU+i-1][Wl+j-1];\n    for(int i=1;i<=W;++i)\n    {\n        Left[1][i]=inf,Right[1][i]=-inf;\n        if(L[1][i]) \n        {\n            Left[1][i]=Right[1][i]=i;\n            if(i!=1) Cmin(Left[1][i],Left[1][i-1]);\n        }\n    }\n    for(int i=2;i<=HL;++i) for(int j=1;j<=W;++j)\n    {\n        Left[i][j]=inf,Right[i][j]=-inf;\n        if(L[i][j])\n        {\n            Cmin(Left[i][j],Left[i-1][j]),Cmax(Right[i][j],Right[i-1][j]);\n            if(j!=1) Cmin(Left[i][j],Left[i][j-1]),Cmax(Right[i][j],Right[i][j-1]);\n        }\n    }\n    for(int i=W;i>=1;--i)\n    {\n        Min[HU][i]=inf,Max[HU][i]=-inf;\n        if(U[HU][i])\n        {\n            Min[HU][i]=Max[HU][i]=i;\n            if(i!=W) Cmax(Max[HU][i],Max[HU][i+1]);\n        }\n    }\n    for(int i=HU-1;i>=1;--i) for(int j=W;j>=1;--j)\n    {\n        Min[i][j]=inf,Max[i][j]=-inf;\n        if(U[i][j])\n        {\n            Cmin(Min[i][j],Min[i+1][j]);\n            Cmax(Max[i][j],Max[i+1][j]);\n            if(j!=W)\n            {\n                Cmin(Min[i][j],Min[i][j+1]);\n                Cmax(Max[i][j],Max[i][j+1]);\n            }\n        }\n    }\n    calc_Top(HU,W);\n    calc_Bottom(HL,W);\n    init_MeetingPoint(HL,W);\n    init_BothReachable(HL,W);\n    int cnt=0,sum=0;\n    for(int y=1;y<=HU;++y)\n    {\n        static int J[maxn]; int hd=1,tl=0;\n        int l=1,r=0;\n        int now=0;\n        for(int x=1;x<=W;++x) if(Min[y][x]<=Max[y][x])\n        {\n            while(r<Max[y][x]) \n            {\n                ++r; if(Bottom[r]==-inf||Top[r]>y) continue;\n                has[r]=Reachable(r);\n                now+=has[r];\n                if(hd<=tl) \n                {\n                    int d=BothReachable(J[tl],r,min(Bottom[J[tl]],Bottom[r]));\n                    now-=d;\n                    has[J[tl]]-=d;\n                }\n                while(hd<=tl&&Bottom[J[tl]]<Bottom[r])\n                {\n                    --tl;\n                    if(hd<=tl) \n                    {\n                        int d=BothReachable(J[tl],r,min(Bottom[J[tl]],Bottom[r]))-BothReachable(J[tl],J[tl+1],min(Bottom[J[tl+1]],Bottom[r]));\n                        now-=d;\n                        has[J[tl]]-=d;\n                    }\n                }\n                J[++tl]=r;\n            }\n            while(l<Min[y][x])\n            {\n                if(Bottom[l]!=-inf&&Top[l]<=y)\n                {\n                    now-=has[l];\n                    if(hd<=tl)\n                    {\n                        if(J[hd]==l) ++hd;\n                    }\n                }\n                ++l;\n            }\n            an+=now*U[y][x];\n        }\n    }\n    divide(Hl,Hl+HU-1,Wl,Wr,k);\n    divide(Hl+HU,Hr,Wl,Wr,k);\n}\nint main()\n{\n    // freopen(\"1.in\",\"r\",stdin);\n    read(n);\n    for(int i=1;i<=n;++i) scanf(\"%s\",s[i]+1);\n    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j)\n    {\n        a[0][i][j]=a[1][j][i]=s[i][j]=='#'?0:s[i][j]-'0';\n    }\n    divide(1,n,1,n,0);\n    printf(\"%lld\\n\",an);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S[2020];\nint L[1600][1600],R[1600][1600];\nint dp[1515][1515];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y,x2,y2; string s;\n\t\n\tcin>>N;\n\tFOR(y,N) {\n\t\tcin>>S[y];\n\t\tFORR(c,S[y]) {\n\t\t\tif(c!='#') c-='0';\n\t\t\telse c=0;\n\t\t}\n\t}\n\tll ret=0;\n\tfor(y=N-1;y>=0;y--) {\n\t\tL[y][N]=N;\n\t\tR[y][N]=-1;\n\t\tfor(x=N-1;x>=0;x--) {\n\t\t\tint down=(y<N-1) && (S[y+1][x]>0);\n\t\t\tint right=(x<N-1) && (S[y][x+1]>0);\n\t\t\t\n\t\t\tif(S[y][x]==0) {\n\t\t\t\tfor(y2=y;y2<N;y2++) {\n\t\t\t\t\tL[y][x]=N;\n\t\t\t\t\tR[y][x]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[y][x]=dp[y+1][x]+dp[y][x+1];\n\t\t\t\tL[y][x]=x;\n\t\t\t\tif(down&&right) {\n\t\t\t\t\tR[y][x]=R[y][x+1];\n\t\t\t\t\t\n\t\t\t\t\tint r=0;\n\t\t\t\t\tfor(y2=y+1;y2<N;y2++) {\n\t\t\t\t\t\tif(L[y2][x+1]<=R[y2][x] && r<L[y2][x+1]) {\n\t\t\t\t\t\t\tdp[y][x]-=dp[y2][L[y2][x+1]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr=R[y2][x];\n\t\t\t\t\t\tR[y2][x]=max(R[y2][x],R[y2][x+1]);\n\t\t\t\t\t\tL[y2][x]=min(L[y2][x],L[y2][x+1]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(down) {\n\t\t\t\t\tR[y][x]=x;\n\t\t\t\t}\n\t\t\t\telse if(right) {\n\t\t\t\t\tR[y][x]=R[y][x+1];\n\t\t\t\t\tfor(y2=y+1;y2<N;y2++) {\n\t\t\t\t\t\tL[y2][x]=L[y2][x+1];\n\t\t\t\t\t\tR[y2][x]=R[y2][x+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tR[y][x]=x;\n\t\t\t\t\tfor(y2=y+1;y2<N;y2++) {\n\t\t\t\t\t\tL[y2][x]=N;\n\t\t\t\t\t\tR[y2][x]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret+=S[y][x]*dp[y][x];\n\t\t\t\tdp[y][x]+=S[y][x];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nconst int N=505;\nint a[N][N],f[N][N],l[N][N],r[N][N];\nchar s[N];\n/* \nf[i][j] (i,j) 能走到的位置的权值和\nl[i][j][k]/r[i][j][k] 表示 (i,j) 可以到达的第 k 行最左/右的位置 ，第一维省略\n不能走到的点贡献相当于已经清零，因为 (i+1,j) (i,j+1) 共同能走到的点的递增序列里面不会出现这些位置，\n且没有被计算到其左上的点的贡献中去 \n*/\nint main(){\n//\tfreopen(\"cell.in\",\"r\",stdin);\n//\tfreopen(\"cell.out\",\"w\",stdout);\n\tri n,i,j,k,now,ans;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%s\",s+1);\n\t\tfor(j=1;j<=n;++j)\n\t\t\ta[i][j]=s[j]=='#'?0:s[j]-'0';\n\t}\n\tans=0;\n\tfor(i=n;i;--i)\n\t\tfor(j=n;j;--j){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tmemset(l[j]+i,127,sizeof(int)*(n-i+1));\n\t\t\t\tmemset(r[j]+i,128,sizeof(int)*(n-i+1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(a[i+1][j]==0&&a[i][j+1]==0)\n\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\telse if(a[i+1][j]==0)\n\t\t\t\tmemcpy(l[j]+i,l[j+1]+i,sizeof(int)*(n-i+1)),\n\t\t\t\tmemcpy(r[j]+i,r[j+1]+i,sizeof(int)*(n-i+1)),\n\t\t\t\tl[j][i]=j,\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\telse if(a[i][j+1]==0)\n\t\t\t\tl[j][i]=r[j][i]=j,\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\telse{\n\t\t\t\tf[i][j]=f[i][j+1]+f[i+1][j];\n\t\t\t\tl[j][i]=j;r[j][i]=r[j+1][i];\n\t\t\t\tnow=0;\n\t\t\t\tfor(k=i+1;k<=n;++k){\n\t\t\t\t\tif(r[j][k]>=l[j+1][k]&&l[j+1][k]>now)\n\t\t\t\t\t//\tprintf(\"sub %d %d %d %d\\n\",i,j,k,l[j+1][k]),\n\t\t\t\t\t\tf[i][j]-=f[k][l[j+1][k]];\n\t\t\t\t\tnow=max(now,r[j][k]);\n\t\t\t\t\tl[j][k]=min(l[j][k],l[j+1][k]);\n\t\t\t\t\tr[j][k]=max(r[j][k],r[j+1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=a[i][j]*f[i][j];\n\t\t//\tprintf(\"f %d %d %d\\n\",i,j,f[i][j]);\n\t\t\tf[i][j]+=a[i][j];\n\t\t//\tprintf(\"check (%d,%d)\\n\",i,j);\n\t\t//\tfor(k=i;k<=n;++k)\n\t\t//\t\tprintf(\"%d %d %d\\n\",k,l[j][k],r[j][k]);\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\ntypedef long long ll;\nint n;\nint a[1505][1505];\nchar ss[1505];\nint L[1505][1505],R[1505][1505];\nll f[1505][1505];\nll ans;\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tscanf(\"%s\",&ss[1]);\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\ta[i][j] = (ss[j]=='#'?0:ss[j]-'0');\n\t\t}\n\t}\n\tfor(int i=n;i>=1;i--) {\n\t\tfor(int j=n;j>=1;j--) {\n\t\t\tif(a[i][j]) {\n\t\t\t\tbool mk1 = a[i+1][j] , mk2 = a[i][j+1];\n\t\t\t\tif( (!mk1) && (!mk2) ) {\n\t\t\t\t\tL[i][j] = R[i][j] = j;\n\t\t\t\t\tf[i][j] = 0;\n\t\t\t\t\tfor(int k=i+1;k<=n;k++) L[k][j] = n+1,R[k][j] = 0;\n\t\t\t\t} else if(!mk1) {\n\t\t\t\t\tf[i][j] = f[i][j+1];\n\t\t\t\t\tL[i][j] = j; R[i][j] = R[i][j+1];\n\t\t\t\t\tfor(int k=i+1;k<=n;k++) L[k][j] = L[k][j+1] , R[k][j] = R[k][j+1];\n\t\t\t\t} else if(!mk2) {\n\t\t\t\t\tf[i][j] = f[i+1][j];\n\t\t\t\t\tL[i][j] = R[i][j] = j;\n\t\t\t\t} else {\n\t\t\t\t\tint msr = 0;\n\t\t\t\t\tint yoo = f[i][j+1] + f[i+1][j];\n\t\t\t\t\tL[i][j] = j; R[i][j] = R[i][j+1];\n\t\t\t\t\tfor(int k=i+1;k<=n;k++) {\n\t\t\t\t\t\tif( (L[k][j+1]>msr) && (L[k][j+1]<=R[k][j])  ) yoo -= f[k][L[k][j+1]];\n\t\t\t\t\t\tmsr = max(msr,R[k][j]);\n\t\t\t\t\t\tL[k][j] = min(L[k][j],L[k][j+1]);\n\t\t\t\t\t\tR[k][j] = max(R[k][j],R[k][j+1]);\n\t\t\t\t\t}\n\t\t\t\t\tf[i][j] = yoo;\n\t\t\t\t}\n\t\t\t\tans += f[i][j] * a[i][j];\n\t\t\t\tf[i][j] += a[i][j];\n\t\t\t} else L[i][j] = n+1,R[i][j] = 0;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n\tint f=1,sum=0;\n\tchar x=getchar();\n\tfor(;(x<'0'||x>'9');x=getchar()) if(x=='-') f=-1;\n\tfor(;x>='0'&&x<='9';x=getchar()) sum=sum*10+x-'0';\n\treturn f*sum;\n}\n\n#define M 2005\nint n;\nll sum;\nchar s[M];\nint size,a[M][M];\nbool vis[M][M];\nstruct node {int x,y;}p[M*M];\n\ninline void dfs(int x,int y) {\n\tif(vis[x][y]||a[x][y]==-1) return;\n\tvis[x][y]=1;\n\tp[++size]=(node){x,y};\n\tsum+=a[x][y];\n\tif(x!=n) dfs(x+1,y);\n\tif(y!=n) dfs(x,y+1);\n}\n\ninline void clear() {\n\tsum=0;\n\tfor1(1,size,i) vis[p[i].x][p[i].y]=0;\n\tsize=0;\n}\n\nint main () {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tn=read();\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]=s[j]=='#'?-1:s[j]-'0';\n\t}\n\tll ans=0;\n\tfor1(1,n,i) {\n\t\tFOR2(n,1,j) {\n\t\t\tif(a[i][j]==-1) continue;\n\t\t\tif(a[i][j+1]==-1) clear();\n\t\t\tdfs(i,j);\n\t\t\tans+=a[i][j]*(sum-a[i][j]);\n\t\t}\n\t\tclear();\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//freopen(\"a.in\",\"r\",stdin);\n//freopen(\"zj.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]];\n\t\t\t\t\tlas_r=max(las_r,r[k][j]);\n\t\t\t\t\tl[k][j]=min(l[k][j],l[k][j+1]);\n\t\t\t\t\tr[k][j]=max(r[k][j],r[k][j+1]);\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\telse l[i][j]=n+1,r[i][j]=0;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=1505;\nint n,a[N][N];\nint L[N][N],R[N][N],f[N][N];\nll ans;\nchar s[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFor(j,1,n) a[i][j]=(s[j]=='#'?0:s[j]-'0');\n\t}\n\tRep(i,n,1)\n\t\tif (a[n][i]){\n\t\t\tL[i][n]=i;\n\t\t\tR[i][n]=(a[n][i+1]?R[i+1][n]:i);\n\t\t\tf[n][i]=f[n][i+1]+a[n][i];\n\t\t\tans+=a[n][i]*f[n][i+1];\n\t\t}\n\tRep(i,n-1,1) Rep(j,n,1) if (a[i][j]){\n\t\tif (!a[i+1][j]&&!a[i][j+1]){\n\t\t\tL[j][i]=R[j][i]=j;\n\t\t\tFor(k,i+1,n) L[j][k]=n+1,R[j][k]=0;\n\t\t}\n\t\telse if (!a[i+1][j]){\n\t\t\tmemcpy(L[j],L[j+1],4*(n+1));\n\t\t\tmemcpy(R[j],R[j+1],4*(n+1));\n\t\t\tL[j][i]=j; R[j][i]=R[j+1][i];\n\t\t\tf[i][j]=f[i][j+1];\n\t\t}\n\t\telse if (!a[i][j+1]){\n\t\t\tL[j][i]=R[j][i]=j;\n\t\t\tf[i][j]=f[i+1][j];\n\t\t}\n\t\telse{\n\t\t\tf[i][j]=f[i+1][j]+f[i][j+1];\n\t\t\tL[j][i]=j; R[j][i]=R[j+1][i];\n\t\t\tint las=0;\n\t\t\tFor(k,i+1,n){\n\t\t\t\tif (L[j+1][k]<=R[j][k]&&las<L[j+1][k])\n\t\t\t\t\tf[i][j]-=f[k][L[j+1][k]];\n\t\t\t\tlas=R[j][k];\n\t\t\t\tR[j][k]=max(R[j][k],R[j+1][k]);\n\t\t\t\tL[j][k]=min(L[j][k],L[j+1][k]);\n\t\t\t}\n\t\t}\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[510][510];\nint Up[510][510], Down[510][510];\nint B[510][510], E[510][510], BB[510], EE[510], S[510];\nint T[510][510], v[510];\nint n, w[510][510], L[510], R[510];\nlong long res;\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", p[i] + 1);\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif(p[i][j]>='0' && p[i][j]<='9')w[i][j] = p[i][j] - '0';\n\t\t\telse w[i][j] = -1;\n\t\t}\n\t}\n\tfor (i = 0; i <= n + 1; i++)for (j = 0; j <= n + 1; j++)if (i == 0 || i > n || j == 0 || j > n)w[i][j] = -1;\n\tfor (i = n; i >= 1; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (w[i][j] == -1)continue;\n\t\t\tDown[i][j] = i;\n\t\t\tDown[i][j] = max(Down[i][j], Down[i][j + 1]);\n\t\t\tDown[i][j] = max(Down[i][j], Down[i + 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tUp[i][j] = n + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tUp[i][j] = i;\n\t\t\tif(w[i][j-1] != -1)Up[i][j] = min(Up[i][j], Up[i][j - 1]);\n\t\t\tif(w[i-1][j] != -1)Up[i][j] = min(Up[i][j], Up[i - 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint pv = 0, s = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tpv = j;\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\ts = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT[i][j] = pv + 1;\n\t\t\tres += s*w[i][j];\n\t\t\ts += w[i][j];\n\t\t\tint b = T[i][j], e = j;\n\t\t\tif (i != 1) {\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\tfor (k = b; k <= e; k++) {\n\t\t\t\t\tif (w[i - 1][k] != -1) {\n\t\t\t\t\t\tB[i][j] = min(B[i][j], T[i - 1][k]);\n\t\t\t\t\t\tE[i][j] = max(E[i][j], k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) BB[j] = B[i][j], EE[j] = E[i][j];\n\t\tfor (j = i - 1; j >= 1; j--) {\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tS[k] = S[k - 1];\n\t\t\t\tif (Down[j][k] >= i) {\n\t\t\t\t\tS[k] += w[j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 1) {\n\t\t\t\t\tif (B[j][k] <= E[j][k])v[k] = 1;\n\t\t\t\t\telse v[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tif (BB[k] <= EE[k]) {\n\t\t\t\t\tres += (S[EE[k]] - S[BB[k] - 1])*w[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == 1)break;\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tL[k] = L[k - 1];\n\t\t\t\tif (v[k])L[k] = k;\n\t\t\t}\n\t\t\tR[n + 1] = n + 1;\n\t\t\tfor (k = n; k >= 1; k--) {\n\t\t\t\tR[k] = R[k + 1];\n\t\t\t\tif (v[k])R[k] = k;\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tint b = BB[k], e = EE[k];\n\t\t\t\tif (Up[i][k] >= j)continue;\n\t\t\t\tBB[k] = B[j][R[b]], EE[k] = E[j][L[e]];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nint n,i,j,k,f[1505][1505],l[1505][1505],r[1505][1505];\nlong long ans;\nchar a[1505][1505];\nint main(){\n\tcin>>n;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tfor(i=0;i<=n+1;i++){\n\t\ta[0][i]=a[i][0]=a[n+1][i]=a[i][n+1]='#';\n\t}\n\tfor(i=n;i;i--){\n\t\tfor(j=n;j;j--){\n\t\t\tif(a[i][j]!='#'){\n\t\t\t\tif(a[i+1][j]=='#'&&a[i][j+1]=='#'){\n\t\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\t\tfor(k=i+1;k<=n;k++){\n\t\t\t\t\t\tl[k][j]=n+1;\n\t\t\t\t\t\tr[k][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j]!='#'&&a[i][j+1]=='#'){\n\t\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j]=='#'&&a[i][j+1]!='#'){\n\t\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\t\tl[i][j]=j;\n\t\t\t\t\tr[i][j]=r[i][j+1];\n\t\t\t\t\tfor(k=i+1;k<=n;k++){\n\t\t\t\t\t\tl[k][j]=l[k][j+1];\n\t\t\t\t\t\tr[k][j]=r[k][j+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j]!='#'&&a[i][j+1]!='#'){\n\t\t\t\t\tl[i][j]=j;r[i][j]=r[i][j+1];\n\t\t\t\t\tf[i][j]=f[i+1][j]+f[i][j+1];\n\t\t\t\t\tint lst=0;\n\t\t\t\t\tfor(k=i+1;k<=n;k++){\n\t\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>lst){\n\t\t\t\t\t\t\tf[i][j]-=f[k][l[k][j+1]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlst=max(lst,r[k][j]);\n\t\t\t\t\t\tl[k][j]=min(l[k][j],l[k][j+1]);\n\t\t\t\t\t\tr[k][j]=max(r[k][j],r[k][j+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans+=f[i][j]*(a[i][j]&15);\n\t\t\t\tf[i][j]+=(a[i][j]&15);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl[i][j]=n+1;\n\t\t\t\tr[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S[2020];\nshort LT[1600][1600],LD[1600][1600];\nshort RT[1600],RD[1600];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y,x2,y2; string s;\n\t\n\tcin>>N;\n\tFOR(y,N) {\n\t\tcin>>S[y];\n\t\t//S[y]=string(N,'1');\n\t\tFORR(c,S[y]) {\n\t\t\tif(c!='#') c-='0';\n\t\t\telse c=0;\n\t\t}\n\t}\n\tll ret=0;\n\tFOR(x,N) {\n\t\tFOR(x2,x+1) {\n\t\t\tFOR(y,N) {\n\t\t\t\tif(S[y][x]) {\n\t\t\t\t\tif(x==x2) {\n\t\t\t\t\t\tLT[x][y]=LD[x][y]=y;\n\t\t\t\t\t}\n\t\t\t\t\tif(y) {\n\t\t\t\t\t\tLT[x2][y]=min(LT[x2][y],LT[x2][y-1]);\n\t\t\t\t\t\tLD[x2][y]=max(LD[x2][y],LD[x2][y-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLT[x2][y]=N;\n\t\t\t\t\tLD[x2][y]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(x2=x;x2>=0;x2--) {\n\t\t\tfor(y=N-1;y>=0;y--) {\n\t\t\t\tif(S[y][x2]==0) {\n\t\t\t\t\tRT[y]=N,RD[y]=-1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(x==x2) {\n\t\t\t\t\t\tRT[y]=RD[y]=y;\n\t\t\t\t\t}\n\t\t\t\t\tif(y<N-1) {\n\t\t\t\t\t\tRT[y]=min(RT[y],RT[y+1]);\n\t\t\t\t\t\tRD[y]=max(RD[y],RD[y+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(y,N) {\n\t\t\t\tFOR(y2,y+1) {\n\t\t\t\t\tif(RT[y2]<=y && RD[y2]>=y && LT[x2][y]<=y2 && LD[x2][y]>=y2) ret+=S[y2][x2]*S[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tFOR(y,N) FOR(x,N) ret-=S[y][x]*S[y][x];\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar a[510][510];\nint n,sum,suml[510];\nbool vis[510][510];\nlong long ans;\nvoid bfs(int x,int y)\n{\n\tstatic queue<pair<int,int> >q;\n\tq.push(make_pair(x,y));vis[x][y]=1;sum+=a[x][y]-'0';suml[y]+=a[x][y]-'0';\n\twhile(!q.empty())\n\t{\n\t\tx=q.front().first,y=q.front().second;q.pop();\n\t\tif(x<n&&!vis[x+1][y]&&a[x+1][y]!='#')q.push(make_pair(x+1,y)),vis[x+1][y]=1,sum+=a[x+1][y]-'0';\n\t\tif(y<n&&!vis[x][y+1]&&a[x][y+1]!='#')q.push(make_pair(x,y+1)),vis[x][y+1]=1,sum+=a[x][y+1]-'0';\n\t}\n}\nvoid bfs1(int x,int y)\n{\n\tstatic queue<pair<int,int> >q;\n\tq.push(make_pair(x,y));\n\twhile(!q.empty())\n\t{\n\t\tx=q.front().first,y=q.front().second;q.pop();\n\t\tif(vis[x+1][y]&&!vis[x+1][y-1])q.push(make_pair(x+1,y)),vis[x+1][y]=0,sum-=a[x+1][y]-'0';\n\t\tif(vis[x][y+1]&&!vis[x-1][y+1])q.push(make_pair(x,y+1)),vis[x][y+1]=0,sum-=a[x][y+1]-'0';\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%s\",a[i]+1);\n\tfor(int c=1;c<=n;++c)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(suml,0,sizeof(suml));\n\t\tsum=0;\n\t\tfor(int i=n;i;--i)\n\t\t{\n\t\t\tfor(int j=c;j<=n;++j)if(a[i][j]=='#')bfs1(i,j);\n\t\t\tif(a[i][c]!='#')\n\t\t\t{\n\t\t\t\tbfs(i,c);\n\t\t\t\tans+=(a[i][c]-'0')*(sum-a[i][c]+'0');\n\t\t\t//\tprintf(\"%d %d %d\\n\",i,c,sum);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nbool CanReach(const std::vector<std::vector<char>>& board, int x1, int y1, int x2, int y2) {\n\tif (x1 > x2 || y1 > y2)return false;\n\tif (x1 == x2 && y1 == y2)return true;\n\tif (board[y1][x1] == '#')return false;\n\tif (!CanReach(board, x1 + 1, y1, x2, y2))return CanReach(board, x1, y1 + 1, x2, y2);\n\treturn true;\n}\n\nint main() {\n\n\tint N;\n\tstd::cin >> N;\n\tstd::vector<std::vector<char>> board(N, std::vector<char>(N));\n\tfor (auto&v : board) {\n\t\tgetchar();\n\t\tfor (auto&w : v)w = getchar();\n\t}\n\tint sum = 0;\n\tfor (int x = 0; x < N; ++x) {\n\t\tfor (int y = 0; y < N; ++y) {\n\t\t\tif (board[y][x] != '#') {\n\t\t\t\tfor (int x2 = x, y2 = y + 1; x2 < N; ++x2, y2 = 0) {\n\t\t\t\t\tfor (; y2 < N; ++y2) {\n\t\t\t\t\t\tif (board[y2][x2] != '#') {\n\t\t\t\t\t\t\tif (CanReach(board, x, y, x2, y2)) {\n\t\t\t\t\t\t\t\tsum += (board[y][x] - '0')*(board[y2][x2] - '0');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << sum << std::endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1507;\nusing bn=bitset<nax*nax>;\nconst int d=63;\n\nint n;\n\nstruct bity\n{\n\tvll wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n\nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\twhile(r%4)\n\t{\n\t\tr--;\n\t\ta.wek[r]|=b.wek[r];\n\t}\n\tfor (int i=0; i<r; i+=4)\n\t{\n\t\ta.wek[i]|=b.wek[i];\n\t\ta.wek[i+1]|=b.wek[i+1];\n\t\ta.wek[i+2]|=b.wek[i+2];\n\t\ta.wek[i+3]|=b.wek[i+3];\n\t}\n}\n\nchar wcz[nax];\nint tab[nax][nax];\n\nbity oso[nax][10];\n\nll wyn;\n\nint ile[nax];\nint num[nax][nax];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%s\", wcz+1);\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (wcz[j]=='#')\n\t\t\t{\n\t\t\t\ttab[i][j]=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttab[i][j]=wcz[j]-'0';\n\t\t\t\tile[tab[i][j]]++;\n\t\t\t\tnum[i][j]=ile[tab[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=9; j++)\n\t\t\toso[i][j]=bity(ile[j]);\n\tfor (int i=n; i; i--)\n\t{\n\t\tfor (int j=n; j; j--)\n\t\t{\n\t\t\tif (tab[i][j]==-1)\n\t\t\t{\n\t\t\t\tfor (int l=1; l<=9; l++)\n\t\t\t\t\toso[j][l].zeruj();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int l=1; l<10; l++)\n\t\t\t\toruj(oso[j][l], oso[j+1][l]);\n\t\t\t//~ oso[j]|=oso[j+1];\n\t\t\tfor (int l=1; l<10; l++)\n\t\t\t{\n\t\t\t\t//~ if (oso[j][l].licz())\n\t\t\t\t\t//~ debug() << i << \" \" << j << \" to \" << l << \" \" << oso[j][l].licz();\n\t\t\t\twyn+=l*tab[i][j]*oso[j][l].licz();\n\t\t\t}\n\t\t\t//~ oso[j][num(i, j)]=1;\n\t\t\toso[j][tab[i][j]].ustaw(num[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nvector<int> C[N],D[N];\nint val[N][N],b[N][N],S[N],n,u[N][N],l[N],r[N];\nchar A[N][N];\nbool flag[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9',b[i][j]=A[i][j]-'0';\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=n;j;--j)\n\t\t\tif (flag[i][j])C[i].push_back(j);\n\t\t\telse D[i].push_back(j);\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=x?b[x][j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x][j]){\n\t\t\t\tl[j]=j-1;\n\t\t\t\tr[j]=max(r[j+1],j);\n\t\t\t\tval[x][j]+=(S[r[j]]-S[l[j]]-b[x][j]);\n\t\t\t}\n\t\t\telse l[j]=n+1,r[j]=0;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?b[x][j]:0);\n\t\t\tfor (int j:D[i])l[j]=n+1,r[j]=0;\n\t\t\tfor (int j:C[i]){\n\t\t\t\tval[i][j]+=S[r[j]=max(r[j+1],r[j])];\n\t\t\t\tval[i][j]-=S[l[j]=min(l[j+1],l[j])];\n\t\t\t}\n\t\t}\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)ans+=val[i][j]*b[i][j];\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include <stack>\nusing namespace std;\nint lcm(int n, int m) {\n\tint a, b, tmp, r;\n\ta = n, b = m;\n\tif (a < b) {\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\tr = a % b;\n\twhile (r != 0) {\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}\nint min(int n, int m) {\n\tif (m < n) return m;\n\telse return n;\n}\n\n\n\nint main() {\n\n\tstruct point {\n\t\tint x, y;\n\t};\n\tint dx[2] = { -1,0 };\n\tint dy[2] = { 0,-1 };\n\tint n, i, j,z;\n\tcin >> n;\n\tchar a[500][500];\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tlong long tans=0;\n\tqueue<point> q;\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tfor(j = n-1; j >=0; j-- ){\n\t\t\tpoint k;\n\t\t\tk.x = i; k.y = j;\n\t\t\tif (a[k.x][k.y] != '#'&&(k.x)*(k.x)+(k.y)*(k.y)!=0) {\n\t\t\t\tpoint h;\n\t\t\t\tfor (z = 0; z <= 1; z++){\n\t\t\t\t\th.x = k.x + dx[i]; if (h.x < 0) break;\n\t\t\t\t\th.y = k.y + dy[i]; if (h.y < 0) break;\n\t\t\t\t\n\t\t\t\t\tif (a[h.x][h.y] != '#' && (h.x)*(h.x) + (h.y)*(h.y) != 0) {\n\t\t\t\t\t\tlong long ans=0;\n\t\t\t\t\t\tlong long sem;\n\t\t\t\t\t\tpoint w;\n\t\t\t\t\t\tw = h;\n\t\t\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\t\t\th = q.front();\n\t\t\t\t\t\t\tpoint l;\n\t\t\t\t\t\t\tans =ans+ a[h.x][h.y];\n\t\t\t\t\t\t\tfor (z = 0; z <= 1; z++) {\n\t\t\t\t\t\t\t\tl.x = h.x + dx[i]; if (l.x < 0) break;\n\t\t\t\t\t\t\t\tl.y = h.y + dy[i]; if (l.y < 0) break;\n\n\t\t\t\t\t\t\t\tif (a[l.x][l.y] != '#') {\n\t\t\t\t\t\t\t\t\tq.push(l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\t\th = q.front();\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsem = ans * a[w.x][w.y];\n\t\t\t\t\t\ttans = tans + sem;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << tans;\n\n\n\n\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"cell\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll N=1505;\nchar s[N][N];\nll n,su[N][N],minn[2][N][N],maxn[2][N][N],mxto[N][N],ans;\nsigned main(){\n\tn=read();\n\tfor(ll i=1;i<=n;i++)scanf(\"%s\",s[i]+1);\n\tfor(ll i=n,now=1,pre=0;i>=1;i--,swap(now,pre)){\n\t\tfor(ll j=n;j>=1;j--)if(s[i][j]!='#'){\n\t\t\tsu[i][j]=su[i][j+1]+su[i+1][j]+s[i][j]-'0';\n\t\t\tmxto[i][j]=max(max(mxto[i][j+1],mxto[i+1][j]),i);\n\t\t\tminn[now][j][i]=maxn[now][j][i]=j;\n\t\t\tfor(ll k=i+1;k<=mxto[i+1][j];k++)minn[now][j][k]=minn[pre][j][k];\n\t\t\tfor(ll k=max(mxto[i+1][j],i)+1;k<=mxto[i][j+1];k++)minn[now][j][k]=minn[now][j+1][k];\n\t\t\tfor(ll k=i;k<=mxto[i][j+1];k++)maxn[now][j][k]=maxn[now][j+1][k];\n\t\t\tfor(ll k=max(mxto[i][j+1],i)+1;k<=mxto[i+1][j];k++)maxn[now][j][k]=maxn[pre][j][k];\n\t\t\tll pos=i+1,lim=min(mxto[i][j+1],mxto[i+1][j]);\n\t\t\twhile(pos<=lim){\n\t\t\t\tif(maxn[pre][j][pos]>=minn[now][j+1][pos]){\n\t\t\t\t\tsu[i][j]-=su[pos][minn[now][j+1][pos]];\n\t\t\t\t\tpos=mxto[pos][minn[now][j+1][pos]];\n\t\t\t\t}pos++;\n\t\t\t}ans+=(s[i][j]-'0')*(su[i][j]-(s[i][j]-'0'));\n\t\t}\n\t}return cout<<ans,signed();\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint b[N][N],S[N],n,u[N][N],l[N],r[N],flag[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9',b[i][j]=A[i][j]-'0';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=x?b[x][j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x][j]){\n\t\t\t\tl[j]=j-1;\n\t\t\t\tr[j]=max(r[j+1],j);\n\t\t\t\tans+=b[x][j]*(S[r[j]]-S[l[j]]-b[x][j]);\n\t\t\t}\n\t\t\telse l[j]=1e9,r[j]=-1;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?b[x][j]:0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tl[j]=min(l[j+1],l[j]);\n\t\t\t\t\tr[j]=max(r[j+1],r[j]);\n\t\t\t\t\tif (l[j]<=r[j])ans+=b[i][j]*(S[r[j]]-S[l[j]]);\n\t\t\t\t}\n\t\t\t\telse l[j]=1e9,r[j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint vy[4] = { 1, 0, -1, 0 };\nint vx[4] = { 0, 1, 0, -1 };\n\nvector<string> board;\n\nint N;\n\nbool inside(int y, int x)\n{\n\treturn y >= 0 && x >= 0 && y < N && x < N;\n}\n\n\n\nint main() {\n\tcin >> N;\n\n\tvector<string> board(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> board[i];\n\t}\n\t\n\tvector<vector<int>> numBoard(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint activeBlock = 0;\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\n\t\t\t//if (rand() % 5 == 0) numBoard[i][j] == -1;\n\t\t\t//else numBoard[i][j] = 1;\n\t\t\tif (board[i][j] == '#') numBoard[i][j] = -1;\n\t\t\telse {\n\t\t\t\tnumBoard[i][j] = (int)(board[i][j] - '0');\n\t\t\t\tactiveBlock++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int>> maxLen(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (numBoard[sy][sx] == -1) continue;\n\t\t\tmaxLen[sy][sx] = 1;\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = sy + vy[k];\n\t\t\t\tint nx = sx + vx[k];\n\t\t\t\tif (inside(ny, nx) && maxLen[ny][nx] >= 1) {\n\t\t\t\t\tmaxLen[sy][sx] = max(maxLen[sy][sx], maxLen[ny][nx] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<int> q;\n\tvector<vector<int>> startUsed(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\n\tvector<vector<int>> used(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint myTurn = 1;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1 && maxLen[sy][sx] > 0)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 2; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t\tmyTurn++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcerr << \"reset \" << ((int)q.size() - activeBlock) << endl;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcerr << \"reset \"  << ((int)q.size() - activeBlock) << endl;\n\n\n\n\tlong ans = 0;\n\tlong nowSum = 0;\n\n\tmyTurn++;\n\tlong add = 0;\n\n\twhile (!q.empty())\n\t{\n\t\tint start = q.front(); q.pop();\n\n\t\tif (start == -1)\n\t\t{\n\t\t\tmyTurn++;\n\t\t\tnowSum = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<int> q2;\n\t\tint sy = start >> 12;\n\t\tint sx = start & 0xFFF;\n\t\tused[sy][sx] = myTurn;\n\t\tq2.push(start);\n\n\n\t\twhile (!q2.empty())\n\t\t{\n\t\t\tint now = q2.front(); q2.pop();\n\t\t\tint y = now >> 12;\n\t\t\tint x = now & 0xFFF;\n\t\t\tnowSum += numBoard[y][x];\n\t\t\tadd++;\n\n\t\t\tint ny = y + 1;\n\t\t\tint nx = x + 1;\n\n\t\t\tif (ny < N && numBoard[ny][x] != -1 && used[ny][x] != myTurn)\n\t\t\t{\n\t\t\t\tused[ny][x] = myTurn;\n\t\t\t\tq2.push((ny << 12) + x);\n\t\t\t}\n\n\t\t\tif (nx < N && numBoard[y][nx] != -1 && used[y][nx] != myTurn)\n\t\t\t{\n\t\t\t\tused[y][nx] = myTurn;\n\t\t\t\tq2.push((y << 12) + nx);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t{\n\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\n\t\tans += numBoard[sy][sx] * nowSum;\n\t}\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (numBoard[i][j] != -1) ans -= numBoard[i][j] * numBoard[i][j];\n\t\t}\n\t}\n\n\tcerr << add << endl;\n\n\tcout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n\n#define _SILENCE_CXX17_C_HEADER_DEPRECATION_WARNING\n#include <bits/stdc++.h>\n\n#include<unordered_set>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n#define PRINT(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,p) scanf(\"%d %d %d %d\",&n,&m,&o,&p)\n#define SINT5(n,m,o,p,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&p,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 1000000009;\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\t\n#define sc  second\n\n\n\nll  a[2048][2048] = {};\nbool p[2048][2048];\n\nint main(){\n\tint n;\n\tcin >> n;\n\tFILL0(a);\n\trep(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j, n) {\n\t\t\tif (s[j] == '#') a[i][j] = INF;\n\t\t\telse             a[i][j] = s[j] - '0';\n\t\t}\n\t}\n\tll ret = 0;\n\n\n\trep(y, n){\n\t\trep(x, n) {\n\t\t\tll r = 0; //-a[y][x];\n\t\t\tif (a[y][x] != INF) {\n\t\t\t\tFILL0(p);\n\n\t\t\t\tp[y][x] = true;\n\t\t\t\trepft(i, y, n) repft(j, x, n) {\n\t\t\t\t\tif (a[i][j] == INF) continue;\n\t\t\t\t\tif (p[i][j]) continue;\n\t\t\t\t\tif (p[i - 1][j] || p[i][j - 1]) {\n\t\t\t\t\t\tp[i][j] = true;\n\t\t\t\t\t\tr += a[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret += a[y][x] * r;\n\t\t\t//printf(\"%2lld \", r);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\tcout << ret << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include <bits/stdc++,h>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int LL\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 600;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nLL ans = 0;\nLL sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE];\nLL dfs(int y,int x) {\n\tif (y > N or x > N) return 0;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x]) {\n\t\treturn 0;\n\t}\n\treached[y][x]=true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs2(int y, int x) {\n\tif (y > N or x > N) return 0;\n//\tcout << y << \" \" << x << endl;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x] == 0) return 0;\n\tif (reached[y - 1][x]) return 0;\n\t//cout << y << \" \" << x << endl;\n\treached[y][x] = 0;\n\tLL ret = 0;\n\tret += dfs2(y, x + 1);\n\tret += dfs2(y + 1, x);\n\n\treturn ret + A[y][x];\n}\nLL solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i,1, N) {\n\t\tsum+=dfs(x, i);\n\t\tans +=( sum - A[x][i] )* A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tsum-=dfs2(x+1, i)+A[x][i];\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N;\n\tEFOR(i,1,N){\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1]-'0';\n\t\t}\n\t}\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n//\tcin >> N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[2][N],r[2][N],flag[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;i++)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=n;j++)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9';\n\tfor (register int i=0;i<=n;i++)\n\t\tfor (register int j=0;j<=n;j++)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;x++){\n\t\tfor (register int i=x;i;i--){\n\t\t\tint t=i&1;\n\t\t\tfor (register int j=1;j<=n;j++)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (register int j=n+1;j;j--){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tif (i<x){\n\t\t\t\t\t\tl[t][j]=min(l[t][j+1],l[t^1][j]);\n\t\t\t\t\t\tr[t][j]=max(r[t][j+1],r[t^1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse l[t][j]=j,r[t][j]=max(j,r[t][j+1]);\n\t\t\t\t\tif (l[t][j]<=r[t][j])ans+=(A[i][j]-'0')*(S[r[t][j]]-S[l[t][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t\t}\n\t\t\t\telse l[t][j]=1e9,r[t][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]>r[k][j+1]) break;\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]];\n\t\t\t\t\tlas_r=max(las_r,r[k][j+1]);\n\t\t\t\t\tif(l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\telse l[i][j]=n+1,r[i][j]=0;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,n,m,mid,a[1510][1510],A[1510][1510],mi[1510][1510],ma[1510][1510],mp[1510][1510],bot[1510][1510],tp[1510][1510],l[1510][1510],r[1510][1510],ql,qr,sta[1510],stp,sbt;\nlong long ans,s0[1510],s1[1510][1510],s2[1510][1510],s3[1510][1510],nw,val[1510];\nchar s[1510];\n\nlong long ask(int a,int b,int l)\n{\n\tl=min(l,min(bot[mid+1][a],bot[mid+1][b]));\n\tif (l<mp[a][b]) return 0;\n\treturn s0[l]-s1[l][a+1]-s2[l][b-1]+s3[a+1][b-1];\n}\n\nvoid ins(int x)\n{\n\tif (stp>=sbt) \n\t{\n\t\tnw-=val[sta[stp]];\n\t\tval[sta[stp]]-=ask(sta[stp],x,min(bot[mid+1][sta[stp]],bot[mid+1][x]));\n\t\tnw+=val[sta[stp]];\n\t}\n\twhile (stp>=sbt&&bot[mid+1][sta[stp]]<=bot[mid+1][x])\n\t{\n\t\tif (stp>sbt) \n\t\t{\n\t\t\tnw-=val[sta[stp-1]];\n\t\t\tval[sta[stp-1]]-=ask(sta[stp-1],x,min(bot[mid+1][sta[stp-1]],bot[mid+1][x]));\n\t\t\tval[sta[stp-1]]+=ask(sta[stp-1],x,bot[mid+1][sta[stp]]);\n\t\t\tnw+=val[sta[stp-1]];\n\t\t}\n\t\tstp--;\n\t}\n\tsta[++stp]=x,nw+=(val[x]=ask(x,x,n));\n}\n\nvoid solve(int xl,int yl,int xr,int yr)\n{\n\tif (xr-xl+1>=yr-yl+1)\n\t{\n\t\tn=xr-xl+1,m=yr-yl+1;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=m; j++) a[i][j]=A[i+xl-1][j+yl-1];\n\t} else\n\t{\n\t\tn=yr-yl+1,m=xr-xl+1;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tfor (int j=1; j<=m; j++) a[i][j]=A[j+xl-1][i+yl-1];\n\t}\n\tif (n==1&&m==1) return;\n\tfor (int i=1; i<=n; i++) tp[i][0]=n+1;\n\tfor (int j=1; j<=m; j++) tp[0][j]=n+1;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++) tp[i][j]=(a[i][j]?min(i,min(tp[i-1][j],tp[i][j-1])):n+1);\n\tfor (int i=1; i<=n; i++) bot[i][m+1]=0;\n\tfor (int j=1; j<=m; j++) bot[n+1][j]=0;\n\tfor (int i=n; i; i--)\n\t\tfor (int j=m; j; j--) bot[i][j]=(a[i][j]?max(i,max(bot[i+1][j],bot[i][j+1])):0);\n\tmid=(n+1>>1);\n\tfor (int i=mid+1; i<=n; i++) a[i][0]=a[i][m+1]=0,l[i][0]=m+1,r[i][0]=0;\n\tfor (int i=1; i<=m; i++)\n\t\tif (!a[mid+1][i]) l[mid+1][i]=m+1; else l[mid+1][i]=(a[mid+1][i-1]?l[mid+1][i-1]:i);\n\tfor (int i=1; i<=m; i++)\n\t\tif (!a[mid+1][i]) r[mid+1][i]=0; else r[mid+1][i]=i;\n\tfor (int i=mid+2; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++) \n\t\t\tif (a[i][j]) l[i][j]=min(l[i-1][j],l[i][j-1]),r[i][j]=max(r[i-1][j],r[i][j-1]);\n\t\t\telse l[i][j]=m+1,r[i][j]=0;\n\tfor (int i=0; i<=m+1; i++)\n\t\tfor (int j=0; j<=m+1; j++) mp[i][j]=n+1;\n\tfor (int i=mid+1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++) \n\t\t\tif (l[i][j]<=r[i][j]) mp[l[i][j]][r[i][j]]=min(mp[l[i][j]][r[i][j]],i);\n\tfor (int i=1; i<=m; i++)\n\t\tfor (int j=m; j; j--) mp[i][j]=min(mp[i][j],min(mp[i-1][j],mp[i][j+1]));\n\tfor (int i=0; i<=n+1; i++)\n\t{\n\t\ts0[i]=0;\n\t\tfor (int j=0; j<=m+1; j++) s1[i][j]=s2[i][j]=s3[i][j]=0;\n\t}\n\tfor (int i=mid+1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++) if (l[i][j]!=m+1)\n\t\t\ts0[i]+=a[i][j],s1[i][l[i][j]]+=a[i][j],s2[i][r[i][j]]+=a[i][j],s3[l[i][j]][r[i][j]]+=a[i][j];\n\tfor (int i=mid+2; i<=n; i++) s0[i]+=s0[i-1];\n\tfor (int i=mid+1; i<=n; i++)\n\t\tfor (int j=m; j; j--) s1[i][j]+=s1[i-1][j]+s1[i][j+1]-s1[i-1][j+1];\n\tfor (int i=mid+1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++) s2[i][j]+=s2[i-1][j]+s2[i][j-1]-s2[i-1][j-1];\n\tfor (int i=m; i; i--)\n\t\tfor (int j=1; j<=m; j++) s3[i][j]+=s3[i+1][j]+s3[i][j-1]-s3[i+1][j-1];\n\tfor (int i=m; i; i--) \n\t\tif (a[mid+1][i]) mi[mid+1][i]=i,ma[mid+1][i]=(a[mid+1][i+1]?ma[mid+1][i+1]:i);\n\t\telse mi[mid+1][i]=m+1,ma[mid+1][i]=0;\n\tfor (int i=1; i<=mid; i++) mi[i][m+1]=m+1,ma[i][m+1]=0;\n\tfor (int i=mid; i; i--)\n\t\tfor (int j=m; j; j--) \n\t\t\tif (a[i][j]) mi[i][j]=min(mi[i+1][j],mi[i][j+1]),ma[i][j]=max(ma[i+1][j],ma[i][j+1]);\n\t\t\telse mi[i][j]=m+1,ma[i][j]=0;\n\tfor (int i=1; i<=mid; i++)\n\t{\n\t\tql=1,qr=0,stp=0,nw=0,sbt=1;\n\t\tfor (int j=1; j<=m; j++) val[j]=0;\n\t\tfor (int j=1; j<=m; j++) if (mi[i][j]!=m+1)\n\t\t{\n\t\t\twhile (qr+1<=ma[i][j]) \n\t\t\t{\n\t\t\t\tqr++;\n\t\t\t\tif (tp[mid+1][qr]<=i) ins(qr);\n\t\t\t}\n\t\t\twhile (ql<mi[i][j]) nw-=val[ql++];\n\t\t\twhile (sbt<=stp&&sta[sbt]<mi[i][j]) sbt++;\n\t\t\tans+=nw*a[i][j];\n\t\t}\n\t}\n\tif (xr-xl+1>=yr-yl+1) solve(xl,yl,xl+xr>>1,yr),solve((xl+xr>>1)+1,yl,xr,yr);\n\telse solve(xl,yl,xr,yl+yr>>1),solve(xl,(yl+yr>>1)+1,xr,yr);\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor (int i=1; i<=N; i++)\n\t{\n\t\tscanf(\"%s\",s+1);\n\t\tfor (int j=1; j<=N; j++) A[i][j]=(s[j]=='#'?0:s[j]-'0');\n\t}\n\tsolve(1,1,N,N);\n\treturn printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\nstruct BoolName : numpunct<char> {\n  string t, f;\n  BoolName (string t = \"Yes\", string f = \"No\") : t(t), f(f) {}\n  string do_truename() const {return t;}\n  string do_falsename() const {return f;}\n};\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15) << boolalpha;\n    cout.imbue(locale(cout.getloc(), new BoolName));\n  }\n} initializer;\n\ntemplate<typename T> istream& operator>>(istream &s, vector<T> &v) {\n  for (T &t : v) s >> t;\n  return s;\n}\n\ntemplate<typename T> ostream& operator<<(ostream &s, const vector<T> &v) {\n  for (const T &t : v) s << t << endl;\n  return s;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<string> a(n);\n  cin >> a;\n  bitset<250000> b1 = 0, b2 = 0, b3 = 0, b4 = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (a[i][j] & 1) b1.set(i * n + j);\n      if (a[i][j] & 2) b2.set(i * n + j);\n      if (a[i][j] & 4) b3.set(i * n + j);\n      if (a[i][j] & 8) b4.set(i * n + j);\n    }\n  }\n  int64_t res = 0;\n  vector<bitset<250000>> v(n), u(n);\n  for (int i = 0; i < n; ++i) {\n    if (a[0][i] == '#') continue;\n    for (int j = i - 1; j >= 0; --j) {\n      if (a[0][j] == '#') break;\n      v[i].set(j);\n    }\n    int c = (b1 & v[i]).count();\n    c += 2 * (b2 & v[i]).count();\n    c += 4 * (b3 & v[i]).count();\n    c += 8 * (b4 & v[i]).count();\n    res += c * (a[0][i] - '0');\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (a[i][j] == '#') continue;\n      if (a[i - 1][j] != '#') {\n        u[j] |= v[j];\n        u[j].set((i - 1) * n + j);\n      }\n      if (j > 0 && a[i][j - 1] != '#') {\n        u[j] |= u[j - 1];\n        u[j].set(i * n + j - 1);\n      }\n      int c = (b1 & u[j]).count();\n      c += 2 * (b2 & u[j]).count();\n      c += 4 * (b3 & u[j]).count();\n      c += 8 * (b4 & u[j]).count();\n      res += c * (a[i][j] - '0');\n    }\n    v = u;\n    for (int j = 0; j < n; ++j) u[j] = 0;\n  }\n  cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication1.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n#include <bits/stdc++.h>\n//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n\n#define YES \"YES\"\n#define NO \"NO\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int LL\n#define zero 0LL\n\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l<r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l>r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 5 * 1e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 501;\nconst int SIZE = SIZE3;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\nstring s;\nut N, M, K, X, L, Y;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\nvoid init() {\n\n}\nLL ans = 0;\nLL sum = 0;\nbool reached[SIZE][SIZE];\nint A[SIZE][SIZE];\nLL dfs(int y,int x) {\n\tif (y > N or x > N) return 0;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x]) {\n\t\treturn 0;\n\t}\n\treached[y][x]=true;\n\treturn dfs(y, x + 1) + dfs(y + 1, x) + A[y][x];\n}\nLL dfs2(int y, int x) {\n\tif (y > N or x > N) return 0;\n//\tcout << y << \" \" << x << endl;\n\tif (A[y][x] == 0) return 0;\n\tif (reached[y][x] == 0) return 0;\n\tif (reached[y - 1][x]) return 0;\n\t//cout << y << \" \" << x << endl;\n\treached[y][x] = 0;\n\tLL ret = 0;\n\tret += dfs2(y, x + 1);\n\tret += dfs2(y + 1, x);\n\n\treturn ret + A[y][x];\n}\nLL solve2(int x) {\n\tREP(i, SIZE) REP(j, SIZE) reached[i][j] = 0;\n\tsum = 0;\n\tEFOR(i,1, N) {\n\t\tsum+=dfs(x, i);\n\t\tans +=( sum - A[x][i] )* A[x][i];\n\t\t//cout << ans << endl;\n\t\treached[x][i] = false;\n\t\tsum-=dfs2(x+1, i)+A[x][i];\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N;\n\tEFOR(i,1,N){\n\t\tcin >> s;\n\t\tEFOR(j, 1, N) {\n\t\t\tif (s[j - 1] == '#')A[i][j] = 0;\n\t\t\telse A[i][j] = s[j - 1]-'0';\n\t\t}\n\t}\n\tEFOR(i, 1, N) solve2(i);\n\treturn ans;\n}\nsigned main() {\n\n\tcout << solve() << endl;\n//\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long ans = 0;\nconst int inf = 114514;\n\ninline void solve(vector<string> a) {\n  int n = (int) a.size(), m = (int) a[0].size();\n  if (n < m) {\n    vector<string> b(m, string(n, ' '));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        b[j][i] = a[i][j];\n      }\n    }\n    a = b;\n    swap(n, m);\n  }\n  if (m == 1) {\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n      if (a[i][0] != '#') {\n        ans += sum * (a[i][0] - '0');\n        sum += a[i][0] - '0';\n      } else {\n        sum = 0;\n      }\n    }\n    return;\n  }\n\n  // Divide & Conquer\n  vector<string> U = vector<string> (a.begin(), a.begin() + (n >> 1));\n  vector<string> D = vector<string> (a.begin() + (n >> 1), a.end());\n  solve(U);\n  solve(D);\n  U.push_back(D[0]);\n  int HU = n >> 1, HD = n - HU;\n\n  // Calculate Left, Right in D\n  vector<vector<int>> lef(HD, vector<int>(m, inf)), rit(HD, vector<int>(m, -inf));\n  for (int j = 0; j < m; j++) if (D[0][j] != '#') {\n    lef[0][j] = rit[0][j] = j;\n  }\n  for (int i = 0; i < HD; i++) {\n    for (int j = 0; j < m; j++) if (D[i][j] != '#') {\n      if (i) lef[i][j] = min(lef[i][j], lef[i - 1][j]);\n      if (i) rit[i][j] = max(rit[i][j], rit[i - 1][j]);\n      if (j) lef[i][j] = min(lef[i][j], lef[i][j - 1]);\n      if (j) rit[i][j] = max(rit[i][j], rit[i][j - 1]);\n    }\n  }\n\n  // Calculate Top in U, and Bottom in D\n  vector<vector<int>> upper(HU + 1, vector<int>(m, inf));\n  vector<vector<int>> lower(HD, vector<int>(m, -inf));\n  vector<int> top(m, inf), bot(m, -inf);\n  for (int i = 0; i <= HU; i++) {\n    for (int j = 0; j < m; j++) if (U[i][j] != '#') {\n      upper[i][j] = i;\n      if (i) upper[i][j] = min(upper[i][j], upper[i - 1][j]);\n      if (j) upper[i][j] = min(upper[i][j], upper[i][j - 1]);\n    }\n  }\n  for (int i = HD - 1; ~i; i--) {\n    for (int j = m - 1; ~j; j--) if (D[i][j] != '#') {\n      lower[i][j] = i;\n      if (i < HD - 1) lower[i][j] = max(lower[i][j], lower[i + 1][j]);\n      if (j < m  - 1) lower[i][j] = max(lower[i][j], lower[i][j + 1]);\n    }\n  }\n  for (int j = 0; j < m; j++) {\n    top[j] = upper[HU][j];\n    bot[j] = lower[0][j];\n  }\n\n  // Calculate MeetPoint in D\n  vector<vector<int>> met(m, vector<int>(m, inf));\n  for (int i = 0; i < HD; i++) {\n    for (int j = 0; j < m; j++) {\n      if (lef[i][j] <= rit[i][j]) {\n        met[lef[i][j]][rit[i][j]] = min(met[lef[i][j]][rit[i][j]], i);\n      }\n    }\n  }\n  for (int l = 0; l < m; l++) {\n    for (int r = m - 1; ~r; --r) {\n      if (l        ) met[l][r] = min(met[l][r], met[l - 1][r]);\n      if (r < m - 1) met[l][r] = min(met[l][r], met[l][r + 1]);\n    }\n  }\n  for (int l = 0; l < m; l++) {\n    for (int r = 0; r < m; r++) {\n      met[l][r] = met[l][r] <= bot[l] && met[l][r] <= bot[r] ? met[l][r] : inf;\n    }\n  }\n\n  // Inclusion-Exclusion of BothReachable in D\n  vector<int> SLR(HD, 0);\n  vector<vector<int>> SAL(HD, vector<int>(m, 0)), SRB(HD, vector<int>(m, 0));\n  vector<vector<int>> SAB(m, vector<int>(m, 0));\n  for (int i = 0; i < HD; i++) {\n    if (i) SLR[i] = SLR[i - 1];\n    for (int j = 0; j < m; j++) if (lef[i][j] <= rit[i][j]) {\n      SLR[i] += D[i][j] - '0';\n    }\n  }\n  for (int i = 0; i < HD; i++) {\n    for (int j = 0; j < m; j++) if (i) {\n      SAL[i][j] = SAL[i - 1][j];\n      SRB[i][j] = SRB[i - 1][j];\n    }\n    for (int j = 0; j < m; j++) if (lef[i][j] <= rit[i][j]) {\n      if (lef[i][j]        ) SAL[i][lef[i][j] - 1] += D[i][j] - '0';\n      if (rit[i][j] < m - 1) SRB[i][rit[i][j] + 1] += D[i][j] - '0';\n    }\n  }\n  for (int i = 0; i < HD; i++) {\n    for (int j = m - 2; ~j; j--) {\n      SAL[i][j] += SAL[i][j + 1];\n    }\n    for (int j = 1; j < m; j++) {\n      SRB[i][j] += SRB[i][j - 1];\n    }\n  }\n  for (int i = 0; i < HD; i++) {\n    for (int j = 0; j < m; j++) if (lef[i][j] <= rit[i][j]) {\n      if (lef[i][j] && rit[i][j] < m - 1) SAB[lef[i][j] - 1][rit[i][j] + 1] += D[i][j] - '0';\n    }\n  }\n  for (int l = m - 1; ~l; l--) {\n    for (int r = l; r < m; r++) {\n      if (l < m - 1) SAB[l][r] += SAB[l + 1][r];\n      if (r        ) SAB[l][r] += SAB[l][r - 1];\n      if (l < m - 1 && r) SAB[l][r] -= SAB[l + 1][r - 1];\n    }\n  }\n\n  // Implement BothReachable in D\n  auto both = [&](int a, int b, int l) {\n    return met[a][b] > l ? 0 : SLR[l] - SAL[l][a] - SRB[l][b] + SAB[a][b];\n  };\n\n  // Calculate Reachable int D\n  vector<int> reach(m, 0);\n  for (int i = 0; i < m; i++) {\n    reach[i] = both(i, i, bot[i]);\n  }\n\n  // Calculate Min, Max in U\n  vector<vector<int>> mn(HU + 1, vector<int>(m, inf)), mx(HU + 1, vector<int>(m, -inf));\n  for (int i = m - 1; ~i; i--) if (U[HU][i] != '#') {\n    mn[HU][i] = i;\n    mx[HU][i] = max(i, i + 1 < m ? mx[HU][i + 1] : -inf);\n  }\n  for (int i = HU - 1; ~i; i--) {\n    for (int j = m - 1; ~j; j--) if (U[i][j] != '#') {\n      mn[i][j] = mn[i + 1][j];\n      mx[i][j] = mx[i + 1][j];\n      if (j < m - 1) mn[i][j] = min(mn[i][j], mn[i][j + 1]);\n      if (j < m - 1) mx[i][j] = max(mx[i][j], mx[i][j + 1]);\n    }\n  }\n\n  // Implemention of Stack\n  vector<int> has(m), st(m);\n  int sum = 0, stl = 0, str = 0, cul = 0, cur = -1, row = 0;\n  auto init = [&]() {\n    has = st = vector<int>(m, 0);\n    sum = stl = str = cul = 0; cur = -1;\n  };\n\n  // Implement Insert\n  auto insert = [&](int x) {\n    if (top[x] > row) return;\n    if (stl < str) {\n      int delta = both(st[str - 1], x, min(bot[st[str - 1]], bot[x]));\n      sum -= delta;\n      has[st[str - 1]] -= delta;\n      if (bot[st[str - 1]] <= bot[x]) {\n        --str;\n        while (stl < str) {\n          delta = both(st[str - 1], x, min(bot[st[str - 1]], bot[x])) - both(st[str - 1], x, min(bot[st[str]], bot[x]));\n          sum -= delta;\n          has[st[str - 1]] -= delta;\n          if (bot[st[str - 1]] <= bot[x]) {\n            --str;\n          } else {\n            break;\n          }\n        }\n      }\n    }\n    st[str++] = x;\n    has[x] = reach[x];\n    sum += has[x];\n  };\n\n  // Implement Erase\n  auto erase = [&](int x) {\n    if (top[x] > row) return;\n    sum -= has[x];\n    if (stl < str && st[stl] == x) ++stl;\n  };\n\n  // Iterate through U\n  for (row = 0; row < HU; row++) {\n    init();\n    for (int i = 0; i < m; i++) {\n      if (mn[row][i] <= mx[row][i]) {\n        while (cur < mx[row][i]) insert(++cur);\n        while (cul < mn[row][i]) erase(cul++);\n        ans += (U[row][i] - '0') * sum;\n      }\n    }\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<string> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  solve(a);\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re \nint v[2][1510][1510],lt[1510][1510],rt[1510][1510],bt[1510],ut[1510];\nint ln[1510][1510],rn[1510][1510],nn[1510][1510],lc[1510],mn[1510][1510];\nchar ss[1510];\nlong long ans;\nint num(re int x1,re int x2,re int l)\n{\n\tl=std::min(bt[x1],std::min(bt[x2],l));\n\tif(l<mn[x1][x2])return 0;\n\treturn lc[l]-ln[l][x2-1]-rn[l][x1+1]+nn[x1+1][x2-1];\n}\nvoid dp(re int vc,re int x1,re int y1,re int x2,re int y2)\n{\n\tfor(re int i=x1-1;i<=x2+1;i++)\n\t\tfor(re int j=y1-1;j<=y2+1;j++)lt[i][j]=1<<30,rt[i][j]=-1<<30,ln[i][j]=rn[i][j]=0;\n\tfor(re int i=y1-1;i<=y2+1;i++)\n\t\tfor(re int j=y1-1;j<=y2+1;j++)nn[i][j]=0,mn[i][j]=1<<30;\n\tfor(re int i=y1-1;i<=y2+1;i++)bt[i]=-1<<30;\n\tfor(re int i=x1;i<=x2;i++)\n\t{\n\t\tfor(re int j=y1;j<=y2;j++)\n\t\tif(v[vc][i][j]){\n\t\t\tif(i==x1)lt[i][j]=rt[i][j]=j;\n\t\t\tlt[i][j]=std::min(lt[i][j],std::min(lt[i-1][j],lt[i][j-1]));\n\t\t\trt[i][j]=std::max(rt[i][j],std::max(rt[i-1][j],rt[i][j-1]));\n\t\t\tre int x=lt[i][j],y=rt[i][j];\n\t\t\tif(x<=y)\n\t\t\t{\n\t\t\t\tmn[x][y]=std::min(mn[x][y],i),nn[x][y]+=v[vc][i][j];\n\t\t\t\tln[i][y]+=v[vc][i][j],rn[i][x]+=v[vc][i][j];\n\t\t\t}//printf(\"**lr**%d %d %d %d %d\\n\",i,j,x,y,mn[x][y]);\n\t\t}\n\t}\n\tfor(re int i=x1;i<=x2;lc[i]=ln[i][y2],i++)\n\t\tfor(re int j=y1;j<=y2;j++)\n\t\t\tln[i][j]+=ln[i-1][j]+ln[i][j-1]-ln[i-1][j-1];\n\tfor(re int i=x1;i<=x2;i++)\n\t\tfor(re int j=y2;j>=y1;j--)\n\t\t\trn[i][j]+=rn[i-1][j]+rn[i][j+1]-rn[i-1][j+1];\n\tfor(re int i=y1;i<=y2;i++)\n\t\tfor(re int j=y2;j>=y1;j--)\n\t\t\tmn[i][j]=std::min(mn[i][j],std::min(mn[i-1][j],mn[i][j+1]));\n\tfor(re int i=y2;i>=y1;i--)\n\t\tfor(re int j=y1;j<=y2;j++)\n\t\t\tnn[i][j]+=nn[i+1][j]+nn[i][j-1]-nn[i+1][j-1];\n\tfor(re int i=x2;i>=x1;i--)\n\t\tfor(re int j=y2;j>=y1;j--)\n\t\tif(v[vc][i][j]){\n\t\t\tbt[j]=std::max(bt[j],std::max(i,bt[j+1]));//printf(\"*k*%d %d %d\\n\",i,j,bt[j]);\n\t\t}else bt[j]=-1<<30;\n\t//for(re int i=y1;i<=y1;i++)if(bt[i]!=-1<<30)printf(\"**b**%d %d %d %d %d %d:%d %d %d %d\\n\",vc,i,bt[i],mn[i][i],ln[bt[i]][i],num(i,i,bt[i]),x1,y1,x2,y2);\n}\nint ov[1510],q[1510];\nvoid clac(re int vc,re int x1,re int y1,re int x2,re int y2)\n{//puts(\"*************\");\n\tfor(re int i=x1-1;i<=x2+1;i++)\n\t\tfor(re int j=y1-1;j<=y2+1;j++)lt[i][j]=1<<30,rt[i][j]=-1<<30;\n\tfor(re int i=y1-1;i<=y2+1;i++)ut[i]=1<<30;\n\tfor(re int i=x2;i>=x1;i--)\n\t{\n\t\tfor(re int j=y2;j>=y1;j--)\n\t\tif(v[vc][i][j]){\n\t\t\tif(i==x2)lt[i][j]=rt[i][j]=j;\n\t\t\tlt[i][j]=std::min(lt[i][j],std::min(lt[i+1][j],lt[i][j+1]));\n\t\t\trt[i][j]=std::max(rt[i][j],std::max(rt[i+1][j],rt[i][j+1]));\n\t\t}\n\t}\n\tfor(re int i=x1;i<=x2;i++)\n\t\tfor(re int j=y1;j<=y2;j++)\n\t\tif(v[vc][i][j]){\n\t\t\tut[j]=std::min(ut[j],std::min(i,ut[j-1]));\n\t\t}else ut[j]=1<<30;\n\t//printf(\"*ut*%d %d %d\\n\",i,x1,ut[3]);}\n\tre int ii=0,jj=0,jj1=0;\n\tfor(re int i=x1;i<x2;i++)\n\t{\n\t\tre long long ncm=0,ta=0;jj=y1-1;jj1=y1-1;\n\t\tfor(re int j=y1;j<=y2;j++)ov[j]=0;\n\t\tfor(re int j=y1;j<=y2;j++)\n\t\tif(lt[i][j]<=rt[i][j]){\n\t\t\twhile(jj<rt[i][j])\n\t\t\t{//printf(\"**%d %d %d %d %d %d %d %d %d %d %d\\n\",vc,x1,y1,x2,y2,jj+1,ut[jj+1],bt[jj+1],lt[i][j],rt[i][j]);\n\t\t\t\t\n\t\t\t\tif(ut[++jj]>i)continue;//printf(\"*****************ujj**%d %d\\n\",jj,ut[jj]);\n\t\t\t\tov[jj]=num(jj,jj,bt[jj]);\n\t\t\t\tncm+=ov[jj];q[ta+1]=0;bt[0]=-1<<30;\n\t\t\t\tfor(;q[ta]>jj1;ta--)\n\t\t\t\t{\n\t\t\t\t\tre int tt=num(q[ta],jj,bt[q[ta]])-num(q[ta],jj,bt[q[ta+1]]);\n\t\t\t\t\t//printf(\"**jj**%d %d %d %d %d\\n\",i,j,jj,q[ta],tt);\n\t\t\t\t\tov[q[ta]]-=tt;ncm-=tt;\n\t\t\t\t\tif(bt[q[ta]]>bt[jj])break;\n\t\t\t\t}q[++ta]=jj;\n\t\t\t}\n\t\t\twhile(jj1<lt[i][j]-1)\n\t\t\t{\n\t\t\t\tncm-=ov[++jj1];\n\t\t\t}//printf(\"*ll*%d %d %d %d %lld\\n\",jj,jj1,ut[jj],num(jj,jj,bt[jj]),ncm);\n\t\t\tans+=v[vc][i][j]*ncm;\n\t\t}\n\t}\n}\nvoid dc(re int vc,re int x1,re int y1,re int x2,re int y2)\n{\n\tif(x2==x1&&y2==y1)return;\n\tif(x2-x1<y2-y1)vc^=1,std::swap(x1,y1),std::swap(x2,y2);\n\tre int xx=(x1+x2)/2;\n\tdc(vc,x1,y1,xx,y2);\n\tdc(vc,xx+1,y1,x2,y2);\n\tdp(vc,xx+1,y1,x2,y2);\n\tclac(vc,x1,y1,xx+1,y2);\n\t//if(vc)printf(\"***%d %d %d %d %d %lld\\n\",vc,y1,x1,y2,x2,ans);\n\t//else printf(\"***%d %d %d %d %d %lld\\n\",vc,x1,y1,x2,y2,ans);\n}\nint main()\n{\n\tre int n;\n\tscanf(\"%d\",&n);\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",ss+1);\n\t\tfor(re int j=1;j<=n;j++)v[0][i][j]=v[1][j][i]=(ss[j]=='#'?0:ss[j]-'0');\n\t}\n\tdc(0,1,1,n,n);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint S[N],n,u[N][N],l[2][N],r[2][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;i++)scanf(\"%s\",A[i]+1);\n\tfor (register int i=0;i<=n;i++)\n\t\tfor (register int j=0;j<=n;j++)u[i][j]=A[i][j]>='0'&&A[i][j]<='9'?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;x++){\n\t\tfor (register int i=x;i;i--){\n\t\t\tint t=i&1;\n\t\t\tfor (register int j=1;j<=n;j++)S[j]=S[j-1]+(u[x][j]<=i?A[x][j]-'0':0);\n\t\t\tfor (register int j=n+1;j;j--){\n\t\t\t\tif (A[i][j]>='0'&&A[i][j]<='9'){\n\t\t\t\t\tif (i<x){\n\t\t\t\t\t\tl[t][j]=min(l[t][j+1],l[t^1][j]);\n\t\t\t\t\t\tr[t][j]=max(r[t][j+1],r[t^1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse l[t][j]=j,r[t][j]=max(j,r[t][j+1]);\n\t\t\t\t\tif (l[t][j]<=r[t][j])ans+=(A[i][j]-'0')*(S[r[t][j]]-S[l[t][j]-1]-(i==x?A[i][j]-'0':0));\n\t\t\t\t}\n\t\t\t\telse l[t][j]=1e9,r[t][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace whatever{\n\tint readu(){\n\t\tchar ch=getchar();\n\t\twhile(!isdigit(ch))\n\t\t\tch=getchar();\n\t\tint value=ch-'0';\n\t\tch=getchar();\n\t\twhile(isdigit(ch)){\n\t\t\tvalue=value*10+ch-'0';\n\t\t\tch=getchar();\n\t\t}\n\t\treturn value;\n\t}\n\tvoid writeull(long long n){\n\t\tif(n<10)\n\t\t\tputchar(n+'0');\n\t\telse{\n\t\t\twriteull(n/10);\n\t\t\tputchar(n%10+'0');\n\t\t}\n\t}\n\tstruct set_type{\n\t\tunsigned long long *data;\n\t\tint size;\n\t\tvoid clear(){\n\t\t\tmemset(data, 0, sizeof(unsigned long long)*size);\n\t\t}\n\t\tvoid resize(int k){\n\t\t\tsize=(k+63)/64;\n\t\t\tsize=(size+3)/4*4;\n\t\t\tdata=new unsigned long long [size];\n\t\t\tclear();\n\t\t}\n\t\tvoid operator|=(const set_type &b){\n\t\t\tassert(size%4==0);\n\t\t\tassert(size==b.size);\n\t\t\tfor(int i=0; i<size; i+=4){\n\t\t\t\tdata[i]|=b.data[i];\n\t\t\t\tdata[i+1]|=b.data[i+1];\n\t\t\t\tdata[i+2]|=b.data[i+2];\n\t\t\t\tdata[i+3]|=b.data[i+3];\n\t\t\t}\n\t\t}\n\t\tint count(){\n\t\t\tassert(size%4==0);\n\t\t\tint result=0;\n\t\t\tfor(int i=0; i<size; i+=4){\n\t\t\t\tresult+=__builtin_popcountll(data[i]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+1]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+2]);\n\t\t\t\tresult+=__builtin_popcountll(data[i+3]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvoid set(unsigned index){\n\t\t\tassert(size%4==0);\n\t\t\tassert(index<size*64);\n\t\t\tdata[index/64]|=(1ull<<(index%64));\n\t\t}\n\t};\n\tvoid run(){\n\t\tint n=readu();\n\t\tstatic char a[500][502];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tgets(a[i]);\n\t\tstatic int cnt[10];\n\t\tstatic int index[500][500];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tif(a[i][j]!='#'){\n\t\t\t\t\tassert(isdigit(a[i][j]));\n\t\t\t\t\tindex[i][j]=cnt[a[i][j]-'0']++;\n\t\t\t\t}\n\t\tstatic set_type data[500][10];\n\t\tfor(int j=0; j<n; ++j)\n\t\t\tfor(int k=0; k<10; ++k)\n\t\t\t\tdata[j][k].resize(cnt[k]);\n\t\tlong long result=0;\n\t\tcerr<<\"clock(): \"<<clock()/double(CLOCKS_PER_SEC)<<endl;\n\t\tfor(int r=n-1; r>=0; --r)\n\t\t\tfor(int c=n-1; c>=0; --c){\n\t\t\t\tif(isdigit(a[r][c])){\n\t\t\t\t\tfor(int i=0; i<10; ++i){\n\t\t\t\t\t\tif(c<n-1)\n\t\t\t\t\t\t\tdata[c][i]|=data[c+1][i];\n\t\t\t\t\t\tresult+=(long long)data[c][i].count()*i*(a[r][c]-'0');\n\t\t\t\t\t}\n\t\t\t\t\tdata[c][a[r][c]-'0'].set(index[r][c]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int i=0; i<10; ++i)\n\t\t\t\t\t\tdata[c][i].clear();\n\t\t\t\t}\n\t\t\t}\n\t\tcerr<<\"clock(): \"<<clock()/double(CLOCKS_PER_SEC)<<endl;\n\t\twriteull(result);\n\t\tputchar('\\n');\n\t}\n}\nint main(){\n\twhatever::run();\n}"
  },
  {
    "language": "C++",
    "code": "//無理。\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nconst int MN = 550;\nint N;\nusing B = array<ull, MN/64+1>;\nint g[MN][MN];\n\n\nB used[MN][MN];\n\nnamespace std {\nbool operator<(const B &l, const B &r) {\n    for (int i = 0; i < MN / 64 + 1; i++) {\n        if (l[i] != r[i]) return l[i] < r[i];\n    }\n    return false;\n}\nbool operator>(const B &l, const B &r) {\n    return r < l;\n}\n\nbool operator==(const B &l, const B &r) {\n    for (int i = 0; i < MN / 64 + 1; i++) {\n        if (l[i] != r[i]) return false;\n    }\n    return true;\n}\n}\n\nbool sam(const B& l, const B& r) {\n    for (int i = 0; i < MN/64+1; i++) {\n        if (l[i] & r[i]) return true;\n    }\n    return false;\n}\n\nbool gt(const B& b, int id) {\n    return (b[id/64] & (1ULL << (id%64))) != 0;\n}\n\nvoid st(B& b, int id) {\n    b[id/64] |= 1ULL << (id % 64);\n}\n\nint L, R, D, U;\nvoid dfs_up(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    //if (g[a][b] == 0 || used[a][b][id]) return;\n    if (g[a][b] == 0 || gt(used[a][b], id)) return;\n    st(used[a][b], id);\n    //used[a][b][id] = true;\n    dfs_up(a-1, b, id); dfs_up(a, b-1, id);\n}\n\nvoid dfs_dw(int a, int b, int id) {\n    if (!(L <= a && a <= R && D <= b && b <= U)) return;\n    if (g[a][b] == 0 || gt(used[a][b], id)) return;\n    st(used[a][b], id);\n//    if (g[a][b] == 0 || used[a][b][id]) return;\n//    used[a][b][id] = true;\n    dfs_dw(a+1, b, id); dfs_dw(a, b+1, id);\n}\n\nll ans = 0;\n\nusing P = pair<B, int>;\n\nV<P> uni(V<P> v) {\n    sort(v.begin(), v.end());\n    V<P> res;\n    for (auto &p: v) {\n        if (res.size() && res.back().first == p.first) {\n            res.back().second += p.second;\n            continue;\n        }\n        res.push_back(p);\n    }\n    return res;\n}\nvoid solve(int l, int r, int d, int u) {\n    if (r < l || u < d) return;\n    if (l == r && d == u) return;\n    L = l; R = r; D = d; U = u;\n    for (int x = l; x <= r; x++) {\n        for (int y = d; y <= u; y++) {\n            used[x][y] = B();\n        }\n    }\n    if (r-l > u-d) {\n        int m = (l+r)/2;\n        for (int y = d; y <= u; y++) {\n            dfs_up(m, y, y);\n        }\n        for (int y = u; y >= d; y--) {\n            dfs_dw(m+1, y, y);\n        }\n        V<P> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (x <= m) mp1.push_back(P(used[x][y], g[x][y]));\n                else mp2.push_back(P(used[x][y], g[x][y]));\n            }\n        }\n        mp1 = uni(mp1); mp2 = uni(mp2);\n\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                //if ((p1.first & p2.first).count()) ans += ll(p1.second) * p2.second;\n                if (sam(p1.first, p2.first)) ans += ll(p1.second) * p2.second;\n            }\n        }\n        solve(l, m, d, u);\n        solve(m+1, r, d, u);\n    } else {\n        int m = (d+u)/2;\n\n        for (int x = l; x <= r; x++) {\n            dfs_up(x, m, x);\n        }\n        for (int x = r; x >= l; x--) {\n            dfs_dw(x, m+1, x);\n        }\n\n        using P = pair<B, int>;\n        V<P> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (y <= m) mp1.push_back(P(used[x][y], g[x][y]));\n                else mp2.push_back(P(used[x][y], g[x][y]));\n            }\n        }\n        mp1 = uni(mp1); mp2 = uni(mp2);\n/*        map<B, int> mp1, mp2;\n        for (int x = l; x <= r; x++) {\n            for (int y = d; y <= u; y++) {\n                if (y <= m) mp1[used[x][y]] += g[x][y];\n                else mp2[used[x][y]] += g[x][y];\n            }\n        }*/\n        for (auto &p1: mp1) {\n            for (auto &p2: mp2) {\n                if (sam(p1.first, p2.first)) ans += ll(p1.second) * p2.second;\n            }\n        }\n        solve(l, r, d, m);\n        solve(l, r, m+1, u);\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(20) << fixed;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        string s;\n        cin >> s;\n        for (int j = 1; j <= N; j++) {\n            int d = 0;\n            if (isdigit(s[j-1])) d = s[j-1] - '0';\n            g[i][j] = d;\n            //ans -= d*d;\n        }\n    }\n    solve(1, N, 1, N);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = 1542;\n\nrandom_device rd;\nmt19937 mt(rd());\n\nstring t[MAXN];\n\nstruct node\n{\n\tint sum, prior;\n\tpair<int, int> value;\n\n\tnode *l, *r;\n\tnode() { sum = prior = 0; l = r = nullptr; value = {0, 0}; }\n\n\tnode(int i, int j)\n\t{\n\t\tvalue = {i, j};\n\t\tsum = t[i][j] - '0';\n\t\tprior = mt();\n\t\tl = r = nullptr;\n\t}\n};\n\nusing pnode = node*;\n\npnode copy_node(pnode t)\n{\n\tif(!t) return nullptr;\n\n\tpnode ret = new node();\n\t\n\tret->prior = mt();\n\tret->l = t->l;\n\tret->r = t->r;\n\tret->value = t->value;\n\tret->sum = t->sum;\n\n\treturn ret;\n}\n\nvoid pull(pnode &t)\n{\n\tif(!t) return;\n\n\tt->sum = ::t[t->value.first][t->value.second] - '0';\n\t\n\tif(t->l) t->sum += t->l->sum;\n\tif(t->r) t->sum += t->r->sum;\n}\n\nvoid split(pnode t, pnode &l, pnode &r, pair<int, int> k)\n{\n\tif(!t) { l = r = nullptr; return; }\n\n\tif(t->value <= k)\n\t{\n\t\tpnode ret = copy_node(t);\n\t\tsplit(ret->r, ret->r, r, k);\n\t\tl = ret;\n\t\tpull(l);\n\t}\n\telse\n\t{\n\t\tpnode ret = copy_node(t);\n\t\tsplit(ret->l, l, ret->l, k);\n\t\tr = ret;\n\t\tpull(r);\n\t}\n}\n\nvoid merge(pnode &t, pnode a, pnode b)\n{\n\tif(!a) { t = copy_node(b); return; }\n\tif(!b) { t = copy_node(a); return; }\n\n\tif(a->prior < b->prior) swap(a, b);\n\n\tt = copy_node(a);\n\n\tpnode l, r, dummy, l1;\n\tsplit(b, l1, r, t->value);\n\tsplit(l1, l, dummy, {t->value.first, t->value.second - 1});\n\n\tmerge(t->l, l, t->l);\n\tmerge(t->r, r, t->r);\n\n\tpull(t);\n}\n\nint n;\n\nvoid read()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> t[i];\n}\n\npnode dp[MAXN][MAXN];\n\nvoid solve()\n{\n\tint answer = 0;\n\tfor(int i = n - 1; i >= 0; i--)\n\t\tfor(int j = n - 1; j >= 0; j--)\n\t\t\tif(t[i][j] != '#')\n\t\t\t{\n\t\t\t\tdp[i][j] = new node(i, j);\n\t\t\t\tif(i != n - 1 && t[i + 1][j] != '#') merge(dp[i][j], dp[i][j], dp[i + 1][j]);\n\t\t\t\tif(j != n - 1 && t[i][j + 1] != '#') merge(dp[i][j], dp[i][j], dp[i][j + 1]);\n\t\t\t\tanswer += (dp[i][j]->sum - t[i][j] + '0') * (t[i][j] - '0');\n\t\t\t}\n\n\tcout << answer << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef unsigned long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 64\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v){\n\t    wek.resize((v/d)+2, 0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trep(x,10) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+1);\n\t\t\t\tif(x) rep(w,10) oruj(B[w][x],B[w][x-1]);\n\t\t\t\trep(w,10) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(w,10) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n//typedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define ll __int128\nstruct bity\n{\n\t#define d 127\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v){\n\t//\tint new_sz = v/d+2;\n\t\twek.resize((v/d)+2, 0);//while(wek.size() < new_sz) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[505];\nlong long ans;\n\nint main(){\n\tscanf(\"%d\",&n); //n = 500; srand((unsigned)time(NULL));\n\tfor(int i=0;i<n;i++) {//for(int j=0;j<n;j++){\n      //\tint x = rand()%10;\n      //\tif(x==0) f[i][j] = '#'; else f[i][j] = '0'+x; //\n      scanf(\"%s\",&f[i]);\n    }\n\trep(i,n) B[i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[x].upper(9*(x*n+y)+9);\n\t\t\t\tif(x) oruj(B[x],B[x-1]);\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[x].licz());\n\t\t\t\trep(a,f[x][y]-'0') B[x].ustaw(9*(x*n+y)+a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tB[x].zeruj();\n\t\t\t\tB[x].upper(9*(x*n+y)+9);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1500;\nconst int oo = 0x3f3f3f3f;\n\nint n;\nint a[N + 5][N + 5];\nint f[N + 5][N + 5];\nchar st[N + 5][N + 5];\nint L[N + 5][N + 5], R[N + 5][N + 5];\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; ++i) {\n        scanf(\"%s\", st[i] + 1);\n        for(int j = 1; j <= n; ++j) {\n            a[i][j] = (st[i][j] == '#') ? 0 : st[i][j] - '0';\n        }\n    }\n\n    long long ans = 0;\n    for(int j = n; j >= 1; --j) if(a[n][j] > 0) {\n        L[n][j] = j; \n\n        if(a[n][j + 1] > 0) {\n            f[n][j] = f[n][j + 1];\n            R[n][j] = R[n][j + 1];\n        } else {\n            R[n][j] = j;\n        }\n\n        ans += a[n][j] * f[n][j];\n        f[n][j] += a[n][j];\n    }\n\n    for(int i = n - 1; i >= 1; --i) {\n        for(int j = n; j >= 1; --j) if(a[i][j] > 0) {\n            bool r = (a[i][j + 1] > 0), d = (a[i + 1][j] > 0);\n\n            if(!r && !d) {\n                L[i][j] = R[i][j] = j;\n                for(int k = i + 1; k <= n; ++k) L[k][j] = oo, R[k][j] = -oo;\n            } else if(r && !d) {\n                L[i][j] = j;\n                R[i][j] = R[i][j + 1];\n                f[i][j] = f[i][j + 1];\n                for(int k = i + 1; k <= n; ++k) L[k][j] = L[k][j + 1], R[k][j] = R[k][j + 1];\n            } else if(!r && d) {\n                f[i][j] = f[i + 1][j];\n                L[i][j] = R[i][j] = j;\n            } else {\n                L[i][j] = j; R[i][j] = R[i][j + 1];\n                f[i][j] = f[i + 1][j] + f[i][j + 1];\n\n                int lim = 0, flag = 0;\n                for(int k = i + 1; k <= n; ++k) {\n                    if(!flag && R[k][j] >= L[k][j + 1] && L[k][j + 1] > lim) {\n                        f[i][j] -= f[k][L[k][j + 1]];\nflag = 1;\n                    }\n                    lim = R[k][j];\n                    L[k][j] = min(L[k][j], L[k][j + 1]);\n                    R[k][j] = max(R[k][j], R[k][j + 1]);\n                }\n            }\n            \n            ans += a[i][j] * f[i][j];\n            f[i][j] += a[i][j];\n        }\n    }\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,g[505][505],s[505][505],mx,xx[505][505];\nbool e[505][505];\nLL res;\nint readchar(){\n\tchar c=getchar();\n\twhile(c==' ' || c=='\\n') c=getchar();\n\tif(c=='#') return 0;\n\treturn c-'0';\n}\nnamespace DSU{\n\tint fa[250005],rk[250005];\n\tvoid init(){\n\t\tint i;\n\t\tmemset(rk,0,sizeof(rk));\n\t\tfor(i=0;i<=n*n;++i) fa[i]=i;\n\t}\n\tint ancestor(int x){\n\t\tif(fa[x]!=x) fa[x]=ancestor(fa[x]);\n\t\treturn fa[x];\n\t}\n\tvoid unite(int u,int v){\n\t\tu=ancestor(u);\n\t\tv=ancestor(v);\n\t\tif(rk[u]<rk[v])\n\t\t\tfa[u]=v;\n\t\telse if(rk[u]>rk[v])\n\t\t\tfa[v]=u;\n\t\telse{\n\t\t\tfa[u]=v;\n\t\t\t++rk[v];\n\t\t}\n\t}\n\tbool con(int u,int v){\n\t\treturn ancestor(u)==ancestor(v);\n\t}\n};\nvoid add(int x,int y){\n\te[x][y]=1;\n\tif(e[x-1][y]) DSU::unite(x*n+y,(x-1)*n+y);\n\tif(e[x][y-1]) DSU::unite(x*n+y-1,x*n+y);\n\tif(e[x+1][y]) DSU::unite(x*n+y,(x+1)*n+y);\n\tif(e[x][y+1]) DSU::unite(x*n+y+1,x*n+y);\n\tif(x<n-1 && g[x+1][y] && !e[x+1][y]) add(x+1,y);\n\tif(y<n-1 && g[x][y+1] && !e[x][y+1]) add(x,y+1);\n}\nint getlower(int x,int y){\n\t//if(x==4 && y==2) printf(\" start lower %d %d\\n\",x,y);\n\tint cx=x,cy=y,ret=(y?s[x][y-1]:0);\n\tmx=x;\n\t//if(x==4 && y==2) printf(\"%d %d\\n\",x,y-1);\n\twhile(1){\n\t\twhile(1){\n\t\t\tif(cx+1<n && e[cx+1][cy]){\n\t\t\t\t++cx;\n\t\t\t\tmx=cx;\n\t\t\t\tret+=(cy?s[cx][cy-1]:0);\n\t//\t\t\tif(x==4 && y==2) printf(\"%d %d\\n\",cx,cy-1);\n\t\t\t}\n\t\t\telse if(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cy+1<n){\n\t\t\t++cy;\n\t\t\tif(e[cx][cy] && DSU::con(cx*n+cy,x*n+y)){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(e[cx][cy]) break;\n\t\t}\n\t\tif(!found) break;\n\t}\n\t//if(x==4 && y==2) printf(\"\\n\");\n\treturn ret;\n}\nint getupper(int x,int y){\n\t//if(x==4 && y==2) printf(\" start upper %d %d\\n\",x,y);\n\tint cx=x,cy=y,ret=0;\n\twhile(1){\n\t\twhile(1){\n\t\t\tif(cy+1<n && e[cx][cy+1]){\n\t\t\t\t++cy;\n\t\t\t}\n\t\t\telse if(cx+1<n && e[cx+1][cy]){\n\t//\t\t\tif(x==4 && y==2) printf(\"%d %d\\n\",cx,cy);\n\t\t\t\tret+=s[cx][cy];\n\t\t\t\t++cx;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tbool found=0;\n\t\twhile(cx<n-1){\n\t//\t\tif(x==4 && y==2) printf(\"%d %d\\n\",cx,cy);\n\t\t\tret+=s[cx][cy];\n\t\t\t++cx;\n\t\t\tif(cx>mx) break;\n\t//\t\tif(x==4 && y==2) printf(\"%d %d: %d\\n\",cx,cy,DSU::con(cx*n+cy,x*n+y));\n\t\t\tif(e[cx][cy] && DSU::con(cx*n+cy,x*n+y)){\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(e[cx][cy]) break;\n\t\t}\n\t\tif(!found || cx>mx) break;\n\t}\n\tif(cx<=mx) ret+=s[cx][cy];\n\t//if(cx<=mx && x==4 && y==2) printf(\"%d %d\\n\\n\",cx,cy);\n\t//if(x==4 && y==2) printf(\"%d %d %d %d %d\\n\",e[5][2],e[6][2],e[6][3],e[6][4],e[6][5]);\n\treturn ret;\n}\nbool vis[505][505];\nint fv(int x,int y){\n\tif(!xx[x][y]) return 0;\n\tif(!vis[x][y]){\n\t\tvis[x][y]=1;\n\t}\n\telse return 0;\n\tint ret=xx[x][y];\n\tif(xx[x][y+1]) ret+=fv(x,y+1);\n\tif(xx[x+1][y]) ret+=fv(x+1,y);\n\treturn ret;\n}\nvoid solveline(int x){\n\tint i,j,k;\n\tmemcpy(s,g,sizeof(g));\n\tfor(i=0;i<n;++i){\n\t\tfor(j=1;j<n;++j){\n\t\t\ts[i][j]+=s[i][j-1];\n\t\t}\n\t}\n\tDSU::init();\n\tfor(i=x;i<n;++i) memset(e[i],0,sizeof(e[i]));\n\tfor(i=n-1;i>=0;--i){\n\t\tif(!g[x][i]) continue;\n\t\tadd(x,i);\n\t\tres-=(LL)g[x][i]*(LL)getlower(x,i);\n\t\tres+=(LL)g[x][i]*(LL)(getupper(x,i)-g[x][i]);\n\t\t//memset(vis,0,sizeof(vis));\n\t\t//if(fv(x,i)!=-getlower(x,i)+getupper(x,i)){\n\t\t//\tmemset(vis,0,sizeof(vis));\n\t\t//\tprintf(\"at %d,%d: exp %d act %d\\n\",x,i,fv(x,i),-getlower(x,i)+getupper(x,i));\n\t\t//}\n\t}\n}\nvoid del(int x,int y){\n\tif((!x || !g[x-1][y]) && (!y || !g[x][y-1])){\n\t\tg[x][y]=0;\n\t\tif(x<n-1) del(x+1,y);\n\t\tif(y<n-1) del(x,y+1);\n\t}\n}\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\tg[i][j]=readchar();\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n\tmemcpy(xx,g,sizeof(xx));\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\te[i][j]=(!!g[i][j]);\n\t\t}\n\t}\n    for(i=n-1;i>=0;--i){\n\t\tsolveline(i);\n\t\tfor(j=0;j<n;++j){\n\t\t\tdel(i,j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint ungigned\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking \n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?(x)-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define INF (1<<29)\nusing namespace std;\nconst int N=505;\nchar s[N];\nint n,cnt[N];\nll ans;\nint a[N][N],sum[N][N];\nint l[N][N],r[N][N];\nint tl[N][N],tr[N][N];\nvoid recalc(int i){\n\tFor(j,1,n) sum[i][j]=sum[i][j-1]+a[i][j];\n}\nint S(int i,int l,int r){\n\treturn sum[i][r]-(l?sum[i][l-1]:0);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFor(j,1,n) a[i][j]=(s[j]=='#'?0:s[j]-48);\n\t\trecalc(i);\n\t}\n\tFor(i,1,n) For(j,1,n)\n\t\tl[i][j]=n+1,r[i][j]=0;\n\tRep(x,n,1){\n\t\tFor(i,1,n) For(j,1,n)\n\t\t\ttl[i][j]=n+1,tr[i][j]=0;\n\t\tFor(y,x,n)\n\t\t\tif (y==x){\n\t\t\t\tRep(j,n,1) if(a[y][j]){\n\t\t\t\t\ttl[y][j]=j;\n\t\t\t\t\ttr[y][j]=max(j,j==n?0:tr[y][j+1]);\n\t\t\t\t\tans+=1ll*a[y][j]*S(y,tl[y][j]+1,tr[y][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tRep(j,n,1) if (a[x][j]){\n\t\t\t\t\ttl[y][j]=min(l[y][j],j==n?n+1:tl[y][j+1]);\n\t\t\t\t\ttr[y][j]=max(r[y][j],j==n?0:tr[y][j+1]);\n\t\t\t\t}\n\t\t\t\tFor(j,1,n) cnt[j]=0;\n\t\t\t\tFor(j,1,n) if (tl[y][j]<=tr[y][j]){\n\t\t\t\t\t++cnt[tl[y][j]];\n\t\t\t\t\t--cnt[tr[y][j]+1];\n\t\t\t\t}\n\t\t\t\tbool flag=0;\n\t\t\t\tFor(j,1,n){\n\t\t\t\t\tcnt[j]+=cnt[j-1];\n\t\t\t\t\tif (!cnt[j]&&a[y][j])\n\t\t\t\t\t\ta[y][j]=0,flag=1;\n\t\t\t\t}\n\t\t\t\tif (flag) recalc(y);\n\t\t\t\tFor(j,1,n)\n\t\t\t\t\tif (tl[y][j]<=tr[y][j])\n\t\t\t\t\t\tans+=1ll*a[x][j]*S(y,tl[y][j],tr[y][j]);\n\t\t\t}\n\t\tFor(i,1,n) For(j,1,n)\n\t\t\tl[i][j]=tl[i][j],r[i][j]=tr[i][j];\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\nconst int Q=1505;\nchar a[Q][Q];\nint f[Q][Q],l[Q][Q],r[Q][Q];\nint n;\nint Ok(int x,int y)\n{return (x<=n)&(y<=n)&(a[x][y]!='#');}\nint main()\n{\n    ll als=0;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%s\",a[i]+1);\n    for(int i=n;i;--i)\n        for(int j=n;j;--j){\n            if(!Ok(i,j)){\n                l[i][j]=n+1,r[i][j]=-1;\n                continue;\n            }\n            int D=Ok(i+1,j),R=Ok(i,j+1);\n            int val=a[i][j]-'0';\n            if(!(D|R)){\n                f[i][j]=val;\n                l[i][j]=r[i][j]=j;\n                for(int k=i+1;k<=n;k++)\n                    l[k][j]=n+1,r[k][j]=0;\n            }\n            else if(D&R){\n                f[i][j]=f[i+1][j]+f[i][j+1]+val;\n                for(int k=i+1,mxr=0;k<=n;k++){\n                    int &lv=l[k][j+1],&rv=r[k][j+1];\n                    if(lv>mxr&&lv<=r[k][j])f[i][j]-=f[k][lv];\n                    mxr=max(mxr,r[k][j]);\n                    l[k][j]=min(l[k][j],lv);\n                    r[k][j]=max(r[k][j],rv);\n                }\n                l[i][j]=j;\n                r[i][j]=r[i][j+1];\n            }\n            else if(D){\n                f[i][j]=f[i+1][j]+val;\n                l[i][j]=r[i][j]=j;\n            }\n            else{\n                f[i][j]=f[i][j+1]+val;\n                \n                for(int k=i;k<=n;k++)\n                    l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];l[i][j]=j;\n            }\n            als+=1LL*val*(f[i][j]-val);\n        }\n    printf(\"%lld\\n\",als);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nconst int N=505;\nint a[N][N],f[N][N],l[N][N],r[N][N];\nchar s[N];\n/* \nf[i][j] (i,j) 能走到的位置的权值和\nl[i][j][k]/r[i][j][k] 表示 (i,j) 可以到达的第 k 行最左/右的位置 ，第一维省略\n不能走到的点贡献相当于已经清零，因为 (i+1,j) (i,j+1) 共同能走到的点的递增序列里面不会出现这些位置，\n且没有被计算到其左上的点的贡献中去 \n*/\nint main(){\n//\tfreopen(\"cell.in\",\"r\",stdin);\n//\tfreopen(\"cell.out\",\"w\",stdout);\n\tri n,i,j,k,now,ans;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%s\",s+1);\n\t\tfor(j=1;j<=n;++j)\n\t\t\ta[i][j]=s[j]=='#'?0:s[j]-'0';\n\t}\n\tans=0;\n\tfor(i=n;i;--i)\n\t\tfor(j=n;j;--j){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tmemset(l[j]+i,127,sizeof(int)*(n-i+1));\n\t\t\t\tmemset(r[j]+i,128,sizeof(int)*(n-i+1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(a[i+1][j]==0&&a[i][j+1]==0)\n\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\telse if(a[i+1][j]==0)\n\t\t\t\tmemcpy(l[j]+i,l[j+1]+i,sizeof(int)*(n-i+1)),\n\t\t\t\tmemcpy(r[j]+i,r[j+1]+i,sizeof(int)*(n-i+1)),\n\t\t\t\tl[j][i]=j,\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\telse if(a[i][j+1]==0)\n\t\t\t\tl[j][i]=r[j][i]=j,\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\telse{\n\t\t\t\tf[i][j]=f[i][j+1]+f[i+1][j];\n\t\t\t\tl[j][i]=j;r[j][i]=r[j+1][i];\n\t\t\t\tnow=0;\n\t\t\t\tfor(k=i+1;k<=n;++k){\n\t\t\t\t\tif(r[j][k]>=l[j+1][k]&&l[j+1][k]>now)\n\t\t\t\t\t//\tprintf(\"sub %d %d %d %d\\n\",i,j,k,l[j+1][k]),\n\t\t\t\t\t\tf[i][j]-=f[k][l[j+1][k]];\n\t\t\t\t\tnow=max(now,r[j][k]);\n\t\t\t\t\tl[j][k]=min(l[j][k],l[j+1][k]);\n\t\t\t\t\tr[j][k]=max(r[j][k],r[j+1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=a[i][j]*f[i][j];\n\t\t//\tprintf(\"f %d %d %d\\n\",i,j,f[i][j]);\n\t\t\tf[i][j]+=a[i][j];\n\t\t//\tprintf(\"check (%d,%d)\\n\",i,j);\n\t\t//\tfor(k=i;k<=n;++k)\n\t\t//\t\tprintf(\"%d %d %d\\n\",k,l[j][k],r[j][k]);\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace whatever{\n\tint readu(){\n\t\tchar ch=getchar();\n\t\twhile(!isdigit(ch))\n\t\t\tch=getchar();\n\t\tint value=ch-'0';\n\t\tch=getchar();\n\t\twhile(isdigit(ch)){\n\t\t\tvalue=value*10+ch-'0';\n\t\t\tch=getchar();\n\t\t}\n\t\treturn value;\n\t}\n\tvoid writeull(long long n){\n\t\tif(n<10)\n\t\t\tputchar(n+'0');\n\t\telse{\n\t\t\twriteull(n/10);\n\t\t\tputchar(n%10+'0');\n\t\t}\n\t}\n\tstruct set_type{\n\t\tunsigned *data;\n\t\tint size;\n\t\tvoid clear(){\n\t\t\tmemset(data, 0, sizeof(unsigned)*size);\n\t\t}\n\t\tvoid resize(int k){\n\t\t\tsize=(k+31)/32;\n\t\t\tdata=new unsigned[size];\n\t\t\tclear();\n\t\t}\n\t\tvoid operator=(const set_type &b){\n\t\t\tassert(size==b.size);\n\t\t\tmemcpy(data, b.data, sizeof(unsigned)*size);\n\t\t}\n\t\tvoid operator|=(const set_type &b){\n\t\t\tassert(size==b.size);\n\t\t\tfor(int i=0; i<size; ++i)\n\t\t\t\tdata[i]|=b.data[i];\n\t\t}\n\t\tint count(){\n\t\t\tint result=0;\n\t\t\tfor(int i=size-1; i!=-1; --i)\n\t\t\t\tresult+=__builtin_popcount(data[i]);\n\t\t\treturn result;\n\t\t}\n\t\tvoid set(unsigned index){\n\t\t\tassert(index<size*32);\n\t\t\tdata[index/32]|=(1u<<(index%32));\n\t\t}\n\t};\n\tvoid run(){\n\t\tint n=readu();\n\t\tstatic char a[500][502];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tgets(a[i]);\n\t\tstatic int cnt[10];\n\t\tstatic int index[500][500];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tif(a[i][j]!='#'){\n\t\t\t\t\tassert(isdigit(a[i][j]));\n\t\t\t\t\tindex[i][j]=cnt[a[i][j]-'0']++;\n\t\t\t\t}\n\t\tstatic set_type set_data[2][500][10];\n\t\tfor(int i=0; i<2; ++i)\n\t\t\tfor(int j=0; j<n; ++j)\n\t\t\t\tfor(int k=0; k<10; ++k)\n\t\t\t\t\tset_data[i][j][k].resize(cnt[k]);\n\t\tset_type (*cur_set_data)[10]=set_data[0];\n\t\tset_type (*next_set_data)[10]=set_data[1];\n\t\tlong long result=0;\n\t\tfor(int r=n-1; r>=0; --r){\n\t\t\tfor(int c=n-1; c>=0; --c){\n\t\t\t\tif(isdigit(a[r][c])){\n\t\t\t\t\tfor(int i=0; i<10; ++i){\n\t\t\t\t\t\tnext_set_data[c][i]=cur_set_data[c][i];\n\t\t\t\t\t\tif(c<n-1)\n\t\t\t\t\t\t\tnext_set_data[c][i]|=next_set_data[c+1][i];\n\t\t\t\t\t\tresult+=(long long)next_set_data[c][i].count()*i*(a[r][c]-'0');\n\t\t\t\t\t\tif(i==a[r][c]-'0')\n\t\t\t\t\t\t\tnext_set_data[c][i].set(index[r][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int i=0; i<10; ++i)\n\t\t\t\t\t\tnext_set_data[c][i].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur_set_data, next_set_data);\n\t\t}\n\t\twriteull(result);\n\n\t}\n}\nint main(){\n\twhatever::run();\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N, m;\nll ans;\n\nint meet[1500][1500], lo[1500][1500], hi[1500][1500], bot[1500][1500];\nint cum[1500], ri[1500][1500], le[1500][1500], tot[1500][1500];\n// ri: row <= r, right < b\n// le: row <= r, left > a \n// tot: a < left <= right < b\n\nvector<string> transpose(vector<string> A) {\n    vector<string> a(sz(A[0]));\n    F0R(i,sz(A)) F0R(j,sz(A[0])) a[j] += A[i][j];\n    return a;\n}\n\nint meetPoint(int a, int b) {\n    int x = meet[a][b]; if (x > min(bot[m+1][a],bot[m+1][b])) return MOD;\n    return x;\n}\n\nint bothReach(int a, int b, int r) {\n    if (meetPoint(a,b) > min(r,MOD-1)) return 0;\n    ckmin(r,min(bot[m+1][a],bot[m+1][b]));\n    // ps(\"HUH\",r,cum[r],ri[r][b],le[r][a],tot[a][b]);\n    return cum[r]-ri[r][b]-le[r][a]+tot[a][b];\n}\n\nint reach(int a) { return bothReach(a,a,MOD); }\n\nvoid initLo(const vector<string>& A) {\n    FOR(i,m+1,sz(A)) F0R(j,sz(A[0])) {\n        lo[i][j] = MOD, hi[i][j] = -MOD;\n        if (A[i][j] == '#') continue;\n        if (i == m+1) lo[i][j] = hi[i][j] = j;\n        if (i > m+1) ckmin(lo[i][j],lo[i-1][j]), ckmax(hi[i][j],hi[i-1][j]);\n        if (j) ckmin(lo[i][j],lo[i][j-1]), ckmax(hi[i][j],hi[i][j-1]);\n    }\n    FORd(i,m+1,sz(A)) F0Rd(j,sz(A[0])) {\n        bot[i][j] = -MOD; if (A[i][j] == '#') continue;\n        bot[i][j] = i;\n        if (j+1 < sz(A[0])) ckmax(bot[i][j],bot[i][j+1]);\n        if (i+1 < sz(A)) ckmax(bot[i][j],bot[i+1][j]);\n        // ps(i,j,bot[i][j]);\n    }\n    // exit(0);\n    F0R(i,sz(A[0])) FOR(j,i,sz(A[0])) {\n        meet[i][j] = MOD;\n        tot[i][j] = 0;\n    }\n    FOR(i,m+1,sz(A)) F0R(j,sz(A[0])) if (lo[i][j] != MOD) {\n        ckmin(meet[lo[i][j]][hi[i][j]],i);\n        if (lo[i][j] > 0 && hi[i][j]+1 < sz(A[0])) tot[lo[i][j]-1][hi[i][j]+1] += A[i][j]-'0';\n    }\n    F0R(i,sz(A[0])) FORd(j,i+1,sz(A[0])) {\n        ckmin(meet[i+1][j],meet[i][j]); ckmin(meet[i][j-1],meet[i][j]);\n    }\n    F0Rd(i,sz(A[0])) FOR(j,i+1,sz(A[0])) {\n        tot[i][j] += tot[i+1][j]+tot[i][j-1];\n        if (i+2 <= j) tot[i][j] -= tot[i+1][j-1];\n    }\n    // ps(meet[0][0],meet[0][1],meet[1][1]);\n    cum[m] = 0; F0R(j,sz(A[0])) ri[m][j] = le[m][j] = 0;\n    FOR(i,m+1,sz(A)) {\n        cum[i] = cum[i-1];\n        F0R(j,sz(A[0])) ri[i][j] = le[i][j] = 0;\n        F0R(j,sz(A[0])) if (lo[i][j] != MOD) {\n            cum[i] += A[i][j]-'0';\n            if (hi[i][j]+1 < sz(A[0])) ri[i][hi[i][j]+1] += A[i][j]-'0';\n            if (lo[i][j]-1 >= 0) le[i][lo[i][j]-1] += A[i][j]-'0';\n        }\n        FOR(j,1,sz(A[0])) ri[i][j] += ri[i][j-1];\n        F0Rd(j,sz(A[0])-1) le[i][j] += le[i][j+1];\n        // ps(\"WUT\",i,ri[i][3], le[i][0]);\n        F0R(j,sz(A[0])) {\n            ri[i][j] += ri[i-1][j];\n            le[i][j] += le[i-1][j];\n        }\n    }\n    /*ps(reach(0), reach(1), bothReach(0,1,1), bothReach(0,1,2), bothReach(0,1,0));\n    exit(0);*/\n    /*FOR(i,m+1,sz(A)) F0R(j,sz(A[0])) {\n        ps(i,j,bot[i][j],lo[i][j],hi[i][j]);\n    }*/\n    //ps(bothReach(0,0,MOD)); exit(0);\n    //ps(reach(0),reach(2),reach(3),bot[2][0],bot[2][2],bot[2][3]); exit(0);\n    //ps(bothReach(0,2,3),bothReach(0,2,2),bothReach(0,3,3), bothReach(2,3,2)); exit(0);\n}\n\nint MN[1500][1500], MX[1500][1500], HI[1500][1500];\n\nvoid initHi(const vector<string>& A) {\n    F0Rd(i,m+1) F0Rd(j,sz(A[0])) {\n        MN[i][j] = MOD, MX[i][j] = -MOD;\n        if (A[i][j] == '#') continue;\n        if (i == m) MN[i][j] = MX[i][j] = j;\n        if (i+1 <= m) ckmin(MN[i][j],MN[i+1][j]), ckmax(MX[i][j],MX[i+1][j]);\n        if (j+1 < sz(A[0])) ckmin(MN[i][j],MN[i][j+1]), ckmax(MX[i][j],MX[i][j+1]);\n    }\n    // ps(MN[0][0],MX[0][0],MN[0][1],MX[0][1]); exit(0);\n    F0R(i,m+1) F0R(j,sz(A[0])) {\n        HI[i][j] = MOD; if (A[i][j] == '#') continue;\n        HI[i][j] = i;\n        if (i) ckmin(HI[i][j],HI[i-1][j]);\n        if (j) ckmin(HI[i][j],HI[i][j-1]);\n    }\n    // ps(HI[0][0],HI[0][1]);\n}\n\nll cur;\ndeque<array<int,3>> yes; // pos, low point, cans\nint dumb[1500];\nvi ins;\n\nvector<string> _A;\n\nvoid ad(int x) {\n    if (lo[m+1][x] == MOD) return;\n    ins.pb(x);\n    array<int,3> tmp = {x,bot[m+1][x],reach(x)}; cur += tmp[2];\n    int lst = 0;\n    while (sz(yes)) {\n        int t = bothReach(yes.back()[0],tmp[0],MOD)-bothReach(yes.back()[0],tmp[0],lst);\n        /*if (sz(_A) == 9) {\n            ps(\"HUH\",yes.back()[0],tmp[0],lst,bothReach(yes.back()[0],tmp[0],MOD),bothReach(yes.back()[0],tmp[0],lst));\n        }*/\n        cur -= t; yes.back()[2] -= t; lst = yes.back()[1];\n        if (yes.back()[1] <= tmp[1]) {\n            assert(yes.back()[2] >= 0);\n            dumb[yes.back()[0]] = yes.back()[2], yes.pop_back();\n        } else break;\n    }\n    yes.pb(tmp);\n    // if (sz(_A) == 9) ps(\"HA\",tmp);\n}\n\nvoid del(int x) {\n    if (lo[m+1][x] == MOD) return;\n    if (sz(yes) && yes.front()[0] == x) {\n        assert(dumb[x] == -1);\n        cur -= yes.front()[2]; yes.pop_front();\n        return;\n    } else {\n        if (dumb[x] == -1) {\n            ps(\"HA\",x,ins);\n            trav(t,yes) ps(t);\n            exit(0);\n        }\n        cur -= dumb[x];\n    }\n}\n\nvoid solve(vector<string> A) {\n    if (sz(A) < sz(A[0])) A = transpose(A);\n    if (sz(A) == 1) return;\n    _A = A;\n    m = (sz(A)-1)/2;\n    initLo(A); initHi(A);\n    F0R(i,m+1) {\n        int l = 0, r = -1; cur = 0;\n        while (sz(yes)) yes.pop_back();\n        ins.clear();\n        // ps(\"DOING\",i);\n        F0R(j,sz(A[0])) dumb[j] = -1;\n        F0R(j,sz(A[0])) if (MX[i][j] != -MOD) {\n            while (r < MX[i][j]) {\n                r ++; \n                if (HI[m][r] <= i) ad(r);\n            }\n            while (l < MN[i][j]) {\n                if (HI[m][l] <= i) del(l);\n                l ++;\n            }\n            ans += (A[i][j]-'0')*cur;\n        }\n    }\n    auto x = vector<string>(A.begin(),A.begin()+m+1);\n    auto y = vector<string>(A.begin()+m+1,A.end());\n    solve(x); solve(y);\n}\n\nint main() {\n    setIO(); re(N);\n    vector<string> A(N); re(A);\n    solve(A); ps(ans);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1505;\nint b[N][N],S[N],n,u[N][N],l[1<<12|1],r[1<<12|1],flag[N][N];\nchar A[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (register int i=1;i<=n;++i)scanf(\"%s\",A[i]+1);\n\tfor (register int i=1;i<=n;++i)\n\t\tfor (register int j=1;j<=n;++j)flag[i][j]=A[i][j]>='0'&&A[i][j]<='9',b[i][j]=A[i][j]-'0';\n\tfor (register int i=0;i<=n;++i)\n\t\tfor (register int j=0;j<=n;++j)u[i][j]=flag[i][j]?min(i,min(u[i-1][j],u[i][j-1])):1<<30;\n\tlong long ans=0;\n\tfor (register int x=1;x<=n;++x){\n\t\tint t=(x&1)<<11;\n\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=x?b[x][j]:0);\n\t\tfor (register int j=n+1;j;--j){\n\t\t\tif (flag[x][j]){\n\t\t\t\tl[t|j]=j-1;\n\t\t\t\tr[t|j]=max(r[t|(j+1)],j);\n\t\t\t\tans+=b[x][j]*(S[r[t|j]]-S[l[t|j]]-b[x][j]);\n\t\t\t}\n\t\t\telse l[t|j]=1e9,r[t|j]=-1;\n\t\t}\n\t\tfor (register int i=x-1;i;--i){\n\t\t\tint t=(i&1)<<11,t2=((i&1)^1)<<11;\n\t\t\tfor (register int j=1;j<=n;++j)S[j]=S[j-1]+(u[x][j]<=i?b[x][j]:0);\n\t\t\tfor (register int j=n+1;j;--j){\n\t\t\t\tif (flag[i][j]){\n\t\t\t\t\tl[t|j]=min(l[t|(j+1)],l[t2|j]);\n\t\t\t\t\tr[t|j]=max(r[t|(j+1)],r[t2|j]);\n\t\t\t\t\tif (l[t|j]<=r[t|j])ans+=b[i][j]*(S[r[t|j]]-S[l[t|j]]);\n\t\t\t\t}\n\t\t\t\telse l[t|j]=1e9,r[t|j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    while(wek.size() < (v/d)+2) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trepn(x,9) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+1);\n\t\t\t\tif(x){\n\t\t\t\t    B[f[x][y]-'0'][x].upper(max(cur[f[x][y]-'0']+1,(int)(B[f[x][y]-'0'][x-1].wek.size())));\n\t\t\t\t    repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\t}\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].w) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"w\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *a, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; a[++n] = c, c = gc());\n\t\ta[n+1] = '\\0';\n\t}\n\tinline void rds(string &a) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (a.clear(); c >= 33 && c <= 126; a.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(a[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string a) {\n\t\tint n = a.length();\n\t\twhile (t < n) pc(a[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 1.5e3 + 7;\nint n, s[N][N], p[N][N], l[2][N][N], r[2][N][N];\nchar a[N][N];\nll ans;\n\nint main() {\n\trd(n);\n\tfor (int i = 1; i <= n; i++) rds(a[i], n);\n\tfor (int i = n, o = 0; i; i--, o ^= 1)\n\t\tfor (int j = n; j > 0; j--)\n\t\t\tif (a[i][j] != '#') {\n\t\t\t\ta[i][j] -= '0';\n\t\t\t\ts[i][j] = s[i][j+1] + s[i+1][j] + a[i][j];\n\t\t\t\tp[i][j] = max(max(p[i][j+1], p[i+1][j]), i);\n\t\t\t\tl[o][j][i] = j;\n\t\t\t\tfor (int k = i + 1; k <= p[i+1][j]; k++)\n\t\t\t\t\tl[o][j][k] = l[o^1][j][k];\n\t\t\t\tfor (int k = max(p[i+1][j], i) + 1; k <= p[i][j+1]; k++)\n\t\t\t\t\tl[o][j][k] = l[o][j+1][k];\n\t\t\t\tr[o][j][i] = j;\n\t\t\t\tfor (int k = i; k <= p[i][j+1]; k++)\n\t\t\t\t\tr[o][j][k] = r[o][j+1][k];\n\t\t\t\tfor (int k = max(p[i][j+1], i) + 1; k <= p[i+1][j]; k++)\n\t\t\t\t\tr[o][j][k] = r[o^1][j][k];\n\t\t\t\tfor (int k = i + 1; k <= min(p[i][j+1], p[i+1][j]); k++)\n\t\t\t\t\tif (r[o^1][j][k] >= l[o][j+1][k])\n\t\t\t\t\t\ts[i][j] -= s[k][l[o][j+1][k]],\n\t\t\t\t\t\tk = p[k][l[o][j+1][k]];\n\t\t\t\tans += 1ll * a[i][j] * (s[i][j] - a[i][j]);\n\t\t\t}\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=1505;\nint n,cnt[N];\nint a[N][N],S[N][N];\nint L[N][N],R[N][N];\nchar s[N];\nll ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%s\",s+1);\n\t\tFor(j,1,n) a[i][j]=(s[j]=='#'?0:s[j]-'0');\n\t\tFor(j,1,n) S[i][j]=S[i][j-1]+a[i][j];\n\t}\n\tFor(i,1,n) Rep(j,n+1,1)\n\t\tif (!a[i][j]) L[i][j]=n+1,R[i][j]=0;\n\t\telse{\n\t\t\tL[i][j]=j;\n\t\t\tR[i][j]=max(R[i][j+1],j);\n\t\t\tans+=a[i][j]*(S[i][R[i][j]]-S[i][j]); \n\t\t}\n\tRep(x,n,1) For(y,x+1,n){\n\t\tRep(j,n,1)\n\t\t\tif (a[x][j]){\n\t\t\t\tL[y][j]=min(L[y][j],L[y][j+1]);\n\t\t\t\tR[y][j]=max(R[y][j],R[y][j+1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tL[y][j]=n+1;\n\t\t\t\tR[y][j]=0;\n\t\t\t}\n\t\tFor(j,1,n) cnt[j]=0;\n\t\tFor(j,1,n)\n\t\t\tif (L[y][j]<=R[y][j]){\n\t\t\t\tans+=a[x][j]*(S[y][R[y][j]]-S[y][L[y][j]-1]);\n\t\t\t\t++cnt[L[y][j]];\n\t\t\t\t--cnt[R[y][j]+1];\n\t\t\t}\n\t\tFor(j,1,n){\n\t\t\tcnt[j]+=cnt[j-1];\n\t\t\tif (!cnt[j])\n\t\t\t\ta[y][j]=0;\n\t\t}\n\t\tFor(j,1,n)\n\t\t\tS[y][j]=S[y][j-1]+a[y][j];\n\t}\n\tprintf(\"%lld\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<utility>\n#include<string.h>\n\nusing namespace std;\n\nint graph[505][505];\nint visited[505][505];\nqueue<pair<int,int > > q;\nint n;\n\nint bfs(int a, int b)\n{\n\tmemset(visited,0,sizeof(visited));\n\tif(graph[a][b]==-1) return 0;\n\tint ans = 0;\n\tq.push(make_pair(a,b));\n\twhile(!q.empty())\n\t{\n\t\tint x = q.front().first; int y = q.front().second; q.pop(); \n\t\tint da[2] = {1,0};\n\t\tint db[2] = {0,1};\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tint na = x+da[i]; int nb = y+db[i];\n\t\t\tif(visited[na][nb]==1) continue;\n\t\t\tif(na>=n || nb>=n) continue;\n\t\t\tif(graph[na][nb]==-1) continue;\n\t\t\tans+=graph[a][b]*graph[na][nb]; visited[na][nb]=1;\n\t\t\tq.push(make_pair(na,nb));\n\t\t}\t\t\n\t}\n\treturn ans;\t\n}\n\nint main(void)\n{\n\tscanf(\"%d\",&n); getchar();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tchar c = getchar();\n\t\t\tif(c=='#') graph[i][j]=-1;\n\t\t\telse graph[i][j] = c-'0';\n\t\t}\n\t\tgetchar();\n\t}\n\tint ans = 0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tans += bfs(i,j);\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]>r[k][j+1]) break;\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]],las_r=r[k][j];\n\t\t\t\t\tif(l[k][j]>r[k][j]) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\telse l[i][j]=n+1,r[i][j]=0;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n;\n  long ret=0;\n  cin >> n;\n  vector<vector<char>>grid(n, vector<char>(n));\n  for(int i=0; i<n; i++)for(int j=0; j<n; j++){\n    cin >> grid[i][j];\n  }\n  for(int sx=0; sx<n; sx++)for(int sy=0; sy<n; sy++){\n    vector<vector<bool>>chk(n, vector<bool>(n, false));\n    if(grid[sx][sy]=='#')continue;\n    pair<int, int>s=make_pair(sx, sy);\n    queue<pair<int, int>>bfs;\n    bfs.push(s);\n    while(!bfs.empty()){\n      pair<int, int>p = bfs.front();\n      bfs.pop();\n      int px=p.first, py=p.second;\n      if(chk[px][py])continue;\n      chk[px][py] = true;\n      ret += (grid[sx][sy]-'0')*(grid[px][py]-'0');\n      if(px+1<n && grid[px+1][py]!='#'){\n        bfs.push(make_pair(px+1, py));\n      }\n      if(py+1<n && grid[px][py+1]!='#'){\n        bfs.push(make_pair(px, py+1));\n      }\n    }\n    ret -= (grid[sx][sy]-'0')*(grid[sx][sy]-'0');\n  }\n  cout << ret;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1505, inf = 0x3f3f3f3f;\nint n,l[N][N],r[N][N],dfn[N][N],pos[N][N];char s[N][N];\nll f[N][N],res;\nint main() {\n\tmemset(s,'#',sizeof(s));read(n);rep(i,1,n)scanf(\"%s\",s[i]+1);\n\tmemset(l,inf,sizeof(l));\n\tper(i,n,1){\n\t\trep(j,1,n){\n\t\t\tif(s[i][j]!='#')l[i][j]=r[i][j]=j;else l[i][j]=inf,r[i][j]=0;\n\t\t\tl[i+1][j]=inf,r[i+1][j]=0;\n\t\t}\n\t\tper(j,i,1)per(k,n,1)\n\t\tif(s[j][k]=='#')l[j][k]=inf,r[j][k]=0;\n\t\telse{\n\t\t\tif(j<i){r[j][k]=max(r[j][k+1],r[j+1][k]);l[j][k]=min(l[j][k+1],l[j+1][k]);}\n\t\t\telse{umax(r[j][k],r[j][k+1]);umin(l[j][k],l[j][k+1]);}\n\t\t//\tif(s[j][k]!='#'&&s[j][k+1]!='#'&&s[j+1][k]!='#'){\n\t\t\t\tif(dfn[j][k]==i+1&&r[j+1][k]<pos[j][k])f[j][k]-=f[i+1][pos[j][k]];\n\t\t\t\tif(r[j+1][k]>=l[j][k+1])dfn[j][k]=i,pos[j][k]=l[j][k+1];\n\t\t//\t}\n\t\t\t//printf(\"%d %d -- %d %d\\n\",j,k,l[j][k],r[j][k]);\n\t\t}\n\t\tper(j,n,1)if(s[i][j]!='#'){\n\t\t//\tprintf(\"%d %d:%lld %lld\\n\",i,j,f[i][j],f[i+1][j]+f[i][j+1]+f[i][j]);\n\t\t\tf[i][j]+=f[i+1][j]+f[i][j+1];ll c=s[i][j]-'0';\n\t\t\tres+=c*f[i][j];f[i][j]+=c;\n\t\t}\n\t}\n\tcout<<res;return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nchar f[505][505];\nbitset<500*500*9+5>B[2][505];\nll ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\tint cur = 0,nxt = 1;\n\tfor(int i=0;i<2*n-1;i++){\n\t\trep(i,n) B[nxt][i].reset();\n\t\tfor(int j=max(0,i-n+1);j<=min(i,n-1);j++){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t\tif(y) B[nxt][x] |= B[cur][x];\n\t\t\t\tif(x) B[nxt][x] |= B[cur][x-1];\n\t\t\t\tans += 1LL*(f[x][y]-'0')*(B[nxt][x].count());\n\t\t\t\trep(a,f[x][y]-'0') B[nxt][x][9*(x*n+y)+a] = 1;\n\t\t\t}\n\t\t}\n\t\tswap(cur,nxt);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// }}}\n// #include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n/*\n\n   checklist\n   - min vs max\n   - ymin + 1\n   - for range\n\n */\n\n// O(N^2 log N)\n// 想定解法と同じ\n\ntemplate<class T, class U> inline void smin(T &a, const U &b) { a = a < (T) b ? a : b; }\ntemplate<class T, class U> inline void smax(T &a, const U &b) { a = a < (T) b ? b : a; }\n\nconst int N = 1501;\nstring s[N]; // y, x\nint maxX[N][N], maxY[N][N];\nint minX[N][N], minY[N][N];\nconst int inf = 1e9;\n// 9 * N * N < inf\n// ans max = O(9 * 9 * N^4)\n\nint get(int y, int x, int f) {\n  if(f) swap(y, x);\n  return s[y][x];\n}\n\nint getMinX(int y, int x, int f) {\n  if(f) swap(y, x);\n  return f ? minY[y][x] : minX[y][x];\n}\nint getMinY(int y, int x, int f) {\n  if(f) swap(y, x);\n  return f ? minX[y][x] : minY[y][x];\n}\nint getMaxX(int y, int x, int f) {\n  if(f) swap(y, x);\n  return f ? maxY[y][x] : maxX[y][x];\n}\nint getMaxY(int y, int x, int f) {\n  if(f) swap(y, x);\n  return f ? maxX[y][x] : maxY[y][x];\n}\n\ntemplate<class T, class U = ll>\nU range2D(T &val, int y1, int x1, int y2, int x2, int h, int w) {\n  if(y1 < 0) y1 = 0;\n  if(x1 < 0) x1 = 0;\n  if(y2 >= h) y2 = h - 1;\n  if(x2 >= w) x2 = w - 1;\n  if(y1 > y2 || x1 > x2) return U(0);\n  U res = val[y2][x2];\n  if(y1-1 >= 0) res -= val[y1-1][x2];\n  if(x1-1 >= 0) res -= val[y2][x1-1];\n  if(y1-1 >= 0 && x1-1 >= 0) res += val[y1-1][x1-1];\n  return res;\n}\n\ntemplate<class T>\nvoid accum2D(T &val, int h, int w) {\n  for(int i = 1; i < h; i++) for(int j = 0; j < w; j++) val[i][j] += val[i-1][j];\n  for(int i = 0; i < h; i++) for(int j = 1; j < w; j++) val[i][j] += val[i][j-1];\n}\n\n// DAQ\nll solve(int y1, int x1, int y2, int x2, int f = 0) {\n  int h = y2 - y1 + 1;\n  int w = x2 - x1 + 1;\n\n  // 自明 {{{\n  if(h == 1 || w == 1) {\n    if(h == 1) {\n      int noe = 0;\n      ll res = 0;\n      for(int x = x1; x <= x2; x++) {\n        int eca = get(y1, x, f);\n        if(eca) {\n          res += (ll) eca * noe;\n          noe += eca;\n        } else noe = 0;\n      }\n      return res;\n    } else {\n      return solve(x1, y1, x2, y2, !f);\n    }\n  }\n  // }}}\n\n  // 上下に分けたものについてのみ解く\n  // w <= h\n\n  int ymid = (y1 + y2) >> 1;\n  // ymid自体は上側\n\n  ll res = 0;\n  // 上のほうが大きい\n  // 渡すときにswapする\n  res += solve(x1, y1, x2, ymid, !f);\n  res += solve(x1, ymid + 1, x2, y2, !f);\n  int h0 = ymid - y1 + 1;\n  int h1 = h - h0;\n\n  // ローカルな関数 {{{\n\n  vector<vector<int>> minMeet(w, vector<int>(w, inf)); // y座標の最小値\n  vector<vector<int>> L(h1, vector<int>(w, inf));\n  vector<vector<int>> R(h1, vector<int>(w, -inf));\n\n  vector<vector<int>> sumByYL(h1, vector<int>(w, 0));\n  vector<vector<int>> sumByYR(h1, vector<int>(w, 0));\n  vector<vector<int>> sumByLR(w, vector<int>(w, 0));\n\n  vector<int> validSum(h1);\n\n  auto getMinMax = [&](int a, int b) {\n    return min(getMaxY(ymid + 1, x1 + a, f), getMaxY(ymid + 1, x1 + b, f));\n  };\n\n  auto getBothReachable = [&](int a, int b, int l) {\n    smin(l, getMinMax(a, b) - (ymid + 1)); // これは必要で，サンプルケース4がhack\n    if(minMeet[a][b] > l) return 0;\n    int res = validSum[l];\n    res -= range2D(sumByYL, 0, a + 1, l, w - 1, h1, w);\n    res -= range2D(sumByYR, 0, 0, l, b - 1, h1, w);\n    res += range2D(sumByLR, a + 1, 0, w - 1, b - 1, w, w);\n    return res;\n  };\n\n  // }}}\n  \n  // 前計算1 {{{\n\n  for(int j = 0; j < w; j++) {\n    if(get(ymid + 1, x1 + j, f)) {\n      L[0][j] = j;\n      R[0][j] = j;\n    }\n  }\n  for(int i = 0; i < h1; i++) {\n    for(int j = 0; j < w; j++) {\n      if(get(ymid + 1 + i, x1 + j, f)) {\n        if(i) smin(L[i][j], L[i-1][j]);\n        if(j) smin(L[i][j], L[i][j-1]);\n        if(i) smax(R[i][j], R[i-1][j]);\n        if(j) smax(R[i][j], R[i][j-1]);\n        // 値が決定\n        if(L[i][j] <= R[i][j]) {\n          smin(minMeet[L[i][j]][R[i][j]], i);\n        }\n      }\n    }\n  }\n\n  // 累積min\n  for(int i = 0; i < w; i++) for(int j = w - 2; j >= 0; j--) smin(minMeet[i][j], minMeet[i][j+1]);\n  for(int i = 1; i < w; i++) for(int j = w - 1; j >= 0; j--) smin(minMeet[i][j], minMeet[i-1][j]);\n\n  for(int i = 0; i < w; i++) for(int j = w - 1; j >= 0; j--) {\n    if(getMinMax(i, j) < minMeet[i][j]) {\n      minMeet[i][j] = inf;\n    }\n  }\n  \n  // }}}\n\n  // 前計算2 {{{\n\n  for(int i = 0; i < h1; i++) for(int j = 0; j < w; j++) {\n    if(L[i][j] <= R[i][j]) {\n      int ecas = get(ymid + 1 + i, x1 + j, f); // != 0\n      sumByYL[i][L[i][j]] += ecas;\n      sumByYR[i][R[i][j]] += ecas;\n      sumByLR[L[i][j]][R[i][j]] += ecas;\n      validSum[i] += ecas;\n    }\n  }\n\n  for(int i = 1; i < h1; i++) validSum[i] += validSum[i-1];\n\n  accum2D(sumByYL, h1, w);\n  accum2D(sumByYR, h1, w);\n  accum2D(sumByLR, w, w);\n\n  // }}}\n\n  vector<vector<int>> UL(h0, vector<int>(w, inf));\n  vector<vector<int>> UR(h0, vector<int>(w, -inf));\n\n  // 前計算3 {{{\n\n  for(int j = 0; j < w; j++) {\n    if(get(ymid, x1 + j, f)) {\n      UL[h0 - 1][j] = j;\n      UR[h0 - 1][j] = j;\n    }\n  }\n\n  for(int i = h0 - 1; i >= 0; i--) for(int j = w - 1; j >= 0; j--) {\n    if(get(y1 + i, x1 + j, f)) {\n      if(i+1 < h0) smin(UL[i][j], UL[i+1][j]);\n      if(j+1 < w) smin(UL[i][j], UL[i][j+1]);\n      if(i+1 < h0) smax(UR[i][j], UR[i+1][j]);\n      if(j+1 < w) smax(UR[i][j], UR[i][j+1]);\n    }\n  }\n\n  // }}}\n\n\n  vector<int> qina(w); // i+1からは取れないが，iからは取れるものの sum\n  for(int i = 0; i < h0; i++) {\n    int l = 0, r = 0; // [l, r)\n    int sum = 0;\n    stack<pair<int, int>> tapris; // index, height\n    for(int j = 0; j < w; j++) if(UL[i][j] <= UR[i][j]) {\n      // U(y1+i, x1+j) は必ず D(0, _) のどこかにたどり着く\n      // add\n      for(;r < w && r <= UR[i][j]; r++) {\n        if(getMinY(ymid, x1 + r, f) > y1 + i) {\n          // 無効値．D(0, x1 + r) は U(y1+i, _) にたどり着かない\n          qina[r] = 0;\n          continue;\n        }\n        qina[r] = getBothReachable(r, r, h1 - 1);\n        assert(qina[r] >= 0);\n        sum += qina[r];\n        int hei = min(getMaxY(ymid + 1, x1 + r, f) - (ymid + 1), h1 - 1);\n        int last = -1;\n        auto f = [&]() {\n          int idx, k;\n          tie(idx, k) = tapris.top();\n          if(qina[idx] == -1) return; // 削除済みの値\n          sum -= qina[idx];\n          qina[idx] -= getBothReachable(idx, r, h1 - 1) - (last == -1 ? 0 : getBothReachable(idx, r, last));\n          // assert(qina[idx] >= 0);\n          sum += qina[idx];\n          last = k;\n        };\n        while(tapris.size() && tapris.top().second <= hei) {\n          f();\n          tapris.pop();\n        }\n        if(tapris.size()) {\n          f();\n        }\n        tapris.emplace(r, hei);\n      }\n      // rem\n      while(l < w && l < UL[i][j]) {\n        sum -= qina[l];\n        qina[l] = -1;\n        l++;\n      }\n      //\n      res += (ll) sum * get(y1 + i, x1 + j, f);\n    }\n  }\n\n  // if(f) swap(y1, x1), swap(y2, x2);\n  return res;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  int n; cin >> n;\n  for(int i = 0; i < n; i++) {\n    cin >> s[i];\n    for(char &c : s[i]) c = c == '#' ? 0 : c - '0';\n  }\n\n  // グローバルな前計算 {{{\n  // maxX\n  for(int i = n - 1; i >= 0; i--) for(int j = n - 1; j >= 0; j--) {\n    if(s[i][j]) {\n      maxX[i][j] = j;\n      if(i + 1 < n) smax(maxX[i][j], maxX[i + 1][j]);\n      if(j + 1 < n) smax(maxX[i][j], maxX[i][j + 1]);\n    } else maxX[i][j] = -inf;\n  }\n  // maxY\n  for(int i = n - 1; i >= 0; i--) for(int j = n - 1; j >= 0; j--) {\n    if(s[j][i]) {\n      maxY[j][i] = j;\n      if(i + 1 < n) smax(maxY[j][i], maxY[j][i + 1]);\n      if(j + 1 < n) smax(maxY[j][i], maxY[j + 1][i]);\n    } else maxY[j][i] = -inf;\n  }\n  // minX\n  for(int i = 1; i < n; i++) for(int j = 1; j < n; j++) {\n    if(s[i][j]) {\n      minX[i][j] = j;\n      if(i - 1 >= 0) smin(minX[i][j], minX[i - 1][j]);\n      if(j - 1 >= 0) smin(minX[i][j], minX[i][j - 1]);\n    } else minX[i][j] = inf;\n  }\n  // minY\n  for(int i = 1; i < n; i++) for(int j = 1; j < n; j++) {\n    if(s[j][i]) {\n      minY[j][i] = j;\n      if(i - 1 >= 0) smin(minY[j][i], minY[j][i - 1]);\n      if(j - 1 >= 0) smin(minY[j][i], minY[j - 1][i]);\n    } else minY[j][i] = inf;\n  }\n  // }}}\n\n  cout << solve(0, 0, n - 1, n - 1) << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct bity\n{\n\t#define d 63\n\tvector<ll> wek;\n\tbity(){}\n\tbity(int v)\n\t{\n\t\twek.resize((v/d)+2, 0);\n\t}\n\tvoid upper(int v)\n\t{\n\t    while(wek.size() < (v/d)+2) wek.pb(0);\n\t}\n\tvoid upp(int v){\n\t    while(wek.size() < v) wek.pb(0);\n\t}\n\tvoid ustaw(int v)\n\t{\n\t\twek[v/d]|=(1LL<<(v%d));\n\t}\n\tvoid zeruj()\n\t{\n\t\tfill(wek.begin(), wek.end(), 0);\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (const ll &i : wek)\n\t\t\tret+=__builtin_popcountll(i);\n\t\treturn ret;\n\t}\n};\n \nvoid oruj(bity &a, const bity &b)\n{\n\tint r=min(a.wek.size(), b.wek.size());\n\tfor (int i=0; i<r; i++)\n\t\ta.wek[i]|=b.wek[i];\n}\n\nint n;\nchar f[505][505];\nbity B[10][505];\nll ans;\nint C[10];\nint cur[10];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%s\",&f[i]);\n\trep(i,n)rep(j,n)if(f[i][j]!='#')C[f[i][j]-'0']++;\n\trepn(x,9) rep(i,n) B[x][i] = bity(0);\n\tfor(int i=0;i<2*n-1;i++){\n\t\tfor(int j=min(i,n-1);j>=max(0,i-n+1);j--){\n\t\t\tint x = j, y = i-j;\n\t\t\tif(f[x][y] != '#'){\n\t\t\t    B[f[x][y]-'0'][x].upper(cur[f[x][y]-'0']+1);\n\t\t\t    repn(w,9) B[w][x].upp(B[w][x-1].wek.size());\n\t\t\t\tif(x){\n\t\t\t\t    repn(w,9) oruj(B[w][x],B[w][x-1]);\n\t\t\t\t}\n\t\t\t\trepn(w,9) ans += 1LL*w*(f[x][y]-'0')*(B[w][x].licz());\n\t\t\t\tB[f[x][y]-'0'][x].ustaw(cur[f[x][y]-'0']++);\n\t\t\t}\n\t\t\telse{\n\t\t\t    repn(w,9) B[w][x].upp(B[w][x-1].wek.size());\n\t\t\t\trepn(w,9) B[w][x].zeruj();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nint n,c=0,T=0;\nchar a[505][505];\npii u[2][505][505];\ninline pii operator + (pii a,pii b)\n{return pii(min(a.fi,b.fi),max(a.se,b.se));}\nint vis[505][505];\nvoid dfs(int x,int y)\n{\n\tif(vis[x][y]==T||!isdigit(a[x][y]))\n\t\treturn;\n\tvis[x][y]=T; dfs(x,y+1); dfs(x+1,y);\n}\nll su[505][505];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tll aa=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%s\",a[i]+1);\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(isdigit(a[i][j]))\n\t\t\t{\n\t\t\t\tint u=a[i][j]-'0';\n\t\t\t\taa-=u*u;\n\t\t\t}\n\t\t}\n\t}\n\tpii GG(2e9,-2e9);\n\tfor(int i=0;i<=n+1;++i)\n\tfor(int j=0;j<=n+1;++j)\n\t\tu[0][i][j]=u[1][j][i]=GG;\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tT=i; c^=1;\n\t\tfor(int j=1;j<=n;++j) dfs(i,j);\n\t\tfor(int k=i;k<=n;++k)\n\t\t\tfor(int w=1;w<=n;++w)\n\t\t\t\tif(vis[k][w]==T)\n\t\t\t\t\tsu[k][w]=su[k][w-1]+a[k][w]-'0';\n\t\t\t\telse su[k][w]=su[k][w-1];\n\t\tfor(int j=n;j>=1;--j)\n\t\t{\n\t\t\tpii*ucj=u[c][j],*ucp=u[c][j+1],*rcj=u[c^1][j];\n\t\t\tif(!isdigit(a[i][j]))\n\t\t\t{\n\t\t\t\tfor(int k=i;k<=n;++k)\n\t\t\t\t\tucj[k]=GG;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tucj[i]=pii(j,j)+ucp[i];\n\t\t\tll ap=0;\n\t\t\tif(ucj[i].fi<=ucj[i].se)\n\t\t\t\tap+=su[i][ucj[i].se]-su[i][ucj[i].fi-1];\n\t\t\tfor(int k=i+1;k<=n;++k)\n\t\t\t{\n\t\t\t\tucj[k]=rcj[k]+ucp[k];\n\t\t\t\tif(ucj[k].fi<=ucj[k].se)\n\t\t\t\tap+=su[k][ucj[k].se]-su[k][ucj[k].fi-1];\n\t\t\t}\n\t\t\taa+=ap*(a[i][j]-'0');\n\t\t}\n\t}\n\tcout<<aa<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n\n#define M 2005\nint n;\nchar s[M];\nint a[M][M],f[M][M],l[M][M],r[M][M];\n\nint main () {\n//freopen(\"a.in\",\"r\",stdin);\n//freopen(\"zj.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) {\n\t\tscanf(\"%s\",s+1);\n\t\tfor1(1,n,j) a[i][j]= s[j]=='#'?0:s[j]-'0';\n\t}\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) { \n\t\tif(a[i][j]) {\n\t\t\tbool t[2]={a[i+1][j],a[i][j+1]};\n\t\t\tif(!(t[0]|t[1])) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tfor1(i+1,n,k) l[k][j]=n+1,r[k][j]=0;\n\t\t\t}\n\t\t\telse if(t[0]&&!t[1]) {\n\t\t\t\tl[i][j]=r[i][j]=j;\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t}\n\t\t\telse if(!t[0]&&t[1]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\tfor1(i+1,n,k) l[k][j]=l[k][j+1],r[k][j]=r[k][j+1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[i][j]=j,r[i][j]=r[i][j+1];\n\t\t\t\t\n\t\t\t\tint las_r=0;\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[k][j+1]>r[k][j+1]) break;\n\t\t\t\t\tif(l[k][j+1]<=r[k][j]&&l[k][j+1]>las_r) tot-=f[k][l[k][j+1]];\n\t\t\t\t\tlas_r=r[k][j];\n\t\t\t\t\tl[k][j]=min(l[k][j],l[k][j+1]);\n\t\t\t\t\tr[k][j]=max(r[k][j],r[k][j+1]);\n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t}\n\t\telse l[i][j]=n+1,r[i][j]=0;\n\t\tans+=a[i][j]*f[i][j];\n\t\tf[i][j]+=a[i][j];\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\tinline int tc()\n\t{\n\t\tint c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\treturn c;\n\t}\n}\nusing ae86::ty;\nusing ae86::tc;\n\nconst int _ = 1503 , inf = 0x3f3f3f3f;\n\nint n,val[_][_],sv[_][_]={0},xl[_][_],xr[_][_];\n\nint main()\n{\n\tn=ty();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tval[i][j]=tc();\n\t\t\tif(!isdigit(val[i][j]))val[i][j]=0;\n\t\t\telse val[i][j]-=48;\n\t\t}\n\n\tlint ans=0;\n\tfor(int i=n;i>=1;i--)\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tif(val[i][j])\n\t\t\t{\n\t\t\t\tif(val[i+1][j] && val[i][j+1])\n\t\t\t\t{\n\t\t\t\t\tint temp=sv[i+1][j]+sv[i][j+1],nowr=0;\n\t\t\t\t\txl[j][i]=j,xr[j][i]=xr[j+1][i];\n\t\t\t\t\tfor(int k=i+1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(xr[j][k]>=xl[j+1][k] && xl[j+1][k]>nowr)temp-=sv[k][xl[j+1][k]];\n\t\t\t\t\t\tnowr=max(nowr,xr[j][k]);\n\t\t\t\t\t\txl[j][k]=min(xl[j][k],xl[j+1][k]),xr[j][k]=max(xr[j][k],xr[j+1][k]);\n\t\t\t\t\t}\n\t\t\t\t\tsv[i][j]=temp;\t\n\t\t\t\t}\n\t\t\t\telse if(val[i+1][j])\n\t\t\t\t{\n\t\t\t\t\txl[j][i]=xr[j][i]=j,sv[i][j]=sv[i+1][j];\n\t\t\t\t}\n\t\t\t\telse if(val[i][j+1])\n\t\t\t\t{\n\t\t\t\t\tfor(int k=i;k<=n;k++)xl[j][k]=xl[j+1][k],xr[j][k]=xr[j+1][k];\n\t\t\t\t\txl[j][i]=j,sv[i][j]=sv[i][j+1];\n\t\t\t\t}\n\t\t\t\telse xl[j][i]=xr[j][i]=j;\n\t\t\t\tans+=1ll*sv[i][j]*val[i][j],sv[i][j]+=val[i][j];\n\t\t\t}\n\t\t\telse for(int k=i;k<=n;k++)xl[j][k]=inf,xr[j][k]=-inf;\n\t\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include <stack>\nusing namespace std;\nint main(){\ncout<<0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1503;\nint n;\nchar s[N][N];\nint dp[N][N];\nint leftmost[2][N][N], upmost[2][N][N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%s\", s[i]);\n\tfor (int i = 0; i <= n; i++)\n\t\ts[n][i] = s[i][n] = '#';\n\tll ans = 0;\n\tfor (int x = n - 1; x >= 0; x--) {\n\t\tfor (int y = n - 1; y >= 0; y--) {\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tleftmost[0][y][k] = upmost[0][y][k] = N;\n\t\t\tif (s[x][y] == '#') continue;\n\t\t\tif (s[x + 1][y] != '#')\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tleftmost[0][y][k] = min(leftmost[0][y][k], leftmost[1][y][k]);\n\t\t\t\t\tupmost[0][y][k] = min(upmost[0][y][k], upmost[1][y][k]);\n\t\t\t\t}\n\t\t\tif (s[x][y + 1] != '#')\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tleftmost[0][y][k] = min(leftmost[0][y][k], leftmost[0][y + 1][k]);\n\t\t\t\t\tupmost[0][y][k] = min(upmost[0][y][k], upmost[0][y + 1][k]);\n\t\t\t\t}\n\t\t\tleftmost[0][y][x] = y;\n\t\t\tupmost[0][y][y] = x;\n\t\t\t\n\t\t\t//eprintf(\"cell = %d %d\\n\", x, y);\n\t\t\t/*\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\teprintf(\"%d \", leftmost[0][y][k]);\n\t\t\teprintf(\"\\n\");\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\teprintf(\"%d \", upmost[0][y][k]);\n\t\t\teprintf(\"\\n\");\n\t\t\t*/\n\t\t\tdp[x][y] = dp[x + 1][y] + dp[x][y + 1];\n\t\t\tif (x != n - 1 && y != n - 1) {\n\t\t\t\tfor (int xx = x + 1; xx < n; xx++) {\n\t\t\t\t\tint yy = leftmost[0][y + 1][xx];\n\t\t\t\t\t//eprintf(\"!!! %d %d\\n\", xx, yy);\n\t\t\t\t\tif (upmost[1][y][yy] == xx)\n\t\t\t\t\t\tdp[x][y] -= dp[xx][yy];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = (int)(s[x][y] - '0');\n\t\t\tans += c * dp[x][y];\n\t\t\tdp[x][y] += c;\n\t\t}\n\t\tfor (int y = 0; y < n; y++)\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tleftmost[1][y][k] = leftmost[0][y][k];\n\t\t\t\tupmost[1][y][k] = upmost[0][y][k];\n\t\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tprintf(\"%d \", dp[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4.1\")\n\n#ifdef LOCAL\n//#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for (int i = ((int)(n) - 1); i >= 0; --i)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr);\n#else\n#define eprintf(args...) ;\n#endif\n\nconst int mod = (int)1e9 + 7;\n\nvoid add (int &a, int b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\n\nvoid sub (int &a, int b)\n{\n    a -= b;\n    if (a < 0)\n        a += mod;\n}\n\nint mult (int a, int b)\n{\n    return (ll)a * b % mod;\n}\n\nint n;\nvector<string> grid;\n\n#ifdef LOCAL\n//#define TEST\n#endif // LOCAL\n\n#ifndef TEST\nbool read ()\n{\n    if (!(cin >> n))\n        return false;\n\n    grid.resize(n);\n    forn (i, n)\n        cin >> grid[i];\n\n    return true;\n}\n#else\nbool read ()\n{\n    n = 500;\n    static mt19937 rng;\n\n    grid = vector<string>(n, string(n, '#'));\n    forn (i, n) forn (j, n)\n        grid[i][j] = rng() % 9 + '1';\n\n    return true;\n}\n#endif\n\nusing ull = unsigned long long;\nconst int bits = 64;\n\nconst int K = (1 << 16) - 1;\nint prec[K + 1];\n\nint popcnt (ull v)\n{\n    return prec[v & K] + prec[(v >> 16) & K] + prec[(v >> 32) & K] + prec[(v >> 48) & K];\n}\n\nstruct bitarr\n{\n    vector<ull> v;\n    int n;\n\n    bitarr () {}\n\n    bitarr (int len)\n    {\n        v.resize((len + bits) / bits);\n        n = len;\n    }\n\n    int last () const\n    {\n        return int(v.back());\n    }\n\n    void or_with (const bitarr &o, const int bound)\n    {\n        assert(n == o.n);\n        assert(sz(v) == sz(o.v));\n\n        const int start = (bound >> 6);\n        for (int i = start; i < sz(v); i++)\n            v[i] |= o.v[i];\n    }\n\n    void reset ()\n    {\n        fill(all(v), ull(0));\n    }\n\n    void set (int pos)\n    {\n        v[pos >> 6] |= (1ULL << (pos & 63));\n    }\n\n    int bitcount () const\n    {\n        int ans = 0;\n        forn (i, sz(v))\n            ans += popcnt(v[i]);\n        return ans;\n    }\n};\n\nconst int inf = int(1e9);\n\nll solve ()\n{\n    forn (i, K + 1)\n        prec[i] = __builtin_popcount(i);\n\n    const int digs = 9;\n\n    vi cnt (digs);\n    vvi id (n, vi(n, -1));\n\n    forn (i, n) forn (j, n)\n    {\n        const int cur = grid[i][j] - '1';\n        if (0 <= cur && cur < digs)\n        {\n            id[i][j] = cnt[cur];\n            cnt[cur]++;\n        }\n    }\n\n    vector<vector<vector<bitarr>>> dp (2, vector<vector<bitarr>>(n, vector<bitarr>(digs)));\n    forn (c, 2) forn (i, n) forn (j, digs)\n        dp[c][i][j] = bitarr(cnt[j]);\n\n    int cur = 0;\n\n    auto in = [&] (int x, int y) -> bool\n    {\n        return 0 <= x && x < n && 0 <= y && y < n && grid[x][y] != '#';\n    };\n\n    vector<vvi> lowest(n, vvi(n, vi(digs, inf)));\n\n    ford (i, n) ford (j, n)\n    {\n        const int here = grid[i][j] - '1';\n        if (0 <= here && here < digs)\n            lowest[i][j][here] = id[i][j];\n\n        forn (d, digs) forn (iter, 2) if (i + (iter == 0) < n && j + (iter == 1) < n)\n            lowest[i][j][d] = min(lowest[i][j][d], lowest[i + (iter == 0)][j + (iter == 1)][d]);\n    }\n\n    ll ans = 0;\n    ford (sum, 2 * n - 1)\n    {\n        const int prev = (cur ^ 1);\n\n        forn (i, n)\n        {\n            const int j = sum - i;\n            if (0 <= j && j < n)\n            {\n                forn (d, digs)\n                    dp[cur][i][d].reset();\n\n                if (in(i, j))\n                {\n                    const int here = grid[i][j] - '1';\n                    assert(0 <= here && here < digs);\n\n                    dp[cur][i][here].set(id[i][j]);\n\n                    forn (iter, 2)\n                    if (in (i + (iter == 0), j + (iter == 1)))\n                    {\n                        forn (d, digs)\n                            dp[cur][i][d].or_with(dp[prev][i + (iter == 0)][d], lowest[i + (iter == 0)][j + (iter == 1)][d]);\n                    }\n\n//                    forn (d, digs)\n//                        ans += dp[cur][i][d].last();\n                    forn (d, digs)\n                        ans += (d + 1) * (here + 1) * dp[cur][i][d].bitcount();\n                    ans -= (here + 1) * (here + 1);\n                }\n            }\n        }\n\n        cur ^= 1;\n    }\n\n    return ans;\n}\n\nint32_t main()\n{\n#ifdef LOCAL\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif // ONLINE_JUDGE\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n#ifdef TEST\n    assert(read());\n    auto ans = solve();\n    cerr << ans << endl;\n    return 0;\n#endif // TEST\n\n    while (read())\n    {\n        auto ans = solve();\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include \"optimization.h\"\n\nusing namespace std;\n\n#define vec vector\n#define ALL(x) begin(x), end(x)\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< long long, long long > pll;\n\nconst int inf = 1000 * 1000 * 1000;\nconst ll inf64 = 1e18;\n\nconst int N = 505;\n\nint n;\nint a[N][N];\nbitset< N > can[2 * N];\nbitset< N > mask[2 * N][10];\n\nint main() {\n\n#ifdef debug\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n\n    scanf(\"%d\", &n);\n\n    for(int i = 0;i < n;i++) {\n        for(int j = 0;j < n;j++) {\n            char symb;\n            scanf(\" %c\", &symb);\n            a[i][j] = symb == '#' ? -1 : symb - '0';\n        }\n    }\n\n    for(int i = 0;i < n;i++) {\n        for(int j = 0;j < n;j++) {\n            if(a[i][j] == -1) {\n                can[i + j][j] = 0;\n            }else {\n                can[i + j][j] = 1;\n                mask[i + j][ a[i][j] ][j] = 1;\n            }\n        }\n    }\n\n    ll res = 0;\n\n    for(int x = 1;x <= 9;x++)   {\n        for(int i = 0;i < n;i++) {\n            for(int j = 0;j < n;j++) {\n                if(a[i][j] == -1) continue;\n                bitset< N > cur;\n                cur[j] = 1;\n                int cnt = 0;\n                for(int c = i + j + 1;c <= n-1+n-1;c++) {\n                    if(!cur.count()) break;\n                    cur = cur | (cur << 1);\n                    cur &= can[c];\n                    cnt += (cur & mask[c][x]).count();\n                }\n                res += 1ll * a[i][j] * cnt * x;\n            }\n        }\n    }\n\n    cout << res << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[510][510];\nint Up[510][510], Down[510][510];\nint B[510][510], E[510][510], BB[510], EE[510], S[510];\nint T[510][510], v[510];\nint n, w[510][510], L[510], R[510];\nlong long res;\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", p[i] + 1);\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif(p[i][j]>='0' && p[i][j]<='9')w[i][j] = p[i][j] - '0';\n\t\t\telse w[i][j] = -1;\n\t\t}\n\t}\n\tfor (i = 0; i <= n + 1; i++)for (j = 0; j <= n + 1; j++)if (i == 0 || i > n || j == 0 || j > n)w[i][j] = -1;\n\tfor (i = n; i >= 1; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (w[i][j] == -1)continue;\n\t\t\tDown[i][j] = i;\n\t\t\tDown[i][j] = max(Down[i][j], Down[i][j + 1]);\n\t\t\tDown[i][j] = max(Down[i][j], Down[i + 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tUp[i][j] = n + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tUp[i][j] = i;\n\t\t\tif(w[i][j-1] != -1)Up[i][j] = min(Up[i][j], Up[i][j - 1]);\n\t\t\tif(w[i-1][j] != -1)Up[i][j] = min(Up[i][j], Up[i - 1][j]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint pv = 0, s = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (w[i][j] == -1) {\n\t\t\t\tpv = j;\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\ts = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT[i][j] = pv + 1;\n\t\t\tres += s*w[i][j];\n\t\t\ts += w[i][j];\n\t\t\tint b = T[i][j], e = j;\n\t\t\tif (i != 1) {\n\t\t\t\tB[i][j] = 1e9, E[i][j] = -1e9;\n\t\t\t\tfor (k = b; k <= e; k++) {\n\t\t\t\t\tif (w[i - 1][k] != -1) {\n\t\t\t\t\t\tB[i][j] = min(B[i][j], T[i - 1][k]);\n\t\t\t\t\t\tE[i][j] = max(E[i][j], k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) BB[j] = B[i][j], EE[j] = E[i][j];\n\t\tfor (j = i - 1; j >= 1; j--) {\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tS[k] = S[k - 1];\n\t\t\t\tif (Down[j][k] >= i) {\n\t\t\t\t\tS[k] += w[j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 1) {\n\t\t\t\t\tif (B[j][k] <= E[j][k])v[k] = 1;\n\t\t\t\t\telse v[k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tif (Up[i][k] <= j) {\n\t\t\t\t\tres += (S[EE[k]] - S[BB[k] - 1])*w[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == 1)break;\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tL[k] = L[k - 1];\n\t\t\t\tif (v[k])L[k] = k;\n\t\t\t}\n\t\t\tR[n + 1] = n + 1;\n\t\t\tfor (k = n; k >= 1; k--) {\n\t\t\t\tR[k] = R[k + 1];\n\t\t\t\tif (v[k])R[k] = k;\n\t\t\t}\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tint b = BB[k], e = EE[k];\n\t\t\t\tif (Up[i][k] >= j)continue;\n\t\t\t\tBB[k] = B[j][R[b]], EE[k] = E[j][L[e]];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint vy[4] = { 1, 0, -1, 0 };\nint vx[4] = { 0, 1, 0, -1 };\n\nvector<string> board;\n\nint N;\n\nbool inside(int y, int x)\n{\n\treturn y >= 0 && x >= 0 && y < N && x < N;\n}\n\n\n\nint main() {\n\tcin >> N;\n\n\tvector<string> board(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> board[i];\n\t}\n\t\n\tvector<vector<int>> numBoard(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint activeBlock = 0;\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\n\t\t\t//if (rand() % 5 == 0) numBoard[i][j] == -1;\n\t\t\t//else numBoard[i][j] = 1;\n\t\t\tif (board[i][j] == '#') numBoard[i][j] = -1;\n\t\t\telse {\n\t\t\t\tnumBoard[i][j] = (int)(board[i][j] - '0');\n\t\t\t\tactiveBlock++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int>> maxLen(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (numBoard[sy][sx] == -1) continue;\n\t\t\tmaxLen[sy][sx] = 1;\n\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = sy + vy[k];\n\t\t\t\tint nx = sx + vx[k];\n\t\t\t\tif (inside(ny, nx) && maxLen[ny][nx] >= 1) {\n\t\t\t\t\tmaxLen[sy][sx] = max(maxLen[sy][sx], maxLen[ny][nx] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<int> q;\n\tvector<vector<int>> startUsed(vector<vector<int>>(N, vector<int>(N, 0)));\n\n\n\tvector<vector<int>> used(vector<vector<int>>(N, vector<int>(N, 0)));\n\tint myTurn = 1;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1 && maxLen[sy][sx] > 0)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 2; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t\tmyTurn++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcerr << \"reset \" << ((int)q.size() - activeBlock) << endl;\n\n\tfor (int sy = N - 1; sy >= 0; sy--)\n\t{\n\t\tfor (int sx = N - 1; sx >= 0; sx--)\n\t\t{\n\t\t\tif (startUsed[sy][sx] == 0 && numBoard[sy][sx] != -1)\n\t\t\t{\n\t\t\t\tqueue<int> q2;\n\t\t\t\tq2.push((sy << 12) + sx);\n\n\t\t\t\twhile (!q2.empty())\n\t\t\t\t{\n\t\t\t\t\tint now = q2.front(); q2.pop();\n\t\t\t\t\tint y = now >> 12;\n\t\t\t\t\tint x = now & 0xFFF;\n\t\t\t\t\tif (startUsed[y][x] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartUsed[y][x] = 1;\n\t\t\t\t\t\tq.push(now);\n\t\t\t\t\t\tq2 = queue<int>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.push(-1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcerr << \"reset \"  << ((int)q.size() - activeBlock) << endl;\n\n\n\n\tlong ans = 0;\n\tlong nowSum = 0;\n\n\tmyTurn++;\n\tlong add = 0;\n\n\twhile (!q.empty())\n\t{\n\t\tint start = q.front(); q.pop();\n\n\t\tif (start == -1)\n\t\t{\n\t\t\tmyTurn++;\n\t\t\tnowSum = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<int> q2;\n\t\tint sy = start >> 12;\n\t\tint sx = start & 0xFFF;\n\t\tused[sy][sx] = myTurn;\n\t\tq2.push(start);\n\n\n\t\twhile (!q2.empty())\n\t\t{\n\t\t\tint now = q2.front(); q2.pop();\n\t\t\tint y = now >> 12;\n\t\t\tint x = now & 0xFFF;\n\t\t\tnowSum += numBoard[y][x];\n\t\t\tadd++;\n\n\t\t\tint ny = y + 1;\n\t\t\tint nx = x + 1;\n\n\t\t\tif (ny < N && numBoard[ny][x] != -1 && used[ny][x] != myTurn)\n\t\t\t{\n\t\t\t\tused[ny][x] = myTurn;\n\t\t\t\tq2.push((ny << 12) + x);\n\t\t\t}\n\n\t\t\tif (nx < N && numBoard[y][nx] != -1 && used[y][nx] != myTurn)\n\t\t\t{\n\t\t\t\tused[y][nx] = myTurn;\n\t\t\t\tq2.push((y << 12) + nx);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = 0; k <= 1; k++)\n\t\t\t{\n\t\t\t\tint ny = y + vy[k];\n\t\t\t\tint nx = x + vx[k];\n\t\t\t\tif (inside(ny, nx) && numBoard[ny][nx] != -1 && used[ny][nx] != myTurn)\n\t\t\t\t{\n\t\t\t\t\tused[ny][nx] = myTurn;\n\t\t\t\t\tq2.push((ny << 12) + nx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\n\t\tans += numBoard[sy][sx] * nowSum;\n\t}\n\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (numBoard[i][j] != -1) ans -= numBoard[i][j] * numBoard[i][j];\n\t\t}\n\t}\n\n\tcerr << add << endl;\n\n\tcout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 520\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nint tmp = 64,tmp2 = 63;\n\nstruct BIT{\n\tvector <ull> v;\n\tBIT() { v.resize(1); }\n\tBIT(int x){\n\t\tint id = x / tmp;\n\t\tif ( v.size() < id + 1 ) v.resize(id + 1);\n\t\tv[id] |= 1ll << (x & tmp2);\n\t}\n\tBIT operator | (const BIT &a){\n\t\tv.resize(max(v.size(),a.v.size()));\n\t\trvc(i,a.v){\n\t\t\tv[i] |= a.v[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tint count(){\n\t\tint res = 0;\n\t\trvc(i,v) res += __builtin_popcountll(v[i]);\n\t\treturn res;\n\t}\n}sum[10][maxn][maxn];\n\nint n,a[maxn][maxn],num[maxn][maxn],cnt[10],vis[maxn][maxn];\nchar ch[maxn][maxn];\nll ans;\n\ninline int check(int x,int y){\n\tif ( x > n || y > n || !a[x][y] ) return 0;\n\treturn 1;\n}\nvoid dfs(int x,int y){\n\tif ( vis[x][y] ) return;\n\tvis[x][y] = 1;\n\tsum[a[x][y]][x][y] = BIT(num[x][y]);\n\tif ( check(x + 1,y) ){\n\t\tif ( vis[x + 1][y] ){\n\t\t\trep(i,1,9) sum[i][x][y] = sum[i][x][y] | sum[i][x + 1][y];\n\t\t}\n\t\telse{\n\t\t\tdfs(x + 1,y);\n\t\t\trep(i,1,9) sum[i][x][y] = sum[i][x][y] | sum[i][x + 1][y];\n\t\t}\n\t}\n\tif ( check(x,y + 1) ){\n\t\tif ( vis[x][y + 1] ){\n\t\t\trep(i,1,9) sum[i][x][y] = sum[i][x][y] | sum[i][x][y + 1];\n\t\t}\n\t\telse{\n\t\t\tdfs(x,y + 1);\n\t\t\trep(i,1,9) sum[i][x][y] = sum[i][x][y] | sum[i][x][y + 1];\n\t\t}\n\t}\n}\nvoid cal(int x,int y){\n\tif ( !a[x][y] ) return;\n\trep(i,1,9){\n\t\tint cur = sum[i][x][y].count();\n\t\tif ( i == a[x][y] ) cur--;\n\t\tans += cur * a[x][y] * i;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n){\n\t\tscanf(\"%s\",ch[i] + 1);\n\t\trep(j,1,n){\n\t\t\tif ( ch[i][j] == '#' ) a[i][j] = 0;\n\t\t\telse{\n\t\t\t   \ta[i][j] = ch[i][j] - '0';\n\t\t\t\tnum[i][j] = ++cnt[a[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n) rep(j,1,n) if ( !vis[i][j] ) dfs(i,j);\n\trep(i,1,n) rep(j,1,n) cal(i,j);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// doot diddly donger cuckerino Hahahahahah\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int LL;\ntypedef unsigned int UINT;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> PII;\ntypedef pair<string, int> PSI;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef vector<bool> VB;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef tuple<int, int, int> TPL;\ntypedef priority_queue<int> pqueue;\ntypedef priority_queue<int, VI, greater<int>> pdqueue;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, 1, 0, -1, -1, 1, -1, 1};\nconst int dxhorse[] = {-2, -2, -1, -1, 1, 1, 2, 2};\nconst int dyhorse[] = {1, -1, 2, -2, 2, -2, 1, -1};\n\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define endl \"\\n\"\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define F first\n#define S second\n#define SZ(x)           (x).size()\n#define MAX(a, b)      ((a)>(b)?(a):(b))\n#define MIN(a, b)      ((a)<(b)?(a):(b))\n#define ALL(a)         std::begin(a), std::end(a)\n#define Fill(n, x)      memset(n,x,sizeof n);\n#define IN_REP         int _t; cin >> _t ; while(_t--)\n#define IOS            ios::sync_with_stdio(false);cin.tie(NULL)\n#define FOR(i, a, b)    for(int i=(a);i<(b);i++)\n#define REP(i, n)       FOR(i,0,n)\n#define FORR(i, n)      for(int i=(n);i>=0;i--)\n#define EPS (double) 1e-9\n#define MOD (1000*1000*1000 + 7)\n#define INF 1011111111\n#define LLINF 1000111000111000111LL\nint n;\nVS c;\nVVI a;\nvector<VB> v;\n\nbool reachable(int x1, int y1, int x2, int y2) {\n    if (x2 < x1 || y2 < y1 || x1 < 0 || x2 < 0 || y1 >= n || y2 >= n || x1 >= n || x2 >= n || y1 < 0 || y2 < 0) {\n        return false;\n    }\n    if (c[x1][y1] == '#') return false;\n    if (x1 == x2 && y1 == y2)return true;\n    return reachable(x1 + 1, y1, x2, y2) || reachable(x1, y1 + 1, x2, y2);\n}\n\nvoid pre() {\n    IOS;\n//    freopen(\"/home/whiteknife/Workspace/CLionProjects/untitled/in\", \"r\", stdin);\n    cin >> n;\n    a.resize(n, VI(n));\n    c.resize(n);\n    v.resize(n, VB(n));\n    REP(i, n)cin >> c[i];\n    REP(i, n)REP(j, n)a[i][j] = ((c[i][j] == '#') ? 0 : (c[i][j] - '0'));\n    REP(i, n)REP(j, n) v[i][j] = false;\n    //    REP(i, n) {\n//        REP(j, n)cout << a[i][j] << \" \";\n//        cout << endl;\n//    }\n\n\n//    FORR(i, n) {\n//        FORR(j, n) {\n//            if (!v[i][j]) {\n//                for (int k = i; k >= 0; --k) {\n//                    for (int l = j; l >= 0; --l) {\n//                        if (c[k][l] == '#')\n//                            goto ok;\n//                        else {\n//                            v[k][l] = true;\n//                        }\n//                    }\n//                }\n//            }\n//            ok:\n//        }\n//    }\n}\n\nint main() {\n    pre();\n    LL ans = 0;\n    REP(i, n) {\n        REP(j, n) {\n            if (c[i][j] == '#')continue;\n            FOR(k, i, n) {\n                FOR(l, j, n) {\n//                    cerr << \"HERE\" << endl;\n//                    cerr << i << \" \" << j << \" \" << k << \" \" << l << endl;\n                    if (i == k && j == l)continue;\n//                    if (reachable(i, j, k, l))cerr << \"YESSSSSSSSS\" << endl;\n                    if (reachable(i, j, k, l)) ans += a[i][j] * a[k][l];\n                }\n            }\n        }\n    }\n//    cerr << \"OVER\" << endl;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 2000;\n\nint n;\nstring stmp[MAXN];\nint a[MAXN][MAXN];\nll go[MAXN][MAXN];\nint gd[MAXN][MAXN];\nint gr[MAXN][MAXN];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> stmp[i];\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (stmp[i][j] == '#')\n\t\t\t\ta[i][j] = 0;\n\t\t\telse\n\t\t\t\ta[i][j] = stmp[i][j] - '0';\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tif (a[i][j] == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i + 1 < n && j + 1 < n && a[i + 1][j] != 0 && a[i][j + 1] != 0) {\n\t\t\t\tgo[i][j] += go[i + 1][j];\n\t\t\t\tgo[i][j] += go[i][j + 1];\n\t\t\t\t//TODO: optimize\n\t\t\t\tfor (int k = i + 1; k < n && gd[j + 1][k] != -1; ++k) {\n\t\t\t\t\tif (gr[j][gd[j + 1][k]] == k)\n\t\t\t\t\t\tgo[i][j] -= go[k][gd[j + 1][k]];\n\t\t\t\t}\n\t\t\t\tgd[j][i] = j;\n\t\t\t\tfor (int x = j + 1; x < n && gr[j + 1][x] != -1; ++x)\n\t\t\t\t\tgr[j][x] = gr[j + 1][x];\n\t\t\t\tint st = i + 1;\n\t\t\t\twhile (st < n && gd[j][st] != -1)\n\t\t\t\t\t++st;\n\t\t\t\twhile (st < n && gd[j + 1][st] != -1)\n\t\t\t\t\tgd[j][st] = gd[j + 1][st], ++st;\n\t\t\t\tgr[j][j] = i;\n\t\t\t}\n\t\t\telse if (i + 1 < n && a[i + 1][j] != 0) {\n\t\t\t\tgo[i][j] += go[i + 1][j];\n\t\t\t\tgd[j][i] = j;\n\t\t\t\tgr[j][j] = i;\n\t\t\t}\n\t\t\telse if (j + 1 < n && a[i][j + 1] != 0) {\n\t\t\t\tgo[i][j] += go[i][j + 1];\n\t\t\t\tmemcpy(gr[j] + j + 1, gr[j + 1] + j + 1, sizeof(gr[0][0]) * (n - j - 1));\n\t\t\t\tmemcpy(gd[j] + i + 1, gd[j + 1] + i + 1, sizeof(gr[0][0]) * (n - i - 1));\n\t\t\t\tgd[j][i] = j;\n\t\t\t\tgr[j][j] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmemset(gr[j] + j + 1, -1, sizeof(gr[0][0]) * (n - j - 1));\n\t\t\t\tmemset(gd[j] + i + 1, -1, sizeof(gr[0][0]) * (n - i - 1));\n\t\t\t\tgd[j][i] = j;\n\t\t\t\tgr[j][j] = i;\n\t\t\t}\n\t\t\tans += go[i][j] * a[i][j];\n\t\t\tgo[i][j] += a[i][j];\n\t\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nconst int N=505;\nint a[N][N],f[N][N],l[N][N],r[N][N];\nchar s[N];\n/* \nf[i][j] (i,j) 能走到的位置的权值和\nl[i][j][k]/r[i][j][k] 表示 (i,j) 可以到达的第 k 行最左/右的位置 ，第一维省略\n不能走到的点贡献相当于已经清零，因为 (i+1,j) (i,j+1) 共同能走到的点的递增序列里面不会出现这些位置，\n且没有被计算到其左上的点的贡献中去 \n*/\nint main(){\n//\tfreopen(\"cell.in\",\"r\",stdin);\n//\tfreopen(\"cell.out\",\"w\",stdout);\n\tri n,i,j,k,now;\n\tregister long long ans;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%s\",s+1);\n\t\tfor(j=1;j<=n;++j)\n\t\t\ta[i][j]=s[j]=='#'?0:s[j]-'0';\n\t}\n\tans=0;\n\tfor(i=n;i;--i)\n\t\tfor(j=n;j;--j){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tmemset(l[j]+i,127,sizeof(int)*(n-i+1));\n\t\t\t\tmemset(r[j]+i,128,sizeof(int)*(n-i+1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(a[i+1][j]==0&&a[i][j+1]==0)\n\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\telse if(a[i+1][j]==0)\n\t\t\t\tmemcpy(l[j]+i,l[j+1]+i,sizeof(int)*(n-i+1)),\n\t\t\t\tmemcpy(r[j]+i,r[j+1]+i,sizeof(int)*(n-i+1)),\n\t\t\t\tl[j][i]=j,\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\telse if(a[i][j+1]==0)\n\t\t\t\tl[j][i]=r[j][i]=j,\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\telse{\n\t\t\t\tf[i][j]=f[i][j+1]+f[i+1][j];\n\t\t\t\tl[j][i]=j;r[j][i]=r[j+1][i];\n\t\t\t\tnow=0;\n\t\t\t\tfor(k=i+1;k<=n;++k){\n\t\t\t\t\tif(r[j][k]>=l[j+1][k]&&l[j+1][k]>now)\n\t\t\t\t\t//\tprintf(\"sub %d %d %d %d\\n\",i,j,k,l[j+1][k]),\n\t\t\t\t\t\tf[i][j]-=f[k][l[j+1][k]];\n\t\t\t\t\tnow=max(now,r[j][k]);\n\t\t\t\t\tl[j][k]=min(l[j][k],l[j+1][k]);\n\t\t\t\t\tr[j][k]=max(r[j][k],r[j+1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=a[i][j]*f[i][j];\n\t\t//\tprintf(\"f %d %d %d\\n\",i,j,f[i][j]);\n\t\t\tf[i][j]+=a[i][j];\n\t\t//\tprintf(\"check (%d,%d)\\n\",i,j);\n\t\t//\tfor(k=i;k<=n;++k)\n\t\t//\t\tprintf(\"%d %d %d\\n\",k,l[j][k],r[j][k]);\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\n \n#define M 2005\nint n;\nchar a[M][M];\nint f[M][M],l[M][M],r[M][M];\n \ninline void max(int &x,int y) {if(x<y) x=y;}\ninline void min(int &x,int y) {if(x>y) x=y;}\n \nint main () {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor1(1,n,i) scanf(\"%s\",a[i]+1);\n\t\n\tll ans=0;\n\tFOR2(n,1,i) FOR2(n,1,j) \n\t\tif(isdigit(a[i][j])) {\n\t\t\tbool t[2]={isdigit(a[i+1][j]),isdigit(a[i][j+1])};\n\t\t\tif(!t[0]&&!t[1]) {\n\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\t\tfor1(i+1,n,k) l[j][k]=n+1,r[j][k]=0;\n\t\t\t}\n\t\t\telse if(!t[0]) {\n\t\t\t\tf[i][j]=f[i][j+1];\n\t\t\t\tl[j][i]=j,r[j][i]=r[j+1][i];\n\t\t\t\tfor1(i+1,n,k) l[j][k]=l[j+1][k],r[j][k]=r[j+1][k];\n\t\t\t}\n\t\t\telse if(!t[1]) {\n\t\t\t\tf[i][j]=f[i+1][j];\n\t\t\t\tl[j][i]=r[j][i]=j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint las=0;\n\t\t\t\tint tot=f[i+1][j]+f[i][j+1];\n\t\t\t\tl[j][i]=j,r[j][i]=r[j+1][i];\n\t\t\t\t\n\t\t\t\tfor1(i+1,n,k) {\n\t\t\t\t\tif(l[j+1][k]<=r[j][k]&&l[j+1][k]>las) tot-=f[k][l[j+1][k]];\n\t\t\t\t\tmax(las,r[j][k]);\n\t\t\t\t//\tmin(l[j][k],l[j+1][k]);\n\t\t\t\t\tmax(r[j][k],r[j+1][k]); \n\t\t\t\t}\n\t\t\t\tf[i][j]=tot;\n\t\t\t}\n\t\t\tans+=f[i][j]*(a[i][j]-'0');\n\t\t\tf[i][j]+=a[i][j]-'0';\n\t\t}\n\t\telse l[j][i]=n+1,r[j][i]=0;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define L 50\n#define GET(x,y) *(map+((y-1)*(n+1))+(x-1))\n#define GETANS(x,y,xx,yy) GETANS2((x-1),(y-1),(xx),(yy))\n#define GETANS2(x,y,xx,yy) *(ansmap  + (yy*n*n*L)+(xx*n*n)+(y*n)+x  )\n#define GETANS2(x,y,xx,yy) *(ansmap  + (yy*n*n*L)+(xx*n*n)+(y*n)+x  )\n#define NUM(x,y) ((GET(x,y))-'0')\n\nint n;\nchar* map;\nchar* ansmap;\n\nint setHash(int Xx,int Xy,int Yx,int Yy, int ans)\n{\n  if( L <= (Yx-Xx) ) return 0;\n  if( L <= (Yy-Xy) ) return 0;\n  // 0:unknown 1:ok -1:ng\n  GETANS(Xx,Xy,Yx-Xx,Yy-Xy) = ans;\n  return 0;\n}\n  \nint getHash(int Xx,int Xy,int Yx,int Yy)\n{\n  if( L <= (Yx-Xx) ) return 0;\n  if( L <= (Yy-Xy) ) return 0;\n//  fprintf(stderr,\"%d,%d,%d,%d/\",Xx,Xy,Yx-Xx,Yy-Xy);\n  return GETANS(Xx,Xy,Yx-Xx,Yy-Xy);\n}\n\nint isOK(int Xx,int Xy,int Yx,int Yy)\n{\n  int ans;\n  if( (Xx==Yx)&&(Xy==Yy) ) return 1;\n  if(Xx>Yx) return 0; \n  if(Xy>Yy) return 0; \n  ans = getHash(Xx,Xy,Yx,Yy);\n  if ( ans != 0 )\n  {\n    if(ans>0) return 1;\n    return 0;\n  }\n  if( '#' == GET(Xx, Xy) ){ \n    setHash(Xx,Xy,Yx,Yy,-1);\n    return 0;\n  }\n  if( isOK(Xx+1, Xy, Yx, Yy) ) {\n    setHash(Xx,Xy,Yx,Yy,1);\n    return 1;\n  }\n  if( isOK(Xx, Xy+1, Yx, Yy) ) {\n    setHash(Xx,Xy,Yx,Yy,1);\n    return 1;\n  }\n  setHash(Xx,Xy,Yx,Yy,-1);\n  return 0;\n}\n\nint calc(int Xx,int Xy,int Yx,int Yy)\n{\n  int ok=isOK(Xx,Xy,Yx,Yy);\n  if(0==ok) return 0;\n  return ok*NUM(Xx,Xy)*NUM(Yx,Yy);\n}\n\nint main(void)\n{\n  int i;\n  int sum=0;\n  int Xx,Xy,Yx,Yy;\n  scanf(\"%d\",&n); \n//  printf (\"%d\\n\",n);\n  map = malloc((n+1)*(n+1));\n  ansmap = calloc(n*n*50*50,1);\n\n  for(i=0;i<n;i++)\n    scanf(\"%s\",(map+(n+1)*i)); \n//  for(i=0;i<n;i++)\n//    printf(\"%s\\n\",(map+(n+1)*i));\n\n  for(Xx=1;Xx<=n;Xx++)\n  {\n    for(Xy=1;Xy<=n;Xy++)\n    {\n      if( '#' == GET(Xx, Xy) ) continue;\n      for(Yx=Xx;Yx<=n;Yx++)\n      {\n        for(Yy=Xy;Yy<=n;Yy++)\n        {\n          if( (Xx>=Yx) && (Xy>=Yy) ) continue;\n          if( '#' == GET(Yx, Yy) )\n          {\n            if(Xx==Yx)break; \n            continue;\n          }\n          sum += calc(Xx,Xy,Yx,Yy);\n        }\n      }      \n    }\n  }\n  printf( \"%d\", sum );\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define GET(x,y) *(map+((y-1)*(n+1))+(x-1))\n#define NUM(x,y) ((GET(x,y))-'0')\n\nint n;\nchar* map;\n\nint isOK(int Xx,int Xy,int Yx,int Yy)\n{\n  if( (Xx==Yx)&&(Xy==Yy) ) return 1;\n  if(Xx>Yx) return 0; \n  if(Xy>Yy) return 0; \n  if( '#' == GET(Xx, Xy) ) return 0;\n  if( isOK(Xx+1, Xy, Yx, Yy) ) return 1;\n  if( isOK(Xx, Xy+1, Yx, Yy) ) return 1;\n  return 0;\n}\n\nint calc(int Xx,int Xy,int Yx,int Yy)\n{\n  int x,y;\n  int ok=isOK(Xx,Xy,Yx,Yy);\n//  printf(\"%d,%d,%d,%d=%d/\", Xx,Xy,Yx,Yy, ok);\n  return ok*NUM(Xx,Xy)*NUM(Yx,Yy);\n}\n\nint main(void)\n{\n  int i;\n  int sum=0;\n  int Xx,Xy,Yx,Yy;\n  scanf(\"%d\",&n); \n//  printf (\"%d\\n\",n);\n  map = malloc((n+1)*(n+1));\n\n  for(i=0;i<n;i++)\n    scanf(\"%s\",(map+(n+1)*i)); \n//  for(i=0;i<n;i++)\n//    printf(\"%s\\n\",(map+(n+1)*i));\n\n  for(Xx=1;Xx<=n;Xx++)\n  {\n    for(Xy=1;Xy<=n;Xy++)\n    {\n      if( '#' == GET(Xx, Xy) ) continue;\n      for(Yx=1;Yx<=n;Yx++)\n      {\n        for(Yy=1;Yy<=n;Yy++)\n        {\n          if( (Xx>=Yx) && (Xy>=Yy) ) continue;\n          if( '#' == GET(Yx, Yy) )\n          {\n//            if( (Xx == Yx) || (Xy == Yy ) ) break; \n            continue;\n          }\n          sum += calc(Xx,Xy,Yx,Yy);\n        }\n      }      \n    }\n  }\n  printf( \"%d\", sum );\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\npublic class Main {\n\n    int[][] cells;\n    int ans;\n    boolean[][] already;\n    \n    public static void main(String[] args) throws IOException {\n\tMain m = new Main();\n\tm.solve();\n    }\n\n    private void solve() throws IOException {\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tint n = Integer.parseInt(br.readLine());\n\tcells = new int[n+1][n+1];\n\tfor (int i=0;i<n;i++) {\n\t    cells[i][n] = cells[n][i] = -1;\n\t    String[] a = br.readLine().split(\"\");\n\t    for (int j=0;j<n;j++) {\n\t\tif (a[j].equals(\"#\")) {\n\t\t    cells[i][j] = -1;\n\t\t    continue;\n\t\t}\n\t\tcells[i][j] = Integer.parseInt(a[j]);\n\t    }\n\t}\n\tbr.close();\n\tans = 0;\n\tfor (int i=0;i<n;i++) {\n\t    for (int j=0;j<n;j++) {\n\t\tif (cells[i][j] < 0) continue;\n\t\t//System.out.println(\"from \"+i+\" \"+j);\n\t\talready = new boolean[n+1][n+1];\n\t\tsearch(i,j,cells[i][j]);\n\t    }\n\t}\n\tSystem.out.println(ans);\n    }\n\n    private void search(int i,int j,int c) {\n\tif (cells[i+1][j] > 0 && !already[i+1][j]) {\n\t    //System.out.println(\"at \"+(i+1)+\" \"+j);\n\t    already[i+1][j] = true;\n\t    ans += c*cells[i+1][j];\n\t    search(i+1,j,c);\n\t}\n\tif (cells[i][j+1] > 0) {\n\t    //System.out.println(\"at \"+i+\" \"+(j+1));\n\t    already[i][j+1] = true;\n\t    ans += c*cells[i][j+1];\n\t    search(i,j+1,c);\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint[][] a = new int[n + 1][n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = nextToken();\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\ta[i][j] = s.charAt(j) == '#' ? 0 : s.charAt(j) - '0';\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tint[][] left = new int[n + 1][n + 1];\n\t\tint[][] right = new int[n + 1][n + 1];\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tArrays.fill(left[i], n);\n\t\t\tArrays.fill(right[i], -1);\n\t\t}\n\n\t\tlong ans = 0;\n\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = n - 1; j >= 0; j--) {\n\n\t\t\t\tif (a[i][j] == 0) {\n\n\t\t\t\t\tfor (int k = i; k < n; k++) {\n\t\t\t\t\t\tleft[j][k] = n;\n\t\t\t\t\t\tright[j][k] = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdp[i][j] = dp[i + 1][j] + dp[i][j + 1];\n\n\t\t\t\t// do shit\n\n\t\t\t\tif (a[i + 1][j] != 0 && a[i][j + 1] != 0) {\n\t\t\t\t\tint delta = 0;\n\t\t\t\t\tint last = -1;\n\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\tif (right[j][k] >= left[j + 1][k]\n\t\t\t\t\t\t\t\t&& left[j + 1][k] > last) {\n\t\t\t\t\t\t\tdelta += dp[k][left[j + 1][k]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = right[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] -= delta;\n\t\t\t\t}\n\n\t\t\t\tleft[j][i] = right[j][i] = j;\n\n\t\t\t\tfor (int k = i; k < n; k++) {\n\t\t\t\t\tleft[j][k] = Math.min(left[j][k], left[j + 1][k]);\n\t\t\t\t\tright[j][k] = Math.max(right[j][k], right[j + 1][k]);\n\t\t\t\t}\n\n\t\t\t\tans += (long) dp[i][j] * a[i][j];\n\t\t\t\tdp[i][j] += a[i][j];\n\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.TreeSet;\n  \npublic class Main {\n  public static void main(String[] args) {\n    InputReader sc = new InputReader(System.in);\n \n    int n = sc.nextInt();\n\n    int[][] field = new int[n][n];\n    for(int i = 0; i < n; i++){\n      String s = sc.nextStr();\n      for(int j = 0; j < n; j++){\n        if(s.charAt(j) == '#'){\n          field[i][j] = 0;\n        }else{\n          field[i][j] = (int)s.charAt(j) - 48;\n        }\n      }\n    }\n\n    long answer = 0;\n\n    for(int startx = 0; startx < n; startx++){\n      for(int starty = 0; starty < n; starty++){\n        if(startx + starty == 0){continue;}\n        if(field[startx][starty] == 0){continue;}\n\n        boolean[][] check = new boolean[n+1][n+1];\n        for(int i = 0; i <= n; i++){\n          for(int j = 0; j <= n; j++){\n            if(i <= startx && j <= starty){\n              check[i][j] = true;\n            }else{\n              check[i][j] = false;\n            }\n          }\n        }\n\n        for(int kyori = 0; kyori <= Math.min(startx, starty); kyori++){\n          int nowx = startx - kyori;\n          int nowy = starty - kyori;\n\n          if(kyori > 0){\n            if(check[nowx+1][nowy] || check[nowx][nowy+1]){\n              answer += field[nowx][nowy] * field[startx][starty];\n            }else{\n              check[nowx][nowy] = false;\n            }\n          }\n\n          //タテチェック\n          for(int i = 1; nowy - i >= 0; i++){\n            if(field[nowx][nowy-i] == 0){\n              check[nowx][nowy-i] = false;\n            }else if(check[nowx][nowy-i+1] || check[nowx+1][nowy-i]){\n              answer += field[nowx][nowy-i] * field[startx][starty];\n            }else{\n              check[nowx][nowy-i] = false;              \n            }\n          }\n\n          nowx = startx - kyori;\n          nowy = starty - kyori;\n          //ヨコチェック\n          for(int i = 1; nowx - i >= 0; i++){\n            if(field[nowx-i][nowy] == 0){\n              check[nowx-i][nowy] = false;\n            }else if(check[nowx-i+1][nowy] || check[nowx-i][nowy+1]){\n              answer += field[nowx-i][nowy] * field[startx][starty];\n            }else{\n              check[nowx-i][nowy] = false;\n            }\n          }\n\n        }\n\n\n      }\n    }\n\n\n    System.out.println(answer);\n \n  }\n\n\n\n //ここからテンプレ\n  static class InputReader {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n      private SpaceCharFilter filter;\n \n      public InputReader(InputStream stream) {\n          this.stream = stream;\n      }\n \n      public int next() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = stream.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      public String nextStr() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        StringBuffer str = new StringBuffer();\n        do{\n          str.append((char)c);\n          c = next();\n        }while(!isSpaceChar(c));\n        return str.toString();\n      }\n \n      public char nextChar() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        char ret;\n        do{\n          ret = (char)c;\n          c = next();\n        }while(!isSpaceChar(c));\n        return ret;\n      }\n \n      public int nextInt() {\n          int c = next();\n          while (isSpaceChar(c))\n              c = next();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = next();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = next();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public boolean isSpaceChar(int c) {\n          if (filter != null)\n              return filter.isSpaceChar(c);\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      public interface SpaceCharFilter {\n          public boolean isSpaceChar(int ch);\n      }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            char[][] a = in.readTable(n, n);\n            long answer = 0;\n            boolean[][] reachable = new boolean[n][n];\n            int[] rowQueue = new int[n * n];\n            int[] colQueue = new int[n * n];\n            for (int i = 0; i < n; i++) {\n                ArrayUtils.fill(reachable, false);\n                int sum = 0;\n                for (int j = n - 1; j >= 0; j--) {\n                    if (a[i][j] == '#') {\n                        ArrayUtils.fill(reachable, false);\n                        sum = 0;\n                        continue;\n                    }\n                    rowQueue[0] = i;\n                    colQueue[0] = j;\n                    reachable[i][j] = true;\n                    int current = a[i][j] - '0';\n                    sum += current;\n                    int size = 1;\n                    for (int k = 0; k < size; k++) {\n                        int row = rowQueue[k];\n                        int col = colQueue[k];\n                        if (row + 1 < n && a[row + 1][col] != '#' && !reachable[row + 1][col]) {\n                            reachable[row + 1][col] = true;\n                            sum += a[row + 1][col] - '0';\n                            rowQueue[size] = row + 1;\n                            colQueue[size++] = col;\n                        }\n                        if (col + 1 < n && a[row][col + 1] != '#' && !reachable[row][col + 1]) {\n                            reachable[row][col + 1] = true;\n                            sum += a[row][col + 1] - '0';\n                            rowQueue[size] = row;\n                            colQueue[size++] = col + 1;\n                        }\n                    }\n                    answer += (sum - current) * current;\n                }\n            }\n            out.printLine(answer);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void fill(boolean[][] array, boolean value) {\n            for (boolean[] row : array) {\n                Arrays.fill(row, value);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public char[] readCharArray(int size) {\n            char[] array = new char[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readCharacter();\n            }\n            return array;\n        }\n\n        public char[][] readTable(int rowCount, int columnCount) {\n            char[][] table = new char[rowCount][];\n            for (int i = 0; i < rowCount; i++) {\n                table[i] = this.readCharArray(columnCount);\n            }\n            return table;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char readCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.TreeSet;\n  \npublic class Main {\n  public static void main(String[] args) {\n    InputReader sc = new InputReader(System.in);\n \n    int n = sc.nextInt();\n\n    int[][] field = new int[n][n];\n    for(int i = 0; i < n; i++){\n      String s = sc.nextStr();\n      for(int j = 0; j < n; j++){\n        if(s.charAt(j) == '#'){\n          field[i][j] = 0;\n        }else{\n          field[i][j] = (int)s.charAt(j) - 48;\n        }\n      }\n    }\n\n    long answer = 0;\n\n    for(int startx = 0; startx < n; startx++){\n      for(int starty = 0; starty < n; starty++){\n        if(startx + starty == 0){continue;}\n        if(field[startx][starty] == 0){continue;}\n\n        boolean[][] check = new boolean[n+1][n+1];\n        for(int i = 0; i <= n; i++){\n          for(int j = 0; j <= n; j++){\n            if(i <= startx && j <= starty){\n              check[i][j] = true;\n            }else{\n              check[i][j] = false;\n            }\n          }\n        }\n\n        for(int kyori = 0; kyori <= Math.min(startx, starty); kyori++){\n          int nowx = startx - kyori;\n          int nowy = starty - kyori;\n\n          if(kyori > 0){\n            if(field[nowx][nowy] > 0 && (check[nowx+1][nowy] || check[nowx][nowy+1])){\n              answer += field[nowx][nowy] * field[startx][starty];\n            }else{\n              check[nowx][nowy] = false;\n            }\n          }\n\n          //タテチェック\n          for(int i = 1; nowy - i >= 0; i++){\n            if(field[nowx][nowy-i] > 0 && (check[nowx][nowy-i+1] || check[nowx+1][nowy-i])){\n              answer += field[nowx][nowy-i] * field[startx][starty];\n            }else{\n              check[nowx][nowy-i] = false;              \n            }\n          }\n\n          nowx = startx - kyori;\n          nowy = starty - kyori;\n          //ヨコチェック\n          for(int i = 1; nowx - i >= 0; i++){\n            if(field[nowx-i][nowy] > 0 && (check[nowx-i+1][nowy] || check[nowx-i][nowy+1])){\n              answer += field[nowx-i][nowy] * field[startx][starty];\n            }else{\n              check[nowx-i][nowy] = false;              \n            }\n          }\n\n        }\n\n\n      }\n    }\n\n\n    System.out.println(answer);\n \n  }\n\n\n\n //ここからテンプレ\n  static class InputReader {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n      private SpaceCharFilter filter;\n \n      public InputReader(InputStream stream) {\n          this.stream = stream;\n      }\n \n      public int next() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = stream.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      public String nextStr() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        StringBuffer str = new StringBuffer();\n        do{\n          str.append((char)c);\n          c = next();\n        }while(!isSpaceChar(c));\n        return str.toString();\n      }\n \n      public char nextChar() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        char ret;\n        do{\n          ret = (char)c;\n          c = next();\n        }while(!isSpaceChar(c));\n        return ret;\n      }\n \n      public int nextInt() {\n          int c = next();\n          while (isSpaceChar(c))\n              c = next();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = next();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = next();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public boolean isSpaceChar(int c) {\n          if (filter != null)\n              return filter.isSpaceChar(c);\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      public interface SpaceCharFilter {\n          public boolean isSpaceChar(int ch);\n      }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            boolean[][] wall = new boolean[n][n];\n            int[][] a = new int[n][n];\n            int[][] b = new int[n][n];\n            for (int i = 0; i < n; ++i) {\n                String s = in.next();\n                for (int j = 0; j < n; ++j) {\n                    char ch = s.charAt(j);\n                    if (ch == '#')\n                        wall[i][j] = true;\n                    else {\n                        a[i][j] = b[i][j] = ch - '0';\n                    }\n                }\n            }\n            long res = 0;\n            Random random = new Random(55415345351L);\n            int[][] seen = new int[n][n];\n            int[][] best = new int[n][n];\n            int[][] via = new int[n][n];\n            int[] qr = new int[n * n];\n            int[] qc = new int[n * n];\n            int[] pr = new int[2 * n];\n            int[] pc = new int[2 * n];\n            int generation = 0;\n            while (true) {\n                int cnt = 0;\n                int sr = -1;\n                int sc = -1;\n                for (int r = 0; r < n; ++r) {\n                    for (int c = 0; c < n; ++c) {\n                        if (b[r][c] > 0) {\n                            ++cnt;\n                            if (random.nextInt(cnt) == 0) {\n                                sr = r;\n                                sc = c;\n                            }\n                        }\n                    }\n                }\n                if (cnt == 0) break;\n                int plen = 0;\n                {\n                    ++generation;\n                    int qt = 0;\n                    int qh = 1;\n                    qr[0] = sr;\n                    qc[0] = sc;\n                    best[sr][sc] = 0;\n                    seen[sr][sc] = generation;\n                    int globalBest = 0;\n                    int globalBr = sr;\n                    int globalBc = sc;\n                    while (qt < qh) {\n                        int r = qr[qt];\n                        int c = qc[qt];\n                        int cbest = best[r][c];\n                        if (cbest > globalBest) {\n                            globalBest = cbest;\n                            globalBr = r;\n                            globalBc = c;\n                        }\n                        ++qt;\n                        if (r + 1 < n) {\n                            int nr = r + 1;\n                            int nc = c;\n                            if (!wall[nr][nc]) {\n                                int extra = b[nr][nc] > 0 ? 1 : 0;\n                                if (seen[nr][nc] < generation || best[nr][nc] < cbest + extra) {\n                                    if (seen[nr][nc] < generation) {\n                                        qr[qh] = nr;\n                                        qc[qh] = nc;\n                                        ++qh;\n                                    }\n                                    seen[nr][nc] = generation;\n                                    best[nr][nc] = cbest + extra;\n                                    via[nr][nc] = 1;\n                                }\n                            }\n                        }\n                        if (c + 1 < n) {\n                            int nr = r;\n                            int nc = c + 1;\n                            if (!wall[nr][nc]) {\n                                int extra = b[nr][nc] > 0 ? 1 : 0;\n                                if (seen[nr][nc] < generation || best[nr][nc] < cbest + extra) {\n                                    if (seen[nr][nc] < generation) {\n                                        qr[qh] = nr;\n                                        qc[qh] = nc;\n                                        ++qh;\n                                    }\n                                    seen[nr][nc] = generation;\n                                    best[nr][nc] = cbest + extra;\n                                    via[nr][nc] = 2;\n                                }\n                            }\n                        }\n                    }\n                    int r = globalBr;\n                    int c = globalBc;\n                    while (r != sr || c != sc) {\n                        pr[plen] = r;\n                        pc[plen] = c;\n                        ++plen;\n                        if (via[r][c] == 1) {\n                            --r;\n                        } else {\n                            --c;\n                        }\n                    }\n                }\n                pr[plen] = sr;\n                pc[plen] = sc;\n                ++plen;\n                {\n                    ++generation;\n                    int qt = 0;\n                    int qh = 1;\n                    qr[0] = sr;\n                    qc[0] = sc;\n                    best[sr][sc] = 0;\n                    seen[sr][sc] = generation;\n                    int globalBest = 0;\n                    int globalBr = sr;\n                    int globalBc = sc;\n                    while (qt < qh) {\n                        int r = qr[qt];\n                        int c = qc[qt];\n                        int cbest = best[r][c];\n                        if (cbest > globalBest) {\n                            globalBest = cbest;\n                            globalBr = r;\n                            globalBc = c;\n                        }\n                        ++qt;\n                        if (r - 1 >= 0) {\n                            int nr = r - 1;\n                            int nc = c;\n                            if (!wall[nr][nc]) {\n                                int extra = b[nr][nc] > 0 ? 1 : 0;\n                                if (seen[nr][nc] < generation || best[nr][nc] < cbest + extra) {\n                                    if (seen[nr][nc] < generation) {\n                                        qr[qh] = nr;\n                                        qc[qh] = nc;\n                                        ++qh;\n                                    }\n                                    seen[nr][nc] = generation;\n                                    best[nr][nc] = cbest + extra;\n                                    via[nr][nc] = 1;\n                                }\n                            }\n                        }\n                        if (c - 1 >= 0) {\n                            int nr = r;\n                            int nc = c - 1;\n                            if (!wall[nr][nc]) {\n                                int extra = b[nr][nc] > 0 ? 1 : 0;\n                                if (seen[nr][nc] < generation || best[nr][nc] < cbest + extra) {\n                                    if (seen[nr][nc] < generation) {\n                                        qr[qh] = nr;\n                                        qc[qh] = nc;\n                                        ++qh;\n                                    }\n                                    seen[nr][nc] = generation;\n                                    best[nr][nc] = cbest + extra;\n                                    via[nr][nc] = 2;\n                                }\n                            }\n                        }\n                    }\n                    int r = globalBr;\n                    int c = globalBc;\n                    int splen = plen;\n                    while (r != sr || c != sc) {\n                        pr[plen] = r;\n                        pc[plen] = c;\n                        ++plen;\n                        if (via[r][c] == 1) {\n                            ++r;\n                        } else {\n                            ++c;\n                        }\n                    }\n                    for (int i = splen, j = plen - 1; i < j; ++i, --j) {\n                        int t = pr[i];\n                        pr[i] = pr[j];\n                        pr[j] = t;\n                        t = pc[i];\n                        pc[i] = pc[j];\n                        pc[j] = t;\n                    }\n                }\n                {\n                    ++generation;\n                    int sofar = 0;\n                    for (int i = 0; i < plen; ++i) {\n                        seen[pr[i]][pc[i]] = generation;\n                        res -= a[pr[i]][pc[i]] * b[pr[i]][pc[i]];\n                        sofar += b[pr[i]][pc[i]];\n                        b[pr[i]][pc[i]] = 0;\n                        best[pr[i]][pc[i]] = sofar;\n                    }\n                    int qt = 0;\n                    int qh = 0;\n                    int nextPath = 0;\n                    while (qt < qh || nextPath < plen) {\n                        if (qt == qh) {\n                            qr[qh] = pr[nextPath];\n                            qc[qh] = pc[nextPath];\n                            ++nextPath;\n                            ++qh;\n                        }\n                        int r = qr[qt];\n                        int c = qc[qt];\n                        int cbest = best[r][c];\n                        res += cbest * a[r][c];\n                        ++qt;\n                        if (r - 1 >= 0) {\n                            int nr = r - 1;\n                            int nc = c;\n                            if (!wall[nr][nc]) {\n                                if (seen[nr][nc] < generation || best[nr][nc] < cbest) {\n                                    if (seen[nr][nc] < generation) {\n                                        qr[qh] = nr;\n                                        qc[qh] = nc;\n                                        ++qh;\n                                    }\n                                    seen[nr][nc] = generation;\n                                    best[nr][nc] = cbest;\n                                }\n                            }\n                        }\n                        if (c - 1 >= 0) {\n                            int nr = r;\n                            int nc = c - 1;\n                            if (!wall[nr][nc]) {\n                                if (seen[nr][nc] < generation || best[nr][nc] < cbest) {\n                                    if (seen[nr][nc] < generation) {\n                                        qr[qh] = nr;\n                                        qc[qh] = nc;\n                                        ++qh;\n                                    }\n                                    seen[nr][nc] = generation;\n                                    best[nr][nc] = cbest;\n                                    via[nr][nc] = 2;\n                                }\n                            }\n                        }\n                        if (nextPath < plen && r + c == pr[nextPath] + pc[nextPath]) {\n                            --qt;\n                            qr[qt] = pr[nextPath];\n                            qc[qt] = pc[nextPath];\n                            ++nextPath;\n                        }\n                    }\n                }\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tchar map[][] = new char[n][];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap[i] = scanString().toCharArray();\n\t\t}\n\t\tint sum[][] = new int[n][n];\n\t\tint maxI[][] = new int[n][n];\n\t\tint curProfilesD[][] = new int[n][n];\n\t\tint curProfilesR[][] = new int[n][n];\n\t\tint prevProfilesD[][] = new int[n][n];\n\t\tint prevProfilesR[][] = new int[n][n];\n\t\tlong ans = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = n - 1; j >= 0; j--) {\n\t\t\t\tif (map[i][j] == '#') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint value = map[i][j] - '0';\n\t\t\t\tif (i == n - 1 || map[i + 1][j] == '#') {\n\t\t\t\t\tif (j == n - 1 || map[i][j + 1] == '#') {\n\t\t\t\t\t\tsum[i][j] = value;\n\t\t\t\t\t\tmaxI[i][j] = i;\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesD[j][k] = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = i; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesR[j][k] = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint psum = sum[i][j + 1];\n\t\t\t\t\t\tsum[i][j] = value + psum;\n\t\t\t\t\t\tans += value * psum;\n\t\t\t\t\t\tmaxI[i][j] = maxI[i][j + 1];\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesD[j][k] = curProfilesD[j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = i; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesR[j][k] = curProfilesR[j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (j == n - 1 || map[i][j + 1] == '#') {\n\t\t\t\t\t\tint psum = sum[i + 1][j];\n\t\t\t\t\t\tsum[i][j] = value + psum;\n\t\t\t\t\t\tans += value * psum;\n\t\t\t\t\t\tmaxI[i][j] = maxI[i + 1][j];\n\t\t\t\t\t\tcurProfilesD[j][i + 1] = j;\n\t\t\t\t\t\tfor (int k = i + 2; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesD[j][k] = prevProfilesD[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurProfilesR[j][i] = j + 1;\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesR[j][k] = prevProfilesR[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint psum = sum[i][j + 1] + sum[i + 1][j];\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tif (curProfilesD[j + 1][k] < prevProfilesR[j][k]) {\n\t\t\t\t\t\t\t\tpsum -= sum[k][curProfilesD[j + 1][k]];\n\t\t\t\t\t\t\t\tk = maxI[k][curProfilesD[j + 1][k]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum[i][j] = value + psum;\n\t\t\t\t\t\tans += value * psum;\n\t\t\t\t\t\tmaxI[i][j] = max(maxI[i][j + 1], maxI[i + 1][j]);\n\t\t\t\t\t\tcurProfilesD[j][i + 1] = j;\n\t\t\t\t\t\tfor (int k = i + 2; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesD[j][k] = min(prevProfilesD[j][k], curProfilesD[j + 1][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurProfilesR[j][i] = curProfilesR[j + 1][i];\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesR[j][k] = max(curProfilesR[j + 1][k], prevProfilesR[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.err.println(i + \" \" + j + \" \" + ans + \" \" +\n//\t\t\t\t\tArrays.toString(Arrays.copyOfRange(curProfilesD[j], i + 1, n)) + \" \" +\n//\t\t\t\t\tArrays.toString(Arrays.copyOfRange(curProfilesR[j], i, n)));\n\t\t\t}\n\t\t\tint t[][] = prevProfilesD;\n\t\t\tprevProfilesD = curProfilesD;\n\t\t\tcurProfilesD = t;\n\t\t\tt = prevProfilesR;\n\t\t\tprevProfilesR = curProfilesR;\n\t\t\tcurProfilesR = t;\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tchar map[][] = new char[n][];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap[i] = scanString().toCharArray();\n\t\t}\n\t\tint sum[][] = new int[n][n];\n\t\tint maxI[][] = new int[n][n];\n\t\tint curProfilesD[][] = new int[n][n];\n\t\tint curProfilesR[][] = new int[n][n];\n\t\tint prevProfilesD[][] = new int[n][n];\n\t\tint prevProfilesR[][] = new int[n][n];\n\t\tint ans = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = n - 1; j >= 0; j--) {\n\t\t\t\tif (map[i][j] == '#') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint value = map[i][j] - '0';\n\t\t\t\tif (i == n - 1 || map[i + 1][j] == '#') {\n\t\t\t\t\tif (j == n - 1 || map[i][j + 1] == '#') {\n\t\t\t\t\t\tsum[i][j] = value;\n\t\t\t\t\t\tmaxI[i][j] = i;\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesD[j][k] = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = i; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesR[j][k] = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint psum = sum[i][j + 1];\n\t\t\t\t\t\tsum[i][j] = value + psum;\n\t\t\t\t\t\tans += value * psum;\n\t\t\t\t\t\tmaxI[i][j] = maxI[i][j + 1];\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesD[j][k] = curProfilesD[j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = i; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesR[j][k] = curProfilesR[j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (j == n - 1 || map[i][j + 1] == '#') {\n\t\t\t\t\t\tint psum = sum[i + 1][j];\n\t\t\t\t\t\tsum[i][j] = value + psum;\n\t\t\t\t\t\tans += value * psum;\n\t\t\t\t\t\tmaxI[i][j] = maxI[i + 1][j];\n\t\t\t\t\t\tcurProfilesD[j][i + 1] = j;\n\t\t\t\t\t\tfor (int k = i + 2; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesD[j][k] = prevProfilesD[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurProfilesR[j][i] = j + 1;\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesR[j][k] = prevProfilesR[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint psum = sum[i][j + 1] + sum[i + 1][j];\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tif (curProfilesD[j + 1][k] < prevProfilesR[j][k]) {\n\t\t\t\t\t\t\t\tpsum -= sum[k][curProfilesD[j + 1][k]];\n\t\t\t\t\t\t\t\tk = maxI[k][curProfilesD[j + 1][k]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum[i][j] = value + psum;\n\t\t\t\t\t\tans += value * psum;\n\t\t\t\t\t\tmaxI[i][j] = max(maxI[i][j + 1], maxI[i + 1][j]);\n\t\t\t\t\t\tcurProfilesD[j][i + 1] = j;\n\t\t\t\t\t\tfor (int k = i + 2; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesD[j][k] = min(prevProfilesD[j][k], curProfilesD[j + 1][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurProfilesR[j][i] = curProfilesR[j + 1][i];\n\t\t\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\t\t\tcurProfilesR[j][k] = max(curProfilesR[j + 1][k], prevProfilesR[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.err.println(i + \" \" + j + \" \" + ans + \" \" +\n//\t\t\t\t\tArrays.toString(Arrays.copyOfRange(curProfilesD[j], i + 1, n)) + \" \" +\n//\t\t\t\t\tArrays.toString(Arrays.copyOfRange(curProfilesR[j], i, n)));\n\t\t\t}\n\t\t\tint t[][] = prevProfilesD;\n\t\t\tprevProfilesD = curProfilesD;\n\t\t\tcurProfilesD = t;\n\t\t\tt = prevProfilesR;\n\t\t\tprevProfilesR = curProfilesR;\n\t\t\tcurProfilesR = t;\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n    Scanner cin;\n\n    int[] vy = { 1, 0, -1, 0 };\n    int[] vx = { 0, 1, 0, -1 };\n\n    int N;\n\n    void calc()\n    {\n        cin = new Scanner();\n        N = cin.nextInt();\n\n        string[] board = new string[N];\n        for (int i = 0; i < N; i++)\n        {\n            board[i] = cin.next();\n            //board[i] = new string('9', N);\n        }\n        int[,] numBoard = new int[N, N];\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                if (board[i][j] == '#') numBoard[i, j] = -1;\n                else numBoard[i, j] = (int)(board[i][j] - '0');\n            }\n        }\n\n        Queue<int> q = new Queue<int>();\n\n        bool[,] startUsed = new bool[N, N];\n\n        for (int sy = N - 1; sy >= 0; sy--)\n        {\n            for (int sx = N - 1; sx >= 0; sx--)\n            {\n                if (!startUsed[sy, sx] && numBoard[sy, sx] != -1)\n                {\n                    Queue<int> q2 = new Queue<int>();\n                    q2.Enqueue((sy << 12) + sx);\n\n                    while (q2.Count != 0)\n                    {\n                        int now = q2.Dequeue();\n                        int y = now >> 12;\n                        int x = now & 0xFFF;\n                        if (!startUsed[y, x])\n                        {\n                            startUsed[y, x] = true;\n                            q.Enqueue(now);\n                            q2.Clear();\n                        }\n\n                        for (int k = 2; k < 4; k++)\n                        {\n                            int ny = y + vy[k];\n                            int nx = x + vx[k];\n                            if (inside(ny, nx) && numBoard[ny, nx] != -1)\n                            {\n                                q2.Enqueue((ny << 12) + nx);\n                            }\n                        }\n                    }\n                    q.Enqueue(-1);\n                }\n            }\n        }\n\n        int[,] used = new int[N, N];\n        int myTurn = 1;\n\n        long ans = 0;\n        long nowSum = 0;\n\n        while (q.Count != 0)\n        {\n            int start = q.Dequeue();\n\n            if(start == -1)\n            {\n                myTurn++;\n                nowSum = 0;\n                //Console.Error.WriteLine(\"reset\");\n                continue;\n            }\n\n            Queue<int> q2 = new Queue<int>();\n            int sy = start >> 12;\n            int sx = start & 0xFFF;\n            used[sy, sx] = myTurn;\n            q2.Enqueue(start);\n\n\n            while (q2.Count != 0)\n            {\n                int now = q2.Dequeue();\n                int y = now >> 12;\n                int x = now & 0xFFF;\n                nowSum += numBoard[y, x];\n\n                for (int k = 0; k <= 1; k++)\n                {\n                    int ny = y + vy[k];\n                    int nx = x + vx[k];\n                    if (inside(ny, nx) && numBoard[ny, nx] != -1 && used[ny,nx] != myTurn)\n                    {\n                        used[ny, nx] = myTurn;\n                        q2.Enqueue((ny << 12) + nx);\n                    }\n                }\n            }\n\n            //Console.Error.WriteLine(sy + \" \" + sx + \" \" + nowSum);\n\n            ans += numBoard[sy, sx] * nowSum;\n        }\n\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                if (numBoard[i, j] != -1) ans -= numBoard[i, j] * numBoard[i, j];\n            }\n        }\n\n        Console.WriteLine(ans);\n    }\n\n    bool inside(int y, int x)\n    {\n        return y >= 0 && x >= 0 && y < N && x < N;\n    } \n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\nimport \"fmt\"\nvar n int\nvar a,g [][]int\nvar u []bool\nfunc main() {\n  var s string\n  fmt.Scan(&n)\n  a = make([][]int,n+1)\n  a[n] = make([]int,n+1)\n  for j:=0;j<n+1;j++ { a[n][j] = -13 }\n  for i:=0;i<n;i++ {\n    a[i] = make([]int,n+1)\n    fmt.Scan(&s)\n    s += \"#\"\n    for j,r := range s { a[i][j] = int(r)-48 }\n  }\n  g = make([][]int,n*n)\n  for i:=0;i<n;i++ {\n    for j:=0;j<n;j++ {\n      if a[i][j] < 0 { continue }\n      x := en(i,j)\n      if a[i][j+1] > 0 { g[x] = append(g[x],en(i,j+1)) }\n      if a[i+1][j] > 0 { g[x] = append(g[x],en(i+1,j)) }\n    }\n  }\n  ans := 0\n  u = make([]bool,n*n)\n  for k:=0;k<2*n-1;k++ {\n    for i:=0;i<=k;i++ {\n      if i >= n { break }\n      j := k-i\n      if j >= n { continue }\n      if a[i][j] < 0 { continue }\n      for t:=0;t<n*n;t++ { u[t] = false }\n      ans += (dfs(en(i,j))-a[i][j])*a[i][j]\n    }\n  }\n  fmt.Println(ans)\n}\nfunc dfs(x int) int {\n  u[x] = true\n  i,j := de(x)\n  s := 0\n  for _,y := range g[x] {\n    if u[y] { continue }\n    s += dfs(y)\n  }\n  return s+a[i][j]\n}\nfunc en(i,j int) int { return i*n+j }\nfunc de(x int) (int,int) { return x/n,x%n }"
  },
  {
    "language": "Go",
    "code": "package main\nimport \"fmt\"\nvar n int\nvar a,g [][]int\nvar u []bool\nvar ans int\nfunc main() {\n  var s string\n  fmt.Scan(&n)\n  a = make([][]int,n+1)\n  a[n] = make([]int,n+1)\n  for j:=0;j<n+1;j++ { a[n][j] = -13 }\n  for i:=0;i<n;i++ {\n    a[i] = make([]int,n+1)\n    fmt.Scan(&s)\n    s += \"#\"\n    for j,r := range s { a[i][j] = int(r)-48 }\n  }\n  g = make([][]int,n*n)\n  for i:=0;i<n;i++ {\n    for j:=0;j<n;j++ {\n      if a[i][j] < 0 { continue }\n      x := en(i,j)\n      if a[i][j+1] > 0 { g[x] = append(g[x],en(i,j+1)) }\n      if a[i+1][j] > 0 { g[x] = append(g[x],en(i+1,j)) }\n    }\n  }\n  u = make([]bool,n*n)\n  for k:=0;k<2*n-1;k++ {\n    for i:=0;i<=k;i++ {\n      if i >= n { break }\n      j := k-i\n      if j >= n { continue }\n      x := en(i,j)\n      if a[i][j] < 0 || u[x] { continue }\n      dfs(x)\n    }\n  }\n  fmt.Println(ans)\n}\nfunc dfs(x int) int {\n  u[x] = true\n  i,j := de(x)\n  s := 0\n  for _,y := range g[x] {\n    if u[y] { continue }\n    s += dfs(y)\n  }\n  ans += s*a[i][j]\n  return s+a[i][j]\n}\nfunc en(i,j int) int { return i*n+j }\nfunc de(x int) (int,int) { return x/n,x%n }"
  },
  {
    "language": "Go",
    "code": "package main\nimport \"fmt\"\nvar n int\nvar a,g,c [][]int\nvar ans int\nfunc main() {\n  var s string\n  fmt.Scan(&n)\n  a = make([][]int,n+1)\n  a[n] = make([]int,n+1)\n  c = make([][]int,n)\n  for j:=0;j<n+1;j++ { a[n][j] = -13 }\n  for i:=0;i<n;i++ {\n    a[i] = make([]int,n+1)\n    c[i] = make([]int,n)\n    fmt.Scan(&s)\n    s += \"#\"\n    for j,r := range s { a[i][j] = int(r)-48 }\n  }\n  g = make([][]int,n*n)\n  for i:=0;i<n;i++ {\n    for j:=0;j<n;j++ {\n      if a[i][j] < 0 { continue }\n      x := en(i,j)\n      if a[i][j+1] > 0 { g[x] = append(g[x],en(i,j+1));c[i][j+1]++ }\n      if a[i+1][j] > 0 { g[x] = append(g[x],en(i+1,j));c[i+1][j]++ }\n    }\n  }\n  for k:=0;k<2*n-1;k++ {\n    for i:=0;i<=k;i++ {\n      if i >= n { break }\n      j := k-i\n      if j >= n { continue }\n      if a[i][j] < 0 || c[i][j] > 0 { continue }\n      dfs(en(i,j))\n    }\n  }\n  fmt.Println(ans)\n}\nfunc dfs(x int) (int,map[int]struct{}) {\n  i,j := de(x)\n  if len(g[x]) == 0 {\n    set := make(map[int]struct{})\n    if c[i][j] == 2 { set[x] = struct{}{} }\n    return a[i][j],set\n  }\n  if len(g[x]) == 1 {\n    b,set := dfs(g[x][0])\n    if c[i][j] == 2 { set[x] = struct{}{} }\n    ans += a[i][j]*b\n    return b+a[i][j],set\n  }\n  b0,set0 := dfs(g[x][0])\n  b1,set1 := dfs(g[x][1])\n  b,set := b0+b1,make(map[int]struct{})\n  for k,_ := range set0 {\n    if _,ok := set1[k];ok {\n      id,jd := de(k)\n      b -= a[id][jd]\n      delete(set0,k)\n      delete(set1,k)\n    }\n  }\n  for k,_ := range set0 { set[k] = struct{}{} }\n  for k,_ := range set1 { set[k] = struct{}{} }\n  if c[i][j] == 2 { set[x] = struct{}{} }\n  ans += a[i][j]*b\n  return b+a[i][j],set\n}\nfunc en(i,j int) int { return i*n+j }\nfunc de(x int) (int,int) { return x/n,x%n }"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nX = [[c  for c in input()] for i in range(N)]\ndef reachable(i1,j1,i2,j2):\n    if i1>i2:\n        return 0\n    if j1>j2:\n        return 0\n    if i1==i2 and j1 == j2:\n        return 0\n    T = [[0 for k in range(j2-j1+1)] for k2 in range(i2-i1+1)]\n    T[0][0] = 1\n    for i in range(i1+1,i2+1):\n        if T[i-i1-1][0] == 1 and X[i][j1] != \"#\":\n            T[i-i1][0] = 1\n    for j in range(j1+1,j2+1):\n        if T[0][j-j1-1] == 1 and X[i1][j] != \"#\":\n            T[0][j-j1] = 1\n            \n    for i in range(i1+1,i2+1):\n        for j in range(j1+1,j2+1):\n            if (T[i-i1][j-j1-1] == 1 or T[i-i1-1][j-j1] == 1) and X[i][j] != \"#\":\n                T[i-i1][j-j1] = 1\n    return T[i2-i1][j2-j1]\n\nans = 0\nfor i1 in range(N):\n    for j1 in range(N):\n        if X[i1][j1] != \"#\":\n            for i2 in range(i1, N):\n                for j2 in range(j1, N):\n                    if X[i2][j2] != \"#\":\n                        if reachable(i1,j1,i2,j2)>0:\n                            ans += int(X[i1][j1])*int(X[i2][j2])\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nX = [[c  for c in input()] for i in range(N)]\ndef reachable(i1,j1,i2,j2):\n    if i1>i2:\n        return 0\n    if j1>j2:\n        return 0\n    if i1==i2 and j1 == j2:\n        return 0\n    T = [[0 for k in range(j2-j1+1)] for k2 in range(i2-i1+1)]\n    T[0][0] = 1\n    for i in range(i1+1,i2+1):\n        if T[i-i1-1][0] == 1 and X[i][j1] != \"#\":\n            T[i-i1][0] = 1\n    for j in range(j1+1,j2+1):\n        if T[0][j-j1-1] == 1 and X[i1][j] != \"#\":\n            T[0][j-j1] = 1\n            \n    for i in range(i1+1,i2+1):\n        for j in range(j1+1,j2+1):\n            if (T[i-i1][j-j1-1] == 1 or T[i-i1-1][j-j1] == 1) and X[i][j] != \"#\":\n                T[i-i1][j-j1] = 1\n    return T[i2-i1][j2-j1]\n\nans = 0\nfor i1 in range(N):\n    for j1 in range(N):\n        if X[i1][j1] != \"#\":\n            for i2 in range(i1, N):\n                for j2 in range(j1, N):\n                    if X[i2][j2] != \"#\":\n                        if reachable(i1,j1,i2,j2)>0:\n                            ans += int(X[i1][j1])*int(X[i2][j2])\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "\ndef elongation(edges1, edges2, data, total):\n    new_edges = list()\n    for e1 in edges1:\n        for e2 in edges2:\n            if e1[1] == e2[0]:\n                if [e1[0], e2[1]] not in new_edges:\n                    new_edges.append([e1[0], e2[1]])\n                    total += \\\n                        data[e1[0] // n][e1[0] % n] * data[e2[1] // n][e2[1] % n]\n            else:\n                continue\n    return new_edges, total\n\n\nn = int(input().strip())\n\ndata = list()\n\ntotal = 0\n\nfor i in range(n):\n    data.append([\n        int(x)\n        if x != '#'\n        else x\n        for x in list(input().strip())])\n\nedges = [[]]\n\nfor i in range(n - 1):\n    for j in range(n):\n        if data[i][j] != '#' and data[i + 1][j] != '#':\n            edges[0].append([\n                i * n + j,\n                (i + 1) * n + j])\n            total += data[i][j]*data[i + 1][j]\n        else:\n            continue\n\nfor i in range(n):\n    for j in range(n - 1):\n        if data[i][j] != '#' and data[i][j + 1] != '#':\n            edges[0].append([\n                i * n + j,\n                i * n + j + 1])\n            total += data[i][j]*data[i][j + 1]\n        else:\n            continue\n\nfor i in range(2 * n - 3):\n    new_edges, total = elongation(edges[i], edges[0], data, total)\n    edges.append(new_edges)\n\nprint(total)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n\nmatrix = []\nfor i in range(n):\n\tline = input()\n\tmatrix.append(line)\n\ndef canReachTree(i, j, index_list, tree):\n\ttry:\n\t\tif matrix[i+1][j] != \"#\":\n\t\t\t#print(\"*\", i+1, j)\n\t\t\tif [i+1, j] not in index_list:\n\t\t\t\tindex_list.append([i+1, j])\n\t\t\t\ttree.append(int(matrix[i+1][j]))\n\t\t\tcanReachTree(i+1, j, index_list, tree)\n\texcept:\n\t\tpass\n\ttry:\n\t\tif matrix[i][j+1] != \"#\":\n\t\t\t#print(\"*\", i, j+1)\n\t\t\tif [i, j+1] not in index_list:\n\t\t\t\tindex_list.append([i, j+1])\n\t\t\t\ttree.append(int(matrix[i][j+1]))\n\t\t\tcanReachTree(i, j+1, index_list, tree)\n\texcept:\n\t\tpass\n\tfinally:\n\t\treturn tree\n\nans = 0\nfor i in range(len(matrix)):\n\tfor j in range(len(matrix[0])):\n\t\tindex_list = []\n\t\ttree = []\n\t\tif matrix[i][j] != \"#\":\n\t\t\t#print(\"i,j:\",i,j)\n\t\t\t#print(canReachTree(i, j, tree))\n\t\t\tsigma = sum(canReachTree(i, j, index_list, tree))\n\t\t\tans += int(matrix[i][j]) * sigma\n\t\t\t#print(\"matrix[i][j],sigma:\",matrix[i][j],sigma)\n\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "print(5)"
  },
  {
    "language": "Python",
    "code": "# your code goes here\n# def debug_print(maze):\n#     for xx in maze:\n#         for yy in xx:\n#             print yy,\n#         print \"\\n\",\n\ndef clear_maze(sx, sy, gx, gy, maze):\n\n    INF = 100000000\n\n    field_x_length = len(maze)\n    field_y_length = len(maze[0])\n    distance = [[INF for i in range(field_x_length)] for j in range(field_y_length)]\n    #    distance = [[None]*field_x_length]*field_y_length\n\n    def bfs():\n        queue = []\n\n        queue.insert(0, (sx, sy))\n\n        distance[sx][sy] = 0\n        while len(queue):\n            x, y = queue.pop()\n\n            if x == gx and y == gy:\n                break\n\n            for i in range(0, 2):\n                nx, ny = x + [1, 0][i], y + [0, 1][i]\n\n                if (0 <= nx and nx < field_x_length and 0 <= ny and ny < field_y_length and maze[nx][ny] != '#' and distance[nx][ny] == INF):\n                    queue.insert(0, (nx, ny))\n                    distance[nx][ny] = distance[x][y] + 1\n\n\n        return distance[gx][gy]\n\n    return bfs()\n    \nN = int(input())\nmaze = [list(input()) for i in range(N)]\n\nans = 0\nfor i in range(N*N):\n\tif maze[i//N][i%N] == '#': continue\n\tfor j in range(i+1,N*N):\n\t\tif i%N > j%N or maze[j//N][j%N] == '#': continue\n\t\t# print(i//N,i%N,j//N,j%N,maze)\n\t\ttmp = clear_maze(i//N,i%N,j//N,j%N,maze)\n\t\tif 0 < tmp and tmp < 100000000:\n\t\t\tans += int(maze[i//N][i%N]) * int(maze[j//N][j%N])\n\t\t\nprint(ans)\t\t\n\t\t"
  }
]