[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n\nint board[MAX_N][MAX_N];\nint N;\n\nint is_valid_cell(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < N && board[x][y] > 0;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            char cell[2];\n            scanf(\"%s\", cell);\n            board[i][j] = (cell[0] == '#') ? 0 : cell[0] - '0';\n        }\n    }\n    \n    long long total_sum = 0;\n    \n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            if (!is_valid_cell(x, y)) continue;\n            \n            for (int dx = 0; dx <= 1; dx++) {\n                for (int dy = 0; dy <= 1; dy++) {\n                    if (dx == 0 && dy == 0) continue;\n                    \n                    int nx = x + dx;\n                    int ny = y + dy;\n                    \n                    while (is_valid_cell(nx, ny)) {\n                        total_sum += board[x][y] * board[nx][ny];\n                        nx += dx;\n                        ny += dy;\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", total_sum);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 1000\n\nchar board[MAX_N][MAX_N + 1];\nint prefix_sum[MAX_N][MAX_N];\nint digit[MAX_N][MAX_N];\nint reachable_right[MAX_N][MAX_N];\nint reachable_down[MAX_N][MAX_N];\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", board[i]);\n    }\n\n    // Initialize digit and prefix_sum\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (board[i][j] >= '1' && board[i][j] <= '9') {\n                digit[i][j] = board[i][j] - '0';\n            } else {\n                digit[i][j] = 0;\n            }\n            prefix_sum[i][j] = digit[i][j];\n            if (i > 0) prefix_sum[i][j] += prefix_sum[i - 1][j];\n            if (j > 0) prefix_sum[i][j] += prefix_sum[i][j - 1];\n            if (i > 0 && j > 0) prefix_sum[i][j] -= prefix_sum[i - 1][j - 1];\n        }\n    }\n\n    // Initialize reachable_right and reachable_down\n    for (int i = N - 1; i >= 0; i--) {\n        for (int j = N - 1; j >= 0; j--) {\n            if (board[i][j] == '#') {\n                reachable_right[i][j] = 0;\n                reachable_down[i][j] = 0;\n            } else {\n                if (j < N - 1 && board[i][j + 1] != '#') {\n                    reachable_right[i][j] = reachable_right[i][j + 1] + digit[i][j + 1];\n                } else {\n                    reachable_right[i][j] = 0;\n                }\n                if (i < N - 1 && board[i + 1][j] != '#') {\n                    reachable_down[i][j] = reachable_down[i + 1][j] + digit[i + 1][j];\n                } else {\n                    reachable_down[i][j] = 0;\n                }\n            }\n        }\n    }\n\n    long long total = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (digit[i][j] == 0) continue;\n            int sum = 0;\n            // Sum of all reachable cells to the right and down\n            sum += reachable_right[i][j];\n            sum += reachable_down[i][j];\n            // Sum of all reachable cells in the rectangle below and to the right\n            if (i + 1 < N && j + 1 < N) {\n                int bottom_row = N - 1;\n                int right_col = N - 1;\n                if (board[i + 1][j] == '#' || board[i][j + 1] == '#') continue;\n                sum += prefix_sum[bottom_row][right_col];\n                if (i >= 0) sum -= prefix_sum[i][right_col];\n                if (j >= 0) sum -= prefix_sum[bottom_row][j];\n                if (i >= 0 && j >= 0) sum += prefix_sum[i][j];\n            }\n            total += digit[i][j] * sum;\n        }\n    }\n\n    printf(\"%lld\\n\", total);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> grid(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> grid[i];\n    }\n\n    vector<vector<int>> prefixSum(N, vector<int>(N, 0));\n    vector<vector<int>> digitSum(N, vector<int>(N, 0));\n\n    for (int i = N - 1; i >= 0; --i) {\n        for (int j = N - 1; j >= 0; --j) {\n            if (grid[i][j] == '#') {\n                continue;\n            }\n            int digit = isdigit(grid[i][j]) ? grid[i][j] - '0' : 0;\n            digitSum[i][j] = digit;\n            if (i + 1 < N) {\n                digitSum[i][j] += digitSum[i + 1][j];\n                prefixSum[i][j] += prefixSum[i + 1][j] + digitSum[i + 1][j] * digit;\n            }\n            if (j + 1 < N) {\n                digitSum[i][j] += digitSum[i][j + 1];\n                prefixSum[i][j] += prefixSum[i][j + 1] + digitSum[i][j + 1] * digit;\n            }\n            if (i + 1 < N && j + 1 < N) {\n                digitSum[i][j] -= digitSum[i + 1][j + 1];\n                prefixSum[i][j] -= prefixSum[i + 1][j + 1] + digitSum[i + 1][j + 1] * digit;\n            }\n        }\n    }\n\n    long long total = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] == '#' || !isdigit(grid[i][j])) {\n                continue;\n            }\n            int digit = grid[i][j] - '0';\n            total += prefixSum[i][j] * digit;\n        }\n    }\n\n    cout << total << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.nextLine(); // consume the newline\n        char[][] board = new char[N][N];\n        for (int i = 0; i < N; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < N; j++) {\n                board[i][j] = line.charAt(j);\n            }\n        }\n\n        long sum = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (board[i][j] != '#' && Character.isDigit(board[i][j])) {\n                    int x = board[i][j] - '0';\n                    sum += dfs(board, i, j, x, new boolean[N][N]);\n                }\n            }\n        }\n        System.out.println(sum);\n    }\n\n    private static long dfs(char[][] board, int i, int j, int x, boolean[][] visited) {\n        int N = board.length;\n        visited[i][j] = true;\n        long sum = 0;\n\n        // Move right\n        if (j + 1 < N && board[i][j + 1] != '#' && !visited[i][j + 1]) {\n            if (Character.isDigit(board[i][j + 1])) {\n                int y = board[i][j + 1] - '0';\n                sum += x * y;\n            }\n            sum += dfs(board, i, j + 1, x, visited);\n        }\n\n        // Move down\n        if (i + 1 < N && board[i + 1][j] != '#' && !visited[i + 1][j]) {\n            if (Character.isDigit(board[i + 1][j])) {\n                int y = board[i + 1][j] - '0';\n                sum += x * y;\n            }\n            sum += dfs(board, i + 1, j, x, visited);\n        }\n\n        visited[i][j] = false;\n        return sum;\n    }\n}",
    "timestamp": "2025-08-05 23:02:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int calculateSum(char[][] board) {\n        int N = board.length;\n        int totalSum = 0;\n        boolean[][] visited = new boolean[N][N];\n\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                if (board[x][y] != '#' && board[x][y] != '0') {\n                    dfs(board, x, y, visited, board[x][y] - '0', totalSum);\n                }\n            }\n        }\n\n        return totalSum;\n    }\n\n    private void dfs(char[][] board, int x, int y, boolean[][] visited, int currentDigit, int totalSum) {\n        int N = board.length;\n        visited[x][y] = true;\n\n        // Check moving right\n        for (int j = y + 1; j < N; j++) {\n            if (board[x][j] != '#') {\n                if (board[x][j] != '0') {\n                    totalSum += currentDigit * (board[x][j] - '0');\n                }\n                if (!visited[x][j]) {\n                    dfs(board, x, j, visited, currentDigit, totalSum);\n                }\n            }\n        }\n\n        // Check moving down\n        for (int i = x + 1; i < N; i++) {\n            if (board[i][y] != '#') {\n                if (board[i][y] != '0') {\n                    totalSum += currentDigit * (board[i][y] - '0');\n                }\n                if (!visited[i][y]) {\n                    dfs(board, i, y, visited, currentDigit, totalSum);\n                }\n            }\n        }\n\n        visited[x][y] = false;\n    }\n}",
    "timestamp": "2025-08-05 23:02:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<vector<char>> board(N, vector<char>(N));\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            cin >> board[i][j];\n        }\n    }\n    \n    int totalSum = 0;\n    \n    for(int x = 0; x < N; x++) {\n        for(int y = 0; y < N; y++) {\n            if(board[x][y] >= '1' && board[x][y] <= '9') {\n                for(int r = x; r < N; r++) {\n                    for(int c = (r == x ? y + 1 : 0); c < N; c++) {\n                        if(board[r][c] >= '1' && board[r][c] <= '9') {\n                            if((r > x || (r == x && c > y)) && \n                               (r - x + c - y == 1 || (r > x && c > y && board[r-1][c] == '.' && board[r][c-1] == '.'))) {\n                                totalSum += (board[x][y] - '0') * (board[r][c] - '0');\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << totalSum << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def sum_of_products(board):\n    N = len(board)\n    digit_cells = []\n    \n    # Collect all digit cells\n    for i in range(N):\n        for j in range(N):\n            if board[i][j].isdigit():\n                digit_cells.append((i, j, int(board[i][j])))\n    \n    sum_products = 0\n    \n    # Check reachability and calculate products\n    for (x1, y1, d1) in digit_cells:\n        for (x2, y2, d2) in digit_cells:\n            if (x1 != x2 or y1 != y2) and (x2 > x1 or (x2 == x1 and y2 > y1)):\n                reachable = True\n                # Check if there is a path from (x1, y1) to (x2, y2) only moving right and down\n                for x in range(x1, x2 + 1):\n                    if board[x][y1] == '#':\n                        reachable = False\n                        break\n                for y in range(y1 + 1, y2 + 1):\n                    if board[x2][y] == '#':\n                        reachable = False\n                        break\n                \n                if reachable:\n                    sum_products += d1 * d2\n    \n    return sum_products\n\n# Example usage:\nboard = [\n    ['1', '.', '.', '#', '2'],\n    ['.', '.', '3', '.', '.'],\n    ['#', '.', '4', '#', '.'],\n    ['.', '5', '.', '.', '.'],\n    ['6', '.', '.', '.', '7']\n]\n\nprint(sum_of_products(board))",
    "timestamp": "2025-08-13 13:21:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class ReachableCellsSum {\n    public static int sumOfProducts(char[][] board) {\n        int n = board.length;\n        int[][] rightDigits = new int[n][n];\n        int[][] downDigits = new int[n][n];\n        \n        // Fill rightDigits matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = n - 2; j >= 0; j--) {\n                if (board[i][j] != '#' && board[i][j + 1] != '#') {\n                    rightDigits[i][j] = rightDigits[i][j + 1];\n                    if (Character.isDigit(board[i][j + 1])) {\n                        rightDigits[i][j] += board[i][j + 1] - '0';\n                    }\n                }\n            }\n        }\n        \n        // Fill downDigits matrix\n        for (int i = n - 2; i >= 0; i--) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] != '#' && board[i + 1][j] != '#') {\n                    downDigits[i][j] = downDigits[i + 1][j];\n                    if (Character.isDigit(board[i + 1][j])) {\n                        downDigits[i][j] += board[i + 1][j] - '0';\n                    }\n                }\n            }\n        }\n\n        int sum = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (Character.isDigit(board[i][j])) {\n                    int digit = board[i][j] - '0';\n                    sum += digit * (rightDigits[i][j] + downDigits[i][j]);\n                }\n            }\n        }\n        \n        return sum;\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {\n            {'1', '2', '#', '4'},\n            {'#', '3', '4', '#'},\n            {'5', '#', '6', '#'},\n            {'#', '#', '7', '8'}\n        };\n        System.out.println(\"Sum of products: \" + sumOfProducts(board));\n    }\n}",
    "timestamp": "2025-08-13 13:21:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char board[N][N];\n    int digits[N][N];\n\n    // Read board and extract digits\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%s\", board[i]);\n        for (int j = 0; j < N; ++j) {\n            digits[i][j] = (board[i][j] >= '1' && board[i][j] <= '9') ? (board[i][j] - '0') : 0;\n        }\n    }\n\n    long long sum = 0;\n\n    // Calculate the sum of products for all reachable pairs\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (board[i][j] == '#') continue;\n            int current_digit = digits[i][j];\n\n            // Check cells to the right\n            for (int k = j + 1; k < N && board[i][k] != '#'; ++k) {\n                if (digits[i][k] != 0) {\n                    sum += current_digit * digits[i][k];\n                }\n            }\n\n            // Check cells downward\n            for (int k = i + 1; k < N && board[k][j] != '#'; ++k) {\n                if (digits[k][j] != 0) {\n                    sum += current_digit * digits[k][j];\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", sum);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:21:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function sumOfProducts(board) {\n    const N = board.length;\n    let sum = 0;\n    \n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            if (isDigit(board[i][j])) {\n                const digitX = parseInt(board[i][j]);\n\n                // Move right\n                for (let right = j + 1; right < N; right++) {\n                    if (isDigit(board[i][right])) {\n                        const digitY = parseInt(board[i][right]);\n                        sum += digitX * digitY;\n                    }\n                    if (board[i][right] === '#') break;\n                }\n\n                // Move down\n                for (let down = i + 1; down < N; down++) {\n                    if (isDigit(board[down][j])) {\n                        const digitY = parseInt(board[down][j]);\n                        sum += digitX * digitY;\n                    }\n                    if (board[down][j] === '#') break;\n                }\n            }\n        }\n    }\n\n    return sum;\n}\n\nfunction isDigit(cell) {\n    return cell >= '1' && cell <= '9';\n}",
    "timestamp": "2025-08-13 13:21:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solution(board):\n    N = len(board)\n    total_sum = 0\n\n    def is_valid_cell(x, y):\n        return 0 <= x < N and 0 <= y < N and board[x][y] != '#'\n\n    def is_digit(x, y):\n        return board[x][y] != '#' and board[x][y] != '.'\n\n    for x in range(N):\n        for y in range(N):\n            if is_digit(x, y):\n                digit_x = int(board[x][y])\n                \n                # Check cells to the right\n                for nx in range(x, N):\n                    for ny in range(y + 1, N):\n                        if is_valid_cell(nx, ny) and is_digit(nx, ny):\n                            digit_y = int(board[nx][ny])\n                            total_sum += digit_x * digit_y\n\n                # Check cells below\n                for nx in range(x + 1, N):\n                    for ny in range(y, N):\n                        if is_valid_cell(nx, ny) and is_digit(nx, ny):\n                            digit_y = int(board[nx][ny])\n                            total_sum += digit_x * digit_y\n\n    return total_sum",
    "timestamp": "2025-08-13 13:22:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function sumOfProducts(board) {\n    const N = board.length;\n    let totalSum = 0;\n\n    for (let x = 0; x < N; x++) {\n        for (let y = 0; y < N; y++) {\n            if (board[x][y] === '#') continue;\n            \n            const start = parseInt(board[x][y]);\n            \n            for (let dx = x; dx < N; dx++) {\n                for (let dy = (dx === x ? y + 1 : 0); dy < N; dy++) {\n                    if (board[dx][dy] === '#') continue;\n                    \n                    const end = parseInt(board[dx][dy]);\n                    \n                    if (isReachable(board, x, y, dx, dy)) {\n                        totalSum += start * end;\n                    }\n                }\n            }\n        }\n    }\n    \n    return totalSum;\n}\n\nfunction isReachable(board, x1, y1, x2, y2) {\n    if (x1 === x2 && y1 === y2) return false;\n    \n    if (x1 > x2 || (x1 === x2 && y1 > y2)) {\n        [x1, y1, x2, y2] = [x2, y2, x1, y1];\n    }\n    \n    for (let x = x1; x <= x2; x++) {\n        for (let y = (x === x1 ? y1 : 0); y <= (x === x2 ? y2 : board.length - 1); y++) {\n            if (board[x][y] === '#') return false;\n        }\n    }\n    \n    return true;\n}",
    "timestamp": "2025-08-13 13:22:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline())\n    grid = [sys.stdin.readline().strip() for _ in range(N)]\n    \n    # Precompute reachability and digits\n    digits = [[0]*N for _ in range(N)]\n    reachable = [[0]*N for _ in range(N)]\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] != '#':\n                digits[i][j] = int(grid[i][j]) if grid[i][j].isdigit() else 0\n    \n    total = 0\n    \n    # Iterate each cell X (i,j)\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '#':\n                continue\n            x_val = digits[i][j]\n            if x_val == 0:\n                continue\n            \n            # BFS or DP to find reachable cells Y (k,l) from (i,j)\n            # Using DP approach to count reachable cells\n            dp = [[0]*N for _ in range(N)]\n            dp[i][j] = 1  # starting point\n            \n            for k in range(i, N):\n                for l in range(j, N):\n                    if k == i and l == j:\n                        continue\n                    if grid[k][l] == '#':\n                        continue\n                    ways = 0\n                    if k > i and dp[k-1][l] > 0:\n                        ways += dp[k-1][l]\n                    if l > j and dp[k][l-1] > 0:\n                        ways += dp[k][l-1]\n                    dp[k][l] = ways\n            \n            # Sum the products for reachable cells\n            for k in range(N):\n                for l in range(N):\n                    if dp[k][l] > 0 and (k != i or l != j):\n                        y_val = digits[k][l]\n                        if y_val > 0:\n                            total += x_val * y_val\n    \n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 13:22:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function sumReachableProducts(board) {\n    const N = board.length;\n    let sum = 0;\n\n    for (let x1 = 0; x1 < N; x1++) {\n        for (let y1 = 0; y1 < N; y1++) {\n            if (board[x1][y1] === '#' || isNaN(board[x1][y1])) continue;\n            const digitX = parseInt(board[x1][y1], 10);\n\n            // BFS to find all reachable cells (Y) from (x1, y1)\n            const visited = new Array(N).fill().map(() => new Array(N).fill(false));\n            const queue = [[x1, y1]];\n            visited[x1][y1] = true;\n\n            while (queue.length > 0) {\n                const [x, y] = queue.shift();\n\n                // Check right neighbor\n                if (y + 1 < N && !visited[x][y + 1] && board[x][y + 1] !== '#') {\n                    visited[x][y + 1] = true;\n                    queue.push([x, y + 1]);\n                    const digitY = parseInt(board[x][y + 1], 10);\n                    sum += digitX * digitY;\n                }\n\n                // Check down neighbor\n                if (x + 1 < N && !visited[x + 1][y] && board[x + 1][y] !== '#') {\n                    visited[x + 1][y] = true;\n                    queue.push([x + 1, y]);\n                    const digitY = parseInt(board[x + 1][y], 10);\n                    sum += digitX * digitY;\n                }\n            }\n        }\n    }\n\n    return sum;\n}",
    "timestamp": "2025-08-13 13:22:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint sumProductPairs(const vector<string>& board) {\n    int N = board.size();\n    vector<vector<int>> digits(N, vector<int>(N, 0));\n    vector<vector<int>> rightSum(N, vector<int>(N, 0));\n    vector<vector<int>> downSum(N, vector<int>(N, 0));\n    \n    // Parse the board and convert characters to digits.\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (board[i][j] != '#') {\n                digits[i][j] = board[i][j] - '0';\n            }\n        }\n    }\n\n    // Calculate sum of digits for right reachable cells.\n    for (int i = 0; i < N; ++i) {\n        for (int j = N - 2; j >= 0; --j) {\n            if (board[i][j] != '#' && board[i][j + 1] != '#') {\n                rightSum[i][j] += digits[i][j + 1] + rightSum[i][j + 1];\n            }\n        }\n    }\n\n    // Calculate sum of digits for down reachable cells.\n    for (int i = N - 2; i >= 0; --i) {\n        for (int j = 0; j < N; ++j) {\n            if (board[i][j] != '#' && board[i + 1][j] != '#') {\n                downSum[i][j] += digits[i + 1][j] + downSum[i + 1][j];\n            }\n        }\n    }\n\n    // Calculate the total sum of products.\n    int totalSum = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (board[i][j] != '#') {\n                totalSum += digits[i][j] * rightSum[i][j];\n                totalSum += digits[i][j] * downSum[i][j];\n            }\n        }\n    }\n\n    return totalSum;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> board(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> board[i];\n    }\n    \n    cout << sumProductPairs(board) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:39:16"
  }
]