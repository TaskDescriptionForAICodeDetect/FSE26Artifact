[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std ;\n\ntypedef pair<int,int>ii;\n\n#define F first\n#define S second\n#define si(x) scanf(\"%d\",&x)\n#define rep(i,n,m) for(int i = n; i < m; i++)\n#define uu first\n#define vv second\n#define ll unsigned long long\n\nvector<int>gra[100007];\nint n,sz[100005];\nint vis[100007],cnt[100005];\nint level[100007];\nint mxl ;\n\n#define pii pair<int,int >\n\nint bfs(int src)\n{\n    mxl = -1;\n    vis[src]=1 ;\n    level[src]=0;\n    queue<int>q ;\n    q.push(src);\n\n    while(!q.empty())\n    {\n        int top = q.front();\n        q.pop();\n\n        int l = gra[top].size();\n\n        for(int i=0 ; i<l ; i++)\n        {\n            int tx = gra[top][i];\n\n            if(vis[tx]==0)\n            {\n                vis[tx]=1 ;\n                level[tx]=level[top]+1 ;\n                mxl = max(mxl , level[tx]);\n                q.push(tx);\n            }\n        }\n\n\n    }\n\n}\nvector<pii>v ;\nint ans[100007];\nint dep[100007];\n\nint dfs2(int src)\n{\n    if(dep[src]!=-1) return dep[src];\n    int l = gra[src].size();\n    if(l==0)return  dep[src]=1;\n\n    int s = 0;\n    for(int i = 0 ; i<l ; i++)\n    {\n        s=max(s,dfs2(gra[src][i]));\n    }\n\n    return dep[src]=s+1 ;\n\n}\nint dfs(int src )\n{\n    sz[src] = 1;\n    //level[src]=l;\n\n    rep(i,0,gra[src].size()){\n        int v = gra[src][i];\n        dfs(v);\n        sz[src] += sz[v];\n\n    }\n    //v.push_back(pii(l,sz[src]));\n}\n\n\n\n\nint main()\n{\n    memset(dep,-1,sizeof dep);\n    cin>>n;\n\n    for(int i =0 ; i<n-1 ; i++)\n    {\n        int u,v ;\n\n        cin>>u>>v ;\n\n        gra[u].push_back(v);\n    }\n    bfs(1);\n    dfs(1);\n    dfs2(1);\n\n    rep(i,1,n+1){\n        cnt[sz[i]]++;\n    }\n    //sort(v.begin(),v.end());\n\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        v.push_back(pii(dep[i],sz[i]));\n    }\n    /*\n    for(int i=1 ; i<=n ; i++)\n    {\n        cout<<dep[i]<<\" \";\n    }cout<<endl;\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        cout<<sz[i]<<\" \";\n\n    }\n    cout<<endl;\n    */\n\n\n    sort(v.begin(),v.end());\n\n    ll ansf=0,temp = 1;\n    for(int i=0; i<n-1 ; i++)\n    {\n        //cout<<v[i].first<<\" \"<<v[i].second<<\" \"<<v[i+1].first<<\" \"<<v[i+1].second;\n\n        if(v[i].uu == v[i+1].uu && v[i].vv == v[i+1].vv){ temp++;}// cout<<\"s\"<<temp<<endl;}\n        else{ ansf+= temp*(temp-1)/2 ; temp=1 ;}// cout<<\"y\"<<ansf<<endl;}\n\n\n\n    }\n\n    if(temp > 0) ansf+= temp*(temp-1)/2 ;\n    //cout<<ansf<<endl;\n\n    printf(\"%llu\\n\",ansf);\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=100005,INF=1<<30;\nll ans=0;\nvector<int> G[MAX];\nll rui[MAX],revrui[MAX];\n\nmap<ll,int> MA;\n\nll DFS(int u,int p,int d){\n    \n    ll ha=rui[d];\n    \n    for(int to:G[u]){\n        if(to==p) continue;\n        \n        ha+=DFS(to,u,d+1);\n        ha%=mod;\n    }\n    \n    ha*=revrui[d];\n    ha%=mod;\n    \n    if(MA.count(ha)) ans+=MA[ha];\n    MA[ha]++;\n    \n    ha*=rui[d];\n    ha%=mod;\n    \n    return ha;\n}\n\nll ru(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N-1;i++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    \n    rui[0]=1;\n    revrui[0]=1;\n    \n    for(int i=1;i<MAX;i++){\n        rui[i]=rui[i-1]*100003;\n        rui[i]%=mod;\n        \n        revrui[i]=ru(rui[i],mod-2);\n    }\n    \n    DFS(0,-1,0);\n    \n    cout<<ans<<endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define base 100000\n#define mod1 1000000007\n#define mod2 1000000123\n#define MAX 1000000\n#define base 123456\n#define ll  long long\nusing namespace std;\nll bm(ll a , ll p,ll m)\n{\n    if(p==0) return 1;\n    ll x = bm(a,p/2,m);\n    x*=x;\n    x%=m;\n    if(p&1) return (x*a)%m;\n    return x;\n}\nstruct haash\n{\n    long long value1;\n    long long value2;\n    long long depth;\n    haash()\n    {\n        value1=value2=depth=0;\n    }\n    bool operator==(const haash a) const\n    {\n        return (value2==a.value2 && depth==a.depth && value1 == a.value1);\n    }\n    haash operator+(haash a)\n    {\n        haash c;\n        c.depth = max(depth,a.depth);\n        if(depth>a.depth)\n        {\n            a.value1 = a.value1*bm(base,abs(depth-a.depth),mod1);\n            a.value2 = a.value2*bm(base,abs(depth-a.depth),mod2);\n            a.value1%=mod1;\n            a.value2%=mod2;\n        }\n        else\n        {\n            value1 = value1*bm(base,abs(depth-a.depth),mod1);\n            value2 = value2*bm(base,abs(depth-a.depth),mod2);\n            value1%=mod1;\n            value2%=mod2;\n\n        }\n        c.value1 = (a.value1+value1)%mod1;\n        c.value2 = (a.value2+value2)%mod2;\n        return c;\n    }\n    bool operator<(const haash a) const\n    {\n\n\n    }\n\n};\n\n\nvector  < int > G[MAX];\nhaash h[MAX];\nmap < pair  < ll , ll > , ll  > m;\nbool vis[MAX];\nint n;\nvoid dfs(int n)\n{\n  //  cout<<n<<endl;\n    haash a,b;\n    vis[n]=1;\n    ll maxh=1;\n    for(int i=0; i<G[n].size(); i++)\n    {\n        int x= G[n][i];\n        if(!vis[x] )\n        {\n            dfs(x);\n            maxh = max(maxh,h[x].depth+1);\n            a = a + h[x];\n\n        }\n    }\n    b.depth = maxh;\n    b.value1=1;\n    b.value2=1;\n    b.value1*=bm(base,maxh-1,mod1);\n    b.value2*=bm(base,maxh-1,mod2);\n    b.value1%=mod1;\n    b.value2%=mod2;\n    b = a + b ;\n\n    h[n]=b;\n    m[make_pair(b.value1,b.value2)]++;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1; i<n; i++)\n    {\n        int  u , v;\n        scanf(\"%d %d\",&u,&v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1);\n\n    long long ans=0;\n    map < pair  < ll , ll > , ll  > ::iterator it = m.begin();\n    while(it!=m.end())\n    {\n        long long x = (it)->second;\n        ans += (x*x-x)/2;\n        it++;\n    }\n    printf(\"%lld\\n\",ans);\n\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nll N;\nvector<ll> paths[100000];\nmap<l_l, ll> mp;\nll p0 = 1e9 + 7;\nll p1 = 4e9 + 7;\nll b0 = 18254964;\nll b1 = 14852534;\nll ans;\n\n\nl_l dfs(int now, int from) {\n    l_l val = {1, 1};\n    for(auto to : paths[now]) {\n        if(to == from) continue;\n        auto tmp = dfs(to, now);\n        tmp.first *= b0;\n        tmp.second *= b1;\n        val.first += tmp.first;\n        val.second += tmp.second;\n    }\n    val.first %= p0;\n    val.second %= p1;\n    ans += mp[val];\n    mp[val]++;\n    return val;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    for(int i = 0; i < N - 1; i++) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        paths[a].push_back(b);\n        paths[b].push_back(a);\n    }\n    dfs(0, -1);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef ONLINE_JUDGE\n    #define gc getchar\n    #define pc putchar\n#else\n    #define gc getchar_unlocked\n    #define pc putchar_unlocked\n#endif\n\nusing namespace std;\n\n#define vi vector<int>\n#define vll vector<i64>\n#define si set<int>\n#define vs vector<string>\n#define pii pair<int,int>\n#define vpi vector<pii>\n#define pri priority_queue<int>\n#define rev_pri priority_queue<int,vector<int>,greater<int> >\n#define mpi map<int,int>\n#define i64 long long int\n#define endl '\\n'\n#define pi acos(-1)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define For(i,n) for(int i=0;i<n;i++)\n#define Fre(i,a,b) for(int i = a; i < b; i++)\n#define sf(n) scanf(\"%d\", &n)\n#define sff(a,b) scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define pfn(n) printf(\"%d\\n\", n)\n#define pfs(n) printf(\"%d \", n)\n#define eps 1e-8\n#define ff first\n#define ss second\n#define mem(a,b) memset(a,b,sizeof(a))\n#define min3(a,b,c) min(a,min(b,c))\n#define max3(a,b,c) max(a,max(b,c))\n#define READ freopen(\"in.txt\", \"r\", stdin)\n#define WRITE freopen(\"out.txt\", \"w\", stdout)\n#define sz size()\n#define dbg(i) printf(\"yo %d\\n\", i)\n#define foreach(i,c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define sqr(a) (a) * (a)\n#define clr clear()\n#define CASE(a) printf(\"Case %d: \",a)\n\n//int dx[] = {0,1,0,-1,1,1,-1,-1};\n//int dy[] = {1,0,-1,0,1,-1,-1,1};\n//i64 dp[60][60];\n\n\n//functions\n\n//i64 gcd(i64 a,i64 b){if(!b)return a;return gcd(b,a%b);}\n\n//inline void fastRead(int *a){register char c=0;while(c<33)c=gc();*a=0;while(c>33){*a=*a*10+c-'0';c=gc();}}\n\n//inline void fastWrite(int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)pc(snum[i--]);pc('\\n');}\n\n//i64 bigmod(i64 num,i64 n){if(n==0)return 1;i64 x=bigmod(num,n/2);x=x*x%mod;if(n%2==1)x=x*num%mod;return x;}\n\n//i64 modinverse(i64 num){return bigmod(num,mod-2)%mod;}\n\n//void combination(int pos,int last){if(pos==k+1){for(int i=1;i<=k;i++)cout << tem[i];cout << endl;return;}\n//for(int i=last+1;i<=n-k+pos;i++){tem[pos] = num[i-1];combination(pos+1,i);}}\n\n//i64 po(i64 a,i64 b){i64 ans=1;while(b--)ans *= a;return ans;}\n\n//i64 ncr(i64 n,i64 r){if(n==r)return 1;if(r==1)return n;if(dp[n][r]!=-1)return dp[n][r];return dp[n][r]=ncr(n-1,r)+ncr(n-1,r-1);}\n\n//int popcount(i64 num){bitset<70> tem(num);return tem.count();}\n\n//matrix rot(matrix a){matrix res;res.row = a.col;res.col = a.row;For(i,a.row)For(j,a.col)res.mat[j][a.row-i-1] = a.mat[i][j];return res;}\n\n#define bs 19\nvi v[100005];\ni64 hs[100005];\n\nvoid dfs(int s)\n{\n        hs[s] = 1;\n\n        For(i,v[s].sz)\n        {\n                int w = v[s][i];\n                dfs(w);\n                hs[s] += (bs * hs[w]) % mod;\n                hs[s] %= mod;\n        }\n}\n\n\nint main()\n{\n\n        //ios_base::sync_with_stdio(false);cin.tie(0);\n        int n,x,y;\n        sf(n);\n        For(i,n-1)\n        {\n                sff(x,y);\n                v[x].pb(y);\n        }\n\n        dfs(1);\n\n        map<i64,i64> m;\n        i64 ans = 0;\n\n        Fre(i,1,n+1)\n                m[hs[i]]++;\n\n        foreach(i,m)\n                ans += (i->ss * (i->ss - 1) )/ 2;\n\n        cout << ans << endl;\n\n\n\n\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nmap<pair<ll, ll>, int> mm;\nll ans = 0;\n\nll mod1 = 1000000087;\nll mod2 = 1000000021;\nll mul1 = 999999893;\nll mul2 = 999999929;\n\nvector<int> G[SIZE];\n\npair<ll, ll> dfs(int now, int back = -1) {\n  ll hash1 = 0, hash2 = 0;\n\n  for (int to : G[now]) {\n    if (to == back) continue;\n\n    auto p = dfs(to, now);\n\n    hash1 += p.first;\n    hash2 += p.second;\n  }\n\n  hash1 = ((hash1 % mod1 * mul1) + 1) % mod1;\n  hash2 = ((hash2 % mod2 * mul2) + 1) % mod2;\n\n  pair<ll, ll> hash = {hash1, hash2};\n\n  ans += mm[hash];\n  mm[hash]++;\n\n  return hash;\n}\n\nint main(){\n  int N;\n\n  scanf(\"%d\", &N);\n\n  for (int i=0; i+1<N; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    a--; b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  dfs(0);\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define MOD 1000000007\n#define DOM 1000000009\n#define BASE 1000000021\n\nusing P = pair<int,pair<long,long>>;\n// depth, hash1, hash2\n\nvector<int> tree[100005];\nmap<pair<int,pair<long,long>>,int> memo;\n\nP dfs(int v, int from){\n  long h1 = 1, h2=1;\n  int d = 1;\n  for(auto to : tree[v]) if(to!=from){\n    P p = dfs(to,v);\n    d = max(d, p.fi+1);\n    h1 += p.se.fi*MOD;\n    h1 %= BASE;\n    h2 += p.se.se*DOM;\n    h2 %= BASE;\n  }\n  P p = mp(d,mp(h1,h2));\n  memo[p]++;\n  return p;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    tree[a].pb(b);\n    tree[b].pb(a);\n  }\n\n  dfs(0,-1);\n\n  long ans = 0;\n  for(auto &p : memo){\n    ans += p.se * (p.se-1) / 2;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\n//内積、 dot(a,b) = |a||b|cos()\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//外積、cross(a,b) = |a||b|sin()\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//線分と点の距離\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\n//線分の交差判定\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\n//線分の交点\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\n//線分と線分の距離\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\n//円と円の交点\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor(){\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a){\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this -> data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this -> data[i][0]) * (obj.data[0][q]);\n                for(int t = 1;t < obj.data[i].size();++t){\n                    hoge += this -> data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix &operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b): value(((a%b) + 2 * b) % b),mod(b) {\n\n    }\n    modint operator+(const modint rhs) const{\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const{\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const{\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value *  rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\ntemplate<typename A,typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost){\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n){\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0&&level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s,int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nvector<int> vertexs[200000];\nmap<int, int> dping;\nint ans = 0;\npair<modint,modint> dfs(int now, int back) {\n    \n    pair<modint, modint> cnt = pair<modint, modint>{ modint(0, MAX_MOD), modint(0, MOD) };\n    for (auto x : vertexs[now]) {\n        if (x == back) continue;\n        pair<modint, modint> gogo = dfs(x, now);\n        cnt.first += gogo.first;\n        cnt.second += gogo.second;\n    }\n    cnt.first *= modint(100001, MAX_MOD);\n    cnt.second *= modint(100001, MOD);\n    cnt.first += modint(1, MAX_MOD);\n    cnt.second += modint(1, MOD);\n    ans += dping[cnt.first.value * MAX_MOD + cnt.second.value];\n    dping[cnt.first.value * MAX_MOD + cnt.second.value]++;\n    return cnt;\n}\nvoid solve() {\n    int n;\n    cin >> n;\n    REP(i, n - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    dfs(0, -1);\n    cout << ans << endl;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n\tHash(){\n\t\thash_value = 0;\n\t\tnum = 0;\n\t\tleft_child = right_child = -1;\n\t}\n\tull hash_value;\n\tint num,left_child,right_child;\n};\n\nclass HashTree{\npublic:\n\tHashTree(int size){\n\t\thash = new Hash[size];\n\t\tnum_of_node = 0;\n\t}\n\n\tvoid addHash(ull value){\n\t\tif(num_of_node == 0){\n\t\t\thash[0].hash_value = value;\n\t\t\thash[0].num = 1;\n\t\t\tnum_of_node++;\n\t\t\treturn;\n\t\t}else{\n\t\t\tint index = 0;\n\n\t\t\twhile(true){\n\t\t\t\tif(value == hash[index].hash_value){\n\t\t\t\t\thash[index].num++;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(value > hash[index].hash_value){\n\t\t\t\t\tif(hash[index].right_child == -1){\n\t\t\t\t\t\thash[index].right_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].right_child;\n\t\t\t\t\t}\n\t\t\t\t}else{ //value < hash[index].hash_value\n\t\t\t\t\tif(hash[index].left_child == -1){\n\t\t\t\t\t\thash[index].left_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].left_child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull calc_ans(){\n\t\tull sum = 0;\n\n\t\tfor(int i = 0; i < num_of_node; i++){\n\t\t\tfor(int k = 1; k <= hash[i].num-1; k++){ //hash[i].numC2????¨????\n\t\t\t\t\tsum += k;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tHash* hash;\n\tint num_of_node;\n};\n\nstruct Node{\n\tNode(){\n\t\tparent = -1;\n\t}\n\n\t//vector<int> S,children;\n\tvector<int> S;\n\tvector<int> children;\n\tint parent;\n};\n\nNode* node;\n\nvector<int> calc(int node_id){\n\n\tvector<int> Ret;\n\tRet.push_back(node[node_id].children.size()); //node[node_id]??????????????±???1?????????????????°??????????????°??????????????????\n\n\tfor(int i = 0; i < node[node_id].children.size();i++){\n\t\tvector<int> tmp = calc(node[node_id].children[i]); //????????????vector?????°???\n\t\tfor(int k = 0; k < tmp.size(); k++){\n\t\t\tif(k+1 >= Ret.size()){ //?????????????????????????????????????????\\????????´?????????????¶???? size()???A?????????vector????????????????????????0???A-1\n\t\t\t\tRet.push_back(tmp[i]);\n\t\t\t}else{\n\t\t\t\tRet[k+1] += tmp[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Ret.size(); i++){\n\t\tnode[node_id].S.push_back(Ret[i]);\n\t}\n\treturn Ret;\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tnode = (Node*)malloc(sizeof(Node)*(N+1));\n\n\tint parent,child;\n\tfor(int i = 0; i < N-1; i++){\n\t\tscanf(\"%d %d\",&parent,&child);\n\t\tnode[parent].children.push_back(child);\n\t\tnode[child].parent = parent;\n\t}\n\n\t//?????????????????????????????±?????¨????????°????¨???????????????£??????\n\tcalc(1);\n\n\tHashTree HT(N);\n\n\tull pre,current;\n\n\t//??±?????????????????°????????????hash?????????\n\tfor(int i = 2; i <= N; i++){\n\t\tpre = 0;\n\t\tcurrent = 0;\n\t\tfor(int k = 0; k < node[i].S.size();k++){\n\t\t\tcurrent = node[i].S[k] + pre*MOD;\n\t\t\tpre = current;\n\t\t}\n\t\tHT.addHash(current);\n\t}\n\n\tprintf(\"%lld\\n\",HT.calc_ans());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<cmath>\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nconst ll base = 999983;\nconst int maxn = 1e5+5;\nint n,ind[maxn];\nvector<ll> htable;\nvector<int> G[maxn];\n\nll dfs(int u)\n{\n    ll temp = 0;\n    for(int i=0;i<G[u].size();++i){\n        temp += dfs(G[u][i]);\n    }\n    htable.push_back(temp*base+G[u].size());\n    return temp*base+G[u].size();\n}\n\ninline ll work(ll m)\n{\n    return m*(m-1)>>1;\n}\n\nint main()\n{\n    while(~scanf(\"%d\",&n)){\n        htable.clear();\n        memset(ind,0,sizeof ind);\n        for(int i=0;i<=n;++i) G[i].clear();\n        for(int i=0;i<n-1;++i){\n            int u,v; scanf(\"%d%d\",&u,&v);\n            G[u].push_back(v);\n            ++ind[v];\n        }\n        int s = 0;\n        for(int i=1;i<=n && !s;++i){\n            if(ind[i] == 0) s = i;\n        }\n        dfs(s);\n        sort(htable.begin(),htable.end());\n        ll num = 1;\n        ll ans = 0;\n        for(int i=1;i<htable.size();++i){\n            if(htable[i] != htable[i-1]){\n                ans += work(num);\n                num = 1;\n            }\n            else ++num;\n        }\n        if(htable.size() > 1 && htable[htable.size()-1] == htable[htable.size()-2]) ans += work(num);\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, n) for(int i = (a); i < (n); i++)\n#define REP(i, n) FOR(i, 0, (n))\n#define ALL(a) (a.begin(), a.end())\ntypedef vector<int> vi;\n\nint64_t h(const vector<vi> &t, int i, int p, vi &v) {\n    int64_t res = 1;\n    for (int c : t[i]) {\n        if (c == p) continue;\n        res += 1000000009 * h(t, c, i, v);\n    }\n    v[i] = res;\n    return res;\n}\n\nint main() {\n    int n;\n    cin>>n;\n    vector<vi> t(n);\n    REP(i,n-1) {\n        int a,b;\n        cin>>a>>b;\n        --a;\n        --b;\n        t[a].push_back(b);\n        t[b].push_back(a);\n    }\n    vi v(n);\n    h(t, 0, -1, v);\n    map<int64_t, int> m;\n    int64_t cnt = 0;\n    REP(i,n) {\n        cnt += m[v[i]];\n        ++m[v[i]];\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);++(i))\nusing namespace std;\n \ntemplate<class T>bool chmax(T& a, const T& b) { return (a < b) ? (a = b, 1) : 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { return (a > b) ? (a = b, 1) : 0; }\n \nusing ull=unsigned long long;\nconst ull B1=1000000003LL;\nconst ull B2=1000000009LL;\n \nconst int limit=200010;\null P1[limit],P2[limit];\n \n \nvector<int> tree[100010];\nmap<ull,int> num;\nint sub[100010];\n \nint dmax=0;\n \null dfs(int v,int p){\n\tull cur=0;\n\tfor(auto &v2:tree[v]){\n\t\tif(v2==p) continue;\n\t\tcur+=dfs(v2,v);\n\t}\n \n\t//sort(begin(ary),end(ary));\n\t//for(auto &it:ary) cur=cur*P1[2*get<1>(it)]+get<0>(it);\n \n\tcur=cur*B1+1;\n\t//sub[v]+=1;\n \n\tnum[cur]++;\t\n\treturn cur;\n}\n \nint main(void){\n\tP1[0]=1LL,P2[0]=1LL;\n\tfor(int i=1;i<limit;++i) P1[i]=P1[i-1]*B1,P2[i]=P2[i-1]*B2;\n \n \n\tint n;\n\tcin >> n;\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\ttree[a].push_back(b);\n\t}\n \n\tdfs(0,-1);\n \n\tull ans=0LL;\n\tfor(auto &it:num){\n\t\t//cout << it.second << endl;\n\t\tull cur=it.second;\n\t\tans+=cur*(cur-1)/2LL;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mst(a,b) memset(a,b,sizeof(a))\n#define cmax(a,b) a = max(a,b)\n#define ft first\n#define sd second\n#define mp(a,b) make_pair(a,b)\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 1e5+19;\nconst LL maxp = 1e9+7;\nconst LL PP = 1e9+9;\n\nstruct edge{\n\tint v,p;\n\tedge(){}\n\tedge(int V,int P):v(V),p(P){}\n}e[maxn<<1];\n\nint n,lst[maxn],ed;\nmap<int,int> hash;\n\nvoid init() {\n\tmst(lst,-1);ed = -1;\n}\n\nvoid add_edge(int u,int v) {\n\te[++ed] = edge(v,lst[u]);lst[u] = ed;\n\te[++ed] = edge(u,lst[v]);lst[v] = ed;\n}\n\nLL solve(int u,int fa) {\n\tint v;\n\tLL tmp = 1;\n\tfor(int i = lst[u] ; ~i ; i = e[i].p) {\n\t\tv = e[i].v;\n\t\tif(v != fa) \n\t\t\ttmp = (tmp+solve(v,u)*PP%maxp)%maxp;\n\t}\n\thash[tmp] = hash[tmp]+1;\n\treturn tmp;\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d\",&n);\n\tint x,y;\n\tfor(int i = 1 ; i < n ; ++i) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd_edge(x,y);\n\t}\n\tsolve(1,-1);\n\tLL ans = 0;\n\tfor(map<int,int>::iterator i = hash.begin() ; i != hash.end() ; ++i) \n\t\tans += (LL)i->second*(LL)(i->second-1)/2;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n    Hash(){\n        hash_value = 0;\n        num = 0;\n        left_child = right_child = -1;\n    }\n    ull hash_value;\n    ull num,left_child,right_child;\n};\n\nstruct HashTree{\npublic:\n    void init(int size){\n        hash = new Hash[size];\n        num_of_node = 0;\n    }\n\n    void addHash(ull value){\n        if(num_of_node == 0){\n            hash[0].hash_value = value;\n            hash[0].num = 1;\n            num_of_node++;\n            return;\n        }else{\n            int index = 0;\n\n            while(true){\n                if(value == hash[index].hash_value){\n                    hash[index].num++;\n                    return;\n                }else if(value > hash[index].hash_value){\n                    if(hash[index].right_child == -1){\n                        hash[index].right_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].right_child;\n                    }\n                }else{ //value < hash[index].hash_value\n                    if(hash[index].left_child == -1){\n                        hash[index].left_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].left_child;\n                    }\n                }\n            }\n        }\n    }\n\n    ull calc_ans(){\n        ull sum = 0;\n\n        for(int i = 0; i < num_of_node; i++){\n        \tsum += (hash[i].num)*(hash[i].num-1)/2;\n        }\n        return sum;\n    }\n\n    Hash* hash;\n    int num_of_node;\n};\n\nstruct Node{\n    vector<int> children;\n    int parent;\n};\n\nNode* node;\nHashTree HT;\n\null calc(int node_id){\n\n    ull Ret = 1;\n    ull child;\n\n    for(int i = 0; i < node[node_id].children.size();i++){\n        child = calc(node[node_id].children[i]);\n        Ret = (Ret+child*MOD)%MOD;\n    }\n\n    HT.addHash(Ret);\n\n    return Ret;\n}\n\nint main(){\n\n    int N;\n    scanf(\"%d\",&N);\n\n    node = (Node*)malloc(sizeof(Node)*(N+1));\n    HT.init(N);\n\n    int parent,child;\n    for(int i = 0; i < N-1; i++){\n        scanf(\"%d %d\",&parent,&child);\n        node[parent].children.push_back(child);\n        node[child].parent = parent;\n    }\n\n    calc(1);\n\n    printf(\"%lld\\n\",HT.calc_ans());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e9+7;\nconst int K = 37;\nvector<int> e[N];\nvector<ll> hs;\nint d[N], f[N];\n\n\nvoid pre_dfs(int u, int dep){\n  if(u==0) return;\n  d[u] = max(d[u], dep);\n  pre_dfs(f[u], dep+1);\n}\n\nll dfs(int u){\n  ll ret = 17;\n  for(auto v: e[u]){\n    ret = (ret+K*dfs(v))%M;\n  }\n  hs.push_back((d[u]+1)*ret);\n  return ret;\n}\n\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    d[u]++;\n    f[v] = u;\n    e[u].push_back(v);\n  }\n  for(int i = 1; i <= n; i++) if(!d[i]) pre_dfs(i, 0);\n  dfs(1);\n  ll ans = 0;\n  sort(hs.begin(), hs.end());\n  for(int i = 0; i < hs.size(); i++){\n    int s = i;\n    while(i < hs.size() && hs[i+1] == hs[i]) i++;\n    ans += (i-s+1)*(i-s)/2;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvi g;\n\tmap<ull,ll> m;\n\tvi used;\n\tull dfs(int v){\n\t\tused[v]=1;\n\t\tull H=1;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tint u=g[v][i];\n\t\t\tif(!used[u]) H+=dfs(u)*mod;\n\t\t}\n\t\tm[H]++;\n\t\treturn H;\n\t}\n\tpublic:\n\tGraph(int v){\n\t\tV=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\tll solve(){\n\t\tll res=0;\n\t\tused=vi(V);\n\t\tdfs(0);\n\t\tfor(auto i=m.begin();i!=m.end();i++){\n\t\t\tll v=i->second;\n\t\t\tres+=v*(v-1)/2;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n;\n\nint main(){\n\tcin>>n;\n\tGraph g(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tg.add_edge(u-1,v-1);\n\t}\n\tcout<<g.solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nll N;\nvector<ll> E[100000];\nmap<pll, ll> cnt;\n\npll dfs(ll v, ll p) {\n  const ll mod1 = 1000000007;\n  const ll mod2 = 1000000009;\n\n  pll ret = pll(1, 1);\n  for(ll u : E[v]) if(u != p) {\n    pll x = dfs(u, v);\n    (ret.fi += x.fi * 12345 % mod1) %= mod1;\n    (ret.se += x.se * 12345 % mod2) %= mod2;\n  }\n  cnt[ret]++;\n\n  return ret;\n}\n\nint main(void) {\n  cin >> N;\n  REP(i, 0, N - 1) {\n    ll A, B; cin >> A >> B; A--; B--;\n    E[A].push_back(B);\n    E[B].push_back(A);\n  }\n\n  dfs(0, -1);\n\n  ll ans = 0;\n  for(auto p : cnt) {\n    ll x = p.second;\n    ans += x * (x - 1) / 2;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nusing ll = long long;\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nconstexpr ll MOD1 = 1e9 + 7;\nconstexpr ll MOD2 = 1e9 + 9;\nconstexpr ll BASE1 = 1e6 + 7;\nconstexpr ll BASE2 = 1e6 + 9;\nusing P = pair<ll, ll>;\nmap<P, int> num;\n\nP dfs(const Graph& g, const int s, vector<bool>& used)\n{\n    used[s] = true;\n    P ans = {1, 1};\n    for (const int to : g.edge[s]) {\n        if (not used[to]) {\n            const P sub = dfs(g, to, used);\n            (ans.first += sub.first * BASE1) %= MOD1;\n            (ans.second += sub.second * BASE2) %= MOD2;\n        }\n    }\n    num[ans]++;\n    return ans;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    Graph g(N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g.addEdge(a, b);\n        g.addEdge(b, a);\n    }\n    vector<bool> used(N, false);\n    dfs(g, 0, used);\n    ll ans = 0;\n    for (const auto& e : num) {\n        const ll n = e.second;\n        ans += (n * (n - 1)) / 2;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n    Hash(){\n        hash_value = 0;\n        num = 0;\n        left_child = right_child = -1;\n    }\n    ull hash_value;\n    int num,left_child,right_child;\n};\n\nstruct HashTree{\npublic:\n    void init(int size){\n        hash = new Hash[size];\n        num_of_node = 0;\n    }\n\n    void addHash(ull value){\n        if(num_of_node == 0){\n            hash[0].hash_value = value;\n            hash[0].num = 1;\n            num_of_node++;\n            return;\n        }else{\n            int index = 0;\n\n            while(true){\n                if(value == hash[index].hash_value){\n                    hash[index].num++;\n                    return;\n                }else if(value > hash[index].hash_value){\n                    if(hash[index].right_child == -1){\n                        hash[index].right_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].right_child;\n                    }\n                }else{ //value < hash[index].hash_value\n                    if(hash[index].left_child == -1){\n                        hash[index].left_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].left_child;\n                    }\n                }\n            }\n        }\n    }\n\n    ull calc_ans(){\n        ull sum = 0;\n\n        for(int i = 0; i < num_of_node; i++){\n        \tsum += (hash[i].num)*(hash[i].num-1)/2;\n        }\n        return sum;\n    }\n\n    Hash* hash;\n    int num_of_node;\n};\n\nstruct Node{\n    vector<int> children;\n    int parent;\n};\n\nNode* node;\nHashTree HT;\n\nvector<int> calc(int node_id){\n\n    vector<int> Ret;\n    Ret.push_back(node[node_id].children.size());\n\n    for(int i = 0; i < node[node_id].children.size();i++){\n        vector<int> tmp = calc(node[node_id].children[i]);\n        for(int k = 0; k < tmp.size(); k++){\n            if(k+1 >= Ret.size()){\n                Ret.push_back(tmp[k]);\n            }else{\n                Ret[k+1] += tmp[k];\n            }\n        }\n    }\n\n    ull pre = 0,current = 0;\n\n    for(int i = 0; i < Ret.size(); i++){\n        current = Ret[i] + pre*MOD;\n        pre = current;\n    }\n    HT.addHash(current);\n\n    return Ret;\n}\n\nint main(){\n\n    int N;\n    scanf(\"%d\",&N);\n\n    node = (Node*)malloc(sizeof(Node)*(N+1));\n    HT.init(N);\n\n    int parent,child;\n    for(int i = 0; i < N-1; i++){\n        scanf(\"%d %d\",&parent,&child);\n        node[parent].children.push_back(child);\n        node[child].parent = parent;\n    }\n\n    calc(1);\n\n    printf(\"%lld\\n\",HT.calc_ans());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(...) cerr<<\"[\"<<#__VA_ARGS__\":\"<<(__VA_ARGS__)<<\"]\"<<endl;\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<double,int> PII;\nconst ll p=998244353;\nconst ll mod=1e9+7;\nconst int maxn=1e5+100;\nmap<ll,int> mp;\n\nstruct node\n{\n    int to,next;\n}e[maxn*2];\n\nint tol=0;\nint head[maxn];\nvoid add(int u,int v)\n{\n    e[++tol].to=v,e[tol].next=head[u],head[u]=tol;\n}\nll dfs(int u,int f)\n{\n    ll ans=1;\n    for(int i=head[u];i;i=e[i].next)\n    {\n        int v=e[i].to;\n        if(v==f) continue;\n        ans=(ans+dfs(v,u)*mod%p)%p;\n    }\n    mp[ans]++;\n    return ans;\n}\n\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    rep(i,1,n)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        add(u,v),add(v,u);\n    }\n    mp.clear();\n    dfs(1,0);\n    ll ans=0;\n    map<ll,int>::iterator it;\n    for(it=mp.begin();it!=mp.end();it++) ans+=1ll*(it->se)*(it->se-1)/2;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\nusing namespace std;\ntypedef unsigned long long LL;\nconst LL maxn=1e6+10,p=11,mod=1e9+7;\nvector<LL>G[maxn];\nLL hash_v[maxn];\nmap<LL,LL>mp;\nmap<LL,LL>::iterator it;\n\nvoid dfs(LL u)\n{\n    hash_v[u]=1;\n    for(LL i=0; i<G[u].size(); i++)\n    {\n        LL v=G[u][i];\n        dfs(v);\n        hash_v[u]=(hash_v[u]+hash_v[v]*p)%mod;\n    }\n    mp[hash_v[u]]++;\n}\nint main()\n{\n   ///freopen(\"in.txt\",\"r\",stdin);\n    LL n;\n    LL u,v;\n    while(scanf(\"%lld\",&n)!=-1)\n    {\n        for(LL i=0; i<=n; i++)\n        G[i].clear();\n        mp.clear();\n        for(LL i=1; i<n; i++)\n        {\n            scanf(\"%lld%lld\",&u,&v);\n            G[u].push_back(v);\n        }\n        dfs(1);\n        LL ans=0;\n        for(it=mp.begin(); it!=mp.end(); it++)\n            ans+=it->second*(it->second-1)/2;\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull base = 998244353;\nint n, a, b; vector<vector<int> > G; map<ull, int> cnt;\null solve(int pos, int pre) {\n\tull ret = 1;\n\tfor (int i : G[pos]) {\n\t\tif (i == pre) continue;\n\t\tret += solve(i, pos) * base;\n\t}\n\tcnt[ret]++;\n\treturn ret;\n}\nint main() {\n\tcin >> n; G.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b; a--, b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tsolve(0, -1);\n\tull ret = 0;\n\tfor (pair<ull, int> i : cnt) ret += 1LL * i.second * (i.second - 1) / 2;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst double PI = acos(-1.0);\nconst int INF=0x3f3f3f3f;\nconst int N=1e5+9;\n\nconst ll MOD=37;\n\nstruct node{\n\tint id, num, dep;\n\tnode (int x, int y, int z) {\n\t\tid=x, num=y, dep=z;\n\t}\n};\n\nint t1, t2;\nll ans, a[N], b[N], c[N], vis[N], h[N], cnt[N], m[N];\nvi v[N], u[N];\nmap<ll, ll> ma;\n\n\n\nvoid func(){\n\tb[1]=1;\n\tfor(int i=2; i<N; i++)\n\t\tb[i]=b[i-1]*MOD;\n}\n\nint main(void){\n\t//if(fopen(\"in\", \"r\")!=NULL) {freopen(\"in\", \"r\", stdin); freopen(\"out\", \"w\", stdout);}\n\t//printf(\"std:%lld\\n\", MOD*MOD+MOD+1+MOD*MOD*MOD);\n\tfunc();\n\tint n;\n\twhile(cin>>n){\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tv[i].clear();\n\t\t\tu[i].clear();\n\t\t}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tscanf(\"%d%d\", &t1, &t2);\n\t\t\tv[t1].push_back(t2);\n\t\t\tv[t2].push_back(t1);\n\t\t}\n\t\tmemset(vis, 0, sizeof vis);\n\t\tmemset(cnt, 0, sizeof cnt);\n\t\tmemset(m, 0, sizeof m);\n\t\tmemset(h, 0, sizeof h);\n\t\tqueue<node> que;\n//\t\tfor(int i=1; i<=n; i++)\n//\t\t\tprintf(\"%d \\n\", v[i].size());\n\t\tfor(int i=2; i<=n; i++)\n\t\t\tif(v[i].size()==1){\n\t\t\t\tque.push(node(i, 0, 1));\n\t\t\t\tvis[i]=1;\n\t\t\t\ta[i]=1;\n\t\t\t\tm[i]=1;\n\t\t\t\tma[1]++;\n\t\t\t}\n//\t\tfor(int i=1; i<=n; i++)\n//\t\t\tprintf(\"%d \\n\", vis[i]);\n\t//\tfor(map<ll, ll>::iterator it=ma.begin(); it!=ma.end(); it++){\n\t//\t\tprintf(\"%lld %lld\\n\", it->x, it->y);\n\t//\t//\tll t=it->y;\n\t//\t//\tans+=t*(t-1)/2;\n\t//\t}\n\t\t//printf(\"c:%d\\n\", ma[1]);\n\t\twhile(!que.empty()){\n\t\t\tll id=que.front().id, num=que.front().num, dep=que.front().dep; que.pop();\n\t\t\t//printf(\"t:%lld %lld\\n\", id, dep);\n\t\t\tfor(int i=0; i<v[id].size(); i++){\n\t\t\t\tint fa=v[id][i];\n\t\t\t\tif(vis[fa] || fa==1) continue;\n\t\t\t\tcnt[fa]++;\n\t\t\t\tif(m[fa]<dep+1){\n\t\t\t\t\ta[fa]*=b[dep+1-m[fa]];\n\t\t\t\t\ta[fa]+=a[id];\n\t\t\t\t\tm[fa]=dep+1;\n\t\t\t\t}\n\t\t\t\telse if(m[fa]>=dep+1){\n\t\t\t\t\tll t1=a[id]*b[m[fa]-(dep+1)];\n\t\t\t\t\ta[fa]+=t1;\n\t\t\t\t}\n\t\t\t\t//\tif(fa==2)\n\t\t\t\t//\t\tprintf(\"t:%lld %lld %lld\\n\", a[fa], m[fa], a[id]);\n\t\t\t\tif(cnt[fa]==v[fa].size()-1){\n\t\t\t\t\tvis[fa]=1;\n\t\t\t\t\ta[fa]+=b[m[fa]];\n\t\t\t\t\tma[a[fa]]++;\n\t\t\t\t\t//printf(\"%d %lld\\n\", fa, a[fa]);\n\t\t\t\t\tque.push(node(fa, 0, m[fa]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tans=0;\n\t\tfor(map<ll, ll>::iterator it=ma.begin(); it!=ma.end(); it++){\n\t\t\t//printf(\"%lld %lld\\n\", it->x, it->y);\n\t\t\tll t=it->y;\n\t\t\tans+=t*(t-1)/2;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef ONLINE_JUDGE\n    #define gc getchar\n    #define pc putchar\n#else\n    #define gc getchar_unlocked\n    #define pc putchar_unlocked\n#endif\n\nusing namespace std;\n\n#define vi vector<int>\n#define vll vector<i64>\n#define si set<int>\n#define vs vector<string>\n#define pii pair<int,int>\n#define vpi vector<pii>\n#define pri priority_queue<int>\n#define rev_pri priority_queue<int,vector<int>,greater<int> >\n#define mpi map<int,int>\n#define i64 long long int\n#define endl '\\n'\n#define pi acos(-1)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define For(i,n) for(int i=0;i<n;i++)\n#define Fre(i,a,b) for(int i = a; i < b; i++)\n#define sf(n) scanf(\"%d\", &n)\n#define sff(a,b) scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define pfn(n) printf(\"%d\\n\", n)\n#define pfs(n) printf(\"%d \", n)\n#define eps 1e-8\n#define ff first\n#define ss second\n#define mem(a,b) memset(a,b,sizeof(a))\n#define min3(a,b,c) min(a,min(b,c))\n#define max3(a,b,c) max(a,max(b,c))\n#define READ freopen(\"in.txt\", \"r\", stdin)\n#define WRITE freopen(\"out.txt\", \"w\", stdout)\n#define sz size()\n#define dbg(i) printf(\"yo %d\\n\", i)\n#define foreach(i,c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define sqr(a) (a) * (a)\n#define clr clear()\n#define CASE(a) printf(\"Case %d: \",a)\n\n//int dx[] = {0,1,0,-1,1,1,-1,-1};\n//int dy[] = {1,0,-1,0,1,-1,-1,1};\n//i64 dp[60][60];\n\n\n//functions\n\n//i64 gcd(i64 a,i64 b){if(!b)return a;return gcd(b,a%b);}\n\n//inline void fastRead(int *a){register char c=0;while(c<33)c=gc();*a=0;while(c>33){*a=*a*10+c-'0';c=gc();}}\n\n//inline void fastWrite(int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)pc(snum[i--]);pc('\\n');}\n\ni64 bigmod(i64 num,i64 n)\n{\n        if(n==0)\n                return 1;\n        i64 x=bigmod(num,n/2);\n        x=x*x%mod;\n        if(n%2==1)\n                x=x*num%mod;\n        return x;\n}\n\n//i64 modinverse(i64 num){return bigmod(num,mod-2)%mod;}\n\n//void combination(int pos,int last){if(pos==k+1){for(int i=1;i<=k;i++)cout << tem[i];cout << endl;return;}\n//for(int i=last+1;i<=n-k+pos;i++){tem[pos] = num[i-1];combination(pos+1,i);}}\n\ni64 po(i64 a,i64 b){i64 ans=1;while(b--)ans *= a;return ans;}\n\n//i64 ncr(i64 n,i64 r){if(n==r)return 1;if(r==1)return n;if(dp[n][r]!=-1)return dp[n][r];return dp[n][r]=ncr(n-1,r)+ncr(n-1,r-1);}\n\n//int popcount(i64 num){bitset<70> tem(num);return tem.count();}\n\n//matrix rot(matrix a){matrix res;res.row = a.col;res.col = a.row;For(i,a.row)For(j,a.col)res.mat[j][a.row-i-1] = a.mat[i][j];return res;}\n\n\n#define p1 41\n\nvi v[100005];\ni64 lev[100005];\ni64 val[100005];\n\nvoid dfs(int s,int l)\n{\n        lev[s] = l;\n        For(i,v[s].sz)\n                if(lev[v[s][i]]==-1)\n                        dfs(v[s][i],l+1);\n}\nint main()\n{\n\n        //ios_base::sync_with_stdio(false);cin.tie(0);\n        int n,m,x,y;\n        sf(n);\n\n        For(i,n-1)\n        {\n                sff(x,y);\n                v[x].pb(y);\n                v[y].pb(x);\n        }\n\n        mem(lev,-1);\n        dfs(1,1);\n        vpi nodes;\n        Fre(i,1,n+1)\n                nodes.pb(mp(lev[i],i));\n\n        sort(all(nodes));\n        reverse(all(nodes));\n\n        For(i,nodes.sz)\n        {\n                int u = nodes[i].ss;\n                int l = nodes[i].ff;\n                if(u!=1)\n                        val[u] =  ( (val[u] * bigmod(49157,l)) % mod + (i64)v[u].sz - 1 + mod ) % mod;\n                else\n                        val[u] =  ( (val[u] * bigmod(49157,l)) % mod + (i64)v[u].sz ) % mod;\n                For(i,v[u].sz)\n                {\n                        int w = v[u][i];\n                        if(lev[w]<l)\n                        {\n                                val[w] = (val[w] + val[u] ) % mod;\n                                break;\n                        }\n                }\n        }\n        map < i64, int > mpans;\n        Fre(i,1,n+1)\n                mpans[val[i]]++;\n        i64 ans = 0;\n        foreach(i,mpans)\n        {\n                i64 n = i->ss;\n                ans += n*(n-1)/2;\n        }\n\n        cout << ans << endl;\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#include <vector>\n#define inputt int t;cin>>t;\n#define pi acos(-1.0)\n#define lson o*2,l,m\n#define rson o*2+1,m+1,r\n#define INF 0x7f7f7f7f\n#define lowbit(X) ((X)&(-X))\n#define clr(X,Y) memset(X,Y,sizeof(X))\ntypedef long long ll;\nusing namespace std;\nvector<int>G[100005];\nunordered_map<int,int>mp;\nconst ll mod = 1000000007;\nll dfs(ll now){\n\tll tmp=0;\n\tint len=G[now].size();\n\tfor(int i=0;i<len;i++){\n\t\ttmp=(tmp+dfs(G[now][i]))%mod;\n\t}\n\ttmp=((tmp*100000%mod)+1)%mod;\n\tmp[tmp]++;\n\treturn tmp;\n}\nint main(){\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tG[x].push_back(y);\n\t}\n\tdfs(1);\n\tlong long ans=0;\n\tfor(auto i:mp){\n\t\tans+=(1+(i.second-1))*(i.second-1)/2;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long M = 9999999999971;\nconst long long MC = 100013;\nconst int N = 100010;\n\nmap<long long, int> H;\nlong long pw[N];\n\nint dp[N];\nlong long sz[N];\nvector<int> adj[N];\nvoid dfs(int u, int pr) {\n\tfor (auto v: adj[u]) {\n\t\tif (v == pr) continue;\n\t\tdp[v] = dp[u] + 1;\n\t\tdfs(v, u);\n\t\tsz[u] = (sz[u] + sz[v]) % M;\n\t}\n\tsz[u] = (sz[u] * MC + 1) % M;\n}\n\nint main() {\n\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\tios_base::sync_with_stdio(0);\n\tfor (int i = 0; i <= 100000; i++) pw[i] = (i == 0) ? 1LL : (pw[i-1] * MC % M);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tfor (int i = 1; i <= n; i++) H[sz[i]] ++;\n\tlong long ans = 0;\n\tfor (auto it: H) {\n\t\tint v = it.second;\n\t\tans += 1LL * v * (v-1) / 2;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n \n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n \ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\ntypedef vector<vector<int>> Graph;\n \ntypedef unsigned long long ull;\nconst ull B = 1e9 + 7;\n \nint N;\nGraph G;\nmap<ull, int> cnt; // {hash, num}\n \null dfs(int v) {\n    ull ret = 1;\n    for (auto nxt : G[v]) {\n        ret += dfs(nxt) * B;\n    }\n    cnt[ret]++;\n    return ret;\n}\n \nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n \n    cin >> N;\n    G.resize(N);\n    rep(i, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        G[a].emplace_back(b);\n    }\n \n    dfs(0);\n \n    int ans = 0;\n    for (auto p : cnt) {\n        ans += p.second * (p.second - 1) / 2;\n    }\n \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e9+7;\nconst int K = 103;\nvector<int> e[N];\nvector<ll> hs;\nint d[N], f[N];\n\n\nvoid pre_dfs(int u, int dep){\n  if(u==0) return;\n  d[u] = max(d[u], dep);\n  pre_dfs(f[u], dep+1);\n}\n\nll dfs(int u){\n  ll ret = 17;\n  for(auto v: e[u]){\n    ret = (ret+K*dfs(v))%M;\n  }\n  hs.push_back((d[u]+1)*ret);\n  return ret;\n}\n\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    d[u]++;\n    f[v] = u;\n    e[u].push_back(v);\n  }\n  for(int i = 1; i <= n; i++) if(!d[i]) pre_dfs(i, 0);\n  dfs(1);\n  ll ans = 0;\n  sort(hs.begin(), hs.end());\n  for(int i = 0; i < hs.size(); i++){\n    int s = i;\n    while(i < hs.size() && hs[i+1] == hs[i]) i++;\n    ans += (i-s+1)*(i-s)/2;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst unsigned long long base = 111111;\n\nunsigned long long rec(int v, const vector< vector<int> > &t,\n\t\t       unordered_map<unsigned long long, int> &num){\n  unsigned long long res = 1;\n  for(int u : t[v]){\n    res += rec(u,t,num) * base;\n  }\n  \n  num[res]++;\n  return res;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  vector< vector<int> > tree(n);\n  for(int i=0;i<n-1;i++){\n    int a,b; cin >> a >> b; a--; b--;\n    tree[a].emplace_back(b);\n  }\n\n  unordered_map<unsigned long long, int> num;\n  rec(0,tree,num);\n\n  long long ans = 0;\n  for(auto x : num){\n    ans += (long long)x.second * (x.second-1) / 2;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#include <vector>\n#define inputt int t;cin>>t;\n#define pi acos(-1.0)\n#define lson o*2,l,m\n#define rson o*2+1,m+1,r\n#define INF 0x7f7f7f7f\n#define lowbit(X) ((X)&(-X))\n#define clr(X,Y) memset(X,Y,sizeof(X))\ntypedef long long ll;\nusing namespace std;\nvector<int>G[100005];\nunordered_map<int,int>mp;\nconst ll mod = 284910501;\nll dfs(ll now){\n\tll tmp=0;\n\tint len=G[now].size();\n\tfor(int i=0;i<len;i++){\n\t\ttmp=(tmp+dfs(G[now][i]))%mod;\n\t}\n\ttmp=((tmp*100000%mod)+1)%mod;\n\tmp[tmp]++;\n\treturn tmp;\n}\nint main(){\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tG[x].push_back(y);\n\t}\n\tdfs(1);\n\tlong long ans=0;\n\tfor(auto i:mp){\n\t\tans+=(1+(i.second-1))*(i.second-1)/2;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define maxn 1e9+7\nusing namespace std;\n\nmap<LL,LL>p;\nvector<int> g[100010];\nLL dfs(int x)\n{\n    int m=((int)g[x].size()) ;\n    LL ans=1;\n    for(int i=0; i<m; i++)\n    {\n        ans += dfs(g[x][i])*maxn;\n    }\n    p[ans]++;\n    return ans;\n}\nvoid init()\n{\n    for(int i=0; i<100010; i++)\n        g[i].clear();\n    p.erase(p.begin(),p.end());\n}\nint main()\n{\n    int n;\n    while(~scanf(\"%d\",&n))\n    {\n        int f,s;\n        init();\n        for(int i=0; i<n-1; i++)\n        {\n            scanf(\"%d%d\",&f,&s);\n            g[f].push_back(s);\n        }\n        dfs(1);\n        LL ans = 0;\n        for(map<LL,LL>::iterator it = p.begin(); it!=p.end(); it++)\n        {\n            LL a=(*it).second;\n            ans += a*(a-1)/2;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll mod = 1e9 + 7;\nconst ll b = 117;\n\nvector<int> G[100000];\nint used[100000];\n\nll hs[100000];\n\nll dfs(int n) {\n\tused[n] = 1;\n\tll res = 1;\n\tfor (auto v : G[n]) {\n\t\tif (!used[v]) {\n\t\t\tres = (res + dfs(v) * b) % mod;\n\t\t}\n\t}\n\treturn hs[n] = res;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tfor (int i = 0, a, b; i < N - 1; i++) {\n\t\tcin >> a >> b;\n\t\tG[a - 1].push_back(b - 1);\n\t\tG[b - 1].push_back(a - 1);\n\t}\n\tdfs(0);\n\tsort(hs, hs + N);\n\tll res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tauto p = equal_range(hs, hs + N, hs[i]);\n\t\tres += p.second - p.first - 1;\n\t}\n\tcout << res / 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 111111\ntypedef unsigned long long ull;\null MOD=1000000007LL;\nvector<int> G[MAX_N];\nint n;\nmap<ull,ull> m;\null dfs(int p){\n  ull res=1LL;\n  for(int i=0;i<(int)G[p].size();i++)\n    res+=dfs(G[p][i])*MOD;\n  m[res]++;\n  return res;\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    int a,b;\n    cin>>a>>b;\n    G[a].push_back(b);\n  }\n  dfs(1);\n  ull ans=0;\n  for(auto i:m) ans+=i.second*(i.second-1)/2;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n\tHash(){\n\t\thash_value = 0;\n\t\tnum = 0;\n\t\tleft_child = right_child = -1;\n\t}\n\tull hash_value;\n\tint num,left_child,right_child;\n};\n\nstruct HashTree{\npublic:\n\tvoid init(int size){\n\t\thash = new Hash[size];\n\t\tnum_of_node = 0;\n\t}\n\n\tvoid addHash(ull value){\n\t\tif(num_of_node == 0){\n\t\t\thash[0].hash_value = value;\n\t\t\thash[0].num = 1;\n\t\t\tnum_of_node++;\n\t\t\treturn;\n\t\t}else{\n\t\t\tint index = 0;\n\n\t\t\twhile(true){\n\t\t\t\tif(value == hash[index].hash_value){\n\t\t\t\t\thash[index].num++;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(value > hash[index].hash_value){\n\t\t\t\t\tif(hash[index].right_child == -1){\n\t\t\t\t\t\thash[index].right_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].right_child;\n\t\t\t\t\t}\n\t\t\t\t}else{ //value < hash[index].hash_value\n\t\t\t\t\tif(hash[index].left_child == -1){\n\t\t\t\t\t\thash[index].left_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].left_child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull calc_ans(){\n\t\tull sum = 0;\n\n\t\tfor(int i = 0; i < num_of_node; i++){\n\t\t\tfor(int k = 1; k <= hash[i].num-1; k++){ //hash[i].numC2????¨????\n\t\t\t\t\tsum += k;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tHash* hash;\n\tint num_of_node;\n};\n\nstruct Node{\n\tvector<int> children;\n\tint parent;\n\tull Hash;\n};\n\nNode* node;\nHashTree HT;\n\null calc(int node_id){\n\n\tull pre = 0,current = 0;\n\n\tfor(int i = 0; i < node[node_id].children.size();i++){\n\t\tcurrent = calc(node[node_id].children[i])+pre*MOD;\n\t\tpre = current;\n\t}\n\n\tcurrent += node[node_id].children.size();\n\n\tHT.addHash(current);\n\n\treturn current;\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tnode = (Node*)malloc(sizeof(Node)*(N+1));\n\tHT.init(N);\n\n\tint parent,child;\n\tfor(int i = 0; i < N-1; i++){\n\t\tscanf(\"%d %d\",&parent,&child);\n\t\tnode[parent].children.push_back(child);\n\t\tnode[child].parent = parent;\n\t}\n\n\t//?????????????????????????????±?????¨????????°????¨???????????????£??????\n\tcalc(1);\n\n\tprintf(\"%lld\\n\",HT.calc_ans());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst int M = 1307;\nconst int K = 7;\nvector<int> e[N];\nint d[N], f[N];\nint hs[N][M];\n\nvoid pre_dfs(int u, int dep){\n  if(u==0) return;\n  d[u] = max(d[u], dep);\n  pre_dfs(f[u], dep+1);\n}\n\nll dfs(int u){\n  ll ret = 17;\n  for(auto v: e[u]){\n    ret = (ret+K*dfs(v)+M)%M;\n  }\n  hs[d[u]][ret]++;\n  return ret;\n}\n\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    d[u]++;\n    f[v] = u;\n    e[u].push_back(v);\n  }\n  for(int i = 1; i <= n; i++) if(!d[i]) pre_dfs(i, 0);\n  dfs(1);\n  ll ans = 0;\n  for(int i = 0; i < N; i++) for(int j = 0; j < M; j++) ans += (ll)hs[i][j]*(hs[i][j]-1)/2;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint b=67280421310721,n,a,c,ans;//21387612863821\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res+=dfs(v[x][i]);\n  res*=b;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nusing ull = unsigned long long;\nconstexpr int MAX = 100000;\nconstexpr ull B = 1007;\n\nvector<int> G[MAX];\nmap<ull, int> mp;\n\null dfs(int v)\n{\n    ull res = 1;\n    int n = G[v].size();\n    for (int i = 0; i < n; i++) {\n        res += dfs(G[v][i]) * B;\n    }\n    mp[res]++;\n    return res;\n}\n\null solve()\n{\n    dfs(0);\n    ull res = 0;\n    for (auto x : mp) {\n        if (x.second >= 2) {\n            res += x.second * (x.second - 1) / 2;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        G[a].emplace_back(b);\n    }\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[100010];\nint size[100010];\n//const int mod=1e9;\n//int p=7301;\nint dfs(int a,int n)\n{\n\tint i,cur=0;\n\tif(E[a].size()==0)\n\t{\n\t\tsize[a]=1;//叶子\n\t\treturn 1;\n\t}\n\tfor(i=0;i<E[a].size();i++)\n\t{\n\t\tint v=E[a][i];\n\tcur+=dfs(v,n);\n//\t\t\tsize[a]=(size[a]+p*dfs(v))%mod;\n\t}\n\tsize[a]=1+cur*n;\n//\tsize[a]=(cur+size[a])%mod;\n\treturn size[a];\n}\nint C(int n,int x)\n{//从n中?x个\n\tif(n<x)\n\t\treturn 0;\n\treturn n*(n-1)/x;\n}\n\n\nint main()\n{\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tmemset(size,0,sizeof(size));\n\t\tint a,b;\n\t\tint i;\n\t\tfor(i=1;i<n;i++)\n\t\t{\n\t\t scanf(\"%d%d\",&a,&b);\n\t\t E[a].push_back(b);\n\t\t}\n\t\tdfs(1,n);\n\t\tsort(size+1,size+n+1);\n\t\tint ans=0;\n\t\tint sum=1;\n\t\tfor(i=2;i<=n;i++)\n\t\t{\n\t\t\tif(size[i]==size[i-1])\n\t\t\t\tsum++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tans+=C(sum,2);\n\t\t\t\tsum=1;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t\tE[i].clear();\n\t\t/*\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=i+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(size[i]==size[j])\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef ONLINE_JUDGE\n    #define gc getchar\n    #define pc putchar\n#else\n    #define gc getchar_unlocked\n    #define pc putchar_unlocked\n#endif\n\nusing namespace std;\n\n#define vi vector<int>\n#define si set<int>\n#define vs vector<string>\n#define pii pair<int,int>\n#define vpi vector<pii>\n#define pri priority_queue<int>\n#define rev_pri priority_queue<int,vector<int>,greater<int> >\n#define mpi map<int,int>\n#define i64 long long int\n#define endl '\\n'\n#define pi acos(-1)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define inf INT_MAX/2\n#define infll LLONG_MAX/3\n#define For(i,n) for(int i=0;i<n;i++)\n#define Fre(i,a,b) for(int i = a; i < b; i++)\n#define sf(n) scanf(\"%d\", &n)\n#define sff(a,b) scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define pfn(n) printf(\"%d\\n\", n)\n#define pfs(n) printf(\"%d \", n)\n#define eps 1e-8\n#define ff first\n#define ss second\n#define mem(a,b) memset(a,b,sizeof(a))\n#define READ freopen(\"in.txt\", \"r\", stdin)\n#define WRITE freopen(\"out.txt\", \"w\", stdout)\n#define sz size()\n#define dbg(i) printf(\"yo %d\\n\", i)\n#define foreach(i,c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define sqr(a) (a) * (a)\n#define clr clear()\n#define CASE(a) printf(\"Case %d: \",a)\n\n//int dx[] = {0,1,0,-1,1,1,-1,-1};\n//int dy[] = {1,0,-1,0,1,-1,-1,1};\n\n\n//i64 gcd(i64 a,i64 b){if(!b)return a;return gcd(b,a%b);}\n\n//inline void fastRead(int *a){register char c=0;while(c<33)c=gc();*a=0;while(c>33){*a=*a*10+c-'0';c=gc();}}\n\n//inline void fastWrite(int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)pc(snum[i--]);pc('\\n');}\n\n//i64 bigmod(i64 num,i64 n){if(n==0)return 1;i64 x=bigmod(num,n/2);x=x*x%mod;if(n%2==1)x=x*num%mod;return x;}\n\n//i64 modinverse(i64 num){return bigmod(num,mod-2)%mod;}\n\n//i64 po(i64 a,i64 b){i64 ans=1;while(b--)ans *= a;return ans;}\n\n//i64 ncr(i64 n,i64 r){if(n==r)return 1;if(r==1)return n;if(dp[n][r]!=-1)return dp[n][r];return dp[n][r]=ncr(n-1,r)+ncr(n-1,r-1);}\n\n\n// bit manipulations\n\n//bool checkbit(int mask,int bit){return mask & (1<<bit);}\n\n//int setbit(int mask,int bit){ return mask  (1<<bit) ; }\n\n//int clearbit(int mask,int bit){return mask & ~(1<<bit);}\n\n//int togglebit(int mask,int bit){return mask ^ (1<<bit);}\n\n#define mxn 100005\n#define mod1 1000000007\n#define mod2 1000000009\n#define p1 33\n#define p2 163\n\ni64 ans;\nvi v[mxn];\nmap< i64 ,i64> gg;\n\n\ni64 dfs(int s)\n{\n\n        i64 sum = p1 ;\n        For(i,v[s].sz)\n        {\n                i64 tem = dfs(v[s][i]);\n                gg[tem]++;\n                sum = ( sum + (tem * p1) % mod1) % mod1 ;\n        }\n\n        return sum ;\n}\n\nint main()\n{\n\n\n        int n , a , b;\n        sf(n);\n        For(i,n-1)\n        {\n                sff(a,b);\n                v[a].pb(b);\n        }\n        dfs(1);\n        foreach(i,gg)\n        {\n                i64 tem = i->ss;\n                ans += (tem * (tem-1)) / 2;\n        }\n        cout << ans << endl;\n\n\n\n\n\n\n\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <deque>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define MAXN 1005\n#define INF 0x3f3f3f3f\n#define LL long long\n#define MAXM 250005\n\npair <int,int> a[100005];\n\nint depth[100005],cnt[100005];\n\nbool cmp(pair <int,int> x,pair <int,int> y)\n{\n    return x.first < y.first;\n}\n\nint main()\n{\n    //freopen(\"exm.txt\",\"r\",stdin);\n    //freopen(\"kids.in\",\"r\",stdin);\n    //freopen(\"kids.out\",\"w\",stdout);\n\n    int T,Case = 0;\n    int ans,n,t,d,m;\n\n    //scanf(\"%d\",&T);\n    //while(T--)\n    while(~scanf(\"%d\",&n))\n    {\n        memset(depth,0,sizeof(depth));\n        memset(cnt,0,sizeof(cnt));\n\n        for(int i = 0;i < n-1;i++)\n            scanf(\"%d%d\",&a[i].first,&a[i].second);\n\n        sort(a,a+n-1,cmp);\n\n        depth[1] = m = 0;\n        for(int i = 0;i < n-1;i++)\n        {\n            depth[a[i].second] = depth[a[i].first] + 1;\n\n            cnt[depth[a[i].second]]++;\n            if(m < depth[a[i].second])\n               m = depth[a[i].second];\n        }\n\n        ans = 0;\n        for(int i = 1;i <= m;i++)\n            ans += cnt[i]*(cnt[i]-1)/2;\n\n\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \nconst int mod = 1e9 + 7;\n  \nint N;\nvector< int > tree[100000];\nunordered_map< int, int > val;\nlong long ret;\n  \nint dfs(int idx, int par = -1)\n{\n  int hashed = 1;\n  for(int to : tree[idx]) {\n    if(to != par) (hashed += 1LL * dfs(to, idx) * 1003 % mod) %= mod;\n  }\n  ret += val[hashed]++;\n  return(hashed);\n}\n  \nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int A, B;\n    cin >> A >> B;\n    --A, --B;\n    tree[A].push_back(B);\n    tree[B].push_back(A);\n  }\n  dfs(0, -1);\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef ONLINE_JUDGE\n    #define gc getchar\n    #define pc putchar\n#else\n    #define gc getchar_unlocked\n    #define pc putchar_unlocked\n#endif\n\nusing namespace std;\n\n#define vi vector<int>\n#define vll vector<i64>\n#define si set<int>\n#define vs vector<string>\n#define pii pair<int,int>\n#define vpi vector<pii>\n#define pri priority_queue<int>\n#define rev_pri priority_queue<int,vector<int>,greater<int> >\n#define mpi map<int,int>\n#define i64 long long int\n#define endl '\\n'\n#define pi acos(-1)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define For(i,n) for(int i=0;i<n;i++)\n#define Fre(i,a,b) for(int i = a; i < b; i++)\n#define sf(n) scanf(\"%d\", &n)\n#define sff(a,b) scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define pfn(n) printf(\"%d\\n\", n)\n#define pfs(n) printf(\"%d \", n)\n#define eps 1e-8\n#define ff first\n#define ss second\n#define mem(a,b) memset(a,b,sizeof(a))\n#define min3(a,b,c) min(a,min(b,c))\n#define max3(a,b,c) max(a,max(b,c))\n#define READ freopen(\"in.txt\", \"r\", stdin)\n#define WRITE freopen(\"out.txt\", \"w\", stdout)\n#define sz size()\n#define dbg(i) printf(\"yo %d\\n\", i)\n#define foreach(i,c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define sqr(a) (a) * (a)\n#define clr clear()\n#define CASE(a) printf(\"Case %d: \",a)\n\n//int dx[] = {0,1,0,-1,1,1,-1,-1};\n//int dy[] = {1,0,-1,0,1,-1,-1,1};\n//i64 dp[60][60];\n\n\n//functions\n\n//i64 gcd(i64 a,i64 b){if(!b)return a;return gcd(b,a%b);}\n\n//inline void fastRead(int *a){register char c=0;while(c<33)c=gc();*a=0;while(c>33){*a=*a*10+c-'0';c=gc();}}\n\n//inline void fastWrite(int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)pc(snum[i--]);pc('\\n');}\n\n//i64 bigmod(i64 num,i64 n){if(n==0)return 1;i64 x=bigmod(num,n/2);x=x*x%mod;if(n%2==1)x=x*num%mod;return x;}\n\n//i64 modinverse(i64 num){return bigmod(num,mod-2)%mod;}\n\n//void combination(int pos,int last){if(pos==k+1){for(int i=1;i<=k;i++)cout << tem[i];cout << endl;return;}\n//for(int i=last+1;i<=n-k+pos;i++){tem[pos] = num[i-1];combination(pos+1,i);}}\n\n//i64 po(i64 a,i64 b){i64 ans=1;while(b--)ans *= a;return ans;}\n\n//i64 ncr(i64 n,i64 r){if(n==r)return 1;if(r==1)return n;if(dp[n][r]!=-1)return dp[n][r];return dp[n][r]=ncr(n-1,r)+ncr(n-1,r-1);}\n\n//int popcount(i64 num){bitset<70> tem(num);return tem.count();}\n\n//matrix rot(matrix a){matrix res;res.row = a.col;res.col = a.row;For(i,a.row)For(j,a.col)res.mat[j][a.row-i-1] = a.mat[i][j];return res;}\n\n#define bs 141\nvi v[100005];\ni64 hs[100005];\n\nvoid dfs(int s)\n{\n        hs[s] = 1;\n\n        For(i,v[s].sz)\n        {\n                int w = v[s][i];\n                dfs(w);\n                hs[s] += (bs * hs[w]) % mod;\n                hs[s] %= mod;\n        }\n}\n\n\nint main()\n{\n\n        //ios_base::sync_with_stdio(false);cin.tie(0);\n        int n,x,y;\n        sf(n);\n        For(i,n-1)\n        {\n                sff(x,y);\n                v[x].pb(y);\n        }\n\n        dfs(1);\n\n        map<i64,i64> m;\n        i64 ans = 0;\n\n        Fre(i,1,n+1)\n                m[hs[i]]++;\n\n        foreach(i,m)\n                ans += (i->ss * (i->ss - 1) )/ 2;\n\n        cout << ans << endl;\n\n\n\n\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\nconst int M = 1000000007;\n\nint r;\nvector<int> g[100005];\nmap<int,int> m;\n\nint dfs(int cur, vector<bool> used){\n\tused[cur] = true;\n\n\tint res = 0;\n\tfor(auto to : g[cur]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(to, used);\n\t\tres %= M;\n\t}\n\tres = res * r + 1;\n\tm[res]++;\n\treturn res;\n}\n\n\nsigned main(){\n\tint n;\n\tcin >> n;\n\trep(i,n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\n\tr = 8731873;\n\tdfs(0, vector<bool>(n,0));\n\n\tint ans = 0;\n\tfor(auto i : m){\n\t\t//show(i.second)\n\t\tans += (i.second * (i.second - 1)) / 2;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef unsigned long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint n;\nvector<vi> tree;\nll hs[111111];\nll r = 456789065ll;\n\nll get_hash(int v)\n{\n\tll tmp = 0;\n\tfor (auto u : tree[v])\n\t{\n\t\ttmp += get_hash(u) * r;\n\t}\n\ttmp += tree[v].size() * r;\n\treturn hs[v] = tmp;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> n;\n\ttree.resize(n);\n\tREP(i, n - 1)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\ttree[a].push_back(b);\n\t}\n\tget_hash(0);\n\tmap<ll, ll> mp;\n\tREP(i, n)\n\t{\n\t\tmp[hs[i]]++;\n\t}\n\tll ans = 0;\n\tfor (auto i : mp)\n\t{\n\t\tans += i.second * (i.second - 1) / 2;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 101111\n\nint n;\nvector <int> E[N];\nunsigned long long ha[N];\nconst unsigned long long P = 19260817, Q = 233;\n\nvoid dfs(int x, int fa = -1) {\n\tfor (auto v : E[x]) if (v != fa) {\n\t\tdfs(v, x);\n\t\tha[x] += ha[v];\n\t}\n\tha[x] *= P;\n\tha[x] += Q;\n}\n\nmap <unsigned long long, int> G;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, u, v; i < n; i++) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tdfs(1);\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += G[ha[i]];\n\t\tG[ha[i]] += 1; \n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull base = 998244353;\nint n, a, b; vector<vector<int> > G; map<ull, int> cnt;\null solve(int pos, int pre) {\n\tull ret = 1;\n\tfor (int i : G[pos]) {\n\t\tif (i == pre) continue;\n\t\tret += solve(i, pos) * base;\n\t}\n\tcnt[ret]++;\n\treturn ret;\n}\nint main() {\n\tcin >> n; G.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b; a--, b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tsolve(0, -1);\n\tull ret = 0;\n\tfor (pair<ull, int> i : cnt) ret += 1ULL * i.second * (i.second - 1) / 2;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n/* --------------------------------------- */\n\nvector<vector<ll>> g;\nmap<ll, ll> cnt;\nconstexpr ll p = 10007, M = 1000000007;\nll hassh(ll pos, ll par) {\n\tll ret = 0;\n\tREP(i, g[pos].size()) {\n\t\tll child = g[pos][i];\n\t\tif(child == par) continue;\n\t\tret += hassh(child, pos) * p;\n\t\tret %= M;\n\t}\n\tret++; ret %= M;\n\tcnt[ret]++;\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\tcin >> n;\n\tg.resize(n);\n\tREP(i, n - 1) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\thassh(0, -1);\n\tll ans = 0;\n\tfor(auto x: cnt) {\n\t\tans += x.second * (x.second - 1) / 2;\n\t}\n\tcout << ans << endl;\n \treturn 0;\n}\n\n/* --------------------------------------- */\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define read() freopen(\"input.txt\", \"r\", stdin)\n\n#define ll64 long long\n#define BASE 100000007\n#define MOD 100000037\n\nll64 BP[300010];\nbool visited[100010];\nvector<int> graph[100010];\nmap<ll64, ll64> C_M;\n\nvoid dfs(int u, map<int, int>& PM)\n{\n    map<int, int> M;\n    visited[u] = true;\n    for(auto v: graph[u]){\n        if(!visited[v]){\n            dfs(v, M);\n        }\n    }\n    M[0] += 1;\n    ll64 hsh = 0;\n    for(auto &it: M){\n        PM[it.first + 1] += it.second;\n        hsh += (it.first * BP[it.second]) % MOD;\n        hsh %= MOD;\n    }\n    C_M[hsh] += 1;\n}\n\nint main()\n{\n    //read();\n    ll64 temp = 1;\n    for(int i = 0; i < 200000; i++){\n        BP[i] = temp;\n        temp = (temp * BASE) % MOD;\n    }\n    map<int, int> tempM;\n    int N;\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N - 1; i++){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    dfs(1, tempM);\n    ll64 ans = 0;\n    for(auto it: C_M){\n        ll64 x = it.second;\n        ans += (x * (x - 1)) / 2;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(i = 0; i<n; i++)\n#define repl(i,n) for(i = 1; i<=n; i++)\n\n#define sz(x)   (int)x.size()\n#define pb      push_back\n#define all(x)  x.begin(), x.end()\n#define uu      first\n#define vv  second\n#define mem(x,y) memset(x,y,sizeof(x))\n#define sdi(x) scanf(\"%d\",&x)\n#define sdii(x,y) scanf(\"%d %d\",&x,&y)\n#define sdiii(x,y,z)  scanf(\"%d %d %d\",&x,&y,&z)\n#define sdl(x) scanf(\"%lld\",&x)\n#define sdll(x,y) scanf(\"%lld %lld\",&x,&y)\n#define sdlll(x,y,z)  scanf(\"%lld %lld %lld\",&x,&y,&z)\n#define sds(x) scanf(\"%s\",s);\n#define pfi(x) printf(\"%d\\n\",x)\n#define pfii(x,y) printf(\"%d %d\\n\",x,y)\n#define pfiii(x,y,z) printf(\"%d %d %d\\n\",x,y,z)\n#define pfl(x) printf(\"%lld\\n\",x)\n#define pfll(x,y) printf(\"%lld %lld\\n\",x,y)\n#define pflll(x,y,z) printf(\"%lld %lld %lld\\n\",x,y,z)\n\n#define eps 1e-9\n#define OK  cerr<< \"OK\" << '\\n'\n#define DB(x) cerr << #x \" = \" << x << '\\n'\n\n#define FRE(i,a,b) for(i = a; i<=b; i++)\n#define FRL(i,a,b) for(i = a; i<b; i++)\n#define un(x) x.erase(unique(all(x)),x.end())\n#define sf(x) scanf(\"%d\",&x)\n#define sff(x,y) scanf(\"%d %d\",&x,&y)\n#define sfff(x,y,z)  scanf(\"%d %d %d\",&x,&y,&z)\n#define sl(x) scanf(\"%lld\",&x)\n#define sll(x,y) scanf(\"%lld %lld\",&x,&y)\n#define slll(x,y,z)  scanf(\"%lld %lld %lld\",&x,&y,&z)\n#define D(x)        cerr << #x \" = \" << x << '\\n'\n#define DBG         cerr << \"Hi\" << '\\n'\n#define PI          acose(-1.00)\n#define xx          first\n#define yy          second\n\ntypedef double db;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\ninline int setBit(int N, int pos) { return N=N|(1<<pos);}\ninline int resetBit(int N, int pos) {return N=N &~(1<<pos);}\ninline bool checkBit(int N, int pos) {return (bool) (N & (1<<pos));}\n\n\n//int fx[] = {+0, +0, +1, -1, +1, -1, +1};\n//int fy[] = {-1, +1, +0, +0, +1, -1, -1};\n\n\nconst LL  mod[] = { 2078526727, 2117566807 };\nconst LL base[] = { 1572872831, 1971536491 };\n\nconst int MAX = 100005;\nint n;\nvector <int> graph[MAX];\nunordered_map <LL, LL> mapp;\n\npair <LL, LL> dfs(int u, int par=-1) {\n    pair <LL, LL> ret = { 0ll, 0ll };\n    for(auto v:graph[u]) {\n        if(v == par) continue;\n        auto now = dfs(v, u);\n        ret.uu += now.uu;\n        if(ret.uu >= mod[0]) ret.uu -= mod[0];\n        ret.vv += now.vv;\n        if(ret.vv >= mod[1]) ret.vv -= mod[1];\n    }\n    LL here = (ret.uu << 32) ^ ret.vv;\n    if(mapp[here] == 0) mapp[here] = 1;\n    else mapp[here]++;\n\n    ret.uu *= base[0];\n    ret.uu %=  mod[0];\n    ret.vv *= base[1];\n    ret.vv %=  mod[1];\n    ret.uu++;\n    if(ret.uu >= mod[0]) ret.uu -= mod[0];\n    ret.vv++;\n    if(ret.vv >= mod[1]) ret.vv -= mod[1];\n    return ret;\n}\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    int i, u, v;\n    LL ans = 0;\n\n    sdi(n);\n    rep(i, n-1) {\n        sdii(u, v);\n        u--, v--;\n        graph[u].pb(v);\n        graph[v].pb(u);\n    }\n    dfs(0);\n    for(auto x:mapp) {\n        LL now = x.vv;\n        ans += ((now)*(now-1)) / 2;\n    }\n    pfl(ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\nusing namespace std;\n\n\nconst int mod=1e9+7;\nconst int maxn=1e6+10;\ntypedef unsigned long long ull;\n\nmap<ull,ull> mp;\nvector<int> g[maxn];\n\null d[maxn],ans;\n\nint n;\n\nvoid dfs(int u,int fa) {\n    d[u]=1;\n    for(int i=0; i<g[u].size(); ++i) {\n        int v=g[u][i];\n        if(v==fa)continue;\n        dfs(v,u);\n        d[u]+=d[v]*mod;\n    }\n    mp[d[u]]++;\n}\nint main() {\n    scanf(\"%d\",&n);\n    for(int i=0; i<=n; i++) g[i].clear();\n    mp.clear();\n    ans=0;\n    for(int i=1; i<n; i++) {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(1,0);\n    for(map<ull,ull>::iterator it=mp.begin(); it!=mp.end(); it++)\n        ans+=(ull)it->second*(it->second-1)/2;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\ndouble dist(star s1,star s2){\n\tdouble ans=10000000000.0;\n\t\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\tif( is_intersected_ls(s1.se[i],s2.se[j])) {\n\t\t\t\n//\t\t\tcout<<s1.se[i].p1.x<<\" \"<<s1.se[i].p1.y<<endl;\n//\t\t\tcout<<s1.se[i].p2.x<<\" \"<<s1.se[i].p2.y<<endl;\n//\t\t\tcout<<s2.se[j].p1.x<<\" \"<<s2.se[j].p1.y<<endl;\n//\t\t\tcout<<s2.se[j].p2.x<<\" \"<<s2.se[j].p2.y<<endl;\n\t\treturn 0.0;\n\t\t}\n\t\tans=min(ans,segment_dis(s1.se[i],s2.se[j]));\n//\t\tcout<<\"   \"<<i<<\" \"<<j<<\" \"<<segment_dis(s1.se[i],s2.se[j])<<endl;\n\t}\n\treturn ans;\n}\nvector<int> G[100030];\nmap<int,int>ma;\nint a[100030];\n\n\nvoid saiki(int r,int mae){\n\tif(G[r].size()==0){\n\t\ta[r]=1;\n\t\treturn;\n\t}\n\t\n\tfor(auto v:G[r])if(v!=mae)saiki(v,r);\n\tint d=0;\n\tfor(auto v:G[r])if(v!=mae){\n\t\td+=a[v];\n\t\td%=inf;\n\t}\n\td=(d*10007+1)%inf;\n\ta[r]=d;\n\treturn;\n}\n\n     signed main(){\nint n;\n     cin>>n;\n     \tfor(int i=0;i<n-1;i++){\n     \t\tint r,rr;\n     \t\tcin>>r>>rr;\n     \t\tG[r].pb(rr);\n     \t\tG[rr].pb(r);\n     \t}\n     \tsaiki(1,-1);\n     \tfor(int i=1;i<=n;i++){\n     \t\tma[a[i]]++;\n     \t//\tcout<<a[i]<<endl;\n     \t}\n     \tint ans=0;\n     \tfor(auto it=ma.begin();it!=ma.end();it++){\n     \t\tint y=(*it).second;\n     \t\tans+=y*(y-1)/2;\n     \t}\n     \t\n     \n     \t\n     \tcout<<ans<<endl;\n     \t\n\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nvector<int>E[100010];\nlong long size[100010];\nconst long long mod=1e9+7;\nint p=9901;\nmap<long,long>MP;\nmap<long,long>:: iterator temp;\nvoid dfs(long long a)\n{\n\tint i;\n\tsize[a]=1;\n\tfor(i=0;i<int(E[a].size());i++)\n\t{\n\t\tint v=E[a][i];\t\n\t\tdfs(v);\n\t\tsize[a]=(size[a]+p*size[v])%mod;\n\t}\n//\tsize[a]=1+cur*n;\n//\tsize[a]=(cur+size[a])%mod;\n\tMP[size[a]]++;\n}\nlong long C(long long n,long long x)\n{//从n中?x个\n\tif(n<x)\n\t\treturn 0;\n\treturn n*(n-1)/x;\n}\n\n\nint main()\n{\n\t// freopen( \"E.txt\", \"r\", stdin );\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF)\n\t{\n\t\tmemset(size,0,sizeof(size));\n\t\tint a,b;\n\t\tint i;\n\t\tfor(i=1;i<n;i++)\n\t\t{\n\t\t scanf(\"%d%d\",&a,&b);\n\t\t E[a].push_back(b);\n\t\t}\n\t\tdfs(1);\n\t\tsort(size+1,size+n+1);\n\t\tlong long ans=0;\n\t\tlong long sum=1;\n\t\t\n\t\t\n\t\t\n\t\tfor(i=2;i<=n;i++)\n\t\t{\n\t\t\tif(size[i]==size[i-1])\n\t\t\t\tsum++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tans+=C(sum,2);\n\t\t\t\tsum=1;\n\t\t\t}\n\t\t}\n\t\tans+=C(sum,2);\n\t\t\n\t\t// for(temp=MP.begin();temp!=MP.end();temp++)\n\t\t// \tans += C(temp->second,2);\n        printf(\"%lld\\n\",ans);\n\t\tfor(i=1;i<=n;i++)\n\t\t\tE[i].clear();\n\t\tMP.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <deque>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\n#define MAXN 1005\n#define INF 0x3f3f3f3f\n#define LL long long\n#define MAXM 250005\n\npair <int,int> a[100005];\n\nint depth[100005],cnt[100005];\n\nbool cmp(pair <int,int> x,pair <int,int> y)\n{\n    return x.first < y.first;\n}\n\nint main()\n{\n    freopen(\"exm.txt\",\"r\",stdin);\n    //freopen(\"kids.in\",\"r\",stdin);\n    //freopen(\"kids.out\",\"w\",stdout);\n\n    int T,Case = 0;\n    int ans,n,t,d,m;\n\n    //scanf(\"%d\",&T);\n    //while(T--)\n    while(~scanf(\"%d\",&n))\n    {\n        memset(depth,0,sizeof(depth));\n        memset(cnt,0,sizeof(cnt));\n\n        for(int i = 0;i < n-1;i++)\n            scanf(\"%d%d\",&a[i].first,&a[i].second);\n\n        sort(a,a+n-1,cmp);\n\n        depth[1] = m = 0;\n        for(int i = 0;i < n-1;i++)\n        {\n            depth[a[i].second] = depth[a[i].first] + 1;\n\n            cnt[depth[a[i].second]]++;\n            if(m < depth[a[i].second])\n               m = depth[a[i].second];\n        }\n\n        ans = 0;\n        for(int i = 1;i <= m;i++)\n            ans += cnt[i]*(cnt[i]-1)/2;\n\n\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint b=67280421310721,n,a,c;\null ans;\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res+=dfs(v[x][i]);\n  res*=b;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){b=21387612863821;\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define EACH(i, a) for(auto&& i:a)\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,a,b) for(ll i = (b)-1; i >= (a); --i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define pb push_back\n#define ALL(v) (v).begin(),(v).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\n\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\n\nll A = 1007, modA = 1e9+7;\n\nvector< vector<ll> > G;\nvector<ll> h;\n\nll add(ll a, ll b) {\n    return (a + b) % modA;\n}\nll mul(ll a, ll b) {\n    return a * b % modA;\n}\nll dfs(ll v, ll prev) {\n    ll res = 1;\n    EACH(to, G[v]) {\n        if (to == prev) continue;\n        res = add(res, mul(A, dfs(to, v)));\n    }\n    return h[v] = res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n; cin >> n;\n    G.clear(); G.resize(n);\n    ll root = 0;\n    REP(i, n-1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    h.assign(n, -1);\n    dfs(0, -1);\n    map<ll, ll> cnt;\n    ll ans = 0;\n    REP(i, n) {\n        ans += cnt[h[i]];\n        cnt[h[i]]++;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*****************************************************************\n *                   BISMILLAHIR RAHMANIR RAHIM                  *\n *                           JU_Circavex                         *\n *****************************************************************/\n\n#include<bits/stdc++.h>\n\n//#include<algorithm>\n//#include<cstdio>\n//#include<sstream>\n//#include<cstdlib>\n//#include<cctype>\n//#include<cmath>\n//#include<set>\n//#include<queue>\n//#include<stack>\n//#include<list>\n//#include<iostream>\n//#include<fstream>\n//#include<numeric>\n//#include<string>\n//#include<vector>\n//#include<cstring>\n//#include<map>\n//#include<iterator>\n//#include<deque>\n//#include<climits>\n//#include<complex>\n\n#define S scanf\n#define P printf\n#define DI(X) int (X);             scanf(\"%d\", &X)\n#define DII(X, Y) int X, Y;        scanf(\"%d%d\", &X, &Y)\n#define DIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define DILL(X) LL (X); scanf(\"%lld\", &X)\n\n#define LL long long int\n#define ULL unsigned long long int\n#define D double\n\n#define all(a) a.begin(),a.end()\n#define X  first\n#define Y  second\n#define MP make_pair\n#define NL P(\"\\n\")\n\n#define PB(x)      push_back(x)\n#define PS(x)      push(x)\n#define sz()       size()\n#define UB         upper_bound\n#define LB         lower_bound\n#define countbit(x) __builtin_popcount(x)\n\n#define MEM(a,val) memset(a,val,sizeof(a));\n#define SET(a)     memset(a,-1,sizeof a)\n#define CLR(a)     memset(a,0,sizeof a)\n\nusing namespace std;\n\n\n#define ll long long int\n#define ull unsigned long long int\n#define inf (1<<30)\n#define linf (1LL<<62)\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define sc4(a,b,c,d) scanf(\"%d%d%d%d\",&a,&b,&c,&d)\n#define f(i,n) for(i=0;i<n;i++)\n#define fl(c,i,n) for(i=c;i<n;i++)\n#define mem(a) memset(a,0,sizeof(a))\n#define memn(a) memset(a,-1,sizeof(a))\n#define aov(a) a.begin(),a.end()\n#define pb push_back\n#define PI (2.0*acos(0.0)) //#define PI acos(-1.0)\n#define pll pair< ll , ll >\n#define pii pair< int , int >\n#define mpr make_pair\n#define xx first\n#define yy second\n#define nl puts(\"\")\n//#define endl '\\n'\n#define dbg(x) cerr<<#x<<\" : \"<<x<<endl\n#define mpp make_pair\n#define SZ(x) (int)(x.size())\n#define fr(i,a,n) for(int i=a;i<=n;i++)\n\n//template <typename T> T BigMod (T b,T p,T m){if (p == 0) return 1;if (p%2 == 0){T s = BigMod(b,p/2,m);return ((s%m)*(s%m))%m;}return ((b%m)*(BigMod(b,p-1,m)%m))%m;}\n//template <typename T> T ModInv (T b,T m){return BigMod(b,m-2,m);}\n//template <typename T> T POW(T B,T P){ if(P==0) return 1; if(P&1) return B*POW(B,P-1);  else return SQR(POW(B,P/2));}\n//template <typename T> LL isLeft(T a,T b,T c) { return (a.x-b.x)*(b.y-c.y)-(b.x-c.x)*(a.y-b.y); }\ntemplate <class T> inline T bigmod(T p,T e,T M){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p) % M;p = (p * p) % M;}return (T)ret;}\n//template <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}   // M is prime}\ntemplate <class T> inline T bpow(T p,T e){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p);p = (p * p);}return (T)ret;}\n//\n//int    Set(int N,int pos){ return N=N | (1<<pos);}\n//int  Reset(int N,int pos){return N= N & ~(1<<pos);}\n//bool Check(int N,int pos){return (bool)(N & (1<<pos));}\n\n#define VI  vector< int >\n#define VII vector< VI >\n#define VLL vector< LL >\n#define PII pair< int , int >\n#define PLL pair< LL , LL >\n#define VPI vector< PII >\n\n\n/// Hashing Bases & MOD\n///           0123456789\n#define Base1 10000019ULL\n#define Base2 10000079ULL\n#define Base3 10000103ULL\n#define MOD1  1000000007ULL\n#define MOD2  1000000009ULL\n#define MOD3  1000000021ULL\n#define LOGX  17\n#define FCIN  ios_base::sync_with_stdio(0); cin.tie(0)\n\n///int mnth[]={-1,31,28,31,30,31,30,31,31,30,31,30,31};  //Not Leap Year\n///int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction\n///int dx[]={-1,+1,0,1,0,-1}; // Hexagonal Direction   **\n///int dy[]={-1,+1,1,0,-1,0}; //                       *#*\n///                                                     **\nint dx[]={0,1,0,-1};int dy[]={1,0,-1,0}; //4 Direction\nint ts, kk = 1;\n\n\n///         0123456789\n#define MX  10000001.0\n#define MD  1000000001.0\n#define MOD 1000000007\n#define eps 1e-9\n#define M   100005\n#define MM  1010\n#define MD  1000000007LL\n\nint n;\nvector< int >al[M];\nll bs[2],md[2];\nll hs[2][M];\nmap< pll,int >mp;\nmap< pll,int >::iterator it;\n\nint main()\n{\n    int t,i,j,k;\n\n    bs[0]=Base1;\n    bs[1]=Base2;\n    md[0]=MOD1;\n    md[1]=MOD2;\n\n    sc(n);\n    fl(1,i,n)\n    {\n        sc2(j,k);\n        al[j].pb(k);\n    }\n\n    ll rs=0;\n    for(i=n;i>0;i--)\n    {\n        ll s1=0,s2=0;\n        f(j,al[i].size())\n        {\n            t=al[i][j];\n            s1+=hs[0][t];\n            s2+=hs[1][t];\n            if(s1>=md[0])s1-=md[0];\n            if(s2>=md[1])s2-=md[1];\n        }\n\n        t=al[i].size();\n        hs[0][i]=s1=(s1*bs[0]+t)%md[0];\n        hs[1][i]=s2=(s2*bs[1]+t)%md[1];\n        pll s=mpr(s1,s2);\n        it=mp.find(s);\n        if(it!=mp.end())\n        {\n            rs+=it->yy;\n            it->yy++;\n        }\n        else\n            mp[s]=1;\n    }\n    printf(\"%lld\\n\",rs);\n\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\nconst int M = 1000000007;\n\nvector<int> r, h;\nvector<int> g[100005];\n\nint dfs(int cur, vector<bool> used){\n\tused[cur] = true;\n\n\tint res = 0;\n\tfor(auto to : g[cur]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(to, used);\n\t\tres %= M;\n\t}\n\tres = res * r[0] + 1;\n\treturn h[cur] = res;\n}\n\n\nsigned main(){\n\trandom_device rnd;\n\tmt19937 engine(rnd());\n\tuniform_int_distribution<> dist(0, M - 1); //dist(engine)\n\n\n\tint n;\n\tcin >> n;\n\trep(i,n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\n\th = vector<int>(n);\n\tr = vector<int>(n);\n\trep(i,n){\n\t\tr[i] = dist(engine);\n\t}\n\tdfs(0, vector<bool>(n,0));\n\n\tmap<int,int> m;\n\trep(i,n){\n\t\tm[h[i]]++;\n\t}\n\tint ans = 0;\n\tfor(auto i : m){\n\t\t//show(i.second)\n\t\tans += (i.second * (i.second - 1)) / 2;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define B 1000000007\n\nint N;\nvector<int> g[100010];\nmap<ull,ll> cnt;\nll res=0;\n\null dfs(int v,int pre){\n  ull crth=0;\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    crth+=dfs(nv,v);\n  }\n  crth*=B;\n  crth+=1;\n  res+=cnt[crth];\n  cnt[crth]++;\n  return crth;\n}\n\nint main(){\n  cin>>N;\n  rep(i,N-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  dfs(0,-1);\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\nusing namespace std;\n \n\ntypedef long long ll;\n\nconst int maxn = 1e5+10;\nconst ll p = 9901;\n\nint n,m,k;\nll has[maxn];\nvector<int>edg[maxn];\nmap<ll,ll>mp;\nmap<ll,ll>::iterator it;\nvoid dfs(int u,int fa){\n    has[u]=1;\n    for(int v:edg[u]){\n        dfs(v,u);\n        has[u]=(has[u]+has[v]*p)%mod;\n    }\n    mp[has[u]]++;\n}\nint main()\n{\n    int u,v;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        scanf(\"%d%d\",&u,&v);\n        edg[u].push_back(v);\n    }\n    dfs(1,0);\n    ll ans=0;\n    for(it =mp.begin();it!=mp.end();it++){\n        ans+=(it->second-1)*it->second/2;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nstruct ss\n{\n    int d=0;\n}s[100002];\nint a[100001];\nint main()\n{\n  int n;\n  while(~scanf(\"%d\",&n))\n  {   int f,z;\n  memset(a,0,sizeof(a));\n      for(int i=0;i<n-1;i++)\n      {\n          scanf(\"%d%d\",&f,&z);\n          s[z].d=s[f].d+1;\n          a[s[z].d]++;\n\n      }\n      int sum=0;\n      for(int i=1;i<=50000;i++)\n      {\n          if(a[i]>=2)\n          {\n               sum+=(a[i]*(a[i]-1)/2);\n          }\n\n      }\n      printf(\"%d\\n\",sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD=1e9+7;\nconst int P=9901;\nlong long has[100010];\nmap<long long,long long>mp;\nvector<int>edge[100010];\n\nvoid dfs(int u,int r)\n{\n\thas[u]=1;\n\tfor (auto v:edge[u])\n\t{\n\t\tif (v==r) continue;\n\t\tdfs(v,u);\n\t\thas[u]=(has[u]+has[v]*P)%MOD;\n\t}\n\tmp[has[u]]++;\n}\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\",&N);\n\tint u,v;\n\tfor (int i=1;i<N;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tlong long ans=0;\n\tfor (auto f=mp.begin();f!=mp.end();f++)\n\t{\n\t\tans+=(f->second-1)*f->second/2;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>pii;\nconst int N = 1e5+5;\nconst ll p = 9901;\nconst ll mod = 1e9+7;\nconst double eps = 1e-8;\nint n,m,k;\nll has[N];\nvector<int>edg[N];\nmap<ll,ll>mp;\nmap<ll,ll>::iterator it;\nvoid dfs(int u,int fa){\n    has[u]=1;\n    for(int v:edg[u]){\n        dfs(v,u);\n        has[u]=(has[u]+has[v]*p)%mod;\n    }\n    mp[has[u]]++;\n}\nint main()\n{\n    int u,v;\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        scanf(\"%d%d\",&u,&v);\n        edg[u].push_back(v);\n    }\n    dfs(1,0);\n    ll ans=0;\n    for(it =mp.begin();it!=mp.end();it++){\n        ans+=(it->second-1)*it->second/2;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nvector<int> G[100000];\n\nconst ll H = (1LL<<30);\nconst ll B = 100003;\n\nll ans=0;\nmap<ll,int> hs;\n\nll dfs(int cur,int bef,int depth){\n    ll ret = 0;\n    bool isLeaf=true;\n    for(auto &e:G[cur]){\n        if(e==bef)continue;\n        isLeaf = false;\n        ret += dfs(e,cur,depth+1);\n    }\n    \n    if(isLeaf){\n        if(hs.count(1)){\n            ans+=hs[1];\n        }\n        hs[1]++;\n        return 1;\n    }\n    \n    if(hs.count((ret*B + 1)%H)){\n        ans+=hs[(ret*B + 1)%H];\n    }\n    hs[(ret*B + 1)%H]++;\n    return (ret*B + 1)%H;\n}\n\n\nint main(){\n    int v;\n    cin>>v;\n    rep(i,v-1){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    ll res = dfs(0,-1,0);\n    \n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint b=1e9+7,n,a,c,ans;\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res+=dfs(v[x][i]);\n  res*=b;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n/*\nID: kfoozmi1\nLANG: C++\nTASK:\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef kfoozminus\n#define dbg(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)\n\nvoid faltu() {\n\tcerr << endl;\n}\n\ntemplate <typename T>\nvoid faltu(T a[], int n) {\n\tfor(int i = 0; i < n; ++i) cerr << a[i] << ' ';\n\tcerr << endl;\n}\n\ntemplate <typename First, typename ... hello>\nvoid faltu(First arg, const hello&... rest) {\n\tcerr << arg << ' ';\n\tfaltu(rest...);\n}\n#else\n#define dbg(args...)\n#endif\n\n#define PB push_back\n#define F first\n#define S second\n#define MP make_pair\n#define SQR(a) ((a) * (a))\n#define vsort(v) sort(v.begin(), v.end())\n#define memset(a, b) memset(a, b, sizeof a)\n#define PQ priority_queue\n#define PI acos(-1)\n#define EPS 1e-9\n\n#define B1 43\n#define B2 43\n\n#define MOD1 1000000007\n#define MOD2 1000000009\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n//int dx[] = {0, 0, +1, -1};\n//int dy[] = {+1, -1, 0, 0};\n//int dx[] = {+1, 0, -1, 0, +1, +1, -1, -1};\n//int dy[] = {0, +1, 0, -1, +1, -1, +1, -1};\n\ninline bool checkBit(ll n, int i) { return n & (1LL << i); }\ninline ll setBit(ll n, int i) { return n | (1LL << i); }\ninline ll resetBit(ll n, int i) { return n & (~ (1LL << i)); }\ninline bool EQ(double a, double b) { return fabs(a-b) < EPS; }\ninline double dist(double ix, double iy, double jx, double jy) { return sqrt(SQR(ix - jx) + SQR(iy - jy)); }\n\n#define PMX 1000000\n\nint marked[PMX/64+2];\n\n#define mark(x) marked[x>>6] |= (1<<((x&63)>>1))\n#define check(x) (marked[x>>6] & (1<<((x&63)>>1)))\n\nbool isPrime(int x)\n{\n    return (x>1) && ((x==2) || ((x&1) && (!(check(x)))));\n}\n\nvoid seive(int n)\n{\n    int i, j;\n    for(i=3; i*i<=n; i+=2)\n    {\n        if(!check(i))\n        {\n            for(j=i*i; j<=n; j+=i<<1)\n            {\n                mark(j);\n            }\n        }\n    }\n}\n\nll bigMod(ll a, ll b, ll MOD)\n{\n\tll r = 1;\n\twhile(b) {\n\t\tif(b & 1) (r *= a) %= MOD;\n\t\tb >>= 1;\n\t\t(a *= a) %= MOD;\n\t}\n\treturn r;\n}\n\nll add(ll a, ll b, ll MOD)\n{\n\tll ret = a + b;\n\tif(ret >= MOD) ret -= MOD;\n\treturn ret;\n}\n\nll sub(ll a, ll b, ll MOD)\n{\n\tll ret = a - b;\n\tif(ret < 0) ret += MOD;\n\treturn ret;\n}\n\nll mul(ll a, ll b, ll MOD)\n{\n\tll ret = a * b;\n\tif(ret >= MOD) ret %= MOD;\n\treturn ret;\n}\n\n#define INF 100000000\n#define MX 100007\n\nmap< pll, ll > mp;\nll ans;\nvector<int> edge[MX];\n\npll dfs(int nd)\n{\n\tdbg(nd);\n\tpll h = {0, 0};\n\tfor(int k = 0; k < edge[nd].size(); k ++) {\n\n\t\tpll p = dfs(edge[nd][k]);\n\t\th.F = add(h.F, p.F, MOD1);\n\t\th.S = add(h.S, p.S, MOD2);\n\t}\n\th.F = add(mul(h.F, B1, MOD1), 1, MOD1);\n\th.S = add(mul(h.S, B2, MOD2), 1, MOD1);\n\tans += mp[h];\n\tmp[h] ++;\n\treturn h;\n}\n\nint main()\n{\n#ifdef kfoozminus\n\t//freopen(\"in\", \"r\", stdin);\n\t//freopen(\"out\", \"w\", stdout);\n#endif\n\tint n, i, u, v;\n\n\tscanf(\"%d\", &n);\n\tfor(i = 1; i < n; i ++) {\n\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedge[u].PB(v);\n\t}\n\tdfs(1);\n\tprintf(\"%lld\\n\", ans);\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\nchar a[99999];\nint main(){\n\tint n,s=0,x=1,i;\n\tfor(scanf(\"%d\",&n);s<n;x++)s+=x;\n\tmemset(a,')',--x);\n\tmemset(a+x,'(',x);\n\ti=a[x],a[x]=a[x-s+n],a[x-s+n]=i;\n\tputs(a);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nusing ull = unsigned long long;\nconstexpr int MAX = 100000;\nconstexpr ull B = 100007;\n\nvector<int> G[MAX];\nmap<ull, int> mp;\n\null dfs(int v)\n{\n    ull res = 1;\n    int n = G[v].size();\n    for (int i = 0; i < n; i++) {\n        res += dfs(G[v][i]) * B;\n    }\n    mp[res]++;\n    return res;\n}\n\null solve()\n{\n    dfs(0);\n    ull res = 0;\n    for (auto x : mp) {\n        if (x.second >= 2) {\n            res += x.second * (x.second - 1) / 2;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        G[a].emplace_back(b);\n    }\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<vector>\n #include<cstring>\n#include<string>\n#include<iomanip>\n#include<cstdio>\n#include<stack>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<cmath>\nusing namespace std;\n#define sf scanf\n#define pf printf\n#define mem(a,b) memset(a,b,sizeof(a));\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define mod 998244353\n#define N 100020\n#define M 400020\n#define ULL unsigned long long\n#define LL long long\n#define inf 0x3f3f3f3f\nmap<ULL,LL>mp;\nvector<int>g[N];\nULL dp[N];\nLL ans;int n;\nconst ULL b=1000000007;\nvoid dfs(int u,int fa){\n    dp[u]=1;\n    for(int i=0;i<g[u].size();++i){\n        int v=g[u][i];\n        if(v==fa)continue;\n        dfs(v,u);\n        dp[u]+=dp[v]*b;\n    }\n    ans+=mp[dp[u]];\n    mp[dp[u]]++;\n}\nint main(){\n    sf(\"%d\",&n);\n        ans=0;\n        rep(i,1,n-1){\n            int u,v;sf(\"%d%d\",&u,&v);\n            g[u].push_back(v);g[v].push_back(u);\n        }\n        dfs(1,1);\n        cout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//OM\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <sstream>\n#include <algorithm>\nusing  namespace  std;\n\n#define  x first\n#define  y second\n#define  pb push_back\n#define  mp make_pair\n#define  PI (acos(-1.0))\n#define  mem(a,b) memset(a,b,sizeof(a))\n#define  Sort(x) sort(x.begin(),x.end())\n#define  FOR(i, b, e) for(int i = b; i <= (int)(e); i++)\n#define  FORR(i, b, e) for(int i = b; i >=(int)(e); i--)\n#define  FORI(i, s) for (__typeof ((s).end ()) i = (s).begin (); i != (s).end (); ++i)\n#define  pr(x) cout<<x<<\"\\n\"\n#define  prs(x) cout<<x<<\" \"\n#define  pr2(x,y) cout<<x<<\" \"<<y<<\"\\n\"\n#define  pr3(x,y,z) cout<<x<<\" \"<<y<<\" \"<<z<<\"\\n\"\n#define  ppr(a) cout<<a.x<<\" \"<<a.y<<\"\\n\"\n\ntypedef  long long ll;\ntypedef  pair <int, int> pii;\ntypedef  pair <double , double> pdd;\ntypedef  vector <int> vi;\ntypedef  vector <pii> vpii;\n\n//int dx[]={1,0,-1,0};int dy[]={0,1,0,-1}; //4 Direction\n//int dx[]={1,1,0,-1,-1,-1,0,1};\n//int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction\n\n#define  EPS 1e-9\n#define  MAX 100007\nvi edge[MAX];\nint depth[MAX];\nlong long p = 999983;      // prime number\nlong long M = 1000000009;  // prime number\nlong long pw[MAX];\nint mxdep;\nvoid DFS(int u)\n{\n    depth[u]=1;\n\n    FOR(i,0,edge[u].size()-1)\n    {\n        DFS(edge[u][i]);\n        depth[u]=max(depth[u],depth[edge[u][i]]+1);\n    }\n    mxdep=max(depth[u],mxdep);\n}\n\n\nmap<ll ,ll > Map;\nll  DFScal(int u)\n{\n    ll res=0;\n    FOR(i,0,edge[u].size()-1)\n    {\n        res= (res+ DFScal(edge[u][i])*pw[depth[u]- depth[edge[u][i]]] )%M;\n    }\n    //pr2(u,res);\n    res=(res+pw[depth[u]])%M;\n    Map[res]++;\n    return res;\n}\n\nint main()\n{\n    int T,n,u,v;\n    scanf(\"%d\",&n);\n    FOR(i,1,n-1)\n    {\n        scanf(\"%d\",&u);\n        scanf(\"%d\",&v);\n        edge[u].pb(v);\n    }\n    DFS(1);\n    pw[0]=1;\n    for(int i=1;i<=mxdep;i++)pw[i]=(pw[i-1]*p)%M;\n    DFScal(1);\n    ll ans=0;\n    int faltu=0;\n    FORI(it,Map)\n    {\n        ll cnt=it->y;\n        ans=ans+(1ll*(cnt)*(cnt-1));\n    }\n    printf(\"%lld\\n\",ans/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll base = 211;\nconstexpr ll M = 1000000000000037LL;\n\nll dfs(int v, vector<vector<int>>& g, vector<bool>& visited, vector<ll>& hs) {\n    visited[v] = true;\n    ll res = 1;\n    for(auto to : g[v]) {\n        if(!visited[to]) {\n            (res += dfs(to, g, visited, hs) * base) %= M;\n        }\n    }\n    return hs[v] = res;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> g(N);\n    for(int i=0; i<N-1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    vector<bool> visited(N);\n    vector<ll> hs(N);\n    dfs(0, g, visited, hs);\n    ll res = 0;\n    sort(hs.begin(), hs.end());\n    for(int i=0; i<N; ++i) {\n        auto p = equal_range(hs.begin(), hs.end(), hs[i]);\n        res += p.second - p.first - 1;\n    }\n    res /= 2;\n    cout << res << endl;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nconst int maxn = 100050;\nusing namespace std;\nvector<int> son[maxn];\nstruct D{\n\tvector<int> d;\n\tint de;\n\tD(){\n\t\td.clear();de = 0;\n\t}\n\tbool operator <(const D& b) const{ \n\t\tint len1=d.size();\n\t\tint len2 = b.d.size();\n\t\tif(len1 != len2) return len1<len2;//深度 \n\t\telse{\n\t\t\tfor(int i=0;i<len1;++i){\n\t\t\t\tif(d[i]==b.d[i]) continue;\n\t\t\t\treturn d[i] < b.d[i];\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}dep[maxn];\nint yz = 0;\nmap<D,int> T;\nvoid dfs(int cur){\n\tif(son[cur].empty()){\n\t\tyz ++;\n\t\treturn;\n\t}\n\tint i,j;\n\tint len = son[cur].size();\n\tdep[cur].d.push_back(len);//把儿子这一层加入\n\tdep[cur].de = 1; \n\tfor(i = 0; i <len ;++ i){\n\t\tint s=son[cur][i];\n\t\tdfs(s); //操作儿子 \n\t\tif(dep[cur].de <= dep[s].de + 1){\n\t\t\tfor(j = 1;j < dep[cur].de;++j) dep[cur].d[j]+=dep[s].d[j-1];//跟新原有 \n\t\t\tfor(j;j < dep[s].de + 1;++j) dep[cur].d.push_back(dep[s].d[j-1]);//需要拓展 \n\t\t\tdep[cur].de = dep[s].de + 1;//更新深度 \n\t\t}\n\t\telse{\n\t\t\tfor(j = 1;j <= dep[s].de; ++j){\n\t\t\t\tdep[cur].d[j]+=dep[s].d[j-1];\n\t\t\t}\n\t\t}\n\t}//当前结点操作完毕\n\t if(T.find(dep[cur])==T.end()){\n\t \tT[dep[cur]] = 1;\n\t }\n\t else  ++ T[dep[cur]];\n\t return;\n}\nlong long C[100050];\nint main(){\n\tint n,i,a,b;scanf(\"%d\",&n);for(i = 1;i <= n; ++i) son[i].clear();\n\tC[1] = 0;\n\tfor(i=2;i<100050;++i) C[i] = C[i-1]+i-1;\n\tfor(i = 1;i < n; ++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tson[a].push_back(b);\n\t}\n\tT.clear();\n\tdfs(1);\n\tmap<D,int>::iterator it;\n\tlong long ans = 0;\n\tans += C[yz];\n\tfor(it = T.begin();it!=T.end();++it){\n\t\tans +=C[it->second];\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\nusing namespace std;\ntypedef long long int lli;\nconst lli mod1 = 1e9+7;\nconst lli mod2 = 1e9+9;\nconst lli base1 = 1007;\nconst lli base2 = 1009;\n\nvector<bool> used;\nvector<vector<int> > adj;\nmap<pair<lli, lli>, lli> hnum;\npair<lli, lli> dfs(int node){\n    if(used[node]) return make_pair(0, 0);\n    used[node] = true;\n    pair<lli, lli> res(1, 1);\n    for(int i: adj[node]){\n        pair<lli, lli> chi = dfs(i);\n        res.first = (res.first +chi.first *base1) %mod1;\n        res.second = (res.second +chi.second *base2) %mod2;\n    }\n    hnum[res]++;\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    used.resize(n);\n    adj.resize(n);\n    for(int i=0; i<n-1; i++){\n        int a,b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    dfs(0);\n    lli ans = 0;\n    for(auto h: hnum){\n        lli num = h.second;\n        ans += num*(num-1)/2;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\nusing namespace std;\n\n\nconst int mod=1e9+7;\nconst int maxn=1e6+10;\n#define uLL unsigned long long\n\nmap<uLL,uLL> mp;\nvector<int> g[maxn];\n\nuLL d[maxn];\nuLL ans;\nint n;\n\nvoid dfs(int u,int fa)\n{\n    d[u]=1;\n    for(int i=0;i<g[u].size();++i)\n    {\n        int v=g[u][i];\n        if(v==fa)continue;\n        dfs(v,u);\n        d[u]+=d[v]*mod;\n    }\n    mp[d[u]]++;\n}\nint main()\n{\n    while(~scanf(\"%d\",&n))\n    {\n        for(int i=0; i<=n; i++)\n            g[i].clear();\n        mp.clear();\n        ans=0;\n        for(int i=1;i<n;i++)\n        {\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            g[u].push_back(v);\n            g[v].push_back(u);\n        }\n\n        dfs(1,0);\n        for(map<uLL,uLL>::iterator it=mp.begin(); it!=mp.end(); it++)\n            ans+=(uLL)it->second*(it->second-1)/2;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\nmap<pair<int,int>,int> M;\nint const P=1000000007;\nint const PP=1000000009;\nlong long const Q=999983;\npair<int,int> f[100100];\nint n;\nlong long ans=0;\nvector<int> V[100100];\nvoid dfs(int x){\n\tf[x]=make_pair(1,1);\n\tfor(auto &&y:V[x]){\n\t\tdfs(y);\n\t\tf[x].first=(f[x].first+f[y].first*Q)%P;\n\t\tf[x].second=(f[x].second+f[y].second*Q)%PP;\n\t}\n\tans+=M[f[x]]++;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tV[x].push_back(y);\n\t}\n\tdfs(1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\nconst ll m1 = 10007;\nconst ll m2 = 10009;\nconst ll mod1 = 100000007;\nconst ll mod2 = 100000009;\n\nvi G[MAX_N];\nbool flag[MAX_N];\npll sz[MAX_N];\nmap<pll,ll> mp;\n\nvoid dfs(int u)\n{\n    flag[u] = true;\n    rep(i,len(G[u])){\n        if(!flag[G[u][i]]){\n            dfs(G[u][i]);\n            sz[u].fi += sz[G[u][i]].fi;\n            sz[u].se += sz[G[u][i]].se;\n        }\n    }\n    sz[u].fi = sz[u].fi*m1%mod1;\n    sz[u].se = sz[u].se*m2%mod2;\n    sz[u].fi++,sz[u].se++;\n    mp[sz[u]]++;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        G[a-1].pb(b-1),G[b-1].pb(a-1);\n    }\n    dfs(0);\n    ll res = 0;\n    each(it,mp){\n        res += it.se*(it.se-1)/2;\n    }\n    cout << res << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1e9 + 7;\nconst int N = 110000;\n\nint modExp(int a, int n, int p) {\n\tint ret = 1;\n\tfor (; n; n >>= 1, a = 1LL * a * a % p) if (n & 1) ret = 1LL * ret * a % p;\n\treturn ret;\n}\n\nlong long ret;\n\nint dp[N], pw[N], qw[N];\nmap<int, int> H;\n\nlong long sum;\n\nvector<int> adj[N];\n\nvoid dfs(int u, int p) {\n\tdp[u] = dp[p] + 1;\n\tret = (ret + pw[dp[u]]) % P;\n\tint ans = (P - ret) % P;\n\tfor (int v : adj[u]) {\n\t\tif (v == p) continue;\n\t\tdfs(v, u);\n\t}\n\tans = (ans + ret) * 1LL * qw[dp[u]] % P;\n\tsum += H[ans];\n\tH[ans]++;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tint n; cin >> n;\n\tfor (int i = 0; i <= n; i++) pw[i] = (i == 0 ? 1 : pw[i - 1] * 1LL * 999983) % P;\n\tfor (int i = 0; i <= n; i++) qw[i] = modExp(pw[i], P - 2, P);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tdp[0] = -1;\n\tdfs(1, 0);\n\tcout << sum << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, n) for(int i = (a); i < (n); i++)\n#define REP(i, n) FOR(i, 0, (n))\n#define ALL(a) (a.begin(), a.end())\ntypedef vector<int> vi;\n\nint64_t h(const vector<vi> &t, int i, int p, vi &v) {\n    int64_t res = 1;\n    for (int c : t[i]) {\n        if (c == p) continue;\n        res += 1000000009 * h(t, c, i, v);\n    }\n    v[i] = res;\n    return res;\n}\n\nint main() {\n    int n;\n    cin>>n;\n    vector<vi> t(n);\n    REP(i,n-1) {\n        int a,b;\n        cin>>a>>b;\n        --a;\n        --b;\n        t[a].push_back(b);\n        t[b].push_back(a);\n    }\n    vi v(n);\n    h(t, 0, -1, v);\n    multiset<int64_t> m;\n    int64_t cnt = 0;\n    REP(i,n) {\n        cnt += m.count(v[i]);\n        m.insert(v[i]);\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst unsigned X = 1234567;\nconst unsigned R = 7531;\n\nint n;\nunsigned h[N];\nvector <int> g[N];\nmap <unsigned, int> f;\n\nvoid dfs (int u, int p) {\n\tunsigned now = 0;\n\tfor (int v : g[u]) if (v != p) {\n\t\tdfs(v, u); \n\t\tnow += h[v];\n\t}\n\th[u] = now * X + R;\n\t++f[h[u]];  \n}\n\nint main (int argc, char const *argv[]) {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tdfs(1, 0);\n\n\tlong long ans = 0;\n\tfor (auto it : f) {\n\t\tlong long cnt = (long long) it.second;\n\t\tans += (cnt * (cnt - 1LL))/2LL;\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\nusing namespace std;\n \n \nconst int mod=1e9+7;\nconst int maxn=1e6+10;\n \n \nmap<__int64,__int64> mp;\nvector<int> g[maxn];\n \n __int64 d[maxn];\n\n\n__int64 ans;\n\nint n; \n\n \nvoid dfs(int u,int fa){\n    d[u]=1;\n    for(int i=0;i<g[u].size();++i)\n\t{\n        int v=g[u][i];\n        if(v==fa)continue;\n        dfs(v,u);\n        d[u]+=d[v]*mod;\n    }\n    mp[d[u]]++;\n}\n \n \n\nint main()\n{\n\twhile(~scanf(\"%d\",&n))\n    {\n    \t\n    \tfor(int i=0; i<=n; i++)\n            g[i].clear();\n        mp.clear();\n        ans=0;\n        for(int i=1;i<n;i++)\n\t\t{\n            int u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n            g[u].push_back(v);\n\t\t\tg[v].push_back(u);\n        }\n      \n        dfs(1,0);\n        for(map<unsigned __int64,__int64>::iterator it=mp.begin(); it!=mp.end(); it++)\n            ans+=(__int64)it->second*(it->second-1)/2;\n        cout<<ans<<endl;\n    }\n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\ntypedef unsigned long long ull;\null B=5575777;\null ans=0;\nint n,a,b;\nvector<int> G[MAX_N];\nunordered_map<ull,ull> mp;\n\null dfs(int pos){\n  ull res=0;\n  for(int to:G[pos])res+=dfs(to);\n  res=res*B+1;\n  ans+=mp[res];\n  mp[res]++;\n  return res;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  for(int i=0;i<n-1;i++){\n    scanf(\"%d %d\",&a,&b);\n    G[a].push_back(b);\n  }\n  dfs(1);\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, a, b;\nvi e[100100];\nconst ll base[2] = {101119, 101141};\nconst ll mod[2] = {1000000007, 1000000021};\npll h[100100];\n\nvoid rec(int v, int p) {\n\tpll res;\n\teach(i,e[v]) if (i!=p) {\n\t\trec(i,v);\n\t\t(res.fi += h[i].fi) %= mod[0];\n\t\t(res.se += h[i].se) %= mod[1];\n\t}\n\t(res.fi *= base[0]) %= mod[0];\n\t(res.se *= base[1]) %= mod[1];\n\t(res.fi += 1) %= mod[0];\n\t(res.se += 1) %= mod[1];\n\th[v] = res;\n}\n\nsigned main() {\n\tcin >> n;\n\trep(i,n-1) {\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\te[a].pb(b), e[b].pb(a);\n\t}\n\trec(0,-1);\n\tmap<pll,ll> m;\n\trep(i,n) m[h[i]]++;\n\tll res = 0;\n\teach(i,m) res += i.se*(i.se-1)/2;\n\tcout << res << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e9+7;\nconst ll K = 633333;\nvector<int> e[N];\nvector<ll> hs;\nint d[N], f[N];\n\n\nvoid pre_dfs(int u, int dep){\n  if(u==0) return;\n  d[u] = max(d[u], dep);\n  pre_dfs(f[u], dep+1);\n}\n\nll dfs(int u){\n  ll ret = 17;\n  for(auto v: e[u]){\n    ret = (ret+K*dfs(v))%M;\n  }\n  hs.push_back((d[u])*ret);\n  return ret;\n}\n\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    d[u]++;\n    f[v] = u;\n    e[u].push_back(v);\n  }\n  for(int i = 1; i <= n; i++) if(!d[i]) pre_dfs(i, 0);\n  dfs(1);\n  ll ans = 0;\n  sort(hs.begin(), hs.end());\n  for(int i = 0; i < hs.size(); i++){\n    int s = i;\n    while(i < hs.size() && hs[i+1] == hs[i]) i++;\n    ans += (ll)(i-s+1)*(i-s)/2;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<queue>\n#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nusing namespace std;\nvector<int>tu[100100];\nqueue<int>have;\nint vis[100100];\nint dp[100100];\nset<int>maxdep;\nint fu[100100];\nint nedhai[100100];\nint nowhai[100100];\nclass YUAN\n{\npublic:\n    int len;\n    vector<int>node;\npublic:\n    void init()\n    {\n        len=0;\n        node.clear();\n    }\n    bool operator <(const YUAN &t)const\n    {\n        if(len!=t.len)return len<t.len;\n        for(int i=0;i<len;i++)\n        {\n            if(node[i]!=t.node[i])return node[i]<t.node[i];\n        }\n        return len<t.len;\n    }\n    bool operator ==(const YUAN &t)const\n    {\n        if(len!=t.len)return len==t.len;\n        for(int i=0;i<len;i++)\n        {\n            if(node[i]!=t.node[i])return node[i]==t.node[i];\n        }\n        return len==t.len;\n    }\n}yuan[100100],all[100100];\nlong long c(int x)\n{\n    return (long long)x*(long long)(x-1ll)/(long long)2;\n}\nvoid dfs(int root)\n{\n    //printf(\"%d\\n\",root);\n    if(yuan[root].len==0)\n    {\n        yuan[root].node.push_back(1);\n        yuan[root].len++;\n    }\n    vis[root]=1;\n    int siz=tu[root].size();\n    for(int i=0;i<siz;i++)\n    {\n        int new_node=tu[root][i];\n        if(vis[new_node]!=0)continue;\n        dfs(new_node);\n        vis[root]=max(vis[root],vis[new_node]+1);\n    }\n    if(vis[root]==1)\n    {\n        maxdep.insert(root);\n    }\n    return ;\n}\nlong long solve()\n{\n    long long res=0ll;\n    while(1)\n    {\n        while(have.size()!=0)have.pop();\n        set<int>::iterator it;\n        if(maxdep.size()==0)break;\n        int cnt=1;\n        for(it=maxdep.begin();it!=maxdep.end();it++)\n        {\n            int now=*it;\n            if(nowhai[now]!=nedhai[now])continue;\n            all[cnt++]=yuan[now];\n        }\n        sort(all+1,all+cnt);\n        dp[1]=1;\n        for(int i=2;i<=cnt-1;i++)\n        {\n            if(all[i]==all[i-1])\n            {\n                dp[i]=dp[i-1]+1;\n            }\n            else\n            {\n                dp[i]=1;\n                res+=c(dp[i-1]);\n            }\n        }\n        res+=c(dp[cnt-1]);\n        for(it=maxdep.begin();it!=maxdep.end();it++)\n        {\n            int now=*it;\n            int fuqin=fu[now];\n            if(fuqin==0)\n            {\n                yuan[now].init();\n                have.push(now);\n                continue;\n            }\n            if(nowhai[now]!=nedhai[now])continue;\n            while(yuan[fuqin].len<=yuan[now].len)\n            {\n                yuan[fuqin].node.push_back(0);\n                yuan[fuqin].len++;\n            }\n            for(int i=0;i<yuan[now].len;i++)\n            {\n                yuan[fuqin].node[i+1]+=yuan[now].node[i];\n            }\n            nowhai[fuqin]++;\n            yuan[now].init();\n            have.push(now);\n            maxdep.insert(fuqin);\n        }\n        while(have.size()!=0)\n        {\n            int x=have.front();\n            maxdep.erase(x);\n            have.pop();\n        }\n    }\n    return res;\n}\nint main()\n{\n    //freopen(\"E://input.txt\",\"r\",stdin);\n    int n;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        for(int i=1;i<=n+10;i++)\n        {\n            tu[i].clear();\n            yuan[i].init();\n            fu[i]=0;\n            nowhai[i]=0;\n            nedhai[i]=0;\n        }\n        for(int i=1;i<n;i++)\n        {\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            tu[x].push_back(y);\n            tu[y].push_back(x);\n            fu[y]=x;\n            nedhai[x]++;\n        }\n        memset(vis,0,sizeof(vis));\n        dfs(1);\n        long long res=solve();\n        printf(\"%lld\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\nusing namespace std;\ntypedef unsigned long long ull;\null const Base = 1000;\nint n,par[N],in[N];\n\null bfs(){\n  queue<int> Q;\n  ull ans=0;\n  map<ull,int> M[N];\n  ull H[N]={},dep[N]={};\n  for(int i=0;i<N;i++) H[i] = 1;\n  for(int i=0;i<n;i++)if(!in[i]) Q.push(i),ans+=M[0][1]++,H[i]=1;\n  \n  \n  while(!Q.empty()){\n    int pos = Q.front();Q.pop();\n    int nx = par[pos];\n    ull &A = H[pos],&B = H[nx];\n    dep[nx] = max(dep[nx],dep[pos]+1);\n    B+=A*Base;\n    if(--in[nx]==0)ans+=M[dep[nx]][B]++,Q.push(nx);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n;\n  for(int i=0,a,b;i<n-1;i++){\n    cin>>a>>b;\n    in[a-1]++,par[b-1] = a-1;\n  }\n  cout<<bfs()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <functional>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nusing lint = long long;\n\nconstexpr lint MOD = 1000000009, B = 100007;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    Graph<> graph(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        --u, --v;\n\n        graph[u].emplace_back(u, v);\n        graph[v].emplace_back(v, u);\n    }\n\n    std::map<lint, lint> cnt;\n    std::function<lint(int, int)>\n        dfs = [&](int v, int p) {\n            lint ret = 1;\n            for (auto e : graph[v]) {\n                if (e.dst == p) continue;\n                (ret += dfs(e.dst, v) * B % MOD) %= MOD;\n            }\n\n            if (!cnt.count(ret)) cnt[ret] = 0;\n            ++cnt[ret];\n\n            return ret;\n        };\n    dfs(0, -1);\n\n    lint ans = 0;\n    for (auto p : cnt) {\n        lint c = p.second;\n        ans += c * (c - 1) / 2;\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n    Hash(){\n        hash_value = 0;\n        num = 0;\n        left_child = right_child = -1;\n    }\n    ull hash_value;\n    ull num,left_child,right_child;\n};\n\nstruct HashTree{\npublic:\n    void init(int size){\n        hash = new Hash[size];\n        num_of_node = 0;\n    }\n\n    void addHash(ull value){\n        if(num_of_node == 0){\n            hash[0].hash_value = value;\n            hash[0].num = 1;\n            num_of_node++;\n            return;\n        }else{\n            int index = 0;\n\n            while(true){\n                if(value == hash[index].hash_value){\n                    hash[index].num++;\n                    return;\n                }else if(value > hash[index].hash_value){\n                    if(hash[index].right_child == -1){\n                        hash[index].right_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].right_child;\n                    }\n                }else{ //value < hash[index].hash_value\n                    if(hash[index].left_child == -1){\n                        hash[index].left_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].left_child;\n                    }\n                }\n            }\n        }\n    }\n\n    ull calc_ans(){\n        ull sum = 0;\n\n        for(int i = 0; i < num_of_node; i++){\n        \tsum += (hash[i].num)*(hash[i].num-1)/2;\n        }\n        return sum;\n    }\n\n    Hash* hash;\n    int num_of_node;\n};\n\nstruct Node{\n    vector<int> children;\n    int parent;\n};\n\nNode* node;\nHashTree HT;\n\nvector<int> calc(int node_id){\n\n    vector<int> Ret;\n    Ret.push_back(node[node_id].children.size());\n\n    for(int i = 0; i < node[node_id].children.size();i++){\n        vector<int> tmp = calc(node[node_id].children[i]);\n        for(int k = 0; k < tmp.size(); k++){\n            if(k+1 >= Ret.size()){\n                Ret.push_back(tmp[k]);\n            }else{\n                Ret[k+1] += tmp[k];\n            }\n        }\n    }\n\n    ull pre = 0,current = 0;\n\n    for(int i = 0; i < Ret.size(); i++){\n        current = Ret[i] + pre*MOD;\n        pre = current;\n    }\n    HT.addHash(current);\n\n    return Ret;\n}\n\nint main(){\n\n    int N;\n    scanf(\"%d\",&N);\n\n    node = (Node*)malloc(sizeof(Node)*(N+1));\n    HT.init(N);\n\n    int parent,child;\n    for(int i = 0; i < N-1; i++){\n        scanf(\"%d %d\",&parent,&child);\n        node[parent].children.push_back(child);\n        node[child].parent = parent;\n    }\n\n    calc(1);\n\n    printf(\"%lld\\n\",HT.calc_ans());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\nusing namespace std;\ntypedef unsigned long long ull;\null const Base = 1777771;\nint n,par[N],in[N];\n\null bfs(){\n  queue<int> Q;\n  ull ans=0;\n  map<ull,int> M[N];\n  vector<ull> H(n,1),dep(n,0);\n  for(int i=0;i<n;i++)if(!in[i])Q.push(i),ans+=M[0][1]++;\n  \n  while(!Q.empty()){\n    int pos = Q.front();Q.pop();\n    int nx = par[pos];\n    ull &A = H[pos],&B = H[nx];\n    dep[nx] = max(dep[nx],dep[pos]+1);\n    B+=A*Base;\n    if(--in[nx]==0)ans+=M[dep[nx]][B]++,Q.push(nx);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n;\n  for(int i=0,a,b;i<n-1;i++){\n    cin>>a>>b;\n    in[a-1]++,par[b-1] = a-1;\n  }\n  cout<<bfs()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e15+7;\nconst ll K = 17;\nvector<int> e[N];\nmap<ll,int>hs;\nmap<ll,int>::iterator it;\nll dfs(int u){\n  ll ret = 0;\n  for(auto& v: e[u])\n    ret = (ret+K*dfs(v)+1)%M;\n  ++hs[ret];\n  return ret;\n}\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    e[u].push_back(v);\n  }\n  dfs(1);\n  ll ans = 0;\n  for(it = hs.begin(); it!=hs.end(); ++it) ans += (it->second)*(it->second-1)/2;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int mod=1e9+7;\nconst int N=1e5+5;\nint dep[N],hd;\nstruct node{\n\tint v,nxt;\n}p[N];\nint head[N],son[N],tot;\null a[N],p2[N],p3[N],b[N];\nvoid add(int x,int y){\n\tp[tot].v=y;\n\tp[tot].nxt=head[x];\n\thead[x]=tot++;\n}\nvoid init(){\n\ttot=0;\n\tp3[0]=p2[0]=1;\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<N;i++){\n\t\tp2[i]=2*p2[i-1];\n\t\tp3[i]=2*p3[i-1];\n\t}\n}\nmap<pair<ull,ull>,int>mp;\nmap<pair<ull,ull>,int>::iterator it;\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];~i;i=p[i].nxt){\n\t\tint y=p[i].v;\n\t\tif(y==fa)\n\t\t\tcontinue;\n\t\tdfs(y,x);\n\t\tdep[x]=max(dep[y],dep[x]);\n\t}\n\tfor(int i=head[x];~i;i=p[i].nxt){\n\t\tint y=p[i].v;\n\t\tif(y==fa)\n\t\t\tcontinue;\n\t\ta[x]=a[x]+a[y]*p2[dep[x]-dep[y]];\n\t\tb[x]=b[x]+b[y]*p3[dep[x]-dep[y]];\n\t}\n\tdep[x]++;\n\ta[x]=a[x]+p2[dep[x]];\n\tb[x]=b[x]+p3[dep[x]];\n\t//cout<<x<<' '<<a[x]<<' '<<dep[x]<<endl;\n\tmp[make_pair(b[x],a[x])]++;\n\thd++;\n}\nint main(){\n\tinit();\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdfs(1,0);\n\tll ans=0;\n\tfor(it=mp.begin();it!=mp.end();it++){\n\t\tint t=it->second;\n\t\t//cout<<t<<endl;\n\t\tans+=1ll*t*(t-1)/2;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\ntypedef unsigned long long ull;\null B=5575777;\null ans=0;\nint n,a,b;\nvector<int> G[MAX_N];\nmap<ull,ull> mp;\n\null dfs(int pos){\n  ull res=0;\n  for(int i=0;i<(int)G[pos].size();i++)\n    res+=dfs(G[pos][i]);\n  res=res*B+1;\n  ans+=mp[res];\n  mp[res]++;\n  return res;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  for(int i=0;i<n-1;i++){\n    scanf(\"%d %d\",&a,&b);\n    G[a].push_back(b);\n  }\n  dfs(1);\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nvector<int> G[1 << 17];\n\nconst ll t = 999999937;\nconst ll m = mod+2;\n\nvector<ll> h;\n\nvoid dfs(int v, int fr) {\n\th[v] = 0;\n\trep(j, G[v].size()) {\n\t\tint to = G[v][j];\n\t\tif (to == fr)continue;\n\t\tdfs(to, v);\n\t\th[v] += h[to];\n\t\tif (h[v] >= m)h[v] -= m;\n\t}\n\th[v] = (h[v] * t+1)%m;\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\th.resize(n);\n\tdfs(0, -1);\n\tsort(h.begin(), h.end());\n\tll ans = 0;\n\trep(i, h.size()) {\n\t\tint le = i;\n\t\twhile (i + 1 < n&&h[i + 1] == h[i])i++;\n\t\tll len = i - le + 1;\n\t\tans += len * (len - 1) / 2;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\ndouble dist(star s1,star s2){\n\tdouble ans=10000000000.0;\n\t\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\tif( is_intersected_ls(s1.se[i],s2.se[j])) {\n\t\t\t\n//\t\t\tcout<<s1.se[i].p1.x<<\" \"<<s1.se[i].p1.y<<endl;\n//\t\t\tcout<<s1.se[i].p2.x<<\" \"<<s1.se[i].p2.y<<endl;\n//\t\t\tcout<<s2.se[j].p1.x<<\" \"<<s2.se[j].p1.y<<endl;\n//\t\t\tcout<<s2.se[j].p2.x<<\" \"<<s2.se[j].p2.y<<endl;\n\t\treturn 0.0;\n\t\t}\n\t\tans=min(ans,segment_dis(s1.se[i],s2.se[j]));\n//\t\tcout<<\"   \"<<i<<\" \"<<j<<\" \"<<segment_dis(s1.se[i],s2.se[j])<<endl;\n\t}\n\treturn ans;\n}\nvector<int> G[100030];\nmap<int,int>ma;\nint a[100030];\n\n\nvoid saiki(int r,int mae){\n\tif(G[r].size()==0){\n\t\ta[r]=1;\n\t\treturn;\n\t}\n\t\n\tfor(auto v:G[r])if(v!=mae)saiki(v,r);\n\tint d=0;\n\tfor(auto v:G[r])if(v!=mae){\n\t\td+=a[v];\n\t\td%=inf;\n\t}\n\td=(d*11+1)%inf;\n\ta[r]=d;\n\treturn;\n}\n\n     signed main(){\nint n;\n     cin>>n;\n     \tfor(int i=0;i<n-1;i++){\n     \t\tint r,rr;\n     \t\tcin>>r>>rr;\n     \t\tG[r].pb(rr);\n     \t\tG[rr].pb(r);\n     \t}\n     \tsaiki(1,-1);\n     \tfor(int i=1;i<=n;i++){\n     \t\tma[a[i]]++;\n     \t//\tcout<<a[i]<<endl;\n     \t}\n     \tint ans=0;\n     \tfor(auto it=ma.begin();it!=ma.end();it++){\n     \t\tint y=(*it).second;\n     \t\tans+=y*(y-1)/2;\n     \t}\n     \t\n     \n     \t\n     \tcout<<ans<<endl;\n     \t\n\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nvector<int> G[100000];\n\nconst ll H = (1LL<<30)+1;\nconst ll B = 100000;\n\nll ans=0;\nmap<ll,int> hs;\n\nll dfs(int cur,int bef,int depth){\n    ll ret = 0;\n    bool isLeaf=true;\n    for(auto &e:G[cur]){\n        if(e==bef)continue;\n        isLeaf = false;\n        ret += dfs(e,cur,depth+1);\n    }\n    \n    if(isLeaf){\n        if(hs.count(1)){\n            ans+=hs[1];\n        }\n        hs[1]++;\n        return 1;\n    }\n    \n    if(hs.count((ret*B + 1)%H)){\n        ans+=hs[(ret*B + 1)%H];\n    }\n    hs[(ret*B + 1)%H]++;\n    return (ret*B + 1)%H;\n}\n\n\nint main(){\n    int v;\n    cin>>v;\n    rep(i,v-1){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    ll res = dfs(0,-1,0);\n    if(hs.count(res))ans+=hs[res];\n    hs[res]++;\n    \n    cout<<ans-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull base = 1000000007;\nint n, a, b; vector<vector<int> > G; map<ull, int> cnt;\null solve(int pos, int pre) {\n\tull ret = 1;\n\tfor (int i : G[pos]) {\n\t\tif (i == pre) continue;\n\t\tret += solve(i, pos) * base;\n\t}\n\tcnt[ret]++;\n\treturn ret;\n}\nint main() {\n\tcin >> n; G.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b; a--, b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tsolve(0, -1);\n\tull ret = 0;\n\tfor (pair<ull, int> i : cnt) ret += 1ULL * i.second * (i.second - 1) / 2;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define LL long long\nLL f[100005],ff[100005];\nint main()\n{\n    LL n;\n    while(scanf(\"%lld\",&n)!=EOF)\n    {\n        LL i,j;\n        memset(f,0,sizeof(f));\n        memset(ff,0,sizeof(ff));\n        LL a,b;\n        for(i=0;i<n-1;i++)\n        {\n            scanf(\"%lld %lld\",&a,&b);\n            f[b]=f[a]+1;\n        }\n        LL ma=0,z;\n        for(i=1;i<=n;i++)\n        {\n            z=f[i];\n            if(z>ma)\n                ma=z;\n            ff[z]++;\n        }\n        LL sum=0;\n        for(i=1;i<=ma;i++)\n        {\n            if(ff[i]>=2)\n                sum=sum+(ff[i]*(ff[i]-1))/2;\n        }\n        printf(\"%lld\\n\",sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <iostream> \nusing namespace std;\nstruct node\n{\n\tint x,y;\n}a[200010];\nint ednum[100010];\nint flag[100010];\nunsigned long long dis[100010];\nbool cmp(const node &a,const node &b)\n{\n\tif(a.x==b.x) return a.y<b.y;\n\treturn a.x<b.x;\n}\nunsigned long long dfs(long long x)\n{\n\tlong long j;\n\tunsigned long long ans=0,num=0;\n\tfor(j=ednum[x-1];j<ednum[x];j++)\n\tif(flag[a[j].y]==0)\n\t{\n\t\tflag[a[j].y]=1;\n\t\tnum=num+1;\n\t\tans=ans+dfs(a[j].y);\n\t\tflag[a[j].y]=0;\n\t}\n\tdis[x]=num+ans*100003;\n\treturn dis[x];\n} \nint main()\n{\n\tlong long i,j,n,len,x,num,ans;\n\twhile(~scanf(\"%lld\",&n))\n\t{\n\t\tmemset(ednum,0,sizeof(ednum));\n\t\tfor(i=0;i<n-1;i++) \n\t\t{\n\t\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\t\ta[i+n-1].x=a[i].y;\n\t\t\ta[i+n-1].y=a[i].x;\n\t\t\tednum[a[i].x]++; ednum[a[i].y]++;\n\t\t}\n\t\tfor(i=1;i<=n;i++) ednum[i]+=ednum[i-1];\n\t\tsort(a,a+2*n-2,cmp);\n\t\tmemset(dis,0,sizeof(dis));\n\t\tmemset(flag,0,sizeof(flag));\n\t\tflag[1]=1;\n\t\tdfs(1);\n\t\tsort(dis,dis+n);\n\t\tans=0;\n\t\tfor(i=1,num=1;i<n;i++)\n\t\t{\n\t\t\tif(dis[i]==dis[i-1]) num++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tans=ans+(num-1)*num/2;\n\t\t\t\tnum=1;\n\t\t\t}\n\t\t}\n\t\tans=ans+(num-1)*num/2;\n/*\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tprintf(\"i:%lld dis:%llu\\n\",i,dis[i]);\n\t\t}*/\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mx 100002\nvector<int>graph[mx+5];\nint node[mx+5],mxdepth[mx+5];\nmap<pair<int, int>, int >depth;\n\nint dfs1(int u)\n{\n    if(graph[u].size()==0){\n         depth[make_pair(u,0)]=1;\n        return 0;\n    }\n\n    int ret = 0;\n    for(int i=0; i<graph[u].size(); i++) {\n        int v = graph[u][i];\n        ret =max(ret, 1+dfs1(v));\n    }\n\n    depth[make_pair(u,0)]=1;\n    for(int i=0; i<graph[u].size(); i++){\n        int v = graph[u][i];\n        for(int k=0; k<mxdepth[v]; k++){\n            pair<int,int>p=make_pair(v,k);\n            depth[make_pair(u,k+1)]+=depth[p];\n        }\n    }\n\n    return mxdepth[u]=ret;\n}\nint dfs2(int u)\n{\n    if(graph[u].size()==0){\n        node[u]=0;\n        return 0;\n    }\n\n    int ret = 0;\n    for(int i=0; i<graph[u].size(); i++) {\n        int v = graph[u][i];\n        int n1=1+dfs2(v);\n        ret +=n1;\n    }\n\n    return node[u] = ret;\n}\nint main()\n{\n    int n;\n\n    while(scanf(\"%d\",&n)==1)\n    {\n        memset(node,0,sizeof(node));\n        for(int i=0; i<=n; i++) graph[i].clear();\n        depth.clear();\n\n        for(int i=1; i<=n-1; i++)\n        {\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            graph[u].push_back(v);\n        }\n\n        dfs1(1);\n        dfs2(1);\n\n        for(int i=1; i<=n; i++)node[i]++;\n\n        //map<pair<int, int>, int>m;\n        map<pair< int, map<pair<int, int>, int > >, int >m;\n\n        for(int i=1; i<=n; i++) {\n            m[make_pair(node[i], depth)]++;\n        }\n\n        map<pair< int, map<pair<int, int>, int > >, int > :: iterator it;\n        long long ans=0;\n        for(it= m.begin(); it!=m.end(); it++) {\n            long long var = it->second;\n            ans+=((var)*(var-1))/2;\n        }\n\n        printf(\"%lld\\n\",ans);\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\ntypedef long long int LL;\n\n\nvector<int >ve[N];\nmap< LL , int >ma;\nLL a[N];\nLL b=10e2+7;\nLL ans;\nvoid dfs(int u)\n{\n    a[u]=1;\n    for(int i=0;i<ve[u].size();i++)\n    {\n        int v=ve[u][i];\n        dfs(v);\n        a[u]+=a[v]*b;\n    }\n    ans+=ma[a[u]];\n    ma[a[u]]++;\n    return ;\n}\n\nint main()\n{\n    int n;\n        cin>>n;\n        int u,v;\n        for(int i=0;i<n-1;i++)\n        {\n            cin>>u>>v;\n            ve[u].push_back(v);\n        }\n        ans=0;\n        dfs(1);\n        cout<<ans<<endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define mem(Arr,x) memset(Arr,x,sizeof(Arr))\n\nconst int maxN=101000;\nconst int maxM=maxN*2;\nconst ull base=20729;\nconst int inf=2147483647;\n\nint n;\nint edgecnt=0,Head[maxN],Next[maxM],V[maxM];\null W[maxN];\n\nvoid dfs(int u);\n\nint main()\n{\n\tmem(Head,-1);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\tedgecnt++;Next[edgecnt]=Head[a];Head[a]=edgecnt;V[edgecnt]=b;\n\t}\n\tdfs(1);\n\tsort(&W[1],&W[n+1]);\n\t//for (int i=1;i<=n;i++) cout<<W[i]<<\" \";cout<<endl;\n\tll Ans=0;\n\tW[++n]=inf;\n\tfor (int i=1,j=0;i<=n;i++) if (W[i]!=W[j]) Ans=Ans+1ll*(ll)(i-1-j+1)*(ll)(i-1-j)/2,j=i;\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}\n\nvoid dfs(int u)\n{\n\tW[u]=1;\n\tfor (int i=Head[u];i!=-1;i=Next[i])\n\t{\n\t\tdfs(V[i]);\n\t\tW[u]=W[u]+W[V[i]]*base;\n\t}\n\treturn;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll mod = 1e9 + 7;\nconst ll b = 117;\n\nvector<int> G[100000];\nint used[100000];\n\nll hs[100000];\n\nll dfs(int n) {\n\tused[n] = 1;\n\tll res = 1;\n\tfor (auto v : G[n]) {\n\t\tif (!used[v]) {\n\t\t\tres = (res + dfs(v) * b) % mod;\n\t\t}\n\t}\n\treturn hs[n] = res;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tfor (int i = 0, a, b; i < N - 1; i++) {\n\t\tcin >> a >> b;\n\t\tG[a - 1].push_back(b - 1);\n\t\tG[b - 1].push_back(a - 1);\n\t}\n\tdfs(0);\n\tsort(hs, hs + N);\n\tll res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tauto p = equal_range(hs, hs + N, hs[i]);\n\t\tres += p.second - p.first - 1;\n\t}\n\tcout << res / 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nmap<ll, int> dic;\nvector<vi> graph;\n\nll mod1 = 1e9+7LL;\nint base1 = 10007;\n\nll dfs(int v, int pv, int d){\n    ll ret = 0LL;\n    for(int nv : graph[v]){\n        if(nv == pv) continue;\n        ret = ADD(ret, dfs(nv, v, d + 1), mod1);\n    }\n    ret = MUL(ret, base1, mod1);\n    ret = ADD(ret, 1LL, mod1);\n\n    dic[ret]++;\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    graph = vector<vi>(n);\n\n    rep(i, n - 1){\n        int a, b; cin >> a >> b; a--, b--;\n        graph[a].emplace_back(b);\n        graph[b].emplace_back(a);\n    }\n    dfs(0, -1, 0);\n\n    ll res = 0LL;\n    for(auto& e : dic){\n        int num = e.second;\n        res += num * (num - 1) / 2;\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint b = 1007, mo = 1e9+7;\nVI g[100010];\nmap<int,int> v;\n// 部分木xのハッシュを返す\nint func(int x, int p) {\n  int ret = b;\n  for(int e: g[x]) {\n    if(e == p) continue;\n    (ret += func(e, x) * b % mo) %= mo;\n  }\n  v[ret]++;\n  return ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n-1) {\n    int a, b;\n    cin >> a >> b; a--, b--;\n    g[a].PB(b);\n    g[b].PB(a);\n  }\n\n  mo = 1e9+7;\n  b = rand() % mo;\n  v.clear();\n  func(0, -1);\n\n  int ret = 0;\n  for(auto i: v) ret += i.second*(i.second-1)/2;\n  cout << ret << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<ctime>\n#include<algorithm>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#define INF 0x3f3f3f3f\n#define inf 2*0x3f3f3f3f\n#define llinf 1000000000000000000\n#define pi acos(-1.0)\n#define mod 1000000007\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\n#define lrt rt<<1\n#define rrt rt<<1|1\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define mem(a,b) memset(a,b,sizeof(a))\n#define lb(x) (x&-x)\n#define gi(x) scanf(\"%d\",&x)\n#define gi2(x,y) scanf(\"%d%d\",&x,&y)\n#define gll(x) scanf(\"%lld\",&x)\n#define gll2(x,y) scanf(\"%lld%lld\",&x,&y)\n#define gc(x) scanf(\"%c\",&x)\n#define gc2(x,y) scanf(\"%c%c\",&x,&y)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int>P;\n/***********************************************/\nint n,x,y;\nvector<int>v[100005];\nll f[100005],num;\nvoid dfs(int x,int pr)\n{\n    f[x]=1;\n    for(int i=0;i<v[x].size();i++)\n    {\n        if(v[x][i]==pr)continue;\n        dfs(v[x][i],x);\n        f[x]+=f[v[x][i]]*num;\n    }\n}\nll cal()\n{\n    map<ll,int>mm;\n    ll sum=0;\n    rep(i,1,n+1)\n    {\n        sum+=mm[f[i]];\n        mm[f[i]]++;\n    }\n    return sum;\n}\nint main()\n{\n    gi(n);\n    srand((ull)time(0));\n    rep(i,0,n-1)\n    {\n        gi2(x,y);\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    ll ans=1e16;\n    rep(i,0,10)\n    {\n        num=rand();\n        dfs(1,1);\n        ans=min(ans,cal());\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\nconst ll base = 1013;\n\nint N, hashes[100010];\nvector<int> G[100010];\n\nvoid dfs(int cur, int par=-1) {\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        dfs(to, cur);\n        (hashes[cur] += hashes[to]) %= MOD;\n    }\n    (hashes[cur] *= base) %= MOD;\n    (hashes[cur] += 1) %= MOD;\n}\n\nmap<int, int> memo;\nsigned main() {\n    cin >> N;\n    for(int i=0; i<N-1; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    dfs(0);\n    for(int i=0; i<N; i++) memo[hashes[i]]++;\n\n    int ans = 0;\n    for(auto e : memo) ans += e.second * (e.second - 1) / 2;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint gi(){\n\tint x=0,w=1;char ch=getchar();\n\twhile ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif (ch=='-') w=0,ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\n#define ull unsigned long long\nconst int N = 2e5+5;\nconst ull base1 = 20020415;\nconst ull base2 = 20011118;\nint n,to[N],nxt[N],head[N],cnt;\null Hash[N],ans;\nvoid link(int u,int v){\n\tto[++cnt]=v;nxt[cnt]=head[u];head[u]=cnt;\n}\nvoid dfs(int u,int f){\n\tHash[u]=base1;\n\tfor (int e=head[u];e;e=nxt[e])\n\t\tif (to[e]!=f) dfs(to[e],u),Hash[u]+=Hash[to[e]]*base2;\n}\nint main(){\n\tn=gi();\n\tfor (int i=1;i<n;++i){\n\t\tint u=gi(),v=gi();\n\t\tlink(u,v);link(v,u);\n\t}\n\tdfs(1,0);sort(Hash+1,Hash+n+1);\n\tfor (int i=1,j;i<=n;i=j){\n\t\tj=i+1;\n\t\twhile (j<=n&&Hash[j]==Hash[i]) ++j;\n\t\tans+=1ll*(j-i)*(j-i-1)/2;\n\t}\n\tprintf(\"%llu\\n\",ans);return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\n#define ll long long\nusing namespace std;\nconst ll maxn = 1000050;\nconst ll mod = 1e12+7;\nconst ll p = 4903;\nll C[100050];\nll ha[maxn] = {0};\n//vector<int> G[maxn];\nint SG[maxn] = {0};\nint fa[maxn] = {0};\nmap<ll,ll> T;\nll n;\nint vis[maxn]={0};\nvoid bfs(){\n\tint i;\n\tqueue<int> q;\n\tfor(i=1;i<=n;++i){\n\t\tha[i] = 1;\n\t\tif(SG[i]==0) {\n\t\t\tq.push(i);vis[i] = 1;\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tif(t==1) continue;\n\t\tif(SG[t]!=0){//儿子没跟完 \n\t\t\tq.push(t);continue;\n\t\t}\n\t\tha[fa[t]] = (ha[fa[t]]+ha[t]*p)%mod;\n\t\tSG[fa[t]]--;//少一个儿子 \n\t\t\n\t\tif(!vis[fa[t]]){//队列里还没有过 \n\t\t\tvis[fa[t]] = 1;q.push(fa[t]);\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i){\n\t\tif(T.find(ha[i])!=T.end()) T[ha[i]]++;\n\t\telse T[ha[i]] = 1;\n\t}\n}\nint main(){\n\tint i,a,b;\n\tcin>>n;\n//\tfor(i=1;i<=n;++i) G[a].clear();\n\tfor(i = 1;i < n; ++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\t//G[a].push_back(b);\n\t\tSG[a]++;\n\t\tfa[b] = a;\n\t}\n\tT.clear();\n\tbfs();\n\tmap<ll,ll>::iterator it;\n\tll ans = 0;\n\tfor(it = T.begin();it!=T.end();++it){\n\t//\tcout<<it->second<<endl;\n\t\tans+=it->second*(it->second-1)/2;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define read() freopen(\"input.txt\", \"r\", stdin)\n\n#define ll64 long long\n#define BASE 100000007\n#define MOD 100000077\n\nll64 BP[300010];\nbool visited[100010];\nvector<int> graph[100010];\nmap<ll64, ll64> C_M;\n\nll64 dfs(int u)\n{\n    //printf(\"=>%d\\n\", u);\n    visited[u] = true;\n    ll64 hsh = 1;\n    for(auto v: graph[u]){\n        if(!visited[v]){\n            hsh += (dfs(v) * BASE) % MOD;\n            hsh %= MOD;\n        }\n    }\n    C_M[hsh] += 1;\n    return hsh;\n}\n\nint main()\n{\n    //read();\n    ll64 temp = 1;\n    for(int i = 0; i < 200000; i++){\n        BP[i] = temp;\n        temp = (temp * BASE) % MOD;\n    }\n    int N;\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N - 1; i++){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    dfs(1);\n    ll64 ans = 0;\n    for(auto &it: C_M){\n        ll64 x = it.second;\n        ans += (x * (x - 1)) / 2;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define M 1777771\n#define N 100005\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair<ull,int> P;\ntypedef long long ll;\n\nconst ll mod = 1e9+7;\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n \nll nCr(ll n,ll r){\n  static vector<ll> k(1e6);\n  if(!k[0]){k[0]=1;for(int i=1;i<k.size();i++)k[i]=i*k[i-1]%mod;}\n  ll a=mod_pow(k[r],mod-2);\n  ll b=mod_pow(k[n-r],mod-2);\n  return ((k[n]*a)%mod)*b%mod;\n}\n\nll n,a,b,maxd[N];\nvector<int> G[N];\nmap<ull,int> S;\null A[N];\n\nint get_maxd(int x,int d){\n  int res=d;\n  rep(i,G[x].size())\n    res=max(res,get_maxd(G[x][i],d+1));\n  return maxd[x]=res;\n}\n\nP dfs(int x,int d){\n  ull res1=0;\n  int res2=d;\n  \n  rep(i,G[x].size()){\n    P r=dfs(G[x][i],d+1);\n    res1+=r.first*A[maxd[x]-r.second];\n    res2=max(res2,r.second);\n  }\n  res1+=A[res2-d];\n  \n  if(S.count(res1))S[res1]++;\n  else S[res1]=1;\n  \n  return P(res1,res2);\n}\n\nint main(){\n  cin>>n;\n  \n  rep(i,n-1){\n    cin>>a>>b;\n    G[a-1].push_back(b-1);\n  }\n  \n  A[0]=1;\n  for(int i=1;i<N;i++)A[i]=A[i-1]*M;\n  \n  get_maxd(0,0);\n  \n  dfs(0,0);\n\n  ll ans=0;\n  \n  map<ull,int>::iterator ite=S.begin();\n  \n  while(ite!=S.end()){\n    if((*ite).second>=2)\n      ans+=nCr((*ite).second,2);\n    ite++;\n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvector<ll>adj[100005];\nll len[1000006];\nvoid dfs(int x,int l)\n{\n    len[l]++;\n    for(int i=0;i<adj[x].size();i++)\n    {\n    dfs(adj[x][i],l+1);\n    }\n}\nint main()\n{\n    ll i,n,x,y,cnt;\n    while(scanf(\"%lld\",&n)==1)\n    {\n     for(i=1;i<n;i++)\n     {\n        scanf(\"%lld%lld\",&x,&y);\n        adj[x].push_back(y);\n     }\n    dfs(1,0);\n    cnt=0;\n    for(i=1;i<=1000006;i++)\n    {\n    x=len[i];\n    x=(x*(x-1))/2;\n    cnt+=x;\n    }\n    printf(\"%lld\\n\",cnt);\n    for(i=1;i<=n;i++)adj[i].clear();\n    memset(len,0,sizeof len);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//OM\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <sstream>\n#include <algorithm>\nusing  namespace  std;\n\n#define  x first\n#define  y second\n#define  pb push_back\n#define  mp make_pair\n#define  PI (acos(-1.0))\n#define  mem(a,b) memset(a,b,sizeof(a))\n#define  Sort(x) sort(x.begin(),x.end())\n#define  FOR(i, b, e) for(int i = b; i <= (int)(e); i++)\n#define  FORR(i, b, e) for(int i = b; i >=(int)(e); i--)\n#define  FORI(i, s) for (__typeof ((s).end ()) i = (s).begin (); i != (s).end (); ++i)\n#define  pr(x) cout<<x<<\"\\n\"\n#define  prs(x) cout<<x<<\" \"\n#define  pr2(x,y) cout<<x<<\" \"<<y<<\"\\n\"\n#define  pr3(x,y,z) cout<<x<<\" \"<<y<<\" \"<<z<<\"\\n\"\n#define  ppr(a) cout<<a.x<<\" \"<<a.y<<\"\\n\"\n\ntypedef  long long ll;\ntypedef  pair <int, int> pii;\ntypedef  pair <double , double> pdd;\ntypedef  vector <int> vi;\ntypedef  vector <pii> vpii;\n\n//int dx[]={1,0,-1,0};int dy[]={0,1,0,-1}; //4 Direction\n//int dx[]={1,1,0,-1,-1,-1,0,1};\n//int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction\n\n#define  EPS 1e-9\n#define  MAX 100007\nvi edge[MAX];\nint depth[MAX];\nlong long p = 77777377;      // prime number\nlong long M = 74747474747474747ll;  // prime number\nlong long pw[MAX];\nint mxdep;\nvoid DFS(int u,int dep)\n{\n    depth[u]=dep;\n    mxdep=max(dep,mxdep);\n    FOR(i,0,edge[u].size()-1)\n    {\n        DFS(edge[u][i],dep+1);\n    }\n}\n\n\nmap<ll ,ll > Map;\nll  DFScal(int u)\n{\n    ll res=0;\n    FOR(i,0,edge[u].size()-1)\n    {\n        res= (res+ DFScal(edge[u][i])*pw[depth[u]- depth[edge[u][i]]] )%M;\n    }\n    //pr2(u,res);\n    res=(res+pw[depth[u]])%M;\n    Map[res]++;\n    return res;\n}\n\nint main()\n{\n    int T,n,u,v;\n    scanf(\"%d\",&n);\n    FOR(i,1,n-1)\n    {\n        scanf(\"%d\",&u);\n        scanf(\"%d\",&v);\n        edge[u].pb(v);\n    }\n    DFS(1,0);\n    pw[0]=1;\n    for(int i=1;i<=mxdep;i++)pw[i]=(pw[i-1]*p)%M;\n    DFScal(1);\n    ll ans=0;\n    ll faltu=0;\n    FORI(it,Map)\n    {\n        ll cnt=it->y;\n        ans=ans+(1ll*(cnt)*(cnt-1));\n    }\n    printf(\"%lld\\n\",ans/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n\tHash(){\n\t\thash_value = 0;\n\t\tnum = 0;\n\t\tleft_child = right_child = -1;\n\t}\n\tull hash_value;\n\tint num,left_child,right_child;\n};\n\nclass HashTree{\npublic:\n\tHashTree(int size){\n\t\thash = new Hash[size];\n\t\tnum_of_node = 0;\n\t}\n\n\tvoid addHash(ull value){\n\t\tif(num_of_node == 0){\n\t\t\thash[0].hash_value = value;\n\t\t\thash[0].num = 1;\n\t\t\tnum_of_node++;\n\t\t\treturn;\n\t\t}else{\n\t\t\tint index = 0;\n\n\t\t\twhile(true){\n\t\t\t\tif(value == hash[index].hash_value){\n\t\t\t\t\thash[index].num++;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(value > hash[index].hash_value){\n\t\t\t\t\tif(hash[index].right_child == -1){\n\t\t\t\t\t\thash[index].right_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].right_child;\n\t\t\t\t\t}\n\t\t\t\t}else{ //value < hash[index].hash_value\n\t\t\t\t\tif(hash[index].left_child == -1){\n\t\t\t\t\t\thash[index].left_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].left_child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull calc_ans(){\n\t\tull sum = 0;\n\n\t\tfor(int i = 0; i < num_of_node; i++){\n\t\t\tfor(int k = 1; k <= hash[i].num-1; k++){ //hash[i].numC2????¨????\n\t\t\t\t\tsum += k;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tHash* hash;\n\tint num_of_node;\n};\n\nstruct Node{\n\tvector<int> children;\n\tint parent;\n};\n\nNode* node;\n\nvector<int> calc(int node_id,HashTree HT){\n\n\tvector<int> Ret;\n\tRet.push_back(node[node_id].children.size()); //node[node_id]??????????????±???1?????????????????°??????????????°??????????????????\n\n\tfor(int i = 0; i < node[node_id].children.size();i++){\n\t\tvector<int> tmp = calc(node[node_id].children[i],HT); //????????????vector?????°???\n\t\tfor(int k = 0; k < tmp.size(); k++){\n\t\t\tif(k+1 >= Ret.size()){ //?????????????????????????????????????????\\????????´?????????????¶???? size()???A?????????vector????????????????????????0???A-1\n\t\t\t\tRet.push_back(tmp[k]);\n\t\t\t}else{\n\t\t\t\tRet[k+1] += tmp[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tull pre = 0,current = 0;\n\n\tfor(int i = 0; i < Ret.size(); i++){\n\t\tcurrent = Ret[i] + pre*MOD;\n\t\tpre = current;\n\t}\n\tHT.addHash(current);\n\n\treturn Ret;\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tnode = (Node*)malloc(sizeof(Node)*(N+1));\n\tHashTree HT(N);\n\n\tint parent,child;\n\tfor(int i = 0; i < N-1; i++){\n\t\tscanf(\"%d %d\",&parent,&child);\n\t\tnode[parent].children.push_back(child);\n\t\tnode[child].parent = parent;\n\t}\n\n\t//?????????????????????????????±?????¨????????°????¨???????????????£??????\n\tcalc(1,HT);\n\n\tprintf(\"%lld\\n\",HT.calc_ans());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define MOD 1000000007\n#define DOM 1000000009\n#define BASE 1000000021\n\nusing P = pair<int,pair<long,long>>;\n// depth, hash1, hash2\n\nvector<int> tree[100005];\nmap<pair<int,pair<long,long>>,int> memo;\n\nP dfs(int v, int from){\n  long h1 = 1, h2=1;\n  int d = 1;\n  for(auto to : tree[v]) if(to!=from){\n    P p = dfs(to,v);\n    d = max(d, p.fi+1);\n    h1 += p.se.fi*MOD;\n    h1 %= BASE;\n    h2 += p.se.se*DOM;\n    h2 %= BASE;\n  }\n  P p = mp(d,mp(h1,h2));\n  memo[p]++;\n  return p;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    tree[a].pb(b);\n    tree[b].pb(a);\n  }\n\n  dfs(0,-1);\n\n  long ans = 0;\n  for(auto &p : memo){\n    ans += (long)p.se * (p.se-1) / 2;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mst(a,b) memset(a,b,sizeof(a))\n#define cmax(a,b) a = max(a,b)\n#define ft first\n#define sd second\n#define mp(a,b) make_pair(a,b)\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 1e5+19;\nconst int PP = 317;\nconst int maxp = 9999901;\n\nstruct edge{\n\tint v,p;\n\tedge(){}\n\tedge(int V,int P):v(V),p(P){}\n}e[maxn<<1];\n\nint hash[maxp],f[maxn],ed,lst[maxn],rnk[maxn];\n\nvoid init() {\n\tmst(hash,0);mst(f,0);\n\tmst(lst,-1);mst(rnk,0);\n\ted = -1;\n}\n\nvoid add_edge(int u,int v) {\n\te[++ed] = edge(v,lst[u]);lst[u] = ed;\n\te[++ed] = edge(u,lst[v]);lst[v] = ed;\n}\n\nint solve(int u,int fa) {\n\tf[u] = 0;\n\tint v;\n\tfor(int i = lst[u] ; ~i ; i = e[i].p) {\n\t\tv = e[i].v;\n\t\tif(v != fa) \n\t\t\tf[u] = ((LL)f[u]+(LL)solve(v,u)*(LL)PP%maxp)%maxp;\n\t}\n\tf[u] += 1;\n\t++hash[f[u]];\n\treturn f[u];\n}\n\nint main() {\n\tinit();\n\tint n,x,y;\n\tLL ans = 0;\n\tscanf(\"%d\",&n);\n\tfor(int i = 1 ; i < n ; ++i) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd_edge(x,y);\n\t}\n\tsolve(1,-1);\n\tfor(int i = 0 ; i < maxp ; ++i) \n\t\tans += (LL)hash[i]*(LL)(hash[i]-1)/2;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n\tHash(){\n\t\thash_value = 0;\n\t\tnum = 0;\n\t\tleft_child = right_child = -1;\n\t}\n\tull hash_value;\n\tint num,left_child,right_child;\n};\n\nstruct HashTree{\npublic:\n\tvoid init(int size){\n\t\thash = new Hash[size];\n\t\tnum_of_node = 0;\n\t}\n\n\tvoid addHash(ull value){\n\t\tif(num_of_node == 0){\n\t\t\thash[0].hash_value = value;\n\t\t\thash[0].num = 1;\n\t\t\tnum_of_node++;\n\t\t\treturn;\n\t\t}else{\n\t\t\tint index = 0;\n\n\t\t\twhile(true){\n\t\t\t\tif(value == hash[index].hash_value){\n\t\t\t\t\thash[index].num++;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(value > hash[index].hash_value){\n\t\t\t\t\tif(hash[index].right_child == -1){\n\t\t\t\t\t\thash[index].right_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].right_child;\n\t\t\t\t\t}\n\t\t\t\t}else{ //value < hash[index].hash_value\n\t\t\t\t\tif(hash[index].left_child == -1){\n\t\t\t\t\t\thash[index].left_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].left_child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull calc_ans(){\n\t\tull sum = 0;\n\n\t\tfor(int i = 0; i < num_of_node; i++){\n\t\t\tfor(int k = 1; k <= hash[i].num-1; k++){ //hash[i].numC2????¨????\n\t\t\t\t\tsum += k;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tHash* hash;\n\tint num_of_node;\n};\n\nstruct Node{\n\tvector<int> children;\n\tint parent;\n};\n\nNode* node;\nHashTree HT;\n\nvector<int> calc(int node_id){\n\n\tvector<int> Ret;\n\tRet.push_back(node[node_id].children.size()); //node[node_id]??????????????±???1?????????????????°??????????????°??????????????????\n\n\tfor(int i = 0; i < node[node_id].children.size();i++){\n\t\tvector<int> tmp = calc(node[node_id].children[i]); //????????????vector?????°???\n\t\tfor(int k = 0; k < tmp.size(); k++){\n\t\t\tif(k+1 >= Ret.size()){ //?????????????????????????????????????????\\????????´?????????????¶???? size()???A?????????vector????????????????????????0???A-1\n\t\t\t\tRet.push_back(tmp[k]);\n\t\t\t}else{\n\t\t\t\tRet[k+1] += tmp[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tull pre = 0,current = 0;\n\n\tfor(int i = 0; i < Ret.size(); i++){\n\t\tcurrent = Ret[i] + pre*MOD;\n\t\tpre = current;\n\t}\n\tHT.addHash(current);\n\n\treturn Ret;\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tnode = (Node*)malloc(sizeof(Node)*(N+1));\n\tHT.init(N);\n\n\tint parent,child;\n\tfor(int i = 0; i < N-1; i++){\n\t\tscanf(\"%d %d\",&parent,&child);\n\t\tnode[parent].children.push_back(child);\n\t\tnode[child].parent = parent;\n\t}\n\n\t//?????????????????????????????±?????¨????????°????¨???????????????£??????\n\tcalc(1);\n\n\tprintf(\"%lld\\n\",HT.calc_ans());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\ndouble dist(star s1,star s2){\n\tdouble ans=10000000000.0;\n\t\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\tif( is_intersected_ls(s1.se[i],s2.se[j])) {\n\t\t\t\n//\t\t\tcout<<s1.se[i].p1.x<<\" \"<<s1.se[i].p1.y<<endl;\n//\t\t\tcout<<s1.se[i].p2.x<<\" \"<<s1.se[i].p2.y<<endl;\n//\t\t\tcout<<s2.se[j].p1.x<<\" \"<<s2.se[j].p1.y<<endl;\n//\t\t\tcout<<s2.se[j].p2.x<<\" \"<<s2.se[j].p2.y<<endl;\n\t\treturn 0.0;\n\t\t}\n\t\tans=min(ans,segment_dis(s1.se[i],s2.se[j]));\n//\t\tcout<<\"   \"<<i<<\" \"<<j<<\" \"<<segment_dis(s1.se[i],s2.se[j])<<endl;\n\t}\n\treturn ans;\n}\nvector<int> G[100030];\nmap<int,int>ma;\nint a[100030];\n\n\nvoid saiki(int r,int mae){\n\tif(G[r].size()==0){\n\t\ta[r]=1;\n\t\treturn;\n\t}\n\t\n\tfor(auto v:G[r])if(v!=mae)saiki(v,r);\n\tint d=0;\n\tfor(auto v:G[r])if(v!=mae){\n\t\td+=a[v];\n\t\td%=inf;\n\t}\n\td=(d*10+1)%inf;\n\ta[r]=d;\n\treturn;\n}\n\n     signed main(){\nint n;\n     cin>>n;\n     \tfor(int i=0;i<n-1;i++){\n     \t\tint r,rr;\n     \t\tcin>>r>>rr;\n     \t\tG[r].pb(rr);\n     \t\tG[rr].pb(r);\n     \t}\n     \tsaiki(1,-1);\n     \tfor(int i=1;i<=n;i++){\n     \t\tma[a[i]]++;\n     \t//\tcout<<a[i]<<endl;\n     \t}\n     \tint ans=0;\n     \tfor(auto it=ma.begin();it!=ma.end();it++){\n     \t\tint y=(*it).second;\n     \t\tans+=y*(y-1)/2;\n     \t}\n     \t\n     \n     \t\n     \tcout<<ans<<endl;\n     \t\n\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define pb              push_back\n#define PII             pair <int,int>\n#define PLL             pair <ll,ll>\n#define mp              make_pair\n#define xx              first\n#define yy              second\n#define all(v)          v.begin(),v.end()\n\n#define lt              2*n\n#define rt              2*n+1\n#define clft            2*n,st,mid\n#define crgt            2*n+1,mid+1,ed\n\n#define CLR(a)          memset(a,0,sizeof(a))\n#define SET(a)          memset(a,-1,sizeof(a))\n\n#define eps             1e-9\n#define PI              acos(-1.0)\n#define MAX             100010\n#define INF             2000000000\n\n/******************************************************************************************/\n\n#define mod1            1000000007\n#define mod2            1000000123\n#define base            100001\n\nvector <ll> ed[MAX];\nll has1[MAX],has2[MAX];\nmap <PLL,ll> M;\n\nvoid dfs(ll u,ll p)\n{\n    ll i,v,h1 = 0,h2 = 0;\n    for(i=0;i<ed[u].size();i++){\n        v = ed[u][i];\n        if(v==p) continue;\n        dfs(v,u);\n        h1 += has1[v];\n        h2 += has2[v];\n        h1 %= mod1;\n        h2 %= mod2;\n    }\n    has1[u] = (h1*base + 1)%mod1;\n    has2[u] = (h2*base + 1)%mod2;\n    M[mp(h1,h2)]++;\n}\n\nint main()\n{\n    //ios_base::sync_with_stdio(false);\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\n    ll n,i,u,v;\n    cin >> n;\n    for(i=1;i<n;i++){\n        cin >> u >> v;\n        ed[u].pb(v);\n        ed[v].pb(u);\n    }\n    dfs(1,0);\n\n    ll ans = 0;\n    map <PLL,ll> :: iterator it = M.begin();\n    while(it!=M.end()){\n        ans += (it->second*(it->second-1))/2;\n        it++;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\nconst int N= 100005;\nint fa[N];\nunsigned long long value[N];\nint sons[N];\nint rsons[N];\nvector<int> now;\nbool vis[N];\nmap<unsigned long long,int> times;\n\n\nint main(int argc, char const *argv[])\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n-1;i++){\n        int start,end;\n        scanf(\"%d%d\",&start,&end);\n        fa[end] = start;\n        sons[start]++;\n        rsons[start]++;\n    }\n\n    for(int i=1;i<=n;i++){\n        if(sons[i] == 0){\n            now.push_back(i);\n        }\n    }\n\n    int now_size = now.size();\n    while(now_size>0){\n        int new_index = 0;\n        for(int i=0;i<now_size ;i++){\n            //printf(\"do %d\\n\",now[i] );\n            int f = fa[now[i]];\n            if(rsons[now[i]]==0 ){\n                value[now[i]]++;\n                times[value[now[i]]]++;\n                value[f] += value[now[i]]*13131;\n                rsons[f]--;\n                //printf(\"test %d\\n\",now[i] );\n                \n                if(rsons[f]==0 && !vis[f]){\n                    vis[f] = true;\n                    now[new_index++] =f;\n                }\n                \n                \n            }\n        }\n        now_size = new_index;\n    }\n    long long result = 0;\n    for(auto it = times.begin();it!= times.end();it++){\n        long long n = (*it).second;\n        result+=n*(n-1)/2;\n        //printf(\"id:%lld value:%d\\n\",(*it).first,(*it).second );\n    }\n    //printf(\"v:%lld\\n\",value[0] );\n    printf(\"%lld\\n\",result );\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing pll = pair<ll, ll>;\nmap<pll, int> dic;\nvector<vi> graph;\n\nll mod1 = 1e9+7LL;\nint base1 = 10007;\nll mod2 = 1e9+9LL;\nint base2 = 1009;\n\npll dfs(int v, int pv, int d){\n    ll ret1 = 0LL, ret2 = 0LL;\n    for(int nv : graph[v]){\n        if(nv == pv) continue;\n        pll nxt = dfs(nv, v, d + 1);\n        ret1 = ADD(ret1, nxt.first , mod1);\n        ret2 = ADD(ret2, nxt.second, mod2);\n    }\n    ret1 = MUL(ret1, base1, mod1);\n    ret2 = MUL(ret2, base2, mod2);\n    ret1 = ADD(ret1, 1LL, mod1);\n    ret2 = ADD(ret2, 1LL, mod2);\n\n    dic[pll(ret1, ret2)]++;\n    return pll(ret1, ret2);\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    graph = vector<vi>(n);\n\n    rep(i, n - 1){\n        int a, b; cin >> a >> b; a--, b--;\n        graph[a].emplace_back(b);\n        graph[b].emplace_back(a);\n    }\n    dfs(0, -1, 0);\n\n    ll res = 0LL;\n    for(auto& e : dic){\n        int num = e.second;\n        res += num * (num - 1) / 2;\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 111111\ntypedef unsigned long long ull;\null MOD=1000000007LL;\nvector<int> G[MAX_N];\nint n;\nmap<ull,ull> m;\null dfs(int p){\n  ull res=1LL;\n  for(int i=0;i<(int)G[p].size();i++)\n    res+=dfs(G[p][i])*MOD;\n  m[res]++;\n  return res;\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    int a,b;\n    cin>>a>>b;\n    G[a].push_back(b);\n  }\n  dfs(1);\n  ull ans=0;\n  for(auto i:m) ans+=i.second*(i.second-1)/2;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint b=1e9+7,n,a,c;//21387612863821\null ans;\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res*=dfs(v[x][i]);\n  res*=b;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define M 1777771\n#define N 100005\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair<ull,int> P;\ntypedef long long ll;\n\nconst ll mod = 1e9+7;\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n \nll nCr(ll n,ll r){\n  static vector<ll> k(1e6);\n  if(!k[0]){k[0]=1;for(int i=1;i<k.size();i++)k[i]=i*k[i-1]%mod;}\n  ll a=mod_pow(k[r],mod-2);\n  ll b=mod_pow(k[n-r],mod-2);\n  return ((k[n]*a)%mod)*b%mod;\n}\n\nll n,a,b,maxd[N];\nvector<int> G[N];\nmap<ull,int> S;\null A[N];\n\nint get_maxd(int x,int d){\n  int res=d;\n  rep(i,G[x].size())\n    res=max(res,get_maxd(G[x][i],d+1));\n  return maxd[x]=res;\n}\n\nP dfs(int x,int d){\n  ull res1=0;\n  int res2=d;\n  \n  rep(i,G[x].size()){\n    P r=dfs(G[x][i],d+1);\n    res1+=r.first*A[maxd[x]-r.second];\n    res2=max(res2,r.second);\n  }\n  res1+=A[res2-d];\n  \n  if(S.count(res1))S[res1]++;\n  else S[res1]=1;\n  \n  return P(res1,res2);\n}\n\nint main(){\n  cin>>n;\n  \n  rep(i,n-1){\n    cin>>a>>b;\n    G[a-1].push_back(b-1);\n  }\n  \n  A[0]=1;\n  for(int i=1;i<N;i++)A[i]=A[i-1]*M;\n  \n  get_maxd(0,0);\n  \n  dfs(0,0);\n\n  ll ans=0;\n  \n  map<ull,int>::iterator ite=S.begin();\n  \n  while(ite!=S.end()){\n    if((*ite).second>=2)\n      ans+=nCr((*ite).second,2);\n    ite++;\n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\nvector<int> G[N];\n\nusing pl = pair<ll,ll>;\n\nll base[2] = {101119, 101141};\nll mod[2] = {1000000007,1000000021};\npl h[N];\nvoid dfs(int v, int p){\n    pl ret(0,0);\n    for(int c:G[v])if(c!=p){\n        dfs(c, v);\n        (ret.fi += h[c].fi) %= mod[0];\n        (ret.se += h[c].se) %= mod[1];\n    }\n\n    (ret.fi *= base[0]) %= mod[0];\n    (ret.se *= base[1]) %= mod[1];\n\n    (ret.fi += 1) %= mod[0];\n    (ret.se += 1) %= mod[1];\n\n    h[v] = ret;\n}\n\nint main(){\n    int n;\n    cin >>n;\n    rep(i,n-1){\n        int a,b;\n        cin >>a >>b;\n        --a; --b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n\n    dfs(0,-1);\n\n    map<pl,ll> ct;\n    rep(i,n) ++ct[h[i]];\n\n    ll ans = 0;\n    for(const auto &p:ct){\n        ll x = p.se;\n        ans += x*(x-1)/2;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nstruct node\n{\n\tint num;\n\tint parent;\n\tint deep;\n}tree[100010];\n\nint main()\n{\n\tint n,max=1,sum=0;\n\tscanf(\"%d\",&n);\n\ttree[0].num = 0;\n\ttree[0].parent = 0;\n\ttree[0].deep = 0;\n\ttree[1].num = 1;\n\ttree[1].parent = 0;\n\ttree[1].deep = 1;\n\tfor (int i = 2; i <=n; i++)\n\t{\n\t\tscanf(\"%d%d\", &tree[i].parent, &tree[i].num);\n\t\tif (!tree[tree[i].parent].deep)\n\t\t\ttree[tree[i].parent].deep = 1;\n\t\ttree[i].deep = tree[tree[i].parent].deep + 1;\n\t\tif (tree[i].deep >= max)\n\t\t\tmax = tree[i].deep;\n\t}\n\tfor (int i = 2; i <= max; i++)\n\t{\n\t\tint count = 0;\n\t\tfor (int j = 2; j <=n; j++)\n\t\t{\n\t\t\tif (tree[j].deep == i)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\t//printf(\"node=%d parent=%d deep=%d\\n\",j, tree[j].parent,i);\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",count);\n\t\twhile (count)\n\t\t{\n\t\t\tcount--;\n\t\t\tsum += count;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pie acos(-1)\n#define si(a) scanf(\"%d\",&a)\n#define sii(a,b) scanf(\"%d %d\",&a,&b)\n#define siii(a,b,c) scanf(\"%d %d %d\",&a,&b,&c)\n#define sl(a) scanf(\"%lld\",&a)\n#define sll(a,b) scanf(\"%lld %lld\",&a,&b)\n#define slll(a,b,c) scanf(\"%lld %lld %lld\",&a,&b,&c)\n#define ss(st) scanf(\"%s\",st)\n#define sch(ch) scanf(\"%c\",&ch)\n#define pi(a) printf(\"%d\",a)\n#define pii(a,b) printf(\"%d %d\",a,b)\n#define piii(a,b,c) printf(\"%d %d %d\",a,b,c)\n#define pl(a) printf(\"%lld\",a)\n#define pll(a,b) printf(\"%lld %lld\",a,b)\n#define plll(a,b,c) printf(\"%lld %lld %lld\",a,b,c)\n#define ps(st) printf(\"%s\",st)\n#define pch(c) printf(\"%c\",c)\n#define debug(n) printf(\"toha %d\\n\",n)\n#define debug1(n) printf(\"saran %d\\n\",n)\n#define for0(i,n) for(i=0;i<n;i++)\n#define for1(i,n) for(i=1;i<=n;i++)\n#define forab(i,a,b) for(i=a;i<=b;i++)\n#define NL puts(\"\")\n#define SP printf(\" \")\n#define LL long long int\n#define ULL unsigned long long int\n#define N 1000007\n#define MOD 100000009\n#define pub(x) push_back(x)\n#define pob(x) pop_back(x)\n#define mem(ara,value) memset(ara,value,sizeof(ara))\n#define INF INT_MAX\nusing namespace std;\nLL n,color[100010],dpt[100010],freq[100010];\nvector <LL> adj[100010];\nvoid input(){\n    LL i,j,k;\n    sl(n);\n    for0(i,n+2){\n        adj[i].clear();\n    }\n    for0(i,n-1){\n        LL u,v;\n        sll(u,v);\n        adj[u-1].pub(v-1);adj[v-1].pub(u-1);\n    }\n}\nvoid dfs(LL source,LL h){\n    color[source]=1;\n    LL i,j,k;\n    for0(i,adj[source].size()){\n        LL u=adj[source][i];\n        if(color[u]==0){\n            dpt[u]=h+1;\n            dfs(u,h+1);\n        }\n    }\n}\nvoid solve(){\n    LL i,j,k,ans=0;\n    mem(color,0);dpt[0]=0;\n    for0(i,n){\n        if(color[i]==0){\n            dfs(i,0);\n        }\n    }\n    mem(freq,0);\n    for0(i,n){\n        freq[dpt[i]]++;\n    }\n    for0(i,n+1){\n        if(freq[i]>1){\n            ans+=((freq[i]*(freq[i]-1))/2);\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main(){\n    LL i,j,k;\n    input();\n    solve();\n//    main();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Team Name : JU_MSB\n// Members   : Shaheen,Biru,Mahbub\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ULL         unsigned long long\n#define LL          long long int\n#define D           double\n#define X           first\n#define Y           second\n#define sz          size()\n#define PB          push_back\n#define MP          make_pair\n#define CHR         getchar()\n#define NL          printf(\"\\n\")\n#define MEM(a,val)  memset(a,val,sizeof(a))\n#define Max(a,b)    ((a>b)?a:b)\n#define Min(a,b)    ((a<b)?a:b)\n#define S1(a)       scanf(\"%d\",&a)\n#define S2(a,b)     scanf(\"%d%d\",&a,&b)\n#define S3(a,b,c)   scanf(\"%d%d%d\",&a,&b,&c)\n#define SL1(a)      scanf(\"%lld\",&a)\n#define SL2(a,b)    scanf(\"%lld%lld\",&a,&b)\n#define SL3(a,b,c)  scanf(\"%lld%lld%lld\",&a,&b,&c)\n#define all(a)      a.begin(),a.end()\n#define F(i,a,b)    for(int i=a;i<b; i++)\n#define R(i,a,b)    for(int i=a-1;i>=b; i--)\n#define cp          cerr << \"***** here here here here *****\" << endl;\n\n#define trace1(x)                cerr << #x << \": \" << x << endl;\n#define trace2(x, y)             cerr << #x << \": \" << x << \" | \" << #y << \": \" << y << endl;\n#define trace3(x, y, z)          cerr << #x << \": \" << x << \" | \" << #y << \": \" << y << \" | \" << #z << \": \" << z << endl;\n#define trace4(a, b, c, d)       cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" << #d << \": \" << d << endl;\n\n#define I2(a,b)     scanf(\"%d%d\",&a,&b)\n#define I3(a,b,c)   scanf(\"%d%d%d\",&a,&b,&c)\n#define L(a)        scanf(\"%lld\",&a)\n#define L2(a,b)     scanf(\"%lld%lld\",&a,&b)\n#define L3(a,b,c)   scanf(\"%lld%lld%lld\",&a,&b,&c)\n#define PL(a)       printf(\"%lld\\n\",a)\n#define PT(t)       printf(\"Case %d: \",t)\n#define SC          scanf\n#define PC          printf\n#define SZ(a)       ((int)a.size())-1\n#define fr(i,a,b)   for(int i=a;i<=b; i++)\n#define lol         printf(\"BUG\\n\")\n#define mk          make_pair\n// shaheen\n#define I(X)                        scanf(\"%d\",     &(X))\n#define II(X, Y)                    scanf(\"%d%d\",   &(X), &(Y))\n#define III(X, Y, Z)                scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define IL(X)                       scanf(\"%lld\", &X)\n#define IIL(X,Y )                   scanf(\"%lld%lld\", &X,&Y)\n#define IIIL(X,Y,Z)                 scanf(\"%lld%lld%lld\", &X,&Y,&Z)\n#define DI(X)         int X;        I(X);\n#define DII(X, Y)     int X, Y;     II(X,Y)\n#define DIII(X, Y, Z) int X, Y, Z;  III(X,Y,Z);\n#define DIL(X)        LL X;         IL(X)\n#define DIIL(X,Y)     LL X,Y;       IIL(X,Y)\n#define DIIIL(X,Y,Z)  LL X,Y,Z;     IIIL(X,Y,Z)\n#define PI(x)                       printf(\"%d\\n\",      x)\n#define PII(x,y)                    printf(\"%d %d\\n\",   x,y)\n#define PIII(x,y,z)                 printf(\"%d %d %d\\n\",x,y,z)\n#define PIL(x)                      printf(\"%lld\\n\",          x)\n#define PIIL(x,y)                   printf(\"%lld %lld\\n\",     x,y)\n#define PIIIL(x,y,z)                printf(\"%lld %lld %lld\\n\",x,y,z)\n\n#define rep(i,a,b)                  for(int i=a;i<=b;i++)\n#define rev(i,a,b)                  for(int i=a;i>=b;i--)\n#define repv(i,a)                   for(int i=0;i<(int)a.size();i++)\n#define revv(i,a)                   for(int i=((int)a.size())-1;i>=0;i--)\n\n#define pline                       cerr << \"_________________________\" << endl;\n\n#define MD1 1000000007ULL\n#define MD2 1000000009ULL\n#define MD3 1000000021ULL\n#define BS1 50ULL\n#define BS2 50ULL\n#define BS3 10000103ULL\n#define PUL pair<ULL,ULL>\n#define PLL pair<LL,LL>\n#define pii pair<int,int>\n///         0123456789\n#define MX  300007\n#define MOD 1000000007\n#define INF 1000000000\n#define EPS 1e-9\n/// ==========================================////\n\n\nmap<PUL,LL> dp;\nLL ans;\nvector<int> A[MX];\nPUL Dekhi(int u,int p) {\n\n    PUL tp=MP(1,1);\n    int f=0;\n    F(i,0,A[u].sz) {\n        int v=A[u][i];\n        if(v==p) continue;\n        PUL k=Dekhi(v,u);\n        f=1;\n        tp.X+=k.X*BS1;\n        tp.Y+=k.Y*BS2;\n    }\n    if(!f) tp=MP(1,1);\n    if(dp.find(tp)!=dp.end()) {\n        ans+=dp[tp];\n    }\n    dp[tp]++;\n    return tp;\n}\n\nint main()\n{\n\n    int n;\n    S1(n);\n    F(i,1,n) {\n        int a,b;\n        S2(a,b);\n        A[a].PB(b);\n        A[b].PB(a);\n    }\n\n    Dekhi(1,0);\n    printf(\"%lld\\n\",ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ULL;\n\nconst ULL HS=19260817;\nconst int maxn=1e5;\n\nint ans=0;\nint du[maxn+10];\nvector<int>G[maxn+10];\nunordered_map<ULL,int>S;\n\nULL gao(int x){\n\tULL t=0;\n\tfor(int i=0;i<du[x];i++)t+=gao(G[x][i]);\n\tt=t*HS+1;\n\tans+=S[t]++;\n\treturn t;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tG[a].push_back(b);\n\t\tdu[a]++;\n\t}\n\tgao(1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mod1    1000000031\n#define mod2    1000000123\n#define mod3    1000000007\n#define MAX     1000000\n#define base    100001\n#define ll      long long\n\nusing namespace std;\n\n\nll bm(ll a , ll p,ll m)\n{\n    if(p==0) return 1;\n    ll x = bm(a,p/2,m);\n    x *= x;\n    x %= m;\n    if(p&1) return (x*a)%m;\n    return x;\n}\n\nstruct haash\n{\n    long long value1;\n    long long value2;\n    long long value3;\n    long long depth;\n    haash()\n    {\n        value1=value2=value3=depth=0LL;\n    }\n\n    bool operator==(const haash a) const\n    {\n        return (value2==a.value2 && depth==a.depth && value1 == a.value1 && value3==a.value3);\n    }\n\n    haash operator+(haash a)\n    {\n        haash c;\n        c.depth = max(depth,a.depth);\n        if(depth>a.depth)\n        {\n            a.value1 = a.value1*bm(base,abs(depth-a.depth),mod1);\n            a.value2 = a.value2*bm(base,abs(depth-a.depth),mod2);\n            a.value3 = a.value3*bm(base,abs(depth-a.depth),mod3);\n            a.value1%=mod1;\n            a.value2%=mod2;\n            a.value3%=mod3;\n        }\n        else\n        {\n            value1 = value1*bm(base,abs(depth-a.depth),mod1);\n            value2 = value2*bm(base,abs(depth-a.depth),mod2);\n            value3 = value3*bm(base,abs(depth-a.depth),mod3);\n            value1%=mod1;\n            value2%=mod2;\n            value3%=mod3;\n\n        }\n        c.value1 = (a.value1+value1)%mod1;\n        c.value2 = (a.value2+value2)%mod2;\n        c.value3 = (a.value3+value3)%mod3;\n        return c;\n    }\n};\n\n\nvector  < int > G[MAX];\nhaash h[MAX];\nmap < pair < pair  < ll , ll >  , pair< ll , ll >   >  , ll  > m;\nbool vis[MAX];\nint n;\nvoid dfs(int n)\n{\n    haash a ,b ;\n    a.value1=a.value2=a.value3=b.value3=a.depth=b.depth=b.value1=b.value2=0LL;\n    vis[n]=1;\n    ll maxh=1LL;\n    for(int i=0; i<G[n].size(); i++)\n    {\n        int x= G[n][i];\n        if(!vis[x] )\n        {\n            dfs(x);\n            maxh = max(maxh,h[x].depth+1LL);\n            a = a + h[x];\n\n        }\n    }\n    b.depth = maxh;\n    b.value1=bm(base,maxh-1LL,mod1);\n    b.value2=bm(base,maxh-1LL,mod2);\n    b.value3=bm(base,maxh-1LL,mod3);\n    b = a + b ;\n\n    h[n]=b;\n    m[make_pair(make_pair(b.value1,b.value2),make_pair(b.value3,b.depth))]++;\n}\nint main()\n{\n\n    scanf(\"%d\",&n);\n\n    for(int i=0;i<=n;i++) vis[i]=0;\n\n    for(int i=1; i<n; i++)\n    {\n        int  u , v;\n        scanf(\"%d %d\",&u,&v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1);\n\n    long long ans=0;\n    map < pair < pair  < ll , ll >  , pair< ll , ll >   >  , ll  > ::iterator it = m.begin();\n    while(it!=m.end())\n    {\n        long long x = (it)->second;\n        ans += (x*x-x)/2LL;\n        it++;\n    }\n    printf(\"%lld\\n\",ans);\n\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define ull unsigned long long\n#define pb push_back\n\nmap<ull, ull>ans;\nvector<int>ma[100005];\n\null dfs(int pos, int fa) {\n    ull x = 1ull;\n    int sz = ma[pos].size();\n    for(int i = 0; i < sz; i ++){\n        int to = ma[pos][i];\n        if(to == fa) continue;\n        x += (19 * dfs(to, pos));\n    }\n    ans[x] ++;\n    return x;\n}\n\nint main () {\n    int n, a, b;\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n - 1; i ++) {\n        scanf(\"%d%d\", &a, &b);\n        ma[a].pb(b);\n        ma[b].pb(a);\n    }\n    ans.clear();\n    map<ull, ull> :: iterator it;\n    dfs(1, -1);\n    ull res = 0ull;\n    for(it = ans.begin(); it != ans.end(); it ++) {\n        ull tm = it -> second;\n        res += tm * (tm - 1) / 2;\n    }\n    printf(\"%llu\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull base = 2013265921;\nint n, a, b; vector<vector<int> > G; map<ull, int> cnt;\null solve(int pos, int pre) {\n\tull ret = 1;\n\tfor (int i : G[pos]) {\n\t\tif (i == pre) continue;\n\t\tret += solve(i, pos) * base;\n\t}\n\tcnt[ret]++;\n\treturn ret;\n}\nint main() {\n\tcin >> n; G.resize(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> a >> b; a--, b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tsolve(0, -1);\n\tull ret = 0;\n\tfor (pair<ull, int> i : cnt) ret += 1ULL * i.second * (i.second - 1) / 2;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint b=1e9+7,n,a,c;\null ans;\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res+=dfs(v[x][i]);\n  res*=b;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint b=1e9+7,n,a,c,ans;//21387612863821\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res+=dfs(v[x][i]);\n  res*=b;\n  res%=21387612863821;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdtr1c++.h>\n\n#define MAX 100100\n#define clr(ar) memset(ar, 0, sizeof(ar))\n#define read() freopen(\"lol.txt\", \"r\", stdin)\n#define dbg(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\nconst unsigned long long base = 666666667;\n\nint n, depth[MAX];\nvector <int> adj[MAX];\nunsigned long long dp[MAX], power[MAX];\ntr1::unordered_map <unsigned long long, int> mp;\n\nvoid dfs(int i, int p){\n    depth[i] = 1;\n    int j, k, d, x, len = adj[i].size();\n\n    for (j = 0; j < len; j++){\n        x = adj[i][j];\n        if (x != p){\n            dfs(x, i);\n            depth[i] = max(depth[i], depth[x] + 1);\n        }\n    }\n\n    d = depth[i] - 1;\n    unsigned long long h = 0;\n    for (j = 0; j < len; j++){\n        x = adj[i][j];\n        if (x != p){\n            unsigned long long r = dp[x] * power[d - depth[x]];\n            h += r;\n        }\n    }\n\n    h += power[depth[i]];\n    dp[i] = h;\n    mp[h]++;\n}\n\nint main(){\n    int i, j, k, l, a, b;\n\n    power[0] = 1;\n    for (i = 1; i < MAX; i++) power[i] = power[i - 1] * base;\n\n    while (scanf(\"%d\", &n) != EOF){\n        mp.clear();\n        for (i = 0; i < MAX; i++) adj[i].clear();\n\n        for (i = 1; i < n; i++){\n            scanf(\"%d %d\", &a, &b);\n            adj[a].push_back(b);\n            adj[b].push_back(a);\n        }\n\n        dfs(1, 1);\n        long long res = 0;\n        for (auto it: mp){\n            long long x = it.second;\n            res += ((x * (x - 1)) >> 1);\n        }\n\n        printf(\"%lld\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e11+7;\nconst ll K = 633333;\nvector<int> e[N];\nvector<ll> hs;\nint d[N], f[N];\n\n\nvoid pre_dfs(int u, int dep){\n  if(u==0) return;\n  d[u] = max(d[u], dep);\n  pre_dfs(f[u], dep+1);\n}\n\nll dfs(int u){\n  ll ret = 17;\n  for(auto v: e[u]){\n    ret = (ret+K*dfs(v))%M;\n  }\n  hs.push_back((d[u])*ret);\n  return ret;\n}\n\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    d[u]++;\n    f[v] = u;\n    e[u].push_back(v);\n  }\n  for(int i = 1; i <= n; i++) if(!d[i]) pre_dfs(i, 0);\n  dfs(1);\n  ll ans = 0;\n  sort(hs.begin(), hs.end());\n  for(int i = 0; i < hs.size(); i++){\n    int s = i;\n    while(i < hs.size() && hs[i+1] == hs[i]) i++;\n    ans += (ll)(i-s+1)*(i-s)/2;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n \ntypedef unsigned long long ull;\nconst ull a=8931919,p=1000000007,q=1000000009;\n \nint N;\nvint G[100000];\n \nint sz[100000];\nmap<pint,int>cnt[111111];\npint dfs(int v,int par){\n    ull hp=1,hq=1;\n    sz[v]=1;\n    for(auto u:G[v]){\n        if(u==par)continue;\n        ull gp,gq;\n        tie(gp,gq)=dfs(u,v);\n        sz[v]+=sz[u];\n        hp=(hp+gp*a)%p;\n        hq=(hq+gq*a)%q;\n    }\n    cnt[sz[v]][pint(hp,hq)]++;\n    return pint(hp,hq);\n}\nsigned main(){\n    cin>>N;\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n    dfs(0,-1);\n \n    int ans=0;\n    reps(i,1,N+1){\n        each(it,cnt[i]){\n            ans+=it->se*(it->se-1)/2;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+5;\nconst int mod=1e9+7;\nmap<ll,int>mp;\nmap<ll,int>::iterator it;\nvector<int>g[maxn];\nint a[maxn];\nint dfs1(int x){\n\tint r=g[x].size();\n\tint t=1;\n\tfor(int i=0;i<r;i++){\n\t\tt+=dfs1(g[x][i]);\n\t}\n\ta[x]=t;\n\treturn t;\n}\nll dfs(int x){\n\tint r=g[x].size();\n\tll t=1;\n\tfor(int i=0;i<r;i++){\n\t\tt+=dfs(g[x][i])*2;\n\t\twhile(t>=mod) t-=mod;\n\t}\n\tmp[t+a[x]*10000000000ll]++;\n\treturn t;\n}\nint main(){\n//\tint size = 256 << 20; // 256MB\n//\tchar *p = (char*)malloc(size) + size;\n//\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n\tint n;\n\tscanf(\"%d\",&n);\n\tint u,v;\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(1);\n\tdfs1(1);\n\tll ans=0;\n\tfor(it=mp.begin();it!=mp.end();it++){\n\t\tint t=(*it).second;\n\t\tans+=1ll*t*(t-1)/2;\n\t}\n\tprintf(\"%I64d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nconst LL M1 = 1000000007;\nconst LL M2 = 1000000009;\nLL R1, R2;\nmap<PLL,LL> memo;\nPLL thash(int u, int p, VVI& G){\n  PLL res(1, 1);\n\n  for(int v: G[u]){\n    if(v == p) continue;\n    PLL x = thash(v, u, G);\n\t(res.FF += R1 * x.FF % M1) %= M1;\n\t(res.SS += R2 * x.SS % M2) %= M2;\n  }\n\n  memo[res]++;\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  mt19937 mt;\n  R1 = mt() % M1, R2 = mt() % M2;\n\n  int N;\n  cin >> N;\n  VVI G(N);\n  REP(i,N-1){\n\tint u, v;\n\tcin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n  }\n  thash(0, -1, G);\n\n  LL ans = 0;\n  for(auto&& p: memo)\n\tans += p.SS * (p.SS - 1) / 2;\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nusing ull = unsigned long long;\nconstexpr int MAX = 100000;\nconstexpr ull B = 100000007;\n\nvector<int> G[MAX];\nmap<ull, ull> mp;\n\null dfs(int v)\n{\n    ull res = 1;\n    for (auto to : G[v]) {\n        res += dfs(to) * B;\n    }\n    mp[res]++;\n    return res;\n}\n\null solve()\n{\n    dfs(0);\n    ull res = 0;\n    for (auto x : mp) {\n        if (x.second >= 2) {\n            res += x.second * (x.second - 1) / 2;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        G[a].emplace_back(b);\n    }\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1000010,p = 100001,MOD = 1e9+7;\nvector<ll> G[N];\nll Hash[N];\nmap<ll,ll> m;\nmap<ll,ll>::iterator it;\nvoid dfs(ll u)\n{\n    Hash[u] = 1;\n    for(int i = 0;i < G[u].size();i++)\n    {\n        ll v = G[u][i];\n        dfs(v);\n        Hash[u] = (Hash[u]+Hash[v]*p)%MOD;//哈希方程，p取一个6到8位的素数，mod一般取1e9+7 \n    }\n    m[Hash[u]]++;\n}\nint main()\n{/*\nint size = 256 << 20; // 256MB\nchar *p = (char*)malloc(size) + size;\n__asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));*/\n\n    int n,u,v;\n    cin >> n;\n    for(int i = 1;i <= n-1;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v);\n    }\n    dfs(1);\n    ll ans = 0; \n    for(it = m.begin();it != m.end();it++)\n        ans += it->second*(it->second-1)/2;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n/*\nhttps://blog.csdn.net/huatian5/article/details/70305845\n*/ \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1000005,p = 9901,MOD = 1e9+7;\nvector<ll> G[N];\nll Hash[N];\nmap<ll,ll> m;\nmap<ll,ll>::iterator it;\nvoid dfs(ll u)\n{\n    Hash[u] = 1;\n    for(int i = 0;i < G[u].size();i++)\n    {\n        ll v = G[u][i];\n        dfs(v);\n        Hash[u] = (Hash[u]+Hash[v]*p)%MOD;\n    }\n    m[Hash[u]]++;\n}\nint main()\n{\n    int n,u,v;\n    cin >> n;\n    for(int i = 1;i <= n-1;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v);\n    }\n    dfs(1);\n    ll ans = 0;\n    for(it = m.begin();it != m.end();it++)\n        ans += it->second*(it->second-1)/2;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <iostream>\n#include <cstdlib>\nusing namespace std ;\n\ntypedef unsigned long long ull ;\nconst int maxn =  1e5 + 10 ;\nconst ull base = 237 ;\n\nstruct Edge\n{\n    int to , next ;\n    Edge(){}\n    Edge( int t , int n ) : to( t ) , next( n ) {}\n}e[maxn * 2] ;\n\nint head[maxn] , len , n ;\n\nvoid init()\n{\n    memset( head , -1 , sizeof( head ) ) ;\n    len = 0 ;\n}\n\nvoid add( int u , int v )\n{\n    e[len] = Edge( v , head[u] ) ;\n    head[u] = len++ ;\n}\n\null _hash[maxn] ;\n\nvoid dfs( int u , int fa , int deep )\n{\n    ull cur = 0 ;\n    for( int i = head[u] ; ~i ; i = e[i].next )\n    {\n        int to = e[i].to ;\n        if( to == fa ) continue ;\n        dfs( to , u , deep + 1 ) ;\n        cur += _hash[to] ;\n    }\n\n    _hash[u] = cur * base + 1 ;\n}\n\n\nint main( )\n{\n\n\n\n    while( ~scanf( \"%d\" , &n ) )\n    {\n        init() ;\n\n        for( int i = 0 ; i < n - 1 ; ++i )\n        {\n            int u , v ;\n            scanf( \"%d %d\" , &u , &v ) ;\n            add( u , v ) ;\n            add( v , u ) ;\n        }\n        long long ans = 0 ;\n        dfs( 1 , 1 , 0 ) ;\n\n        sort( _hash + 1 , _hash + n + 1 ) ;\n        ull last = _hash[1] ;\n        int num = 0 ;\n        for( int i = 1 ; i <= n ; ++i )\n        {\n            if( _hash[i] == last )\n                ++num ;\n            else\n            {\n                ans += ( long long ) num * ( num - 1 ) / 2 ;\n                num = 1 ;\n                last = _hash[i] ;\n            }\n        }\n\n        printf( \"%I64d\\n\" , ans ) ;\n    }\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" \" << x << endl\nusing namespace std;\n \nconst int BASE = 100003;\nconst int MOD = 30743651146573LL;\n \nint depth[100000];\n \nvector<vector<int>> child;\nint parent[100000];\n \nvoid dfs(int v) {\n  for(int u : child[v]) {\n    depth[u] = depth[v] + 1;\n    dfs(u);\n  }\n}\n \nint hash_value[100000];\n \nsigned main() {\n  memset(depth, -1, sizeof(depth));\n  int N; cin >> N;\n  child.resize(N);\n  parent[0] = -1;\n  REP(i,N-1) {\n    int a, b; cin >> a >> b;\n    --a, --b;\n    parent[b] = a;\n    child[a].push_back(b);\n  }\n  depth[0] = 0;\n  dfs(0);\n  vector<pair<int, int>> ord;\n  REP(i,N) {\n    ord.emplace_back(-depth[i], i);\n  }\n  sort(ord.begin(), ord.end());\n  REP(i,N) {\n    int v = ord[i].second;\n    int h = 1;\n    for(int u : child[v]) {\n      h += hash_value[u] * BASE;\n      h %= MOD;\n    }\n    hash_value[v] = h;\n  }\n  map<int, int> hash_count;\n  REP(i,N) {\n    hash_count[hash_value[i]]++;\n  }\n  int ans = 0;\n  for(auto kv : hash_count) {\n    ans += kv.second * (kv.second - 1) / 2;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint b=67280421310721,n,a,c;//21387612863821\null ans;\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res+=dfs(v[x][i]);\n  res*=b;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl;\n#define CNO cout<<\"No\"<<endl;\n\ntypedef long long LL;\ntypedef long double LD;\n\nmap<LL,LL> mp;\nvector<vector<int>> e;\n\nLL dfs(int x, int p){\n  LL hs=0;\n  for(auto nx:e[x]){\n    if(nx==p) continue;\n    hs=(hs+dfs(nx, x))%MOD;\n  }\n  hs=(1007*hs+1)%MOD;\n  mp[hs]++;\n  return hs;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  e=vector<vector<int>>(n);\n  int a,b;\n  rep(i,n-1){\n    cin >> a >> b;\n    e[a-1].push_back(b-1);\n    e[b-1].push_back(a-1);\n  }\n  dfs(0, -1);\n  LL ans=0;\n  for(auto x:mp){\n    ans += x.second*(x.second-1)/2;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nusing ull = unsigned long long;\n\n#define MAX_N 100000\n\nint N;\nvector<int> graph[MAX_N];\n\null base = 100000007; //base for rolling hash\nmap<ull, int> mp;\n\null dfs(int v, int p) {\n  ull res = 1;\n  for(int u : graph[v]) {\n    if(u == p) continue;\n    res += dfs(u, v)*base;\n  }\n  mp[res]++;\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N;\n  rep(i, N-1) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n  dfs(0, -1);\n  int ans = 0;\n  for(auto p : mp) {\n    ans += p.second*(p.second-1) / 2;\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n\tint n;cin>>n;int p,q;\n\tif(n==1){cout<<\")(\"<<endl;return 0;}\n\tfor(int i=1;i<=n;i++){\n\t\tint F=i*(i+1)/2;\n\t\tif(F>=n)break;\n\t\tif(F<n){\n\t\t\tp=i+1;q=n-(i*(i+1)/2);\n\t\t}\n\t}\n\tint cnt=0,cnt2=0;\n\tfor(int i=1;i<=q;i++){cout<<')';cnt++;cnt2++;}\n\tif(q!=p){cout<<\"()\";cnt++;cnt2+=2;}\n\twhile(cnt<p){cout<<')';cnt++;cnt2++;}\n\twhile(cnt2<p*2){cout<<'(';cnt2++;}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\nusing namespace std;\ntypedef long long LL;\nconst LL maxn=1e6+10,p=9901,mod=1e9+7;\nvector<LL>G[maxn];\nLL hash_v[maxn];\nmap<LL,LL>mp;\nmap<LL,LL>::iterator it;\n\nvoid dfs(LL u)\n{\n    hash_v[u]=1;\n    for(LL i=0; i<G[u].size(); i++)\n    {\n        LL v=G[u][i];\n        dfs(v);\n        hash_v[u]=(hash_v[u]+hash_v[v]*p)%mod;\n    }\n    mp[hash_v[u]]++;\n}\nint main()\n{\n   ///freopen(\"in.txt\",\"r\",stdin);\n    LL n;\n    LL u,v;\n    while(scanf(\"%lld\",&n)!=-1)\n    {\n        for(LL i=0; i<=n; i++)\n        G[i].clear();\n        mp.clear();\n        for(LL i=1; i<n; i++)\n        {\n            scanf(\"%lld%lld\",&u,&v);\n            G[u].push_back(v);\n        }\n        dfs(1);\n        LL ans=0;\n        for(it=mp.begin(); it!=mp.end(); it++)\n            ans+=it->second*(it->second-1)/2;\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by ??? on 2017/4/20.\n//\n\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define maxn 1000010\n#define p 9901\n#define mod 1000000007\n\nusing namespace std;\n\nvector<int>G[maxn];\nlong long hashh[maxn];\nmap<long long, long long>mp;\n\nvoid dfs(int u)\n{\n    hashh[u] = 1;\n    for(int i = 0; i < G[u].size(); i++)\n    {\n        int v = G[u][i];\n        dfs(v);\n        hashh[u] = (hashh[u] + hashh[v] * p) % mod;\n    }\n    mp[hashh[u]]++;\n}\n\nint main (void)\n{\n    int n;\n    int u, v;\n    while(scanf(\"%d\", &n) != EOF)\n    {\n        for(int i = 0; i <= n; i++)\n            G[i].clear();\n        mp.clear();\n\n        for(int i = 0; i < n - 1; i++)\n        {\n            scanf(\"%d %d\", &u, &v);\n            G[u].push_back(v);\n        }\n        dfs(1);\n        long long ans = 0;\n        for(map<long long, long long>:: iterator it = mp.begin(); it != mp.end(); it++)\n            ans += it->second * (it->second - 1) / 2;\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef unsigned long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint n;\nvector<vi> tree;\nll hs[111111];\nll r = 456789065ll;\n\nll get_hash(int v)\n{\n\tll tmp = 0;\n\tfor (auto u : tree[v])\n\t{\n\t\ttmp += get_hash(u) * r;\n\t}\n\ttmp += tree[v].size() * r;\n\treturn hs[v] = tmp;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> n;\n\ttree.resize(n);\n\tREP(i, n - 1)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\ttree[a].push_back(b);\n\t}\n\tget_hash(0);\n\tmap<ll, int> mp;\n\tREP(i, n)\n\t{\n\t\tmp[hs[i]]++;\n\t}\n\tll ans = 0;\n\tfor (auto i : mp)\n\t{\n\t\tans += i.second * (i.second - 1) / 2;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long\n#define ll long long\nll ans;\nmap<ull,ll>m;\nconst int maxn=200005;\nvector<int>g[maxn];\null dp[maxn];\nconst ull b=1000000007;\nvoid dfs(int u,int p)\n{\n\tdp[u]=1;\n\tfor(int i=0;i<g[u].size();i++)\n\t{\n\t\tint v=g[u][i];\n\t\tif(v==p)\n\t\tcontinue;\n\t\tdfs(v,u);\n\t\tdp[u]+=dp[v]*b;\n\t}\n\tans+=m[dp[u]];\n\tm[dp[u]]++;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(1,-1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ULL;\n\nconst ULL HS=19260817;\nconst int maxn=1e5;\n\nULL ans=0;\nint du[maxn+10];\nvector<int>G[maxn+10];\nunordered_map<ULL,ULL>S;\n\nULL gao(int x){\n\tULL t=0;\n\tfor(int i=0;i<du[x];i++)t+=gao(G[x][i]);\n\tt=t*HS+1;\n\tans+=S[t]++;\n\treturn t;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tG[a].push_back(b);\n\t\tdu[a]++;\n\t}\n\tgao(1);\n\t//printf(\"%llu\\n\",ans);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n//#define M 1777771\n#define M 1000000007\n#define N 100005\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair<ull,int> P;\ntypedef long long ll;\n\nconst ll mod = 1e9+7;\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n \nll nCr(ll n,ll r){\n  static vector<ll> k(1e6);\n  if(!k[0]){k[0]=1;for(int i=1;i<k.size();i++)k[i]=i*k[i-1]%mod;}\n  ll a=mod_pow(k[r],mod-2);\n  ll b=mod_pow(k[n-r],mod-2);\n  return ((k[n]*a)%mod)*b%mod;\n}\n\nll n,a,b,maxd[N];\nvector<int> G[N];\nmap<ull,int> S;\null A[N];\n\nint get_maxd(int x,int d){\n  int res=d;\n  rep(i,G[x].size())\n    res=max(res,get_maxd(G[x][i],d+1));\n  return maxd[x]=res;\n}\n\nP dfs(int x,int d){\n  ull res1=0;\n  int res2=d;\n  \n  rep(i,G[x].size()){\n    P r=dfs(G[x][i],d+1);\n    res1+=r.first*A[maxd[x]-r.second];\n    res2=max(res2,r.second);\n  }\n  res1+=A[res2-d];\n  \n  if(S.count(res1))S[res1]++;\n  else S[res1]=1;\n  \n  return P(res1,res2);\n}\n\nint main(){\n  cin>>n;\n  \n  rep(i,n-1){\n    cin>>a>>b;\n    G[a-1].push_back(b-1);\n  }\n  \n  A[0]=1;\n  for(int i=1;i<N;i++)A[i]=A[i-1]*M;\n  \n  get_maxd(0,0);\n  \n  dfs(0,0);\n\n  ll ans=0;\n  \n  map<ull,int>::iterator ite=S.begin();\n  \n  while(ite!=S.end()){\n    if((*ite).second>=2)\n      ans+=nCr((*ite).second,2);\n    ite++;\n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\nstd::map<int,std::vector<int>>v;\nstd::map<int,int>m;\nlong long r;\nint d(int i,int p){\n\tint h=1;\n\tfor(int c:v[i])if(c-p)h=(h+997LL*d(c,i))%1000000007;\n\tr+=m[h]++;\n\treturn h;\n}\nint main(){\n\tint N,a,b;\n\tfor(scanf(\"%d\",&N);--N;)scanf(\"%d%d\",&a,&b),v[a].push_back(b),v[b].push_back(a);\n\td(1,0);\n\tprintf(\"%lld\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\n#define ll long long\nusing namespace std;\nconst ll maxn = 1000050;\nconst ll mod = 1e9+7+1616189;\nconst ll p = 9901;\nll C[100050];\nll ha[maxn] = {0};\nvector<int> G[maxn];\nint SG[maxn] = {0};\nint fa[maxn] = {0};\nmap<ll,ll> T;\nint n;\nint vis[maxn]={0};\nvoid bfs(){\n\tint i;\n\tqueue<int> q;\n\tfor(i=1;i<=n;++i){\n\t\tha[i] = 1;\n\t\tif(G[i].size()==0) {\n\t\t\tq.push(i);vis[i] = 1;\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tint t = q.front();q.pop();\n\t\tif(t==1) continue;\n\t\tif(SG[t]){//还没完成，放后面 \n\t\t\tq.push(t);continue;\n\t\t}\n\t\tha[fa[t]] += ha[t]*p;\n\t\tif(ha[fa[t]] > mod) ha[fa[t]] %=mod; \n\t\tSG[fa[t]]--;//少一个儿子 \n\t\t\n\t\tif(!vis[fa[t]]){//队列里还没有过 \n\t\t\tvis[fa[t]] = 1;q.push(fa[t]);\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i){\n\t\tif(T.find(ha[i])!=T.end()) T[ha[i]]++;\n\t\telse T[ha[i]] = 1;\n\t}\n}\nint main(){\n\tint i,a,b;scanf(\"%d\",&n);\n\tC[1] = 0;\n\tfor(i=2;i<100050;++i) C[i] = C[i-1]+i-1;\n\tfor(i = 1;i < n; ++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tG[a].push_back(b);\n\t\tSG[a]++;\n\t\tfa[b] = a;\n\t}\n\tT.clear();\n\tbfs();\n\tmap<ll,ll>::iterator it;\n\tlong long ans = 0;\n\tfor(it = T.begin();it!=T.end();++it){\n\t//\tcout<<it->second<<endl;\n\t\tans+=it->second*(it->second-1)/2;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef ONLINE_JUDGE\n    #define gc getchar\n    #define pc putchar\n#else\n    #define gc getchar_unlocked\n    #define pc putchar_unlocked\n#endif\n\nusing namespace std;\n\n#define vi vector<int>\n#define vll vector<i64>\n#define si set<int>\n#define vs vector<string>\n#define pii pair<int,int>\n#define vpi vector<pii>\n#define pri priority_queue<int>\n#define rev_pri priority_queue<int,vector<int>,greater<int> >\n#define mpi map<int,int>\n#define i64 long long int\n#define endl '\\n'\n#define pi acos(-1)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define mod2 1000000009\n#define For(i,n) for(int i=0;i<n;i++)\n#define Fre(i,a,b) for(int i = a; i < b; i++)\n#define sf(n) scanf(\"%d\", &n)\n#define sff(a,b) scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define pfn(n) printf(\"%d\\n\", n)\n#define pfs(n) printf(\"%d \", n)\n#define eps 1e-8\n#define ff first\n#define ss second\n#define mem(a,b) memset(a,b,sizeof(a))\n#define min3(a,b,c) min(a,min(b,c))\n#define max3(a,b,c) max(a,max(b,c))\n#define READ freopen(\"in.txt\", \"r\", stdin)\n#define WRITE freopen(\"out.txt\", \"w\", stdout)\n#define sz size()\n#define dbg(i) printf(\"yo %d\\n\", i)\n#define foreach(i,c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define sqr(a) (a) * (a)\n#define clr clear()\n#define CASE(a) printf(\"Case %d: \",a)\n\n//int dx[] = {0,1,0,-1,1,1,-1,-1};\n//int dy[] = {1,0,-1,0,1,-1,-1,1};\n//i64 dp[60][60];\n\n\n//functions\n\n//i64 gcd(i64 a,i64 b){if(!b)return a;return gcd(b,a%b);}\n\n//inline void fastRead(int *a){register char c=0;while(c<33)c=gc();*a=0;while(c>33){*a=*a*10+c-'0';c=gc();}}\n\n//inline void fastWrite(int a){char snum[20];int i=0;do{snum[i++]=a%10+48;a=a/10;}while(a!=0);i=i-1;while(i>=0)pc(snum[i--]);pc('\\n');}\n\ni64 bigmod(i64 num,i64 n)\n{\n        if(n==0)\n                return 1;\n        i64 x=bigmod(num,n/2);\n        x=x*x%mod;\n        if(n%2==1)\n                x=x*num%mod;\n        return x;\n}\n\n//i64 modinverse(i64 num){return bigmod(num,mod-2)%mod;}\n\n//void combination(int pos,int last){if(pos==k+1){for(int i=1;i<=k;i++)cout << tem[i];cout << endl;return;}\n//for(int i=last+1;i<=n-k+pos;i++){tem[pos] = num[i-1];combination(pos+1,i);}}\n\ni64 po(i64 a,i64 b){i64 ans=1;while(b--)ans *= a;return ans;}\n\n//i64 ncr(i64 n,i64 r){if(n==r)return 1;if(r==1)return n;if(dp[n][r]!=-1)return dp[n][r];return dp[n][r]=ncr(n-1,r)+ncr(n-1,r-1);}\n\n//int popcount(i64 num){bitset<70> tem(num);return tem.count();}\n\n//matrix rot(matrix a){matrix res;res.row = a.col;res.col = a.row;For(i,a.row)For(j,a.col)res.mat[j][a.row-i-1] = a.mat[i][j];return res;}\n\n\n#define p1 41\n\nvi v[100005];\ni64 lev[100005];\ni64 val[100005];\ni64 val2[100005];\n\n\nvoid dfs(int s,int l)\n{\n        lev[s] = l;\n        For(i,v[s].sz)\n                if(lev[v[s][i]]==-1)\n                        dfs(v[s][i],l+1);\n}\nint main()\n{\n\n        //ios_base::sync_with_stdio(false);cin.tie(0);\n        int n,m,x,y;\n        sf(n);\n\n        For(i,n-1)\n        {\n                sff(x,y);\n                v[x].pb(y);\n                v[y].pb(x);\n        }\n\n        mem(lev,-1);\n        dfs(1,1);\n        vpi nodes;\n        Fre(i,1,n+1)\n                nodes.pb(mp(lev[i],i));\n\n        sort(all(nodes));\n        reverse(all(nodes));\n\n        For(i,nodes.sz)\n        {\n                int u = nodes[i].ss;\n                int l = nodes[i].ff;\n                if(u!=1)\n                {\n                        val[u] =  ( (val[u] * bigmod(49157,l)) % mod + (i64)v[u].sz - 1 + mod ) % mod;\n                        val2[u] =  ( (val2[u] * bigmod(98317,l)) % mod2 + (i64)v[u].sz - 1 + mod2 ) % mod2;\n\n                }\n                else\n                {\n                        val[u] =  ( (val[u] * bigmod(49157,l)) % mod + (i64)v[u].sz  ) % mod;\n                        val2[u] =  ( (val2[u] * bigmod(98317,l)) % mod2 + (i64)v[u].sz ) % mod2;\n\n                }\n                For(i,v[u].sz)\n                {\n                        int w = v[u][i];\n                        if(lev[w]<l)\n                        {\n                                val[w] = (val[w] + val[u] ) % mod;\n                                val2[w] = (val2[w] + val2[u] ) % mod2;\n                                break;\n                        }\n                }\n        }\n        map < pair<i64,i64>, int > mpans;\n        Fre(i,1,n+1)\n                mpans[mp(val[i],val2[i])]++;\n        i64 ans = 0;\n        foreach(i,mpans)\n        {\n                i64 n = i->ss;\n                ans += n*(n-1)/2;\n        }\n\n        cout << ans << endl;\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\nusing namespace std;\n \n \nconst int mod=1e9+7;\nconst int maxn=1e6+10;\n#define _int64 unsigned long long\n \nmap<_int64,_int64> mp;\nvector<int> g[maxn];\n \n_int64 d[maxn];\n\n\n_int64 ans;\n\nint n; \n\n \nvoid dfs(int u,int fa){\n    d[u]=1;\n    for(int i=0;i<g[u].size();++i)\n\t{\n        int v=g[u][i];\n        if(v==fa)continue;\n        dfs(v,u);\n        d[u]+=d[v]*mod;\n    }\n    mp[d[u]]++;\n}\n \n \n\nint main()\n{\n\twhile(~scanf(\"%d\",&n))\n    {\n    \t\n    \tfor(int i=0; i<=n; i++)\n            g[i].clear();\n        mp.clear();\n        ans=0;\n        for(int i=1;i<n;i++)\n\t\t{\n            int u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n            g[u].push_back(v);\n\t\t\tg[v].push_back(u);\n        }\n      \n        dfs(1,0);\n        for(map<_int64,_int64>::iterator it=mp.begin(); it!=mp.end(); it++)\n            ans+=(_int64)it->second*(it->second-1)/2;\n        cout<<ans<<endl;\n    }\n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n\nvector<int> G[100000];\n\nconst ll H = (1LL<<30);\nconst ll B = 100003;\n\nll ans=0;\nmap<ll,int> hs;\n\nll dfs(int cur,int bef,int depth){\n    ll ret = 0;\n    bool isLeaf=true;\n    for(auto &e:G[cur]){\n        if(e==bef)continue;\n        isLeaf = false;\n        ret += dfs(e,cur,depth+1);\n    }\n    \n    int hash_num = (ret*B + 1)%H;\n    if(hs.count(hash_num)) ans+=hs[hash_num];\n    hs[hash_num]++;\n    \n    return hash_num;\n}\n\n\nint main(){\n    int v,a,b;\n    cin>>v;\n    rep(i,v-1){\n        cin>>a>>b;\n        G[--a].pb(--b);\n        G[b].pb(a);\n    }\n    dfs(0,-1,0);\n    \n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 200010\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint n;\nvector<int> e[MAX];\nint d[MAX]={};\nll b[MAX]={};\n\nvoid dfs(int v,int depth){\n  d[v]=depth;\n  FOR(i,0,e[v].size())dfs(e[v][i],depth+1);\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    e[a].pb(b);\n  }\n  dfs(0,0);\n\n  ll ans=0;\n  FOR(i,0,n)b[d[i]]++;\n  FOR(i,0,MAX)if(b[i]>1)ans+=b[i]*(b[i]-1)/2;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n\tHash(){\n\t\thash_value = 0;\n\t\tnum = 0;\n\t\tleft_child = right_child = -1;\n\t}\n\tull hash_value;\n\tint num,left_child,right_child;\n};\n\nstruct HashTree{\npublic:\n\tvoid init(int size){\n\t\thash = new Hash[size];\n\t\tnum_of_node = 0;\n\t}\n\n\tvoid addHash(ull value){\n\t\tif(num_of_node == 0){\n\t\t\thash[0].hash_value = value;\n\t\t\thash[0].num = 1;\n\t\t\tnum_of_node++;\n\t\t\treturn;\n\t\t}else{\n\t\t\tint index = 0;\n\n\t\t\twhile(true){\n\t\t\t\tif(value == hash[index].hash_value){\n\t\t\t\t\thash[index].num++;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(value > hash[index].hash_value){\n\t\t\t\t\tif(hash[index].right_child == -1){\n\t\t\t\t\t\thash[index].right_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].right_child;\n\t\t\t\t\t}\n\t\t\t\t}else{ //value < hash[index].hash_value\n\t\t\t\t\tif(hash[index].left_child == -1){\n\t\t\t\t\t\thash[index].left_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].left_child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull calc_ans(){\n\t\tull sum = 0;\n\n\t\tfor(int i = 0; i < num_of_node; i++){\n\t\t\tfor(int k = 1; k <= hash[i].num-1; k++){ //hash[i].numC2????¨????\n\t\t\t\t\tsum += k;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tHash* hash;\n\tint num_of_node;\n};\n\nstruct Node{\n\tvector<int> children;\n\tint parent;\n\tull Hash;\n};\n\nNode* node;\nHashTree HT;\n\null calc(int node_id){\n\n\tull pre = node[node_id].children.size(),current = 0;\n\n\tfor(int i = 0; i < node[node_id].children.size();i++){\n\t\tcurrent = calc(node[node_id].children[i])+pre*MOD;\n\t\tpre = current;\n\t}\n\n\tHT.addHash(current);\n\n\treturn current;\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tnode = (Node*)malloc(sizeof(Node)*(N+1));\n\tHT.init(N);\n\n\tint parent,child;\n\tfor(int i = 0; i < N-1; i++){\n\t\tscanf(\"%d %d\",&parent,&child);\n\t\tnode[parent].children.push_back(child);\n\t\tnode[child].parent = parent;\n\t}\n\n\t//?????????????????????????????±?????¨????????°????¨???????????????£??????\n\tcalc(1);\n\n\tprintf(\"%lld\\n\",HT.calc_ans());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint n,a,c;\null b=21387612863821\null ans;\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res*=dfs(v[x][i]);\n  res*=b;\n  //cout<<x<<' '<<m[res]<<endl;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> edge;\nvector<int> par;\nvector<int> h;\nint geth(int p, int pr) {\n    par[p] = pr;\n    int ma = 0;\n    for (int i : edge[p]) {\n        if (i == pr) continue;\n        ma = max(ma, geth(i, p) + 1);\n    }\n    return h[p] = ma;\n}\n\nint main() {\n    long long M = 1000007;\n    cin >> n;\n    edge.resize(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    h.resize(n, -1);\n    par.resize(n, -1);\n    geth(0, -1);\n    vector<vector<int>> lis(n);\n    for (int i = 0; i < n; ++i) {\n        lis[h[i]].push_back(i);\n    }\n    vector<long long> hsh(n, 0);\n    vector<map<long long, long long>> hsmp(n);\n    long long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j : lis[i]) {\n            hsh[j] = 1;\n            for (int k : edge[j]) {\n                if (par[j] == k) continue;\n                hsh[j] += hsh[k] * M;\n            }\n            if (hsmp[i].count(hsh[j]))\n                ++hsmp[i][hsh[j]];\n            else\n                hsmp[i][hsh[j]] = 1;\n        }\n        for (auto& j : hsmp[i]) {\n            ans += j.second * (j.second - 1) / 2;\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e11+7;\nconst ll K = 100007;\nvector<int> e[N];\nmap<ll,int>hs;\nmap<ll,int>::iterator it;\nll dfs(int u){\n  ll ret = 0;\n  for(auto& v: e[u])\n    ret = (ret+K*dfs(v)+1)%M;\n  ++hs[ret];\n  return ret;\n}\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    e[u].push_back(v);\n  }\n  dfs(1);\n  ll ans = 0;\n  for(it = hs.begin(); it!=hs.end(); ++it) ans += (it->second)*(it->second-1)/2;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e9+7;\nconst int K = 10001;\nvector<int> e[N];\nvector<ll> hs;\nint d[N], f[N];\n\n\nvoid pre_dfs(int u, int dep){\n  if(u==0) return;\n  d[u] = max(d[u], dep);\n  pre_dfs(f[u], dep+1);\n}\n\nll dfs(int u){\n  ll ret = 17;\n  for(auto v: e[u]){\n    ret = (ret+K*dfs(v))%M;\n  }\n  hs.push_back((d[u]+1)*ret);\n  return ret;\n}\n\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    d[u]++;\n    f[v] = u;\n    e[u].push_back(v);\n  }\n  for(int i = 1; i <= n; i++) if(!d[i]) pre_dfs(i, 0);\n  dfs(1);\n  ll ans = 0;\n  sort(hs.begin(), hs.end());\n  for(int i = 0; i < hs.size(); i++){\n    int s = i;\n    while(i < hs.size() && hs[i+1] == hs[i]) i++;\n    ans += (i-s+1)*(i-s)/2;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll base = 211;\nconstexpr ll M = 1000000000000037LL;\n\nll dfs(int v, vector<vector<int>>& g, vector<bool>& visited, vector<ll>& hs) {\n    visited[v] = true;\n    ll res = 1;\n    for(auto to : g[v]) {\n        if(!visited[to]) {\n            (res += dfs(to, g, visited, hs) * base) %= M;\n        }\n    }\n    return hs[v] = res;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> g(N);\n    for(int i=0; i<N-1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    vector<bool> visited(N);\n    vector<ll> hs(N);\n    dfs(0, g, visited, hs);\n    ll res = 0;\n    sort(hs.begin(), hs.end());\n    for(int i=0; i<N; ++i) {\n        auto p = equal_range(hs.begin(), hs.end(), hs[i]);\n        res += p.second - p.first - 1;\n    }\n    res /= 2;\n    cout << res << endl;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\nconst int M = 1000000007;\n\nint r;\nvector<int> g[100005];\nmap<int,int> m;\n\nint dfs(int cur, vector<bool> used){\n\tused[cur] = true;\n\n\tint res = 0;\n\tfor(auto to : g[cur]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(to, used);\n\t\tres %= M;\n\t}\n\tres = res * r + 1;\n\tres %= M;\n\tm[res]++;\n\treturn res;\n}\n\n\nsigned main(){\n\tint n;\n\tcin >> n;\n\trep(i,n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\n\tr = 8731873;\n\tdfs(0, vector<bool>(n,0));\n\n\tint ans = 0;\n\tfor(auto i : m){\n\t\t//show(i.second)\n\t\tans += (i.second * (i.second - 1)) / 2;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\nusing namespace std;\ntypedef unsigned long long ull;\null const Base = 1777771;\nint n,par[N],in[N];\n\null bfs(){\n  queue<int> Q;\n  ull ans=0;\n  map<ull,int> M[N];\n  vector<ull> H(n,1),dep(n,0);\n  for(int i=0;i<n;i++)if(!in[i])Q.push(i),ans+=M[0][1]++;\n  \n  while(!Q.empty()){\n    int pos = Q.front();Q.pop();\n    int nx = par[pos];\n    ull &A = H[pos],&B = H[nx];\n    dep[nx] = max(dep[nx],dep[pos]+1);\n    B+=A*Base;\n    if(--in[nx]==0)ans+=M[dep[nx]][B]++,Q.push(nx);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n;\n  for(int i=0,a,b;i<n-1;i++){\n    cin>>a>>b;\n    in[a-1]++,par[b-1] = a-1;\n  }\n  cout<<bfs()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define M 1777771\n#define N 100005\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair<ull,int> P;\ntypedef long long ll;\n\nll n,a,b,maxd[N];\nvector<int> G[N];\nmap<ull,ll> S;\null A[N];\n\nint get_maxd(int x,int d){\n  int res=d;\n  rep(i,G[x].size())\n    res=max(res,get_maxd(G[x][i],d+1));\n  return maxd[x]=res;\n}\n\nP dfs(int x,int d){\n  ull res1=0;\n  int res2=d;\n  \n  rep(i,G[x].size()){\n    P r=dfs(G[x][i],d+1);\n    res1+=r.first*A[maxd[x]-r.second];\n    res2=max(res2,r.second);\n  }\n  res1+=A[res2-d];\n  \n  if(S.count(res1))S[res1]++;\n  else S[res1]=1;\n  \n  return P(res1,res2);\n}\n\nint main(){\n  cin>>n;\n\n  rep(i,n-1){\n    cin>>a>>b;\n    G[a-1].push_back(b-1);\n  }\n  \n  A[0]=1;\n  for(int i=1;i<N;i++)A[i]=A[i-1]*M;\n  \n  get_maxd(0,0);\n  \n  dfs(0,0);\n\n  ll ans=0;\n  \n  map<ull,ll>::iterator ite=S.begin();\n  \n  while(ite!=S.end()){\n    if((*ite).second>=2)\n      ans+=(*ite).second*((*ite).second-1)/2;\n    ite++;\n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define M 1777771\n#define N 100005\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair<ull,int> P;\ntypedef long long ll;\n\nll n,a,b,maxd[N];\nvector<int> G[N];\nmap<ull,int> S;\null A[N];\n\nint get_maxd(int x,int d){\n  int res=d;\n  rep(i,G[x].size())\n    res=max(res,get_maxd(G[x][i],d+1));\n  return maxd[x]=res;\n}\n\nP dfs(int x,int d){\n  ull res1=0;\n  int res2=d;\n  \n  rep(i,G[x].size()){\n    P r=dfs(G[x][i],d+1);\n    res1+=r.first*A[maxd[x]-r.second];\n    res2=max(res2,r.second);\n  }\n  res1+=A[res2-d];\n  \n  if(S.count(res1))S[res1]++;\n  else S[res1]=1;\n  \n  return P(res1,res2);\n}\n\nint main(){\n  cin>>n;\n\n  rep(i,n-1){\n    cin>>a>>b;\n    G[a-1].push_back(b-1);\n  }\n  \n  A[0]=1;\n  for(int i=1;i<N;i++)A[i]=A[i-1]*M;\n  \n  get_maxd(0,0);\n  \n  dfs(0,0);\n\n  ll ans=0;\n  \n  map<ull,int>::iterator ite=S.begin();\n  \n  while(ite!=S.end()){\n    if((*ite).second>=2){\n      ans+=(*ite).second*((*ite).second-1)/2;\n    }\n    ite++;\n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n    Hash(){\n        hash_value = 0;\n        num = 0;\n        left_child = right_child = -1;\n    }\n    ull hash_value;\n    int num,left_child,right_child;\n};\n\nstruct HashTree{\npublic:\n    void init(int size){\n        hash = new Hash[size];\n        num_of_node = 0;\n    }\n\n    void addHash(ull value){\n        if(num_of_node == 0){\n            hash[0].hash_value = value;\n            hash[0].num = 1;\n            num_of_node++;\n            return;\n        }else{\n            int index = 0;\n\n            while(true){\n                if(value == hash[index].hash_value){\n                    hash[index].num++;\n                    return;\n                }else if(value > hash[index].hash_value){\n                    if(hash[index].right_child == -1){\n                        hash[index].right_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].right_child;\n                    }\n                }else{ //value < hash[index].hash_value\n                    if(hash[index].left_child == -1){\n                        hash[index].left_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].left_child;\n                    }\n                }\n            }\n        }\n    }\n\n    ull calc_ans(){\n        ull sum = 0;\n\n        for(int i = 0; i < num_of_node; i++){\n        \tsum += (hash[i].num)(hash[i].num-1)/2;\n        }\n        return sum;\n    }\n\n    Hash* hash;\n    int num_of_node;\n};\n\nstruct Node{\n    vector<int> children;\n    int parent;\n};\n\nNode* node;\nHashTree HT;\n\nvector<int> calc(int node_id){\n\n    vector<int> Ret;\n    Ret.push_back(node[node_id].children.size());\n\n    for(int i = 0; i < node[node_id].children.size();i++){\n        vector<int> tmp = calc(node[node_id].children[i]);\n        for(int k = 0; k < tmp.size(); k++){\n            if(k+1 >= Ret.size()){\n                Ret.push_back(tmp[k]);\n            }else{\n                Ret[k+1] += tmp[k];\n            }\n        }\n    }\n\n    ull pre = 0,current = 0;\n\n    for(int i = 0; i < Ret.size(); i++){\n        current = Ret[i] + pre*MOD;\n        pre = current;\n    }\n    HT.addHash(current);\n\n    return Ret;\n}\n\nint main(){\n\n    int N;\n    scanf(\"%d\",&N);\n\n    node = (Node*)malloc(sizeof(Node)*(N+1));\n    HT.init(N);\n\n    int parent,child;\n    for(int i = 0; i < N-1; i++){\n        scanf(\"%d %d\",&parent,&child);\n        node[parent].children.push_back(child);\n        node[child].parent = parent;\n    }\n\n    calc(1);\n\n    printf(\"%lld\\n\",HT.calc_ans());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n\tHash(){\n\t\thash_value = 0;\n\t\tnum = 0;\n\t\tleft_child = right_child = -1;\n\t}\n\tull hash_value;\n\tint num,left_child,right_child;\n};\n\nclass HashTree{\npublic:\n\tHashTree(int size){\n\t\thash = new Hash[size];\n\t\tnum_of_node = 0;\n\t}\n\n\tvoid addHash(ull value){\n\t\tif(num_of_node == 0){\n\t\t\thash[0].hash_value = value;\n\t\t\thash[0].num = 1;\n\t\t\tnum_of_node++;\n\t\t\treturn;\n\t\t}else{\n\t\t\tint index = 0;\n\n\t\t\twhile(true){\n\t\t\t\tif(value == hash[index].hash_value){\n\t\t\t\t\thash[index].num++;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(value > hash[index].hash_value){\n\t\t\t\t\tif(hash[index].right_child == -1){\n\t\t\t\t\t\thash[index].right_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].right_child;\n\t\t\t\t\t}\n\t\t\t\t}else{ //value < hash[index].hash_value\n\t\t\t\t\tif(hash[index].left_child == -1){\n\t\t\t\t\t\thash[index].left_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].left_child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull calc_ans(){\n\t\tull sum = 0;\n\n\t\tfor(int i = 0; i < num_of_node; i++){\n\t\t\tfor(int k = 1; k <= hash[i].num-1; k++){ //hash[i].numC2????¨????\n\t\t\t\t\tsum += k;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tHash* hash;\n\tint num_of_node;\n};\n\nstruct Node{\n\n\tvector<int> S;\n\tvector<int> children;\n\tint parent;\n};\n\nNode* node;\n\nvector<int> calc(int node_id){\n\n\tvector<int> Ret;\n\tRet.push_back(node[node_id].children.size()); //node[node_id]??????????????±???1?????????????????°??????????????°??????????????????\n\n\tfor(int i = 0; i < node[node_id].children.size();i++){\n\t\tvector<int> tmp = calc(node[node_id].children[i]); //????????????vector?????°???\n\t\tfor(int k = 0; k < tmp.size(); k++){\n\t\t\tif(k+1 >= Ret.size()){ //?????????????????????????????????????????\\????????´?????????????¶???? size()???A?????????vector????????????????????????0???A-1\n\t\t\t\tRet.push_back(tmp[k]);\n\t\t\t}else{\n\t\t\t\tRet[k+1] += tmp[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Ret.size(); i++){\n\t\tnode[node_id].S.push_back(Ret[i]);\n\t}\n\treturn Ret;\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tnode = (Node*)malloc(sizeof(Node)*(N+1));\n\n\tint parent,child;\n\tfor(int i = 0; i < N-1; i++){\n\t\tscanf(\"%d %d\",&parent,&child);\n\t\tnode[parent].children.push_back(child);\n\t\tnode[child].parent = parent;\n\t}\n\n\t//?????????????????????????????±?????¨????????°????¨???????????????£??????\n\tcalc(1);\n\n\tHashTree HT(N);\n\n\tull pre,current;\n\n\t//??±?????????????????°????????????hash?????????\n\tfor(int i = 2; i <= N; i++){\n\t\tpre = 0;\n\t\tcurrent = 0;\n\t\tfor(int k = 0; k < node[i].S.size();k++){\n\t\t\tcurrent = node[i].S[k] + pre*MOD;\n\t\t\tpre = current;\n\t\t}\n\t\tHT.addHash(current);\n\t}\n\n\tprintf(\"%lld\\n\",HT.calc_ans());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define M 1777771\n#define N 100005\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair<ull,int> P;\ntypedef long long ll;\n\nconst ll mod = 1e9+7;\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n \nll nCr(ll n,ll r){\n  static vector<ll> k(1e6);\n  if(!k[0]){k[0]=1;for(int i=1;i<k.size();i++)k[i]=i*k[i-1]%mod;}\n  ll a=mod_pow(k[r],mod-2);\n  ll b=mod_pow(k[n-r],mod-2);\n  return ((k[n]*a)%mod)*b%mod;\n}\n\nint n,a,b,maxd[N];\nvector<int> G[N];\nmap<ull,int> S;\null A[N];\n\nint get_maxd(int x,int d){\n  int res=d;\n  rep(i,G[x].size())\n    res=max(res,get_maxd(G[x][i],d+1));\n  return maxd[x]=res;\n}\n\nP dfs(int x,int d){\n  ull res1=0;\n  int res2=d;\n  \n  rep(i,G[x].size()){\n    P r=dfs(G[x][i],d+1);\n    res1+=r.first*A[maxd[x]-r.second];\n    res2=max(res2,r.second);\n  }\n  res1+=A[res2-d];\n  \n  if(S.count(res1))S[res1]++;\n  else S[res1]=1;\n  \n  return P(res1,res2);\n}\n\nint main(){\n  cin>>n;\n  \n  rep(i,n-1){\n    cin>>a>>b;\n    G[a-1].push_back(b-1);\n  }\n  \n  A[0]=1;\n  for(int i=1;i<N;i++)A[i]=A[i-1]*M;\n  \n  get_maxd(0,0);\n  \n  dfs(0,0);\n\n  int ans=0;\n  \n  map<ull,int>::iterator ite=S.begin();\n  \n  while(ite!=S.end()){\n    if((*ite).second>=2)\n      ans+=nCr((*ite).second,2);\n    ite++;\n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\nstruct RollingHash {\n    using uint = uint64_t;\n    vector<uint> hash, pow;\n    static const uint MASK30 = (1LL<<30)-1,\n                      MASK31 = (1LL<<31)-1,\n                      MASK61 = (1LL<<61)-1;\n\n    template<typename S>\n    RollingHash(const S& s, uint base) {\n        int n = s.size();\n        hash.assign(n+1, 0);\n        pow.assign(n+1, 1);\n        for (int i = 0; i < n; ++i) {\n            hash[i+1] = _mod(_mul(hash[i], base) + s[i]);\n            pow[i+1] = _mul(pow[i], base);\n        }\n    }\n\n    uint get(int l, int r) const {\n        return _mod(hash[r] + MASK61 - _mul(hash[l], pow[r - l]));\n    }\n\n    static uint _mul(uint a, uint b) {\n        uint au = a >> 31, ad = a & MASK31,\n             bu = b >> 31, bd = b & MASK31;\n        uint m = au * bd + ad * bu;\n        uint mu = m >> 30, md = m & MASK30;\n\n        return _mod(au*bu*2 + mu + (md<<31) + ad*bd);\n    }\n    static uint _mod(uint x) {\n        uint xu = x >> 61, xd = x & MASK61;\n        uint ret = xu + xd;\n        if (ret >= MASK61) ret -= MASK61;\n        return ret;\n    }\n    static uint gen_base() {\n        mt19937 random{random_device{}()};\n        uniform_int_distribution<uint> dist(2, MASK61-2);\n        return dist(random);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    vector<vector<int>> G(n);\n    for (int i = 0; i < n-1; ++i) {\n        int s, t; cin >> s >> t; --s, --t;\n        G[s].push_back(t);\n    }\n\n    using uint = uint64_t;\n    vector<uint> hash(n);\n    const uint base = RollingHash::gen_base();\n\n    function<void(int)> dfs = [&](int v){\n        for (int u : G[v]) {\n            dfs(u);\n            hash[v] = RollingHash::_mod(hash[v] + hash[u]);\n        }\n        for (int k = 0; k < 2; ++k) {\n            hash[v] = RollingHash::_mul(hash[v], base);\n            hash[v] = RollingHash::_mod(hash[v] + 1);\n        }\n    };\n\n    dfs(0);\n\n    map<uint, LL> cnt;\n    for (int i = 0; i < n; ++i) {\n        ++cnt[hash[i]];\n    }\n\n    LL ans = 0;\n    for (const auto& tp : cnt) {\n        ans += tp.second * (tp.second - 1) / 2;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nint fa[100100],du[100100],du1[100100],vis[100100];\nint n,x,y,num[100100];\nset<int>s,s1,ss;\nlong long ans=0;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;++i)\n    {\n        scanf(\"%d %d\",&x,&y);\n        fa[y]=x;du[x]++;\n    }\n    for(int i=1;i<=n;++i) if(du[i]==0) {s.insert(i);vis[i]=1;}\n    int siz=s.size();\n    ans+=1LL*siz*(siz-1)/2;\n    while(s.size()>1)\n    {\n        s1.clear();\n        set<int>::iterator it;\n        for(it=s.begin();it!=s.end();++it) s1.insert(*it);\n        s.clear();\n        for(it=s1.begin();it!=s1.end();++it) if(vis[*it])\n        {\n            int f=fa[*it];\n            du1[f]++,s.insert(f);\n        }\n        for(it=s.begin();it!=s.end();++it)\n        {\n            if(du[*it]!=du1[*it]) continue;\n            vis[*it]=1;\n            num[du[*it]]++;ss.insert(du[*it]);\n        }\n        //puts(\"\");\n        for(it=ss.begin();it!=ss.end();++it)\n        {\n            //printf(\"num[%d]=%d \",(*it),num[*it]);\n            ans+=1LL*num[*it]*(num[*it]-1)/2;\n            num[*it]=0;\n        }\n        //puts(\"\");puts(\"\");\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mst(a,b) memset(a,b,sizeof(a))\n#define cmax(a,b) a = max(a,b)\n#define ft first\n#define sd second\n#define mp(a,b) make_pair(a,b)\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn = 1e5+19;\nconst LL PP = 1e9+7;\nconst LL maxp = 19260817;\n\nstruct edge{\n\tint v,p;\n\tedge(){}\n\tedge(int V,int P):v(V),p(P){}\n}e[maxn<<1];\n\nint hash[maxp],ed,lst[maxn],rnk[maxn];\nLL f[maxn];\n\nvoid init() {\n\tmst(hash,0);mst(f,0);\n\tmst(lst,-1);mst(rnk,0);\n\ted = -1;\n}\n\nvoid add_edge(int u,int v) {\n\te[++ed] = edge(v,lst[u]);lst[u] = ed;\n\te[++ed] = edge(u,lst[v]);lst[v] = ed;\n}\n\nLL solve(int u,int fa) {\n\tint v;\n\tfor(int i = lst[u] ; ~i ; i = e[i].p) {\n\t\tv = e[i].v;\n\t\tif(v != fa) \n\t\t\tf[u] = (f[u]+solve(v,u)*PP%maxp)%maxp;\n\t}\n\t++f[u];\n\t++hash[f[u]];\n\treturn f[u];\n}\n\nint main() {\n\tinit();\n\tint n,x,y;\n\tLL ans = 0;\n\tscanf(\"%d\",&n);\n\tfor(int i = 1 ; i < n ; ++i) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd_edge(x,y);\n\t}\n\tsolve(1,-1);\n\n\tfor(int i = 0 ; i < maxp ; ++i) \n\t\tans += (LL)hash[i]*(LL)(hash[i]-1)/2;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nconst int maxn = 100050;\nusing namespace std;\nvector<int> son[maxn];\nstruct D{\n\tvector<int> d;\n\tint de;\n\tD(){\n\t\td.clear();de = 0;\n\t}\n\tbool operator <(const D& b) const{ \n\t\tint len1=d.size();\n\t\tint len2 = b.d.size();\n\t\tif(len1 != len2) return len1<len2;//深度 \n\t\telse{\n\t\t\tfor(int i=0;i<len1;++i){\n\t\t\t\tif(d[i]==b.d[i]) continue;\n\t\t\t\treturn d[i] < b.d[i];\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}dep[maxn];\nint yz = 0;\nmap<D,int> T;\nvoid dfs(int cur){\n\tif(son[cur].empty()){\n\t\tyz ++;\n\t\treturn;\n\t}\n\tint i,j;\n\tint len = son[cur].size();\n\tdep[cur].d.push_back(len);//把儿子这一层加入\n\tdep[cur].de = 1; \n\tfor(i = 0; i <len ;++ i){\n\t\tint s=son[cur][i];\n\t\tdfs(s); //操作儿子 \n\t\t\n\t\tif(dep[cur].de <= dep[s].de + 1){\n\t\t\tfor(j = 1;j < dep[cur].de;++j) dep[cur].d[j]+=dep[s].d[j-1];//跟新原有 \n\t\t\tfor(j;j < dep[s].de + 1;++j) dep[cur].d.push_back(dep[s].d[j-1]);//需要拓展 \n\t\t\tdep[cur].de = dep[s].de + 1;//更新深度 \n\t\t}\n\t\telse{\n\t\t\tfor(j = 1;j <= dep[s].de; ++j){\n\t\t\t\tdep[cur].d[j]+=dep[s].d[j-1];\n\t\t\t}\n\t\t}\n\t\tdep[s].d.clear();\n\t}//当前结点操作完毕\n\t if(T.find(dep[cur])==T.end()){\n\t \tT[dep[cur]] = 1;\n\t }\n\t else  ++ T[dep[cur]];\n\t return;\n}\nlong long C[100050];\nint main(){\n\tint n,i,a,b;scanf(\"%d\",&n);for(i = 1;i <= n; ++i) son[i].clear();\n\tC[1] = 0;\n\tfor(i=2;i<100050;++i) C[i] = C[i-1]+i-1;\n\tfor(i = 1;i < n; ++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tson[a].push_back(b);\n\t}\n\tT.clear();\n\tdfs(1);\n\tmap<D,int>::iterator it;\n\tlong long ans = 0;\n\tans += C[yz];\n\tfor(it = T.begin();it!=T.end();++it){\n\t\tans +=C[it->second];\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e9+7;\nconst ll K = 633333;\nvector<int> e[N];\nvector<ll> hs;\nint d[N], f[N];\n\n\nvoid pre_dfs(int u, int dep){\n  if(u==0) return;\n  d[u] = max(d[u], dep);\n  pre_dfs(f[u], dep+1);\n}\n\nll dfs(int u){\n  ll ret = 17;\n  for(auto v: e[u]){\n    ret = (ret+K*dfs(v))%M;\n  }\n  hs.push_back((d[u])*ret);\n  return ret;\n}\n\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    d[u]++;\n    f[v] = u;\n    e[u].push_back(v);\n  }\n  for(int i = 1; i <= n; i++) if(!d[i]) pre_dfs(i, 0);\n  dfs(1);\n  ll ans = 0;\n  sort(hs.begin(), hs.end());\n  for(int i = 0; i < hs.size(); i++){\n    int s = i;\n    while(i < hs.size() && hs[i+1] == hs[i]) i++;\n    ans += (i-s+1)*(i-s)/2;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2784.cc: Similarity of Subtrees\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int P = 4073;\nconst int MOD = 1000000009;\n\n/* typedef */\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\nstruct Trp {\n  int n, d, h;\n  Trp() {}\n  Trp(int _n, int _d, int _h): n(_n), d(_d), h(_h) {}\n\n  bool operator==(const Trp &t) const {\n    return n == t.n && d == t.d && h == t.h;\n  }\n\n  bool operator<(const Trp &t) const {\n    return n < t.n || (n == t.n && (d < t.d || (d == t.d && h < t.h)));\n  }\n\n  void print() { printf(\"(%d,%d,%d)\\n\", n, d, h); }\n};\n\n/* global variables */\n\nvi nbrs[MAX_N];\nint prts[MAX_N], cns[MAX_N];\nTrp ts[MAX_N];\n\n/* subroutines */\n\ninline void setmax(int &a, int b) { if (a < b) a = b; }\n\n/* main */\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    a--, b--;\n    nbrs[a].push_back(b);\n    nbrs[b].push_back(a);\n  }\n\n  fill(ts, ts + n, Trp(1, 0, 1));\n  \n  prts[0] = -1;\n  qi q;\n  q.push(0);\n\n  while (! q.empty()) {\n    int u = q.front(); q.pop();\n    int &up = prts[u];\n    vi &nbru = nbrs[u];\n    for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int &v = *vit;\n      if (v != up) {\n\tprts[v] = u;\n\tcns[u]++;\n\tq.push(v);\n      }\n    }\n  }\n\n  for (int i = 0; i < n; i++)\n    if (! cns[i]) q.push(i);\n\n  while (! q.empty()) {\n    int u = q.front(); q.pop();\n    int &up = prts[u];\n\n    if (up >= 0) {\n      ts[up].n += ts[u].n;\n      setmax(ts[up].d, ts[u].d + 1);\n      ts[up].h = (ts[up].h + (ll)ts[u].h * P) % MOD;\n      if (--cns[up] == 0) q.push(up);\n    }\n  }\n  sort(ts, ts + n);\n  //for (int i = 0; i < n; i++) ts[i].print();\n\n  ll c = 0;\n  for (int i = 0, j = 0; i < n;) {\n    while (j < n && ts[i] == ts[j]) j++;\n    int d = j - i;\n    c += (ll)d * (d - 1) / 2;\n    i = j;\n  }\n\n  printf(\"%lld\\n\", c);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll             long long\n#define pi             pair <int,int>\n#define pl             pair <ll,ll>\n#define ps             pair <string,string>\n#define vi             vector <int>\n#define vl             vector <ll>\n#define vpi            vector <pi>\n#define vpl            vector <pl>\n#define f(i,a,b)       for(ll i=(a);i<(b);i++)\n#define fd(i,a,b)      for(ll i=(a);i>(b);i--)\n#define x              first\n#define y              second\n#define si(a)          scanf(\"%d\",&a)\n#define sii(a,b)       scanf(\"%d %d\",&a,&b)\n#define siii(a,b,c)    scanf(\"%d %d %d\",&a,&b,&c)\n#define sl(a)          scanf(\"%lld\",&a)\n#define sll(a,b)       scanf(\"%lld %lld\",&a,&b)\n#define slll(a,b,c)    scanf(\"%lld %lld %lld\",&a,&b,&c)\n#define sd(a)          scanf(\"%lf\",&a)\n#define sdd(a,b)       scanf(\"%lf %lf\",&a,&b)\n#define sddd(a,b,c)    scanf(\"%lf %lf %lf\",&a,&b,&c)\n#define ss(s)          scanf(\"%s\",s)\n#define pf             printf\n#define pfi(n)         printf(\"%d\\n\",n)\n#define pfl(n)         printf(\"%lld\\n\",n)\n#define pfls(n)        printf(\"%lld \",n)\n#define pfci(n,ans)    printf(\"Case %lld: %d\\n\",n,ans)\n#define pfcl(n,ans)    printf(\"Case %lld: %lld\\n\",n,ans)\n#define pfcd(n,ans)    printf(\"Case %lld: %lf\\n\",n,ans)\n#define pb             push_back\n#define all(v)         v.begin(),v.end()\n#define mem(a,v)       memset(a,v,sizeof(a))\n#define MAX 100007\n#define MOD 10007\n#define INF 1e12\n#define LG  16\n#define mid ((l+r)/2)\n#define PI (acos(-1.0))\n#define ppl pair<pl,ll>\n#define id(i,j,n) (n*(i-1)+j)\n#define PT pair<double,double>\n#define IN(n) (2*(n)-1)\n#define OUT(n) (2*(n))\nusing namespace std;\n\n\n#define MD1 1000000021\n#define PR1 1299019\n\n#define MD2 1000000033\n#define PR2 1299029\n\n\nvl G[MAX];\nll H1[MAX], H2[MAX];\npl H[MAX];\n\nvoid dfs(ll u,ll p){\n    H1[u]=H2[u]=0;\n    f(i,0,G[u].size()){\n        ll v=G[u][i];\n        if(v!=p){\n            dfs(v,u);\n            H1[u]=(H1[u]+H1[v])%MD1;\n            H2[u]=(H2[u]+H2[v])%MD2;\n        }\n    }\n    H1[u]=(PR1*H1[u]+1)%MD1;\n    H1[u]=(H1[u]+MD1)%MD1;\n    H2[u]=(PR2*H2[u]+1)%MD2;\n    H2[u]=(H2[u]+MD2)%MD2;\n    H[u]=pl(H1[u],H2[u]);\n}\n\nint main(){\n    ll N;\n    cin>>N;\n    f(i,1,N){\n        ll a,b;\n        cin>>a>>b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    dfs(1,1);\n    sort(H+1,H+N+1);\n    H[0]=pl(-INF,-INF);\n    ll stk=1, ans=0;\n    f(i,1,N+1){\n        if(H[i]!=H[i-1]){\n            ans+=(stk*(stk-1));\n            stk=1;\n        }\n        else stk++;\n    }\n    ans>>=1;\n    cout<<ans<<endl;\n    //pfl(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int mod=1e9+7;\nconst int N=1e5+5;\nconst int x1=1e5+3;\nconst int x2=1e5+19;\nint dep[N],hd;\nstruct node{\n\tint v,nxt;\n}p[N];\nint head[N],son[N],tot;\null a[N],p2[N],p3[N],b[N];\nvoid add(int x,int y){\n\tp[tot].v=y;\n\tp[tot].nxt=head[x];\n\thead[x]=tot++;\n}\nvoid init(){\n\ttot=0;\n\tp3[0]=p2[0]=1;\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<N;i++){\n\t\tp2[i]=x1*p2[i-1];\n\t\tp3[i]=x2*p3[i-1];\n\t}\n}\nmap<pair<ull,ull>,int>mp;\nmap<pair<ull,ull>,int>::iterator it;\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];~i;i=p[i].nxt){\n\t\tint y=p[i].v;\n\t\tif(y==fa)\n\t\t\tcontinue;\n\t\tdfs(y,x);\n\t\tdep[x]=max(dep[y],dep[x]);\n\t}\n\tfor(int i=head[x];~i;i=p[i].nxt){\n\t\tint y=p[i].v;\n\t\tif(y==fa)\n\t\t\tcontinue;\n\t\ta[x]=a[x]+a[y]*p2[dep[x]-dep[y]];\n\t\tb[x]=b[x]+b[y]*p3[dep[x]-dep[y]];\n\t}\n\tdep[x]++;\n\ta[x]=a[x]+p2[dep[x]];\n\tb[x]=b[x]+p3[dep[x]];\n\t//cout<<x<<' '<<a[x]<<' '<<dep[x]<<endl;\n\tmp[make_pair(b[x],a[x])]++;\n\thd++;\n}\nint main(){\n\n\tinit();\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdfs(1,0);\n\tll ans=0;\n\tfor(it=mp.begin();it!=mp.end();it++){\n\t\tint t=it->second;\n\t\t//cout<<t<<endl;\n\t\tans+=1ll*t*(t-1)/2;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n\tHash(){\n\t\thash_value = 0;\n\t\tnum = 0;\n\t\tleft_child = right_child = -1;\n\t}\n\tull hash_value;\n\tint num,left_child,right_child;\n};\n\nclass HashTree{\npublic:\n\tHashTree(int size){\n\t\thash = new Hash[size];\n\t\tnum_of_node = 0;\n\t}\n\n\tvoid addHash(ull value){\n\t\tif(num_of_node == 0){\n\t\t\thash[0].hash_value = value;\n\t\t\thash[0].num = 1;\n\t\t\tnum_of_node++;\n\t\t\treturn;\n\t\t}else{\n\t\t\tint index = 0;\n\n\t\t\twhile(true){\n\t\t\t\tif(value == hash[index].hash_value){\n\t\t\t\t\thash[index].num++;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(value > hash[index].hash_value){\n\t\t\t\t\tif(hash[index].right_child == -1){\n\t\t\t\t\t\thash[index].right_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].right_child;\n\t\t\t\t\t}\n\t\t\t\t}else{ //value < hash[index].hash_value\n\t\t\t\t\tif(hash[index].left_child == -1){\n\t\t\t\t\t\thash[index].left_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].left_child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull calc_ans(){\n\t\tull sum = 0;\n\n\t\tfor(int i = 0; i < num_of_node; i++){\n\t\t\tfor(int k = 1; k <= hash[i].num-1; k++){ //hash[i].numC2????¨????\n\t\t\t\t\tsum += k;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tHash* hash;\n\tint num_of_node;\n};\n\nstruct Node{\n\tNode(){\n\t\tparent = -1;\n\t}\n\n\t//vector<int> S,children;\n\tvector<int> S;\n\tvector<int> children;\n\tint parent;\n};\n\nNode* node;\n\nvector<int> calc(int node_id){\n\n\tvector<int> Ret;\n\tRet.push_back(node[node_id].children.size()); //node[node_id]??????????????±???1?????????????????°??????????????°??????????????????\n\n\tfor(int i = 0; i < node[node_id].children.size();i++){\n\t\tvector<int> tmp = calc(node[node_id].children[i]); //????????????vector?????°???\n\t\tfor(int k = 0; k < tmp.size(); k++){\n\t\t\tif(k+1 >= Ret.size()){ //?????????????????????????????????????????\\????????´?????????????¶???? size()???A?????????vector????????????????????????0???A-1\n\t\t\t\tRet.push_back(tmp[i]);\n\t\t\t}else{\n\t\t\t\tRet[k+1] += tmp[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < Ret.size(); i++){\n\t\tnode[node_id].S.push_back(Ret[i]);\n\t}\n\treturn Ret;\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tnode = (Node*)malloc(sizeof(Node)*(N+1));\n\n\tint parent,child;\n\tfor(int i = 0; i < N-1; i++){\n\t\tscanf(\"%d %d\",&parent,&child);\n\t\tnode[parent].children.push_back(child);\n\t\tnode[child].parent = parent;\n\t}\n\n\t//?????????????????????????????±?????¨????????°????¨???????????????£??????\n\tcalc(1);\n\n\tHashTree HT(N);\n\n\tull pre,current;\n\n\t//??±?????????????????°????????????hash?????????\n\tfor(int i = 1; i <= N; i++){\n\t\tpre = 0;\n\t\tfor(int k = 0; k < node[i].S.size();k++){\n\t\t\tcurrent = node[i].S[k] + pre*MOD;\n\t\t\tpre = current;\n\t\t}\n\t\tHT.addHash(current);\n\t}\n\n\tprintf(\"%lld\\n\",HT.calc_ans());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\nint N;\nvector<int>G[1<<17];\nmap<long,int>M;\nlong B1=1000000181,B2=1000999943;\nlong ans;\nlong dfs(int u,int p)\n{\n\tlong ret=0;\n\tfor(int v:G[u])\n\t{\n\t\tif(v!=p)\n\t\t{\n\t\t\tret+=dfs(v,u);\n\t\t}\n\t}\n\tret=(ret*B1+1)%B2;\n\tans+=M[ret]++;\n\treturn ret;\n}\nmain()\n{\n\tcin>>N;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;cin>>u>>v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst double PI = acos(-1.0);\nconst int INF=0x3f3f3f3f;\nconst int N=1e5+9;\n\nll vis[N], n, a[N], b[N], t1, t2;\nmap<pll, ll> ma;\nvi v[N];\n\npll dfs(int d, int dep){\n\t//printf(\"c:%d %d\\n\", d, dep);\n\t//printf(\"t:%d %d\\n\", t.x, t.y);\n\tpll t=pii(0, 0);\n\tvis[d]=1;\n\tif(v[d].size()==1 && vis[v[d][0]]){\n\t\ta[d]=1, b[d]=0;\n\t\tma[pii(a[d], b[d])]++;\n\t\treturn pll(1, dep);\n\t}\n\tfor(int i=0; i<v[d].size(); i++){\n\t\t//printf(\"ok %d\\n\", v[d][i]);\n\t\tif(!vis[v[d][i]]){\n\t\t\tpii t1=dfs(v[d][i], dep+1);\n\t\t\tt.x+=t1.x;\n\t\t\tt.y+=t1.y;\n\t\t}\n\t}\n//\tprintf(\"t:%d %d\\n\", t.x, t.y);\n//\tprintf(\"ab:%d %d\\n\", a[d], b[d]);\n\ta[d]=t.x+1;\n\tb[d]=t.y+dep-a[d]*dep;\n\tma[pll(a[d], b[d])]++;\n\treturn pll(t.x+1, t.y+dep);\n}\n\nint main(void){\n\t//if(fopen(\"in\", \"r\")!=NULL) {freopen(\"in\", \"r\", stdin); freopen(\"out\", \"w\", stdout);}\n\twhile(cin>>n){\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tscanf(\"%lld%lld\", &t1, &t2);\n\t\t\tv[t1].push_back(t2);\n\t\t\tv[t2].push_back(t1);\n\t\t}\n\t\tmemset(vis, 0, sizeof vis);\n\t\tdfs(1, 0);\n\t//\tfor(int i=1; i<=n; i++){\n\t//\t\tprintf(\"%d %d\\n\", a[i], b[i]);\n\t//\t}\n\t\tll ans=0;\n\t\tfor(map<pll, ll>::iterator it=ma.begin(); it!=ma.end(); it++){\n\t\t\tll t=it->y;\n\t\t\tans+=t*(t-1)/2;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\nconst int M = 1000000007;\n\nint r;\nvector<int> g[100005];\nmap<int,int> m;\n\nint dfs(int cur, vector<bool> used){\n\tused[cur] = true;\n\n\tint res = 0;\n\tfor(auto to : g[cur]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(to, used);\n\t\tres %= M;\n\t}\n\tres = res * r + 1;\n\tm[res]++;\n\treturn res;\n}\n\n\nsigned main(){\n\tint n;\n\tcin >> n;\n\trep(i,n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\n\tr = 67280421310721LL;\n\tdfs(0, vector<bool>(n,0));\n\n\tint ans = 0;\n\tfor(auto i : m){\n\t\t//show(i.second)\n\t\tans += (i.second * (i.second - 1)) / 2;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e9+7;\nconst ll K = 100007;\nvector<int> e[N];\nmap<ll,int>hs;\nmap<ll,int>::iterator it;\nll dfs(int u){\n  ll ret = 0;\n  for(auto& v: e[u])\n    ret = (ret+K*(1+dfs(v)))%M;\n  ++hs[ret];\n  return ret;\n}\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    e[u].push_back(v);\n  }\n  dfs(1);\n  ll ans = 0;\n  for(it = hs.begin(); it!=hs.end(); ++it) ans += (it->second)*(it->second-1)/2;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst int MAX_N = 1e5 + 5;\n\nint N;\nlist<int> G[MAX_N];\n\ninline void maxi(int &x, int y){ x=max(x,y);}\n\nconst int HCT = 1;\n\nconst ULL hcb[4] = {103, 59627, 65203, 73709};\nULL hcbpow[4][MAX_N];\n\nstruct Node{\n\tint h;\n\tULL hc[HCT];\n\tNode() { memset(hc, 0, sizeof hc);}\n}node[MAX_N];\n\ninline int cmp(const Node &x, const Node &y){\n\tif (x.h != y.h){\n\t\tif (x.h < y.h) return -1;\n\t\telse return 1;\n\t}\n\tfor (int i = 0; i < HCT; ++i){\n\t\tif (x.hc[i] != y.hc[i]){\n\t\t\tif (x.hc[i] < y.hc[i]) return -1;\n\t\t\telse return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\ninline bool comp(const Node &x, const Node &y){\n\treturn cmp(x, y) < 1;\n}\n\ninline void pre(){\n\tfor (int i = 0; i < HCT; ++i) hcbpow[i][0] = 1;\n\tfor (int i = 1; i < MAX_N; ++i){\n\t\tfor (int j = 0; j < HCT; ++j){\n\t\t\thcbpow[j][i] = hcbpow[j][i-1] * hcb[j];\n\t\t}\n\t}\n}\n\nvoid hdfs(int u, int father){\n\tfor (auto &v: G[u]){\n\t\tif (v != father){\n\t\t\thdfs(v, u);\n\t\t\tmaxi(node[u].h, node[v].h+1);\n\t\t}\n\t}\n\tmaxi(node[u].h, 1);\n}\n\nvoid hcdfs(int u, int father){\n\tfor (auto &v : G[u]){\n\t\tif (v != father){\n\t\t\thcdfs(v, u);\n\t\t\tint dh = node[u].h-1 - node[v].h;\n\t\t\tfor (int i = 0; i < HCT; ++i){\n\t\t\t\tnode[u].hc[i] += node[v].hc[i] * hcbpow[i][dh];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < HCT; ++i){\n\t\tnode[u].hc[i] += hcbpow[i][node[u].h];\n\t}\n}\n\nLL solve(){\n\thdfs(1, 0);\n\thcdfs(1, 0);\n\tsort(node+1, node+1+N, comp);\n\tLL ret = 0, cnt = 1;\n\tfor (int i = 1; i <= N+1; ++i){\n\t\tif (cmp(node[i], node[i-1]) == 0) ++cnt;\n\t\telse{\t\n\t\t\tret += (cnt-1)*cnt/2;\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tpre();\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; ++i){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tLL ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing pll = pair<ll, ll>;\nmap<pll, int> dic;\nvector<vi> graph;\n\nll mod1 = 1e9+7LL;\nint base1 = 10007;\nll mod2 = 1e9+9LL;\nint base2 = 1009;\n\npll dfs(int v, int pv, int d){\n    ll ret1 = 0LL, ret2 = 0LL;\n    for(int nv : graph[v]){\n        if(nv == pv) continue;\n        pll nxt = dfs(nv, v, d + 1);\n        ret1 = ADD(ret1, nxt.first , mod1);\n        ret2 = ADD(ret2, nxt.second, mod2);\n    }\n    ret1 = MUL(ret1, base1, mod1);\n    ret2 = MUL(ret2, base2, mod2);\n    ret1 = ADD(ret1, 1LL, mod1);\n    ret2 = ADD(ret2, 1LL, mod2);\n\n    dic[pll(ret1, ret2)]++;\n    return pll(ret1, ret2);\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    graph = vector<vi>(n);\n\n    rep(i, n - 1){\n        int a, b; cin >> a >> b; a--, b--;\n        graph[a].emplace_back(b);\n        graph[b].emplace_back(a);\n    }\n    dfs(0, -1, 0);\n\n    long long res = 0LL;\n    for(auto& e : dic){\n        ll num = e.second;\n        res += num * (num - 1) / 2;\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int mod = 1e9 + 7;\n \nint N;\nvector< int > tree[100000];\nint hashed[100000];\nmap< int, int > val;\nlong long ret;\n \nint dfs(int idx, int par = -1)\n{\n  int hashed = 1;\n  for(int to : tree[idx]) {\n    if(to != par) (hashed += 1LL * dfs(to, idx) * 1003 % mod) %= mod;\n  }\n  ret += val[hashed]++;\n  return(hashed);\n}\n \nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int A, B;\n    cin >> A >> B;\n    --A, --B;\n    tree[A].push_back(B);\n    tree[B].push_back(A);\n  }\n  dfs(0, -1);\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <iostream>\n#include <cstdlib>\nusing namespace std ;\n\ntypedef unsigned long long ull ;\nconst int maxn =  1e5 + 10 ;\nconst ull base = 237 ;\n\nstruct Edge\n{\n    int to , next ;\n    Edge(){}\n    Edge( int t , int n ) : to( t ) , next( n ) {}\n}e[maxn * 2] ;\n\nint head[maxn] , len , n ;\n\nvoid init()\n{\n    memset( head , -1 , sizeof( head ) ) ;\n    len = 0 ;\n}\n\nvoid add( int u , int v )\n{\n    e[len] = Edge( v , head[u] ) ;\n    head[u] = len++ ;\n}\n\null _hash[maxn] ;\n\nvoid dfs( int u , int fa , int deep )\n{\n    ull cur = 0 ;\n    for( int i = head[u] ; ~i ; i = e[i].next )\n    {\n        int to = e[i].to ;\n        if( to == fa ) continue ;\n        dfs( to , u , deep + 1 ) ;\n        cur += _hash[to] ;\n    }\n\n    _hash[u] = cur * base + 1 ;\n}\n\n\nint main( )\n{\n\n\n\n    while( ~scanf( \"%d\" , &n ) )\n    {\n        init() ;\n\n        for( int i = 0 ; i < n - 1 ; ++i )\n        {\n            int u , v ;\n            scanf( \"%d %d\" , &u , &v ) ;\n            add( u , v ) ;\n            add( v , u ) ;\n        }\n        long long ans = 0 ;\n        dfs( 1 , 1 , 0 ) ;\n\n        sort( _hash + 1 , _hash + n + 1 ) ;\n        ull last = _hash[1] ;\n        int num = 0 ;\n        for( int i = 1 ; i <= n ; ++i )\n        {\n            if( _hash[i] == last )\n                ++num ;\n            else\n            {\n                ans += ( long long ) num * ( num - 1 ) / 2 ;\n                num = 1 ;\n                last = _hash[i] ;\n            }\n        }\n\n        printf( \"%I64d\" , ans ) ;\n    }\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\ntypedef vector<vector<int>> Graph;\nvector<ll> hashv(111111,0);\n\nll dfs(const Graph &tree, int node){\n    int sz=tree[node].size();\n    if(sz==0){\n        return hashv[node] = 1;\n        \n    }\n\n    ll tmp=0;\n    for(int i=0;i<sz;i++){\n        int next=tree[node][i];\n        tmp += dfs(tree,next);\n    }\n    tmp *= MOD;\n    tmp += 1;\n    return hashv[node] = tmp;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;cin>>n;\n    Graph tree(n);\n    for(int i=0;i<n-1;i++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        tree[a].push_back(b);\n    }\n    dfs(tree,0);\n    map<ll,ll> mp;\n    ll res=0;\n    for(int i=0;i<n;i++){\n        res += mp[hashv[i]];\n        mp[hashv[i]]++;\n    }\n    cout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\ntypedef long long int LL;\n\n\nvector<int >ve[N];\nmap< LL , int >ma;\nLL a[N];\nLL b=17;\nLL ans;\nvoid dfs(int u)\n{\n    a[u]=1;\n    for(int i=0;i<ve[u].size();i++)\n    {\n        int v=ve[u][i];\n        dfs(v);\n        a[u]+=a[v]*b;\n    }\n    ans+=ma[a[u]];\n    ma[a[u]]++;\n    return ;\n}\n\nint main()\n{\n    int n;\n        cin>>n;\n        int u,v;\n        for(int i=0;i<n-1;i++)\n        {\n            cin>>u>>v;\n            ve[u].push_back(v);\n        }\n        ans=0;\n        dfs(1);\n        cout<<ans<<endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\nconst int M = 1000000007;\n\nint r;\nvector<int> g[100005];\nmap<int,int> m;\n\nint dfs(int cur, vector<bool> used){\n\tused[cur] = true;\n\n\tint res = 0;\n\tfor(auto to : g[cur]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(to, used);\n\t\tres %= M;\n\t}\n\tres = res * r + 1;\n\tm[res]++;\n\treturn res;\n}\n\n\nsigned main(){\n\trandom_device rnd;\n\tmt19937 engine(rnd());\n\tuniform_int_distribution<> dist(M - 100, M - 1); //iranai\n\n\n\tint n;\n\tcin >> n;\n\trep(i,n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\n\tr = dist(engine);\n\tdfs(0, vector<bool>(n,0));\n\n\tint ans = 0;\n\tfor(auto i : m){\n\t\t//show(i.second)\n\t\tans += (i.second * (i.second - 1)) / 2;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Hash{\n\tHash(){\n\t\thash_value = 0;\n\t\tnum = 0;\n\t\tleft_child = right_child = -1;\n\t}\n\tull hash_value;\n\tint num,left_child,right_child;\n};\n\nclass HashTree{\npublic:\n\tHashTree(int size){\n\t\thash = new Hash[size];\n\t\tnum_of_node = 0;\n\t}\n\n\tvoid addHash(ull value){\n\t\tif(num_of_node == 0){\n\t\t\thash[0].hash_value = value;\n\t\t\thash[0].num = 1;\n\t\t\tnum_of_node++;\n\t\t\treturn;\n\t\t}else{\n\t\t\tint index = 0;\n\n\t\t\twhile(true){\n\t\t\t\tif(value == hash[index].hash_value){\n\t\t\t\t\thash[index].num++;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(value > hash[index].hash_value){\n\t\t\t\t\tif(hash[index].right_child == -1){\n\t\t\t\t\t\thash[index].right_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].right_child;\n\t\t\t\t\t}\n\t\t\t\t}else{ //value < hash[index].hash_value\n\t\t\t\t\tif(hash[index].left_child == -1){\n\t\t\t\t\t\thash[index].left_child = num_of_node;\n\t\t\t\t\t\thash[num_of_node].hash_value = value;\n\t\t\t\t\t\thash[num_of_node].num = 1;\n\t\t\t\t\t\tnum_of_node++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tindex = hash[index].left_child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull calc_ans(){\n\t\tull sum = 0;\n\n\t\tfor(int i = 0; i < num_of_node; i++){\n\t\t\tfor(int k = 1; k <= hash[i].num-1; k++){ //hash[i].numC2????¨????\n\t\t\t\t\tsum += k;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tHash* hash;\n\tint num_of_node;\n};\n\nstruct Node{\n\tvector<int> children;\n\tint parent;\n};\n\nNode* node;\nvector<ull> HashV;\n\nvector<int> calc(int node_id){\n\n\tvector<int> Ret;\n\tRet.push_back(node[node_id].children.size()); //node[node_id]??????????????±???1?????????????????°??????????????°??????????????????\n\n\tfor(int i = 0; i < node[node_id].children.size();i++){\n\t\tvector<int> tmp = calc(node[node_id].children[i]); //????????????vector?????°???\n\t\tfor(int k = 0; k < tmp.size(); k++){\n\t\t\tif(k+1 >= Ret.size()){ //?????????????????????????????????????????\\????????´?????????????¶???? size()???A?????????vector????????????????????????0???A-1\n\t\t\t\tRet.push_back(tmp[k]);\n\t\t\t}else{\n\t\t\t\tRet[k+1] += tmp[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tull pre = 0,current = 0;\n\n\tfor(int i = 0; i < Ret.size(); i++){\n\t\tcurrent = Ret[i] + pre*MOD;\n\t\tpre = current;\n\t}\n\tHashV.push_back(current);\n\n\treturn Ret;\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tnode = (Node*)malloc(sizeof(Node)*(N+1));\n\tHashTree HT(N);\n\n\tint parent,child;\n\tfor(int i = 0; i < N-1; i++){\n\t\tscanf(\"%d %d\",&parent,&child);\n\t\tnode[parent].children.push_back(child);\n\t\tnode[child].parent = parent;\n\t}\n\n\t//?????????????????????????????±?????¨????????°????¨???????????????£??????\n\tcalc(1);\n\n\tfor(int i = 0; i < HashV.size();i++){\n\t\tHT.addHash(HashV[i]);\n\t}\n\n\n\tprintf(\"%lld\\n\",HT.calc_ans());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint b=21387612863821,n,a,c,ans;\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res+=dfs(v[x][i]);\n  res*=b;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst ll M = 1e9+7;\nconst ll K = 19237;\nvector<int> e[N];\nmap<ll,int>hs;\nmap<ll,int>::iterator it;\nll dfs(int u){\n  ll ret = 0;\n  for(auto& v: e[u])\n    ret = (ret+K*(1+dfs(v)))%M;\n  ++hs[ret];\n  return ret;\n}\nint main()\n{\n  int n, u , v; scanf(\"%d\", &n);\n  for(int i = 1; i < n; i++){\n    scanf(\"%d%d\", &u, &v);\n    e[u].push_back(v);\n  }\n  dfs(1);\n  ll ans = 0;\n  for(it = hs.begin(); it!=hs.end(); ++it) ans += (it->second)*(it->second-1)/2;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define read() freopen(\"input.txt\", \"r\", stdin)\n\n#define ll64 long long\n#define BASE 100000007\n#define MOD 100000073\n\nll64 BP[300010];\nbool visited[100010];\nvector<int> graph[100010];\nmap<ll64, ll64> C_M;\n\nvoid dfs(int u, map<int, int>& PM)\n{\n    map<int, int> M;\n    visited[u] = true;\n    for(auto v: graph[u]){\n        if(!visited[v]){\n            dfs(v, M);\n        }\n    }\n    M[0] += 1;\n    ll64 hsh = 0;\n    for(auto &it: M){\n        PM[it.first + 1] += it.second;\n        hsh += (it.first * BP[it.second]) % MOD;\n        hsh %= MOD;\n    }\n    C_M[hsh] += 1;\n}\n\nint main()\n{\n    //read();\n    ll64 temp = 1;\n    for(int i = 0; i < 200000; i++){\n        BP[i] = temp;\n        temp = (temp * BASE) % MOD;\n    }\n    map<int, int> tempM;\n    int N;\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N - 1; i++){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    dfs(1, tempM);\n    ll64 ans = 0;\n    for(auto &it: C_M){\n        ll64 x = it.second;\n        ans += (x * (x - 1)) / 2;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\ntypedef unsigned long long ull;\null B=5575777;\null ans=0;\nint n,a,b;\nvector<int> G[MAX_N];\nunordered_map<ull,ull> mp;\n\null dfs(int pos){\n  ull res=0;\n  for(int to:G[pos])res+=dfs(to);\n  res=res*B+1;\n  ans+=mp[res];\n  mp[res]++;\n  return res;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  for(int i=0;i<n-1;i++){\n    scanf(\"%d %d\",&a,&b);\n    G[a].push_back(b);\n  }\n  dfs(1);\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define read() freopen(\"input.txt\", \"r\", stdin)\n\n#define ll64 long long\n#define BASE 100000007\n#define MOD 100000037\n\nll64 BP[300010];\nbool visited[100010];\nvector<int> graph[100010];\nmap<ll64, ll64> C_M;\nmap<map<int, int>, int> M_M;\n\nvoid dfs(int u, map<int, int>& PM)\n{\n    map<int, int> M;\n    visited[u] = true;\n    for(auto v: graph[u]){\n        if(!visited[v]){\n            dfs(v, M);\n        }\n    }\n    M[0] += 1;\n    ll64 hsh = 0;\n    for(auto &it: M){\n        PM[it.first + 1] += it.second;\n        hsh += (it.first * BP[it.second]) % MOD;\n        hsh %= MOD;\n    }\n    C_M[hsh] += 1;\n    M_M[M] += 1;\n}\n\nint main()\n{\n    //read();\n    ll64 temp = 1;\n    for(int i = 0; i < 200000; i++){\n        BP[i] = temp;\n        temp = (temp * BASE) % MOD;\n    }\n    map<int, int> tempM;\n    int N;\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N - 1; i++){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    dfs(1, tempM);\n    ll64 ans = 0;\n    for(auto &it: M_M){\n        ll64 x = it.second;\n        ans += (x * (x - 1)) / 2;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\nusing namespace std;\n\n\nconst int mod=1e9+7;\nconst int maxn=1e6+10;\n#define mem(a,b) memset(a,b,sizeof(a))\n#define uLL unsigned long long\n\nmap<uLL,uLL> mp;\nvector<int> g[maxn];\n\nuLL d[maxn];\nuLL ans;\nint n;\n\nint head[maxn],cntroad;\nstruct Edge {\n    Edge(int V = 0,int N = 0):v(V),Next(N) {}\n    int v,Next;\n}road[maxn<<1];\nvoid addedge(int u,int v) {road[cntroad] = Edge(v,head[u]); head[u] = cntroad++;}\nvoid dfs(int u,int fa)\n{\n    d[u]=1;\n    for(int i = head[u]; i != -1; i = road[i].Next)\n    {\n        int v=road[i].v;\n        if(v==fa)continue;\n        dfs(v,u);\n        d[u]+=d[v]*mod;\n    }\n    mp[d[u]]++;\n}\nint main()\n{\n    while(~scanf(\"%d\",&n))\n    {\n        mem(head,-1);\n        cntroad = 0;\n        mp.clear();\n        ans=0;\n        for(int i=1;i<n;i++)\n        {\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            addedge(u,v);\n            addedge(v,u);\n        }\n\n        dfs(1,0);\n        for(map<uLL,uLL>::iterator it=mp.begin(); it!=mp.end(); it++)\n            ans+=(uLL)it->second*(it->second-1)/2;\n        cout << ans;printf(\"\\n\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define MOD 100000000000009LL\n#define MAX_N 100010\ntypedef unsigned long long ull;\nvector<ull>x[MAX_N], y[MAX_N]; vector<int>G;\null dp[MAX_N]; queue<ull>Q; ull r[MAX_N];\nbool used[MAX_N];\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n - 1; i++) { int a, b; cin >> a >> b; y[a].push_back(b); y[b].push_back(a); }\n\tQ.push(1LL); used[1] = true;\n\twhile (!Q.empty()) {\n\t\tull a1 = Q.front(); Q.pop(); G.push_back(a1);\n\t\tfor (int i = 0; i < (int)y[a1].size(); i++) {\n\t\t\tif (used[y[a1][i]] == false) { used[y[a1][i]] = true; Q.push(y[a1][i]); }\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)G.size(); i++)r[G[i]] = i + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (int)y[i].size(); j++) {\n\t\t\tx[r[i]].push_back(r[y[i][j]]);\n\t\t}\n\t}\n\tfor (int i = n; i >= 1; i--) {\n\t\tull sum = 0; int cnt2 = 0;\n\t\tfor (int j = 0; j < (int)x[i].size(); j++) {\n\t\t\tif (i > x[i][j])continue;\n\t\t\tsum += dp[x[i][j]]; sum %= MOD; cnt2++;\n\t\t}\n\t\tdp[i] = (sum * 100009ULL + 1) % MOD;\n\t}\n\tsort(dp + 1, dp + n + 1); ull cnt = 0, cnt2 = 0;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tif (dp[i - 1] != dp[i]) { cnt += cnt2*(cnt2 - 1) / 2; cnt2 = 1; }\n\t\telse { cnt2++; }\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\nusing ll = long long int;\n\nconst ll P = 1013;\nconst ll MOD = 1000000007;\n\nint N;\nll hash_tab[100010];\nmap<ll, int> cnt;\nvector<int> G[100010];\n\nvoid dfs(int cur, int par=-1) {\n  for(auto to : G[cur]) {\n    if(to == par) continue;\n    dfs(to, cur);\n    (hash_tab[cur] += hash_tab[to]) %= MOD;\n  }\n  (hash_tab[cur] *= P) %= MOD;\n  (hash_tab[cur] += 1) %= MOD;\n  cnt[ hash_tab[cur] ]++;\n}\n\nint main() {\n  cin >> N;\n  for(int i=0; i<N-1; i++) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  dfs(0);\n  ll ans = 0;\n  for(auto x : cnt) {\n    ll tmp = x.second;\n    ans += tmp * (tmp - 1) / 2;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int mod=1e9+7;\nconst int N=1e5+5;\nint dep[N],hd;\nstruct node{\n\tint v,nxt;\n}p[N];\nint head[N],son[N],tot;\null a[N],p2[N],p3[N],b[N];\nvoid add(int x,int y){\n\tp[tot].v=y;\n\tp[tot].nxt=head[x];\n\thead[x]=tot++;\n}\nvoid init(){\n\ttot=0;\n\tp3[0]=p2[0]=1;\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<N;i++){\n\t\tp2[i]=2*p2[i-1];\n\t\tp3[i]=2*p3[i-1];\n\t}\n}\nmap<pair<ull,ull>,int>mp;\nmap<pair<ull,ull>,int>::iterator it;\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];~i;i=p[i].nxt){\n\t\tint y=p[i].v;\n\t\tif(y==fa)\n\t\t\tcontinue;\n\t\tdfs(y,x);\n\t\tdep[x]=max(dep[y],dep[x]);\n\t}\n\tfor(int i=head[x];~i;i=p[i].nxt){\n\t\tint y=p[i].v;\n\t\tif(y==fa)\n\t\t\tcontinue;\n\t\ta[x]=a[x]+a[y]*p2[dep[x]-dep[y]];\n\t\tb[x]=b[x]+b[y]*p2[dep[x]-dep[y]];\n\t}\n\tdep[x]++;\n\ta[x]=a[x]+p2[dep[x]];\n\tb[x]=b[x]+p2[dep[x]];\n\t//cout<<x<<' '<<a[x]<<' '<<dep[x]<<endl;\n\tmp[make_pair(b[x],a[x])]++;\n\thd++;\n}\nint main(){\n\tinit();\n\tint n,x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdfs(1,0);\n\tll ans=0;\n\tfor(it=mp.begin();it!=mp.end();it++){\n\t\tint t=it->second;\n\t\t//cout<<t<<endl;\n\t\tans+=1ll*t*(t-1)/2;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <map>\n\n#define MAXN 100005\n\nusing namespace std;\n\nstruct edge\n{\n\tint y,next;\n};\n\nedge v[2*MAXN];\nint head[MAXN];\nint tot = 0;\nlong long ans = 0;\nmap<unsigned long long,int> S;\n\nvoid add(int x,int y)\n{\n\ttot++;\n\tv[tot].y = y;\n\tv[tot].next = head[x];\n\thead[x] = tot;\n}\n\nunsigned long long dfs(int x,int fa)\n{\n\tunsigned long long temp = 1;\n\tfor (int i=head[x];i;i=v[i].next)\n\t{\n\t\tif (v[i].y == fa) continue;\n\t\ttemp += 131*dfs(v[i].y,x);\n\t}\n\tans += S[temp];\n\tS[temp]++;\n\treturn temp;\n}\n\nint main()\n{\n\tint x,y,n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\n\tS.clear();\n\tans = 0;\n\tdfs(1,0);\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef unsigned long long ull;\nint n,a,c;\null b=21387612863821;\null ans;\nmap<ull,ull>m;\nvector<int>v[100009];\null dfs(int x){\n  ull res=1;\n  r(i,v[x].size()) res*=dfs(v[x][i]);\n  res*=b;\n  //cout<<x<<' '<<m[res]<<endl;\n  ans+=m[res]++;\n  return res;\n}\nsigned main(){\n  cin>>n;\n  r(i,n-1){\n    cin>>a>>c;\n    v[a].push_back(c);\n  }\n  dfs(1);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long; using ll = LL;\nusing PLL = pair<LL, LL>; using pll = PLL;\nusing PII = pair<int, int>; using pii = PII;\nconst int INF = 1e9; const LL LINF = 1e18;\n#define SZ(a) (int)a.size()\n#define FOR(i,s,t) for(int i= s; i<t;i++)\n#define ALL(a) a.begin(),a.end()\nusing VL = vector<LL>; using VVL = vector<VL>;\nconst LL mod = 1000000007;\nusing ukuku = unsigned long long;\nmap<ukuku, int>Map;\n#define debug(x) cout<<#x<<\":=\"<<x<<endl;\nukuku dfs(int v, const VVL& G) {\n\tukuku ret = 5;\n\tFOR(i, 0, SZ(G[v])) {\n\t\tint nx = G[v][i];\n\t\tret += dfs(nx, G)*mod;\n\t}\n\tMap[ret]++;\n\treturn ret;\n}\n\nvoid solve() {\n\tint N;\n\tcin >> N;\n\tVVL G(N);\n\tFOR(i, 0, N - 1) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--, b--;\n\t\tG[a].push_back(b);\n\t}\n\tdfs(0,G);\n\tLL ans = 0;\n\tfor (auto it : Map) {\n\t\tans += (it.second)*(it.second-1) / 2;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\nstd::map<int,std::vector<int>>v;\nstd::map<int,int>m;\nlong long r;\nint d(int i,int p){\n\tint h=1;\n\tfor(int c:v[i])if(c-p)h=(h+997LL*d(c,i))%1000000007;\n\tr+=m[h]++;\n\treturn h;\n}\nint main(){\n\tint N,a,b;\n\tfor(scanf(\"%d\",&N);--N;)scanf(\"%d%d\",&a,&b),v[a].push_back(b),v[b].push_back(a);\n\td(1,0);\n\tprintf(\"%lld\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<cmath>\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nconst ll base = 1e5+7;\nconst int maxn = 1e5+5;\nint n,ind[maxn];\nvector<ll> htable;\nvector<int> G[maxn];\n\nll dfs(int u)\n{\n    ll temp = 0;\n    for(int i=0;i<G[u].size();++i){\n        temp += dfs(G[u][i]);\n    }\n    htable.push_back(temp*base+G[u].size());\n    return temp*base+G[u].size();\n}\n\ninline ll work(ll m)\n{\n    return m*(m-1)>>1;\n}\n\nint main()\n{\n        scanf(\"%d\",&n);\n    {\n        htable.clear();\n        memset(ind,0,sizeof ind);\n        for(int i=0;i<n-1;++i){\n            int u,v; scanf(\"%d%d\",&u,&v);\n            G[u].push_back(v);\n            ++ind[v];\n        }\n        int s = 0;\n        for(int i=1;i<=n && !s;++i){\n            if(ind[i] == 0) s = i;\n        }\n        dfs(s);\n        sort(htable.begin(),htable.end());\n        ll num = 1;\n        ll ans = 0;\n        for(int i=1;i<htable.size();++i){\n            if(htable[i] != htable[i-1]){\n                ans += work(num);\n                num = 1;\n            }\n            else ++num;\n        }\n        if(htable.size() > 1 && htable[htable.size()-1] != htable[htable.size()-2]) ans += work(num);\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint D = 9901;\n\nstruct Hash{\n    Hash(){\n        hash_value = 0;\n        num = 0;\n        left_child = right_child = -1;\n    }\n    ull hash_value;\n    ull num,left_child,right_child;\n};\n\nstruct HashTree{\npublic:\n    void init(int size){\n        hash = new Hash[size];\n        num_of_node = 0;\n    }\n\n    void addHash(ull value){\n        if(num_of_node == 0){\n            hash[0].hash_value = value;\n            hash[0].num = 1;\n            num_of_node++;\n            return;\n        }else{\n            int index = 0;\n\n            while(true){\n                if(value == hash[index].hash_value){\n                    hash[index].num++;\n                    return;\n                }else if(value > hash[index].hash_value){\n                    if(hash[index].right_child == -1){\n                        hash[index].right_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].right_child;\n                    }\n                }else{ //value < hash[index].hash_value\n                    if(hash[index].left_child == -1){\n                        hash[index].left_child = num_of_node;\n                        hash[num_of_node].hash_value = value;\n                        hash[num_of_node].num = 1;\n                        num_of_node++;\n                        return;\n                    }else{\n                        index = hash[index].left_child;\n                    }\n                }\n            }\n        }\n    }\n\n    ull calc_ans(){\n        ull sum = 0;\n\n        for(int i = 0; i < num_of_node; i++){\n        \tsum += (hash[i].num)*(hash[i].num-1)/2;\n        }\n        return sum;\n    }\n\n    Hash* hash;\n    int num_of_node;\n};\n\nstruct Node{\n    vector<int> children;\n    int parent;\n};\n\nNode* node;\nHashTree HT;\n\null calc(int node_id){\n\n    ull Ret = 1;\n    ull child;\n\n    for(int i = 0; i < node[node_id].children.size();i++){\n        child = calc(node[node_id].children[i]);\n        Ret = (Ret+child*D)%MOD;\n    }\n\n    HT.addHash(Ret);\n\n    return Ret;\n}\n\nint main(){\n\n    int N;\n    scanf(\"%d\",&N);\n\n    node = (Node*)malloc(sizeof(Node)*(N+1));\n    HT.init(N);\n\n    int parent,child;\n    for(int i = 0; i < N-1; i++){\n        scanf(\"%d %d\",&parent,&child);\n        node[parent].children.push_back(child);\n        node[child].parent = parent;\n    }\n\n    calc(1);\n\n    printf(\"%lld\\n\",HT.calc_ans());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<cstdio>\n#include<map>\n#define MAXN 100010\n#define MOD 100000000\nusing namespace std;\n\nvector<int> G[MAXN];\nint n;\nint d[MAXN];\nint cnt[MOD];\nint vis[MAXN];\n\nvoid dfs(int u)\n{\n\td[u]=1;\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tfor(int i=0;i!=G[u].size();++i)\n\t{\n\t\tint v=G[u][i];\n\t\tdfs(v);\n\t\td[u]=(d[u]+d[v]*2)%MOD;\n\t\tcnt[d[u]]++;\n\t}\n}\n\nint main()\n{\n\tmemset(d,0,sizeof(d));\n\tmemset(vis,0,sizeof(vis));\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i!=n-1;++i)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tG[u].push_back(v);\n\t}\n\tdfs(1);\n\tlong long ans=0;\n\tfor(int i=0;i!=MOD;++i)\n\t{\n\t\tif(cnt[i])\n\t\t\tans+=(long long)cnt[i]*cnt[i-1]/2;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100009\n#define ll long long\nint N;\nint depth[maxn];\nstruct node{\n    int x,y;\n    int next;\n}line[maxn*4];\nint tot,head[maxn];\nll ans=0;\nvoid insert(int x,int y)\n{\n    tot++;line[tot].x=x;line[tot].y=y;\n    line[tot].next=head[x];\n    head[x]=tot;\n}\nll Hash[maxn];\nll p=1000000007;\nll mod=998244353;\nmap<ll,ll>Map;\nmap<ll,ll>::iterator it;\nvoid dfs(int u,int fa)\n{\n    int k;\n    depth[u]=depth[fa]+1;\n    Hash[u]=1;\n    for(k=head[u];k;k=line[k].next)\n    {\n        if(line[k].y==fa)continue;\n        dfs(line[k].y,u);\n        Hash[u]=(Hash[u]+Hash[line[k].y]*p)%mod;\n    }\n    Map[Hash[u]]++;\n}\nint main()\n{\n    while(scanf(\"%d\",&N)!=EOF)\n    {\n        int i,j,k;\n        int a,b;\n        for(i=1;i<N;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            insert(a,b);\n        }\n        dfs(1,0);\n        ans=0;\n        for(it=Map.begin();it!=Map.end();it++)\n        {\n            ll p=it->second;\n            ans+=p*(p-1)/2;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\nusing namespace std;\ntypedef unsigned long long LL;\nconst LL maxn=1e6+10,p=7,mod=1e9+7;\nvector<LL>G[maxn];\nLL hash_v[maxn];\nmap<LL,LL>mp;\nmap<LL,LL>::iterator it;\n\nvoid dfs(LL u)\n{\n    hash_v[u]=1;\n    for(LL i=0; i<G[u].size(); i++)\n    {\n        LL v=G[u][i];\n        dfs(v);\n        hash_v[u]=(hash_v[u]+hash_v[v]*p)%mod;\n    }\n    mp[hash_v[u]]++;\n}\nint main()\n{\n   ///freopen(\"in.txt\",\"r\",stdin);\n    LL n;\n    LL u,v;\n    while(scanf(\"%lld\",&n)!=-1)\n    {\n        for(LL i=0; i<=n; i++)\n        G[i].clear();\n        mp.clear();\n        for(LL i=1; i<n; i++)\n        {\n            scanf(\"%lld%lld\",&u,&v);\n            G[u].push_back(v);\n        }\n        dfs(1);\n        LL ans=0;\n        for(it=mp.begin(); it!=mp.end(); it++)\n            ans+=it->second*(it->second-1)/2;\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\ntypedef unsigned long long ull;\null B=5575777;\null ans=0;\nint n,a,b;\nvector<int> G[MAX_N];\nunordered_map<ull,ull> mp;\n\null dfs(int pos){\n  ull res=0;\n  for(int to:G[pos])res+=dfs(to);\n  res=res*B+1;\n  ans+=mp[res]++;\n  return res;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  for(int i=0;i<n-1;i++){\n    scanf(\"%d %d\",&a,&b);\n    G[a].push_back(b);\n  }\n  dfs(1);\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\nconst int M = 1000000007;\n\nint r;\nvector<int> g[100005];\nmap<int,int> m;\n\nint dfs(int cur){\n\n\tint res = 0;\n\tfor(auto to : g[cur]){\n\t\tres += dfs(to);\n\t\tres %= M;\n\t}\n\tres = res * r + 1;\n\tres %= M;\n\tm[res]++;\n\treturn res;\n}\n\n\nsigned main(){\n\tint n;\n\tcin >> n;\n\trep(i,n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t}\n\n\tr = 8731873;\n\tdfs(0);\n\n\tint ans = 0;\n\tfor(auto i : m){\n\t\t//show(i.second)\n\t\tans += (i.second * (i.second - 1)) / 2;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//nupt2017team08\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\nusing namespace std;\n#define INF 0x3f3f3f3f\ntypedef long long ll;\nconst ll mod = 1e9+7;\nconst ll p = 11777;\nconst int MAXN=1e5+10;\nstruct edge\n{\n    int v;\n    edge(int vv)\n    {\n        v=vv;\n    }\n};\nvector<edge>E[MAXN];\nint val[MAXN];\nmap<ll,int>mp;\nvoid addedge(int x,int y)\n{\n    E[x].push_back(y);\n}\nvoid dfs(int k)\n{\n    val[k]=p;\n    for(int i=0;i<E[k].size();i++)\n    {\n        int v=E[k][i].v;\n        dfs(v);\n        val[k]+=(val[v]*p)%mod;\n        val[k]%=mod;\n    }\n    mp[val[k]]++;\n}\nll cal(int t)\n{\n    ll ans=0;\n    for(int i=1;i<=t;i++)\n        ans+=i;\n    return ans;\n}\nint n,x,y;\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n-1;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        addedge(x,y);\n    }\n    dfs(1);\n    ll ans=0;\n    for(map<ll,int>::iterator iter=mp.begin();iter!=mp.end();iter++)\n    {\n        ans+=cal(iter->second-1);\n    }\n    printf(\"%I64d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6+10;\nvector<int>g[maxn];\nint depth[maxn];\nlong long cnt[maxn];\nvoid dfs(int s)\n{\n\tfor(int i=0;i<g[s].size();i++)\n\t{\n\t\tdepth[g[s][i]] = depth[s]+1;\n\t\tdfs(g[s][i]);\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint a,b;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[a].push_back(b);\n\t}\n\tdepth[1] = 0;\n\tdfs(1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnt[depth[i]]++;\n\t}\n\tlong long ans = 0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\n\t\tlong long tmp = cnt[i]*(cnt[i]-1);\n\t\ttmp/=2;\n\t\tans+=tmp;\n\t}\n\tcout<<ans<<endl;\n\treturn 0; \n } "
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(...) cerr<<\"[\"<<#__VA_ARGS__\":\"<<(__VA_ARGS__)<<\"]\"<<endl;\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<double,int> PII;\nconst ll p=998244353;\nconst ll mod=1e9+7;\nconst int maxn=1e5+100;\nmap<ll,int> mp;\n\nstruct node\n{\n    int to,next;\n}e[maxn*2];\n\nint tol=0;\nint head[maxn];\nvoid add(int u,int v)\n{\n    e[++tol].to=v,e[tol].next=head[u],head[u]=tol;\n}\nll dfs(int u,int f)\n{\n    ll ans=1;\n    for(int i=head[u];i;i=e[i].next)\n    {\n        int v=e[i].to;\n        if(v==f) continue;\n        ans=(ans+dfs(v,u)*mod%p)%p;\n    }\n    mp[ans]++;\n    return ans;\n}\n\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    rep(i,1,n)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        add(u,v),add(v,u);\n    }\n    mp.clear();\n    dfs(1,0);\n    ll ans=0;\n    map<ll,int>::iterator it;\n    for(it=mp.begin();it!=mp.end();it++) ans+=1ll*(it->se)*(it->se-1)/2;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar a[99999];\nint main(){\n\tint n,s=0,x=1,i;\n\tfor(scanf(\"%d\",&n);s<n;x++)s+=x;\n\tmemset(a,')',--x);\n\tmemset(a+x,'(',x);\n\ti=a[x],a[x]=a[x-s+n],a[x-s+n]=i;\n\t*a=!puts(a);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2784 Similarity of Subtrees\n// 2018.4.15 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 数値のハッシュ関数\n#define HASHSIZ 500009\ntypedef struct { unsigned long long id; int c; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\nint  many;\n\nvoid insert(unsigned long long id)\n{\n\tHASH *p = hash + (int)(id % HASHSIZ);\n\twhile (p->id) {\n\t\tif (p->id == id) { many = 1, p->c++; return; }\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->id = id, p->c = 1;\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define M   1000000007\n#define MAX 100002\nint hi[MAX], *to[MAX];\n\nlong long dfs(int node)\n{\n\tint i;\n\tunsigned long long ans;\n\t\n\tans = 1;\n\tfor (i = 0; i < hi[node]; i++) ans += (long long)dfs(to[node][i]) * M;\n\tinsert(ans);\n\treturn ans;\n}\n\nint main()\n{\n\tint N, a, b, i, j;\n\tlong long ans;\n\tint *memo;\n\n\tN = in();\n\tmemo = malloc(N<<3);\n\tj = 0; for (i = 1; i < N; i++) {\n\t\tmemo[j++] = a = in(), memo[j++] = b = in();\n\t\thi[a]++;\n\t}\n\tfor (i = 1; i <= N; i++) if (hi[i]) to[i] = malloc(hi[i]<<2);\n\tmemset(hi, 0, N<<2);\n\tj = 0; for (i = 1; i < N; i++) {\n\t\ta = memo[j++], b = memo[j++];\n\t\tto[a][hi[a]++] = b;\n\t}\n\n\tdfs(1);\n\n\tans = 0;\n\tif (many) for (i = 0; i < HASHSIZ; i++) {\n\t\tif ((j = hash[i].c) > 1) ans += (long long)j*(j-1) >> 1;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2784 Similarity of Subtrees\n// 2018.4.15 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 数値のハッシュ関数\n#define HASHSIZ 500009\ntypedef struct { unsigned long long id; int c; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n\nvoid insert(unsigned long long id)\n{\n\tHASH *p = hash + (int)(id % HASHSIZ);\n\twhile (p->id) {\n\t\tif (p->id == id) { p->c++; return; }\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->id = id, p->c = 1;\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define M   1000000007\n#define MAX 100002\nint hi[MAX], *to[MAX];\n\nlong long dfs(int node)\n{\n\tint i;\n\tunsigned long long ans;\n\t\n\tans = 1;\n\tfor (i = 0; i < hi[node]; i++) ans += (long long)dfs(to[node][i]) * M;\n\tinsert(ans);\n\treturn ans;\n}\n\nint main()\n{\n\tint N, a, b, i, j;\n\tlong long ans;\n\tint *memo;\n\n\tN = in();\n\tmemo = malloc(N<<3);\n\tj = 0; for (i = 1; i < N; i++) {\n\t\tmemo[j++] = a = in(), memo[j++] = b = in();\n\t\thi[a]++;\n\t}\n\tfor (i = 1; i <= N; i++) if (hi[i]) to[i] = malloc(hi[i]<<2);\n\tmemset(hi, 0, N<<2);\n\tj = 0; for (i = 1; i < N; i++) {\n\t\ta = memo[j++], b = memo[j++];\n\t\tto[a][hi[a]++] = b;\n\t}\n\n\tdfs(1);\n\n\tans = 0;\n\tfor (i = 0; i < HASHSIZ; i++) {\n\t\tif (j = hash[i].c) ans += (long long)j*(j-1) >> 1;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar a[99999];\nint main(){\n\tint n,s=0,x=1,i;\n\tfor(scanf(\"%d\",&n);s<n;x++)s+=x;\n\tmemset(a,')',--x);\n\tmemset(a+x,'(',x);\n\ti=a[x],a[x]=a[x-s+n],a[x-s+n]=i;\n\tputs(a);\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing P = System.Numerics.Complex;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var G = Enumerate(n, x => new List<int>());\n\n            for (int i = 0; i < n - 1; i++)\n            {\n                var a = ri - 1; var b = ri - 1;\n                G[a].Add(b); G[b].Add(a);\n            }\n            var c = (int)1e9 + 7;\n            const long M = (long)1e18 + 3;\n            var dic = new Dictionary<BigInteger, int>();\n            Func<int, int, BigInteger> dfs = null;\n            dfs = (prev, cur) =>\n            {\n                BigInteger ret = 1;\n\n                foreach (var to in G[cur])\n                    if (prev != to) ret += c * dfs(cur, to);\n                if (dic.ContainsKey(ret)) dic[ret]++;\n                else dic[ret] = 1;\n                ret %= M;\n                return ret;\n            };\n            dfs(-1, 0);\n            long ans = 0;\n            foreach (var kv in dic)\n            {\n                ans += 1L * kv.Value * (kv.Value - 1) / 2;\n            }\n            Console.WriteLine(ans);\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n"
  },
  {
    "language": "Ruby",
    "code": "class List\n    def initialize(val)\n        @val = val\n        @next = nil\n        @code = nil\n    end\n\n    def merge(other)\n        return self if !other\n        new_head = self.class.new(@val + other.val)\n        if @next\n            new_head.next = @next.merge(other.next)\n        else\n            new_head.next = other.next\n        end\n        new_head\n    end\n\n    def encode\n        return @val.to_s if !@next\n        @code ||= @val.to_s + \",\" + @next.encode\n    end\n\n    attr_accessor :next\n    attr_reader :val\nend\n\nrequire 'tsort'\n\nclass Hash\n    include TSort\n    alias tsort_each_node each_key\n\n    def tsort_each_child(u)\n        self[u].each do |v|\n            yield v\n        end\n    end\nend\n\nn = gets.to_i\ng = {}\n(1..n).map {|v| g[v] = []}\n\n(n-1).times do\n    u, v = gets.split.map(&:to_i)\n    g[u] << v\nend\n\nhead = {}\ng.tsort.each do |u|\n    l = List.new(1)\n    if !g[u].empty?\n        merged = g[u].map {|v| head[v]}.inject {|m, l| m.merge(l)}\n        l.next = merged\n    end\n    head[u] = l\nend\n\ngroup = Hash.new(0)\n(1..n).each do |u|\n    group[head[u].encode] += 1\nend\np group.each_value.map {|k| k * (k-1)/2}.inject(:+)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\n\nMOD = 10 ** 30 + 7\n\nN = input()\nE = [[] for i in range(N)]\n\nfor i in range(N - 1):\n    a, b = map(int, raw_input().split())\n    a -= 1\n    b -= 1\n    E[a].append(b)\n    E[b].append(a)\n\nm = {}\n\ndef func(num, pre):\n    S = 0\n    for to in E[num]:\n        if to != pre:\n            S += func(to, num)\n    S *= 1000000007\n    S += 1\n    S %= MOD\n    if not S in m:\n        m[S] = 1\n    else:\n        m[S] += 1\n    return S\n\nfunc(0, -1)\n\nans = 0\nfor key in m:\n    ans += m[key] * (m[key] - 1) / 2\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\nimport sys\ndef main():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    N = int(readline())\n    G = [[] for i in range(N)]\n    for i in range(N-1):\n        a, b = map(int, readline().split()); a -= 1; b -= 1\n        G[a].append(b)\n        G[b].append(a)\n\n    H = [-1]*N\n    MOD = 10**9 + 9\n    X1 = [0]*N; v1 = 13\n    X2 = [0]*N; v2 = 17\n    U = [0]*N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]; su2 += X2[w]\n        H[v] = k = h+1\n        X1[v] = w1 = (su1*v1 + 1) % MOD\n        X2[v] = w2 = (su2*v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v*(v-1)//2\n    write(\"%d\\n\" % ans)\nmain()\n"
  }
]