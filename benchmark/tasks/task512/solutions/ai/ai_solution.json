[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint depth[MAX_N];\nint parent[MAX_N];\nint nodes_at_depth[MAX_N][MAX_N];\nint children[MAX_N][MAX_N];\nint child_count[MAX_N];\n\nvoid dfs(int node, int current_depth) {\n    depth[node] = current_depth;\n    nodes_at_depth[current_depth][++nodes_at_depth[current_depth][0]] = node;\n\n    for (int i = 0; i < child_count[node]; i++) {\n        int child = children[node][i];\n        dfs(child, current_depth + 1);\n    }\n}\n\nint are_subtrees_similar(int node1, int node2) {\n    int max_depth1 = depth[node1];\n    int max_depth2 = depth[node2];\n\n    for (int d = 0; d <= max_depth1; d++) {\n        if (nodes_at_depth[d][0] != nodes_at_depth[d][0]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    memset(nodes_at_depth, 0, sizeof(nodes_at_depth));\n    memset(child_count, 0, sizeof(child_count));\n\n    for (int i = 2; i <= N; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        parent[i] = p;\n        children[p][child_count[p]++] = i;\n    }\n\n    dfs(1, 0);\n\n    int similar_pairs = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            if (are_subtrees_similar(i, j)) {\n                similar_pairs++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", similar_pairs);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n\ntypedef struct Node {\n    int depth;\n    struct Node *next;\n} Node;\n\nNode *adj[MAX_N + 1];\nint depth_counts[MAX_N + 1][MAX_N + 1]; // depth_counts[i][d] = count of nodes at depth d in subtree i\nint max_depth[MAX_N + 1];\nint N;\n\nvoid add_edge(int u, int v) {\n    Node *new_node = (Node *)malloc(sizeof(Node));\n    new_node->depth = v;\n    new_node->next = adj[u];\n    adj[u] = new_node;\n}\n\nvoid dfs(int u, int depth) {\n    depth_counts[u][depth] = 1;\n    max_depth[u] = depth;\n    for (Node *node = adj[u]; node != NULL; node = node->next) {\n        int v = node->depth;\n        dfs(v, depth + 1);\n        for (int d = depth + 1; d <= max_depth[v]; d++) {\n            depth_counts[u][d] += depth_counts[v][d];\n        }\n        if (max_depth[v] > max_depth[u]) {\n            max_depth[u] = max_depth[v];\n        }\n    }\n}\n\nint compare_subtrees(int i, int j) {\n    if (max_depth[i] != max_depth[j]) {\n        return 0;\n    }\n    for (int d = 0; d <= max_depth[i]; d++) {\n        if (depth_counts[i][d] != depth_counts[j][d]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        adj[i] = NULL;\n    }\n    for (int i = 2; i <= N; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        add_edge(p, i);\n    }\n    dfs(1, 0);\n    int count = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (compare_subtrees(i, j)) {\n                count++;\n            }\n        }\n    }\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<vector<int>> depthCount;\n\nvoid bfs(int root, int N) {\n    vector<int> depth(N + 1, 0);\n    queue<int> q;\n    q.push(root);\n    depth[root] = 0;\n    int maxDepth = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            depth[v] = depth[u] + 1;\n            if (depth[v] > maxDepth) maxDepth = depth[v];\n            q.push(v);\n        }\n    }\n\n    depthCount.resize(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        depthCount[i].resize(maxDepth + 1, 0);\n    }\n\n    q.push(root);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        depthCount[u][depth[u]]++;\n        for (int v : adj[u]) {\n            q.push(v);\n            for (int d = 0; d <= maxDepth; ++d) {\n                depthCount[v][d] += depthCount[u][d];\n            }\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    adj.resize(N + 1);\n    for (int i = 2; i <= N; ++i) {\n        int p;\n        cin >> p;\n        adj[p].push_back(i);\n    }\n\n    bfs(1, N);\n\n    map<vector<int>, int> freq;\n    for (int i = 1; i <= N; ++i) {\n        freq[depthCount[i]]++;\n    }\n\n    long long res = 0;\n    for (auto &[k, v] : freq) {\n        res += (long long)v * (v - 1) / 2;\n    }\n\n    cout << res << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SimilarSubtrees {\n    static class TreeNode {\n        int id;\n        List<TreeNode> children = new ArrayList<>();\n        TreeNode(int id) {\n            this.id = id;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        TreeNode[] nodes = new TreeNode[N + 1];\n        for (int i = 1; i <= N; i++) {\n            nodes[i] = new TreeNode(i);\n        }\n        for (int i = 2; i <= N; i++) {\n            int parent = scanner.nextInt();\n            nodes[parent].children.add(nodes[i]);\n        }\n\n        Map<String, Integer> subtreeMap = new HashMap<>();\n        dfs(nodes[1], subtreeMap);\n\n        long result = 0;\n        for (int count : subtreeMap.values()) {\n            result += (long) count * (count - 1) / 2;\n        }\n        System.out.println(result);\n    }\n\n    private static String dfs(TreeNode node, Map<String, Integer> subtreeMap) {\n        List<String> childHashes = new ArrayList<>();\n        for (TreeNode child : node.children) {\n            childHashes.add(dfs(child, subtreeMap));\n        }\n        Collections.sort(childHashes);\n        String hash = String.join(\",\", childHashes) + \"|\" + childHashes.size();\n        subtreeMap.put(hash, subtreeMap.getOrDefault(hash, 0) + 1);\n        return hash;\n    }\n}",
    "timestamp": "2025-08-05 21:59:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeSimilarity {\n    static ArrayList<Integer>[] tree;\n    static int[] depth;\n    static int[][] nodeCountAtDepth;\n    static int N;\n\n    public static void dfs(int node, int currentDepth) {\n        depth[node] = currentDepth;\n        nodeCountAtDepth[currentDepth][0]++;\n\n        for (int child : tree[node]) {\n            dfs(child, currentDepth + 1);\n        }\n    }\n\n    public static boolean areSimilar(int subtree1, int subtree2) {\n        int maxDepth = Math.max(depth[subtree1], depth[subtree2]);\n        for (int d = 0; d <= maxDepth; d++) {\n            if (nodeCountAtDepth[d][subtree1] != nodeCountAtDepth[d][subtree2]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int countSimilarSubtrees() {\n        int similarPairs = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = i + 1; j <= N; j++) {\n                if (areSimilar(i, j)) {\n                    similarPairs++;\n                }\n            }\n        }\n        return similarPairs;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        tree = new ArrayList[N + 1];\n        depth = new int[N + 1];\n        nodeCountAtDepth = new int[N + 1][N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n\n        for (int i = 2; i <= N; i++) {\n            int parent = scanner.nextInt();\n            tree[parent].add(i);\n        }\n\n        dfs(1, 0);\n        System.out.println(countSimilarSubtrees());\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:59:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> graph[MAXN];\nvector<int> depth_count[MAXN];\n\nvoid dfs(int node, int curr_depth) {\n    // Increase count for current depth\n    if (depth_count[node].size() <= curr_depth) {\n        depth_count[node].resize(curr_depth + 1, 0);\n    }\n    depth_count[node][curr_depth]++;\n\n    // Process children\n    for (int child : graph[node]) {\n        dfs(child, curr_depth + 1);\n\n        // Merge children's depth counts\n        for (int d = 0; d < depth_count[child].size(); d++) {\n            if (depth_count[node].size() <= d) {\n                depth_count[node].resize(d + 1, 0);\n            }\n            depth_count[node][d] += depth_count[child][d];\n        }\n    }\n}\n\nbool are_similar(int u, int v) {\n    if (depth_count[u].size() != depth_count[v].size()) return false;\n    \n    for (int d = 0; d < depth_count[u].size(); d++) {\n        if (depth_count[u][d] != depth_count[v][d]) return false;\n    }\n    return true;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n\n    // Build tree\n    for (int i = 2; i <= N; i++) {\n        int parent;\n        cin >> parent;\n        graph[parent].push_back(i);\n    }\n\n    // Calculate depth counts for each subtree\n    dfs(1, 0);\n\n    // Count similar subtrees\n    int similar_pairs = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            if (are_similar(i, j)) {\n                similar_pairs++;\n            }\n        }\n    }\n\n    cout << similar_pairs << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, Counter\n\ndef build_tree(edges, N):\n    tree = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        tree[u].append(v)\n    return tree\n\ndef calc_subtree_signature(tree, node, depth_counts):\n    depth_counts[node] = Counter()\n    for child in tree[node]:\n        child_signature = calc_subtree_signature(tree, child, depth_counts)\n        for depth, count in child_signature.items():\n            depth_counts[node][depth + 1] += count\n    depth_counts[node][0] += 1\n    return depth_counts[node]\n\ndef solve(N, edges):\n    tree = build_tree(edges, N)\n    depth_counts = [None] * (N + 1)\n    calc_subtree_signature(tree, 1, depth_counts)\n    \n    signature_count = defaultdict(int)\n    for i in range(1, N + 1):\n        signature = tuple(sorted(depth_counts[i].items()))\n        signature_count[signature] += 1\n\n    similar_pairs = 0\n    for count in signature_count.values():\n        if count > 1:\n            similar_pairs += (count * (count - 1)) // 2\n\n    return similar_pairs\n\n# Example usage:\nN = 5\nedges = [(1, 2), (1, 3), (3, 4), (3, 5)]\nprint(solve(N, edges))  # Output should be based on your specific input data",
    "timestamp": "2025-08-13 08:23:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeSimilarity {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        List<Integer>[] tree = new List[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            int parent = scanner.nextInt();\n            int child = scanner.nextInt();\n            tree[parent].add(child);\n        }\n\n        Map<Map<Integer, Integer>, List<Integer>> depthCountMap = new HashMap<>();\n        countNodesAtDepth(tree, 1, depthCountMap);\n\n        int similarCount = 0;\n        for (List<Integer> values : depthCountMap.values()) {\n            int size = values.size();\n            if (size > 1) {\n                similarCount += size * (size - 1) / 2;\n            }\n        }\n\n        System.out.println(similarCount);\n    }\n\n    private static Map<Integer, Integer> countNodesAtDepth(List<Integer>[] tree, int node,\n            Map<Map<Integer, Integer>, List<Integer>> depthCountMap) {\n        Map<Integer, Integer> depthCount = new HashMap<>();\n\n        for (int child : tree[node]) {\n            Map<Integer, Integer> childCount = countNodesAtDepth(tree, child, depthCountMap);\n            for (Map.Entry<Integer, Integer> entry : childCount.entrySet()) {\n                depthCount.merge(entry.getKey() + 1, entry.getValue(), Integer::sum);\n            }\n        }\n\n        depthCount.put(0, 1); // Counting the current node\n\n        depthCountMap.computeIfAbsent(depthCount, k -> new ArrayList<>()).add(node);\n        return depthCount;\n    }\n}",
    "timestamp": "2025-08-13 08:23:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100001\n\ntypedef struct Node {\n    struct Node* children[MAX_N];\n    int childCount;\n} Node;\n\nNode nodes[MAX_N];\nint depthCounts[MAX_N][MAX_N];\nint maxDepth[MAX_N];\nint countSimilarPairs = 0;\n\nvoid addEdge(int parent, int child) {\n    nodes[parent].children[nodes[parent].childCount++] = &nodes[child];\n}\n\nvoid dfs(Node* node, int depth) {\n    depthCounts[node - nodes][depth]++;\n    if (depth > maxDepth[node - nodes]) {\n        maxDepth[node - nodes] = depth;\n    }\n    for (int i = 0; i < node->childCount; i++) {\n        dfs(node->children[i], depth + 1);\n    }\n}\n\nint compareNodeDepth(int a, int b) {\n    if (maxDepth[a] != maxDepth[b]) return 0;\n    for (int d = 0; d <= maxDepth[a]; d++) {\n        if (depthCounts[a][d] != depthCounts[b][d]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i < N; i++) {\n        nodes[i].childCount = 0;\n        memset(depthCounts[i], 0, sizeof(depthCounts[i]));\n        maxDepth[i] = 0;\n    }\n\n    for (int i = 2; i <= N; i++) {\n        int parent;\n        scanf(\"%d\", &parent);\n        addEdge(parent - 1, i - 1);\n    }\n\n    for (int i = 0; i < N; i++) {\n        dfs(&nodes[i], 0);\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (compareNodeDepth(i, j)) {\n                countSimilarPairs++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", countSimilarPairs);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 08:23:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, Counter\n\ndef solve_similar_subtrees(N, edges):\n    # Build adjacency list\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n\n    # Store depth and nodes at each depth for each subtree\n    subtree_depths = [None] * (N + 1)\n    \n    def dfs(node, depth=0):\n        node_depths = Counter()\n        node_depths[depth] = 1\n        \n        for child in graph[node]:\n            child_depths = dfs(child, depth + 1)\n            node_depths += child_depths\n        \n        subtree_depths[node] = node_depths\n        return node_depths\n\n    # Perform DFS from root\n    dfs(1)\n\n    # Count similar subtrees\n    similar_count = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if subtree_depths[i] == subtree_depths[j]:\n                similar_count += 1\n\n    return similar_count\n\n# Input handling\ndef main():\n    N = int(input())\n    edges = []\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    result = solve_similar_subtrees(N, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:23:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    parent = list(map(int, sys.stdin.readline().split()))\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for i in range(2, N+1):\n        tree[parent[i-2]].append(i)\n    \n    # BFS to assign depths and compute subtree info\n    depth = [0] * (N + 1)\n    subtree_depths = defaultdict(list)\n    stack = [(1, False)]\n    \n    while stack:\n        node, processed = stack.pop()\n        if not processed:\n            stack.append((node, True))\n            for child in sorted(tree[node], reverse=True):\n                stack.append((child, False))\n        else:\n            depth_counts = defaultdict(int)\n            depth_counts[depth[node]] = 1\n            for child in tree[node]:\n                for d, cnt in subtree_depths[child].items():\n                    depth_counts[d] += cnt\n            subtree_depths[node] = depth_counts\n    \n    # Create a hashable representation for each subtree's depth counts\n    subtree_signatures = {}\n    for node in range(1, N+1):\n        signature = tuple(sorted(subtree_depths[node].items()))\n        subtree_signatures[node] = signature\n    \n    # Count the number of similar subtrees\n    signature_count = defaultdict(int)\n    for node in range(1, N+1):\n        signature = subtree_signatures[node]\n        signature_count[signature] += 1\n    \n    result = 0\n    for cnt in signature_count.values():\n        result += cnt * (cnt - 1) // 2\n    print(result)\n\nsolve()",
    "timestamp": "2025-08-13 08:23:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstruct TreeNode {\n    int id;\n    vector<TreeNode*> children;\n};\n\nvoid insertEdge(vector<TreeNode>& nodes, int u, int v) {\n    nodes[u].children.push_back(&nodes[v]);\n}\n\nvoid dfs(TreeNode* node, vector<unordered_map<int, int>>& depthCount, int depth) {\n    depthCount[node->id][depth]++;\n    for (auto* child : node->children) {\n        dfs(child, depthCount, depth + 1);\n        for (const auto& [d, count] : depthCount[child->id]) {\n            depthCount[node->id][d] += count;\n        }\n    }\n}\n\nint countSimilarSubtrees(int n, const vector<pair<int, int>>& edges) {\n    vector<TreeNode> nodes(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        nodes[i].id = i;\n    }\n\n    for (const auto& edge : edges) {\n        insertEdge(nodes, edge.first, edge.second);\n    }\n\n    vector<unordered_map<int, int>> depthCount(n + 1);\n\n    dfs(&nodes[1], depthCount, 0);\n\n    map<vector<int>, int> subtreeProfileCount;\n    for (int i = 1; i <= n; ++i) {\n        vector<int> profile;\n        for (const auto& [depth, count] : depthCount[i]) {\n            profile.push_back(count);\n        }\n        sort(profile.begin(), profile.end());\n        subtreeProfileCount[profile]++;\n    }\n\n    int result = 0;\n    for (const auto& [profile, count] : subtreeProfileCount) {\n        if (count > 1) {\n            result += count * (count - 1) / 2;\n        }\n    }\n    return result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> edges(n - 1);\n    for (int i = 0; i < n - 1; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    cout << countSimilarSubtrees(n, edges) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:45:33"
  }
]