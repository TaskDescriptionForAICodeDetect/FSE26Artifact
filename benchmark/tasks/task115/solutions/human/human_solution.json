[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[160][1000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(x>=500)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define INF 11451419\nusing namespace std;\n\nint n,d;\nstruct weapon{\n\tint a,e,r;\n};\n\nbool comp(const weapon& g1,const weapon& g2){\n\treturn g1.r<g2.r;\n};\n\nweapon b[101];\n//武器の種類・EXP・HP\nint dp[101][101][101];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&d,&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfor(int k=0;k<=100;k++)dp[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)scanf(\"%d%d%d\",&b[i].a,&b[i].e,&b[i].r);\n\t\tsort(b,b+n,comp);\n\t\tdp[0][0][d]=0;\n\t\tint res=INF;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tif(b[i].r>j)continue;\n\t\t\t\tfor(int k=d;k>=0;k--){\n\t\t\t\t\tdp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][min(100,j+b[i].e)][max(0,k-b[i].a)]=min(dp[i][min(100,j+b[i].e)][max(0,k-b[i].a)],dp[i][j][k]+1);\n\t\t\t\t\tdp[i+1][min(100,j+b[i].e)][max(0,k-b[i].a)]=min(dp[i+1][min(100,j+b[i].e)][max(0,k-b[i].a)],dp[i][j][k]+1);\n\t\t\t\t\tif(k-b[i].a<=0)res=min(res,dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res==INF)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nmain(){\n\t\n\tint d,n ;\n\tint tool[110][3] ; // ?¢????????????????????¨?????????????????¨????\n\tint table[110][110] ; // HP(?????????????????°),level,?????°???????????????\n\t\n\twhile( cin >> d >> n , d ){\n\t\tfor( int i=0 ; i<n ; i++ )\n\t\t\tfor( int j=0 ; j<3 ; j++ )\n\t\t\t\tcin >> tool[i][j] ;\n\t\t\n\t\tfor( int i=0 ; i<110 ; i++ )\n\t\t\tfor( int j=0 ; j<110 ; j++ )\n\t\t\t\ttable[i][j] = 300 ;\n\t\t\n\t\tint ans = 300 ;\n\t\ttable[0][0] = 0 ;\n\t\tfor( int i=0 ; i<d ; i++ ){\n\t\t\tfor( int j=0 ; j<=100 ; j++ ){\n\t\t\t\tif( table[i][j] != 300 ){\n\t\t\t\t\tfor( int k=0 ; k<n ; k++ ){\n\t\t\t\t\t\tint tmp1 = i+tool[k][0] ;\n\t\t\t\t\t\tint tmp2 = j+tool[k][1] ;\n\t\t\t\t\t\tif( tmp1 > d ) tmp1 = d ;\n\t\t\t\t\t\tif( tmp2 > 100 ) tmp2 = 100 ;\n\t\t\t\t\t\tif( j >= tool[k][2] ){\n\t\t\t\t\t\t\ttable[tmp1][tmp2] = min( table[tmp1][tmp2] , table[i][j]+1 ) ;\n\t\t\t\t\t\t\t//cout << tmp1 << \" \" << tmp2 << \" \" << table[tmp1][tmp2] << endl ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( int i=0 ; i<=100 ; i++ ) ans = min( ans , table[d][i] ) ;\n\t\t\n\t\tif( ans != 300 ) cout << ans << endl ;\n\t\telse cout << \"NA\" << endl ;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nint D[50], N[50];\nint A[50][100], E[50][100], R[50][100];\nint DP[110][110];\nint main()\n{\n\tint T = 0;\n\t\n\twhile (true){\n\t\tscanf(\"%d%d\", &D[T], &N[T]);\n\t\tif (D[T] == 0 && N[T] == 0)break;\n\t\tfor (int j = 0; j < N[T]; j++)scanf(\"%d%d%d\", &A[T][j], &E[T][j], &R[T][j]);\n\t\tT++;\n\t}\n\tfor (int k = 0; k < T; k++){\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] = -100000;\n\t\tDP[0][0] = 0;\n\t\tint ans = 10000;\n\t\tfor (int i = 0; i < N[k]; i++){\n\t\t\tfor (int j = i + 1; j < N[k]; j++){\n\t\t\t\tif (R[k][i]>R[k][j]){\n\t\t\t\t\tswap(A[k][i], A[k][j]);\n\t\t\t\t\tswap(E[k][i], E[k][j]);\n\t\t\t\t\tswap(R[k][i], R[k][j]);\n\t\t\t\t}\n\t\t\t\telse if (R[k][i] == R[k][j] && A[k][i] < A[k][j] && E[k][i] < E[k][j]){\n\t\t\t\t\tswap(A[k][i], A[k][j]);\n\t\t\t\t\tswap(E[k][i], E[k][j]);\n\t\t\t\t\tswap(R[k][i], R[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint O = 0;\n\t\twhile (O*T <= 470000000){\n\t\t\tfor (int i = 0; i < N[k]; i++){\n\n\t\t\t\tfor (int j = R[k][i]; j <= 109; j++){\n\t\t\t\t\tfor (int l = 0; l <= 108; l++){\n\t\t\t\t\t\tO++;\n\t\t\t\t\t\tif (j + E[k][i] <= 109)DP[j + E[k][i]][l + 1] = max(DP[j + E[k][i]][l + 1], DP[j][l] + A[k][i]);\n\t\t\t\t\t\telse DP[109][l + 1] = max(DP[109][l + 1], DP[j][l] + A[k][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D[k]){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Tool {int a, e, r;};\n// bool operator<(const Tool& lhs, const Tool& rhs) {return lhs.r < rhs.r;}\nbool operator<(const Tool& lhs, const Tool& rhs) {\n  if(lhs.r != rhs.r) return lhs.r < rhs.r;\n  return lhs.e < rhs.e;\n}\n\nint solve(int D, vector<Tool> tool) {\n  sort(begin(tool), end(tool));\n  vector<vector<int>> dp(D + 1, vector<int>(101, INF));\n  dp[D][0] = 0;\n  for(const auto& t: tool) {\n    for(int hp = D; 0 <= hp; --hp) {\n      for(int exp = 0; exp <= 100; ++exp) {\n        if(exp < t.r) continue;\n        int next_hp = max(0, hp - t.a);\n        int next_exp = min(100, exp + t.e);\n        dp[next_hp][next_exp] = min(dp[next_hp][next_exp], dp[hp][exp] + 1);\n      }\n    }\n  }\n\n  int result = INF;\n  for(const auto& i: dp[0]) result = min(result, i);\n  return result;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    int answer = solve(D, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][100000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=100)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end(),greater<pair<pair<int,int>,int> >());\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nconst int INF=1e9;\nint D,N;\nint a[105],e[105],r[105];\nint dp[105][105];\nint ans=INF;\ntemplate<typename A,size_t N,typename T>\nvoid Fill(A (&array)[N],const T &val)\n{\n  std::fill( (T*)array,(T*)(array+N),val );\n}\n\nint main()\n{\n  while(cin >> D >> N && D)\n    {\n      ans=INF;\n      Fill(dp,INF);\n      dp[D][0]=0;\n      for (int i = 0; i < N; ++i)\n\t{\n\t  cin >> a[i] >> e[i] >> r[i];\n\t}\n      for (int i = D; i >=0; i--)\n\t{\n\t  for (int j = 0; j <= 100; ++j)\n\t    {\n\t      for (int k = 0; k < N; ++k)\n\t\t{\n\t\t  if(r[k]<=j)\n\t\t    {\n\t\t      int nexthp=max(i-a[k],0);\n\t\t      int nextexp=min(100,j+e[k]);\n\t\t      dp[nexthp][nextexp]=min(dp[nexthp][nextexp],dp[i][j]+1);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      for (int i = 0; i <= 100; ++i)\n\t{\n\t  ans=min(ans,dp[0][i]);\n\t}\n      if(ans==INF)\n\t{\n\t  cout << \"NA\" << endl;\n\t}\n      else\n\t{\n\t  cout << ans << endl;\n\t}\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][2000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(x>=700)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint D, N, a[111], e[111], r[111], dp[111][111];\nint main() {\n\twhile (cin >> D >> N, D | N) {\n\t\tfor (int i = 0; i < N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tint maxr = *max_element(r, r + N);\n\t\tfor (int i = 0; i <= D; i++) fill(dp[i], dp[i] + maxr + 1, 999999999);\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j <= maxr; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j < r[k]) continue;\n\t\t\t\t\tint p = min(j + e[k], maxr), q = min(i + a[k], D);\n\t\t\t\t\tdp[q][p] = min(dp[q][p], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = *min_element(dp[D], dp[D] + maxr + 1);\n\t\tif (ret == 999999999) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n    int maxr,maxe,maxa,flg;\n    maxr=maxe=maxa=flg=0;\n    maxr = -1;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n    }\n\n    int N = 10001;\n    int ans = INF;\n    \n    for(int i=0;i<=d;i++) for(int j=0;j<=N;j++)dp[i][j] = INF;\n    dp[d][0] = 0;\n\n    int cnt = 0;\n      for(int j=0;j<=N;j++) { //?????¨???????¨????\n\tcnt++;\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\t  for(int k=0;k<n;k++) {\n\t    int na = i - a[k];\n\t    int ne = j + e[k];\n\t    if(na < 0) na = 0;\n\t    if(j < r[k]) continue;\n\t    dp[na][ne] = min(dp[i][j]+1,dp[na][ne]);\n\t  }\n\t  \n\t}\n\tans = min(ans,dp[0][j]);\n      }\n\n\n      /*\n    for(int j=0;j<=cnt;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n    }\n      */\n    \n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n   \n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nconst int INF = 1000000000;\n\nint main() {\n\tint d, n;\n\twhile (cin >> d >> n, d) {\n\t\tint a[n], e[n], r[n];\n\t\trep (i, n) cin >> a[i] >> e[i] >> r[i];\n\t\t//耐久値、経験値\n\t\tint dp[d + 1][101];\n\t\trep (i, d + 1) rep (j, 101) dp[i][j] = INF;\n\t\tdp[d][0] = 0;\n\t\tfor (int i = d; i >= 0; i--) rep (j, 101) {\n\t\t\tif (dp[i][j] == INF) continue;\n\t\t\trep (k, n) {\n\t\t\t\tif (r[k] > j) continue;\n\t\t\t\t//a[i] -> 減る耐久値, e[i] -> 得る経験値\n\t\t\t\tdp[max(0, i - a[k])][min(100, j + e[k])] = min(dp[max(0, i - a[k])][min(100, j + e[k])],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t dp[i][j] + 1);\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep (i, 101) ans = min(ans, dp[0][i]);\n\t\tcout << (ans == INF ? \"NA\" : to_string(ans)) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& os, const pair<T1, T2>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& v) {\n    os << \"{\";\n    for(int i = 0; i < v.size(); i++)\n        os << v[i] << (i+1<v.size()?\", \":\"\");\n    os << \"}\";\n    return os;\n}\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n}\n//}}}\n\nconst int MAXEX = 100;\nconst int MAXP = 100;\nconst int MAXN = 100;\nint memo[MAXP+1][MAXEX+1];\nint D;\nint N;\nint A[MAXN];\nint E[MAXN];\nint R[MAXN];\nint dfs(int rest, int ex) {\n    if(rest <= 0) return 0;\n    int& res = memo[rest][ex];\n    if(res != -1) return res;\n    res = INT_MAX;\n    REP(i, N) if(ex >= R[i]) {\n        int nrest = rest - A[i];\n        int nex = min(MAXEX, ex+E[i]);\n        res = min(res, 1+dfs(nrest,nex));\n    }\n    return res;\n}\nint main(){\n    iostream_init();\n    while(cin >> D >> N && (D > 0)) {\n        REP(i, N) cin >> A[i] >> E[i] >> R[i];\n        memset(memo, -1, sizeof(memo));\n        auto ans = dfs(D, 0);\n        if(ans < INT_MAX) {\n            cout << ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nint a[256], e[256], r[256];\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != -1) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      if(a[i] == 0 && e[i] == 0) continue;\n      if(a[i] == 0 && ex == 110) continue;\n      res = min(res, func(min(110,ex+e[i]), HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = -1;\n      }\n    }\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m,a[100],b[100],c[100],dp[110][110];\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;if(n==0 && m==0)break;\n\t\tfor(int i=0;i<110;i++){\n\t\t\tfor(int j=0;j<110;j++)dp[i][j]=1<<30;\n\t\t}\n\t\tfor(int i=0;i<m;i++)cin>>a[i]>>b[i]>>c[i];\n\t\tdp[0][0]=0;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tif(j<c[k])continue;\n\t\t\t\t\tint H=min(dp[min(n,i+a[k])][min(100,j+b[k])],dp[i][j]+1);\n\t\t\t\t\tdp[min(n,i+a[k])][min(100,j+b[k])]=H;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint minx=1<<30;\n\t\tfor(int i=0;i<=100;i++)minx=min(minx,dp[n][i]);\n\t\tif(minx>=(1<<30))cout<<\"NA\"<<endl;\n\t\telse{cout<<minx<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint ans;\nint dp[101][101];\n\nint solve(int hp, int exp) {\n\n    if(hp <= 0) {\n        return 0;\n    }\n\n    if(dp[hp][exp] != -1) {\n        return dp[hp][exp];\n    }\n\n    int ret = INF;\n    for(int i = 0; i < n; ++i) {\n        if(exp >= r[i]) {\n            ret = min(ret, solve(max(0, hp - a[i]), min(100, exp + e[i])) + 1);\n        }\n    }\n\n    return dp[hp][exp] = ret;\n}\n\nint main() {\n\n    while(cin >> d >> n, d || n) {\n\n        for(int i = 0; i < n; ++i) {\n            cin >> a[i] >> e[i] >> r[i];\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        ans = solve(d, 0);\n\n        if(ans == INF) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b)(a=min(a,b))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100], e[100], r[100];\nint dp[101][101];\n\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\trep(i, n)scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\trep(i, 101) {\n\t\t\tdp[0][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i <= d; i++) {\n\t\t\tfor (int j = 100; j >= 0; j--) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tif (j >= r[k])cmin(dp[i][j], dp[max(0, i - a[k])][j + e[k]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[d][0] == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\", dp[d][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nint D,N;\n\nstruct Info{\n\tInfo(){\n\t\tattack = exp = r_exp = -1;\n\t\tunuse = false;\n\t}\n\tInfo(int arg_attack,int arg_exp,int arg_r_exp){\n\t\tattack = arg_attack;\n\t\texp = arg_exp;\n\t\tr_exp = arg_r_exp;\n\t\tunuse = false;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn r_exp > arg.r_exp;\n\t};\n\n\tint attack,exp,r_exp;\n\tbool unuse;\n};\n\nstruct Data{\n\tint current_exp,rest_D,count;\n};\n\n\nvoid func(){\n\n\tint a,e,r;\n\tpriority_queue<Info> S;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&a,&e,&r);\n\t\tS.push(Info(a,e,r));\n\t}\n\n\tInfo info[N];\n\n\tint index = 0;\n\n\twhile(!S.empty()){\n\t\tinfo[index].attack = S.top().attack;\n\t\tinfo[index].exp = S.top().exp;\n\t\tinfo[index].r_exp = S.top().r_exp;\n\t\tindex++;\n\t\tS.pop();\n\t}\n\n\t//??¨????????????????????¨????????????????????????\n\tint a_num = 0,e_num = 0;\n\tfor(int i = 0; info[i].r_exp == 0; i++){\n\t\tif(info[i].attack > 0){\n\t\t\ta_num++;\n\t\t}\n\t\tif(info[i].exp > 0){\n\t\t\te_num++;\n\t\t}\n\t}\n\n\tif(a_num == 0 && e_num == 0){\n\t\tprintf(\"NA\\n\");\n\t\treturn;\n\t}else{\n\n\t\tif(a_num == 0 && e_num > 0){ //????¨??????????????????????????????¨??????????????????????????????\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(info[i].attack > 0)a_num++;\n\t\t\t}\n\n\t\t\tif(a_num == 0){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = -1;\n\n\tqueue<Data> Q;\n\n\tData first;\n\tfirst.current_exp = 0;\n\tfirst.rest_D = D;\n\tfirst.count = 0;\n\n\tQ.push(first);\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().rest_D <= 0){\n\t\t\tans = Q.front().count;\n\t\t\tbreak;\n\t\t}\n\n\t\t//??????????????????????¨?????????????????????????????????????????????¨???????????°???????????¨????????¨????????????\n\t\t//????????????????????????0????????°?????¨?????????\n\t\tfor(int i = 0; info[i].r_exp <= Q.front().current_exp;i++){\n\t\t\tif((info[i].unuse == true) || (info[i].attack <= 0 && info[i].exp <= 0))continue;\n\t\t\tFLG = true;\n\t\t\tfor(int k = 0; k < i;k++){\n\t\t\t\tif(info[i].exp <= info[k].exp && info[i].attack <= info[k].attack){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tinfo[i].unuse = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG == true){\n\t\t\t\tData new_data;\n\t\t\t\tnew_data.count = Q.front().count+1;\n\t\t\t\tnew_data.current_exp = Q.front().current_exp+info[i].exp;\n\t\t\t\tnew_data.rest_D = Q.front().rest_D - info[i].attack;\n\t\t\t\tQ.push(new_data);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tif(ans == -1){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&D,&N);\n\t\tif(D == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=100)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p])return dp[p];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end(),greater<pair<pair<int,int>,int> >());\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  //if(t>=100)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p])return dp[p];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k=0,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end(),greater<pair<pair<int,int>,int> >());\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Tool {int a, e, r;};\n\nint bfs(int D, const vector<Tool>& tool) {\n  vector<vector<int>> memo(D + 1, vector<int>(201, INF));\n  queue<tuple<int, int, int>> q;\n  q.emplace(0, D, 0);\n  while(!q.empty()) {\n    int depth, hp, exp;\n    tie(depth, hp, exp) = q.front();\n    q.pop();\n    if(100 < depth) return INF;\n    if(hp <= 0) return depth;\n    if(memo[hp][exp] <= depth) continue;\n    memo[hp][exp] = depth;\n    for(const auto& t: tool) {\n      if(exp < t.r) continue;\n      q.emplace(depth + 1, hp - t.a, exp + t.e);\n    }\n  }\n  return INF;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    int answer = bfs(D, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\nint ans,cnt ;\nint maxr;\nvoid saiki(int d,int ex,int kai) {\n  cnt++;\n  if(d <= 0 ) dp[0][ex] = 0;\n  if(d > 0) {\n    for(int i=0;i<n;i++) {\n      if(r[i] <= ex) {\n\tint da  =  d-a[i];\n\tif(da < 0) da = 0;\n\tif(maxr <=ex && a[i] == 0) continue;\n\tif(a[i] == 0 && e[i] == 0) continue;\n\tif(dp[da][ex+e[i]] < INF) {\n\t  dp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n\t  continue;\n\t}\n        saiki(da,ex+e[i],kai+1);\n\tdp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n      }\n    }\n  }\n}\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    maxr = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n    }\n    \n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=20000;j++)\n\tdp[i][j] = INF;\n    \n    saiki(d,0,0);\n\n    if(dp[d][0] == INF) cout << \"NA\" <<endl;\n    else cout << dp[d][0] <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvector<pair<int,pii> >in(m);\n\t\trep(i,m){\n\t\t\tcin>>in[i].second.first>>in[i].second.second>>in[i].first;\n\t\t}\n\t\tsort(all(in));\n\t\tvvi dp(n+1,vi(101,inf));//sum kei=cost\n\t\tdp[0][0]=0;\n\t\trep(i,n)rep(j,101)rep(k,m){\n\t\t\tif(j<in[k].first)continue;\n\t\t\tint a=min(n,i+in[k].second.first);\n\t\t\tint b=min(100,j+in[k].second.second);\n\t\t\tdp[a][b]=min(dp[a][b],dp[i][j]+1);\n\t\t}\n\t\tint mi=inf;\n\t\trep(i,101)mi=min(dp[n][i],mi);\n\t\tif(mi!=inf)cout<<mi<<endl;\n\t\telse cout<<\"NA\"<<endl;\n//\t\trep(i,n+1){rep(j,20)if(dp[i][j]!=inf)printf(\"%3d\",dp[i][j]);\n//\t\telse cout<<\" \"<<-1;cout<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint d, n;\n\twhile(cin >> d >> n, d+n){\n\t\tvector<int> a(n), e(n), r(n); //耐久力 経験値 必要な経験値\n\t\tfor(int i=0; i< n; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tint dp[d+1][11000]; //耐久力 i の時に 経験値 j の時の回数\n\t\tfor(int i=0; i < d+1; i++)for(int j=0; j< 11000; j++) dp[i][j] = -1;\n\t\tdp[d][0] = 0;\n\t\tfor(int i = d; 0 <= i; i--){\n\t\t\tfor(int j = 0; j <= 10000; j++){\n\t\t\t\tif(dp[i][j] == -1) continue;\n\t\t\t\tfor(int k=0; k < n; k++){\n\t\t\t\t\tif(r[k] <= j){\n\t\t\t\t\t\tint p = (i-a[k]<0 ? 0 : i-a[k]);\n\t\t\t\t\t\tdp[p][j+e[k]] = min(dp[i][j]+1, (dp[p][j+e[k]] == -1 ? (int)10e8 : dp[p][j+e[k]]) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 10e7;\n\t\tfor(int i=0; i <= 10000; i++) if(dp[0][i] != -1) ret = min(dp[0][i], ret);\n\t\tif(ret == 10e7) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<list>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\nstruct a\n{\n\tint b, c, d;\n};\na e[100];\nint dp[101][101];//????????????n????¨???????m\nint main() {\n\tint f, g;\n\twhile (cin >> f >> g, f | g) {\n\t\tint MAX = 0;\n\t\tfor (int h = 0; h < g; h++) {\n\t\t\tint i, j, k;\n\t\t\tscanf(\"%d%d%d\", &i, &j, &k);\n\t\t\te[h] = { i,j,k };\n\t\t\tMAX = max(MAX, k);\n\t\t}\n\t\tfor (int h = 0; h <= f; h++) {\n\t\t\tfor (int i = 0; i <= MAX;i++) {\n\t\t\t\tdp[h][i] = 1 << 29;\n\t\t\t\tif (h == 0)dp[h][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 1; h <= f; h++) {\n\t\t\tfor (int i = 0; i <= MAX;i++) {\n\t\t\t\tfor (int j = 0; j < g; j++) {\n\t\t\t\t\tif (i >= e[j].d) {\n\t\t\t\t\t\tdp[h][i] = min(dp[h][i], 1 + dp[max(0,h - e[j].b)][min(MAX, i + e[j].c)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[f][0] == 1 << 29)puts(\"NA\");\n\t\telse cout << dp[f][0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define INF (2 << 28)\nusing namespace std;\n\nint d, n, dp[111][111];\nint a[111], e[111], r[111];\n\nint rec(int exp, int hp){\n    \n    if(hp <= 0) return 0;\n    \n    int ret = INF;\n    for(int i = 0; i < n; i++){\n        if(r[i] <= exp)\n            ret = min(ret, rec(min(100, exp + e[i]), hp - a[i]) + 1);\n    }\n    return dp[exp][hp] = ret;\n}\n\nint main(){\n    \n    while(cin >> d >> n, d||n){\n        for(int i = 0; i < n; i++) cin >> a[i] >> e[i] >> r[i];\n        \n        memset(dp, -1, sizeof(dp));\n        int dd = rec(0, d);\n        if(dd == INF) cout << \"NA\" << endl;\n        else cout << dd << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint D, N, w, a[111], e[111], r[111], dp[111][111][222];\nint rec(int f1, int f2, int d) {\n\tif (f1 >= D) return d;\n\tif (dp[f1][f2][d]) return dp[f1][f2][d] - 1;\n\tint ret = 999999999;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!a[i] && (!e[i] || f2 == w)) continue;\n\t\tif (f2 >= r[i]) ret = min(ret, rec(f1 + a[i], min(f2 + e[i], w), d + 1));\n\t}\n\tdp[f1][f2][d] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> D >> N, D | N) {\n\t\tfor (int i = 0; i < N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tw = max_element(r, r + N);\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j <= w; j++) {\n\t\t\t\tfor (int k = 0; k < N * 2; k++) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = rec(0, 0, 0);\n\t\tif (ret == 999999999) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 100*100+50\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1+N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1+N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i+a[k]][j+e[k]]==INF) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1+N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<list>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\nstruct c {\n\tint d, e, f;\n};\nc k[100];\nint a, b;\nint memo[101][101];\nint saiki(int n, int m) {//????????????n??§????¨???????m\n\tif (memo[n][m] != -1)return memo[n][m];\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (k[i].f <= m) {\n\t\t\tif (k[i].d >= n)return memo[n][m]=1;\n\t\t\tMIN = min(MIN, 1+saiki(n-k[i].d, min(100, k[i].e + m)));\n\t\t}\n\t}\n\treturn memo[n][m]=MIN;\n}\nint main() {\n\twhile (cin >> a >> b, a | b) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tint h, i, j; scanf(\"%d%d%d\", &h, &i, &j);\n\t\t\tk[g] = { h,i,j };\n\t\t}\n\t\tint S = saiki(a, 0);\n\t\tif (S >= 1 << 29) { puts(\"NA\"); }\n\t\telse cout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][100001];\nint ans,cnt ;\n\nvoid saiki(int d,int ex,int kai) {\n  cnt++;\n  if(d <= 0 ) dp[0][ex] = 0;\n  if(d > 0) {\n    for(int i=0;i<n;i++) {\n      if(r[i] <= ex) {\n\tint da  =  d-a[i];\n\tif(da < 0) da = 0;\n\tif(dp[da][ex+e[i]] < INF) {\n\t  //cout <<\"ok\"<<endl;\n\t  dp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n\t  continue;\n\t}\n        saiki(d-a[i],ex+e[i],kai+1);\n\tdp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n      }\n    }\n  }\n}\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n\n    for(int i=0;i<n;i++) cin >> a[i] >> e[i] >> r[i];\n    \n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=50000;j++)\n\tdp[i][j] = INF;\n\n    saiki(d,0,0);\n\n    if(dp[d][0] == INF) cout << \"NA\" <<endl;\n    else cout << dp[d][0] <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = 1e9;\n\nint main(){\n  int D, N;\n  while(cin >> D >> N, D){\n    vector<int> A(N), E(N), R(N);\n    for(int i = 0; i < N; ++i){\n      cin >> A[i] >> E[i] >> R[i];\n    }\n    vector<vector<int>> dp(D+1,vector<int>(101,INF));\n    dp[D][0] = 0;\n    for(int i = D; i >= 0; --i){\n      for(int j = 0; j <= 100; ++j){\n        if(dp[i][j] >= INF) continue;\n        for(int k = 0; k < N; ++k){\n          if(R[k] > j) continue;\n          int i_ = max(0,i-A[k]), j_ = min(100,j+E[k]);\n          dp.at(i_).at(j_) = min(dp[i_][j_],dp[i][j]+1);\n        }\n      }\n    }\n    int ans = INF;\n    for(int j = 0; j <= 100; ++j)\n      ans = min(ans,dp[0][j]);\n    if(ans >= INF) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  while (true) {\n    int d = in();\n    int n = in();\n    if (d == 0 && n == 0) break;\n    vector<int> a(n), e(n), r(n);\n    rep(i, n) cin >> a[i] >> e[i] >> r[i];\n    auto dp = vectors(d + 1, 101, INF);\n    dp[d][0] = 0;\n    for (int i = d; i >= 0; i--) {\n      for (int j = 0; j <= 100; j++) {\n        for (int k = 0; k < n; k++) {\n          if (j < r[k]) continue;\n          cmin(dp[max(0LL, i - a[k])][min(100LL, j + e[k])], dp[i][j] + 1);\n        }\n      }\n    }\n    int ans = INF;\n    for (int j = 0; j <= 100; j++) cmin(ans, dp[0][j]);\n    if (ans == INF) {\n      cout << \"NA\" << endl;\n      continue;\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int D,n;\n    while(cin>>D>>n,D,n){\n        int tool[101][2],num[101];\n        bool ok[300]={};\n        for(int i=0,r[3];i<n;i++){\n            for(int j=0;j<3;j++)cin>>r[j];\n            if(ok[r[2]]==false||tool[r[2]][0]<=r[0]&&tool[r[2]][1]<=r[1]){\n                tool[r[2]][0]=r[0];\n                tool[r[2]][1]=r[1];\n                ok[r[2]]=1;\n            }\n        }\n        if(ok[0]){\n            for(int i=1,now=0,r=0;D>0;i++){\n                for(int j=r;j>=r-tool[now][1];j--){\n                    if(ok[j]){\n                        now=j;\n                        break;\n                    }\n                }\n                D-=tool[now][0];\n                r+=tool[now][1];\n                if(D<1)cout<<i<<endl;\n            }\n        }\n        else cout<<\"NA\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][11111];\nint solve(int d, int exp){\n    if(d <= 0) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(a[i]==0 && e[i]==0) continue;\n        if(r[i] <= exp){\n            res = min(res, 1+solve(d-a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(D,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[150][150];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REPR(i,n) for (int i=(int)(n)-1;i>=0;--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>basic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>&os,\nconst C& c){os<<'[';for(auto i=begin(c);i!=end(c);++i)os<<(i==begin(c)?\"\":\" \")<<*i;return os<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\ntemplate<class T>bool inputs(T *a, int n) { REP(i,n) if(!input(a[i])) return 0; return 1;}\n\nint dp[101][101][101];\n\nstruct P {\n  int a,e,r;\n  void in() {\n    cin >> a >> e >> r;\n  }\n  bool operator<(const P &rhs) const {\n    return r < rhs.r;\n  }\n} p[100];\n\nint main() {\n  int d,n;\n  while(cin>>d>>n,d||n) {\n    REP(i,n) {\n      p[i].in();\n    }\n    sort(p,p+n);\n    memset(dp,0x3f,sizeof(dp));\n    dp[0][0][0] = 0;\n    REP(i,n) {\n      for (int j=0; j <= 100; ++j) {\n        REP(k,d+1) {\n          chmin(dp[i+1][j][k], dp[i][j][k]);\n          if (j>=p[i].r) {\n            REP(l,100) {\n              chmin(dp[i+1][min(100,j+p[i].e*l)][min(d,k+p[i].a*l)], dp[i][j][k] + l);\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(i,101) chmin(ans, dp[n][i][d]);\n    if (ans == INF) puts(\"NA\");\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[101][101];\nint main()\n{\n\twhile (true){\n\t\tint ans = 100000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\t}\n\t\tfor (int i = 0; i <= 100; i++)for (int j = 0; j <= 100; j++)DP[i][j] = 100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int i = 0; i <= D; i++){\n\t\t\tfor (int j = 0; j <= 100; j++){\n\t\t\t\tif (DP[i][j] == 100000)continue;\n\t\t\t\tfor (int k = 0; k < N; k++){\n\t\t\t\t\tif (R[k]>j)continue;\n\t\t\t\t\tDP[min(100, i + A[k])][min(100,j + E[k])] = min(DP[min(100, i + A[k])][min(100,j + E[k])], DP[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = D; i <= 100; i++){\n\t\t\tfor (int j = 0; j <= 100; j++){\n\t\t\t\tif (DP[i][j] != 100000){\n\t\t\t\t\tans = min(ans, DP[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 100000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nint d,n;\nint a[110],e[110],r[110];\nint memo[110][110];\n\nint rec(int hp, int exp){\n  if(hp<0 || exp>100)return INF;\n  if(hp==0)return 0;\n  if(memo[hp][exp]>=0)return memo[hp][exp];\n\n  int res = INF;\n  for(int i=0;i<n;i++){\n    if(exp>=r[i]){\n      res = min(res, rec(max(0,hp-a[i]), min(100,exp+e[i])) + 1 );\n    }\n  }\n  return memo[hp][exp] = res;\n}\n\nint main(){\n  while(cin >> d >> n, d){\n    for(int i=0;i<n;i++)cin >> a[i] >> e[i] >> r[i];\n\n    memset(memo,-1,sizeof(memo));\n    int ans = rec(d,0);\n    if(ans==INF)cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[1000][100010];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAX = 101;\n\nint d, n;\nint a[MAX], e[MAX], r[MAX];\n\n\nint bfs(){\n\tint dis[MAX][MAX];\n\tfor (int i = 0; i < MAX; i++) {\n\t\tfill(dis[i], dis[i] + MAX, INF);\n\t}\n\n\tqueue<pair<int, int>> q;\n\tq.emplace(d,0);\n\twhile(not q.empty()){\n\t\tint hp, exp;\n\t\ttie(hp, exp) = q.front(); q.pop();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif(r[i] > exp) continue;\n\t\t\t\n\t\t\tint nhp = max(0, hp - a[i]);\n\t\t\tint nexp = min(100, exp + e[i]);\n\t\t\tif(dis[nhp][nexp] > dis[hp][exp] + 1){\n\t\t\t\tdis[nhp][nexp] = dis[hp][exp] + 1;\n\t\t\t\tq.emplace(nhp, nexp);\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 0;\n\tfor (int i = 0; i <= 100; i++) {\n\t\tres = min(res, dis[0][i]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> d >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i] >> e[i] >> r[i];\n\t}\n\n\tcout << bfs() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\nstruct Tool {int a, e, r;};\n\nint dfs(int hp, int exp, int depth, const vector<Tool>& tool) {\n  if(hp <= 0) return depth;\n  int result = INF;\n  for(const auto& t: tool) {\n    if(exp < t.r) continue;\n    result = min(result, dfs(hp - t.a, exp + t.e, depth + 1, tool));\n  }\n  return result;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    int answer = dfs(D, 0, 0, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<unordered_set> \n#include<cmath>\nusing namespace std;\nlong long p = 998244353;\n//long long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<int,pin>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)\n#define mint modint<998244353>\n#define end_s(a) cout <<a<<endl;return 0\nvel pa;\nint root(int x) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x]); pa[x] = ans;\n\treturn ans;\n}\nvoid marge(int x, int y) {\n\tx = root(x);\n\ty = root(y);\n\tif (x != y) { pa[x] = y; }\n}\nV<string> solve2(int a, int b) {\n\tif (a < 0 || b < 0) { return {}; }\n\tif (a == 0 && b == 0) {\n\t\tV<string> ans(1, \"\");\n\t\treturn ans;\n\t}\n\tV<string> ans = solve2(a - 1, b);\n\tV<string> nans;\n\tfor (auto x : ans) { nans.push_back(x+\"A\"); }\n\tV<string> ans2 = solve2(a, b - 1);\n\tfor (auto x : ans2) { nans.push_back(x+\"B\"); }\n\treturn nans;\n}\nsigned main() {\n\twhile (true) {\n\t\tint d, n; cin >> d >> n;\n\t\tif (d == 0) { break; }\n\t\tint inf = 100;\n\t\tvvel dp(d + 1, vel(101, 10000));\n\t\tvel a(n), e(n), r(n);\n\t\trep(i, n) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tdp[0][0] = 0;\n\t\trep(i, d + 1) {\n\t\t\trep(j, 101) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tif (r[k] <= j) {\n\t\t\t\t\t\tmmin(dp[min(i + a[k], d)][min(j + e[k], inf)], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 10000;\n\t\trep(i, 101) { mmin(ans, dp[d][i]); }\n\t\tif (ans == 10000) { cout << \"NA\" << endl; }\n\t\telse { cout << ans << endl; }\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[101][10010];\nint main()\n{\n\twhile (true){\n\t\tint ans = 100000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\t}\n\t\tfor (int i = 0; i <= 100; i++)for (int j = 0; j < 10010; j++)DP[i][j] = 100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int i = 0; i <= D; i++){\n\t\t\tfor (int j = 0; j <= 100; j++){\n\t\t\t\tif (DP[i][j] == 100000)continue;\n\t\t\t\tfor (int k = 0; k < N; k++){\n\t\t\t\t\tif (R[k]>j)continue;\n\t\t\t\t\tDP[min(100, i + A[k])][min(100,j + E[k])] = min(DP[min(D, i + A[k])][j + E[k]], DP[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = D; i <= 100; i++){\n\t\t\tfor (int j = 0; j < 10010; j++){\n\t\t\t\tif (DP[i][j] != 100000){\n\t\t\t\t\tans = min(ans, DP[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 100000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Data { int a,e,r; };\nstruct Obj {\n  int damage,exp,cnt;\n  bool operator < ( const Obj &obj) const {\n    return cnt > obj.cnt;\n  }\n};\nconst int IINF = INT_MAX;\nint dp[110][110];\n\nint main(){\n  int D,N;\n  while(cin >> D >> N, D|N ){\n    vector<Data> arr(N);\n    rep(i,N) cin >> arr[i].a >> arr[i].e >> arr[i].r;\n    rep(i,110) rep(j,110) dp[i][j] = IINF; \n    dp[0][0] = 0;\n    priority_queue<Obj> Q;\n    Q.push((Obj){0,0,0});\n    bool found = false;\n    while( !Q.empty() ){\n      Obj obj = Q.top(); Q.pop();\n      if( obj.damage == D ) { cout << obj.cnt << endl; found = true; break; }\n      rep(i,N) if( obj.exp >= arr[i].r ){\n        int damage = min(D,obj.damage + arr[i].a);\n        int exp    = min(100,obj.exp+arr[i].e);\n        int cnt    = obj.cnt + 1;\n        if( dp[damage][exp] > cnt ) {\n          dp[damage][exp] = cnt;\n          Q.push((Obj){damage,exp,cnt});\n        }\n      }\n    }\n    if( !found ) puts(\"NA\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\n// ??§????????°INF\nconst int INF = (1 << 30);\n// ?¨±?????????????????\nconst double EPS = (1e-10);\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint D, N;\n\twhile (true) {\n\t\tcin >> D >> N; if (D == 0 && N == 0)break;\n\t\tvector<int> a(N), e(N), r(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tvector<vector<int>>dp(D + 1, vector<int>(101, INF));\n\t\tdp[D][0] = 0;\n\t\tfor (int i = D; i >= 0; --i) {\n\t\t\tfor (int j = 0; j < 101; ++j) {\n\t\t\t\tif (dp[i][j] == INF)continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (j < r[k])continue;\n\t\t\t\t\tint tmp_i = max(0, i - a[k]), tmp_j = min(100, j + e[k]);\n\t\t\t\t\tdp[tmp_i][tmp_j] = min(dp[tmp_i][tmp_j], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 101; ++i)ans = min(ans, dp[0][i]);\n\t\tif (ans == INF) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b)(a=min(a,b))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100], e[100], r[100];\nint dp[101][101];\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\trep(i, n)scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\trep(i, 101)dp[0][i] = 0;\n\t\trep(i, d + 1)for (int j = 100; j >= 0; j--)rep(k, n) {\n\t\t\tif (j - e[k] >= r[k]) {\n\t\t\t\trep(p, e[k] + 1)rep(t, a[k] + 1) {\n\t\t\t\t\tcmin(dp[min(d, i + t)][j - p], dp[i][j] + 1);\n\t\t\t\t\tif (min(d, i + t) == d)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[d][0] == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\", dp[d][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][1000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int q){\n  int res=0,k=1;\n  if(x>=1000&&p==q)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,p)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,p)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0,d);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint D, N, Ans;\nint Endurance[100], getExperience[100], needExperience[100];\nint DpCount[101][101];\n\nconst int INF = 2e9;\n\nvoid solve() {\n\tint minLife, maxExperience;\n\n\t//fill_n(*DpCount, 101 * 10001, INF);\n\tfor (int i = 0; i < 101; ++i) {\n\t\tfill(DpCount[i], DpCount[i] + 101, INF);\n\t}\n\tDpCount[D][0] = 0;\n\n\tfor (int currentLife = D; currentLife > 0; --currentLife) {\n\t\tfor (int currentExperience = 0; currentExperience < 101; ++currentExperience) {\n\t\t\tif (DpCount[currentLife][currentExperience] == INF) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (currentExperience < needExperience[i]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tminLife = max(0, currentLife - Endurance[i]);\n\t\t\t\tmaxExperience = min(100, currentExperience + getExperience[i]);\n\t\t\t\tDpCount[minLife][maxExperience] = min(DpCount[minLife][maxExperience],\n\t\t\t\t\tDpCount[currentLife][currentExperience] + 1);\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tAns = *min_element(DpCount[0], DpCount[0] + 101);\n}\n\nint main() {\n\n\twhile (cin >> D >> N, D) {\n\t\tmemset(Endurance, 0, sizeof(Endurance));\n\t\tmemset(getExperience, 0, sizeof(getExperience));\n\t\tmemset(needExperience, 0, sizeof(needExperience));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> Endurance[i] >> getExperience[i] >> needExperience[i];\n\t\t}\n\t\tsolve();\n\t\tif (Ans == INF) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << Ans << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nint D[50], N[50];\nint A[50][100], E[50][100], R[50][100];\nint DP[110][110];\nint main()\n{\n\tint T = 0;\n\t\n\twhile (true){\n\t\tscanf(\"%d%d\", &D[T], &N[T]);\n\t\tif (D[T] == 0 && N[T] == 0)break;\n\t\tfor (int j = 0; j < N[T]; j++)scanf(\"%d%d%d\", &A[T][j], &E[T][j], &R[T][j]);\n\t\tT++;\n\t}\n\tfor (int k = 0; k < T; k++){\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] = -100000;\n\t\tDP[0][0] = 0;\n\t\tint ans = 10000;\n\t\tfor (int i = 0; i < N[k]; i++){\n\t\t\tfor (int j = i + 1; j < N[k]; j++){\n\t\t\t\tif (R[k][i]>R[k][j]){\n\t\t\t\t\tswap(A[k][i], A[k][j]);\n\t\t\t\t\tswap(E[k][i], E[k][j]);\n\t\t\t\t\tswap(R[k][i], R[k][j]);\n\t\t\t\t}\n\t\t\t\telse if (R[k][i] == R[k][j] && A[k][i] < A[k][j] && E[k][i] < E[k][j]){\n\t\t\t\t\tswap(A[k][i], A[k][j]);\n\t\t\t\t\tswap(E[k][i], E[k][j]);\n\t\t\t\t\tswap(R[k][i], R[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint O = 0;\n\t\twhile (O*T <= 490000000){\n\t\t\tfor (int i = 0; i < N[k]; i++){\n\n\t\t\t\tfor (int j = R[k][i]; j <= 109; j++){\n\t\t\t\t\tfor (int l = 0; l <= 108; l++){\n\t\t\t\t\t\tO++;\n\t\t\t\t\t\tif (j + E[k][i] <= 109)DP[j + E[k][i]][l + 1] = max(DP[j + E[k][i]][l + 1], DP[j][l] + A[k][i]);\n\t\t\t\t\t\telse DP[109][l + 1] = max(DP[109][l + 1], DP[j][l] + A[k][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D[k]){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d >= D) return 0;\n    if(exp > 100) return INF;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            if(a[i]==0 && e[i]==0) continue;\n            res = min(res, 1+solve(d+a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nint d,n;\nint a[110],e[110],r[110];\nint memo[110][110];\n\nint rec(int hp, int exp){\n  if(hp==0)return 0;\n  if(memo[hp][exp]>=0)return memo[hp][exp];\n\n  int res = INF;\n  for(int i=0;i<n;i++){\n    if(exp>=r[i]){\n      int nhp = max(0,hp-a[i]), nexp = min(100,exp+e[i]);\n      if(hp == nhp && exp == nexp)continue;\n      res = min(res, rec(nhp, nexp) + 1 );\n    }\n  }\n  return memo[hp][exp] = res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&d,&n), d){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",a+i,e+i,r+i);\n\n    memset(memo,-1,sizeof(memo));\n    int ans = rec(d,0);\n    if(ans==INF)puts(\"NA\");\n    else printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][100000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=160)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][10001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n      maxe = max(maxe,e[i]);\n    }\n\n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=maxr+maxe;j++){\n\tdp[i][j] = INF;\n      }\n    dp[d][0] = 0;\n   \n    \n      for(int j=0;j<=maxr+maxe;j++) { //?????¨???????¨????\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\tfor(int k=0;k<n;k++) {\n\t  int na = i+a[k];\n\t  int ne = j-e[k];\n\t  if(na > d) na = d;\n\t  if(j-e[k] < 0) ne = 0;\n\t  if(j-e[k] < r[k]) continue;\n\t  dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t\n\t}\n      }\n    }\n      \n      /*  \n    for(int j=0;j<=maxr+maxe;j++) { //?????¨???????¨????\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n      }*/\n\n\n    int ans = INF;\n    for(int i=0;i<=maxr+maxe;i++)  ans = min(ans,dp[0][i]);\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<list>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\nstruct a\n{\n\tint b, c, d;\n};\na e[500];\nint dp[501][501];//????????????n????¨???????m\nint main() {\n\tint f, g;\n\twhile (cin >> f >> g, f | g) {\n\t\tint MAX = 500;\n\t\tfor (int h = 0; h < g; h++) {\n\t\t\tint i, j, k;\n\t\t\tscanf(\"%d%d%d\", &i, &j, &k);\n\t\t\te[h] = { i,j,k };\n\t\t}\n\t\tfor (int h = 0; h <= f; h++) {\n\t\t\tfor (int i = 0; i <= MAX;i++) {\n\t\t\t\tdp[h][i] = 1 << 29;\n\t\t\t\tif (h == 0)dp[h][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 1; h <= f; h++) {\n\t\t\tfor (int i = 0; i <= MAX;i++) {\n\t\t\t\tfor (int j = 0; j < g; j++) {\n\t\t\t\t\tif (i >= e[j].d) {\n\t\t\t\t\t\tdp[h][i] = min(dp[h][i], 1 + dp[max(0,h - e[j].b)][min(MAX, i + e[j].c)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[f][0] >= 100000)puts(\"NA\");\n\t\telse cout << dp[f][0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\nint ans,cnt ;\n\nvoid saiki(int d,int ex,int kai) {\n  cnt++;\n  if(d <= 0 ) dp[0][ex] = 0;\n  if(d > 0) {\n    for(int i=0;i<n;i++) {\n      if(r[i] <= ex) {\n\tint da  =  d-a[i];\n\tif(da < 0) da = 0;\n\tif(da == d) continue;\n\tif(dp[da][ex+e[i]] < INF) {\n\t  dp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n\t  continue;\n\t}\n        saiki(da,ex+e[i],kai+1);\n\tdp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n      }\n    }\n  }\n}\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n\n    for(int i=0;i<n;i++) cin >> a[i] >> e[i] >> r[i];\n    \n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=20000;j++)\n\tdp[i][j] = INF;\n    \n    saiki(d,0,0);\n\n    if(dp[d][0] == INF) cout << \"NA\" <<endl;\n    else cout << dp[d][0] <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nint D,N;\n\nstruct Info{\n\tInfo(){\n\t\tattack = exp = r_exp = -1;\n\t\tunuse = false;\n\t}\n\tInfo(int arg_attack,int arg_exp,int arg_r_exp){\n\t\tattack = arg_attack;\n\t\texp = arg_exp;\n\t\tr_exp = arg_r_exp;\n\t\tunuse = false;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn r_exp > arg.r_exp;\n\t};\n\n\tint attack,exp,r_exp;\n\tbool unuse;\n};\n\nstruct Data{\n\tint current_exp,rest_D,count;\n};\n\n\nvoid func(){\n\n\tint a,e,r;\n\tpriority_queue<Info> S;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&a,&e,&r);\n\t\tS.push(Info(a,e,r));\n\t}\n\n\tInfo info[N];\n\n\tint index = 0;\n\n\twhile(!S.empty()){\n\t\tinfo[index].attack = S.top().attack;\n\t\tinfo[index].exp = S.top().exp;\n\t\tinfo[index].r_exp = S.top().r_exp;\n\t\tindex++;\n\t\tS.pop();\n\t}\n\n\t//??¨????????????????????¨????????????????????????\n\tint a_num = 0,e_num = 0;\n\tfor(int i = 0; info[i].r_exp == 0; i++){\n\t\tif(info[i].attack > 0){\n\t\t\ta_num++;\n\t\t}\n\t\tif(info[i].exp > 0){\n\t\t\te_num++;\n\t\t}\n\t}\n\n\tif(a_num == 0 && e_num == 0){\n\t\tprintf(\"NA\\n\");\n\t\treturn;\n\t}else{\n\n\t\tif(a_num == 0 && e_num > 0){ //????¨??????????????????????????????¨??????????????????????????????\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(info[i].attack > 0)a_num++;\n\t\t\t}\n\n\t\t\tif(a_num == 0){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = -1;\n\n\tqueue<Data> Q;\n\n\tData first;\n\tfirst.current_exp = 0;\n\tfirst.rest_D = D;\n\tfirst.count = 0;\n\n\tQ.push(first);\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().rest_D <= 0){\n\t\t\tans = Q.front().count;\n\t\t\tbreak;\n\t\t}\n\n\t\t//??????????????????????¨?????????????????????????????????????????????¨???????????°???????????¨????????¨????????????\n\t\t//????????????????????????0????????°?????¨?????????\n\t\tfor(int i = 0; info[i].r_exp <= Q.front().current_exp;i++){\n\t\t\tif((info[i].unuse == true) || (info[i].attack <= 0 && info[i].exp <= 0))continue;\n\t\t\tFLG = true;\n\t\t\tfor(int k = 0; info[k].r_exp <= Q.front().current_exp;k++){\n\t\t\t\tif(i != k && info[i].exp <= info[k].exp && info[i].attack <= info[k].attack){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tinfo[i].unuse = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG == true){\n\t\t\t\tData new_data;\n\t\t\t\tnew_data.count = Q.front().count+1;\n\t\t\t\tnew_data.current_exp = Q.front().current_exp+info[i].exp;\n\t\t\t\tnew_data.rest_D = Q.front().rest_D - info[i].attack;\n\t\t\t\tQ.push(new_data);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tif(ans == -1){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&D,&N);\n\t\tif(D == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 1 << 29;\nint a[110], e[110], r[110];\nint d, n;\n\n// ?¨??????????,??????????????°???????¨????\nint func(int hp, int m, int k){\n\tif(hp <= 0) return m;\n\tint res = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(k >= r[i]){\n\t\t\tres = min(res, func(hp - a[i], m + 1, k + e[i]));\n\t\t}\n\t}\n\tif(res == INF){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0; \n\t}\n\tif(m == 0){\n\t\tcout << res << endl;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> d >> n && (d || n)){\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tfunc(d, 0, 0);\n\t}\n\n\treturn 0;\n}\n\n/*\na ??????????????????\ne ??????????¨????\nr ??????????¨????\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n;\n  bool dp[101][101],table[101][101],b[101];\n  while(cin>>d>>n,d){\n    int a[n],e[n],r[n];\n    memset(dp,0,sizeof(dp));\n    memset(b,0,sizeof(b));\n    dp[0][0]=1;b[0]=1;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          if(!b[j])continue;\n          r(k,d+1){\n            if(dp[j][k]){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>=d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              b[y]=1;\n              table[y][x]=1;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 0x3f3f3f3f;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>basic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>&os,\nconst C& c){os<<'[';for(auto i=begin(c);i!=end(c);++i)os<<(i==begin(c)?\"\":\" \")<<*i;return os<<']';}\n\nint a[100];\nint e[100];\nint r[100];\nint dp[101][101];\n\nint main() {\n  int d,n;\n  while (cin>>d>>n, d||n) {\n    REP(i,n) {\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    memset(dp,0x3f,sizeof(dp));\n    dp[0][0] = 0;\n    REP(i,d) {\n      REP(j,101) {\n        REP(k,n) {\n          if (j >= r[k]) {\n            chmin(dp[min(d,i+a[k])][min(100,j+e[k])], dp[i][j] + 1);\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(j,101)\n      chmin(ans, dp[d][j]);\n    if (ans == INF) puts(\"NA\");\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,s;\nvector<pair<pair<int,int>,int> >v;\nvoid dfs(int p,int x,int t){\n  if(t>=s)return;\n  if(p<0){s=t;return;}\n  if(x>10000)return;\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x)dfs(p-v[i].f.f,x+v[i].f.s,t+1);\n}\nint main(){\n  while(cin>>d>>n,d){\n    v.clear();s=1000000;\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end());\n    dfs(d,0,0);\n    if(s!=10000000)cout<<\"NA\"<<endl;\n    else cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][100000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=100)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end(),greater<pair<pair<in,int>,int> >());\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\n\nint dp[111][111];\nint solve(int d, int exp){\n    if(d <= 0) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INT_MAX/2;\n    rep(i,N){\n        if(r[i] <= exp){\n            res = min(res, 1+solve(d-a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(D,0);\n        if(ans == INT_MAX/2) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nint d,n;\nint a[110],e[110],r[110];\nint memo[110][110];\n\nint rec(int hp, int exp){\n  if(hp==0)return 0;\n  if(memo[hp][exp]>=0)return memo[hp][exp];\n\n  int res = INF;\n  for(int i=0;i<n;i++){\n    if(exp>=r[i]){\n      int nhp = max(0,hp-a[i]), nexp = min(100,exp+e[i]);\n      if(hp == nhp && exp == nexp)continue;\n      res = min(res, rec(nhp, nexp) + 1 );\n    }\n  }\n  return memo[hp][exp] = res;\n}\n\nint main(){\n  while(cin >> d >> n, d){\n    for(int i=0;i<n;i++)cin >> a[i] >> e[i] >> r[i];\n\n    memset(memo,-1,sizeof(memo));\n    int ans = rec(d,0);\n    if(ans==INF)cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define SIZE 101\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n\nint calc(int d,int n){\n  int a[SIZE],e[SIZE],r[SIZE];\n  int dp[SIZE][SIZE] = {0};\n\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%d\",&a[i],&e[i],&r[i]);\n  }\n\n  for(int i=0;i<=100;i++){\n    for(int j=0;j<=d;j++){\n      dp[i][j] = INF;\n    }\n  }\n\n  dp[0][0] = 0;\n  \n  for(int i=0;i<=100;i++){      \n    for(int j=0;j<=d;j++){\n      for(int k=0;k<n;k++){\n\tif(r[k] > i) continue;\n\tint x = min(i+e[k],100);\n\tint y = min(j+a[k],d);\n\t\n\tdp[x][y] = min(dp[x][y],dp[i][j]+1);\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i=0;i<=100;i++)\n    ans = min(ans,dp[i][d]);\n\n  return ans;\n}\n\nint main(){\n  int d,n,c;\n\n  while(1){\n    scanf(\"%d%d\",&d,&n);\n    if(d==0) break;\n\n    c = calc(d,n);\n    if(c!=INF)\n      printf(\"%d\\n\",c);\n    else\n      puts(\"NA\");\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nconst int MAX_V = 10000;\nstruct edge {};\nvector<edge> G[MAX_V];\n\n// ??§????????°INF\n#define INF (1e30)\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint D, N;\n\twhile (true) {\n\t\tcin >> D >> N; if (D == 0 && N == 0)break;\n\t\tvector<int> a(N), e(N), r(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tvector<vector<int>>dp(D+1,vector<int>(101,N));\n\t\tdp[D][0] = 0;\n\t\tfor (int i = D; i >= 0; ++i) {\n\t\t\tfor (int j = 0; j < 101; ++j) {\n\t\t\t\tif (dp[i][j] == INF)continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (j < r[k])continue;\n\t\t\t\t\tint tmp_i = max(0, i - a[k]), tmp_j = min(100, j + e[k]);\n\t\t\t\t\tdp[tmp_i][tmp_j] = min(dp[tmp_i][tmp_j], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 101; ++i)ans = min(ans, dp[0][i]);\n\t\tif (ans == INF) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b)(a=min(a,b))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100], e[100], r[100];\nint dp[101][101];\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\trep(i, n)scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\trep(i, 101)dp[0][i] = 0;\n\t\trep(i, d + 1)for (int j = 100; j >= 0; j--)rep(k, n) {\n\t\t\tif (j - e[k] >= r[k]) {\n\t\t\t\trep(t, a[k] + 1)rep(p, e[k] + 1)cmin(dp[min(d, i + t)][j - p], dp[i][j] + 1);\n\t\t\t}\n\t\t}\n\t\tif (dp[d][0] == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\", dp[d][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    int maxa = 0;\n    int flg = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      if(r[i] == 0 && a[i] != 0) flg = 1;\n      if(maxr < r[i]) maxr = r[i],maxa = a[i];\n    }\n\n    //cout <<\"maxr=\" << maxr <<endl;\n    //  cout << \"maxe=\"<<maxe <<endl;\n\n    int N = (d/maxa+1)*maxr;\n    for(int i=0;i<n;i++) \n      for(int j=n-1;j>i;j--)\n\tif(r[j] < r[j-1]) swap(r[j],r[j-1]);   \n\n    for(int i=0;i<=d;i++)\n      for(int j=0;j<=N;j++) \n\tdp[i][j] = INF;\n\n\n    dp[d][0] = 0;\n    \n    int ans = INF;\n    dp[d][0] = 0;\n    if(flg == 1) {\n      for(int j=0;j<=N;j++) { //?????¨???????¨????\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\t  for(int k=0;k<n;k++) {\n\t    int na = i + a[k];\n\t    int ne = j - e[k];\n\t    if(na > d) na = d;\n\t    if(ne < 0) ne = 0;\n\t    if(ne < r[k]) continue;\n\t    dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t  }\n\t}\n\tans = min(ans,dp[0][j]);\n      }\n    }\n\n\n    /*\n    for(int j=0;j<=N;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n    }\n    */\n    \n    \n\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n   \n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 1 << 29;\nint a[1100], e[1100], r[1100];\nint d, n;\n\n// ?¨??????????,??????????????°???????¨????\nint func(int hp, int m, int k){\n\tif(hp <= 0) return m;\n\tint res = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(k >= r[i]){\n\t\t\tres = min(res, func(hp - a[i], m + 1, k + e[i]));\n\t\t}\n\t}\n\tif(res == INF){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0; \n\t}\n\tif(m == 0){\n\t\tcout << res << endl;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> d >> n && (d || n)){\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tfunc(d, 0, 0);\n\t}\n\n\treturn 0;\n}\n\n/*\na ??????????????????\ne ??????????¨????\nr ??????????¨????\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint d, n, memo[110][110];\nvector <int> a, e, r;\nconst int INF = 100000000;\n\nint rec(int c = 0, int exp = 0, int end = d) {\n\tif (end <= 0) {\n\t\treturn 0;\n\t}\n\tif (memo[exp][end] != -1) {\n\t\treturn memo[exp][end];\n\t}\n\tif (c >= 200) {\n\t\treturn INF;\n\t}\n\n\tint res = INF;\n\trep (i, n) {\n\t\tif (exp < r[i]) continue;\n\t\tif (a[i] == 0 && e[i] == 0) continue;\n\t\tres = min(res, rec(c + 1, min(exp + e[i], 105), end - a[i]) + 1);\n\t}\n\treturn memo[exp][end] = res;\n}\n\nint main() {\n\twhile (cin >> d >> n, d) {\n\t\ta = e = r = vector <int> (n);\n\t\trep (i, n) cin >> a[i] >> e[i] >> r[i];\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tint ans = rec();\n\t\tcout << (ans == INF ? \"NA\" : to_string(ans)) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,s;\nvector<pair<pair<int,int>,int> >v;\nvoid dfs(int p,int x,int t){\n  if(t>=s)return;\n  if(p<0){s=t;return;}\n  if(x>10000)return;\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x)dfs(p-v[i].f.f,x+v[i].f.s,t+1);\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();s=1000000;\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end());\n    dfs(d,0,0);\n    if(s!=10000000)cout<<\"NA\"<<endl;\n    else cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint D,N;\nint a[100],e[100],r[100];\n\nconst int INF=1234567;\nint dp[101][101];\nint dfs(int rem, int ex)\n{\n    if(rem==0) return 0;\n    if(dp[rem][ex]>=0) return dp[rem][ex];\n\n    int ret=INF;\n    rep(i,N)\n    {\n        if(a[i]==0) continue;\n        if(ex<r[i]) continue;\n\n        int nr=max(0,rem-a[i]);\n        int ne=min(100,ex+e[i]);\n        ret=min(ret,dfs(nr,ne)+1);\n    }\n\n    return dp[rem][ex]=ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d\", &D, &N),D)\n    {\n        rep(i,N) scanf(\" %d %d %d\", &a[i], &e[i], &r[i]);\n        memset(dp,-1,sizeof(dp));\n        int ans=dfs(D,0);\n        if(ans==INF) printf(\"NA\\n\");\n        else printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define uch unsigned char\nusing namespace std;\nint D, N, w, a[111], e[111], r[111]; uch dp[111][111][222];\nuch rec(uch f1, uch f2, uch d) {\n\tif (f1 >= D) return d;\n\tif (dp[f1][f2][d]) return dp[f1][f2][d] - 1;\n\tuch ret = 255;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!a[i] && (!e[i] || f2 == w)) continue;\n\t\tif (f2 >= r[i]) ret = min(ret, rec(f1 + a[i], min(f2 + e[i], w), d + 1));\n\t}\n\tdp[f1][f2][d] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> D >> N, D | N) {\n\t\tfor (int i = 0; i < N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tw = *max_element(r, r + N);\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j <= w; j++) {\n\t\t\t\tfor (int k = 0; k < N * 2; k++) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = rec(0, 0, 0);\n\t\tif (ret == 255) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nconst int MAX_V = 10000;\nstruct edge {};\nvector<edge> G[MAX_V];\n\n// ??§????????°INF\n#define INF (1<<30)\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint D, N;\n\twhile (true) {\n\t\tcin >> D >> N; if (D == 0 && N == 0)break;\n\t\tvector<int> a(N), e(N), r(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tvector<vector<int>>dp(D+1,vector<int>(101,INF));\n\t\tdp[D][0] = 0;\n\t\tfor (int i = D; i >= 0; --i) {\n\t\t\tfor (int j = 0; j < 101; ++j) {\n\t\t\t\tif (dp[i][j] == INF)continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (j < r[k])continue;\n\t\t\t\t\tint tmp_i = max(0, i - a[k]), tmp_j = min(100, j + e[k]);\n\t\t\t\t\tdp[tmp_i][tmp_j] = min(dp[tmp_i][tmp_j], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 101; ++i)ans = min(ans, dp[0][i]);\n\t\tif (ans == INF) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint dp[110][110];\nstruct S {\n\tint a, e, r;\n\tbool operator <(const S& x) const {\n\t\treturn r < x.r;\n\t}\n} t[100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint D, N;\n\twhile(cin >> D >> N, D) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> t[i].a >> t[i].e >> t[i].r;\n\t\t}\n\t\tsort(t, t + N);\n\n\t\tconst int INF = 1 << 25;\n\t\tfill((int*)begin(dp), (int*)end(dp), INF);\n\t\tdp[0][D] = 0;\n\n\t\ttypedef pair<int, int> P;\n\t\tqueue<P> q;\n\t\tq.push({ 0, D });\n\t\twhile(q.size()) {\n\t\t\tint ex = q.front().first, d = q.front().second;\n\t\t\tq.pop();\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tif(ex < t[i].r) continue;\n\t\t\t\tint nex = ex + t[i].e, nd = max(0, d - t[i].a);\n\t\t\t\tif(dp[nex][nd] > dp[ex][d] + 1) {\n\t\t\t\t\tdp[nex][nd] = dp[ex][d] + 1;\n\t\t\t\t\tq.push({ nex, nd });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int j = 0; j <= 100; j++) {\n\t\t\tans = min(ans, dp[j][0]);\n\t\t}\n\t\tif(ans == INF) cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define LOOP(i,x,n) for(int i=(x);i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e10;\n\nusing namespace std;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\nsigned main(){\n  int d,n;\n  while(cin>>d>>n,d){\n    bool flag=false;\n    vector<int> a(n),e(n),r(n);\n    REP(i,n){\n      cin>>a[i]>>e[i]>>r[i];\n      if(r[i]==0)flag=true;\n    }\n    if(!flag){\n      cout<<\"NA\"<<endl;\n\n    }else{\n      int dp[201][201]={};\n      bool used[201][201]={};\n\n      REP(i,n){\n        if(r[i]==0){\n          dp[0][e[i]]=a[i];\n          used[0][e[i]]=true;\n        }\n      }\n\n      REP(i,101){\n        REP(j,101){\n          if(used[i][j]){\n            REP(k,n){\n              if(j-r[k]>=0){\n              used[i+1][j+e[k]>=100?100:j+e[k]]=true;\n              cmax(dp[i+1][j+e[k]>=100?100:j+e[k]],dp[i][j]+a[k]);\n              }\n            }\n          }\n        }\n      }\n      // REP(i,30)cout<<i<<' ';\n      // cout<<endl;\n      // REP(i,15){\n      //   REP(j,101){\n      //     cout<<dp[i][j]<<' ';\n      //   }\n      //   cout<<endl;\n      // }cout<<endl;\n      bool f=false;\n      REP(i,101){\n        REP(j,101){\n          if(dp[i][j]>=d){\n            cout<<i+1<<endl;\n            f=true;\n            break;\n          }\n        }\n        if(f)break;\n      }\n\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][11111];\nint solve(int d, int exp){\n    if(d <= 0) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            res = min(res, 1+solve(d-a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(D,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 1 << 29;\nint a[110], e[110], r[110];\nint d, n;\n// dp[?????????][????¨????] = ????°?????????°\nint dp[110][110];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> d >> n && (d || n)){\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tfor(int i = 0; i < 110; ++i){\n\t\t\tfor(int j = 0; j < 110; ++j){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][0] = 0;\n\t\tfor(int i = 0; i <= d; ++i){\n\t\t\tfor(int j = 0; j <= 100; ++j){\n\t\t\t\tfor(int k = 0; k < n; ++k){\n\t\t\t\t\tif(j >= r[k]){\n\t\t\t\t\t\tint nd = min(i + a[k], d);\n\t\t\t\t\t\tint ne = min(j + e[k], 100);\n\t\t\t\t\t\tdp[nd][ne] = min(dp[nd][ne], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int j = 0; j <= 100; ++j){\n\t\t\tans = min(ans, dp[d][j]);\n\t\t}\n\t\tif(ans != INF)\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn 0;\n}\n\n/*\n// ?¨??????????,??????????????°???????¨????\nint func(int hp, int m, int k){\n\tif(hp <= 0) return m;\n\tint res = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(k >= r[i]){\n\t\t\tres = min(res, func(hp - a[i], m + 1, k + e[i]));\n\t\t}\n\t}\n\tif(res == INF){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0; \n\t}\n\tif(m == 0){\n\t\tcout << res << endl;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> d >> n && (d || n)){\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tfunc(d, 0, 0);\n\t}\n\n\treturn 0;\n}\n*/\n/*\na ??????????????????\ne ??????????¨????\nr ??????????¨????\n*/"
  },
  {
    "language": "C++",
    "code": "require 'set'\n\ndef bfs(start_node, extra = nil)\n    return 0 if start_node.is_goal?(extra)\n    reached = Set[start_node]\n    dist = 1\n    queue = [start_node]\n    until queue.empty?\n        next_queue = []\n        until queue.empty?\n            node = queue.shift\n            node.each_next_node(extra) do |next_node|\n                return dist if next_node.is_goal?(extra)\n                next if reached.include?(next_node)\n                reached << next_node\n                next_queue << next_node\n            end\n        end\n        dist += 1\n        queue = next_queue\n    end\n    return nil\nend\n\nclass Array\n    def is_goal?(extra)\n        self[0] <= 0\n    end\n\n    def each_next_node(extra)\n        d, t = self\n        (extra[:valid_weapons][t] || []).each do |a, e|\n            ne = t + e\n            ne = extra[:max_e] if ne > extra[:max_e]\n            yield [d - a, ne]\n        end\n    end\nend\n\nloop do\n    d, n = gets.split.map(&:to_i)\n    break if n == 0\n    weapons = (1..n).map { gets.split.map(&:to_i) }\n    weapons.sort_by!(&:last)\n    valid_weapons = {}\n    (0..weapons[-1][2]).each do |t|\n        l = weapons.select {|a, e, r| r <= t}\n        l.map! {|a, e, _| [a, e]}\n        l.uniq!\n        l = l.select {|a1, e1| l.all?{|a2, e2| (a1 == a2 && e1 == e2) || (a1 > a2 || e1 > e2)}}\n        valid_weapons[t] = l\n    end\n    puts bfs([d, 0], {:valid_weapons => valid_weapons, :max_e => weapons[-1][2]}) || 'NA'\nend\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<list>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\nstruct c {\n\tint d, e, f;\n};\nc k[100];\nint a, b;\nint saiki(int n, int m) {//????????????n??§????¨???????m\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (k[i].f <= m) {\n\t\t\tif (k[i].d >= n)return 1;\n\t\t\tMIN = min(MIN, 1+saiki(n-k[i].d, min(100, k[i].e + m)));\n\t\t}\n\t}\n\treturn MIN;\n}\nint main() {\n\twhile (cin >> a >> b, a | b) {\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tint h, i, j; scanf(\"%d%d%d\", &h, &i, &j);\n\t\t\tk[g] = { h,i,j };\n\t\t}\n\t\tint S = saiki(a, 0);\n\t\tif (S >= 1 << 29) { puts(\"NA\"); }\n\t\telse cout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<10003;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\nif(n==1)return 1;\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define LOOP(i,x,n) for(int i=(x);i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e10;\n\nusing namespace std;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\nsigned main(){\n  int d,n;\n  while(cin>>d>>n,d){\n    bool flag=false;\n    vector<int> a(n),e(n),r(n);\n    REP(i,n){\n      cin>>a[i]>>e[i]>>r[i];\n      if(r[i]==0)flag=true;\n    }\n    if(flag==false){\n      cout<<\"NA\"<<endl;\n\n    }else{\n      int dp[201][201]={};\n      int used[201][201]={};\n\n      REP(i,n){\n        if(r[i]==0){\n          dp[0][e[i]]=a[i];\n          used[0][e[i]]=1;\n        }\n      }\n\n      REP(i,101){\n        REP(j,101){\n          if(used[i][j]){\n            REP(k,n){\n              if(j-r[k]>=0){\n              used[i+1][j+e[k]>=100?100:j+e[k]]=1;\n              cmax(dp[i+1][j+e[k]>=100?100:j+e[k]],dp[i][j]+a[k]);\n              }\n            }\n          }\n        }\n      }\n      // REP(i,30)cout<<i<<' ';\n      // cout<<endl;\n      // REP(i,15){\n      //   REP(j,101){\n      //     cout<<dp[i][j]<<' ';\n      //   }\n      //   cout<<endl;\n      // }cout<<endl;\n      bool f=false;\n      REP(i,201){\n        REP(j,101){\n          if(dp[i][j]>=d){\n            cout<<i+1<<endl;\n            f=true;\n            break;\n          }\n        }\n        if(f)break;\n      }\n\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main(){\n  int D, N, a[100], e[100], r[100];\n  while(cin >> D >> N, D){\n    for(int i = 0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    vector< vector< int > > dp(D + 1, vector< int >( 101, INF));\n    dp[D][0] = 0;\n    for(int i = D; i > 0; i--){\n      for(int j = 0; j <= 100; j++){\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < N; k++){\n          if(j < r[k]) continue;\n          dp[max( 0, i - a[k])][min( 100, j + e[k])] = min( dp[max( 0, i - a[k])][min( 100, j + e[k])], dp[i][j] + 1);\n        }\n      }\n    }\n    int ret = INF;\n    for(int i = 0; i < 101; i++) ret = min( ret, dp[0][i]);\n    if(ret == INF) cout << \"NA\" << endl;\n    else cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint dp[101][101];\n\nvoid solve()\n{\n\tfill_n(*dp, 101 * 101, 1 << 28);\n\tdp[0][0] = 0;\n\n\tfor (int i = 0; i < d; i++){\n\t\tfor (int j = 0; j <= 100; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tif (j < r[k]) continue;\n\t\t\t\tint nd = min(d, i + a[k]);\n\t\t\t\tint ne = min(100, j + e[k]);\n\t\t\t\tdp[nd][ne] = min(dp[nd][ne], dp[i][j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = 1 << 28;\n\tfor (int i = 0; i <= 100; i++){\n\t\tres = min(res, dp[d][i]);\n\t}\n\n\tif (res == (1 << 28)) cout << \"NA\" << endl;\n\telse cout << res << endl;\n}\n\nint main()\n{\n\twhile (cin >> d >> n, d){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint D, n;\nint a[100], e[100], d[100];\nint memo[110][110];\n\nint dfs(int tai, int ex){\n\n  if(tai <= 0){\n    return 0;\n  }\n\n  if(memo[tai][ex] != -1){\n    return memo[tai][ex];\n  }\n\n  int ans = 100000000;\n\n  for(int i = 0;i < n;i++){\n    if((a[i] != 0 && d[i] <= ex) || (a[i] == 0 && d[i] <= ex && ex < 100)){\n      ans = min(ans, dfs(tai-a[i], min(ex+e[i],100))+1);\n    }\n  }\n\n  return memo[tai][ex] = ans;\n}\n\nint main(){\n  while(cin >> D >> n, D != 0){\n    bool zeroFrag = false;\n    for(int i = 0;i < n;i++){\n      cin >> a[i] >> e[i] >> d[i];\n      if(a[i] == 0 && e[i] == 0){\n        i--;\n        n--;\n      }else if(d[i] == 0){\n        zeroFrag = true;\n      }\n    }\n\n    if(zeroFrag){\n      memset(memo,-1,sizeof(memo));\n      int ans = dfs(D, 0);\n      if(ans >= 100000000){\n        cout << \"NA\" << endl;\n      }else{\n        cout << ans << endl;\n      }\n    }else{\n      cout << \"NA\" << endl;\n    }\n\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 110\n#define MAX_R 110\n#define MAX_D 110\n \nstruct State{\n    int r,d;\n    State(){}\n    State(int r,int d) : r(r),d(d) {}\n};\n \nint D,N;\nint a[MAX_N],e[MAX_N],r[MAX_N];\n \nint bfs(){\n    queue<State> Q; Q.push(State(0,D));\n    queue<int> step; step.push(0);\n    bool visited[MAX_R][MAX_D] = {{false}};\n    visited[0][D] = true;\n    while(!Q.empty()){\n\tState s = Q.front(); Q.pop();\n\tint stp = step.front(); step.pop();\n\tif(s.d == 0){ return stp; }\n\tfor(int i = 0 ; i < N ; i++){\n\t    State ns = (State){min(100,s.r+e[i]),max(0,s.d-a[i])};\n\t    if(s.r >= r[i] && !visited[ns.r][ns.d]){\n\t\tvisited[ns.r][ns.d] = true;\n\t\tQ.push(ns);\n\t\tstep.push(stp+1);\n\t    }\n\t}\n    }\n    return -1;\n}\n \nint main(){\n    while(cin >> D >> N, D){\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> a[i] >> e[i] >> r[i];\n\t}\n\tint res = bfs();\n\tif(res == -1){\n\t    cout << \"NA\" << endl;\n\t}else{\n\t    cout << res << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//道具を使う順番もあまり関係なかったりする。でも素直に耐久力と経験値に注目しちゃえば良い。\n//stack使う＆遷移後枝刈り→TLE(1ケース1秒)、遷移前枝刈りにする→TLE(1ケース0.2秒くらい？)、\n//stackっぽいものを配列で自作→？？\n#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nint d, n;\nint a[100], e[100], r[100];\n\nsigned main() {\n\twhile( cin >> d >> n ) {\n\t\tif(!d) break;\n\t\tint i, j;\n\t\tfor( i = 0; i < n; i++ )\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t\n\t\tint dp[101][101];\t\t//dp[残り耐久力][min(EXP,100)]\n\t\tfor( i = 0; i < 101; i++ ) {\n\t\t\tfor( j = 0; j < 101; j++ ) {\n\t\t\t\tdp[i][j] = 1000000;\n\t\t\t}\n\t\t}\n\t\tint data[10000], dnum = 0;\n\t\tdata[dnum++] = ((0)<<(20)) + ((d)<<(10)) + ((0)<<(0));\n\t\t\n\t\twhile( dnum > 0 ) {\n\t\t\tint Cost = (data[dnum-1]>>(20));\n\t\t\tint Dif = (data[dnum-1]>>(10)) % (1<<(10));\n\t\t\tint Exp = (data[dnum-1]) % (1<<(10));\n\t\t\t\n\t\t\tdnum--;\n\t\t\tdp[Dif][Exp] = Cost;\n\t\t\t\n\t\t\tfor( i = 0; i < n; i++ ) {\n\t\t\t\tif( Exp >= r[i] ) {\n\t\t\t\t\t//殴る\n\t\t\t\t\tint nCost = Cost+1;\n\t\t\t\t\tint nDif = max(0, Dif - a[i]);\n\t\t\t\t\tint nExp = min(100, Exp + e[i]);\n\t\t\t\t\t//枝刈り\n\t\t\t\t\tif( dp[nDif][nExp] <= nCost )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//遷移する\n\t\t\t\t\tdata[dnum++] = (nCost<<(20)) + (nDif<<(10)) + (nExp<<(0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 100000;\n\t\tfor( i = 0; i < 101; i++ ) {\n\t\t\tif( dp[0][i] < 10000 ) {\n\t\t\t\tans = min(dp[0][i], ans);\n\t\t\t}\n\t\t}\n\t\tif( ans < 10000 )\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint ans;\nint dp[101][101];\n\nint solve(int hp, int exp) {\n\n    if(hp <= 0) {\n        return 0;\n    }\n\n    if(dp[hp][exp] != -1) {\n        return dp[hp][exp];\n    }\n\n    int ret = INF;\n    for(int i = 0; i < n; ++i) {\n        if(exp >= r[i]) {\n            ret = min(ret, solve(hp - a[i], exp + e[i]) + 1);\n        }\n    }\n\n    return dp[hp][exp] = ret;\n}\n\nint main() {\n\n    while(cin >> d >> n, d || n) {\n\n        for(int i = 0; i < n; ++i) {\n            cin >> a[i] >> e[i] >> r[i];\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        ans = solve(d, 0);\n\n        if(ans == INF) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <ctime>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n    int maxr,maxe,mina,flg;\n    maxr=maxe=flg=0;\n    maxr = -1;\n    mina = INF;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n    }\n\n    int N = 101;\n    int ans = INF;\n    \n    for(int i=0;i<=d;i++) for(int j=0;j<=N;j++)dp[i][j] = INF;\n    dp[d][0] = 0;\n\n    int cnt = 0;\n    int c = 0;\n      for(int j=0;j<=N;j++) { //?????¨???????¨????\n\tcnt++;\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\t  if(dp[i][j] == INF) continue;\n\t  for(int k=0;k<n;k++) {\n\t    if(j < r[k]) continue;\n\t    c++;\n\t    int na = i - a[k];\n\t    int ne = j + e[k];\n\t    if(na < 0) na = 0;\n\t    if(ne > N) ne = N;\n\t    dp[na][ne] = min(dp[i][j]+1,dp[na][ne]);\n\t  }\n\t}\n\tans = min(ans,dp[0][j]);\n      }\n\n\n      /*      \n    for(int j=0;j<=cnt;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n    }\n      */\n      \n\n      //      cout <<\"time=\"<< clock() <<endl;   \n      //cout << c<<endl; \n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n   \n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>=d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define BE(c) c.begin(),c.end()\nusing namespace std;\nint DP[201][201][201];\ntypedef int ut;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<ppr> Vppr;\nVppr v;\nconst int INF=1<<30;\nint main() {\n\tint D,N,a,e,r;\n\tcin.tie(0);\nwhile(cin >> D >> N && N){\n\t\n\tREP(i,N){\n\t\tcin >> a >> e >> r;\n\t\tv.push_back(ppr(r,pr(a,e)));\n\t}\n\tREP(i,101) REP(j,101) REP(k,101) DP[i][j][k]=INF;\n\tDP[0][0][0]=0;\n\tsort(BE(v));\n\tREP(i,N){\n\t\tREP(j,D+1){\n\t\t\tREP(k,101){\n\t\t\t\tif(k>=v[i].first)\n\t\t\t\t\tDP[i][min(j+v[i].second.first,D)][min(100,k+v[i].second.second)]\n\t\t\t\t\t=min(DP[i][min(j+v[i].second.first,D)][min(100,k+v[i].second.second)],DP[i][j][k]+1);\n\t\t\t\tDP[i+1][j][k]=DP[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tint minium=INF;\n\tREP(i,101)\n\t\tminium=min(minium,DP[N][D][i]);\n\tif(minium==INF) cout << \"NA\" << endl;\n\telse cout << minium << endl;\n\tv.clear();\n}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr,maxe,maxa,flg;\n    maxr=maxe=maxa=flg=0;\n    maxr = -1;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      if(r[i] == 0 && a[i] != 0) flg = 1;\n      if(maxr < r[i]) maxr = r[i],maxa = a[i];\n    }\n\n    for(int i=0;i<n;i++) \n      for(int j=n-1;j>i;j--)\n\tif(r[j] < r[j-1]) swap(r[j],r[j-1]);   \n\n    int ans = INF;\n    if(flg == 1) {\n      int N = (d/maxa+1)*maxr;\n      \n    for(int i=0;i<=d;i++)\n      for(int j=0;j<=N;j++) \n\tdp[i][j] = INF;\n    dp[d][0] = 0;\n\n      for(int j=0;j<=N;j++) { //?????¨???????¨????\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\t  for(int k=0;k<n;k++) {\n\t    int na = i + a[k];\n\t    int ne = j - e[k];\n\t    if(na > d) na = d;\n\t    if(ne < 0) ne = 0;\n\t    if(ne < r[k]) continue;\n\t    dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t  }\n\t}\n\tans = min(ans,dp[0][j]);\n      }\n    }\n\n\n    /*\n    for(int j=0;j<=N;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n    }\n    */\n    \n    \n\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n   \n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 101\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N2;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(j+e[k]>=N2){\n\t      if(dp[i+a[k]][N2-1]>dp[i][j]+1) dp[i+a[k]][N2-1]=dp[i][j]+1;\n\t    }\n\t    else if(dp[i+a[k]][j+e[k]]>dp[i][j]+1) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint D, N;\nvector<int> a(110), e(110), r(110); //耐久力 経験値 必要な経験値\nint dp[110][11000]; //耐久力 i の時に 経験値 j の時の回数\n\nint solve(int d, int exp){\n\tint ret = 10e8;\n\tif(d <= 0) return 0;\n\tif(dp[d][exp] != -1) return dp[d][exp];\n\tfor(int i=0; i< N; i++){\n\t\tint E = min(110, exp+e[i]);\n\t\tif(r[i] <= exp) ret = min(ret, solve(d-a[i], E)+1);\n\t}\n\tdp[d][exp] = ret;\n\treturn ret;\n}\n\nint main(){\n\twhile(cin >> D >> N, D+N){\n\t\tfor(int i=0; i< N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tfor(int i=0; i < 110; i++)for(int j=0; j< 11000; j++) dp[i][j] = -1;\n\t\tint ret = solve(D, 0);\n\t\tif(ret == 10e8) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 100*100+50\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t      if(dp[i+a[k]][j+e[k]]>dp[i][j]+1) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define INF (2 << 28)\nusing namespace std;\n\nint main(){\n    \n    int d, n, dp[111][111];\n    int a[111], e[111], r[111];\n    \n    while(cin >> d >> n, d||n){\n        for(int i = 0; i < n; i++) cin >> a[i] >> e[i] >> r[i];\n        fill_n(*dp, 111*111, INF);\n        dp[d][0] = 0;\n        for(int i = d; i >= 0; i--){\n            for(int j = 0; j <= 100; j++){\n                for(int k = 0; k < n; k++){\n                    if(r[k] <= j)\n                       dp[max(0, i - a[k])][min(100, j + e[k])]  = min(dp[max(0, i - a[k])][min(100, j + e[k])], dp[i][j]  + 1);\n                }\n            }\n        }\n        int res = *min_element(dp[0], dp[0] + 101);\n        if(res == INF) cout << \"NA\" << endl;\n        else cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nint D,N;\n\nstruct Info{\n\tInfo(){\n\t\tattack = exp = r_exp = -1;\n\t\tunuse = false;\n\t}\n\tInfo(int arg_attack,int arg_exp,int arg_r_exp){\n\t\tattack = arg_attack;\n\t\texp = arg_exp;\n\t\tr_exp = arg_r_exp;\n\t\tunuse = false;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn r_exp > arg.r_exp;\n\t};\n\n\tint attack,exp,r_exp;\n\tbool unuse;\n};\n\nstruct Data{\n\tint current_exp,rest_D,count;\n};\n\n\nvoid func(){\n\n\tint a,e,r;\n\tpriority_queue<Info> S;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&a,&e,&r);\n\t\tS.push(Info(a,e,r));\n\t}\n\n\tInfo info[N];\n\n\tint index = 0;\n\n\twhile(!S.empty()){\n\t\tinfo[index].attack = S.top().attack;\n\t\tinfo[index].exp = S.top().exp;\n\t\tinfo[index].r_exp = S.top().r_exp;\n\t\tindex++;\n\t\tS.pop();\n\t}\n\n\t//??¨????????????????????¨????????????????????????\n\tint a_num = 0,e_num = 0;\n\tfor(int i = 0; info[i].r_exp == 0; i++){\n\t\tif(info[i].attack > 0){\n\t\t\ta_num++;\n\t\t}\n\t\tif(info[i].exp > 0){\n\t\t\te_num++;\n\t\t}\n\t}\n\n\tif(a_num == 0 && e_num == 0){\n\t\tprintf(\"NA\\n\");\n\t\treturn;\n\t}else{\n\n\t\tif(a_num == 0 && e_num > 0){ //????¨??????????????????????????????¨??????????????????????????????\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(info[i].attack > 0)a_num++;\n\t\t\t}\n\n\t\t\tif(a_num == 0){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = -1;\n\n\tqueue<Data> Q;\n\n\tData first;\n\tfirst.current_exp = 0;\n\tfirst.rest_D = D;\n\tfirst.count = 0;\n\n\tQ.push(first);\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().rest_D <= 0){\n\t\t\tans = Q.front().count;\n\t\t\tbreak;\n\t\t}\n\n\t\t//??????????????????????¨?????????????????????????????????????????????¨???????????°???????????¨????????¨????????????\n\t\t//????????????????????????0????????°?????¨?????????\n\t\tfor(int i = 0; info[i].r_exp <= Q.front().current_exp;i++){\n\t\t\tif((info[i].unuse == true) || (info[i].attack <= 0 && info[i].exp <= 0))continue;\n\t\t\tFLG = true;\n\t\t\tfor(int k = 0; info[k].r_exp <= Q.front().current_exp;k++){\n\t\t\t\tif(i != k && ((info[i].exp <= info[k].exp && info[i].attack < info[k].attack) || (info[i].exp < info[k].exp && info[i].attack <= info[k].attack))){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tinfo[i].unuse = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG == true){\n\t\t\t\tData new_data;\n\t\t\t\tnew_data.count = Q.front().count+1;\n\t\t\t\tnew_data.current_exp = Q.front().current_exp+info[i].exp;\n\t\t\t\tnew_data.rest_D = Q.front().rest_D - info[i].attack;\n\t\t\t\tQ.push(new_data);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tif(ans == -1){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&D,&N);\n\t\tif(D == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][11111];\nint solve(int d, int exp){\n    if(d <= 0) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(a[i]==0) continue;\n        if(r[i] <= exp){\n            res = min(res, 1+solve(d-a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(D,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tint D,N,a[101],e[100],r[100];\n\twhile(scanf(\"%d%d\",&D,&N),D!=0){\n\t\tfor(int i=0;i<N;i++) scanf(\"%d%d%d\",&a[i],&e[i],&r[i]);\n\t\tint res=0,m=100,ex=0; a[100]=0;\n\t\twhile(D>0){\n\t\t\tfor(int i=0;i<N;i++) if(r[i]<=ex) if(a[i]>a[m]) m=i; else if(a[i]==a[m]&&e[i]>e[m]) m=i;\n\t\t\tif(m==100) break;\n\t\t\tD-=a[m];\n\t\t\tex+=e[m];\n\t\t\tres++;\n\t\t}\n\t\tif(res>0) printf(\"%d\\n\",res);\n\t\telse printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][100000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=70)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint D, N;\nvector<int> a(110), e(110), r(110); //耐久力 経験値 必要な経験値\nint dp[110][11000]; //耐久力 i の時に 経験値 j の時の回数\n\nint solve(int d, int exp){\n\tint ret = 10e8;\n\tif(d <= 0) return 0;\n\tif(dp[d][exp] != -1) return dp[d][exp];\n\tfor(int i=0; i< N; i++){\n\t\tif(r[i] <= exp) ret = min(ret, solve(d-a[i], exp+e[i])+1);\n\t}\n\tdp[d][exp] = ret;\n\treturn ret;\n}\n\nint main(){\n\twhile(cin >> D >> N, D+N){\n\t\tfor(int i=0; i< N; i++){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t\tif(a[i] == 0 && e[i] == 0) r[i] = 10e8;\n\t\t}\n\t\tfor(int i=0; i < 110; i++)for(int j=0; j< 11000; j++) dp[i][j] = -1;\n\t\tint ret = solve(D, 0);\n\t\tif(ret == 10e8) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 0288.cc: Knocker of the Gigas Cedar\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_R = 100;\nconst int MAX_D = 100;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\n/* global variables */\n\nint as[MAX_N], es[MAX_N], rs[MAX_N];\nint dp[2][MAX_R + 1][MAX_D + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int d, n;\n    cin >> d >> n;\n    if (d == 0) break;\n\n    int maxr = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> as[i] >> es[i] >> rs[i];\n      if (maxr < rs[i]) maxr = rs[i];\n    }\n\n    for (int i = 0; i <= maxr; i++)\n      for (int j = 0; j <= d; j++) dp[0][i][j] = dp[1][i][j] = INF;\n\n    int cur = 0, nxt = 1;\n    dp[cur][0][0] = 0;\n\n    int mind = INF;\n    bool cont = true;\n\n    while (mind >= INF && cont) {\n      cont = false;\n\n      memcpy(dp[nxt], dp[cur], sizeof(dp[cur]));\n      for (int i = 0; i <= maxr; i++)\n\tfor (int j = 0; j <= d; j++)\n\t  if (dp[cur][i][j] < INF) {\n\t    int ndp = dp[cur][i][j] + 1;\n\t    for (int k = 0; k < n; k++)\n\t      if (i >= rs[k]) {\n\t\tint i0 = i + es[k];\n\t\tif (i0 > maxr) i0 = maxr;\n\t\tint j0 = j + as[k];\n\t\tif (j0 > d) j0 = d;\n\t\tif (dp[nxt][i0][j0] > ndp) {\n\t\t  dp[nxt][i0][j0] = ndp;\n\t\t  if (j0 == d && mind > ndp) mind = ndp;\n\t\t  cont = true;\n\t\t}\n\t      }\n\t  }\n\n      cur ^= 1, nxt ^= 1;\n    }\n\n    if (mind >= INF) puts(\"NA\");\n    else printf(\"%d\\n\", mind);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\n\n\n\nint main(){\n\t\n\tint l,N;\n\twhile(cin>>l>>N,l){\n\t\tvector<int>damage(N);\n\t\tvector<int>exp(N);\n\t\tvector<int>req(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>damage[i]>>exp[i]>>req[i];\n\t\t}\n\t\tvector<vector<int>>dp(l+1,vector<int>(101,MOD));\n\t\tdp[l][0]=0;\n\t\tfor(int i=l;i>0;i--){\n\t\t\tfor(int k=0;k<=100;k++){\n\t\t\t\tfor(int l=0;l<N;l++){\n\t\t\t\t\tif(k<req[l])continue;\n\t\t\t\t\tint left=max(0,i-damage[l]);\n\t\t\t\t\tint nxexp=min(100,k+exp[l]);\n\t\t\t\t\tdp[left][nxexp]=min(dp[left][nxexp],dp[i][k]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=MOD;\n\t\tfor(int i=0;i<=100;i++)ans=min(ans,dp[0][i]);\n\t\tif(ans==MOD)cout<<\"NA\\n\";\n\t\telse cout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][10001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n      maxe = max(maxe,e[i]);\n    }\n\n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=maxr+maxe;j++){\n\tdp[i][j] = INF;\n\tdp[d][0] = 0;\n      }\n  \n   \n    \n      for(int j=0;j<=maxr+maxe;j++) { //?????¨???????¨????\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\tfor(int k=0;k<n;k++) {\n\t  int na = i+a[k];\n\t  int ne = j-e[k];\n\t  if(na > d) na = d;\n\t  if(j-e[k] < 0) ne = 0;\n\t  if(ne < r[k]) continue;\n\t  dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t\n\t}\n      }\n    }\n      \n      /*\n    for(int j=0;j<=maxr+maxe;j++) { //?????¨???????¨????\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n      }\n      */\n\n\n    int ans = INF;\n    for(int i=0;i<=maxr+maxe;i++)  ans = min(ans,dp[0][i]);\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\twhile (true){\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (R[i]>R[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = R[i]; j <= 109; j++){\n\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\tif(j+E[i]<=109)DP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\telse DP[109][k + 1] = max(DP[109][k + 1], DP[j][k] + A[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nint D, N;\nint dp[101][101];\nint A[100], E[100], R[100];\n\nint main(){\n    while(scanf(\"%d %d\", &D, &N), D || N){\n        for(int i=0;i<N;i++){\n            scanf(\"%d %d %d\", A+i, E+i, R+i);\n        }\n\n        for(int i=0;i<=D;i++){\n            for(int j=0;j<=100;j++){\n                dp[i][j] = 1001001001;\n            }\n        }\n\n        dp[D][0] = 0;\n        for(int i=D;i>=0;i--){\n            for(int j=100;j>=0;j--){\n                if(j < 100){dp[i][j] = std::min(dp[i][j], dp[i][j+1]);}\n                \n                for(int k=0;k<N;k++){\n                    if(j >= R[k]){\n                        int ni = std::max(i-A[k],0),\n                            nj = std::min(j+E[k],100);\n                        dp[ni][nj] = std::min(dp[ni][nj], dp[i][j] + 1);\n                    }\n                }\n            }\n        }\n\n        // for(int i=0;i<=D;i++){\n        //     for(int j=0;j<16;j++){\n        //         printf(\"%d \", dp[i][j]);\n        //     }\n        //     puts(\"\");\n        // }\n\n        if(dp[0][0] != 1001001001){printf(\"%d\\n\", dp[0][0]);}\n        else{puts(\"NA\");}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\n\nint dp[111][111];\nint solve(int d, int exp){\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    if(d <= 0) return 0;\n    res = INT_MAX;\n    rep(i,N){\n        if(r[i] > exp) continue;\n        res = min(res, 1+solve(d-a[i], exp+e[i]));\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(D,0);\n        if(ans == INT_MAX) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define LOOP(i,x,n) for(int i=(x);i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e10;\n\nusing namespace std;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\nsigned main(){\n  int d,n;\n  while(cin>>d>>n,d){\n    bool flag=false;\n    vector<int> a(n),e(n),r(n);\n    REP(i,n){\n      cin>>a[i]>>e[i]>>r[i];\n      if(r[i]==0)flag=true;\n    }\n    if(!flag){\n      cout<<\"NA\"<<endl;\n\n    }else{\n      int dp[201][201];\n\n      REP(i,n){\n        if(r[i]==0)dp[0][e[i]]=a[i];\n      }\n\n      REP(i,101){\n        REP(j,101){\n          REP(k,n){\n            if(dp[i][j]>0&&j-r[k]>=0){\n              cmax(dp[i+1][j+e[k]>=100?100:j+e[k]],dp[i][j]+a[k]);\n            }\n          }\n        }\n      }\n      // REP(i,30)cout<<i<<' ';\n      // cout<<endl;\n      // REP(i,10){\n      //   REP(j,30){\n      //     cout<<dp[i][j]<<' ';\n      //   }\n      //   cout<<endl;\n      // }cout<<endl;\n      bool f=false;\n      REP(i,101){\n        REP(j,101){\n          if(dp[i][j]>=d){\n            cout<<i+1<<endl;\n            f=true;\n            break;\n          }\n        }\n        if(f)break;\n      }\n\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint dp[100][101];\t//??¨?????????,?????????????¨???°(100??§????????????)\n\nint n;\nint a[100],e[100],r[100];\t//??????????¨??????¶???\n\nint solve(int dNow,int eNow){\n\tif(dNow<0) return 0;\t//?????????????????????\n\tif(dp[dNow][eNow]!=-1) return dp[dNow][eNow];\n\n\tint ans=114514;\n\tfor(int i=0;i<n;i++){\n\t\tif(eNow<r[i]) continue;\n\t\tans=min(ans,1+solve(dNow-a[i],min(eNow+e[i],100)));\n\t}\n\n\tdp[dNow][eNow]=ans;\n\treturn ans;\n}\n\nint main(){\n\tint d;\t//??¨????????????\n\tint i,j;\n\tbool able;\n\twhile(cin>>d,d>0){\n\t\tcin>>n;\n\t\table=false;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>a[i]>>e[i]>>r[i];\n\t\t\tif(r[i]==0) able=true;\n\t\t}\n\t\tif(!able){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<100;i++){\n\t\t\tfor(j=0;j<101;j++){\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tcout<<solve(d-1,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint main(){\n\tint d, n;\n\twhile(cin >> d >> n, d||n){\n\t\tvector<int> a(n), e(n), r(n);\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tconst int INF = 100000;\n\n\t\tvector<vector<int>> dp(1000, vector<int>(1000, INF));\n\t\tdp[d][0] = 0;\n\t\tfor(int i = d; i >= 0; i--){\n\t\t\trep(j,101){\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\t\tif(r[k] > j) continue;\n\t\t\t\t\tint y = max(i - a[k], 0);\n\t\t\t\t\tint x = min(100, j + e[k]);\n\t\t\t\t\tdp[y][x] = min(dp[y][x], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(i,101){\n\t\t\tans = min(ans, dp[0][i]);\n\t\t}\n\n\t\tif(ans == INF){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REPR(i,n) for (int i=(int)(n)-1;i>=0;--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>basic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>&os,\nconst C& c){os<<'[';for(auto i=begin(c);i!=end(c);++i)os<<(i==begin(c)?\"\":\" \")<<*i;return os<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\ntemplate<class T>bool inputs(T *a, int n) { REP(i,n) if(!input(a[i])) return 0; return 1;}\n\nint dp[101][101][101];\n\nstruct P {\n  int a,e,r;\n  void in() {\n    cin >> a >> e >> r;\n  }\n  bool operator<(const P &rhs) const {\n    return r < rhs.r;\n  }\n} p[100];\n\nint main() {\n  int d,n;\n  while(cin>>d>>n,d||n) {\n    REP(i,n) {\n      p[i].in();\n    }\n    sort(p,p+n);\n    memset(dp,0x3f,sizeof(dp));\n    dp[0][0][0] = 0;\n    REP(i,n) {\n      for (int j=0; j <= 100; ++j) {\n        REP(k,d+1) {\n          chmin(dp[i+1][j][k], dp[i][j][k]);\n          if (j>=p[i].r) {\n            chmin(dp[i+1][min(100,j+p[i].e)][min(d,k+p[i].a)], dp[i+1][j][k] + 1);\n            // REP(l,100) {\n            //   chmin(dp[i+1][min(100,j+p[i].e*l)][min(d,k+p[i].a*l)], dp[i][j][k] + l);\n            // }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(i,101) chmin(ans, dp[n][i][d]);\n    if (ans == INF) puts(\"NA\");\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define INF 1<<28\nusing namespace std;\n\nint d, n;\nint a[111], e[111], r[111];\nint memo[111][111];\n\nint solve(int p, int q){\n\n  if(p < 1) return 0;\n  if(memo[p][q]) return memo[p][q];\n\n  int ret = INF;\n  for(int i=0;i<n;i++){\n    if(r[i] <= q) ret = min(ret, solve(p-a[i], q+e[i])+1);\n  }\n\n  return memo[p][q] = ret;\n}\n\nint main(){\n\n  while(scanf(\"%d %d\", &d, &n), d){\n\n    for(int i=0;i<n;i++) cin >> a[i] >> e[i] >> r[i];\n\n    memset(memo, 0, sizeof(memo));\n    int ans = solve(d, 0);\n    if(ans == INF) cout << \"NA\\n\";\n    else cout << ans << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][100000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=50)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nint D, N;\nint dp[101][101];\nint A[100], E[100], R[100];\n\nint main(){\n    while(scanf(\"%d %d\", &D, &N), D || N){\n        for(int i=0;i<N;i++){\n            scanf(\"%d %d %d\", A+i, E+i, R+i);\n        }\n\n        for(int i=0;i<=D;i++){\n            for(int j=0;j<=100;j++){\n                dp[i][j] = 1001001001;\n            }\n        }\n\n        dp[D][0] = 0;\n        for(int i=D;i>=0;i--){\n            for(int j=0;j<=100;j++){\n                for(int k=0;k<N;k++){\n                    if(j >= R[k]){\n                        int ni = std::max(i-A[k],0),\n                            nj = std::min(j+E[k],100);\n                        dp[ni][nj] = std::min(dp[ni][nj], dp[i][j] + 1);\n                    }\n                }\n            }\n        }\n\n        int res = 1001001001;\n        for(int i=0;i<=100;i++){\n            res = std::min(res, dp[0][i]);\n        }\n\n        if(res != 1001001001){printf(\"%d\\n\", res);}\n        else{puts(\"NA\");}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n;\n  bool dp[101][101],table[101][101];\n  while(cin>>d>>n,d){\n    int a[n],e[n],r[n];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=1;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          r(k,d+1){\n            if(dp[j][k]){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>=d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              table[y][x]=1;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\n\n\n\nint main(){\n\t\n\tint l,N;\n\twhile(cin>>l>>N,l){\n\t\tvector<int>damage(N);\n\t\tvector<int>exp(N);\n\t\tvector<int>req(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>damage[i]>>exp[i]>>req[i];\n\t\t}\n\t\tvector<vector<int>>dp(l+1,vector<int>(101,MOD));\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<=l;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(j<req[k])continue;\n\t\t\t\t\tint left=max(0,i-damage[k]);\n\t\t\t\t\tint nxexp=min(100,j+exp[k]);\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[left][nxexp]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[l][0]==MOD)cout<<\"NA\\n\";\n\t\telse cout<<dp[l][0]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][1000],s;\nvector<pair<pair<int,int>,int> >v;\nvoid dfs(int p,int x,int t){\n  if(t>=s)return;\n  if(p<0){s=t;return;}\n  if(x>10000)return;\n  for(int i=0;i<v.size();i++)\n    if(v[i].s>=x)dfs(p-v[i].f.f,x+v[i].f.s,t+1);\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();s=1000000;\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end());\n    dfs(d,0,0);\n    if(s!=10000000)cout<<\"NA\"<<endl;\n    else cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nconst int MOD=100000;\nint dp[101][101];\nint main(){\n      int d,n;\n      while(cin>>d>>n&&(d||n)){\n            int a[n],e[n],r[n];\n            REP(i,n)cin>>a[i]>>e[i]>>r[i];\n            REP(i,101)REP(j,101)dp[i][j]=INF;\n            dp[0][0]=0;\n            REP(i,d+1){\n                  REP(j,101){//current keikenchi\n                        if(dp[j][i]==INF)continue;\n                        REP(k,n){\n                              if(r[k]>j)continue;\n                              int nj=min(100,j+e[k]);\n                              int ni=min(d,i+a[k]);\n                              dp[nj][ni]=min(dp[nj][ni],dp[j][i]+1);\n                        }\n                  }\n            }\n            int ans=INF;\n            REP(i,101)if(dp[i][d]!=-1)ans=min(ans,dp[i][d]);\n            if(ans==INF)cout<<\"NA\"<<endl;\n            else cout<<ans<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nint a[256], e[256], r[256];\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != -1) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      if(a[i] == 0 && e[i] == 0) continue;\n      if(a[i] == 0 && *max_element(e, e+N) < ex) break;\n      res = min(res, func(min(100,ex+e[i]), HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = -1;\n      }\n    }\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint main(){\n    int d, n;\n    while(cin >> d >> n, d+n){\n        vector<int> a(n), e(n), r(n);\n        for(int i = 0; i < n; i++)  cin >> a[i] >> e[i] >> r[i];\n        vector<vector<int>> dp(d+1, vector<int>(101, 1<<30));\n        dp[0][0] = 0;\n        for(int du = 0; du <= d; du++){\n            for(int ex = 0; ex < 101; ex++){\n                for(int k = 0; k < n; k++){\n                    if(dp[du][ex] == 1<<30 || r[k] > ex)    continue;\n                    dp[min(du+a[k],d)][min(100,ex+e[k])] = \n                        min(dp[min(du+a[k],d)][min(100,ex+e[k])], dp[du][ex]+1);\n                }\n            }\n        }\n        int ans = 1<<30;\n        for(int i = 0; i < 101; i++)    ans = min(ans, dp[d][i]);\n        if(ans == 1<<30)    cout << \"NA\" << endl;\n        else                cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b)(a=min(a,b))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100], e[100], r[100];\nint dp[101][101];\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\trep(i, n)scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\trep(i, 101)dp[0][i] = 0;\n\t\trep(i, 101)for (int j = 100; j >= 0; j--)rep(k, n) {\n\t\t\tif (j - e[k] >= r[k])cmin(dp[min(d, i + a[k])][j - e[k]], dp[i][j] + 1);\n\t\t}\n\t\tif (dp[d][0] == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\", dp[d][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<2003;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define LOOP(i,x,n) for(int i=(x);i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e10;\n\nusing namespace std;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\nsigned main(){\n  int d,n;\n  while(cin>>d>>n,d){\n    bool flag=false;\n    vector<int> a(n),e(n),r(n);\n    REP(i,n){\n      cin>>a[i]>>e[i]>>r[i];\n      if(r[i]==0)flag=true;\n    }\n    if(!flag){\n      cout<<\"NA\"<<endl;\n\n    }else{\n      int dp[201][201];\n      bool used[201][201];\n\n      REP(i,n){\n        if(r[i]==0){\n          dp[0][e[i]]=a[i];\n          used[0][e[i]]=true;\n        }\n      }\n\n      REP(i,101){\n        REP(j,101){\n          if(used[i][j]){\n            REP(k,n){\n              if(j-r[k]>=0){\n              used[i+1][j+e[k]>=100?100:j+e[k]]=true;\n              cmax(dp[i+1][j+e[k]>=100?100:j+e[k]],dp[i][j]+a[k]);\n              }\n            }\n          }\n        }\n      }\n      // REP(i,30)cout<<i<<' ';\n      // cout<<endl;\n      // REP(i,15){\n      //   REP(j,101){\n      //     cout<<dp[i][j]<<' ';\n      //   }\n      //   cout<<endl;\n      // }cout<<endl;\n      bool f=false;\n      REP(i,101){\n        REP(j,101){\n          if(dp[i][j]>=d){\n            cout<<i+1<<endl;\n            f=true;\n            break;\n          }\n        }\n        if(f)break;\n      }\n\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; ++i)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> Point;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1ll << 60;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n#ifdef WIN32\n#define dump(x) cerr << #x << \" = \" << (x) << \"\\n\"\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\"\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nint d, n, a[ 100 ], e[ 100 ], r[ 100 ];\nint dp[ 101 ][ 101 ];\n\nbool input() {\n\tif ( !( ~scanf( \"%d %d\", &d, &n ) ) || ( !d && !n ) ) {\n\t\treturn false;\n\t}\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tscanf( \"%d %d %d\", &a[ i ], &e[ i ], &r[ i ] );\n\t}\n\treturn true;\n}\n\nint dfs( int hp, int exp ) {\n\tif ( hp <= 0 ) {\n\t\treturn 0;\n\t}\n\tif ( ~dp[ hp ][ exp ] ) {\n\t\treturn dp[ hp ][ exp ];\n\t}\n\tint res = INF;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tif ( exp >= r[ i ] ) {\n\t\t\tres = min( res, dfs( hp - a[ i ], min( 100, exp + e[ i ] ) ) + 1 );\n\t\t}\n\t}\n\treturn dp[ hp ][ exp ] = res;\n}\n\nvoid solve() {\n\tNCLR( dp );\n\tprintf( dfs( d, 0 ) == INF ? \"NA\\n\" : \"%d\\n\", dfs( d, 0 ) );\n}\n\nint main() {\n\twhile ( input() ) {\n#ifdef WIN32\n\t\tclock_t stime = clock();\n#endif\n\t\tsolve();\n#ifdef WIN32\n\t\tclock_t etime = clock();\n\t\tfprintf( stderr, \"TIME : %f\\n\", ( double ) ( etime - stime ) / CLOCKS_PER_SEC );\n#endif\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main(){\n  int D, N, a[100], e[100], r[100];\n  while(cin >> D >> N, D){\n    for(int i = 0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    vector< vector< int > > dp(D + 1, vector< int >( 101, INF));\n    dp[D][0] = 0;\n    for(int i = D; i > 0; i--){\n      for(int j = 100; j >= 0; j--){\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < N; k++){\n          if(j < r[k]) continue;\n          dp[max( 0, i - a[k])][min( 100, j + e[k])] = min( dp[max( 0, i - a[k])][min( 100, j + e[k])], dp[i][j] + 1);\n        }\n      }\n    }\n    int ret = INF;\n    for(int i = 0; i < 101; i++) ret = min( ret, dp[0][i]);\n    if(ret == INF) cout << \"NA\" << endl;\n    else cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nint D,N;\n\nstruct Info{\n\tInfo(){\n\t\tattack = exp = r_exp = -1;\n\t\tunuse = false;\n\t}\n\tInfo(int arg_attack,int arg_exp,int arg_r_exp){\n\t\tattack = arg_attack;\n\t\texp = arg_exp;\n\t\tr_exp = arg_r_exp;\n\t\tunuse = false;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn r_exp > arg.r_exp;\n\t};\n\n\tint attack,exp,r_exp;\n\tbool unuse;\n};\n\nstruct Data{\n\tint current_exp,rest_D,count;\n};\n\n\nvoid func(){\n\n\tint a,e,r;\n\tpriority_queue<Info> S;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&a,&e,&r);\n\t\tS.push(Info(a,e,r));\n\t}\n\n\tInfo info[N];\n\n\tint index = 0;\n\n\twhile(!S.empty()){\n\t\tinfo[index].attack = S.top().attack;\n\t\tinfo[index].exp = S.top().exp;\n\t\tinfo[index].r_exp = S.top().r_exp;\n\t\tindex++;\n\t\tS.pop();\n\t}\n\n\t//??¨????????????????????¨????????????????????????\n\t/*int a_num = 0,e_num = 0;\n\tfor(int i = 0; info[i].r_exp == 0 && i < N; i++){\n\t\tif(info[i].attack > 0){\n\t\t\ta_num++;\n\t\t}\n\t\tif(info[i].exp > 0){\n\t\t\te_num++;\n\t\t}\n\t}\n\n\tif(a_num == 0 && e_num == 0){\n\t\tprintf(\"NA\\n\");\n\t\treturn;\n\t}else{\n\n\t\tif(a_num == 0 && e_num > 0){ //????¨??????????????????????????????¨??????????????????????????????\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(info[i].attack > 0)a_num++;\n\t\t\t}\n\n\t\t\tif(a_num == 0){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n*/\n\tint ans = -1;\n\n\tqueue<Data> Q;\n\n\tData first;\n\tfirst.current_exp = 0;\n\tfirst.rest_D = D;\n\tfirst.count = 0;\n\n\tQ.push(first);\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().rest_D <= 0){\n\t\t\tans = Q.front().count;\n\t\t\tbreak;\n\t\t}\n\n\t\t//??????????????????????¨?????????????????????????????????????????????¨???????????°???????????¨????????¨????????????\n\t\tfor(int i = 0; info[i].r_exp <= Q.front().current_exp && i < N;i++){\n\t\t\tif((info[i].unuse == true) || (info[i].attack <= 0 && info[i].exp <= 0))continue;\n\t\t\tFLG = true;\n\t\t\tfor(int k = 0; info[k].r_exp <= Q.front().current_exp && k < N;k++){\n\t\t\t\tif(i != k && ((info[i].exp <= info[k].exp && info[i].attack < info[k].attack) || (info[i].exp < info[k].exp && info[i].attack <= info[k].attack))){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tinfo[i].unuse = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG == true){\n\t\t\t\tData new_data;\n\t\t\t\tnew_data.count = Q.front().count+1;\n\t\t\t\tnew_data.current_exp = Q.front().current_exp+info[i].exp;\n\t\t\t\tnew_data.rest_D = Q.front().rest_D - info[i].attack;\n\t\t\t\tQ.push(new_data);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tif(ans == -1){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&D,&N);\n\t\tif(D == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint bfs[110][110];\nint c[110];\nint d[110];\nint e[110];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<110;i++)for(int j=0;j<110;j++)\n\t\t\tbfs[i][j]=999999999;\n\t\tqueue<pair<int,int> > Q;\n\t\tbfs[0][0]=0;\n\t\tQ.push(make_pair(0,0));\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d%d\",c+i,d+i,e+i);\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint s=Q.front().first;\n\t\t\tint t=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<b;i++){\n\t\t\t\tif(t<e[i])continue;\n\t\t\t\tif(bfs[min(a,s+c[i])][min(t+d[i],100)]>99999999){\n\t\t\t\t\tbfs[min(a,s+c[i])][min(t+d[i],100)]=bfs[s][t]+1;\n\t\t\t\t\tQ.push(make_pair(min(a,s+c[i]),min(t+d[i],100)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<=100;i++)ret=min(ret,bfs[a][i]);\n\t\tif(ret>99999999)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint ans;\nint dp[101][101];\n\nint solve(int hp, int exp) {\n\n    if(hp <= 0) {\n        return 0;\n    }\n\n    if(dp[hp][exp] != -1) {\n        return dp[hp][exp];\n    }\n\n    int ret = INF;\n    for(int i = 0; i < n; ++i) {\n        if(exp >= r[i]) {\n            ret = min(ret, solve(max(0, hp - a[i]), exp + e[i]) + 1);\n        }\n    }\n\n    return dp[hp][exp] = ret;\n}\n\nint main() {\n\n    while(cin >> d >> n, d || n) {\n\n        for(int i = 0; i < n; ++i) {\n            cin >> a[i] >> e[i] >> r[i];\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        ans = solve(d, 0);\n\n        if(ans == INF) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define LOOP(i,x,n) for(int i=(x);i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e10;\n\nusing namespace std;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\nsigned main(){\n  int d,n;\n  while(cin>>d>>n,d){\n    bool flag=false;\n    vector<int> a(n),e(n),r(n);\n    REP(i,n){\n      cin>>a[i]>>e[i]>>r[i];\n      if(r[i]==0)flag=true;\n    }\n    if(flag==false){\n      cout<<\"NA\"<<endl;\n\n    }else{\n      int dp[301][301]={};\n      int used[301][301]={};\n\n      REP(i,n){\n        if(r[i]==0){\n          cmax(dp[0][e[i]],a[i]);\n          //dp[0][e[i]]=a[i];\n          used[0][e[i]]=1;\n        }\n      }\n\n      REP(i,201){\n        REP(j,101){\n          if(used[i][j]){\n            REP(k,n){\n              if(j-r[k]>=0){\n              used[i+1][j+e[k]>=100?100:j+e[k]]=1;\n              cmax(dp[i+1][j+e[k]>=100?100:j+e[k]],dp[i][j]+a[k]);\n              }\n            }\n          }\n        }\n      }\n      // REP(i,30)cout<<i<<' ';\n      // cout<<endl;\n      // REP(i,15){\n      //   REP(j,101){\n      //     cout<<dp[i][j]<<' ';\n      //   }\n      //   cout<<endl;\n      // }cout<<endl;\n      bool f=false;\n      REP(i,201){\n        REP(j,101){\n          if(dp[i][j]>=d){\n            cout<<i+1<<endl;\n            f=true;\n            break;\n          }\n        }\n        if(f)break;\n      }\n      if(f==false){\n        cout<<\"NA\"<<endl;\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint d, n, memo[110][110];\nvector <int> a, e, r;\nconst int INF = 1000000000;\n\nint rec(int c = 0, int dur = d, int exp = 0) {\n\tif (c > 100) {\n\t\treturn INF;\n\t}\n\tif (dur < 0) {\n\t\treturn 0;\n\t}\n\tif (memo[dur][exp] != -1) {\n\t\treturn memo[dur][exp];\n\t}\n\tint res = INF;\n\trep (i, n) {\n\t\tif (exp < r[i]) continue;\n\t\tres = min(res, rec(c + 1, dur - a[i], min(exp + e[i], 110)) + 1);\n\t}\n\treturn memo[dur][exp] = res;\n}\n\nint main() {\n\tint cnt = 0;\n\twhile(cin >> d >> n, n) {\n\t\ta = e = r = vector <int> (n);\n\t\trep (i, n) cin >> a[i] >> e[i] >> r[i];\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tint ans = rec();\n\t\tcout << (ans == INF ? \"NA\" : to_string(ans)) << endl;\n\t\tcnt++;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct c {\n\tint d, e, f;\n};\nc k[500];\nint a, b;\nint memo[501][501];\nint saiki(int n, int m) {//????????????n??§????¨???????m\n\tif (memo[n][m] != -1)return memo[n][m];\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (k[i].f <= m) {\n\t\t\tif (k[i].d >= n)return memo[n][m]=1;\n\t\t\tMIN = min(MIN, 1+saiki(n-k[i].d, min(100, k[i].e + m)));\n\t\t}\n\t}\n\treturn memo[n][m]=MIN;\n}\nint main() {\n\twhile (cin >> a >> b, a | b) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tint h, i, j; scanf(\"%d%d%d\", &h, &i, &j);\n\t\t\tk[g] = { h,i,j };\n\t\t}\n\t\tint S = saiki(a, 0);\n\t\tif (S >= 1 << 29) { puts(\"NA\"); }\n\t\telse cout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint d, n;\n\twhile(cin >> d >> n, d+n){\n\t\tvector<int> a(n), e(n), r(n); //耐久力 経験値 必要な経験値\n\t\tfor(int i=0; i< n; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tint dp[d+1][11000]; //耐久力 i の時に 経験値 j の時の回数\n\t\tfor(int i=0; i < d+1; i++)for(int j=0; j< 11000; j++) dp[i][j] = 10e7;\n\t\tdp[d][0] = 0;\n\t\tfor(int i = d; 0 <= i; i--){\n\t\t\tfor(int j = 0; j <= 10000; j++){\n\t\t\t\tif(dp[i][j] == 10e7) continue;\n\t\t\t\tfor(int k=0; k < n; k++){\n\t\t\t\t\tif(r[k] <= j){\n\t\t\t\t\t\tint p = (i-a[k]<0 ? 0 : i-a[k]);\n\t\t\t\t\t\tdp[p][j+e[k]] = min(dp[i][j]+1, dp[p][j+e[k]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 10e7;\n\t\tfor(int i=0; i <= 10000; i++) ret = min(dp[0][i], ret);\n\t\tif(ret == 10e7) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REPR(i,n) for (int i=(int)(n)-1;i>=0;--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>basic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>&os,\nconst C& c){os<<'[';for(auto i=begin(c);i!=end(c);++i)os<<(i==begin(c)?\"\":\" \")<<*i;return os<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\ntemplate<class T>bool inputs(T *a, int n) { REP(i,n) if(!input(a[i])) return 0; return 1;}\n\nint dp[101][101][101];\n\nstruct P {\n  int a,e,r;\n  void in() {\n    cin >> a >> e >> r;\n  }\n  bool operator<(const P &rhs) const {\n    return r < rhs.r;\n  }\n} p[100];\n\nint main() {\n  int d,n;\n  while(cin>>d>>n,d||n) {\n    REP(i,n) {\n      p[i].in();\n    }\n    sort(p,p+n);\n    memset(dp,0x3f,sizeof(dp));\n    dp[0][0][0] = 0;\n    REP(i,n) {\n      for (int j=0; j <= 100; ++j) {\n        REP(k,d+1) {\n          chmin(dp[i+1][j][k], dp[i][j][k]);\n          if (j>=p[i].r) {\n            REP(l,100) {\n              chmin(dp[i+1][min(100,j+p[i].e*l)][min(d,k+p[i].a*l)], dp[i][j][k] + l);\n            }\n          }\n        }\n      }\n    }\n    int ans = INF;\n    REP(i,101) chmin(ans, dp[n][i][d]);\n    if (ans == INF) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[101][10010];\nint main()\n{\n\twhile (true){\n\t\tint ans = 100000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\t}\n\t\tfor (int i = 0; i <= 100; i++)for (int j = 0; j < 10010; j++)DP[i][j] = 100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int i = 0; i <= D; i++){\n\t\t\tfor (int j = 0; j <= N * 100; j++){\n\t\t\t\tif (DP[i][j] == 100000)continue;\n\t\t\t\tfor (int k = 0; k < N; k++){\n\t\t\t\t\tif (R[k]>j)continue;\n\t\t\t\t\tDP[min(100, i + A[k])][j + E[k]] = min(DP[min(D, i + A[k])][j + E[k]], DP[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = D; i <= 100; i++){\n\t\t\tfor (int j = 0; j < 10010; j++){\n\t\t\t\tif (DP[i][j] != 100000){\n\t\t\t\t\tans = min(ans, DP[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 100000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint D, N;\nvector<int> a(110), e(110), r(110); //耐久力 経験値 必要な経験値\nint dp[110][11000]; //耐久力 i の時に 経験値 j の時の回数\n\nint solve(int d, int exp){\n\tint ret = 10e8;\n\tif(d <= 0) return 0;\n\tif(dp[d][exp] != -1) return dp[d][exp];\n\tfor(int i=0; i< N; i++){\n\t\tif(r[i] <= exp) ret = min(ret, solve(d-a[i], exp+e[i])+1);\n\t}\n\tdp[d][exp] = ret;\n\treturn ret;\n}\n\nint main(){\n\twhile(cin >> D >> N, D+N){\n\t\tfor(int i=0; i< N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tfor(int i=0; i < 110; i++)for(int j=0; j< 11000; j++) dp[i][j] = -1;\n\t\tint ret = solve(D, 0);\n\t\tif(ret == 10e8) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nconst int MAX_V = 10000;\nstruct edge {};\nvector<edge> G[MAX_V];\n\n// ??§????????°INF\n#define INF (1<<30)\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint D, N;\n\twhile (true) {\n\t\tcin >> D >> N; if (D == 0 && N == 0)break;\n\t\tvector<int> a(N), e(N), r(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tvector<vector<int>>dp(D+1,vector<int>(101,INF));\n\t\tdp[D][0] = 0;\n\t\tfor (int i = D; i >= 0; --i) {\n\t\t\tfor (int j = 0; j < 101; ++j) {\n\t\t\t\tif (dp[i][j] == INF)continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (j < r[k])continue;\n\t\t\t\t\tint tmp_i = max(0, i - a[k]), tmp_j = min(100, j + e[k]);\n\t\t\t\t\tdp[tmp_i][tmp_j] = min(dp[tmp_i][tmp_j], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 101; ++i)ans = min(ans, dp[0][i]);\n\t\tif (ans == INF) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[kai][ex];\nint ans ;\n\nvoid saiki(int d,int ex,int kai) {\n\n  if(d <= 0 &&  ans > kai) ans = kai;\n  if(d > 0) {\n    for(int i=0;i<n;i++) {\n      if(r[i] <= ex) {\n\tsaiki(d-a[i],ex+e[i],kai+1);\n      }\n    }\n  }\n}\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n\n    for(int i=0;i<n;i++) cin >> a[i] >> e[i] >> r[i];\n    ans =INF;\n    saiki(d,0,0);\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n  }\n  \n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint dp[100][101];\t//??¨?????????,?????????????¨???°(100??§????????????)\n\nint n;\nint a[100],e[100],r[100];\t//??????????¨??????¶???\n\nint solve(int dNow,int eNow){\n\tif(dNow<0) return 0;\t//?????????????????????\n\tif(dp[dNow][eNow]!=-1) return dp[dNow][eNow];\n\n\tint ans=114514;\n\tfor(int i=0;i<n;i++){\n\t\tif(eNow<r[i]) continue;\n\t\tans=min(ans,1+solve(dNow-a[i],min(eNow+e[i],100)));\n\t}\n\n\tdp[dNow][eNow]=ans;\n\treturn ans;\n}\n\nint main(){\n\tint d;\t//??¨????????????\n\tint i,j;\n\tbool able;\n\twhile(cin>>d,d>0){\n\t\tcin>>n;\n\t\table=false;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>a[i]>>e[i]>>r[i];\n\t\t\tif(r[i]==0) able=true;\n\t\t}\n\n\t\tif(!able){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<100;i++){\n\t\t\tfor(j=0;j<101;j++){\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tcout<<solve(d-1,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint d, n;\nint a[100], e[100], r[100];\n//int ma[101];\nint dp[101][101];\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &d, &n), d){\n\t\tfill((int *)dp, (int *)dp + sizeof(dp) / sizeof(int), INF);\n\t\tdp[0][0] = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d %d\", &a[i], &e[i], &r[i]);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < d; i++){\n\t\t\tfor (int j = 0; j <= 100; j++){\n\t\t\t\tfor (int t = 0; t < n; t++){\n\t\t\t\t\tif (j < r[t]) continue;\n\t\t\t\t\tint nd = min(i + a[t], d);\n\t\t\t\t\tint ne = min(j + e[t], 100);\n\t\t\t\t\tdp[nd][ne] = min(dp[nd][ne], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tfor (int i = 0; i <= 100; i++){\n\t\t\tres = min(res, dp[d][i]);\n\t\t}\n\t\tif (res - INF) printf(\"%d\\n\", res);\n\t\telse puts(\"NA\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint d, n;\nvector <int> a, e, r;\nvector <vector <int>> memo;\nconst int INF = 1000000000;\n\nvoid rec(int c = 0, int exp = 0, int end = d) {\n\tif (memo[exp][end] <= c) return;\n\tmemo[exp][end] = c;\n\n\trep (i, n) {\n\t\tif (exp < r[i]) continue;\n\t\trec(c + 1, min(exp + e[i], 100), max(end - a[i], 0));\n\t}\n}\n\nint main() {\n\twhile (cin >> d >> n, d) {\n\t\ta = e = r = vector <int> (n);\n\t\trep (i, n) cin >> a[i] >> e[i] >> r[i];\n\t\tmemo = vector <vector <int>> (105, vector <int> (105, INF));\n\t\trec();\n\t\tint ans = INF;\n\t\trep (i, 101) ans = min(ans, memo[i][0]);\n\t\tcout << (ans == INF ? \"NA\" : to_string(ans)) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint min(int a, int b) {\n  return a < b ? a : b;\n}\n\nint main(void) {\n  int n, d, i, j, k, inf = 10e8, l;\n  while( 1 ) {\n    scanf(\"%d%d\", &d, &n);\n    if(!d) break;\n    int a[n], e[n], r[n], dp[d + 1][200];\n    for(i = 0; i < n; ++i) scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n    for(i = 0; i <= d; ++i) for(j = 0; j < 200; ++j) dp[i][j] = inf;\n    dp[0][0] = 0;\n    for(i = 0; i <= 100; ++i) {//経験値\n      for(j = 0; j < n; ++j) if(i >= r[j]){//道具\n        for(k = 0; k <= d; ++k) {\n          if(dp[min(d, k + a[j])][min(100, i + e[j])] > dp[k][i] + 1) dp[min(d, k + a[j])][min(100, i + e[j])] = dp[k][i] + 1;\n        }\n      }\n    }\n    /*for(i = 0; i <= d; ++i) {\n      for(j = 0; j < 20; ++j) printf(\"%d \", dp[i][j]);\n      printf(\"\\n\");\n    }*/\n    int ans = inf;\n    for(i = 0; i <= 100; ++i) if(ans > dp[d][i]) ans = dp[d][i];\n    if(ans != inf) printf(\"%d\\n\", ans);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  //if(t>=100)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p])return dp[p];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k=0,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b&&a)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end(),greater<pair<pair<int,int>,int> >());\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][1000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int q){\n  int res=0,k=1;\n  if(x>=1000&&p==q)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,p)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,p)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0,d);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[150][1000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define INF 1<<28\nusing namespace std;\n\nint d, n;\nint a[111], e[111], r[111];\nint memo[111][111];\n\nint solve(int p, int q){\n\n  if(p < 1) return 0;\n  q = min(101, q);\n  if(memo[p][q]) return memo[p][q];\n\n  int ret = INF;\n  for(int i=0;i<n;i++){\n    if(r[i] <= q) ret = min(ret, solve(p-a[i], q+e[i])+1);\n  }\n\n  return memo[p][q] = ret;\n}\n\nint main(){\n\n  while(scanf(\"%d %d\", &d, &n), d){\n\n    for(int i=0;i<n;i++) cin >> a[i] >> e[i] >> r[i];\n\n    memset(memo, 0, sizeof(memo));\n    int ans = solve(d, 0);\n    if(ans == INF) cout << \"NA\\n\";\n    else cout << ans << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint dp[100][101];\t//??¨?????????,?????????????¨???°(100??§????????????)\n\nint n;\nint a[100],e[100],r[100];\t//??????????¨??????¶???\n\nint solve(int dNow,int eNow){\n\tif(dNow<0) return 0;\t//?????????????????????\n\tif(dp[dNow][eNow]!=-1) return dp[dNow][eNow];\n\n\tint ans=114514;\n\tfor(int i=0;i<n;i++){\n\t\tif(eNow<r[i]) continue;\n\t\tans=min(ans,1+solve(dNow-a[i],min(eNow+e[i],100)));\n\t}\n\n\tdp[dNow][eNow]=ans;\n\treturn ans;\n}\n\nint main(){\n\tint loopCnt=0;\n\n\tint d;\t//??¨????????????\n\tint i,j;\n\tbool able;\n\twhile(cin>>d,d>0){\n\t\tcin>>n;\n\t\table=false;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>a[i]>>e[i]>>r[i];\n\t\t\tif(r[i]==0) able=true;\n\t\t}\n\n\t\tif(loopCnt==0) cout<<\"WA\"<<endl;\n\t\tloopCnt++;\n\n\t\tif(!able){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<100;i++){\n\t\t\tfor(j=0;j<101;j++){\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tcout<<solve(d-1,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        for(int j=r[i];j<101;j++){\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>=d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nconst int MAX_V = 10000;\nstruct edge {};\nvector<edge> G[MAX_V];\n\n// ??§????????°INF\n#define INF (1<<30)\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint D, N;\n\twhile (true) {\n\t\tcin >> D >> N; if (D == 0 && N == 0)break;\n\t\tvector<int> a(N), e(N), r(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tvector<vector<int>>dp(D+1,vector<int>(101,N));\n\t\tdp[D][0] = 0;\n\t\tfor (int i = D; i >= 0; ++i) {\n\t\t\tfor (int j = 0; j < 101; ++j) {\n\t\t\t\tif (dp[i][j] == INF)continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (j < r[k])continue;\n\t\t\t\t\tint tmp_i = max(0, i - a[k]), tmp_j = min(100, j + e[k]);\n\t\t\t\t\tdp[tmp_i][tmp_j] = min(dp[tmp_i][tmp_j], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 101; ++i)ans = min(ans, dp[0][i]);\n\t\tif (ans == INF) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nclass data{\npublic:\n    int cnt;\n    int power;\n    int Exp;\n    data(){}\n    data(int _cnt,int _power,int _exp){\n        cnt = _cnt;\n        power = _power;\n        Exp = _exp;\n    }\n};\nint memo[101][10001];\nint main(){\n    int D,N;\n    while(true){\n        scanf(\"%d%d\",&D,&N);\n        if(D == 0 && N == 0)break;\n        vector < P > s;\n        memset(memo,0,sizeof(memo));\n        rep(i,N){\n            int a,e,r;\n            scanf(\"%d%d%d\",&a,&e,&r);\n            s.PB(P(r,Pii(a,e)));\n        }\n        sort(s.begin(),s.end());\n        int ans = -1;\n        queue < data > Q;\n        Q.push(data(0,D,0));\n        memo[D][0] = 0;\n        while(!Q.empty()){\n            data d = Q.front();Q.pop();\n            if(d.power == 0){\n                ans = d.cnt;\n                break;\n            }\n            rep(i,N){\n                if(d.Exp < s[i].fi)break;\n                int na = max(0,d.power-s[i].se.fi);\n                int ne = d.Exp+s[i].se.se;\n                if(memo[na][ne])continue;\n                memo[na][ne] = d.cnt+1;\n                Q.push(data(d.cnt+1,na,ne));\n            }\n        }\n        if(ans == -1)puts(\"NA\");\n        else printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\n// ??§????????°INF\nconst int INF = (1 << 30);\n// ?¨±?????????????????\nconst double EPS = (1e-10);\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint D, N;\n\tvector<int> a(100), e(100), r(100);\n\twhile (true) {\n\t\tcin >> D >> N; if (D == 0 && N == 0)break;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tvector<vector<int>>dp(D + 1, vector<int>(101, INF));\n\t\tdp[D][0] = 0;\n\t\tfor (int i = D; i >= 0; --i) {\n\t\t\tfor (int j = 0; j < 101; ++j) {\n\t\t\t\tif (dp[i][j] == INF)continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (j < r[k])continue;\n\t\t\t\t\tint tmp_i = max(0, i - a[k]), tmp_j = min(100, j + e[k]);\n\t\t\t\t\tdp[tmp_i][tmp_j] = min(dp[tmp_i][tmp_j], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 101; ++i)ans = min(ans, dp[0][i]);\n\t\tif (ans == INF) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nint D,N;\n\nstruct Info{\n\tInfo(){\n\t\tattack = exp = r_exp = -1;\n\t\tunuse = false;\n\t}\n\tInfo(int arg_attack,int arg_exp,int arg_r_exp){\n\t\tattack = arg_attack;\n\t\texp = arg_exp;\n\t\tr_exp = arg_r_exp;\n\t\tunuse = false;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn r_exp > arg.r_exp;\n\t};\n\n\tint attack,exp,r_exp;\n\tbool unuse;\n};\n\nstruct Data{\n\tint current_exp,rest_D,count;\n};\n\n\nvoid func(){\n\n\tint a,e,r;\n\tpriority_queue<Info> S;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&a,&e,&r);\n\t\tS.push(Info(a,e,r));\n\t}\n\n\tInfo info[N];\n\n\tint index = 0;\n\n\twhile(!S.empty()){\n\t\tinfo[index].attack = S.top().attack;\n\t\tinfo[index].exp = S.top().exp;\n\t\tinfo[index].r_exp = S.top().r_exp;\n\t\tindex++;\n\t\tS.pop();\n\t}\n\n\t//??¨????????????????????¨????????????????????????\n\tint a_num = 0,e_num = 0;\n\tfor(int i = 0; info[i].r_exp == 0 && i < N; i++){\n\t\tif(info[i].attack > 0){\n\t\t\ta_num++;\n\t\t}\n\t\tif(info[i].exp > 0){\n\t\t\te_num++;\n\t\t}\n\t}\n\n\tif(a_num == 0 && e_num == 0){\n\t\tprintf(\"NA\\n\");\n\t\treturn;\n\t}else{\n\n\t\tif(a_num == 0 && e_num > 0){ //????¨??????????????????????????????¨??????????????????????????????\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(info[i].attack > 0)a_num++;\n\t\t\t}\n\n\t\t\tif(a_num == 0){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tint dp[101][101];\n\n\tfor(int i = 0; i < 101; i++){\n\t\tfor(int k = 0; k < 101; k++)dp[i][k] = BIG_NUM;\n\t}\n\n\tdp[D][0] = 0;\n\n\tfor(int a = 0; a <= 100; a++){\n\t\tfor(int b = D;b >= 0;b--){\n\t\t\tif(dp[b][a] == BIG_NUM)continue;\n\t\t\tfor(int c = 0;info[c].r_exp <= a && c < N; c++){\n\t\t\t\tdp[max(0,b-info[c].attack)][min(100,a+info[c].exp)] = min(dp[max(0,b-info[c].attack)][min(100,a+info[c].exp)],dp[b][a]+1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint minimum = BIG_NUM;\n\n\tfor(int i = 0; i < 101;i++){\n\t\tminimum = min(minimum,dp[0][i]);\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&D,&N);\n\t\tif(D == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nint d,n;\nint a[110],e[110],r[110];\nint memo[110][110];\n\nint rec(int hp, int exp){\n  if(hp==0)return 0;\n  if(memo[hp][exp]>=0)return memo[hp][exp];\n  \n  int res = INF;\n  for(int i=0;i<n;i++){\n    if(exp>=r[i]){\n      res = min(res, rec(max(0,hp-a[i]), min(100,exp+e[i])) + 1 );\n    }\n  }\n  return memo[hp][exp] = res;\n}\n\nint main(){\n  while(cin >> d >> n, d){\n    for(int i=0;i<n;i++)cin >> a[i] >> e[i] >> r[i];\n\n    memset(memo,-1,sizeof(memo));\n    int ans = rec(d,0);\n    if(ans==INF)cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n;\n  bool dp[101][101],table[101][101];\n  while(cin>>d>>n,d){\n    int a[n],e[n],r[n];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=1;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        for(int j=r[i];j<d+1;j++){\n          r(k,d+1){\n            if(dp[j][k]){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>=d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              table[y][x]=1;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\nstruct Tool {int a, e, r;};\n\nvector<vector<int>> memo;\n\nint dfs(int hp, int exp, int depth, const vector<Tool>& tool) {\n  if(200 < depth) return INF;\n  if(hp <= 0) return depth;\n  if(memo[hp][exp] != -1) if(memo[hp][exp] <= depth) return memo[hp][exp];\n  int result = INF;\n  for(const auto& t: tool) {\n    if(exp < t.r) continue;\n    result = min(result, dfs(hp - t.a, exp + t.e, depth + 1, tool));\n  }\n  return memo[hp][exp] = result;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    memo.assign(101, vector<int>(201, -1));\n\n    int answer = dfs(D, 0, 0, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint ans;\nint dp[101][101];\n\nint solve(int hp, int exp) {\n\n    if(hp <= 0) {\n        return 0;\n    }\n\n    if(dp[hp][exp] != -1) {\n        return dp[hp][exp];\n    }\n\n    int ret = INF;\n    for(int i = 0; i < n; ++i) {\n        if(exp >= r[i]) {\n            ret = min(ret, solve(max(0, hp - a[i]), min(100, exp + e[i])) + 1);\n        }\n    }\n\n    return dp[hp][exp] = ret;\n}\n\nint main() {\n\n    while(cin >> d >> n, d || n) {\n\n        int cnt = 0;\n\n        for(int i = 0; i < n; ++i) {\n            int ai, ei, ri;\n            cin >> ai >> ei >> ri;\n            if(ai) {\n                a[cnt] = ai;\n                e[cnt] = ei;\n                r[cnt] = ri;\n                ++cnt;\n            }\n        }\n\n        n = cnt;\n\n        memset(dp, -1, sizeof(dp));\n\n        ans = solve(d, 0);\n\n        if(ans == INF) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[101][101];\nvector<int> a;\nvector<int> e;\nvector<int> r;\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != INT_MAX) return memo[ex][HP];\n  int res = INT_MAX;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      res = min(res, func(ex+e[i], HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 101; i++){\n      for(int j=0; j < 101; j++){\n        memo[i][j] = INT_MAX;\n      }\n    }\n    a = vector<int>(N);\n    e = vector<int>(N);\n    r = vector<int>(N);\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX){\n      cout << \"NA\" << endl;\n    }else{\n      cout << func(0, D) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define INF (2 << 28)\nusing namespace std;\n\nint main(){\n    \n    int d, n, dp[111][111];\n    int a[111], e[111], r[111];\n    \n    while(cin >> d >> n, d||n){\n        for(int i = 0; i < n; i++) cin >> a[i] >> e[i] >> r[i];\n        fill_n(*dp, 111*111, INF);\n        dp[d][0] = 0;\n        for(int i = d; i >= 0; i--){\n            for(int j = 0; j <= 100; j++){\n                for(int k = 0; k < n; k++){\n                    if(r[k] <= j)\n                       dp[max(0, i - a[k])][min(100, j + e[k])]  = min(dp[max(0, i - a[k])][min(100, j + e[k])], dp[i][j]  + 1);\n                }\n            }\n        }\n        int res = *min_element(dp[0], dp[0] + 100);\n        if(res == INF) cout << \"NA\" << endl;\n        else cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream& os, const pair<T1, T2>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& v) {\n    os << \"{\";\n    for(int i = 0; i < v.size(); i++)\n        os << v[i] << (i+1<v.size()?\", \":\"\");\n    os << \"}\";\n    return os;\n}\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n}\n//}}}\n\nconst int MAXEX = 100;\nconst int MAXP = 100;\nconst int MAXN = 100;\nint memo[MAXP+1][MAXEX+1];\nint D;\nint N;\nint A[MAXN];\nint E[MAXN];\nint R[MAXN];\nconst int INF = 1000000000;\nint dfs(int rest, int ex) {\n    if(rest <= 0) return 0;\n    int& res = memo[rest][ex];\n    if(res != -1) return res;\n    res = INF;\n    REP(i, N) if(ex >= R[i]) {\n        int nrest = rest - A[i];\n        int nex = min(MAXEX, ex+E[i]);\n        res = min(res, 1+dfs(nrest,nex));\n    }\n    return res;\n}\nint main(){\n    iostream_init();\n    while(cin >> D >> N && (D > 0)) {\n        REP(i, N) cin >> A[i] >> E[i] >> R[i];\n        memset(memo, -1, sizeof(memo));\n        auto ans = dfs(D, 0);\n        if(ans < INF/10) {\n            cout << ans << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; ++i)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> Point;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1ll << 60;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n#ifdef WIN32\n#define dump(x) cerr << #x << \" = \" << (x) << \"\\n\"\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\"\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nint d, n, a[ 100 ], e[ 100 ], r[ 100 ];\nint dp[ 1000 ][ 1000 ];\n\nbool input() {\n\tif ( !( ~scanf( \"%d %d\", &d, &n ) ) || ( !d && !n ) ) {\n\t\treturn false;\n\t}\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tscanf( \"%d %d %d\", &a[ i ], &e[ i ], &r[ i ] );\n\t}\n\treturn true;\n}\n\nint dfs( int hp, int exp ) {\n\tif ( hp <= 0 ) {\n\t\treturn 0;\n\t}\n\tif ( ~dp[ hp ][ exp ] ) {\n\t\treturn dp[ hp ][ exp ];\n\t}\n\tint res = INF;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tif ( exp >= r[ i ] ) {\n\t\t\tres = min( res, dfs( hp - a[ i ], min( 100, exp + e[ i ] ) ) + 1 );\n\t\t}\n\t}\n\treturn dp[ hp ][ exp ] = res;\n}\n\nvoid solve() {\n\tNCLR( dp );\n\tprintf( dfs( d, 0 ) == INF ? \"NA\\n\" : \"%d\\n\", dfs( d, 0 ) );\n}\n\nint main() {\n\twhile ( input() ) {\n#ifdef WIN32\n\t\tclock_t stime = clock();\n#endif\n\t\tsolve();\n#ifdef WIN32\n\t\tclock_t etime = clock();\n\t\tfprintf( stderr, \"TIME : %f\\n\", ( double ) ( etime - stime ) / CLOCKS_PER_SEC );\n#endif\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<20)\ntypedef pair<int,int> P;\ntypedef pair<int,P> Pi;\n\nint D,N;\nint a[111],e[111],r[111];\nint dp[111][111];\n\nint main(){\n  while(cin >> D >> N , D){\n    fill_n(*dp,111*111,INF);\n    for(int i=0;i<N;i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    dp[D][0] = 0;\n    for(int i=D;i>0;i--){\n      for(int j=0;j<101;j++){\n\tif(dp[i][j] == INF) continue;\n\tfor(int k=0;k<N;k++){\n\t  if(j < r[k]) continue;\n\t  dp[max(0,i-a[k])][min(100,j+e[k])] = min(dp[max(0,i-a[k])][min(100,j+e[k])],dp[i][j]+1);\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<101;i++){\n      ans = min(ans,dp[0][i]);\n    }\n    if(ans == INF) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d == D) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        int dd = min(D,d+a[i]), ee = min(100,exp+e[i]);\n        if((dd==d && ee==100) || r[i] > exp) continue;\n        res = min(res, 1+solve(dd,ee));\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N){\n            cin >> a[i] >> e[i] >> r[i];\n            if(a[i]==0 && e[i]==0) r[i] = INF;\n        }\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans >= INF/10) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  int dp[N1+N1+N1+N1][N1+N1+N1+N1],minv;\n  for(int i=0;i<N1+N1+N1+N1;i++){\n    for(int j=0;j<N1+N1+N1+N1;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1+N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N1+N1+N1+N1;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i+a[k]][j+e[k]]==INF) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1+N1+N1;i++){\n    for(int j=1;j<N1+N1+N1+N1;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF (2 << 28)\nusing namespace std;\n\nint d, n, dp[111][111];\nint a[111], e[111], r[111];\n\nint rec(int exp, int hp){\n    \n    if(hp <= 0) return 0;\n    \n    int ret = INF;\n    for(int i = 0; i < n; i++){\n        if(r[i] <= exp)\n            ret = min(ret, rec(exp + e[i], hp - a[i]) + 1);\n    }\n    return dp[exp][hp] = ret;\n}\n\nint main(){\n    \n    while(cin >> d >> n, d||n){\n        for(int i = 0; i < n; i++) cin >> a[i] >> e[i] >> r[i];\n    \n        memset(dp, -1, sizeof(dp));\n        int dd = rec(0, d);\n        if(dd == INF) cout << \"NA\" << endl;\n        else cout << dd << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int INF=1234567;\nint c[101][101];\n\nint main()\n{\n    int D,N;\n    int a[100],e[100],r[100];\n    while(scanf(\" %d %d\", &D, &N),D)\n    {\n        rep(i,N) scanf(\" %d %d %d\", &a[i], &e[i], &r[i]);\n\n        fill(c[0],c[101],INF);\n        c[D][0]=0;\n        queue<pi> que;\n        que.push(pi(D,0));\n        while(!que.empty())\n        {\n            pi v=que.front();\n            que.pop();\n            int rem=v.fi, ex=v.se;\n            rep(i,N)\n            {\n                if(ex<r[i]) continue;\n\n                int nr=max(0,rem-a[i]), ne=min(100,ex+e[i]);\n                if(c[nr][ne] > c[rem][ex]+1)\n                {\n                    c[nr][ne] = c[rem][ex]+1;\n                    que.push(pi(nr,ne));\n                }\n            }\n        }\n\n        int ans=INF;\n        rep(i,101) ans=min(ans,c[0][i]);\n\n        if(ans==INF) printf(\"NA\\n\");\n        else printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint d,n;\n\twhile(cin >> d >> n,d){\n\t\tint a[100],e[100],r[100],dp[101][101];\n\t\tfor(int i = 0;i <= d;i++){\n\t\t\tfor(int j = 0;j <= 100;j++) dp[i][j] = INF;\n\t\t}\n\t\tdp[d][0] = 0;\n\t\tfor(int i = 0;i < n;i++) cin >> a[i] >> e[i] >> r[i];\n\t\tfor(int i = d;i >= 1;i--){\n\t\t\tfor(int j = 0;j <= 100;j++){\n\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\tif(r[k] <= j){\n\t\t\t\t\t\tdp[max(0,i - a[k])][min(100,j + e[k])] = min(dp[max(0,i - a[k])][min(100,j + e[k])],dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i <= 100;i++) mi = min(mi,dp[0][i]);\n\t\tif(mi == INF) cout << \"NA\" << endl;\n\t\telse cout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nmain(){\n\t\n\tint d,n ;\n\tint tool[110][3] ; // ?¢????????????????????¨?????????????????¨????\n\tint table[110][110] ; // HP,level,?????°???????????????\n\t\n\twhile( cin >> d >> n , d ){\n\t\tint t = 101 ;\n\t\tfor( int i=0 ; i<n ; i++ ){\n\t\t\tfor( int j=0 ; j<3 ; j++ ) cin >> tool[i][j] ;\n\t\t\tt = min( t , tool[i][2] ) ;\n\t\t}\n\t\t\n\t\tfor( int i=0 ; i<110 ; i++ )\n\t\t\tfor( int j=0 ; j<110 ; j++ )\n\t\t\t\ttable[i][j] = 101 ;\n\t\t\n\t\tint ans = 101 ;\n\t\tif( t != 0 ) cout << \"NA\" << endl ;\n\t\telse {\n\t\t\ttable[0][0] = 0 ;\n\t\t\tfor( int i=0 ; i<d ; i++ ){\n\t\t\t\tfor( int j=0 ; j<=100 ; j++ ){\n\t\t\t\t\tif( table[i][j] != 101 ){\n\t\t\t\t\t\tfor( int k=0 ; k<n ; k++ ){\n\t\t\t\t\t\t\tint tmp1 = i+tool[k][0] ;\n\t\t\t\t\t\t\tint tmp2 = j+tool[k][1] ;\n\t\t\t\t\t\t\tif( tmp1 > d ) tmp1 = d ;\n\t\t\t\t\t\t\tif( tmp2 > 100 ) tmp2 = 100 ;\n\t\t\t\t\t\t\tif( j >= tool[k][2] ){\n\t\t\t\t\t\t\t\ttable[tmp1][tmp2] = min( table[tmp1][tmp2] , table[i][j]+1 ) ;\n\t\t\t\t\t\t\t\t//cout << tmp1 << \" \" << tmp2 << \" \" << table[tmp1][tmp2] << endl ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor( int i=0 ; i<=100 ; i++ ) ans = min( ans , table[d][i] ) ;\n\t\t\tcout << ans << endl ;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<20)\ntypedef pair<int,int> P;\ntypedef pair<int,P> Pi;\n\nint D,N;\nint a[111],e[111],r[111];\nPi data[111];\nint dp[111][111][111];\n\nint dfs(int tree,int now,int exc){\n  if(tree <= 0) return 0;\n  if(now >= N) return INF;\n  if(dp[tree][now][exc] != INF) return dp[tree][now][exc];\n  int ret = INF;\n  if(exc >= data[now+1].first){\n    ret = min(ret,dfs(tree,now+1,exc));\n  }\n  ret = min(ret,dfs(tree-data[now].second.first,now,min(100,exc+data[now].second.second))+1);\n  return dp[tree][now][exc] = ret;\n}\n\nint main(){\n  while(cin >> D >> N , D){\n    fill_n(**dp,111*111*111,INF);\n    for(int i=0;i<N;i++){\n      cin >> a[i] >> e[i] >> r[i];\n      P p = P(a[i],e[i]);\n      data[i] = Pi(r[i],p);\n    }\n    sort(data,data+N);\n    if(data[0].first != 0){\n      cout << \"NA\" << endl;\n    } else {\n      int ans = dfs(D,0,0);\n      if(ans == INF) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nconst int MAX_V = 10000;\nstruct edge {};\nvector<edge> G[MAX_V];\n\n// ??§????????°INF\n#define INF (1<<30)\n// ?¨±?????????????????\n#define EPS (1e-10)\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint D, N;\n\twhile (true) {\n\t\tcin >> D >> N; if (D == 0 && N == 0)break;\n\t\tvector<int> a(N), e(N), r(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tvector<vector<int>>dp(D+1,vector<int>(101,N));\n\t\tdp[D][0] = 0;\n\t\tfor (int i = D; i >= 0; --i) {\n\t\t\tfor (int j = 0; j < 101; ++j) {\n\t\t\t\tif (dp[i][j] == INF)continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (j < r[k])continue;\n\t\t\t\t\tint tmp_i = max(0, i - a[k]), tmp_j = min(100, j + e[k]);\n\t\t\t\t\tdp[tmp_i][tmp_j] = min(dp[tmp_i][tmp_j], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 101; ++i)ans = min(ans, dp[0][i]);\n\t\tif (ans == INF) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][11111];\nint solve(int d, int exp){\n    if(d >= D) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            res = min(res, 1+solve(d+a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Tool {int a, e, r;};\nbool operator<(const Tool& lhs, const Tool& rhs) {return lhs.r < rhs.r;}\n\nint solve(int D, vector<Tool> tool) {\n  sort(begin(tool), end(tool));\n  vector<vector<int>> dp(D + 1, vector<int>(201, INF));\n  dp[D][0] = 0;\n  for(const auto& t: tool) {\n    for(int hp = D; 0 <= hp; --hp) {\n      for(int exp = 0; exp <= 200; ++exp) {\n        int next_hp = max(0, hp - t.a);\n        int next_exp = exp + t.e;\n        if(exp < t.r) continue;\n        if(200 < next_exp) continue;\n        dp[next_hp][next_exp] = min(dp[next_hp][next_exp], dp[hp][exp] + 1);\n      }\n    }\n  }\n\n  int result = INF;\n  for(const auto& i: dp[0]) result = min(result, i);\n  return result;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    int answer = solve(D, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int INF = 1<<28;\nconst int MAXN = 101;\nconst int MAXD = 101;\nconst int MAXE = 101;\n \nint D, N;\nint dp[MAXD][MAXE];\nint a[MAXN], b[MAXN], c[MAXN];\n \nint main() {\n  while(cin >> D >> N && (D|N)) {\n    for(int i = 0; i < N; ++i)\n      cin >> a[i] >> b[i] >> c[i];\n    fill(dp[0], dp[MAXD], INF);\n    dp[0][0] = 0;\n    for(int d = 0; d <= D; ++d) {\n      for(int e = 0; e < MAXE; ++e) {\n        for(int i = 0; i < N; ++i) {\n          if(e < c[i]) continue;\n          int nd = min(d + a[i], D);\n          int ne = min(e + b[i], MAXE-1);\n          dp[nd][ne] = min(dp[nd][ne], dp[d][e] + 1);\n        }\n      }\n    }\n    int res = INF;\n    for(int e = 0; e < MAXE; ++e) {\n      res = min(res, dp[D][e]);\n    }\n    if(res == INF) cout << \"NA\" <<endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n  int r, d, c;\n};\n\n\n\nint main(){\n  \n  int D,N;\n  int a[101], e[101], r[101];\n  \n  while(1){\n    cin >> D >> N;\n    if( D==0 && N==0) break;\n    \n    for(int i = 0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    \n    queue<State> q;\n    q.push((State){0,D,0});\n    bool flag[101][101];\n    memset(flag, 0, sizeof(flag));\n    flag[0][D] = true;\n    bool visit = false;\n    while(!q.empty()){\n      State s = q.front();q.pop();\n      if(s.d == 0){\n\tvisit = true;\n\tcout << s.c << endl;\n\tbreak;\n      }\n      for(int i = 0; i < N; i++){\n\tState next;\n\tif(s.r >= r[i]){\n\t  next.c = s.c+1;\n\t  next.d = max(0,s.d-a[i]);\n\t  next.r = min(100,s.r + e[i]);\n\t  if(flag[next.r][next.d]) continue;\n\t  flag[next.r][next.d]=true;\n\t  q.push(next);\n\t}\n      }\n\n    }\n    if(!visit) cout << \"NA\" << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n      maxe = max(maxe,e[i]);\n    }\n\n    int N = 10;\n   \n   \n    \n    int ans = INF;\n    for(int j=0;;j++) { //?????¨???????¨????\n      int cnt =0;\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tdp[i][j] = INF;\n\tif(j == 0 && i == d) dp[i][j] = 0;\n\tfor(int k=0;k<n;k++) {\n\t  int na = i+a[k];\n\t  int ne = j-e[k];\n\t  if(na > d) na = d;\n\t  if(ne < 0) ne = 0;\n\t  if(ne < r[k]) continue;\n\t  dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t}\n      }\n      if(dp[0][j] == INF) break;\n      if(j-1>=0 && dp[0][j] > dp[0][j-1]){\n\tans = dp[0][j-1];\n\tbreak;\n      }\n    }\n  \n\n\n    /*\n    for(int j=0;j<=N;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n    }\n    */\n    \n\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\nstruct Tool {int a, e, r;};\n\nvector<vector<int>> memo;\n\nint dfs(int hp, int exp, int depth, const vector<Tool>& tool) {\n  if(hp <= 0) return depth;\n  if(memo[hp][exp] != -1) if(memo[hp][exp] <= depth) return memo[hp][exp];\n  int result = INF;\n  for(const auto& t: tool) {\n    if(exp < t.r) continue;\n    result = min(result, dfs(hp - t.a, exp + t.e, depth + 1, tool));\n  }\n  return memo[hp][exp] = result;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    memo.assign(101, vector<int>(201, -1));\n\n    int answer = dfs(D, 0, 0, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint d, n, memo[110][110];\nvector <int> a, e, r;\nconst int INF = 1000000000;\n\nint rec(int dur = d, int exp = 0) {\n\tif (dur < 0) {\n\t\treturn 0;\n\t}\n\tif (memo[dur][exp] != -1) {\n\t\treturn memo[dur][exp];\n\t}\n\tint res = INF;\n\trep (i, n) {\n\t\tif (exp < r[i]) continue;\n\t\tres = min(res, rec(dur - a[i], min(exp + e[i], 100)) + 1);\n\t}\n\treturn memo[dur][exp] = res;\n}\n\nint main() {\n\twhile(cin >> d >> n, n) {\n\t\ta = e = r = vector <int> (n);\n\t\trep (i, n) cin >> a[i] >> e[i] >> r[i];\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tint ans = rec();\n\t\tcout << (ans == INF ? \"NA\" : to_string(ans)) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF=1e9;\n\nint main()\n{\n\tfor(int d,n;cin>>d>>n && d|n;){\n\t\tvector<int> as(n),es(n),rs(n);\n\t\tfor(int i=0;i<n;i++) cin>>as[i]>>es[i]>>rs[i];\n\t\t\n\t\tint m=*max_element(begin(rs),end(rs));\n\t\tvector<vector<int>> dp(d+1,vector<int>(m+1,INF));\n\t\tdp[d][0]=0;\n\t\tfor(int i=d;i>=0;i--)\n\t\t\tfor(int j=0;j<=m;j++)\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\tif(rs[k]<=j){\n\t\t\t\t\t\tint u=max(i-as[k],0),v=min(j+es[k],m);\n\t\t\t\t\t\tdp[u][v]=min(dp[u][v],dp[i][j]+1);\n\t\t\t\t\t}\n\t\tint res=*min_element(begin(dp[0]),end(dp[0]));\n\t\tif(res<INF) cout<<res<<endl;\n\t\telse        cout<<\"NA\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n;\n  bool dp[101][101],table[101][101];\n  while(cin>>d>>n,d){\n    int a[n],e[n],r[n];\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=1;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          r(k,d+1){\n            if(dp[j][k]){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>=d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              table[y][x]=1;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[1500][1000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\twhile (true){\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int cou = 0; cou < N; cou++){\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\tfor (int j = R[i]; j <= 109 - E[i]; j++){\n\t\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\t\tDP[j + E[i]][k+1] = max(DP[j+E[i]][k+1], DP[j][k] + A[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n      maxe = max(maxe,e[i]);\n    }\n\n    int N = 20000;\n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=N;j++){\n\tdp[i][j] = INF;\n      }\n\tdp[d][0] = 0;\n  \n   \n    \n      for(int j=0;j<=N;j++) { //?????¨???????¨????\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\tfor(int k=0;k<n;k++) {\n\t  int na = i+a[k];\n\t  int ne = j-e[k];\n\t  if(na > d) na = d;\n\t  if(ne < 0) ne = 0;\n\t  if(ne < r[k]) continue;\n\t  //  cout <<\"i=\"<<i<<\" j=\"<<j<<\" na=\"<< na <<\" ne=\"<<ne <<endl;\n\t  dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t\n\t}\n      }\n    }\n      \n\n      /*      \n    for(int j=0;j<=N;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n      }\n      */\n      \n\n\n    int ans = INF;\n    for(int i=0;i<=N;i++)  ans = min(ans,dp[0][i]);\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nint a[256], e[256], r[256];\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != INT_MAX/2) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      res = min(res, func(min(100, ex+e[i]), HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = INT_MAX/2;\n      }\n    }\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << func(0, D) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n  int r, d, c;\n};\n\n\n\nint main(){\n  \n  int D,N;\n  int a[101], e[101], r[101];\n  \n  while(1){\n    cin >> D >> N;\n    if( D==0 && N==0) break;\n    \n    for(int i = 0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    \n    queue<State> q;\n    q.push((State){0,D,0});\n    bool flag[101][101];\n    memset(flag, 0, sizeof(flag));\n    flag[0][D] = true;\n    bool visit = false;\n    while(!q.empty()){\n      State s = q.front();q.pop();\n      if(s.d == 0){\n\tvisit = true;\n\tcout << s.c << endl;\n\tbreak;\n      }\n      for(int i = 0; i < N; i++){\n\tState next;\n\tif(s.r >= r[i]){\n\t  next.c = s.c+1;\n\t  next.d = max(0,s.d-a[i]);\n\t  next.r = min(200,s.r + e[i]);\n\t  if(flag[next.r][next.d]) continue;\n\t  flag[next.r][next.d]=true;\n\t  q.push(next);\n\t}\n      }\n\n    }\n    if(!visit) cout << \"NA\" << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint D, N, a[111], e[111], r[111], dp[111][111];\nint main() {\n\twhile (cin >> D >> N, D | N) {\n\t\tfor (int i = 0; i < N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tint maxr = *max_element(r, r + N);\n\t\tfor (int i = 0; i <= D; i++) fill(dp[i], dp[i] + maxr + 1, 999999999);\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tfor (int j = r[k]; j <= maxr; j++) {\n\t\t\t\t\tint p = min(j + e[k], maxr), q = min(i + a[k], D);\n\t\t\t\t\tdp[q][p] = min(dp[q][p], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = *min_element(dp[D], dp[D] + maxr + 1);\n\t\tif (ret == 999999999) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nint main()\n{\n    for(;;){\n        int d, n;\n        cin >> d >> n;\n        if(d == 0)\n            return 0;\n\n        vector<int> a(n), e(n), r(n);\n        for(int i=0; i<n; ++i)\n            cin >> a[i] >> e[i] >> r[i];\n\n        vector<vector<int> > dp(d+1, vector<int>(101, INF));\n        dp[0] = vector<int>(101, 0);\n        for(int i=1; i<=d; ++i){\n            for(int j=100; j>=0; --j){\n                for(int k=0; k<n; ++k){\n                    if(j < r[k])\n                        continue;\n\n                    int i2 = max(0, i - a[k]);\n                    int j2 = min(100, j + e[k]);\n                    dp[i][j] = min(dp[i][j], dp[i2][j2] + 1);\n                }\n            }\n        }\n        if(dp[d][0] < INF)\n            cout << dp[d][0] << endl;\n        else\n            cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nstruct Data\n{\n\tint A,E,R;\n\n\tData(int a,int e,int r)\n\t{\n\t\tA = a;\n\t\tE = e;\n\t\tR = r;\n\t}\n};\n\nint main()\n{\n\tint d,n;\n\twhile(cin >> d >> n)\n\t{\n\t\tif(d == 0 && n == 0) break;\n\n\n\t\tvector<Data> v;\n\t\trep(i,n)\n\t\t{\n\t\t\tint a,e,r;\n\t\t\tcin >> a >> e >> r;\n\n\t\t\tv.push_back(Data(a,e,r));\n\t\t}\n\t\t\n\t\tqueue<pair<pair<int,int>,int> > que;\n\t\tque.push(make_pair(make_pair(0,d),0));\n\t\tbool flag = true;\n\n\t\t//D exp\n\t\tbool memo[105][105];\n\t\tmemset(memo,0,sizeof(memo));\n\n\t\twhile(que.size())\n\t\t{\n\t\t\tpair<int,int> p = que.front().first;\n\t\t\tint exp = que.front().second;\n\t\t\tque.pop();\n\n\t\t\tif(memo[p.second][exp]) continue;\n\t\t\tmemo[p.second][exp] = true;\n\n\t\t\tif(p.second <= 0)\n\t\t\t{\n\t\t\t\tcout << p.first << endl;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i,n)\n\t\t\t{\n\t\t\t\tif(v[i].R <= exp)\n\t\t\t\t{\n\t\t\t\t\tque.push(make_pair(make_pair(p.first+1,p.second-v[i].A),exp+v[i].E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(flag) cout << \"NA\" << endl;\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int n,d;\n  while(1){\n    cin>>d>>n;\n    if(d==0)break;\n    vector<vi> dp(205,vi(105,-1));\n    vi a(n),e(n),r(n);\n    rep(i,n){\n      cin>>a[i]>>e[i]>>r[i];\n      if(a[i]+e[i]+r[i]==0)i--,n--;\n    }\n    dp[0][0]=0;\n    rep(i,201)rep(j,101)if(dp[i][j]>=0){\n      int k;\n      rep(k,n)if(r[k]<=j){\n\tdp[i+1][min(j+e[k],100)]=max(dp[i+1][min(j+e[k],100)],dp[i][j]+a[k]);\n\tif(dp[i+1][min(j+e[k],100)]>=d){\n\t  cout<<i+1<<endl;\n\t  goto END;\n\t}\n      }\n    }\n    cout<<\"NA\"<<endl;\n  END:;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\twhile (true){\n\t\tint O = 0;\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (R[i]>R[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t\telse if (R[i] == R[j] && A[i] < A[j] && E[i] < E[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(O<=30000000){\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\tfor (int j = R[i]; j <= 109; j++){\n\t\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\t\tO++;\n\t\t\t\t\t\tif (j + E[i] <= 109)DP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t\telse DP[109][k + 1] = max(DP[109][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int D, N;\n    while(cin >> D >> N, D) {\n        using tool = tuple<int, int, int>;\n        vector<tool> v(N);\n        for(int i=0; i<N; ++i) {\n            int a, e, r;\n            cin >> a >> e >> r;\n            v[i] = make_tuple(a, e, r);\n        }\n        vector<vector<int>> dp(D+1, vector<int>(101, INF));\n        queue<P> que;\n        que.push(make_pair(0, 0));\n        dp[0][0] = 0;\n        while(!que.empty()) {\n            P p = que.front();\n            que.pop();\n            for(int i=0; i<N; ++i) {\n                int a, e, r;\n                tie(a, e, r) = v[i];\n                if(p.second < r) {\n                    continue;\n                }\n                int nd = min(D, p.first + a);\n                int nr = min(100, p.second + e);\n                if(dp[nd][nr] > dp[p.first][p.second] + 1) {\n                    dp[nd][nr] = dp[p.first][p.second] + 1;\n                    que.push(make_pair(nd, nr));\n                }\n            }\n        }\n        int res = INF;\n        for(int i=0; i<101; ++i) {\n            res = min(res, dp[D][i]);\n        }\n        if(res == INF) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << res << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define INF (2 << 28)\nusing namespace std;\n\nint d, n, dp[111][111];\nint a[111], e[111], r[111];\n\nint rec(int exp, int hp){\n    \n    if(hp <= 0) return 0;\n    \n    int ret = INF;\n    for(int i = 0; i < n; i++){\n        if(r[i] <= exp && a[i] > 0)\n            ret = min(ret, rec(exp + e[i], hp - a[i]) + 1);\n    }\n    return dp[exp][hp] = ret;\n}\n\nint main(){\n    \n    while(cin >> d >> n, d||n){\n        for(int i = 0; i < n; i++) cin >> a[i] >> e[i] >> r[i];\n        \n        memset(dp, -1, sizeof(dp));\n        int dd = rec(0, d);\n        if(dd == INF) cout << \"NA\" << endl;\n        else cout << dd << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint dp[110][110];\nstruct S {\n\tint a, e, r;\n\tbool operator <(const S& x) const {\n\t\treturn r < x.r;\n\t}\n} t[100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint D, N;\n\twhile(cin >> D >> N, D) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> t[i].a >> t[i].e >> t[i].r;\n\t\t}\n\n\t\tconst int INF = 1 << 25;\n\t\tfill((int*)begin(dp), (int*)end(dp), INF);\n\t\tdp[0][D] = 0;\n\n\t\ttypedef pair<int, int> P;\n\t\tqueue<P> q;\n\t\tq.push({ 0, D });\n\t\twhile(q.size()) {\n\t\t\tint ex = q.front().first, d = q.front().second;\n\t\t\tq.pop();\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tif(ex < t[i].r) continue;\n\t\t\t\tint nex = min(100, ex + t[i].e), nd = max(0, d - t[i].a);\n\t\t\t\tif(dp[nex][nd] > dp[ex][d] + 1) {\n\t\t\t\t\tdp[nex][nd] = dp[ex][d] + 1;\n\t\t\t\t\tq.push({ nex, nd });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int j = 0; j <= 100; j++) {\n\t\t\tans = min(ans, dp[j][0]);\n\t\t}\n\t\tif(ans == INF) cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<20)\ntypedef pair<int,int> P;\ntypedef pair<int,P> Pi;\n\nint D,N;\nint a[111],e[111],r[111];\nPi data[111];\nint dp[111][111][111];\n\nint dfs(int tree,int now,int exc){\n  if(tree <= 0) return 0;\n  if(now >= N) return INF;\n  if(dp[tree][now][exc] != INF) return dp[tree][now][exc];\n  int ret = INF;\n  if(exc >= data[now+1].first){\n    ret = min(ret,dfs(tree,now+1,exc));\n  }\n  ret = min(ret,dfs(tree-data[now].second.first,now,exc+data[now].second.second)+1);\n  return dp[tree][now][exc] = ret;\n}\n\nint main(){\n  while(cin >> D >> N , D){\n    fill_n(**dp,111*111*111,INF);\n    for(int i=0;i<N;i++){\n      cin >> a[i] >> e[i] >> r[i];\n      P p = P(a[i],e[i]);\n      data[i] = Pi(r[i],p);\n    }\n    sort(data,data+N);\n    if(data[0].first != 0){\n      cout << \"NA\" << endl;\n    } else {\n      int ans = dfs(D,0,0);\n      if(ans == INF) cout << \"NA\" << endl;\n      else cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][10000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(x>=10000)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\twhile (true){\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (R[i]>R[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t\telse if (R[i] == R[j] && A[i] < A[j] && E[i] < E[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][0] = 0;\n\t\tfor (int cou = 0; cou < N; cou++){\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\tfor (int j = R[i]; j <= 109; j++){\n\t\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\t\tif (j + E[i] <= 109)DP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t\telse DP[109][k + 1] = max(DP[109][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 101\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i+a[k]][j+e[k]]>dp[i][j]+1){\n\t      if(j+e[k]>=N2) dp[i+a[k]][N2-1]=dp[i][j]+1;\n\t      else dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct c {\n\tint d, e, f;\n};\nc k[100];\nint a, b;\nint memo[101][101];\nint saiki(int n, int m) {//????????????n??§????¨???????m\n\tif (memo[n][m] != -1)return memo[n][m];\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (k[i].f <= m) {\n\t\t\tif (k[i].d >= n)return memo[n][m]=1;\n\t\t\tMIN = min(MIN, 1+saiki(n-k[i].d, min(100, k[i].e + m)));\n\t\t}\n\t}\n\treturn memo[n][m]=MIN;\n}\nint main() {\n\twhile (cin >> a >> b, a | b) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tint h, i, j; scanf(\"%d%d%d\", &h, &i, &j);\n\t\t\tk[g] = { h,i,j };\n\t\t}\n\t\tint S = saiki(a, 0);\n\t\tif (S >= 1 << 29) { puts(\"NA\"); }\n\t\telse cout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint dp[100][101];\t//??¨?????????,?????????????¨???°(100??§????????????)\n\nint n;\nint a[100],e[100],r[100];\t//??????????¨??????¶???\n\nint solve(int dNow,int eNow){\n\tif(dNow<0) return 0;\t//?????????????????????\n\tif(dp[dNow][eNow]!=-1) return dp[dNow][eNow];\n\n\tint ans=114514;\n\tfor(int i=0;i<n;i++){\n\t\tif(eNow<r[i]) continue;\n\t\tans=min(ans,1+solve(dNow-a[i],min(eNow+e[i],100)));\n\t}\n\n\tdp[dNow][eNow]=ans;\n\treturn ans;\n}\n\nint main(){\n\tint loopCnt=0;\n\n\tint d;\t//??¨????????????\n\tint i,j;\n\tbool able;\n\twhile(cin>>d,d>0){\n\t\tloopCnt++;\n\n\t\tcin>>n;\n\t\table=false;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>a[i]>>e[i]>>r[i];\n\t\t\tif(r[i]==0) able=true;\n\t\t}\n\n\t\tif(loopCnt==2) cout<<\"WA\"<<endl;\n\n\t\tif(!able){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<100;i++){\n\t\t\tfor(j=0;j<101;j++){\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tcout<<solve(d-1,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 102\n#define N2 102\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N2;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(j+e[k]>=N2){\n\t      if(dp[i+a[k]][N2-1]>dp[i][j]+1) dp[i+a[k]][N2-1]=dp[i][j]+1;\n\t    }\n\t    else if(dp[i+a[k]][j+e[k]]>dp[i][j]+1) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1e+9\nusing namespace std;\n\nint a[101], e[101], r[101], dp[110][110];\n\n\nsigned main(){\n\twhile(1){\n\t\tint d, n;\n\t\tcin >> d >> n;\n\t\tif(d==0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int k=0;k<=d;k++){\n\t\t\t\tdp[i][k]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][0]=0;\n\t\tint fl=0;\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int k=0;k<=d;k++){\n\t\t\t\tif(dp[i][k]!=INF){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(r[j]<=i){\n\t\t\t\t\t\t\tint aa, bb;\n\t\t\t\t\t\t\taa = min(100ll,i+e[j]);\n\t\t\t\t\t\t\tbb = min(d,k+a[j]);\n\t\t\t\t\t\t\tdp[aa][bb] = min(dp[i][k]+1, dp[aa][bb]);\n\t\t\t\t\t\t\tfl=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(fl==0){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans=1e+8;\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tans = min(dp[i][d],ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint D,N;\nint a[100],e[100],r[100];\n\nconst int INF=1234567;\nint dp[101][101];\nint dfs(int rem, int ex)\n{\n    if(dp[rem][ex]>=0) return dp[rem][ex];\n    if(rem==0) return 0;\n\n    int ret=INF;\n    rep(i,N)\n    {\n        if(ex<r[i]) continue;\n\n        int nr=max(0,rem-a[i]);\n        int ne=min(100,ex+e[i]);\n        ret=min(ret,dfs(nr,ne)+1);\n    }\n\n    return dp[rem][ex]=ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d\", &D, &N),D)\n    {\n        rep(i,N) scanf(\" %d %d %d\", &a[i], &e[i], &r[i]);\n        memset(dp,-1,sizeof(dp));\n        int ans=dfs(D,0);\n        if(ans==INF) printf(\"NA\\n\");\n        else printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nint D,N;\n\nstruct Info{\n\tInfo(){\n\t\tattack = exp = r_exp = -1;\n\t\tunuse = false;\n\t}\n\tInfo(int arg_attack,int arg_exp,int arg_r_exp){\n\t\tattack = arg_attack;\n\t\texp = arg_exp;\n\t\tr_exp = arg_r_exp;\n\t\tunuse = false;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn r_exp > arg.r_exp;\n\t};\n\n\tint attack,exp,r_exp;\n\tbool unuse;\n};\n\nstruct Data{\n\tint current_exp,rest_D,count;\n};\n\n\nvoid func(){\n\n\tint a,e,r;\n\tpriority_queue<Info> S;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&a,&e,&r);\n\t\tS.push(Info(a,e,r));\n\t}\n\n\tInfo info[N];\n\n\tint index = 0;\n\n\twhile(!S.empty()){\n\t\tinfo[index].attack = S.top().attack;\n\t\tinfo[index].exp = S.top().exp;\n\t\tinfo[index].r_exp = S.top().r_exp;\n\t\tindex++;\n\t\tS.pop();\n\t}\n\n\t//??¨????????????????????¨????????????????????????\n\tint a_num = 0,e_num = 0;\n\tfor(int i = 0; info[i].r_exp == 0 && i < N; i++){\n\t\tif(info[i].attack > 0){\n\t\t\ta_num++;\n\t\t}\n\t\tif(info[i].exp > 0){\n\t\t\te_num++;\n\t\t}\n\t}\n\n\tif(a_num == 0 && e_num == 0){\n\t\tprintf(\"NA\\n\");\n\t\treturn;\n\t}else{\n\n\t\tif(a_num == 0 && e_num > 0){ //????¨??????????????????????????????¨??????????????????????????????\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(info[i].attack > 0)a_num++;\n\t\t\t}\n\n\t\t\tif(a_num == 0){\n\t\t\t\tprintf(\"NA\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = -1;\n\n\tqueue<Data> Q;\n\n\tData first;\n\tfirst.current_exp = 0;\n\tfirst.rest_D = D;\n\tfirst.count = 0;\n\n\tQ.push(first);\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().rest_D <= 0){\n\t\t\tans = Q.front().count;\n\t\t\tbreak;\n\t\t}\n\n\t\t//??????????????????????¨?????????????????????????????????????????????¨???????????°???????????¨????????¨????????????\n\t\tfor(int i = 0; info[i].r_exp <= Q.front().current_exp && i < N;i++){\n\t\t\tif((info[i].unuse == true) || (info[i].attack <= 0 && info[i].exp <= 0))continue;\n\t\t\tFLG = true;\n\t\t\tfor(int k = 0; info[k].r_exp <= Q.front().current_exp && k < N;k++){\n\t\t\t\tif(i != k && ((info[i].exp <= info[k].exp && info[i].attack < info[k].attack) || (info[i].exp < info[k].exp && info[i].attack <= info[k].attack))){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tinfo[i].unuse = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG == true){\n\t\t\t\tData new_data;\n\t\t\t\tnew_data.count = Q.front().count+1;\n\t\t\t\tnew_data.current_exp = Q.front().current_exp+info[i].exp;\n\t\t\t\tnew_data.rest_D = Q.front().rest_D - info[i].attack;\n\t\t\t\tQ.push(new_data);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tif(ans == -1){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&D,&N);\n\t\tif(D == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<10003;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef long long ll;\ntypedef long double ld;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(int i = x-1 ; i >= 0 ; i --)\n#define rrep1(i,x) for(int i = x ; i > 0 ; i --)\n#define fr first\n#define sc second\n#define pb push_back\n\nconst int INF = 1000000000;\n\nint main(){\n\twhile(1){\n\t\tint d,n;\n\t\tint a[102],e[102],r[102];\n\t\tscanf(\"%d%d\",&d,&n);\n\t\tif(d == 0 && n == 0)break;\n\t\trep(i,n){\n\t\t\tscanf(\"%d%d%d\",&a[i],&e[i],&r[i]);\n\t\t}\n\t\tint c[102][102];\n\t\trep(i,102)rep(j,102){\n\t\t\tc[i][j] = INF;\n\t\t}\n\t\tc[0][0] = 0;\n\t\trep(i,d)rep(j,101){\n\t\t\tif(c[i][j] == INF)continue;\n\t\t\trep(k,n){\n\t\t\t\tif(j < r[k])continue;\n\t\t\t\tc[min(d,i+a[k])][min(100,j+e[k])] = min ( c[min(d,i+a[k])][min(100,j+e[k])] , c[i][j]+1 );\n\t\t\t}\n\t\t}\n\t\tint ret = INF;\n\t\trep(j,101)ret = min ( ret , c[d][j] );\n\t\tif(ret == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\n\nint dp[111][111];\nint solve(int d, int exp){\n    if(d <= 0) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INT_MAX;\n    rep(i,N){\n        if(r[i] > exp) continue;\n        res = min(res, 1+solve(d-a[i], exp+e[i]));\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(D,0);\n        if(ans == INT_MAX) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b)(a=min(a,b))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100], e[100], r[100];\nint dp[101][101];\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\trep(i, n)scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\trep(i, 101)dp[0][i] = 0;\n\t\trep(i, 101)for (int j = 100; j >= 0; j--)rep(k, n) {\n\t\t\tif (j - e[k] >= r[k]) {\n\t\t\t\trep(t, a[k] + 1)rep(p, e[k] + 1)cmin(dp[min(d, i + t)][j - p], dp[i][j] + 1);\n\t\t\t}\n\t\t}\n\t\tif (dp[d][0] == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\", dp[d][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[1000][10010];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<list>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\nstruct a\n{\n\tint b, c, d;\n};\na e[500];\nint dp[501][501];//????????????n????¨???????m\nint main() {\n\tint f, g;\n\twhile (cin >> f >> g, f | g) {\n\t\tint MAX = 0;\n\t\tfor (int h = 0; h < g; h++) {\n\t\t\tint i, j, k;\n\t\t\tscanf(\"%d%d%d\", &i, &j, &k);\n\t\t\te[h] = { i,j,k };\n\t\t\tMAX = max(MAX, k);\n\t\t}\n\t\tfor (int h = 0; h <= f; h++) {\n\t\t\tfor (int i = 0; i <= MAX;i++) {\n\t\t\t\tdp[h][i] = 1 << 29;\n\t\t\t\tif (h == 0)dp[h][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 1; h <= f; h++) {\n\t\t\tfor (int i = 0; i <= MAX;i++) {\n\t\t\t\tfor (int j = 0; j < g; j++) {\n\t\t\t\t\tif (i >= e[j].d) {\n\t\t\t\t\t\tdp[h][i] = min(dp[h][i], 1 + dp[max(0,h - e[j].b)][min(MAX, i + e[j].c)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[f][0] >= 100000)puts(\"NA\");\n\t\telse cout << dp[f][0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint D, N, w, a[111], e[111], r[111], dp[111][111][222];\nint rec(int f1, int f2, int d) {\n\tif (f1 >= D) return d;\n\tif (dp[f1][f2][d]) return dp[f1][f2][d] - 1;\n\tint ret = 999999999;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!a[i] && (!e[i] || f2 == w)) continue;\n\t\tif (f2 >= r[i]) ret = min(ret, rec(f1 + a[i], min(f2 + e[i], w), d + 1));\n\t}\n\tdp[f1][f2][d] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> D >> N, D | N) {\n\t\tfor (int i = 0; i < N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tw = *max_element(r, r + N);\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j <= w; j++) {\n\t\t\t\tfor (int k = 0; k < N * 2; k++) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = rec(0, 0, 0);\n\t\tif (ret == 999999999) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int D,N;cin>>D>>N,D|N;){\n    int a[999],e[999],r[999];\n    for(int i=0;i<N;i++){\n      cin>>a[i]>>e[i]>>r[i];\n    }\n    static int dp[999][999];\n    fill(dp[0],dp[999],1e9);\n    dp[D][0]=0;\n    int ans=1e9;\n    for(int i=D;i>0;i--){\n      for(int j=0;j<=100;j++){\n\tfor(int k=0;k<N;k++){\n\t  if(j>=r[k]){\n\t    int nexp=min(100,j+e[k]);\n\t    int hp=i-a[k];\n\t    int n=dp[i][j]+1;\n\t    if(hp<=0){\n\t      ans=min(ans,n);\n\t    }else{\n\t      dp[hp][nexp]=min(dp[hp][nexp],n);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans>1e8){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<ans<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\twhile (true){\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (R[i]>R[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = R[i]; j <= 109 - E[i]; j++){\n\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\tif(j+E[i]<=109)DP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\telse DP[109][k + 1] = max(DP[109][k + 1], DP[j][k] + A[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b)(a=min(a,b))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100], e[100], r[100];\nint dp[101][101];\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\trep(i, n)scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\trep(i, 101)dp[0][i] = 0;\n\t\trep(i, d + 1)for (int j = 100; j >= 0; j--)rep(k, n) {\n\t\t\tif (j - e[k] >= r[k]) {\n\t\t\t\tcmin(dp[min(d, i + a[k])][j - e[k]], dp[i][j] + 1);\n\t\t\t}\n\t\t\tcmin(dp[min(d, i + 1)][max(0, j - 1)], dp[i][j]);\n\t\t}\n\t\tif (dp[d][0] == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\", dp[d][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nint D[50], N[50];\nint A[50][100], E[50][100], R[50][100];\nint DP[110][110];\nint main()\n{\n\tint T = 0;\n\t\n\twhile (true){\n\t\tscanf(\"%d%d\", &D[T], &N[T]);\n\t\tif (D[T] == 0 && N[T] == 0)break;\n\t\tfor (int j = 0; j < N[T]; j++)scanf(\"%d%d%d\", &A[T][j], &E[T][j], &R[T][j]);\n\t\tT++;\n\t}\n\tfor (int k = 0; k < T; k++){\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] = -100000;\n\t\tDP[0][0] = 0;\n\t\tint ans = 10000;\n\t\tfor (int i = 0; i < N[k]; i++){\n\t\t\tfor (int j = i + 1; j < N[k]; j++){\n\t\t\t\tif (R[k][i]>R[k][j]){\n\t\t\t\t\tswap(A[k][i], A[k][j]);\n\t\t\t\t\tswap(E[k][i], E[k][j]);\n\t\t\t\t\tswap(R[k][i], R[k][j]);\n\t\t\t\t}\n\t\t\t\telse if (R[k][i] == R[k][j] && A[k][i] < A[k][j] && E[k][i] < E[k][j]){\n\t\t\t\t\tswap(A[k][i], A[k][j]);\n\t\t\t\t\tswap(E[k][i], E[k][j]);\n\t\t\t\t\tswap(R[k][i], R[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint O = 0;\n\t\twhile (O*T <= 500000000){\n\t\t\tfor (int i = 0; i < N[k]; i++){\n\n\t\t\t\tfor (int j = R[k][i]; j <= 109; j++){\n\t\t\t\t\tfor (int l = 0; l <= 108; l++){\n\t\t\t\t\t\tO++;\n\t\t\t\t\t\tif (j + E[k][i] <= 109)DP[j + E[k][i]][l + 1] = max(DP[j + E[k][i]][l + 1], DP[j][l] + A[k][i]);\n\t\t\t\t\t\telse DP[109][l + 1] = max(DP[109][l + 1], DP[j][l] + A[k][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D[k]){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\twhile (true){\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (R[i]>R[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t\telse if (R[i] == R[j] && A[i] < A[j] && E[i] < E[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][0] = 0;\n\t\tfor (int cou = 0; cou < max(25,N/4); cou++){\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\tfor (int j = R[i]; j <= 109; j++){\n\t\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\t\tif (j + E[i] <= 109)DP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t\telse DP[109][k + 1] = max(DP[109][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=100)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p])return dp[p];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end(),greater<pair<pair<int,int>,int> >());\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d >= D) return 0;\n    if(exp >= 111) return INF;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            if(a[i]==0 && e[i]==0) continue;\n            res = min(res, 1+solve(d+a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  int dp[N1+N1][N1+N1],minv;\n  for(int i=0;i<N1+N1;i++){\n    for(int j=0;j<N1+N1;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N1;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i+a[k]][j+e[k]]==INF) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1;i++){\n    for(int j=1;j<N1+N1;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXN = 101;\nconst int MAXD = 101;\nconst int MAXE = 101;\n\nint D, N;\nint dp[MAXD][MAXE];\nint a[MAXN], b[MAXN], c[MAXN];\n\nint main() {\n  while(cin >> D >> N && (D|N)) {\n    for(int i = 0; i < N; ++i)\n      cin >> a[i] >> b[i] >> c[i];\n    fill(dp[0], dp[MAXD], INF);\n    dp[0][0] = 0;\n    for(int d = 0; d <= D; ++d) {\n      for(int e = 0; e < MAXE; ++e) {\n\tfor(int i = 0; i < N; ++i) {\n\t  if(e < c[i]) continue;\n\t  int nd = min(d + a[i], D);\n\t  int ne = min(e + b[i], MAXE-1);\n\t  dp[nd][ne] = min(dp[nd][ne], dp[d][e] + 1);\n\t}\n      }\n    }\n    int res = INF;\n    for(int e = 0; e < MAXE; ++e) {\n      res = min(res, dp[D][e]);\n    }\n    if(res == INF) cout << \"NA\" <<endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint min(int a, int b) {\n  return a < b ? a : b;\n}\n\nint main(void) {\n  int n, d, i, j, k, inf = 10e8, l;\n  while( 1 ) {\n    scanf(\"%d%d\", &d, &n);\n    if(!d) break;\n    int a[n], e[n], r[n], dp[d + 1][200];\n    for(i = 0; i < n; ++i) scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n    for(i = 0; i <= d; ++i) for(j = 0; j < 200; ++j) dp[i][j] = inf;\n    dp[0][0] = 0;\n    for(i = 0; i <= 100; ++i) {//経験値\n      for(j = 0; j < n; ++j) if(i >= r[j]){//道具\n        for(k = 0; k <= d; ++k) {\n          for(l = 0; l <= i + e[j] && l <= 100; ++l) {\n            if(dp[min(d, k + a[j])][l] > dp[k][i] + 1) dp[min(d, k + a[j])][l] = dp[k][i] + 1;\n          }\n        }\n      }\n    }\n    /*for(i = 0; i <= d; ++i) {\n      for(j = 0; j < 20; ++j) printf(\"%d \", dp[i][j]);\n      printf(\"\\n\");\n    }*/\n    int ans = inf;\n    for(i = 0; i <= 100; ++i) if(ans > dp[d][i]) ans = dp[d][i];\n    if(ans != inf) printf(\"%d\\n\", ans);\n    else printf(\"NA\\n\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][100000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=100)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint D, N, a[111], e[111], r[111], dp[111][111];\nint main() {\n\twhile (scanf(\"%d%d\", &D, &N), D | N) {\n\t\tfor (int i = 0; i < N; i++) scanf(\"%d%d%d\", a + i, e + i, r + i);\n\t\tint maxr = *max_element(r, r + N);\n\t\tfor (int i = 0; i <= D; i++) fill(dp[i], dp[i] + maxr + 1, 999999999);\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j <= maxr; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j < r[k]) continue;\n\t\t\t\t\tint p = min(j + e[k], maxr), q = min(i + a[k], D);\n\t\t\t\t\tdp[q][p] = min(dp[q][p], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = *min_element(dp[D], dp[D] + maxr + 1);\n\t\tif (ret == 999999999) puts(\"NA\");\n\t\telse printf(\"%d\\n\", ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nvector<int> a;\nvector<int> e;\nvector<int> r;\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != INT_MAX/2) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      res = min(res, func(min(100, ex+e[i]), HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = INT_MAX/2;\n      }\n    }\n    a = vector<int>(N);\n    e = vector<int>(N);\n    r = vector<int>(N);\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << func(0, D) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b)(a=min(a,b))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100], e[100], r[100];\nint dp[101][101];\n\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\trep(i, n)scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\trep(i, 101) {\n\t\t\tdp[0][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i <= d; i++) {\n\t\t\tfor (int j = 100; j >= 0; j--) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tif (j >= r[k])cmin(dp[i][j], dp[max(0, i - a[k])][min(100, j + e[k])] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[d][0] == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\", dp[d][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define LOOP(i,x,n) for(int i=(x);i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e10;\n\nusing namespace std;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\nsigned main(){\n  int d,n;\n  while(cin>>d>>n,d){\n    bool flag=false;\n    vector<int> a(n),e(n),r(n);\n    REP(i,n){\n      cin>>a[i]>>e[i]>>r[i];\n      if(r[i]==0)flag=true;\n    }\n    if(!flag){\n      cout<<\"NA\"<<endl;\n\n    }else{\n      int dp[201][201]={};\n      bool used[201][201];\n\n      REP(i,n){\n        if(r[i]==0){\n          dp[0][e[i]]=a[i];\n          used[0][e[i]]=true;\n        }\n      }\n\n      REP(i,101){\n        REP(j,101){\n          if(used[i][j]){\n            REP(k,n){\n              if(j-r[k]>=0){\n              used[i+1][j+e[k]>=100?100:j+e[k]]=true;\n              cmax(dp[i+1][j+e[k]>=100?100:j+e[k]],dp[i][j]+a[k]);\n              }\n            }\n          }\n        }\n      }\n      // REP(i,30)cout<<i<<' ';\n      // cout<<endl;\n      // REP(i,15){\n      //   REP(j,101){\n      //     cout<<dp[i][j]<<' ';\n      //   }\n      //   cout<<endl;\n      // }cout<<endl;\n      bool f=false;\n      REP(i,101){\n        REP(j,101){\n          if(dp[i][j]>=d){\n            cout<<i+1<<endl;\n            f=true;\n            break;\n          }\n        }\n        if(f)break;\n      }\n\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][100000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=300)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 100*100+50\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1+N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1+N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i+a[k]][j+e[k]]==INF){\n\t      if(dp[i+a[k]][j+e[k]]>dp[i][j]+1) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1+N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        for(int j=r[i];j<101;j++){\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>=d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<list>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\nstruct c {\n\tint d, e, f;\n};\nunordered_map<int, c>k;\nint a, b;\nunordered_map<int, unordered_map<int, int>>memo;\nint saiki(int n, int m) {//????????????n??§????¨???????m\n\tif (memo[n][m] != -1)return memo[n][m];\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (k[i].f <= m) {\n\t\t\tif (k[i].d >= n)return memo[n][m]=1;\n\t\t\tMIN = min(MIN, 1+saiki(n-k[i].d, min(100, k[i].e + m)));\n\t\t}\n\t}\n\treturn memo[n][m]=MIN;\n}\nint main() {\n\twhile (cin >> a >> b, a | b) {\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tint h, i, j; scanf(\"%d%d%d\", &h, &i, &j);\n\t\t\tk[g] = { h,i,j };\n\t\t}\n\t\tint S = saiki(a, 0);\n\t\tif (S >= 1 << 29) { puts(\"NA\"); }\n\t\telse cout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b)(a=min(a,b))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100], e[100], r[100];\nint dp[101][101];\n\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\trep(i, n)scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\trep(i, 101) {\n\t\t\tdp[0][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i <= d; i++) {\n\t\t\tfor (int j = 100; j >= 0; j--) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tif (j >= r[k])cmin(dp[i][j], dp[max(0, i - a[k])][max(100, j + e[k])] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[d][0] == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\", dp[d][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define INF 1<<28\nusing namespace std;\n\nint d, n;\nint a[111], e[111], r[111];\nint memo[111][111111];\n\nint solve(int p, int q){\n\n  if(p < 1) return 0;\n  if(memo[p][q]) return memo[p][q];\n\n  int ret = INF;\n  for(int i=0;i<n;i++){\n    if(r[i] <= q) ret = min(ret, solve(p-a[i], q+e[i])+1);\n  }\n\n  return memo[p][q] = ret;\n}\n\nint main(){\n\n  while(scanf(\"%d %d\", &d, &n), d){\n\n    for(int i=0;i<n;i++) cin >> a[i] >> e[i] >> r[i];\n\n    memset(memo, 0, sizeof(memo));\n    int ans = solve(d, 0);\n    if(ans == INF) cout << \"NA\\n\";\n    else cout << ans << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  int dp[N1+N1+N1][N1+N1+N1],minv;\n  for(int i=0;i<N1+N1+N1;i++){\n    for(int j=0;j<N1+N1+N1;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N1;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i+a[k]][j+e[k]]==INF) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1+N1;i++){\n    for(int j=1;j<N1+N1+N1;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true){\n\t\tint d,n; cin >> d >> n;\n\t\tif(d == 0) break;\n\t\tint a[n],e[n],r[n];\n\t\tfor (int i = 0;i < n;i++){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tint dp[101][101];\n\t\tfill(dp[0],dp[101],INT_MAX);\n\n\t\tdp[0][0] = 0;\n\n\t\tfor (int i = 0;i <= d;i++){\n\t\t\tfor (int j = 0;j <= 100;j++){\n\t\t\t\tfor (int k = 0;k < n;k++){\n\t\t\t\t\tif(dp[i][j] == INT_MAX) continue;\n\t \t\t\t\tif(r[k] > j) continue;\n\t\t\t\t\tint ni = min(i+a[k],d);\n\t\t\t\t\tint nj = min(j+e[k],100);\n\t\t\t\t\tdp[ni][nj] = min(dp[ni][nj],dp[i][j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0;i <= 100;i++){\n\t\t\tans = min(dp[d][i],ans);\n\t\t}\n\t\tif(ans == INT_MAX) cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        for(int j=r[i];j<d+1;j++){\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>=d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Tool {int a, e, r;};\n\nint bfs(int D, const vector<Tool>& tool) {\n  vector<vector<bool>> visited(D + 1, vector<bool>(201, false));\n  queue<tuple<int, int, int>> q;\n  q.emplace(0, D, 0);\n  while(!q.empty()) {\n    int depth, hp, exp;\n    tie(depth, hp, exp) = q.front();\n    q.pop();\n    if(100 < depth) return INF;\n    if(hp <= 0) return depth;\n    for(const auto& t: tool) {\n      if(exp < t.r) continue;\n      int next_hp = max(hp - t.a, 0);\n      int next_exp = exp + t.e;\n      if(visited[next_hp][next_exp]) continue;\n      visited[next_hp][next_exp] = true;\n      q.emplace(depth + 1, next_hp, next_exp);\n    }\n  }\n  return INF;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    int answer = bfs(D, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint d, n, memo[110][110];\nvector <int> a, e, r;\nconst int INF = 1000000000;\n\nint rec(int c = 0, int dur = d, int exp = 0) {\n\tif (c > 110) {\n\t\treturn INF;\n\t}\n\tif (dur <= 0) {\n\t\treturn 0;\n\t}\n\tif (memo[dur][exp] != -1) {\n\t\treturn memo[dur][exp];\n\t}\n\tint res = INF;\n\trep (i, n) {\n\t\tif (exp < r[i]) continue;\n\t\tif (e[i] == 0) continue;\n\t\tres = min(res, rec(c + 1, dur - a[i], min(exp + e[i], 101)) + 1);\n\t}\n\treturn memo[dur][exp] = res;\n}\n\nint main() {\n\tint cnt = 0;\n\twhile(cin >> d >> n, n) {\n\t\ta = e = r = vector <int> (n);\n\t\trep (i, n) cin >> a[i] >> e[i] >> r[i];\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tint ans = rec();\n\t\tcout << (ans == INF ? \"NA\" : to_string(ans)) << endl;\n\t\tcnt++;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,s;\nvector<pair<pair<int,int>,int> >v;\nvoid dfs(int p,int x,int t){\n  if(t>=s)return;\n  if(p<=0){s=t;return;}\n  if(x>10000)return;\n  for(int i=v.size()-1;i>=0;i--)\n    if(v[i].s<=x)dfs(p-v[i].f.f,x+v[i].f.s,t+1);\n}\nint main(){\n  while(cin>>d>>n,d){\n    v.clear();s=1000000;\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end());\n    dfs(d,0,0);\n    if(s!=10000000)cout<<\"NA\"<<endl;\n    else cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[160][1000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(x>=1000)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint D, N, a[111], e[111], r[111], dp[111][111][999];\nint rec(int f1, int f2, int d) {\n\tif (f1 >= D) return d;\n\tif (dp[f1][f2][d]) return dp[f1][f2][d] - 1;\n\tint ret = 999999999;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!a[i] && !e[i]) continue;\n\t\tif (f2 >= r[i]) ret = min(ret, rec(f1 + a[i], min(f2 + e[i], 100), d + 1));\n\t}\n\tdp[f1][f2][d] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> D >> N, D | N) {\n\t\tfor (int i = 0; i < N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tfor (int k = 0; k < N * 2; k++) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = rec(0, 0, 0);\n\t\tif (ret == 999999999) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\nconst long long int MOD=1000000007;\n\n\n\nint main(){\n\t\n\tint l,N;\n\twhile(cin>>l>>N,l){\n\t\tvector<int>damage(N);\n\t\tvector<int>exp(N);\n\t\tvector<int>req(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>damage[i]>>exp[i]>>req[i];\n\t\t}\n\t\tvector<vector<int>>dp(l+1,vector<int>(101,MOD));\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(int i=1;i<=l;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(j<req[k])continue;\n\t\t\t\t\tint left=max(0,i-damage[k]);\n\t\t\t\t\tint nxexp=min(100,j+exp[k]);\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[left][nxexp]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[1][0]==MOD)cout<<\"NA\\n\";\n\t\telse cout<<dp[l][0]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[160][40001];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint ans;\nint dp[101][101];\n\nint solve(int hp, int exp) {\n\n    if(hp <= 0) {\n        return 0;\n    }\n\n    if(dp[hp][exp] != -1) {\n        return dp[hp][exp];\n    }\n\n    int ret = INF;\n    for(int i = 0; i < n; ++i) {\n        if(exp >= r[i]) {\n            ret = min(ret, solve(max(0, hp - a[i]), min(100, exp + e[i])) + 1);\n        }\n    }\n\n    return dp[hp][exp] = ret;\n}\n\nint main() {\n\n    while(cin >> d >> n, d || n) {\n\n        int wastes = 0;\n\n        for(int i = 0; i < n; ++i) {\n            cin >> a[i] >> e[i] >> r[i];\n            if(a[i] == 0) {\n                ++wastes;\n            }\n        }\n\n        n -= wastes;\n\n        memset(dp, -1, sizeof(dp));\n\n        ans = solve(d, 0);\n\n        if(ans == INF) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Tool {int a, e, r;};\n\nint solve(int D, const vector<Tool>& tool) {\n    vector<vector<vector<int>>> dp(201, vector<vector<int>>(D + 1, vector<int>(201, INF)));\n    dp[0][D][0] = 0;\n    for(int step = 0; step < 200; ++step) {\n//       for(int hp = D; 0 <= hp; --hp) {\n//         for(int exp = 200; 0 <= exp; --exp) {\n      for(int hp = 0; hp <= D; ++hp) {\n        for(int exp = 0; exp <= 200; ++exp) {\n          for(const auto& t: tool) {\n            if(exp < t.r) continue;\n            int nhp = max(hp - t.a, 0);\n            int nexp = exp + t.e;\n            if(200 < nexp) continue;\n            dp[step + 1][nhp][nexp] = min(dp[step + 1][nhp][nexp], dp[step][hp][exp] + 1);\n            if(dp[step + 1][0][nexp] != INF) return dp[step + 1][0][nexp];\n          }\n        }\n      }\n//       for(int exp = 0; exp <= 200; ++exp) if(dp[step + 1][0][exp] != INF) return dp[step + 1][0][exp];\n    }\n  return INF;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    int answer = solve(D, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d >= D) return 0;\n    if(exp > 100) return INF;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        int dd = min(D,d+a[i]), ee = min(100,exp+e[i]);\n        if(dd==d && ee==100) continue;\n        if(r[i] <= exp) res = min(res, 1+solve(dd,ee));\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N){\n            cin >> a[i] >> e[i] >> r[i];\n            if(a[i]==0 && e[i]==0) r[i] = INF;\n        }\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 100*100+50\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i][j]!=INF){\n\t      if(dp[i+a[k]][j+e[k]]>dp[i][j]+1) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\nint ans,cnt ;\nint maxr;\nvoid saiki(int d,int ex,int kai) {\n  cnt++;\n  if(d <= 0 ) dp[0][ex] = 0;\n  if(d > 0) {\n    for(int i=0;i<n;i++) {\n      if(r[i] <= ex) {\n\tint da  =  d-a[i];\n\tif(da < 0) da = 0;\n\tif(maxr <=ex && a[i] == 0) continue;\n\tif(a[i] == 0 && r[i] == 0) continue;\n\tif(dp[da][ex+e[i]] < INF) {\n\t  dp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n\t  continue;\n\t}\n        saiki(da,ex+e[i],kai+1);\n\tdp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n      }\n    }\n  }\n}\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    maxr = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n    }\n    \n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=20000;j++)\n\tdp[i][j] = INF;\n    \n    saiki(d,0,0);\n\n    if(dp[d][0] == INF) cout << \"NA\" <<endl;\n    else cout << dp[d][0] <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nconst int MAX_V = 10000;\nstruct edge {};\nvector<edge> G[MAX_V];\n\n// ??§????????°INF\nconst int INF = (1<<30);\n// ?¨±?????????????????\nconst double EPS =(1e-10);\n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint D, N;\n\twhile (true) {\n\t\tcin >> D >> N; if (D == 0 && N == 0)break;\n\t\tvector<int> a(N), e(N), r(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\t\tvector<vector<int>>dp(D+1,vector<int>(101,INF));\n\t\tdp[D][0] = 0;\n\t\tfor (int i = D; i >= 0; --i) {\n\t\t\tfor (int j = 0; j < 101; ++j) {\n\t\t\t\tif (dp[i][j] == INF)continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (j < r[k])continue;\n\t\t\t\t\tint tmp_i = max(0, i - a[k]), tmp_j = min(100, j + e[k]);\n\t\t\t\t\tdp[tmp_i][tmp_j] = min(dp[tmp_i][tmp_j], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < 101; ++i)ans = min(ans, dp[0][i]);\n\t\tif (ans == INF) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[160][100010];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][11111];\nint solve(int d, int exp){\n    if(d >= D) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            if(a[i]==0 && e[i]==0) continue;\n            int iter = min(a[i] ? 100/a[i]+1 : INF, e[i] ? 100/e[i]+1 : INF);\n            loop(j,1,iter+1){\n                res = min<int>(res, j+solve(d+a[i]*j, exp+e[i]*j));\n            }\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int INF = 1e+9;\nint DP[128][128];\nint main() {\n\tint D, N;\n\twhile(cin >> D >> N && (D || N)){\n\t\tint a[128], e[128], r[128];\n\t\tfor(int i = 0; i < N; ++i)\n\t\t\tscanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tfor(int i = 0; i <= D; ++i)\n\t\t\tfor(int j = 0; j <= 100; ++j)\n\t\t\t\tDP[i][j] = INF;\n\t\tDP[D][0] = 0;\n\t\tfor(int i = D; i > 0; --i){\n\t\t\tfor(int j = 0; j <= 100; ++j){\n\t\t\t\tfor(int k = 0; k < N; ++k){\n\t\t\t\t\tif(j >= r[k])\n\t\t\t\t\tDP[max(0, i - a[k])][min(100, j + e[k])] = min(DP[max(0, i - a[k])][min(100, j + e[k])], DP[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i = 0; i <= 100; ++i)\n\t\t\tans = min(ans, DP[0][i]);\n\t\tif(ans == INF){\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\nint ans,cnt ;\n\nvoid saiki(int d,int ex,int kai) {\n  cnt++;\n  if(d <= 0 ) dp[0][ex] = 0;\n  if(d > 0) {\n    for(int i=0;i<n;i++) {\n      if(r[i] <= ex) {\n\tint da  =  d-a[i];\n\tif(da < 0) da = 0;\n\tif(dp[da][ex+e[i]] < INF) {\n\t  dp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n\t  continue;\n\t}\n        saiki(da,ex+e[i],kai+1);\n\tdp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n      }\n    }\n  }\n}\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n\n    for(int i=0;i<n;i++) cin >> a[i] >> e[i] >> r[i];\n    \n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=20000;j++)\n\tdp[i][j] = INF;\n\n    saiki(d,0,0);\n\n    if(dp[d][0] == INF) cout << \"NA\" <<endl;\n    else cout << dp[d][0] <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[10000][100010];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nint a[256], e[256], r[256];\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != -1) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      res = min(res, func(min(110, ex+e[i]), HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = -1;\n      }\n    }\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << func(0, D) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct c {\n\tint d, e, f;\n};\nc k[100];\nint a, b;\nint memo[101][101];\nint saiki(int n, int m) {//????????????n??§????¨???????m\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (k[i].f <= m) {\n\t\t\tif (k[i].d >= n)return memo[n][m]=1;\n\t\t\tint O = 0;\n\t\t\tif (memo[n - k[i].d][min(100, k[i].e + m)] != -1) {\n\t\t\t\tO = 1+memo[n - k[i].d][min(100, k[i].e + m)];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tO = 1 + saiki(n - k[i].d, min(100, k[i].e + m));\n\t\t\t}\n\t\t\tMIN = min(MIN,O);\n\t\t}\n\t}\n\treturn memo[n][m]=MIN;\n}\nint main() {\n\twhile (cin >> a >> b, a | b) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tint h, i, j; scanf(\"%d%d%d\", &h, &i, &j);\n\t\t\tk[g] = { h,i,j };\n\t\t}\n\t\tint S = saiki(a, 0);\n\t\tif (S >= 1 << 29) { puts(\"NA\"); }\n\t\telse cout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\twhile (true){\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int cou = 0; cou < N; cou++){\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\tfor (int j = R[i]; j <= 109; j++){\n\t\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\t\tif (j + E[i] <= 109)DP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t\telse DP[109][k + 1] = max(DP[109][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>=d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int n,d;\n    while(cin>>d>>n,n||d){\n        int a[100],e[100],r[100];\n        for(int i=0;i<n;i++)cin>>a[i]>>e[i]>>r[i];\n        int dp[101][101];fill_n(*dp,101*101,1<<25);\n        dp[0][0]=0;\n        for(int i=0;i<d;i++){\n            for(int j=0;j<=100;j++){\n                for(int k=0;k<n;k++){\n                    if(j<r[k])continue;\n                    int a_=min(i+a[k],d);\n                    int e_=min(j+e[k],100);\n                    dp[a_][e_]=min(dp[a_][e_],dp[i][j]+1);\n                }\n            }\n        }\n        int mi=1<<25;\n        for(int i=0;i<=100;i++)mi=min(dp[d][i],mi);\n        if(mi==(1<<25))cout<<\"NA\"<<endl;\n        else cout<<mi<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\twhile (1) {\n\t\tint D, N; cin >> D >> N;\n\t\tif (!D)break;\n\t\tvector<int>as, es, rs;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a, e, r; cin >> a >>e >> r;\n\t\t\tas.push_back(a);\n\t\t\tes.push_back(e);\n\t\t\trs.push_back(r);\n\n\t\t}\n\t\tint dp[101][101];\n\t\tfor (int i = 0; i < 101; ++i) {\n\t\t\tfor (int j = 0; j < 101; ++j) {\n\t\t\t\tdp[i][j] = 1000;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tfor (int d = 0; d < D; ++d) {\n\t\t\tfor (int e = 0; e <= 100; ++e) {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tif (e >= rs[i]) {\n\t\t\t\t\t\tconst int nexte = min(100, e + es[i]);\n\t\t\t\t\t\tconst int nextd = min(D, d + as[i]);\n\t\t\t\t\t\tdp[nextd][nexte] = min(dp[nextd][nexte], dp[d][e] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000;\n\t\tfor (int d = D; d <= D; ++d) {\n\t\t\tfor (int e = 0; e <= 100; ++e) {\n\t\t\t\tans = min(ans, dp[d][e]);\n\t\t\t}\n\t\t}\n\t\tif (ans == 1000)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint D, N, w, a[111], e[111], r[111]; int dp[111][111][222];\nint rec(int f1, int f2, int d) {\n\tif (f1 >= D) return d;\n\tif (dp[f1][f2][d]) return dp[f1][f2][d] - 1;\n\tint ret = 255;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!a[i] && (!e[i] || f2 == w)) continue;\n\t\tif (f2 >= r[i]) ret = min(ret, rec(f1 + a[i], min(f2 + e[i], w), d + 1));\n\t}\n\tdp[f1][f2][d] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> D >> N, D | N) {\n\t\tfor (int i = 0; i < N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tw = *max_element(r, r + N);\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j <= w; j++) fill(dp[i][j], dp[i][j] + N * 2, 0);\n\t\t}\n\t\tint ret = rec(0, 0, 0);\n\t\tif (ret == 255) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint D, n;\nint a[100], e[100], d[100];\nint memo[110][110];\n\nint dfs(int tai, int ex){\n\n  if(tai <= 0){\n    return 0;\n  }\n\n  if(memo[tai][ex] != -1){\n    return memo[tai][ex];\n  }\n\n  int ans = 100000000;\n\n  for(int i = 0;i < n;i++){\n    if((a[i] != 0 && d[i] <= ex) || (a[i] == 0 && d[i] <= ex && ex < 100)){\n      ans = min(ans, dfs(tai-a[i], min(ex+e[i],100))+1);\n    }\n  }\n\n  return memo[tai][ex] = ans;\n}\n\nint main(){\n  while(cin >> D >> n, D != 0){\n    bool zeroFrag = false;\n    for(int i = 0;i < n;i++){\n      cin >> a[i] >> e[i] >> d[i];\n      if(a[i] == 0 && e[i] == 0){\n        i--;\n        n--;\n      }else if(d[i] == 0){\n        zeroFrag = true;\n      }\n    }\n\n    if(zeroFrag){\n      memset(memo,-1,sizeof(memo));\n      int ans = dfs(D, 0);\n      if(ans >= 100000000){\n        cout << \"NA\" << endl;\n      }else{\n        cout << ans << endl;\n      }\n    }else{\n      cout << \"NA\" << endl;\n    }\n\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint ans;\nint dp[101][101];\n\nint solve(int hp, int exp) {\n\n    if(hp <= 0) {\n        return 0;\n    }\n\n    if(dp[hp][exp] != -1) {\n        return dp[hp][exp];\n    }\n\n    int ret = INF;\n    for(int i = 0; i < n; ++i) {\n        if(exp >= r[i]) {\n            if(a[i] == 0 && (exp >= 100 || e[i] == 0)) continue;\n            ret = min(ret, solve(max(0, hp - a[i]), min(100, exp + e[i])) + 1);\n        }\n    }\n\n    return dp[hp][exp] = ret;\n}\n\nint main() {\n\n    while(cin >> d >> n, d || n) {\n\n        for(int i = 0; i < n; ++i) {\n            cin >> a[i] >> e[i] >> r[i];\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        ans = solve(d, 0);\n\n        if(ans == INF) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint memo[110][110][110];\n\nint d, n;\npair<int, pair<int, int> > ono[110];\n\nint dp(int i, int noko, int num){\n\t\n\tif(noko <= 0){\n\t\treturn 0;\n\t}\n\n\tif(i == n){\n\t\treturn INT_MAX;\n\t}\n\t\n\tint r = ono[i].first;\n\tint a = ono[i].second.first;\n\tint e = ono[i].second.second;\n\t\n\tif(r > num){\n\t\treturn INT_MAX;\n\t}\n\t\n\tif(memo[i][noko][num] != -1){\n\t\treturn memo[i][noko][num];\n\t}\n\tif(a == 0 && e == 0){\n\t\treturn memo[i][noko][num] = dp(i+1, noko, num);\n\t}\n\t\n\tif(num == 100 && a == 0){\n\t\treturn memo[i][noko][num] = dp(i+1, noko, num);\n\t}\n\t\n\treturn memo[i][noko][num] = min(dp(i, noko-a, min(100ll, num+e))+1, dp(i+1, noko, num));\n}\n\t\nsigned main(){\n\twhile(cin >> d >> n, d != 0){\n\t\tint a, e, r;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> a >> e >> r;\n\t\t\tono[i] = {r, {a, e}};\n\t\t}\n\t\t\n\t\tsort(ono, ono+n);\n\t\t\n\t\tmemset(memo, -1, sizeof(memo));\n\t\t\n\t\tint ans = dp(0, d, 0);\n\t\t\n\t\tif(ans < INT_MAX){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\t\t\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nint a[256], e[256], r[256];\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != -1) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      if(a[i] <= 0) continue;\n      res = min(res, func(min(100,ex+e[i]), HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = -1;\n      }\n    }\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nint a[256], e[256], r[256];\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != -1) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      if(a[i] <= 0 && e[i] == 0) continue;\n      res = min(res, func(min(100,ex+e[i]), HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = -1;\n      }\n    }\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][100000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0,k=1;\n  if(t>=100)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b>=2)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end(),greater<pair<pair<int,int>,int> >());\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 110\n#define MAX_R 110\n#define MAX_D 110\n\nstruct State{\n  int r,d;\n  State(){}\n  State(int r,int d) : r(r),d(d) {}\n};\n\nint D,N;\nint a[MAX_N],e[MAX_N],r[MAX_N];\n\nint bfs(){\n  queue<State> Q; Q.push(State(0,D));\n  queue<int> step; step.push(0);\n  bool visited[MAX_R][MAX_D] = {{false}};\n  visited[0][D] = true;\n  while(!Q.empty()){\n    State s = Q.front(); Q.pop();\n    int stp = step.front(); step.pop();\n    if(s.d == 0){ return stp; }\n    for(int i = 0 ; i < N ; i++){\n      State ns = (State){min(100,s.r+e[i]),max(0,s.d-a[i])};\n      if(s.r >= r[i] && !visited[ns.r][ns.d]){\n        visited[ns.r][ns.d] = true;\n        Q.push(ns);\n        step.push(stp+1);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin >> D >> N, D){\n    for(int i = 0 ; i < N ; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int res = bfs();\n    if(res == -1){\n      cout << \"NA\" << endl;\n    }else{\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d >= D || exp >= 111) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            if(a[i]==0 && e[i]==0) continue;\n            res = min(res, 1+solve(d+a[i], exp+e[i]));\n            // int iter = min(a[i] ? 100/a[i]+1 : INF, e[i] ? 100/e[i]+1 : INF);\n            // loop(j,1,iter+1){\n            //     res = min<int>(res, j+solve(d+a[i]*j, exp+e[i]*j));\n            // }\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<10003;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\nif(n!=1)return 1;\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int d,n,table[101][101];\n  while(cin>>d>>n,d){\n    int dp[101][d+1],a[n],e[n],r[n];\n    memset(dp,-1,sizeof(dp));\n    dp[0][0]=0;\n    r(i,n)cin>>a[i]>>e[i]>>r[i];\n    for(int o=1;o<203;o++){\n      r(i,101)r(j,d+1)table[i][j]=dp[i][j];\n      r(i,n){\n        r(j,101){\n          if(j<r[i])continue;\n          r(k,d+1){\n            if(dp[j][k]!=-1){\n              int y=j+e[i];\n              int x=k+a[i];\n              if(x>d){\n                cout<<o<<endl;\n                goto L;\n              }\n              if(y>100)y=100;\n              if(table[y][x]==-1)table[y][x]=o;\n            }\n          }\n        }\n      }\n      r(i,101)r(j,d+1)dp[i][j]=table[i][j];\n    }\n    cout<<\"NA\"<<endl;\n    L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\nint ans,cnt ;\nint maxr;\nvoid saiki(int d,int ex,int kai) {\n  cnt++;\n  if(d <= 0 ) dp[0][ex] = 0;\n  if(d > 0) {\n    for(int i=0;i<n;i++) {\n      if(r[i] <= ex) {\n\tint da  =  d-a[i];\n\tif(da < 0) da = 0;\n\tif(maxr <=ex && a[i] == 0) continue;\n\tif(dp[da][ex+e[i]] < INF) {\n\t  dp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n\t  continue;\n\t}\n        saiki(da,ex+e[i],kai+1);\n\tdp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n      }\n    }\n  }\n}\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    maxr = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n    }\n    \n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=20000;j++)\n\tdp[i][j] = INF;\n    \n    saiki(d,0,0);\n\n    if(dp[d][0] == INF) cout << \"NA\" <<endl;\n    else cout << dp[d][0] <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint n;\nvector<int> a, e, r;\n\nint memo[105][105];\nvoid dfs(int exp, int hp, int sum){\n\tif(memo[exp][hp] <= sum) return;\n\tmemo[exp][hp] = sum;\n\n\trep(i,n){\n\t\tif(exp < r[i]) continue;\n\t\tdfs(min(100, exp + e[i]), max(0, hp - a[i]), sum + 1);\n\t}\n}\n\nint main(){\n\tint d;\n\twhile(cin >> d >> n, d||n){\n\n\t\ta = vector<int>(n);\n\t\te = vector<int>(n);\n\t\tr = vector<int>(n);\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tconst int INF = 1e8;\n\t\trep(i,105) rep(j,105) memo[i][j] = INF;\n\t\tdfs(0, d, 0);\n\n\t\tint ans = INF;\n\t\trep(i,101){\n\t\t\tif(memo[i][0] == -1) continue;\n\t\t\tans = min(ans, memo[i][0]);\n\t\t}\n\t\tif(ans == INF) cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint D, N, a[111], e[111], r[111], dp[111][111];\nint main() {\n\twhile (scanf(\"%d%d\", &D, &N), D | N) {\n\t\tfor (int i = 0; i < N; i++) scanf(\"%d%d%d\", a + i, e + i, r + i);\n\t\tint maxr = *max_element(r, r + N);\n\t\tfor (int i = 0; i <= D; i++) fill(dp[i], dp[i] + maxr + 1, 999999999);\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j <= maxr; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j < r[k]) continue;\n\t\t\t\t\tint p = min(j + e[k], maxr), q = min(i + a[k], D);\n\t\t\t\t\tdp[q][p] = min(dp[q][p], dp[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = *min_element(dp[D], dp[D] + maxr + 1);\n\t\tif (ret == 999999999) puts(\"NA\");\n\t\telse printf(\"%d\\n\", ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 100*100\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1+N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1+N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i+a[k]][j+e[k]]==INF) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1+N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n      maxe = max(maxe,e[i]);\n    }\n\n    int N = 10000;\n   \n    int ans = INF;\n    for(int j=0;j<=N;j++) { //?????¨???????¨????\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tdp[i][j] = INF;\n\tif(j == 0 && i == d) dp[i][j] = 0;\n\tfor(int k=0;k<n;k++) {\n\t  int na = i+a[k];\n\t  int ne = j-e[k];\n\t  if(na > d) na = d;\n\t  if(ne < 0) ne = 0;\n\t  if(ne < r[k]) continue;\n\t  dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t}\n      }\n      ans = min(ans,dp[0][j]);\n    }\n  \n\n\n    /*\n    for(int j=0;j<=N;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n    }\n    */\n    \n    \n\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint D, N;\nvector<int> a(110), e(110), r(110); //耐久力 経験値 必要な経験値\nint dp[110][11000]; //耐久力 i の時に 経験値 j の時の回数\n\nint solve(int d, int exp){\n\tint ret = 10e8;\n\tif(d <= 0) return 0;\n\tif(dp[d][exp] != -1) return dp[d][exp];\n\tfor(int i=0; i< N; i++){\n\t\tint E = min(110, exp+e[i]);\n\t\tif(a[i] == 0 && E == exp) continue;\n\t\tif(r[i] <= exp) ret = min(ret, solve(d-a[i], E)+1);\n\t}\n\tdp[d][exp] = ret;\n\treturn ret;\n}\n\nint main(){\n\twhile(cin >> D >> N, D+N){\n\t\tfor(int i=0; i< N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tfor(int i=0; i < 110; i++)for(int j=0; j< 11000; j++) dp[i][j] = -1;\n\t\tint ret = solve(D, 0);\n\t\tif(ret == 10e8) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,s;\nvector<pair<pair<int,int>,int> >v;\nvoid dfs(int p,int x,int t){\n  if(t>=s)return;\n  if(p<0){s=t;return;}\n  if(x>10000)return;\n  for(int i=v.size()-1;i>=0;i--)\n    if(v[i].s<=x)dfs(p-v[i].f.f,x+v[i].f.s,t+1);\n}\nint main(){\n  while(cin>>d>>n,d){\n    v.clear();s=1000000;\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end());\n    dfs(d,0,0);\n    if(s!=10000000)cout<<\"NA\"<<endl;\n    else cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 1 << 29;\nint a[10100], e[10100], r[10100];\nint d, n;\n\n// ?¨??????????,??????????????°???????¨????\nint func(int hp, int m, int k){\n\tif(hp <= 0) return m;\n\tint res = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(k >= r[i]){\n\t\t\tres = min(res, func(hp - a[i], m + 1, k + e[i]));\n\t\t}\n\t}\n\tif(res == INF){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0; \n\t}\n\tif(m == 0){\n\t\tcout << res << endl;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> d >> n && (d || n)){\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tfunc(d, 0, 0);\n\t}\n\n\treturn 0;\n}\n\n/*\na ??????????????????\ne ??????????¨????\nr ??????????¨????\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 100*100+50\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1+N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1+N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i+a[k]][j+e[k]]==INF&&dp[i][j]!=INF){\n\t      if(dp[i+a[k]][j+e[k]]>dp[i][j]+1) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1+N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d >= D || exp >= 111) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            if(a[i]==0 && e[i]==0) continue;\n            int iter = min(a[i] ? 100/a[i]+1 : INF, e[i] ? 100/e[i]+1 : INF);\n            loop(j,1,iter+1){\n                res = min<int>(res, j+solve(d+a[i]*j, exp+e[i]*j));\n            }\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint dp[110][110][110];\nstruct S {\n\tint a, e, r;\n\tbool operator <(const S& x) const {\n\t\treturn r < x.r;\n\t}\n} t[100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint D, N;\n\twhile(cin >> D >> N, D) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> t[i].a >> t[i].e >> t[i].r;\n\t\t}\n\t\tsort(t, t + N);\n\n\t\tconst int INF = 1 << 25;\n\t\tfill((int*)begin(dp), (int*)end(dp), INF);\n\t\tdp[0][0][D] = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j <= 100; j++) {\n\t\t\t\tfor(int k = 1; k <= D; k++) {\n\t\t\t\t\tif(dp[i][j][k] == INF) continue;\n\t\t\t\t\tif(t[i].r <= j) {\n\t\t\t\t\t\tfor(int l = 0;; l++) {\n\t\t\t\t\t\t\tint nj = min(100, j + t[i].e * l);\n\t\t\t\t\t\t\tint nk = max(0, k - t[i].a * l);\n\t\t\t\t\t\t\tdp[i + 1][nj][nk] = min(dp[i + 1][nj][nk], dp[i][j][k] + l);\n\t\t\t\t\t\t\tif(nk == 0) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int j = 0; j <= 100; j++) {\n\t\t\tans = min(ans, dp[N][j][0]);\n\t\t}\n\t\tif(ans == INF) cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//道具を使う順番もあまり関係なかったりする。でも素直に耐久力と経験値に注目しちゃえば良い。\n#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef pair<int,PII> PIII;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint main() {\n\twhile( cin >> d >> n ) {\n\t\tif(!d) break;\n\t\tint i, j;\n\t\tfor( i = 0; i < n; i++ )\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t\n\t\tint dp[101][101];\t\t//dp[残り耐久力][min(EXP,100)]\n\t\tfor( i = 0; i < 101; i++ ) {\n\t\t\tfor( j = 0; j < 101; j++ ) {\n\t\t\t\tdp[i][j] = 1000000;\n\t\t\t}\n\t\t}\n\t\tstack<PIII> data;\n\t\tdata.push(PIII(0, PII(d, 0)) );\n\t\twhile( !data.empty() ) {\n\t\t\tint Cost = data.top().first;\n\t\t\tint Dif = data.top().second.first;\n\t\t\tint Exp = data.top().second.second;\n\t\t\tdata.pop();\n\t\t\tif( dp[Dif][Exp] <= Cost )\n\t\t\t\tcontinue;\n\t\t\tdp[Dif][Exp] = Cost;\n\t\t\t\n\t\t\tfor( i = 0; i < n; i++ ) {\n\t\t\t\tif( Exp >= r[i] ) {\n\t\t\t\t\t//殴る\n\t\t\t\t\tint nCost = Cost+1;\n\t\t\t\t\tint nDif = max(0, Dif - a[i]);\n\t\t\t\t\tint nExp = min(100, Exp + e[i]);\n\t\t\t\t\t//遷移する\n\t\t\t\t\tdata.push( PIII( nCost, PII(nDif, nExp)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 100000;\n\t\tfor( i = 0; i < 101; i++ ) {\n\t\t\tif( dp[0][i] < 10000 ) {\n\t\t\t\tans = min(dp[0][i], ans);\n\t\t\t}\n\t\t}\n\t\tif( ans < 10000 )\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d >= D) return 0;\n    if(exp >= 111) return INF;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            if(a[i]==0 && e[i]==0) continue;\n            res = min(res, 1+solve(d+a[i], exp+e[i]));\n            // int iter = min(a[i] ? 100/a[i]+1 : INF, e[i] ? 100/e[i]+1 : INF);\n            // loop(j,1,iter+1){\n            //     res = min<int>(res, j+solve(d+a[i]*j, exp+e[i]*j));\n            // }\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cmin(a,b)(a=min(a,b))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[100], e[100], r[100];\nint dp[101][101];\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\trep(i, n)scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\trep(i, 101)dp[0][i] = 0;\n\t\trep(i, d + 1)for (int j = 100; j >= 0; j--) {\n\t\t\tif (dp[i][j] == INF)continue;\n\t\t\trep(k, n) {\n\t\t\t\tif (j - e[k] >= r[k]) {\n\t\t\t\t\trep(p, e[k] + 1)rep(t, a[k] + 1) {\n\t\t\t\t\t\tcmin(dp[min(d, i + t)][j - p], dp[i][j] + 1);\n\t\t\t\t\t\tif (min(d, i + t) == d)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[d][0] == INF)puts(\"NA\");\n\t\telse printf(\"%d\\n\", dp[d][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint a[128], e[128], r[128];\nint memo[128][128];\nint D, N;\n\nint getMin(int left, int exp)\n{\n\tif (left <= 0) return (0);\n\tif (memo[left][exp] >= 0) return (memo[left][exp]);\n\t\n\tint ans = 99999;\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tif (exp == 100 && a[i] == 0) continue;\n\t\tif (r[i] <= exp && !(a[i] == 0 && e[i] == 0))\n\t\t\tans = min(ans, getMin(left - a[i], min(100, exp + e[i])) + 1);\n\t}\n\t\n\treturn (memo[left][exp] = ans);\n}\n\nint main()\n{\n\t\n\twhile (scanf(\"%d %d\", &D, &N) && N){\n\t\tbool e0 = false;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tscanf(\"%d %d %d\", a + i, e + i, r + i);\n\t\t\tif (r[i] == 0) e0 = true;\n\t\t}\n\t\t\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tint ans = getMin(D, 0);\n\t\t\n\t\tif (ans >= 99999) printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define LOOP(i,x,n) for(int i=(x);i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e10;\n\nusing namespace std;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\nsigned main(){\n  int d,n;\n  while(cin>>d>>n,d){\n    bool flag=false;\n    vector<int> a(n),e(n),r(n);\n    REP(i,n){\n      cin>>a[i]>>e[i]>>r[i];\n      if(r[i]==0)flag=true;\n    }\n    if(flag==false){\n      cout<<\"NA\"<<endl;\n\n    }else{\n      int dp[301][301]={};\n      int used[301][301]={};\n\n      REP(i,n){\n        if(r[i]==0){\n          dp[0][e[i]]=a[i];\n          used[0][e[i]]=1;\n        }\n      }\n\n      REP(i,201){\n        REP(j,101){\n          if(used[i][j]){\n            REP(k,n){\n              if(j-r[k]>=0){\n              used[i+1][j+e[k]>=100?100:j+e[k]]=1;\n              cmax(dp[i+1][j+e[k]>=100?100:j+e[k]],dp[i][j]+a[k]);\n              }\n            }\n          }\n        }\n      }\n      // REP(i,30)cout<<i<<' ';\n      // cout<<endl;\n      // REP(i,15){\n      //   REP(j,101){\n      //     cout<<dp[i][j]<<' ';\n      //   }\n      //   cout<<endl;\n      // }cout<<endl;\n      bool f=false;\n      REP(i,201){\n        REP(j,101){\n          if(dp[i][j]>=d){\n            cout<<i+1<<endl;\n            f=true;\n            break;\n          }\n        }\n        if(f)break;\n      }\n      if(f==false){\n        cout<<\"NA\"<<endl;\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<20)\ntypedef pair<int,int> P;\ntypedef pair<int,P> Pi;\n\nint D,N;\nint a[111],e[111],r[111];\nint dp[111][111];\n\nint main(){\n  while(cin >> D >> N , D){\n    fill_n(*dp,111*111,INF);\n    for(int i=0;i<N;i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    dp[D][0] = 0;\n    for(int i=D;i>0;i--){\n      for(int j=0;j<101;j++){\n\tif(dp[i][j] == INF) continue;\n\tfor(int k=0;k<N;k++){\n\t  if(j < r[k]) continue;\n\t  dp[max(0,i-a[k])][min(100,j+e[k])] = min(dp[max(0,i-a[k])][min(100,j+e[k])],dp[i][j]+1);\n\t}\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<101;i++){\n      ans = min(ans,dp[0][i]);\n    }\n    if(ans == INF) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nvector<int> a;\nvector<int> e;\nvector<int> r;\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  int res = INT_MAX;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      res = min(res, func(ex+e[i], HP-a[i])+1);\n    }\n  }\n  return res;\n}\n\nint main(void){\n  while(cin >> D >> N, D | N){\n    a = vector<int>(N);\n    e = vector<int>(N);\n    r = vector<int>(N);\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX){\n      cout << \"NA\" << endl;\n    }else{\n      cout << func(0, D) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint dp[100][101];\t//??¨?????????,?????????????¨???°(100??§????????????)\n\nint n;\nint a[100],e[100],r[100];\t//??????????¨??????¶???\n\nint solve(int dNow,int eNow){\n\tif(dNow<0) return 0;\t//?????????????????????\n\t//if(dp[dNow][eNow]!=-1) return dp[dNow][eNow];\n\n\tint ans=114514;\n\tfor(int i=0;i<n;i++){\n\t\tif(eNow<r[i]) continue;\n\t\tans=min(ans,1+solve(dNow-a[i],min(eNow+e[i],100)));\n\t}\n\n\t//dp[dNow][eNow]=ans;\n\treturn ans;\n}\n\nint main(){\n\tint d;\t//??¨????????????\n\tint i,j;\n\tbool able;\n\twhile(cin>>d,d>0){\n\t\tcin>>n;\n\t\table=false;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>a[i]>>e[i]>>r[i];\n\t\t\tif(r[i]==0) able=true;\n\t\t}\n\t\tif(!able){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<100;i++){\n\t\t\tfor(j=0;j<101;j++){\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tcout<<solve(d-1,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint dp[100][101];\t//??¨?????????,?????????????¨???°(100??§????????????)\n\nint n;\nint a[100],e[100],r[100];\t//??????????¨??????¶???\n\nint solve(int dNow,int eNow){\n\tif(dNow<0) return 0;\t//?????????????????????\n\tif(dp[dNow][eNow]!=-1) return dp[dNow][eNow];\n\n\tint ans=114514;\n\tbool able=false;\n\tfor(int i=0;i<n;i++){\n\t\tif(eNow<r[i]) continue;\n\t\tif(a[i]==0 && (100<=eNow || e[i]==0)) continue;\n\t\table=true;\n\t\tans=min(ans,1+solve(dNow-a[i],min(eNow+e[i],100)));\n\t}\n\n\tif(!able){\n\t\treturn -1;\n\t}\n\n\tdp[dNow][eNow]=ans;\n\treturn ans;\n}\n\nint main(){\n\tint d;\t//??¨????????????\n\tint i,j;\n\twhile(cin>>d,d>0){\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>a[i]>>e[i]>>r[i];\n\t\t}\n\n\t\tfor(i=0;i<100;i++){\n\t\t\tfor(j=0;j<101;j++){\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tint ans=solve(d-1,0);\n\t\tif(ans==-1){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t}else{\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\tint O = 0;\n\twhile (true){\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (R[i]>R[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t\telse if (R[i] == R[j] && A[i] < A[j] && E[i] < E[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(O<=100000000){\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\tfor (int j = R[i]; j <= 109; j++){\n\t\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\t\tO++;\n\t\t\t\t\t\tif (j + E[i] <= 109)DP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t\telse DP[109][k + 1] = max(DP[109][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nint a[256], e[256], r[256];\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != -1) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      if(a[i] <= 0) continue;\n      res = min(res, func(min(110, ex+e[i]), HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = -1;\n      }\n    }\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nstruct Data\n{\n\tint A,E,R;\n\n\tData(int a,int e,int r)\n\t{\n\t\tA = a;\n\t\tE = e;\n\t\tR = r;\n\t}\n};\n\nint main()\n{\n\tint d,n;\n\twhile(cin >> d >> n)\n\t{\n\t\tif(d == 0 && n == 0) break;\n\n\n\t\tvector<Data> v;\n\t\trep(i,n)\n\t\t{\n\t\t\tint a,e,r;\n\t\t\tcin >> a >> e >> r;\n\n\t\t\tv.push_back(Data(a,e,r));\n\t\t}\n\t\t\n\t\tqueue<pair<pair<int,int>,int> > que;\n\t\tque.push(make_pair(make_pair(0,d),0));\n\t\tbool flag = true;\n\n\t\twhile(que.size())\n\t\t{\n\t\t\tpair<int,int> p = que.front().first;\n\t\t\tint exp = que.front().second;\n\t\t\tque.pop();\n\n\t\t\tif(p.second <= 0)\n\t\t\t{\n\t\t\t\tcout << p.first << endl;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i,n)\n\t\t\t{\n\t\t\t\tif(v[i].R <= exp)\n\t\t\t\t{\n\t\t\t\t\tque.push(make_pair(make_pair(p.first+1,p.second-v[i].A),exp+v[i].E));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(flag) cout << \"NA\" << endl;\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<list>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\nstruct c {\n\tint d, e, f;\n};\nc k[100];\nint a, b;\nint memo[101][101];\nint saiki(int n, int m) {//????????????n??§????¨???????m\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (k[i].f <= m) {\n\t\t\tif (k[i].d >= n)return memo[n][m]=1;\n\t\t\tint O = 0;\n\t\t\tif (memo[n - k[i].d][min(100, k[i].e + m)] != -1) {\n\t\t\t\tO = 1+memo[n - k[i].d][min(100, k[i].e + m)];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tO = 1 + saiki(n - k[i].d, min(100, k[i].e + m));\n\t\t\t}\n\t\t\tMIN = min(MIN,O);\n\t\t}\n\t}\n\treturn memo[n][m]=MIN;\n}\nint main() {\n\twhile (cin >> a >> b, a | b) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tint h, i, j; scanf(\"%d%d%d\", &h, &i, &j);\n\t\t\tk[g] = { h,i,j };\n\t\t}\n\t\tint S = saiki(a, 0);\n\t\tif (S >= 1 << 29) { puts(\"NA\"); }\n\t\telse cout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,s;\nvector<pair<pair<int,int>,int> >v;\nvoid dfs(int p,int x,int t){\n  if(t>=s)return;\n  if(p<0){s=t;return;}\n  if(x>10000)return;\n  for(int i=v.size()-1;i>=0;i--)\n    if(v[i].s<=x)dfs(p-v[i].f.f,x+v[i].f.s,t+1);\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();s=1000000;\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end());\n    dfs(d,0,0);\n    if(s!=10000000)cout<<\"NA\"<<endl;\n    else cout<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d == D) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        int dd = min(D,d+a[i]), ee = min(100,exp+e[i]);\n        if((dd==d && ee==100) || r[i] > exp) continue;\n        res = min(res, 1+solve(dd,ee));\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N){\n            cin >> a[i] >> e[i] >> r[i];\n            if(a[i]==0 && e[i]==0) r[i] = INF;\n        }\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n    int maxr,maxe,maxa,flg;\n    maxr=maxe=maxa=flg=0;\n    maxr = -1;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n    }\n\n    int N = 20000;\n    int ans = INF;\n    \n    for(int i=0;i<=d;i++) for(int j=0;j<=N;j++)dp[i][j] = INF;\n    dp[d][0] = 0;\n\n    int cnt = 0;\n      for(int j=0;j<=N;j++) { //?????¨???????¨????\n\tcnt++;\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\t  for(int k=0;k<n;k++) {\n\t    int na = i - a[k];\n\t    int ne = j + e[k];\n\t    if(na < 0) na = 0;\n\t    if(j < r[k]) continue;\n\t    dp[na][ne] = min(dp[i][j]+1,dp[na][ne]);\n\t  }\n\t  \n\t}\n\tif(ans < dp[0][j]) break;\n\tans = min(ans,dp[0][j]);\n      }\n\n\n      /*\n    for(int j=0;j<=cnt;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n    }\n      */\n    \n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n   \n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//道具を使う順番もあまり関係なかったりする。でも素直に耐久力と経験値に注目しちゃえば良い。\n#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef pair<int,PII> PIII;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint main() {\n\twhile( cin >> d >> n ) {\n\t\tif(!d) break;\n\t\tint i, j;\n\t\tfor( i = 0; i < n; i++ )\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t\n\t\tint dp[101][101];\t\t//dp[残り耐久力][min(EXP,100)]\n\t\tfor( i = 0; i < 101; i++ ) {\n\t\t\tfor( j = 0; j < 101; j++ ) {\n\t\t\t\tdp[i][j] = 1000000;\n\t\t\t}\n\t\t}\n\t\tstack<PIII> data;\n\t\tdata.push(PIII(0, PII(d, 0)) );\n\t\twhile( !data.empty() ) {\n\t\t\tint Cost = data.top().first;\n\t\t\tint Dif = data.top().second.first;\n\t\t\tint Exp = data.top().second.second;\n\t\t\tdata.pop();\n\t\t\tdp[Dif][Exp] = Cost;\n\t\t\t\n\t\t\tfor( i = 0; i < n; i++ ) {\n\t\t\t\tif( Exp >= r[i] ) {\n\t\t\t\t\t//殴る\n\t\t\t\t\tint nCost = Cost+1;\n\t\t\t\t\tint nDif = max(0, Dif - a[i]);\n\t\t\t\t\tint nExp = min(100, Exp + e[i]);\n\t\t\t\t\t//枝刈り\n\t\t\t\t\tif( dp[nDif][nExp] <= nCost )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//遷移する\n\t\t\t\t\tdata.push( PIII( nCost, PII(nDif, nExp)) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 100000;\n\t\tfor( i = 0; i < 101; i++ ) {\n\t\t\tif( dp[0][i] < 10000 ) {\n\t\t\t\tans = min(dp[0][i], ans);\n\t\t\t}\n\t\t}\n\t\tif( ans < 10000 )\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\twhile (true){\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (R[i]>R[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t\telse if (R[i] == R[j] && A[i] < A[j] && E[i] < E[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][0] = 0;\n\t\twhile(clock()<=980){\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\tfor (int j = R[i]; j <= 109; j++){\n\t\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\t\tif (j + E[i] <= 109)DP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t\telse DP[109][k + 1] = max(DP[109][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 100*100+50\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1+N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1+N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(dp[i][j]!=INF){\n\t      if(dp[i+a[k]][j+e[k]]>dp[i][j]+1) dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1+N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][10001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n      maxe = max(maxe,e[i]);\n    }\n\n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=maxr+maxe;j++){\n\tdp[i][j] = INF;\n      }\n    dp[d][0] = 0;\n   \n    \n      for(int j=0;j<=maxr+maxe;j++) { //?????¨???????¨????\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\tfor(int k=0;k<n;k++) {\n\t  int na = i+a[k];\n\t  int ne = j-e[k];\n\t  if(na > d) na = d;\n\t  if(j-e[k] < 0) ne = 0;\n\t  if(ne < r[k]) continue;\n\t  dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t\n\t}\n      }\n    }\n      \n      \n    for(int j=0;j<=maxr+maxe;j++) { //?????¨???????¨????\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n      }\n\n\n    int ans = INF;\n    for(int i=0;i<=maxr+maxe;i++)  ans = min(ans,dp[0][i]);\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Tool {int a, e, r;};\n\nint solve(int D, const vector<Tool>& tool) {\n    vector<vector<vector<int>>> dp(201, vector<vector<int>>(D + 1, vector<int>(201, INF)));\n    dp[0][D][0] = 0;\n    for(int step = 0; step < 200; ++step) {\n//       for(int hp = D; 0 <= hp; --hp) {\n//         for(int exp = 200; 0 <= exp; --exp) {\n      for(int hp = 0; hp <= D; ++hp) {\n        for(int exp = 0; exp <= 200; ++exp) {\n          for(const auto& t: tool) {\n            if(exp < t.r) continue;\n            int nhp = max(hp - t.a, 0);\n            int nexp = exp + t.e;\n            if(200 < nexp) continue;\n            dp[step + 1][nhp][nexp] = min(dp[step + 1][nhp][nexp], dp[step][hp][exp] + 1);\n          }\n        }\n      }\n      for(int exp = 0; exp <= 200; ++exp) if(dp[step + 1][0][exp] != INF) return dp[step + 1][0][exp];\n    }\n  return INF;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    int answer = solve(D, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint d, n;\nint a[100], e[100], r[100];\n\nint ans;\nint dp[101][101];\n\nint solve(int hp, int exp) {\n\n    if(hp <= 0) {\n        return 0;\n    }\n\n    if(dp[hp][exp] != -1) {\n        return dp[hp][exp];\n    }\n\n    int ret = INF;\n    for(int i = 0; i < n; ++i) {\n        if(exp >= r[i]) {\n            ret = min(ret, solve(max(0, hp - a[i]), min(100, exp + e[i])) + 1);\n        }\n    }\n\n    return dp[hp][exp] = ret;\n}\n\nint main() {\n\n    while(cin >> d >> n, d || n) {\n\n        int cnt = 0;\n\n        for(int i = 0; i < n; ++i) {\n            int ai, ei, ri;\n            cin >> ai >> ei >> ri;\n            if(ai || ei) {\n                a[cnt] = ai;\n                e[cnt] = ei;\n                r[cnt] = ri;\n                ++cnt;\n            }\n        }\n\n        n = cnt;\n\n        memset(dp, -1, sizeof(dp));\n\n        ans = solve(d, 0);\n\n        if(ans == INF) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << ans << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nint main() {\n    int d, n;\n    while(cin >> d >> n, d){\n        [&](){\n            vector<int> as(n), es(n), rs(n);\n            for (int i = 0; i < n; ++i) {\n                cin >> as[i] >> es[i] >> rs[i];\n            }\n            auto dp = make_v(d+1, 101, -1);\n            dp[d][0] = 0;\n            queue<pair<int, int>> Q;\n            Q.emplace(d, 0);\n            while(!Q.empty()){\n                int i, j; tie(i, j) = Q.front(); Q.pop();\n                if(i == 0) {\n                    cout << dp[i][j] << \"\\n\";\n                    return;\n                }\n                for (int k = 0; k < n; ++k) {\n                    if(rs[k] <= j){\n                        int ii = max(0, i-as[k]), jj = min(100, j+es[k]);\n                        if(!~dp[ii][jj]){\n                            dp[ii][jj] = dp[i][j]+1;\n                            Q.emplace(ii, jj);\n                        }\n                    }\n                }\n            }\n            puts(\"NA\");\n        }();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n      maxe = max(maxe,e[i]);\n    }\n\n    int N = 10000;\n   \n    int ans = INF;\n    for(int j=0;j<=N;j++) { //?????¨???????¨????\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tdp[i][j] = INF;\n\tif(j == 0 && i == d) dp[i][j] = 0;\n\tfor(int k=0;k<n;k++) {\n\t  int na = i+a[k];\n\t  int ne = j-e[k];\n\t  if(na > d) na = d;\n\t  if(ne < 0) ne = 0;\n\t  if(ne < r[k]) continue;\n\t  dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t}\n      }\n      ans = min(ans,dp[0][j]);\n    }\n  \n\n\n    \n    for(int j=0;j<=N;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n    }\n    \n    \n\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint d, n, memo[110][110];\nvector <int> a, e, r;\nconst int INF = 1000000000;\n\nint rec(int c = 0, int dur = d, int exp = 0) {\n\tif (c > 110) {\n\t\treturn INF;\n\t}\n\tif (dur <= 0) {\n\t\treturn 0;\n\t}\n\tif (memo[dur][exp] != -1) {\n\t\treturn memo[dur][exp];\n\t}\n\tint res = INF;\n\trep (i, n) {\n\t\tif (exp < r[i]) continue;\n\t\tif (a[i] == 0 && e[i] == 0) continue;\n\t\tres = min(res, rec(c + 1, dur - a[i], min(exp + e[i], 101)) + 1);\n\t}\n\treturn memo[dur][exp] = res;\n}\n\nint main() {\n\tint cnt = 0;\n\twhile(cin >> d >> n, n) {\n\t\ta = e = r = vector <int> (n);\n\t\trep (i, n) cin >> a[i] >> e[i] >> r[i];\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tint ans = rec();\n\t\tcout << (ans == INF ? \"NA\" : to_string(ans)) << endl;\n\t\tcnt++;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\nimport java.util.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    int INF = 1 << 28;\n    int d, n;\n    int[] a, e, r;\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        for (;;) {\n            d = sc.nextInt(); n = sc.nextInt();\n            if ((d|n) == 0) break;\n            \n            a = new int[n]; e = new int[n]; r = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt(); e[i] = sc.nextInt(); r[i] = sc.nextInt();\n            }\n            \n            mem = new int[300][300];\n            for (int[] a : mem) fill(a, -1);\n            \n            int ret = solve(0, d);\n            if (ret == INF) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(ret);\n            }\n        }\n    }\n    \n    int[][] mem;\n    int solve(int exp, int hp) {\n        if (hp < 0) return 0; \n        if (mem[exp][hp] > 0) return mem[exp][hp];\n        \n        int min = INF;\n        for (int i = 0; i < n; i++) if (r[i] <= exp){\n            min = min(min, solve(exp + e[i], hp - a[i]) + 1);\n        }\n        \n        return mem[exp][hp] = min;\n    }\n    \n    void debug(Object...os) {\n        System.out.println(deepToString(os));\n    }\n    \n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][10001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      maxr = max(maxr,r[i]);\n      maxe = max(maxe,e[i]);\n    }\n\n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=maxr+maxe;j++){\n\tdp[i][j] = INF;\n      }\n    dp[d][0] = 0;\n   \n    \n      for(int j=0;j<=maxr+maxe;j++) { //?????¨???????¨????\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\tfor(int k=0;k<n;k++) {\n\t  int na = i+a[k];\n\t  int ne = j-e[k];\n\t  if(na > d) na = d;\n\t  if(j-e[k] < 0) ne = 0;\n\t  if(ne < r[k]) continue;\n\t  dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t\n\t}\n      }\n    }\n      \n      /*\n    for(int j=0;j<=maxr+maxe;j++) { //?????¨???????¨????\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n      }\n      */\n\n\n    int ans = INF;\n    for(int i=0;i<=maxr+maxe;i++)  ans = min(ans,dp[0][i]);\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint D, N, a[111], e[111], r[111], dp[111][111][999];\nint rec(int f1, int f2, int d) {\n\tif (f1 >= D) return d;\n\tif (dp[f1][f2][d]) return dp[f1][f2][d] - 1;\n\tint ret = 999999999;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!a[i] && (!e[i] || f2 == 100)) continue;\n\t\tif (f2 >= r[i]) ret = min(ret, rec(f1 + a[i], min(f2 + e[i], 100), d + 1));\n\t}\n\tdp[f1][f2][d] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> D >> N, D | N) {\n\t\tfor (int i = 0; i < N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tfor (int k = 0; k < N * 2; k++) {\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = rec(0, 0, 0);\n\t\tif (ret == 999999999) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N1 101\n#define N2 101\n#define INF 2000000000\nusing namespace std;\nvoid DP();\nint D,N,a[N1],e[N1],r[N1];\nint dp[N1+N1+N1+N1][N2],minv;\nint main(){\n  while(1){\n    cin >> D >> N;\n    if(D==0&&N==0) break;\n    for(int i=0;i<N;i++) cin >> a[i] >> e[i] >> r[i];\n    DP();\n  }\n  return 0;\n}\nvoid DP(){\n  for(int i=0;i<N1+N1;i++){\n    for(int j=0;j<N2;j++){\n      dp[i][j]=INF;\n    }\n  }\n  for(int i=1;i<N1+N1;i++) dp[0][i]=i-1;\n  for(int i=D,k=1;i>=0;i--,k++) dp[k][0]=i;\n  dp[1][1]=0;\n  for(int i=1;i<=D+1;i++){\n    for(int j=1;j<N2;j++){\n      if(dp[i][j]!=INF){\n\tfor(int k=0;k<N;k++){\n\t  if(dp[0][j]>=r[k]){\n\t    if(j+e[k]>=N2){\n\t      if(dp[i+a[k]][N2-1]>dp[i][j]+1) dp[i+a[k]][N2-1]=dp[i][j]+1;\n\t    }\n\t    else if(dp[i+a[k]][j+e[k]]>dp[i][j]+1)dp[i+a[k]][j+e[k]]=dp[i][j]+1;\n\t  }\n\t}\n      }\n    }\n  }\n  minv=INF;\n  for(int i=D+1;i<N1+N1;i++){\n    for(int j=1;j<N2;j++){\n      minv=min(minv,dp[i][j]);\n    }\n  }\n  if(minv!=INF) cout << minv << endl;\n  else cout << \"NA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[1111], e[1111], r[1111];\nint INF = INT_MAX/4;\nint dp[1111][1111];\nint solve(int d, int exp){\n    if(d >= D) return 0;\n    if(exp >= 1111) return INF;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            if(a[i]==0 && e[i]==0) continue;\n            res = min(res, 1+solve(d+a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nint d,n;\nint a[110],e[110],r[110];\nint memo[110][110];\n\ninline int rec(int hp, int exp){\n  if(hp==0)return 0;\n  if(memo[hp][exp]>=0)return memo[hp][exp];\n\n  int res = INF;\n  for(int i=0;i<n;i++){\n    if(exp>=r[i]){\n      int nhp = max(0,hp-a[i]), nexp = min(100,exp+e[i]);\n      if(hp == nhp && exp == nexp)continue;\n      res = min(res, rec(nhp, nexp) + 1 );\n    }\n  }\n  return memo[hp][exp] = res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&d,&n), d){\n    for(int i=0;i<n;i++)scanf(\"%d%d%d\",a+i,e+i,r+i);\n\n    memset(memo,-1,sizeof(memo));\n    int ans = rec(d,0);\n    if(ans==INF)puts(\"NA\");\n    else printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nvector<int> a;\nvector<int> e;\nvector<int> r;\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != INT_MAX/2) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      res = min(res, func(ex+e[i], HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = INT_MAX/2;\n      }\n    }\n    a = vector<int>(N);\n    e = vector<int>(N);\n    r = vector<int>(N);\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << func(0, D) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct a\n{\n\tint b, c, d;\n};\na e[500];\nint dp[501][501];//????????????n????¨???????m\nint main() {\n\tint f, g;\n\twhile (cin >> f >> g, f | g) {\n\t\tint MAX = 0;\n\t\tfor (int h = 0; h < g; h++) {\n\t\t\tint i, j, k;\n\t\t\tscanf(\"%d%d%d\", &i, &j, &k);\n\t\t\te[h] = { i,j,k };\n\t\t\tMAX = max(MAX, k);\n\t\t}\n\t\tfor (int h = 0; h <= f; h++) {\n\t\t\tfor (int i = 0; i <= MAX;i++) {\n\t\t\t\tdp[h][i] = 1 << 29;\n\t\t\t\tif (h == 0)dp[h][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 1; h <= f; h++) {\n\t\t\tfor (int i = 0; i <= MAX;i++) {\n\t\t\t\tfor (int j = 0; j < g; j++) {\n\t\t\t\t\tif (i >= e[j].d) {\n\t\t\t\t\t\tdp[h][i] = min(dp[h][i], 1 + dp[max(0,h - e[j].b)][min(MAX, i + e[j].c)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[f][0] == 1 << 29)puts(\"NA\");\n\t\telse cout << dp[f][0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint d, n, memo[110][110];\nvector <int> a, e, r;\nconst int INF = 100000000;\n\nint rec(int c = 0, int exp = 0, int end = d) {\n\tif (end <= 0) {\n\t\treturn 0;\n\t}\n\tif (memo[exp][end] != -1) {\n\t\treturn memo[exp][end];\n\t}\n\tif (c >= 300) {\n\t\treturn INF;\n\t}\n\n\tint res = INF;\n\trep (i, n) {\n\t\tif (exp < r[i]) continue;\n\t\tif (a[i] == 0 && e[i] == 0) continue;\n\t\tres = min(res, rec(c + 1, min(exp + e[i], 105), end - a[i]) + 1);\n\t}\n\treturn memo[exp][end] = res;\n}\n\nint main() {\n\twhile (cin >> d >> n, d) {\n\t\ta = e = r = vector <int> (n);\n\t\trep (i, n) cin >> a[i] >> e[i] >> r[i];\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tint ans = rec();\n\t\tcout << (ans == INF ? \"NA\" : to_string(ans)) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d == D) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        int dd = min(D,d+a[i]), ee = min(100,exp+e[i]);\n        if((dd==d && ee==exp) || r[i] > exp) continue;\n        res = min(res, 1+solve(dd,ee));\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N){\n            cin >> a[i] >> e[i] >> r[i];\n            if(a[i]==0 && e[i]==0) r[i] = INF;\n        }\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans >= INF/10) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][20001];\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n    int maxr = 0;\n    int maxe = 0;\n    int sum  = 0;\n    int flg = 0;\n    for(int i=0;i<n;i++) {\n      cin >> a[i] >> e[i] >> r[i];\n      if(r[i] == 0 && a[i] != 0) flg = 1;\n      maxr = max(maxr,r[i]);\n      maxe = max(maxe,e[i]);\n      sum += e[i] + r[i];\n    }\n    int N = sum;\n\n    for(int i=0;i<n;i++) \n      for(int j=n-1;j>i;j--)\n\tif(r[j] < r[j-1]) swap(r[j],r[j-1]);   \n    \n    int ans = INF;\n    int cnt =0;\n    if(flg == 1) {\n      for(int j=0;j<=N;j++) { //?????¨???????¨????\n\tfor(int i=d;i>=0;i--) {//?????????????????????\n\t  dp[i][j] = INF;\n\t  if(j == 0 && i == d) dp[i][j] = 0;\n\t  for(int k=0;k<n;k++) {\n\t    cnt++;\n\t    int na = i+a[k];\n\t    int ne = j-e[k];\n\t    if(na > d) na = d;\n\t    if(ne < 0) ne = 0;\n\t    if(ne < r[k]) break;\n\t\n\t    dp[i][j] = min(dp[i][j],dp[na][ne]+1);\n\t  }\n\t\n\t}\n\tans = min(ans,dp[0][j]);\n      }\n    }\n  \n\n\n    /*\n    for(int j=0;j<=N;j++) { //?????¨???????¨????\n      cout << j <<\"|\";\n      for(int i=d;i>=0;i--) {//?????????????????????\n\tif(dp[i][j] == INF) cout <<\"#\"<<\" \";\n\telse  cout << dp[i][j]<<\" \";\n      }\n      cout << endl;\n    }\n    */\n    \n    \n\n\n    if(ans == INF) cout << \"NA\" <<endl;\n    else cout << ans <<endl;\n    // cout << cnt <<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d >= D) return 0;\n    if(exp > 100) return INF;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        int dd = min(D,d+a[i]), ee = min(100,exp+e[i]);\n        if(dd==d && ee==100) continue;\n        if(r[i] <= exp) res = min(res, 1+solve(d+a[i], exp+e[i]));\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N){\n            cin >> a[i] >> e[i] >> r[i];\n            if(a[i]==0 && e[i]==0) r[i] = INF;\n        }\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\n\nint n;\nint a[101],e[101],r[101];\nint dp[101][10001];\nint ans,cnt ;\n\nvoid saiki(int d,int ex,int kai) {\n  cnt++;\n  if(d <= 0 ) dp[0][ex] = 0;\n  if(d > 0) {\n    for(int i=0;i<n;i++) {\n      if(r[i] <= ex) {\n\tint da  =  d-a[i];\n\tif(da < 0) da = 0;\n\tif(dp[da][ex+e[i]] < INF) {\n\t  //cout <<\"ok\"<<endl;\n\t  dp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n\t  continue;\n\t}\n        saiki(d-a[i],ex+e[i],kai+1);\n\tdp[d][ex] =min(dp[d][ex],dp[da][ex+e[i]]+1);\n      }\n    }\n  }\n}\n\nint main() {\n\n  while(1) {\n    int d;\n    cin >> d >> n;\n    if(d==0 && n ==0) break;\n\n\n    for(int i=0;i<n;i++) cin >> a[i] >> e[i] >> r[i];\n    \n    for(int i=0;i<=d;i++) \n      for(int j=0;j<=10000;j++)\n\tdp[i][j] = INF;\n\n    saiki(d,0,0);\n\n    if(dp[d][0] == INF) cout << \"NA\" <<endl;\n    else cout << dp[d][0] <<endl;\n    // cout << cnt <<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAX = 101;\n\nint d, n;\nint a[MAX], e[MAX], r[MAX];\n\n\nint bfs(){\n\tint dis[MAX][MAX];\n\tfor (int i = 0; i < MAX; i++) {\n\t\tfill(dis[i], dis[i] + MAX, INF);\n\t}\n\tdis[d][0] = 0;\n\n\tqueue<pair<int, int>> q;\n\tq.emplace(d,0);\n\twhile(not q.empty()){\n\t\tint hp, exp;\n\t\ttie(hp, exp) = q.front(); q.pop();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif(r[i] > exp) continue;\n\t\t\t\n\t\t\tint nhp = max(0, hp - a[i]);\n\t\t\tint nexp = min(100, exp + e[i]);\n\t\t\tif(dis[nhp][nexp] > dis[hp][exp] + 1){\n\t\t\t\tdis[nhp][nexp] = dis[hp][exp] + 1;\n\t\t\t\tq.emplace(nhp, nexp);\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = INF;\n\tfor (int i = 0; i <= 100; i++) {\n\t\tres = min(res, dis[0][i]);\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> d >> n, d||n){\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tint ans = bfs();\n\t\tif(ans == INF) cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint D,N;\nint memo[101][101];\nint a[100],e[100],r[100];\nint f(int d,int E)\n{\n\tif(memo[d][E]>=0)return memo[d][E];\n\tif(E==100)\n\t{\n\t\tint ans=1e9;\n\t\tfor(int i=0;i<N;i++)if(a[i])ans=min(ans,(d-1)/a[i]+1);\n\t\treturn memo[d][E]=ans;\n\t}\n\tint ans=1e9;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(E<r[i])continue;\n\t\tif(d<=a[i])\n\t\t{\n\t\t\tans=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(a[i]||e[i])ans=min(ans,1+f(d-a[i],min(100,E+e[i])));\n\t}\n\treturn memo[d][E]=ans;\n}\nmain()\n{\n\twhile(cin>>D>>N,D)\n\t{\n\t\tfor(int i=0;i<N;i++)cin>>a[i]>>e[i]>>r[i];\n\t\tfor(int i=0;i<=D;i++)for(int j=0;j<=100;j++)memo[i][j]=-1;\n\t\tint ans=f(D,0);\n\t\tif(ans==1e9)cout<<\"NA\"<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 1 << 29;\nint a[110], e[110], r[110];\nint d, n;\n\n// ?¨??????????,??????????????°???????¨????\nint func(int hp, int m, int k){\n\tif(hp <= 0) return m;\n\tint res = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(k >= r[i]){\n\t\t\tres = min(res, func(hp - a[i], m + 1, k + e[i]));\n\t\t}\n\t}\n\tif(res == INF){\n\t\tcout << \"NA\" << endl;\n\t\treturn INF; \n\t}\n\tif(m == 0){\n\t\tcout << res << endl;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> d >> n && (d || n)){\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tfunc(d, 0, 0);\n\t}\n\n\treturn 0;\n}\n\n/*\na ??????????????????\ne ??????????¨????\nr ??????????¨????\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nint D,N;\n\nstruct Info{\n\tInfo(){\n\t\tattack = exp = r_exp = -1;\n\t\tunuse = false;\n\t}\n\tInfo(int arg_attack,int arg_exp,int arg_r_exp){\n\t\tattack = arg_attack;\n\t\texp = arg_exp;\n\t\tr_exp = arg_r_exp;\n\t\tunuse = false;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn r_exp > arg.r_exp;\n\t};\n\n\tint attack,exp,r_exp;\n\tbool unuse;\n};\n\nstruct Data{\n\tint current_exp,rest_D,count;\n};\n\n\nvoid func(){\n\n\tint a,e,r;\n\tpriority_queue<Info> S;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&a,&e,&r);\n\t\tS.push(Info(a,e,r));\n\t}\n\n\tInfo info[N];\n\n\tint index = 0;\n\n\twhile(!S.empty()){\n\t\tinfo[index].attack = S.top().attack;\n\t\tinfo[index].exp = S.top().exp;\n\t\tinfo[index].r_exp = S.top().r_exp;\n\t\tindex++;\n\t\tS.pop();\n\t}\n\n\tint ans = -1;\n\n\tqueue<Data> Q;\n\n\tData first;\n\tfirst.current_exp = 0;\n\tfirst.rest_D = D;\n\tfirst.count = 0;\n\n\tQ.push(first);\n\n\tbool FLG;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().rest_D <= 0){\n\t\t\tans = Q.front().count;\n\t\t\tbreak;\n\t\t}\n\n\t\t//??????????????????????¨?????????????????????????????????????????????¨???????????°???????????¨????????¨????????????\n\t\t//????????????????????????0????????°?????¨?????????\n\t\tfor(int i = 0; info[i].r_exp <= Q.front().current_exp;i++){\n\t\t\tif(info[i].unuse == true || info[i].attack <= 0)continue;\n\t\t\tFLG = true;\n\t\t\tfor(int k = 0; k < i;k++){\n\t\t\t\tif(info[i].exp <= info[k].exp && info[i].attack <= info[k].attack){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tinfo[i].unuse = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG == true){\n\t\t\t\tData new_data;\n\t\t\t\tnew_data.count = Q.front().count+1;\n\t\t\t\tnew_data.current_exp = Q.front().current_exp+info[i].exp;\n\t\t\t\tnew_data.rest_D = Q.front().rest_D - info[i].attack;\n\t\t\t\tQ.push(new_data);\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tif(ans == -1){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&D,&N);\n\t\tif(D == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define INF (2 << 28)\nusing namespace std;\n\nint d, n, dp[111][111];\nint a[111], e[111], r[111];\n\nint rec(int exp, int hp){\n    \n    if(hp <= 0) return 0;\n    \n    int ret = INF;\n    for(int i = 0; i < n; i++){\n        if(r[i] <= exp)\n            ret = min(ret, rec(exp + e[i], hp - a[i]) + 1);\n    }\n    return dp[exp][hp] = ret;\n}\n\nint main(){\n    \n    while(cin >> d >> n, d||n){\n        for(int i = 0; i < n; i++) cin >> a[i] >> e[i] >> r[i];\n    \n        memset(dp, -1, sizeof(dp));\n        int dd = rec(0, d);\n        if(dd == INF) cout << \"NA\" << endl;\n        else cout << dd << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Tool {int a, e, r;};\nbool operator<(const Tool& lhs, const Tool& rhs) {return lhs.r < rhs.r;}\n\nint solve(int D, vector<Tool> tool) {\n  sort(begin(tool), end(tool));\n  vector<vector<int>> dp(D + 1, vector<int>(101, INF));\n  dp[D][0] = 0;\n  for(const auto& t: tool) {\n    for(int hp = D; 0 <= hp; --hp) {\n      for(int exp = 0; exp <= 100; ++exp) {\n        if(exp < t.r) continue;\n        int next_hp = max(0, hp - t.a);\n        int next_exp = min(100, exp + t.e);\n        dp[next_hp][next_exp] = min(dp[next_hp][next_exp], dp[hp][exp] + 1);\n      }\n    }\n  }\n\n  int result = INF;\n  for(const auto& i: dp[0]) result = min(result, i);\n  return result;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    int answer = solve(D, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][1000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(x>=1000)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct c {\n\tint d, e, f;\n};\nc k[100];\nint a, b;\nint memo[101][101];\nint saiki(int n, int m) {//????????????n??§????¨???????m\n\tint MIN = 1 << 29;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (k[i].f <= m) {\n\t\t\tif (k[i].d >= n)return memo[n][m]=1;\n\t\t\tint O = 0;\n\t\t\tif (memo[n - k[i].d][min(100, k[i].e + m)] != -1) {\n\t\t\t\tO = memo[n - k[i].d][min(100, k[i].e + m)];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tO = 1 + saiki(n - k[i].d, min(100, k[i].e + m));\n\t\t\t}\n\t\t\tMIN = min(MIN,O);\n\t\t}\n\t}\n\treturn memo[n][m]=MIN;\n}\nint main() {\n\twhile (cin >> a >> b, a | b) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tint h, i, j; scanf(\"%d%d%d\", &h, &i, &j);\n\t\t\tk[g] = { h,i,j };\n\t\t}\n\t\tint S = saiki(a, 0);\n\t\tif (S >= 1 << 29) { puts(\"NA\"); }\n\t\telse cout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e+9;\nint DP[128][128];\nint main() {\n\tint D, N;\n\twhile(cin >> D >> N && (D || N)){\n\t\tint a[128], e[128], r[128];\n\t\tfor(int i = 0; i < N; ++i)\n\t\t\tscanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\tfor(int i = 0; i <= D; ++i)\n\t\t\tfor(int j = 0; j <= 100; ++j)\n\t\t\t\tDP[i][j] = INF;\n\t\tDP[D][0] = 0;\n\t\tfor(int i = D; i > 0; --i){\n\t\t\tfor(int j = 0; j <= 100; ++j){\n\t\t\t\tfor(int k = 0; k < N; ++k){\n\t\t\t\t\tif(j >= r[k])\n\t\t\t\t\tDP[max(0, i - a[k])][min(100, j + e[k])] = min(DP[max(0, i - a[k])][min(100, j + e[k])], DP[i][j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i = 0; i <= 100; ++i)\n\t\t\tans = min(ans, DP[0][i]);\n\t\tif(ans == INF){\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][11111];\nint solve(int d, int exp){\n    if(d <= 0) return 0;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(a[i]==0 && e[i]==0) continue;\n        if(r[i] <= exp){\n            res = min(res, 1+solve(d-a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(D,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\n\nint D,N;\nint dp[101][101];\nint a[101],b[101],c[101];\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&D,&N);\n    if(D==0&&N==0)break;\n    for(int i=0;i<N;i++)scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n    fill(dp[0],dp[101],INF);    \n    dp[0][0]=0;    \n    for(int i=0;i<D;i++){\n      for(int j=0;j<=100;j++){\n        if(dp[i][j]==INF)continue;\n        int cost=dp[i][j];\n        for(int k=0;k<N;k++){\n          if(j<c[k])continue;\n          int &to=dp[min(D,i+a[k])][min(100,j+b[k])];\n          to=min(to,cost+1);\n        }\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<=100;i++)\n      ans=min(ans,dp[D][i]);\n    if(ans==INF)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint D, N;\nint dp[101][101];\nint A[100], E[100], R[100];\nusing namespace std;\n\nint main(){\n    while(scanf(\"%d %d\", &D, &N), D || N){\n        for(int i=0;i<N;i++){\n            scanf(\"%d %d %d\", A+i, E+i, R+i);\n        }\n\n        for(int i=0;i<=D;i++){\n            for(int j=0;j<=100;j++){\n                dp[i][j] = 1001001001;\n            }\n        }\n// dp[i][j] :=\n//?¨?????????????????????????i????????????????¨???????j?????¨?????????????????§?¨???????????????????\n        dp[D][0] = 0;\n        for(int i=D;i>=0;i--){\n            for(int j=0;j<=100;j++){\n                for(int k=0;k<N;k++){\n                    if(j >= R[k]){\n                        int ni = max(i-A[k],0),\n                            nj = min(j+E[k],100);\n                        dp[ni][nj] = min(dp[ni][nj], dp[i][j] + 1);\n                    }\n                }\n            }\n        }\n\n        int res = 9999999;\n        for(int i=0;i<=100;i++){\n            res = min(res, dp[0][i]);\n        }\n\n        if(res != 9999999){cout<<res<<endl;}\n        else{cout<<\"NA\"<<endl;}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct Tool {int a, e, r;};\n\nint bfs(int D, const vector<Tool>& tool) {\n  vector<vector<int>> memo(D + 1, vector<int>(201, INF));\n  queue<tuple<int, int, int>> q;\n  q.emplace(0, D, 0);\n  while(!q.empty()) {\n    int depth, hp, exp;\n    tie(depth, hp, exp) = q.front();\n    q.pop();\n    if(100 < depth) return INF;\n    if(hp <= 0) return depth;\n    if(memo[hp][exp] <= depth) continue;\n    memo[hp][exp] = depth;\n    for(const auto& t: tool) {\n      if(exp < t.r) continue;\n      if(hp - t.a >= 0) if(memo[hp - t.a][exp + t.e] <= depth + 1) continue;\n      q.emplace(depth + 1, hp - t.a, exp + t.e);\n    }\n  }\n  return INF;\n}\n\nint main() {\n  int D, N;\n  while(cin >> D >> N, D | N) {\n    vector<Tool> tool(N);\n    for(auto& t: tool) cin >> t.a >> t.e >> t.r;\n\n    int answer = bfs(D, tool);\n    if(answer == INF) cout << \"NA\" << endl;\n    else              cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<list>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\nstruct a\n{\n\tint b, c, d;\n};\na e[500];\nint dp[501][501];//????????????n????¨???????m\nint main() {\n\tint f, g;\n\twhile (cin >> f >> g, f | g) {\n\t\tint MAX = 500;\n\t\tfor (int h = 0; h < g; h++) {\n\t\t\tint i, j, k;\n\t\t\tscanf(\"%d%d%d\", &i, &j, &k);\n\t\t\te[h] = { i,j,k };\n\t\t}\n\t\tfor (int h = 0; h <= f; h++) {\n\t\t\tfor (int i = 0; i <= MAX;i++) {\n\t\t\t\tdp[h][i] = 1 << 29;\n\t\t\t\tif (h == 0)dp[h][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 1; h <= f; h++) {\n\t\t\tfor (int i = MAX; i >= 0;i--) {\n\t\t\t\tfor (int j = 0; j < g; j++) {\n\t\t\t\t\tif (i >= e[j].d) {\n\t\t\t\t\t\tdp[h][i] = min(dp[h][i], 1 + dp[max(0,h - e[j].b)][min(MAX, i + e[j].c)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[f][0] >= 100000)puts(\"NA\");\n\t\telse cout << dp[f][0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[10010][110];\nint main()\n{\n\twhile (true){\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (R[i]>R[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = R[i]; j <= 10009 - E[i]; j++){\n\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\tDP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvector<pair<int,pii> >in(m);\n\t\trep(i,m){\n\t\t\tcin>>in[i].second.first>>in[i].second.second>>in[i].first;\n\t\t}\n\t\tvvi dp(n+1,vi(101,inf));//sum kei=cost\n\t\tdp[0][0]=0;\n\t\trep(i,n)rep(j,101)rep(k,m){\n\t\t\tif(j<in[k].first)continue;\n\t\t\tint a=min(n,i+in[k].second.first);\n\t\t\tint b=min(100,j+in[k].second.second);\n\t\t\tdp[a][b]=min(dp[a][b],dp[i][j]+1);\n\t\t}\n\t\tint mi=inf;\n\t\trep(i,101)mi=min(dp[n][i],mi);\n\t\tif(mi!=inf)cout<<mi<<endl;\n\t\telse cout<<\"NA\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\n\nint dp[111][111];\nint solve(int d, int exp){\n    if(d <= 0) return 0;\n    int & res = dp[d][exp];\n    res = INT_MAX;\n    rep(i,N){\n        if(r[i] > exp) continue;\n        res = min(res, 1+solve(d-a[i], exp+e[i]));\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(D,0);\n        if(ans == INT_MAX) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 1 << 29;\nint a[110], e[110], r[110];\nint d, n;\nint dp[110][110][110];\n\n// ?¨??????????,??????????????°???????¨????\nint func(int hp, int m, int k){\n\tif(hp <= 0) return m;\n\tif(dp[hp][m][k]) return dp[hp][m][k];\n\tint res = INF;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(k >= r[i]){\n\t\t\tres = min(res, func(hp - a[i], m + 1, k + e[i]));\n\t\t}\n\t}\n\tif(res == INF){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0; \n\t}\n\tif(m == 0){\n\t\tcout << res << endl;\n\t}\n\treturn dp[hp][m][k] = res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> d >> n && (d || n)){\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> a[i] >> e[i] >> r[i];\n\t\t}\n\n\t\tfor(int i = 0; i < 110; ++i){\n\t\t\tfor(int j = 0; j < 110; ++j){\n\t\t\t\tfor(int k = 0; k < 110; ++k){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunc(d, 0, 0);\n\t}\n\n\treturn 0;\n}\n\n/*\na ??????????????????\ne ??????????¨????\nr ??????????¨????\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nint D, N;\nint A[100], E[100], R[100];\nint DP[110][110];\nint main()\n{\n\twhile (true){\n\t\tint O = 0;\n\t\tint ans = 10000;\n\t\tscanf(\"%d%d\", &D, &N);\n\t\tif (D == 0 && N == 0)return 0;\n\t\tfor (int i = 0; i < N; i++)scanf(\"%d%d%d\", &A[i], &E[i], &R[i]);\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] =-100000;\n\t\tDP[0][0] = 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tfor (int j = i + 1; j < N; j++){\n\t\t\t\tif (R[i]>R[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t\telse if (R[i] == R[j] && A[i] < A[j] && E[i] < E[j]){\n\t\t\t\t\tswap(A[i], A[j]);\n\t\t\t\t\tswap(E[i], E[j]);\n\t\t\t\t\tswap(R[i], R[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(O<=10000000){\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\tfor (int j = R[i]; j <= 109; j++){\n\t\t\t\t\tfor (int k = 0; k <= 108; k++){\n\t\t\t\t\t\tO++;\n\t\t\t\t\t\tif (j + E[i] <= 109)DP[j + E[i]][k + 1] = max(DP[j + E[i]][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t\telse DP[109][k + 1] = max(DP[109][k + 1], DP[j][k] + A[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint D, N;\nint memo[256][256];\nint a[256], e[256], r[256];\nint func(int ex, int HP){\n  if(HP <= 0){\n    return 0;\n  }\n  if(memo[ex][HP] != -1) return memo[ex][HP];\n  int res = INT_MAX/2;\n  for(int i=0; i < N; i++){\n    if(ex >= r[i]){\n      if(a[i] == 0 && e[i] == 0) continue;\n      if(a[i] == 0 && *max_element(r, r+N) < ex) break;\n      res = min(res, func(min(100,ex+e[i]), HP-a[i])+1);\n    }\n  }\n  memo[ex][HP] = res;\n  return res;\n}\n \nint main(void){\n  while(cin >> D >> N, D | N){\n    for(int i=0; i < 256; i++){\n      for(int j=0; j < 256; j++){\n        memo[i][j] = -1;\n      }\n    }\n    for(int i=0; i < N; i++){\n      cin >> a[i] >> e[i] >> r[i];\n    }\n    int ans = func(0, D);\n    if(ans == INT_MAX/2){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint d, n;\n\twhile(cin >> d >> n, d+n){\n\t\tvector<pair<int, pair<int, int> > > tool(n);\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ttool[i] = make_pair(c, make_pair(a, b));\n\t\t}\n\t\tsort(tool.begin(), tool.end());\n\t\tint dp[d+1][11000]; //耐久力 i の時に 道具 j の時の回数\n\t\tfor(int i=0; i < d+1; i++)for(int j=0; j< 11000; j++) dp[i][j] = 10e7;\n\t\tdp[d][0] = 0;\n\t\tfor(int i = d; 0 <= i; i--){\n\t\t\tfor(int j = 0; j <= 10000; j++){\n\t\t\t\tif(dp[i][j] == 10e7) continue;\n\t\t\t\tfor(int k=0; k < n; k++){\n\t\t\t\t\tint a = tool[k].second.first, e = tool[k].second.second, r = tool[k].first;;\n\t\t\t\t\tif(j < r) break;\n\t\t\t\t\tint p = (i-a<0 ? 0 : i-a);\n\t\t\t\t\tdp[p][j+e] = min(dp[i][j]+1, dp[p][j+e]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 10e7;\n\t\tfor(int i=0; i <= 10000; i++) ret = min(dp[0][i], ret);\n\t\tif(ret == 10e7) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nint D,N;\nint a[111], e[111], r[111];\nint INF = INT_MAX/4;\nint dp[111][111];\nint solve(int d, int exp){\n    if(d >= D) return 0;\n    if(exp >= 100) return INF;\n    int & res = dp[d][exp];\n    if(res != -1) return res;\n    res = INF;\n    rep(i,N){\n        if(r[i] <= exp){\n            if(a[i]==0 && e[i]==0) continue;\n            res = min(res, 1+solve(d+a[i], exp+e[i]));\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while(cin >> D >> N && D){\n        rep(i,N) cin >> a[i] >> e[i] >> r[i];\n        memset(dp,-1,sizeof(dp));\n        int ans = solve(0,0);\n        if(ans == INF) cout << \"NA\";\n        else cout << ans;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nint d, n, memo[110][110];\nvector <int> a, e, r;\nconst int INF = 100000000;\n\nint rec(int exp = 0, int end = d) {\n\tif (end <= 0) {\n\t\treturn 0;\n\t}\n\tif (memo[exp][end] != -1) {\n\t\treturn memo[exp][end];\n\t}\n\n\tint res = INF;\n\trep (i, n) {\n\t\tif (exp < r[i]) continue;\n\t\tif (a[i] == 0 && e[i] == 0) continue;\n\t\tres = min(res, rec(exp + e[i], end - a[i]) + 1);\n\t}\n\treturn memo[exp][end] = res;\n}\n\nint main() {\n\twhile (cin >> d >> n, d) {\n\t\ta = e = r = vector <int> (n);\n\t\trep (i, n) cin >> a[i] >> e[i] >> r[i];\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tint ans = rec();\n\t\tcout << (ans == INF ? \"NA\" : to_string(ans)) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nint D, N;\nint dp[101][101];\nint A[100], E[100], R[100];\n\nint rec(int health, int exp){\n    // printf(\"%d, %d\\n\",health,exp);\n    \n    if(health <= 0){return 0;}\n    if(dp[health][exp] != -1){return dp[health][exp];}\n\n    int res = 1001001001;\n    for(int i=0;i<N;i++){\n        if(exp == 100 && A[i] == 0){continue;}\n        \n        if(exp >= R[i]){\n            res = std::min(res, rec(health-A[i], std::min(exp+E[i], 100)) + 1);\n        }\n    }\n\n    return dp[health][exp] = res;\n}\n\nint main(){\n    while(scanf(\"%d %d\", &D, &N), D || N){\n        memset(dp, -1, sizeof(dp));\n    \n        for(int i=0;i<N;i++){\n            scanf(\"%d %d %d\", A+i, E+i, R+i);\n        }\n\n        bool f = false, g = false;\n        for(int i=0;i<N;i++){\n            if(R[i] == 0){\n                if(A[i] > 0){\n                    f = true; g = true;\n                }else if(E[i] > 0){\n                    f = true;\n                }\n            }\n            if(A[i] > 0){\n                g = true;\n            }\n        }\n\n        if(f && g){\n            printf(\"%d\\n\", rec(D, 0));\n        }else{\n            puts(\"NA\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nstruct Data {\n\tint a, e, r;\n\tData() {}\n\tData(int a, int e, int r) : a(a), e(e), r(r) {}\n};\n\nint dp[101][101];\nData data[100];\n\nint main() {\n\tint d, n;\n\twhile (scanf(\"%d %d\", &d, &n), d || n) {\n\t\tREP(i, n) {\n\t\t\tint a, e, r;\n\t\t\tscanf(\"%d %d %d\", &a, &e, &r);\n\t\t\tdata[i] = Data(a, e, r);\n\t\t}\n\t\t\n\t\tfill(dp[0], dp[d + 1], INF);\n\t\tdp[0][0] = 0;\n\t\tREP(i, d) REP(j, 101) {\n\t\t\tif (dp[i][j] == INF) continue;\n\t\t\tREP(k, n) {\n\t\t\t\tif (j < data[k].r) continue;\n\t\t\t\tdp[min(d, i + data[k].a)][min(100, j + data[k].e)] = \n\t\t\t\t\tmin(dp[min(d, i + data[k].a)][min(100, j + data[k].e)], dp[i][j] + 1);\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tREP(i, 101) ans = min(ans, dp[d][i]);\n\t\tif (ans == INF) puts(\"NA\");\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x,int t){\n  int res=0;\n  if(t>=100)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p])return dp[p];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s,t+1)+1);\n    }\n  return dp[p]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    sort(v.begin(),v.end(),greater<pair<pair<int,int>,int> >());\n    int p=dfs(d,0,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int n,d;\n  while(1){\n    cin>>d>>n;\n    if(d==0)break;\n    vector<vi> dp(10005,vi(d+1,INF));\n    vi a(n),e(n),r(n);\n    rep(i,n)cin>>a[i]>>e[i]>>r[i];\n    dp[0][0]=0;\n    rep(i,10001)rep(j,d+1)if(dp[i][j]<INF){\n      int k;\n      rep(k,n)if(r[k]<=i){\n\tif(i+e[k]<=100)\n\t  dp[i+e[k]][min(j+a[k],d)]=min(dp[i+e[k]][min(j+a[k],d)],dp[i][j]+1);\n      }\n    }\n    int ans=INF;\n    rep(i,10001)ans=min(ans,dp[i][d]);\n    if(ans==INF)\n      cout<<\"NA\"<<endl;\n    else \n      cout<<ans<<endl;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nint D[50], N[50];\nint A[50][100], E[50][100], R[50][100];\nint DP[110][110];\nint main()\n{\n\tint T = 0;\n\t\n\twhile (true){\n\t\tscanf(\"%d%d\", &D[T], &N[T]);\n\t\tif (D[T] == 0 && N[T] == 0)break;\n\t\tfor (int j = 0; j < N[T]; j++)scanf(\"%d%d%d\", &A[T][j], &E[T][j], &R[T][j]);\n\t\tT++;\n\t}\n\tfor (int k = 0; k < T; k++){\n\t\tfor (int i = 0; i <= 109; i++)for (int j = 0; j <= 109; j++)DP[i][j] = -100000;\n\t\tDP[0][0] = 0;\n\t\tint ans = 10000;\n\t\tfor (int i = 0; i < N[k]; i++){\n\t\t\tfor (int j = i + 1; j < N[k]; j++){\n\t\t\t\tif (R[k][i]>R[k][j]){\n\t\t\t\t\tswap(A[k][i], A[k][j]);\n\t\t\t\t\tswap(E[k][i], E[k][j]);\n\t\t\t\t\tswap(R[k][i], R[k][j]);\n\t\t\t\t}\n\t\t\t\telse if (R[k][i] == R[k][j] && A[k][i] < A[k][j] && E[k][i] < E[k][j]){\n\t\t\t\t\tswap(A[k][i], A[k][j]);\n\t\t\t\t\tswap(E[k][i], E[k][j]);\n\t\t\t\t\tswap(R[k][i], R[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint O = 0;\n\t\twhile (O*T <= 100000000){\n\t\t\tfor (int i = 0; i < N[k]; i++){\n\n\t\t\t\tfor (int j = R[k][i]; j <= 109; j++){\n\t\t\t\t\tfor (int l = 0; l <= 108; l++){\n\t\t\t\t\t\tO++;\n\t\t\t\t\t\tif (j + E[k][i] <= 109)DP[j + E[k][i]][l + 1] = max(DP[j + E[k][i]][l + 1], DP[j][l] + A[k][i]);\n\t\t\t\t\t\telse DP[109][l + 1] = max(DP[109][l + 1], DP[j][l] + A[k][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 110; i++){\n\t\t\tfor (int j = 0; j < 110; j++){\n\t\t\t\tif (DP[i][j] >= D[k]){\n\t\t\t\t\tans = min(ans, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 10000)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint D, N, a[111], e[111], r[111], dp[111][111];\nint rec(int f1, int f2, int d) {\n\tif (f1 >= D) return d;\n\tif (dp[f1][f2]) return dp[f1][f2] - 1;\n\tint ret = 999999999;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!a[i] && (!e[i] || f2 == 100)) continue;\n\t\tif (f2 >= r[i]) ret = min(ret, rec(f1 + a[i], min(f2 + e[i], 100), d + 1));\n\t}\n\tdp[f1][f2] = ret + 1;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> D >> N, D | N) {\n\t\tfor (int i = 0; i < N; i++) cin >> a[i] >> e[i] >> r[i];\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\tfor (int k = 0; k < N * 2; k++) {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = rec(0, 0, 0);\n\t\tif (ret == 999999999) cout << \"NA\" << endl;\n\t\telse cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint d,n,dp[110][2000];\nvector<pair<pair<int,int>,int> >v;\nint dfs(int p,int x){\n  int res=0,k=1;\n  if(x>=1500)return 10000000;\n  if(p<=0)return 0;\n  if(dp[p][x])return dp[p][x];\n  for(int i=0;i<v.size();i++)\n    if(v[i].s<=x){\n      if(k)k--,res=dfs(p-v[i].f.f,x+v[i].f.s)+1;\n      else res=min(res,dfs(p-v[i].f.f,x+v[i].f.s)+1);\n    }\n  return dp[p][x]=res;\n}\nint main(){\n  while(cin>>d>>n,d){\n    memset(dp,0,sizeof(dp));\n    v.clear();\n    while(n--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a+b)v.push_back(mk(mk(a,b),c));\n    }\n    int p=dfs(d,0);\n    if(!p)cout<<\"NA\"<<endl;\n    else cout<<p<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define INF (2 << 28)\nusing namespace std;\n\nint d, n, dp[111][111];\nint a[111], e[111], r[111];\n\nint rec(int exp, int hp){\n    \n    if(hp <= 0) return 0;\n    \n    int ret = INF;\n    for(int i = 0; i < n; i++){\n        if(r[i] <= exp && a[i] > 0)\n            ret = min(ret, rec(min(100, exp + e[i]), hp - a[i]) + 1);\n    }\n    return dp[exp][hp] = ret;\n}\n\nint main(){\n    \n    while(cin >> d >> n, d||n){\n        for(int i = 0; i < n; i++) cin >> a[i] >> e[i] >> r[i];\n        \n        memset(dp, -1, sizeof(dp));\n        int dd = rec(0, d);\n        if(dd == INF) cout << \"NA\" << endl;\n        else cout << dd << endl;\n    }\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0288\n  Title:Knocker of the Gigas Cedar\n  @kankichi573\n  2015/10/4 RE 1/10\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <setjmp.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\nint D,N,a[100],e[100],r[100];\nint memo[102][101];\njmp_buf jb;\n\nint solve(int rest,int exp)\n{\n  int i,ret,ret1;\n\n  if(exp>100)\n    exp=101;\n\n  //printf(\"rest=%d exp=%d\\n\",rest,exp);\n  if(ret=memo[rest][exp])\n    goto END;\n\n  for(i=0;i<N;i++)\n    {\n      if(exp >= r[i] && rest <= a[i])\n\t{\n\t  ret=1;\n\t  goto END;\n\t}\n    }\n  ret=INT_MAX;\n\n  for(i=0;i<N;i++)\n    {\n      if(exp >= r[i] && a[i] > 0)\n\t{\n\t  ret1 = 1 + solve(rest-a[i],exp+e[i]);\n\t  ret=min(ret,ret1);\n\t}\n    }\n  if(ret==INT_MAX)\n    if(exp <= 100)\n      for(i=0;i<N;i++)\n\t{\n\t  if(exp >= r[i])\n\t    {\n\t      ret1 = 1 + solve(rest-a[i],exp+e[i]);\n\t      ret=min(ret,ret1);\n\t    }\n\t}\n    else\n      longjmp(jb,1);\n END:    \n    if(ret==INT_MAX)\n      return(-1);\n    else\n      {\n\tmemo[rest][exp]=ret;\n\treturn(ret);\n      }\n}\n\nmain()\n{\n  int i,ret;\n  \n  while(scanf(\"%d %d\",&D,&N)  && (D||N))\n    {\n      memset(memo,0,sizeof(memo));\n      for(i=0;i<N;i++)\n\tscanf(\"%d %d %d\",&a[i],&e[i],&r[i]);\n\n      if(setjmp(jb)==0)\n\t{\n\t  ret=solve(D,0);\n\t  if(ret==-1)\n\t    printf(\"NA\\n\");\n\t  else\n\t    printf(\"%d\\n\",ret);\n\t}\n      else\n\tprintf(\"NA\\n\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define INF 1<<20\n#define min(a,b) a < b ? a : b\nint d, n;\nint a[100], e[100], r[100];\nint mem[300][300];\n\nint solve(int exp, int hp) {\n\tint i, ret = INF;\n\tif (hp <= 0) return 0;\n\tif (exp >= 300) return INF;\n\tif (mem[exp][hp] >= 0) return mem[exp][hp];\n\t\n\tfor (i = 0; i < n; i++) if (r[i] <= exp) {\n\t\tret = min(ret, solve(exp + e[i], hp - a[i]) + 1);\n\t}\n\t\n\treturn mem[exp][hp] = ret;\n}\n\nint main(void) {\n\tint i, j, ans;\n\tfor (;;) {\n\t\tscanf(\"%d%d\", &d, &n);\n\t\tif (!(d|n)) break;\n\t\t\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < 300; i++) for (j = 0; j < 300; j++) {\n\t\t\tmem[i][j] = -1;\n\t\t}\n\t\t\n\t\tans = solve(0, d);\n\t\tif (ans == INF) {\n\t\t\tprintf(\"NA\\n\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 100000000\nint main(){\n  int D,n,i,j,k,l,exp,d[101][3];\n  while(scanf(\"%d %d\",&D,&n),D||n){\n    for(i=0;i<n;i++)scanf(\"%d %d %d\",&d[i][0],&d[i][1],&d[i][2]);\n    int dp[101][102]={0};\n    for(i=0;i<D;i++){\n      for(j=0;j<101;j++)dp[i+1][j]=M;\n    }\n    for(i=1;i<=D;i++){\n      for(j=0;j<101;j++){\n\tfor(k=0;k<n;k++){\n\t  if(j<d[k][2])continue;//exp husoku\n\t  exp=j+d[k][1];\n\t  if(exp>101)exp=101;\n\t  l=i-d[k][0];\n\t  if(l<0)l=0;\n\t  if(dp[i][j]>dp[l][exp]+1)dp[i][j]=dp[l][exp]+1;\n\t}\n      }\n    }\n    if(M-dp[D][0])printf(\"%d\\n\",dp[D][0]);\n    else          printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 100000000\nint main(){\n  int D,n,i,j,k,l,exp,d[101][3];\n  while(scanf(\"%d %d\",&D,&n),D||n){\n    for(i=0;i<n;i++)scanf(\"%d %d %d\",&d[i][0],&d[i][1],&d[i][2]);\n    int dp[101][102]={0};\n    for(i=0;i<D;i++){\n      for(j=0;j<101;j++)dp[i+1][j]=M;\n    }\n    for(i=1;i<=D;i++){\n      for(j=101;j>=0;j--){\n\tfor(k=0;k<n;k++){\n\t  if(j<d[k][2])continue;//exp husoku\n\t  exp=j+d[k][1];\n\t  if(exp>101)exp=101;\n\t  l=i-d[k][0];\n\t  if(l<0)l=0;\n\t  if(dp[i][j]>dp[l][exp]+1)dp[i][j]=dp[l][exp]+1;\n\t}\n      }\n    }\n    if(M-dp[D][0])printf(\"%d\\n\",dp[D][0]);\n    else          printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 100000000\nint main(){\n  int D,n,i,j,k,l,exp,d[101][3];\n  while(scanf(\"%d %d\",&D,&n),D||n){\n    for(i=0;i<n;i++)scanf(\"%d %d %d\",&d[i][0],&d[i][1],&d[i][2]);\n    int dp[101][102]={0};\n    for(i=0;i<D;i++){\n      for(j=0;j<102;j++)dp[i+1][j]=M;\n    }\n    for(i=1;i<=D;i++){\n      for(j=101;j>=0;j--){\n\tfor(k=0;k<n;k++){\n\t  if(j<d[k][2])continue;//exp husoku\n\t  exp=j+d[k][1];\n\t  if(exp>101)exp=101;\n\t  l=i-d[k][0];\n\t  if(l<0)l=0;\n\t  if(dp[i][j]>dp[l][exp]+1)dp[i][j]=dp[l][exp]+1;\n\t}\n      }\n    }\n    /*for(i=0;i<D;i++){\n      for(j=0;j<20;j++)printf(\"%d \",dp[i][j]);printf(\"\\n\");\n      }//*/\n    if(M-dp[D][0])printf(\"%d\\n\",dp[D][0]);\n    else          printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define inf 1072114514\n\ntypedef struct{\n  int a;\n  int e;\n  int r;\n}dat;\n\nint datsort(const void *a,const void *b){\n  if(((dat*)a)->r < ((dat*)b)->r){return -1;}\n  if(((dat*)a)->r > ((dat*)b)->r){return 1;}\n  return 0;\n}\n\nint max(int a,int b){\n  if(a>b){return a;}\n  return b;\n}\n\nint min(int a,int b){\n  if(a<b){return a;}\n  return b;\n}\n\nint main(){\n  int i,j,k,d,n,res;\n  int a[128],e[128],r[128];\n  int dp[128][128];\n  dat data[128];\n  while(scanf(\"%d%d\",&d,&n),d!=0){\n    for(i=0;i<n;i++){\n      scanf(\"%d%d%d\",&data[i].a,&data[i].e,&data[i].r);\n    }\n    qsort(data,n,sizeof(data[0]),datsort);\n    for(i=0;i<n;i++){\n      a[i]=data[i].a;\n      e[i]=data[i].e;\n      r[i]=data[i].r;\n    }\n    for(i=0;i<128;i++){\n      for(j=0;j<128;j++){dp[i][j]=inf;}\n    }\n    dp[d][0]=0;\n    for(j=d;j>0;j--){\n      for(k=0;k<=100;k++){\n        for(i=0;i<n;i++){\n          if(k<r[i]){continue;}\n          dp[max(j-a[i],0)][min(k+e[i],100)]=min(dp[j][k]+1,dp[max(j-a[i],0)][min(k+e[i],100)]);\n        }\n      }\n    }\n    res=inf;\n    for(i=0;i<=100;i++){\n      res=min(dp[0][i],res);\n    }\n    if(res==inf){printf(\"NA\\n\");}\n    else{printf(\"%d\\n\",res);}\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// Aizu 0288: Knocker of the Gigas Cedar\n// 2017.9.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define INF 201\n\nint a[102], e[102], r[102];\nunsigned char dp[102][102];\n\nint main()\n{\n\tint d, n, i, j, k, f, ans;\n\n\twhile (scanf(\"%d%d\", &d, &n) && d > 0) {\n\t\tfor (f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", a+i, e+i, r+i);\n\t\t\tif (a[i] > 0) f = 1;\n\t\t}\n\t\tif (!f) { puts(\"NA\"); continue; } \n\t\n\t\tmemset(dp, INF, sizeof(dp));\n\t\tdp[d][0] = 0;\n\t\tfor (i = d; i >= 0; i--) for (j = 0; j <= 100; j++) {\n\t\t\tfor (k = 0; k < n; k++) if (j >= r[k]) {\n\t\t\t\tint ni, nj;\n\t\t\t\tif (i > a[k]) ni = i-a[k]; else ni = 0;\n\t\t\t\tif (j + e[k] < 100) nj = j + e[k]; else nj = 100;\n\t\t\t\tif (dp[ni][nj] > dp[i][j] + 1) dp[ni][nj] = dp[i][j] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (ans = INF, i = 0; i <= 100; i++) if (dp[0][i] < ans) ans = dp[0][i];\n\t\tif (ans == INF) puts(\"NA\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0288: Knocker of the Gigas Cedar\n// 2017.9.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int a, e, r; } T;\nT tbl[102];\nchar dp[102][102][102];\n\nint main()\n{\n\tint d, n, i, j, k, r, f;\n\n\twhile (scanf(\"%d%d\", &d, &n) && d) {\n\t\tfor (f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", &tbl[i].a, &tbl[i].e, &tbl[i].r);\n\t\t\tif (tbl[i].a > 0) f = 1;\n\t\t}\n\t\tif (!f) { puts(\"NA\"); continue; } \n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0][0] = 1;\n\t\tfor (i = 1; ; i++) {\n\t\t\tf = 0;\n\t\t\tfor (j = 0; j <= d; j++) for (r = 0; r <= 100; r++) {\n\t\t\t\tif (!dp[i-1][j][r]) continue;\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\tif (tbl[k].r > r) continue;\n\t\t\t\t\tdp[i][j+tbl[k].a][r+tbl[k].e] = 1;\n\t\t\t\t\tif (tbl[k].e > 0 || tbl[k].a > 0) f = 1;\n\t\t\t\t\tif (j+tbl[k].a >= d) { printf(\"%d\\n\", i); goto Done; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) { puts(\"NA\"); goto Done; }\n\t\t}\n\t\tDone:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0288: Knocker of the Gigas Cedar\n// 2017.9.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define INF 0x11111111\n\nint a[102], e[102], r[102];\nint dp[102][102];\n\nint main()\n{\n\tint d, n, i, j, k, f, ans;\n\n\twhile (scanf(\"%d%d\", &d, &n) && d > 0) {\n\t\tfor (f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", a+i, e+i, r+i);\n\t\t\tif (a[i] > 0) f = 1;\n\t\t}\n\t\tif (!f) { puts(\"NA\"); continue; } \n\t\n\t\tmemset(dp, INF, sizeof(dp));\n\t\tdp[d][0] = 0;\n\t\tfor (i = d; i >= 0; i--) for (j = 0; j <= 100; j++) {\n\t\t\tfor (k = 0; k < n; k++) if (j >= r[k]) {\n\t\t\t\tint ni, nj;\n\t\t\t\tni = 0;   if (i > a[k])       ni = i-a[k];\n\t\t\t\tnj = 100; if (j + e[k] < 100) nj = j + e[k];\n\t\t\t\tif (dp[ni][nj] > dp[i][j] + 1) dp[ni][nj] = dp[i][j] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (ans = INF, i = 0; i <= 100; i++) if (dp[0][i] < ans) ans = dp[0][i];\n\t\tif (ans == INF) puts(\"NA\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define INF 1<<20\n#define min(a,b) a < b ? a : b\nint d, n;\nint a[100], e[100], r[100];\nint mem[300][300];\n\nint solve(int exp, int hp) {\n\tint i, ret = INF;\n\tif (hp <= 0) return 0;\n\tif (mem[exp][hp] >= 0) return mem[exp][hp];\n\t\n\tfor (i = 0; i < n; i++) if (r[i] <= exp) {\n\t\tret = min(ret, solve(exp + e[i], hp - a[i]) + 1);\n\t}\n\t\n\treturn mem[exp][hp] = ret;\n}\n\nint main(void) {\n\tint i, j, ans;\n\tfor (;;) {\n\t\tscanf(\"%d%d\", &d, &n);\n\t\tif (!(d|n)) break;\n\t\t\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < 300; i++) for (j = 0; j < 300; j++) {\n\t\t\tmem[i][j] = -1;\n\t\t}\n\t\t\n\t\tans = solve(0, d);\n\t\tif (ans == INF) {\n\t\t\tprintf(\"NA\\n\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0288\n  Title:Knocker of the Gigas Cedar\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\nint D,N,a[100],e[100],r[100];\nint memo[101][101];\n\nint solve(int rest,int exp)\n{\n  int i,ret,ret1;\n\n  //printf(\"rest=%d exp=%d\\n\",rest,exp);\n  if(ret=memo[rest][exp])\n    goto END;\n\n  for(i=0;i<N;i++)\n    {\n      if(exp >= r[i] && rest <= a[i])\n\t{\n\t  ret=1;\n\t  goto END;\n\t}\n    }\n  ret=INT_MAX;\n    for(i=0;i<N;i++)\n    {\n      //printf(\"i=%d r=%d|\",i,r[i]);\n      if(exp >= r[i])\n\t{\n\t  ret1 = 1 + solve(rest-a[i],exp+e[i]);\n\t  ret=min(ret,ret1);\n\t}\n    }\n END:    \n    if(ret==INT_MAX)\n      return(-1);\n    else\n      {\n\tmemo[rest][exp]=ret;\n\treturn(ret);\n      }\n}\n\nmain()\n{\n  int i,ret;\n  \n  while(scanf(\"%d %d\",&D,&N)  && (D||N))\n    {\n      memset(memo,0,sizeof(memo));\n      for(i=0;i<N;i++)\n\tscanf(\"%d %d %d\",&a[i],&e[i],&r[i]);\n      ret=solve(D,0);\n      if(ret==-1)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",ret);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0288: Knocker of the Gigas Cedar\n// 2017.9.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int a, e, r; } T;\nT tbl[102];\nchar dp[210][102][102];\n\nint main()\n{\n\tint d, n, i, j, k, r, f, k1, k2;\n\n\twhile (scanf(\"%d%d\", &d, &n) && d) {\n\t\tfor (f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", &tbl[i].a, &tbl[i].e, &tbl[i].r);\n\t\t\tif (tbl[i].a > 0) f = 1;\n\t\t}\n\t\tif (!f) { puts(\"NA\"); continue; } \n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0][0] = 1;\n\t\tfor (i = 1; ; i++) {\n\t\t\tf = 0;\n\t\t\tfor (j = 0; j < d; j++) for (r = 0; r <= 100; r++) {\n\t\t\t\tif (!dp[i-1][j][r]) continue;\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\tif (tbl[k].r > r) continue;\n\t\t\t\t\tif ((k1 = r+tbl[k].e) > 100) k1 = 100;\n\t\t\t\t\tif ((k2 = j+tbl[k].a) > 100) k2 = 100;\n\t\t\t\t\tdp[i][k2][k1] = 1;\n\t\t\t\t\tif (tbl[k].e > 0 || tbl[k].a > 0) f = 1;\n\t\t\t\t\tif (j+tbl[k].a >= d) { printf(\"%d\\n\", i); goto Done; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) { puts(\"NA\"); goto Done; }\n\t\t}\n\t\tDone:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 1000\n\nint D,N;\nint a[100];\nint e[100];\nint r[100];\n\nint memo[101][101];\n\nint search(int tkrk,int kkt) {\n\tint ret=INF;\n\tint i;\n\tif(tkrk<=0)return 0;\n\tif(memo[tkrk][kkt]>0)return memo[tkrk][kkt]-1;\n\tmemo[tkrk][kkt]=INF+1;\n\tfor(i=0;i<N;i++) {\n\t\tif(kkt>=r[i]) {\n\t\t\tint next_kkt=kkt+e[i];\n\t\t\tint candidate;\n\t\t\tif(next_kkt>100)next_kkt=100;\n\t\t\tcandidate=search(tkrk-a[i],next_kkt)+1;\n\t\t\tif(candidate<ret)ret=candidate;\n\t\t}\n\t}\n\tmemo[tkrk][kkt]=ret+1;\n\treturn ret;\n}\n\nint main(void) {\n\twhile(scanf(\"%d%d\",&D,&N)==2 && (D!=0 || N!=0)) {\n\t\tint i,j;\n\t\tint ret;\n\t\tfor(i=0;i<N;i++) {\n\t\t\tif(scanf(\"%d%d%d\",&a[i],&e[i],&r[i])!=3)return 1;\n\t\t}\n\t\tfor(i=0;i<=100;i++) {\n\t\t\tfor(j=0;j<=100;j++)memo[i][j]=0;\n\t\t}\n\t\tret=search(D,0);\n\t\tif(ret==INF)puts(\"NA\"); else printf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint min(int l, int r)\n{\n\treturn l < r ? l : r;\n}\n\nint cost(int d, int g, const int *a, const int *e, const int *r, int *cache, int n)\n{\n\t// ??´??????\n\tif (d <= 0) return 0;\n\t\n\t// ????¨??????????\n\tg = min(g, 100);\n\t\n\t// ????¨??????????????¨????\n\t// ????????§??¬????????????????????§?????????0???????¨??????¨??????OK\n\tif (!cache[g * 100 + d]) {\n\t\tint i;\n\t\t\n\t\t// ?????????(??°?????????)\n\t\tcache[g * 100 + d] = 9999;\n\t\t\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\t// ?????¨??????????£?????????¢?´¢\n\t\t\t// ????????????????£????????????¨??????\n\t\t\t// ????¨????????????§???????????????????£????????????¨??????\n\t\t\tif (r[i] <= g && (a[i] != 0 || e[i] != 0) && (g < 100 || a[i] > 0)) {\n\t\t\t\tcache[g * 100 + d] = min(cache[g * 100 + d], cost(d - a[i], g + e[i], a, e, r, cache, n) + 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//printf(\"d=%d g=%d result=%d\\n\", d, g, cache[g * 100 + d]);\n\t\n\treturn cache[g * 100 + d];\n}\n\nint main(void)\n{\n\tint d, n;\n\t\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\tint a[100], e[100], r[100], cache[101 * 100] = { 0 }; // ????¨???????0(??¢???????????§)\n\t\tint result, i;\n\t\t\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tscanf(\"%d%d%d\", a + i, e + i, r + i);\n\t\t}\n\n\t\tresult = cost(d, 0, a, e, r, cache, n);\n\t\t\n\t\tif (result < 9999) printf(\"%d\\n\", result);\n\t\telse               printf(\"NA\\n\", result);\n\t\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0288: Knocker of the Gigas Cedar\n// 2017.9.10 bal4u@uu\n// 2017.11.12\n\n#include <stdio.h>\n#include <string.h>\n#define INF 0x11111111\n\nint a[102], e[102], r[102];\nint dp[102][102];\n\nint main()\n{\n\tint d, n, i, j, k, f, ans;\n\n\twhile (scanf(\"%d%d\", &d, &n) && d > 0) {\n\t\tfor (f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", a+i, e+i, r+i);\n\t\t\tif (a[i] > 0) f = 1;\n\t\t}\n\t\tif (!f) { puts(\"NA\"); continue; } \n\t\n\t\tmemset(dp, INF, sizeof(dp));\n\t\tdp[d][0] = 0;\n\t\tfor (i = d; i >= 0; i--) for (k = 0; k < n; k++) {\n\t\t\tfor (j = r[k]; j <= 100; j++) {\n\t\t\t\tint ni, nj;\n\t\t\t\tif (i > a[k]) ni = i-a[k]; else ni = 0;\n\t\t\t\tif (j + e[k] < 100) nj = j + e[k]; else nj = 100;\n\t\t\t\tif (dp[ni][nj] > dp[i][j] + 1) dp[ni][nj] = dp[i][j] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (ans = INF, i = 0; i <= 100; i++) if (dp[0][i] < ans) ans = dp[0][i];\n\t\tif (ans == INF) puts(\"NA\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint min(int l, int r)\n{\n\treturn l < r ? l : r;\n}\n\nint cost(int d, int g, const int *a, const int *e, const int *r, int *cache, int n)\n{\n\t// ??´??????\n\tif (d <= 0) return 0;\n\t\n\t// ????¨??????????, ??¬????????????????°?????????????\n\tg = min(g, 100);\n\t\n\t// ????¨??????????????¨????\n\t// ????????§??¬????????????????????§?????????0???????¨??????¨??????OK\n\tif (!cache[g * 100 + d]) {\n\t\tint i;\n\t\t\n\t\t// ?????????(??°?????????)\n\t\tcache[g * 100 + d] = 9999;\n\t\t\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\t// ?????¨??????????£?????????¢?´¢\n\t\t\t// ????¨????????????§???????????????????£????????????¨??????\n\t\t\tif (r[i] <= g && (g < 100 || a[i] > 0)) {\n\t\t\t\tcache[g * 100 + d] = min(cache[g * 100 + d], cost(d - a[i], g + e[i], a, e, r, cache, n) + 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//printf(\"d=%d g=%d result=%d\\n\", d, g, cache[g * 100 + d]);\n\t\n\treturn cache[g * 100 + d];\n}\n\nint main(void)\n{\n\tint d, n;\n\t\n\twhile (scanf(\"%d%d\", &d, &n), d) {\n\t\tint a[100], e[100], r[100], cache[101 * 100] = { 0 }; // ????¨???????0(??¢???????????§)\n\t\tint result;\n\t\tint i;\n\t\t\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tscanf(\"%d%d%d\", a + i, e + i, r + i);\n\t\t}\n\n\t\tresult = cost(d, 0, a, e, r, cache, n);\n\t\t\n\t\tif (result < 9999) printf(\"%d\\n\", result);\n\t\telse               printf(\"NA\\n\", result);\n\t\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0288: Knocker of the Gigas Cedar\n// 2017.9.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int a, e, r; } T;\nT tbl[102];\nchar dp[202][202][202];\n\nint main()\n{\n\tint d, n, i, j, k, r, f;\n\n\twhile (scanf(\"%d%d\", &d, &n) && d) {\n\t\tfor (f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", &tbl[i].a, &tbl[i].e, &tbl[i].r);\n\t\t\tif (tbl[i].a > 0) f = 1;\n\t\t}\n\t\tif (!f) { puts(\"NA\"); continue; } \n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0][0] = 1;\n\t\tfor (i = 1; ; i++) {\n\t\t\tf = 0;\n\t\t\tfor (j = 0; j < d; j++) for (r = 0; r <= 100; r++) {\n\t\t\t\tif (!dp[i-1][j][r]) continue;\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\tif (tbl[k].r > r) continue;\n\t\t\t\t\tdp[i][j+tbl[k].a][r+tbl[k].e] = 1;\n\t\t\t\t\tif (tbl[k].e > 0 || tbl[k].a > 0) f = 1;\n\t\t\t\t\tif (j+tbl[k].a >= d) { printf(\"%d\\n\", i); goto Done; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) { puts(\"NA\"); goto Done; }\n\t\t}\n\t\tDone:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0288: Knocker of the Gigas Cedar\n// 2017.9.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int a, e, r; } T;\nT tbl[102];\nchar dp[310][202][202];\n\nint main()\n{\n\tint d, n, i, j, k, r, f;\n\n\twhile (scanf(\"%d%d\", &d, &n) && d) {\n\t\tfor (f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", &tbl[i].a, &tbl[i].e, &tbl[i].r);\n\t\t\tif (tbl[i].a > 0) f = 1;\n\t\t}\n\t\tif (!f) { puts(\"NA\"); continue; } \n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0][0] = 1;\n\t\tfor (i = 1; ; i++) {\n\t\t\tf = 0;\n\t\t\tfor (j = 0; j < d; j++) for (r = 0; r <= 100; r++) {\n\t\t\t\tif (!dp[i-1][j][r]) continue;\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\tif (tbl[k].r > r) continue;\n\t\t\t\t\tdp[i][j+tbl[k].a][r+tbl[k].e] = 1;\n\t\t\t\t\tif (tbl[k].e > 0 || tbl[k].a > 0) f = 1;\n\t\t\t\t\tif (j+tbl[k].a >= d) { printf(\"%d\\n\", i); goto Done; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) { puts(\"NA\"); goto Done; }\n\t\t}\n\t\tDone:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define INF 1<<20\n#define min(a,b) a < b ? a : b\nint d, n;\nint a[100], e[100], r[100];\nint mem[300][300];\n\nint solve(int exp, int hp) {\n\tint i, ret = INF;\n\tif (hp <= 0) return 0;\n\tif (exp >= 300) return INF;\n\tif (mem[exp][hp] >= 0) return mem[exp][hp];\n\t\n\tfor (i = 0; i < n; i++) if (r[i] <= exp) {\n\t\tif (!(a[i]|e[i])) continue;\n\t\tret = min(ret, solve(exp + e[i], hp - a[i]) + 1);\n\t}\n\t\n\treturn mem[exp][hp] = ret;\n}\n\nint main(void) {\n\tint i, j, ans;\n\tfor (;;) {\n\t\tscanf(\"%d%d\", &d, &n);\n\t\tif (!(d|n)) break;\n\t\t\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n\t\t}\n\t\t\n\t\tfor (i = 0; i < 300; i++) for (j = 0; j < 300; j++) {\n\t\t\tmem[i][j] = -1;\n\t\t}\n\t\t\n\t\tans = solve(0, d);\n\t\tif (ans == INF) {\n\t\t\tprintf(\"NA\\n\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0288: Knocker of the Gigas Cedar\n// 2017.9.10 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define INF 120\n\nint a[102], e[102], r[102];\nchar dp[102][102];\n\nint main()\n{\n\tint d, n, i, j, k, f, ans;\n\n\twhile (scanf(\"%d%d\", &d, &n) && d > 0) {\n\t\tfor (f = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d%d%d\", a+i, e+i, r+i);\n\t\t\tif (a[i] > 0) f = 1;\n\t\t}\n\t\tif (!f) { puts(\"NA\"); continue; } \n\t\n\t\tmemset(dp, INF, sizeof(dp));\n\t\tdp[d][0] = 0;\n\t\tfor (i = d; i >= 0; i--) for (k = 0; k < n; k++) {\n\t\t\tfor (j = r[k]; j <= 100; j++) {\n\t\t\t\tint ni, nj;\n\t\t\t\tif (i > a[k]) ni = i-a[k]; else ni = 0;\n\t\t\t\tif (j + e[k] < 100) nj = j + e[k]; else nj = 100;\n\t\t\t\tif (dp[ni][nj] > dp[i][j] + 1) dp[ni][nj] = dp[i][j] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (ans = INF, i = 0; i <= 100; i++) if (dp[0][i] < ans) ans = dp[0][i];\n\t\tif (ans == INF) puts(\"NA\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define INF 1<<20\n#define min(a,b) a < b ? a : b\nint d, n;\nint a[100], e[100], r[100];\nint mem[10010][300];\n \nint solve(int exp, int hp) {\n    int i, ret = INF;\n    if (hp <= 0) return 0;\n    if (exp > 10000) return INF;\n    if (mem[exp][hp] >= 0) return mem[exp][hp];\n     \n    for (i = 0; i < n; i++) if (r[i] <= exp) {\n        if (!(a[i]|e[i])) continue;\n        ret = min(ret, solve(exp + e[i], hp - a[i]) + 1);\n    }\n     \n    return mem[exp][hp] = ret;\n}\n \nint main(void) {\n    int i, j, ans;\n    for (;;) {\n        scanf(\"%d%d\", &d, &n);\n        if (!(d|n)) break;\n         \n        for (i = 0; i < n; i++) {\n            scanf(\"%d%d%d\", &a[i], &e[i], &r[i]);\n        }\n         \n        for (i = 0; i < 300; i++) for (j = 0; j < 300; j++) {\n            mem[i][j] = -1;\n        }\n         \n        ans = solve(0, d);\n        if (ans == INF) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    while(true){\n        val (d, n) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (n == 0) return\n        val tools = Array(n){\n            val (a, e, r) = readLine()!!.trim().split(' ').map(String::toInt)\n            Tool(a, e, r)\n        }\n        println(\n                solve(d, tools) ?: \"NA\"\n        )\n    }\n}\nfun solve(treeHealth: Int, tools: Array<Tool>): Int? {\n    if (tools.none{it.experienceNeed == 0 && (it.experienceGain > 0 || it.damage > 0)}) return null\n    val sorted = tools.filterNot{it.damage == 0 && it.experienceGain == 0}.sortedBy(Tool::experienceNeed)\n    val maxExperience = sorted.maxBy(Tool::experienceNeed)!!.experienceNeed\n    val memo = Array(treeHealth + 1){Array(maxExperience + 1){Array(tools.size){null as Int?}}}\n    fun sub(health: Int, experience: Int, tool: Int): Int? {\n        return when{\n            health <= 0 -> 0\n            tool >= sorted.size -> null\n            memo[health][experience][tool] != null -> memo[health][experience][tool]\n            experience < sorted[tool].experienceNeed -> null\n            sorted[tool].damage == 0 && experience == maxExperience -> {\n                memo[health][experience][tool] = sub(health, experience, tool + 1)\n                memo[health][experience][tool]\n            }\n            else -> {\n                memo[health][experience][tool] = listOf(sub(health - sorted[tool].damage, minOf(maxExperience, experience + sorted[tool].experienceGain), tool)?.let{it + 1}, sub(health, experience, tool + 1)).filterNotNull().min()\n                memo[health][experience][tool]\n            }\n        }\n    }\n    return sub(treeHealth, 0, 0)\n}\ndata class Tool(val damage: Int, val experienceGain: Int, val experienceNeed: Int)\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\td = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((d | n) == 0)\n\t\t\t\tbreak;\n\t\t\taer = new AER[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\taer[i] = new AER(scanner.nextInt(), scanner.nextInt(),\n\t\t\t\t\t\tscanner.nextInt());\n\t\t\t}\n\t\t\tPriorityQueue<AER> pq = new PriorityQueue<AER>();\n\t\t\tpq.offer(new AER(d, 0, 0));\n\t\t\tans = INF;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tAER now = pq.poll();\n\t\t\t\tif (now.a == 0) {\n\t\t\t\t\tans = Math.min(ans, now.r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (AER a : aer) {\n\t\t\t\t\tif (now.e < a.r)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nhp = Math.max(0, now.a - a.a);\n\t\t\t\t\tint nexp = Math.min(100, now.e + a.e);\n\t\t\t\t\tif (now.a == nhp && now.e == nexp)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpq.offer(new AER(nhp, nexp, now.r + 1));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans == INF ? \"NA\" : ans);\n\t\t}\n\t}\n\n\tint d, n;\n\tint INF = 1 << 30;\n\tAER[] aer;\n\tint ans;\n\n\tclass AER implements Comparable<AER> {\n\t\tint a, e, r;\n\n\t\tpublic AER(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"AER [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(AER o) {\n\t\t\tif (this.r == o.r)\n\t\t\t\treturn this.a - o.a;\n\t\t\treturn this.r - o.r;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n */\npublic class Main {\n\n\tstatic int[] A;\n\tstatic int[] E;\n\tstatic int[] R;\n\tstatic int min;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint D, N;\n\t\t\tD = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tN = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((D | N) == 0) break;\n\n\t\t\tA = new int[N];\n\t\t\tE = new int[N];\n\t\t\tR = new int[N];\n\t\t\tmin = Integer.MAX_VALUE;\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tA[i] = parseInt(words[0]);\n\t\t\t\tE[i] = parseInt(words[1]);\n\t\t\t\tR[i] = parseInt(words[2]);\n\t\t\t}\n\n\t\t\tboolean possible = false;\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (R[i] == 0 && E[i] > 0) {\n\t\t\t\t\tpossible = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (possible && A[i] > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (possible) {\n\t\t\t\trec(D, 0, 0);\n\t\t\t\tSystem.out.println(min);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic void rec(int d, int e, int c) {\n\n\t\tif (c >= min && d > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (d <= 0) {\n\t\t\tmin = Math.min(min, c);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = A.length - 1; i >= 0; i--) {\n\t\t\tif (R[i] <= e) {\n\t\t\t\trec(d - A[i], e + E[i], c + 1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    int INF = 1 << 28;\n    int d, n;\n    int[] a, e, r;\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        for (;;) {\n            d = sc.nextInt(); n = sc.nextInt();\n            if ((d|n) == 0) break;\n            \n            a = new int[n]; e = new int[n]; r = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt(); e[i] = sc.nextInt(); r[i] = sc.nextInt();\n            }\n            \n            mem = new int[110][110];\n            for (int[] a : mem) fill(a, -1);\n            \n            int ret = solve(0, d);\n            if (ret == INF) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(ret);\n            }\n        }\n    }\n    \n    int[][] mem;\n    int solve(int exp, int hp) {\n        if (hp < 0) return 0; \n        if (mem[exp][hp] > 0) return mem[exp][hp];\n        \n        int min = INF;\n        for (int i = 0; i < n; i++) if (r[i] <= exp){\n            min = min(min, solve(exp + e[i], hp - a[i]) + 1);\n        }\n        \n        return mem[exp][hp] = min;\n    }\n    \n    void debug(Object...os) {\n        System.out.println(deepToString(os));\n    }\n    \n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\td = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((d | n) == 0)\n\t\t\t\tbreak;\n\t\t\taer = new AER[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\taer[i] = new AER(scanner.nextInt(), scanner.nextInt(),\n\t\t\t\t\t\tscanner.nextInt());\n\t\t\t}\n\t\t\tdp = new int[d + 1][101];\n\t\t\tfor (int[] dpp : dp)\n\t\t\t\tArrays.fill(dpp, -1);\n\t\t\tint ans = dfs(d, 0);\n\t\t\tSystem.out.println(ans == INF ? \"NA\" : ans);\n\t\t}\n\t}\n\n\tprivate int dfs(int hp, int exp) {\n\t\tif (hp == 0)\n\t\t\treturn 0;\n\t\tif (dp[hp][exp] > -1)\n\t\t\treturn dp[hp][exp];\n\n\t\tint res = INF;\n\t\tfor (AER a : aer) {\n\t\t\tif (a.r > exp)\n\t\t\t\tcontinue;\n\t\t\tint nhp = Math.max(0, hp - a.a);\n\t\t\tint nexp = Math.min(100, exp + a.e);\n\t\t\tres = Math.min(res, dfs(nhp, nexp) + 1);\n\t\t}\n\t\treturn dp[hp][exp] = res;\n\t}\n\n\tint d, n;\n\tint[][] dp;\n\tint INF = 1 << 30;\n\tAER[] aer;\n\n\tclass AER {\n\t\tint a, e, r;\n\n\t\tpublic AER(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"AER [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n    int INF = 1 << 28;\n    int d, n;\n    int[] a, e, r;\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        for (;;) {\n            d = sc.nextInt(); n = sc.nextInt();\n            if ((d|n) == 0) break;\n            \n            a = new int[n]; e = new int[n]; r = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt(); e[i] = sc.nextInt(); r[i] = sc.nextInt();\n            }\n            \n            mem = new int[300][300];\n            for (int[] a : mem) fill(a, -1);\n            \n            int ret = solve(0, d);\n            if (ret == INF) {\n                System.out.println(\"NA\");\n            } else {\n                System.out.println(ret);\n            }\n        }\n    }\n    \n    int[][] mem;\n    int solve(int exp, int hp) {\n        if (hp < 0) return 0; \n        if (mem[exp][hp] > 0) return mem[exp][hp];\n        \n        int min = INF;\n        for (int i = 0; i < n; i++) if (r[i] <= exp){\n            min = min(min, solve(exp + e[i], hp - a[i]) + 1);\n        }\n        \n        return mem[exp][hp] = min;\n    }\n    \n    void debug(Object...os) {\n        System.out.println(deepToString(os));\n    }\n    \n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint D = scanner.nextInt();\n\t\t\tint N = scanner.nextInt();\n\t\t\tif ((D | N) == 0)\n\t\t\t\tbreak;\n\t\t\tJu[] jus = new Ju[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint e = scanner.nextInt();\n\t\t\t\tint r = scanner.nextInt();\n\t\t\t\tjus[i] = new Ju(a, e, r);\n\t\t\t}\n\t\t\tPriorityQueue<Ju> pq = new PriorityQueue<Ju>();\n\t\t\tpq.offer(new Ju(D, 0, 0));\n\t\t\tString ans = \"NA\";\n\t\t\tint[][] cost = new int[D + 1][100];\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tJu ju = pq.poll();\n\t\t\t\tif (ju.a <= 0) {\n\t\t\t\t\tans = String.valueOf(ju.r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cost[ju.a][ju.r] > ju.e)\n\t\t\t\t\tcontinue;\n\t\t\t\tcost[ju.a][ju.r] = ju.e;\n\t\t\t\tfor (Ju j : jus) {\n\t\t\t\t\tif (ju.e >= j.r) {\n\t\t\t\t\t\tpq.offer(new Ju(ju.a - j.a, ju.e + j.e, ju.r + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tclass Ju implements Comparable<Ju> {\n\t\tint a, e, r;\n\n\t\tpublic Ju(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Ju [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Ju o) {\n\t\t\tif (this.r == o.r)\n\t\t\t\treturn this.a - o.a;\n\t\t\treturn this.r - o.r;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint INF = 1 << 24;\n\t\twhile (true) {\n\t\t\tint D = scanner.nextInt();\n\t\t\tint N = scanner.nextInt();\n\t\t\tif ((D | N) == 0)\n\t\t\t\tbreak;\n\t\t\tAER[] aer = new AER[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\taer[i] = new AER(scanner.nextInt(), scanner.nextInt(),\n\t\t\t\t\t\tscanner.nextInt());\n\t\t\t}\n\t\t\tint[][] dp = new int[D + 1][101];\n\t\t\tfor (int[] d : dp)\n\t\t\t\tArrays.fill(d, INF);\n\t\t\tdp[D][0] = 0;\n\t\t\tfor (int i = D; i > 0; i--) {\n\t\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\t\tif (dp[i][j] == INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (AER a : aer) {\n\t\t\t\t\t\tif (j < a.r)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tint aa = Math.max(0, i - a.a);\n\t\t\t\t\t\tint bb = Math.min(100, j + a.e);\n\t\t\t\t\t\tdp[aa][bb] = Math.min(dp[aa][bb], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i < 101; i++) {\n\t\t\t\tans = Math.min(ans, dp[0][i]);\n\t\t\t}\n\t\t\tSystem.out.println(ans == INF ? \"NA\" : ans);\n\t\t}\n\t}\n\n\tclass AER {\n\t\tint a, e, r;\n\n\t\tpublic AER(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"AER [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\td = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((d | n) == 0)\n\t\t\t\tbreak;\n\t\t\taer = new AER[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\taer[i] = new AER(scanner.nextInt(), scanner.nextInt(),\n\t\t\t\t\t\tscanner.nextInt());\n\t\t\t}\n\t\t\tdp = new int[d + 1][101];\n\t\t\tfor (int[] dpp : dp)\n\t\t\t\tArrays.fill(dpp, INF);\n\t\t\tPriorityQueue<AER> pq = new PriorityQueue<AER>();\n\t\t\tpq.offer(new AER(d, 0, 0));\n\t\t\tans = INF;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tAER now = pq.poll();\n\t\t\t\tif (now.a == 0) {\n\t\t\t\t\tans = Math.min(ans, now.r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (AER a : aer) {\n\t\t\t\t\tif (now.e < a.r)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nhp = Math.max(0, now.a - a.a);\n\t\t\t\t\tint nexp = Math.min(100, now.e + a.e);\n\t\t\t\t\tif (now.a == nhp && now.e == nexp)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[nhp][nexp] <= now.r + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[nhp][nexp] = now.r + 1;\n\t\t\t\t\tpq.offer(new AER(nhp, nexp, now.r + 1));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans == INF ? \"NA\" : ans);\n\t\t}\n\t}\n\n\tint d, n;\n\tint[][] dp;\n\tint INF = 1 << 30;\n\tAER[] aer;\n\tint ans;\n\n\tclass AER implements Comparable<AER> {\n\t\tint a, e, r;\n\n\t\tpublic AER(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"AER [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(AER o) {\n\t\t\tif (this.r == o.r)\n\t\t\t\treturn this.a - o.a;\n\t\t\treturn this.r - o.r;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Knocker of the Gigas Cedar\n * PCK2013 ??¬???4\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint D, N;\n\t\t\tD = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tN = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((D | N) == 0) break;\n\n\t\t\tint[] A = new int[N];\n\t\t\tint[] E = new int[N];\n\t\t\tint[] R = new int[N];\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tA[i] = parseInt(words[0]);\n\t\t\t\tE[i] = parseInt(words[1]);\n\t\t\t\tR[i] = parseInt(words[2]);\n\t\t\t}\n\n\t\t\t//?¨?????????????????????????, ????¨????\n\t\t\tint[][] dp = new int[D + 1][101];\n\n\t\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\n\t\t\tdp[0][0] = 0;\n\n\t\t\tfor (int i = 0; i <= D; i++) {\n\t\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\tint nd = Math.min(i + A[k], D);\n\t\t\t\t\t\tint ne = Math.min(j + E[k], 100);\n\t\t\t\t\t\tif (j >= R[k]) {\n\t\t\t\t\t\t\tdp[nd][ne] = Math.min(dp[nd][ne], dp[i][j] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = INF;\n\n\t\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\t\tans = Math.min(ans, dp[D][i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(ans != INF ? ans : \"NA\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint D = scanner.nextInt();\n\t\t\tint N = scanner.nextInt();\n\t\t\tif ((D | N) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] a = new int[N];\n\t\t\tint[] e = new int[N];\n\t\t\tint[] r = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint aa = scanner.nextInt();\n\t\t\t\tint ee = scanner.nextInt();\n\t\t\t\tint rr = scanner.nextInt();\n\t\t\t\ta[i] = aa;\n\t\t\t\te[i] = ee;\n\t\t\t\tr[i] = rr;\n\t\t\t}\n\t\t\tint[][] dp = new int[D + 1][101];\n\t\t\tfor (int[] d : dp)\n\t\t\t\tArrays.fill(d, INF);\n\t\t\tdp[D][0] = 0;\n\t\t\tfor (int i = D; i > 0; i--) {\n\t\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\t\tif (dp[i][j] == INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\tif (j < r[k])\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdp[Math.max(0, i - a[k])][Math.min(100, j + e[k])] = Math\n\t\t\t\t\t\t\t\t.min(dp[Math.max(0, i - a[k])][Math.min(100, j\n\t\t\t\t\t\t\t\t\t\t+ e[k])], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret = INF;\n\t\t\tfor (int i = 0; i < 101; i++)\n\t\t\t\tret = Math.min(ret, dp[0][i]);\n\t\t\tSystem.out.println(ret == INF ? \"NA\" : ret);\n\t\t}\n\n\t}\n\n\tint INF = 1 << 30;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\td = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((d | n) == 0)\n\t\t\t\tbreak;\n\t\t\taer = new AER[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\taer[i] = new AER(scanner.nextInt(), scanner.nextInt(),\n\t\t\t\t\t\tscanner.nextInt());\n\t\t\t}\n\t\t\tdp = new int[d + 1][101];\n\t\t\tfor (int[] dpp : dp)\n\t\t\t\tArrays.fill(dpp, -1);\n\t\t\tint ans = dfs(d, 0);\n\t\t\tSystem.out.println(ans == INF ? \"NA\" : ans);\n\t\t}\n\t}\n\n\tprivate int dfs(int hp, int exp) {\n\t\tif (hp == 0)\n\t\t\treturn 0;\n\t\tif (dp[hp][exp] > -1)\n\t\t\treturn dp[hp][exp];\n\n\t\tint res = INF;\n\t\tfor (AER a : aer) {\n\t\t\tif (a.r > exp)\n\t\t\t\tcontinue;\n\n\t\t\tint nhp = Math.max(0, hp - a.a);\n\t\t\tint nexp = Math.min(100, exp + a.e);\n\t\t\tif (hp == nhp && exp == nexp)\n\t\t\t\tcontinue;\n\t\t\tres = Math.min(res, dfs(nhp, nexp) + 1);\n\t\t}\n\t\treturn dp[hp][exp] = res;\n\t}\n\n\tint d, n;\n\tint[][] dp;\n\tint INF = 1 << 30;\n\tAER[] aer;\n\n\tclass AER {\n\t\tint a, e, r;\n\n\t\tpublic AER(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"AER [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint D = scanner.nextInt();\n\t\t\tint N = scanner.nextInt();\n\t\t\tif ((D | N) == 0)\n\t\t\t\tbreak;\n\t\t\tJu[] jus = new Ju[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint e = scanner.nextInt();\n\t\t\t\tint r = scanner.nextInt();\n\t\t\t\tjus[i] = new Ju(a, e, r);\n\t\t\t}\n\t\t\tPriorityQueue<Ju> pq = new PriorityQueue<Ju>();\n\t\t\tpq.offer(new Ju(D, 0, 0));\n\t\t\tString ans = \"NA\";\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tJu ju = pq.poll();\n\t\t\t\tif (ju.a <= 0) {\n\t\t\t\t\tans = String.valueOf(ju.r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (Ju j : jus) {\n\t\t\t\t\tif (ju.e >= j.r) {\n\t\t\t\t\t\tpq.offer(new Ju(ju.a - j.a, ju.e + j.e, ju.r + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tclass Ju implements Comparable<Ju> {\n\t\tint a, e, r;\n\n\t\tpublic Ju(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\t\t\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Ju [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\n\t\t@Override\n\t\tpublic int compareTo(Ju o) {\n\t\t\tif (this.r == o.r)\n\t\t\t\treturn this.a - o.a;\n\t\t\treturn this.r - o.r;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\td = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((d | n) == 0)\n\t\t\t\tbreak;\n\t\t\taer = new AER[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\taer[i] = new AER(scanner.nextInt(), scanner.nextInt(),\n\t\t\t\t\t\tscanner.nextInt());\n\t\t\t}\n\t\t\tdp = new int[d + 1][101];\n\t\t\tfor (int[] dpp : dp)\n\t\t\t\tArrays.fill(dpp, INF);\n\t\t\tPriorityQueue<AER> pq = new PriorityQueue<AER>();\n\t\t\tpq.offer(new AER(d, 0, 0));\n\t\t\tans = INF;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tAER now = pq.poll();\n\t\t\t\tif (now.a == 0) {\n\t\t\t\t\tans = Math.min(ans, now.r);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ans - 1 <= now.r)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (AER a : aer) {\n\t\t\t\t\tif (now.e < a.r)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nhp = Math.max(0, now.a - a.a);\n\t\t\t\t\tint nexp = Math.min(100, now.e + a.e);\n\t\t\t\t\tif (now.a == nhp && now.e == nexp)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[nhp][nexp] <= now.r + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[nhp][nexp] = now.r + 1;\n\t\t\t\t\tpq.offer(new AER(nhp, nexp, now.r + 1));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans == INF ? \"NA\" : ans);\n\t\t}\n\t}\n\n\tint d, n;\n\tint[][] dp;\n\tint INF = 1 << 30;\n\tAER[] aer;\n\tint ans;\n\n\tclass AER implements Comparable<AER> {\n\t\tint a, e, r;\n\n\t\tpublic AER(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"AER [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(AER o) {\n\t\t\tif (this.a == o.a)\n\t\t\t\treturn this.r - o.r;\n\t\t\treturn this.a - o.a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\td = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((d | n) == 0)\n\t\t\t\tbreak;\n\t\t\taer = new AER[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\taer[i] = new AER(scanner.nextInt(), scanner.nextInt(),\n\t\t\t\t\t\tscanner.nextInt());\n\t\t\t}\n\t\t\tdp = new int[d + 1][101];\n\t\t\tfor (int[] dpp : dp)\n\t\t\t\tArrays.fill(dpp, INF);\n\t\t\tPriorityQueue<AER> pq = new PriorityQueue<AER>();\n\t\t\tpq.offer(new AER(d, 0, 0));\n\t\t\tans = INF;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tAER now = pq.poll();\n\t\t\t\tif (now.a == 0) {\n\t\t\t\t\tans = Math.min(ans, now.r);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ans <= now.r)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (AER a : aer) {\n\t\t\t\t\tif (now.e < a.r)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nhp = Math.max(0, now.a - a.a);\n\t\t\t\t\tint nexp = Math.min(100, now.e + a.e);\n\t\t\t\t\tif (now.a == nhp && now.e == nexp)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[nhp][nexp] < now.r + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[nhp][nexp] = now.r + 1;\n\t\t\t\t\tpq.offer(new AER(nhp, nexp, now.r + 1));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans == INF ? \"NA\" : ans);\n\t\t}\n\t}\n\n\tint d, n;\n\tint[][] dp;\n\tint INF = 1 << 30;\n\tAER[] aer;\n\tint ans;\n\n\tclass AER implements Comparable<AER> {\n\t\tint a, e, r;\n\n\t\tpublic AER(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"AER [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(AER o) {\n\t\t\treturn this.a - o.a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic String[] s = new String[] {\"\",\"Man\",\"Oku\",\"Cho\",\"Kei\",\"Gai\",\"Jo\",\"Jou\",\"Ko\",\"Kan\",\"Sei\",\"Sai\",\"Gok\",\"Ggs\",\"Asg\",\"Nyt\",\"Fks\",\"Mts\"};\n\tstatic int INF = 2 << 25;\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint d = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(d == 0 && n == 0) break;\n\t\t\tint[] a = new int[n];\n\t\t\tint[] e = new int[n];\n\t\t\tint[] r = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\te[i] = sc.nextInt();\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[][] dp = new int[d+1][101];\n\t\t\tfor(int i = d; i >= 0; i--) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[d][0] = 0;\n\t\t\tfor(int i = d; i >= 0; i--) {\n\t\t\t\tfor(int j = 0; j <= 100; j++) {\n\t\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\t\tif(j >= r[k]) {\n\t\t\t\t\t\t\tdp[Math.max(0, i - a[k])][Math.min(j + e[k], 100)] = Math.min(dp[Math.max(0, i - a[k])][Math.min(j + e[k], 100)], dp[i][j] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int i = 0; i < 101; i++) {\n\t\t\t\tmin = Math.min(min, dp[0][i]);\n\t\t\t}\n\t\t\tif(min == INF) {\n\t\t\t\tout.println(\"NA\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(min);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t\t\n\t}\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tpublic int nextInt() {\n\t\treturn (int)nextLong();\n\t}\n \n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n */\npublic class Main {\n\n\tstatic int[] A;\n\tstatic int[] E;\n\tstatic int[] R;\n\tstatic int min;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint D, N;\n\t\t\tD = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tN = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((D | N) == 0) break;\n\n\t\t\tA = new int[N];\n\t\t\tE = new int[N];\n\t\t\tR = new int[N];\n\t\t\tmin = Integer.MAX_VALUE;\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\t\t\t\tA[i] = parseInt(words[0]);\n\t\t\t\tE[i] = parseInt(words[1]);\n\t\t\t\tR[i] = parseInt(words[2]);\n\t\t\t}\n\n\t\t\tboolean possible = false;\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (R[i] == 0 && E[i] > 0) {\n\t\t\t\t\tpossible = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (possible && A[i] > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (possible) {\n\t\t\t\trec(D, 0, 0);\n\t\t\t\tSystem.out.println(min);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tstatic void rec(int d, int e, int c) {\n\n\t\tif (c >= min && d > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (d <= 0) {\n\t\t\tmin = Math.min(min, c);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 0; i < A.length; i++) {\n\t\t\tif (R[i] <= e) {\n\t\t\t\trec(d - A[i], e + E[i], c + 1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\td = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((d | n) == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[n];\n\t\t\te = new int[n];\n\t\t\tr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = scanner.nextInt();\n\t\t\t\te[i] = scanner.nextInt();\n\t\t\t\tr[i] = scanner.nextInt();\n\t\t\t}\n\t\t\tmemo = new int[d + 1][101];\n\t\t\tfor (int[] m : memo)\n\t\t\t\tArrays.fill(m, -1);\n\t\t\tint ans = rec(d, 0);\n\t\t\tSystem.out.println(ans == INF ? \"NA\" : ans);\n\t\t}\n\n\t}\n\n\tprivate int rec(int hp, int exp) {\n\t\tif (hp == 0)\n\t\t\treturn 0;\n\t\tif (memo[hp][exp] >= 0)\n\t\t\treturn memo[hp][exp];\n\t\tint res = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (exp >= r[i]) {\n\t\t\t\tint nhp = Math.max(0, hp - a[i]);\n\t\t\t\tint nexp = Math.min(100, exp + e[i]);\n\t\t\t\tif (hp == nhp && exp == nexp)\n\t\t\t\t\tcontinue;\n\t\t\t\tres = Math.min(res, rec(nhp, nexp) + 1);\n\t\t\t}\n\t\t}\n\n\t\treturn memo[hp][exp] = res;\n\t}\n\n\tint d, n;\n\tint[] a, e, r;\n\tint[][] memo;\n\tint INF = 1 << 30;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\td = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((d | n) == 0)\n\t\t\t\tbreak;\n\t\t\taer = new AER[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\taer[i] = new AER(scanner.nextInt(), scanner.nextInt(),\n\t\t\t\t\t\tscanner.nextInt());\n\t\t\t}\n\t\t\tdp = new int[d + 1][101];\n\t\t\tfor (int[] dpp : dp)\n\t\t\t\tArrays.fill(dpp, INF);\n\t\t\tPriorityQueue<AER> pq = new PriorityQueue<AER>();\n\t\t\tpq.offer(new AER(d, 0, 0));\n\t\t\tans = INF;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tAER now = pq.poll();\n\t\t\t\tif (now.a == 0) {\n\t\t\t\t\tans = Math.min(ans, now.r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (AER a : aer) {\n\t\t\t\t\tif (now.e < a.r)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nhp = Math.max(0, now.a - a.a);\n\t\t\t\t\tint nexp = Math.min(100, now.e + a.e);\n\t\t\t\t\tif (now.a == nhp && now.e == nexp)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[nhp][nexp] <= now.r + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[nhp][nexp] = now.r + 1;\n\t\t\t\t\tpq.offer(new AER(nhp, nexp, now.r + 1));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans == INF ? \"NA\" : ans);\n\t\t}\n\t}\n\n\tint d, n;\n\tint[][] dp;\n\tint INF = 1 << 30;\n\tAER[] aer;\n\tint ans;\n\n\tclass AER implements Comparable<AER> {\n\t\tint a, e, r;\n\n\t\tpublic AER(int a, int e, int r) {\n\t\t\tsuper();\n\t\t\tthis.a = a;\n\t\t\tthis.e = e;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"AER [a=\" + a + \", e=\" + e + \", r=\" + r + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(AER o) {\n\t\t\tif (this.r == o.r)\n\t\t\t\treturn this.a - o.a;\n\t\t\treturn this.r - o.r;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int a { get; set; }\n    public int e { get; set; }\n    public int r { get; set; }\n}\n\npublic class P2\n{\n    public int e { get; set; }\n    public int time { get; set; }\n    public int d { get; set; }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var d = int.Parse(line[0]);\n            var n = int.Parse(line[1]);\n            if (d == 0 && n == 0) break;\n            var ps = new P[n];\n            for (int i = 0; i < n; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                ps[i] = new P { a = int.Parse(line[0]), e = int.Parse(line[1]), r = int.Parse(line[2]) };\n            }\n            ps = ps.OrderBy(x => x.r).ToArray();\n            getAns(d, n, ps);\n        }\n    }\n    static void getAns(int d, int n, P[] ps)\n    {\n        var map = new int[d + 1, 101];\n        for (int i = 0; i < d + 1; i++)\n            for (int j = 0; j < 101; j++) map[i, j] = int.MaxValue;\n        var q = new Queue<P2>();\n        for (int i = 0; i < n; i++)\n        {\n            if (ps[i].r == 0)\n            {\n                var nd =d - ps[i].a;\n                var ne =         ps[i].e;\n                q.Enqueue(new P2 { e = ps[i].e, time = 1, d = d - ps[i].a });\n                map[nd, ne] = 1;\n            }\n            else break;\n        }\n        while (q.Count() > 0)\n        {\n            var w = q.Dequeue();\n            if (w.d == 0) { Console.WriteLine(w.time); return; }\n            for (int i = 0; i < n; i++)\n            {\n                if (ps[i].r <= w.e)\n                {\n                    var ne = w.e + ps[i].e;\n                    if (ne > 100) ne = 100;\n                    var nd = w.d - ps[i].a;\n                    if (nd < 0) nd = 0;\n\n                    if ((map[nd, ne] != int.MaxValue && map[nd, ne] > w.time + 1) |\n                            (map[nd, ne] == int.MaxValue))\n                    {\n                        q.Enqueue(new P2 { e = ne, d = nd, time = w.time + 1 });\n                        map[nd, ne] = w.time + 1;\n                    }\n                }\n                else break;\n            }\n        }\n        Console.WriteLine(\"NA\");\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0288\n{\n    class Tool\n    {\n        public int Attack { get; set; }\n        public int Exp { get; set; }\n        public int Requirement { get; set; }\n        public Tool(int[] vs)\n        {\n            Attack = vs[0];\n            Exp = vs[1];\n            Requirement = vs[2];\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] dn = RArInt();\n                if (dn.Sum() == 0) break;\n\n                Tool[] tools = new Tool[dn[1]];\n                for (int i = 0; i < dn[1]; i++) tools[i] = new Tool(RArInt());\n\n                int[,] dp = new int[dn[0] + 1, 101];\n                for (int i = 0; i < dp.GetLength(0); i++)\n                {\n                    for (int j = 0; j < dp.GetLength(1); j++)\n                    {\n                        dp[i, j] = int.MaxValue;\n\n                    }\n                }\n                dp[0, 0] = 0;\n\n                int maxI = dp.GetLength(0);\n                int maxJ = dp.GetLength(1);\n\n                for (int i = 0; i < maxI; i++)\n                {\n                    for (int j = 0; j < maxJ; j++)\n                    {\n                        if (dp[i, j] == int.MaxValue) continue;\n                        foreach (var tool in tools)\n                        {\n                            if (j >= tool.Requirement)\n                            {\n                                int nextI = i + tool.Attack;\n                                int nextJ = j + tool.Exp;\n                                dp[Math.Min(nextI, maxI - 1), Math.Min(nextJ, maxJ - 1)] = Math.Min(dp[Math.Min(nextI, maxI - 1), Math.Min(nextJ, maxJ - 1)], dp[i, j] + 1);\n                            }\n                        }\n                    }\n                }\n\n                int res = int.MaxValue;\n                for (int i = 0; i < maxJ; i++)\n                {\n                    res = Math.Min(res, dp[maxI - 1, i]);\n                }\n                Console.WriteLine(res == int.MaxValue ? \"NA\" : res.ToString());\n\n            }\n\n        }\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef bfs(start_node, extra = nil)\n    return 0 if start_node.is_goal?(extra)\n    reached = Set[start_node]\n    dist = 1\n    queue = [start_node]\n    until queue.empty?\n        next_queue = []\n        until queue.empty?\n            node = queue.shift\n            node.each_next_node(extra) do |next_node|\n                return dist if next_node.is_goal?(extra)\n                next if reached.include?(next_node)\n                reached << next_node\n                next_queue << next_node\n            end\n        end\n        dist += 1\n        queue = next_queue\n    end\n    return nil\nend\n\nclass Array\n    def is_goal?(weapons)\n        self[0] <= 0\n    end\n\n    def each_next_node(weapons)\n        d, t = self\n        weapons.each do |a, e, r|\n            next if r > t\n            yield [d - a, t + e]\n        end\n    end\nend\n\nloop do\n    d, n = gets.split.map(&:to_i)\n    break if n == 0\n    weapons = (1..n).map { gets.split.map(&:to_i) }\n    puts bfs([d, 0], weapons) || 'NA'\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef bfs(start_node, extra = nil)\n    return 0 if start_node.is_goal?(extra)\n    reached = Set[start_node]\n    dist = 1\n    queue = [start_node]\n    until queue.empty?\n        next_queue = []\n        until queue.empty?\n            node = queue.shift\n            node.each_next_node(extra) do |next_node|\n                return dist if next_node.is_goal?(extra)\n                next if reached.include?(next_node)\n                reached << next_node\n                next_queue << next_node\n            end\n        end\n        dist += 1\n        queue = next_queue\n    end\n    return nil\nend\n\nclass Array\n    def is_goal?(extra)\n        self[0] <= 0\n    end\n\n    def each_next_node(valid_weapons)\n        d, t = self\n        (valid_weapons[t] || []).each do |a, e|\n            yield [d - a, t + e]\n        end\n    end\nend\n\nloop do\n    d, n = gets.split.map(&:to_i)\n    break if n == 0\n    weapons = (1..n).map { gets.split.map(&:to_i) }\n    weapons.sort_by!(&:last)\n    valid_weapons = {}\n    (0..weapons[-1][2]).each do |t|\n        l = weapons.select {|a, e, r| r <= t}\n        l.map! {|a, e, _| [a, e]}\n        l.uniq!\n        l = l.select {|a1, e1| l.all?{|a2, e2| (a1 == a2 && e1 == e2) || (a1 > a2 || e1 > e2)}}\n        valid_weapons[t] = l\n    end\n    puts bfs([d, 0], valid_weapons) || 'NA'\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef bfs(start_node, extra = nil)\n    return 0 if start_node.is_goal?(extra)\n    reached = Set[start_node]\n    dist = 1\n    queue = [start_node]\n    until queue.empty?\n        next_queue = []\n        until queue.empty?\n            node = queue.shift\n            node.each_next_node(extra) do |next_node|\n                return dist if next_node.is_goal?(extra)\n                next if reached.include?(next_node)\n                reached << next_node\n                next_queue << next_node\n            end\n        end\n        dist += 1\n        queue = next_queue\n    end\n    return nil\nend\n\nclass Array\n    def is_goal?(weapons)\n        self[0] <= 0\n    end\n\n    def each_next_node(weapons)\n        d, t = self\n        weapons.each do |a, e, r|\n            break if r > t\n            nt = t + e\n            max = weapons[-1][2]\n            nt = max if nt > max\n            yield [d - a, nt]\n        end\n    end\nend\n\nloop do\n    d, n = gets.split.map(&:to_i)\n    break if n == 0\n    weapons = (1..n).map { gets.split.map(&:to_i) }\n    weapons.sort_by!(&:last)\n    puts bfs([d, 0], weapons) || 'NA'\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef bfs(start_node, extra = nil)\n    return 0 if start_node.is_goal?(extra)\n    reached = Set[start_node]\n    dist = 1\n    queue = [start_node]\n    until queue.empty?\n        next_queue = []\n        until queue.empty?\n            node = queue.shift\n            node.each_next_node(extra) do |next_node|\n                return dist if next_node.is_goal?(extra)\n                next if reached.include?(next_node)\n                reached << next_node\n                next_queue << next_node\n            end\n        end\n        dist += 1\n        queue = next_queue\n    end\n    return nil\nend\n\nclass Array\n    def is_goal?(extra)\n        self[0] <= 0\n    end\n\n    def each_next_node(extra)\n        d, t = self\n        (extra[:valid_weapons][t] || []).each do |a, e|\n            ne = t + e\n            ne = extra[:max_e] if ne > extra[:max_e]\n            yield [d - a, ne]\n        end\n    end\nend\n\nloop do\n    d, n = gets.split.map(&:to_i)\n    break if n == 0\n    weapons = (1..n).map { gets.split.map(&:to_i) }\n    weapons.sort_by!(&:last)\n    valid_weapons = {}\n    (0..weapons[-1][2]).each do |t|\n        l = weapons.select {|a, e, r| r <= t}\n        l.map! {|a, e, _| [a, e]}\n        l.uniq!\n        l = l.select {|a1, e1| l.all?{|a2, e2| (a1 == a2 && e1 == e2) || (a1 > a2 || e1 > e2)}}\n        valid_weapons[t] = l\n    end\n    puts bfs([d, 0], {:valid_weapons => valid_weapons, :max_e => weapons[-1][2]}) || 'NA'\nend\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n  d,n=map(int,input().split())\n  if d+n==0: break\n  a,e,r=zip(*list(map(int,input().split()) for _ in range(n)))\n  \n  m=max(e+r)\n  # dp[残り耐久力][経験値]=最小回数\n  dp=[[float(\"inf\")]*(m+1) for _ in range(d+1)]\n  dp[d][0]=0\n  for i in reversed(range(d+1)):\n    for j in range(m+1):\n      for k in range(n):\n        if r[k]<=j:\n          u,v=max(i-a[k],0),min(j+e[k],m)\n          dp[u][v]=min(dp[u][v],dp[i][j]+1)\n  \n  res=min(dp[0])\n  print(res if res<float(\"inf\") else \"NA\")"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 20\n\ndef search(item_lst):\n  visited = {}\n  visited[(0, 0)] = True\n  que = []\n  heappush(que, (0, 0, 0))\n  while que:\n    score, a, e = heappop(que)\n    for da, de in item_lst[e]:\n      na = a + da\n      if na == d:\n        print(score + 1)\n        return True\n      ne = e + de\n      if ne > 100:\n        ne = 100\n      \n      if (na, ne) not in visited:\n        visited[(na, ne)] = True\n        heappush(que, (score + 1, na, ne))\n  \n  print(\"NA\")\n  return False\ndef main():\n  while True:\n    d, n = map(int, input().split())\n    if d == 0:\n      break\n    item_lst = [[] for _ in range(101)]\n    for _ in range(n):\n      a, e, r = map(int, input().split())\n      for i in range(r, 101):\n        item_lst[i].append((a, e))\n    search(item_lst)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 20\n\ndef search(item_lst):\n  visited = {}\n  visited[(0, 0)] = True\n  que = []\n  heappush(que, (0, 0, 0))\n  while que:\n    score, a, e = heappop(que)\n    for da, de in item_lst[e]:\n      na, ne = min(d, a + da), min(100, e + de)\n      if na == d:\n        print(score + 1)\n        return True\n\n      if (na, ne) not in visited:\n        visited[(na, ne)] = True\n        heappush(que, (score + 1, na, ne))\n  \n  print(\"NA\")\n  return False\n\nwhile True:\n  d, n = map(int, input().split())\n  if d == 0:\n    break\n  item_lst = [[] for _ in range(101)]\n  for _ in range(n):\n    a, e, r = map(int, input().split())\n    for i in range(r, 101):\n      item_lst[i].append((a, e))\n  search(item_lst)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 20\ndef search(item_lst):\n  dp = [[INF] * 101 for _ in range(101)]\n  dp[0][0] = 0\n  que = []\n  heappush(que, (0, 0, 0))\n  while que:\n    score, a, e = heappop(que)\n    for da, de in item_lst[e]:\n      na, ne = min(d, a + da), min(100, e + de)\n      if na == d:\n        print(score + 1)\n        return True\n\n      if dp[na][ne] > score + 1:\n        dp[na][ne] = score + 1\n        heappush(que, (score + 1, na, ne))\n  \n  print(\"NA\")\n  return False\n\nwhile True:\n  d, n = map(int, input().split())\n  if d == 0:\n    break\n  item_lst = [[] for _ in range(101)]\n  for _ in range(n):\n    a, e, r = map(int, input().split())\n    for i in range(r, 101):\n      item_lst[i].append((a, e))\n  search(item_lst)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef main():\n    while 1:\n        D, N = map(int, readline().split())\n        if D == N == 0:\n            break\n        P = [list(map(int, readline().split())) for i in range(N)]\n        P.sort(key=lambda x: x[2])\n        INF = 10**9\n\n        memo = [[INF]*101 for i in range(D+1)]\n        memo[D][0] = 0\n        for i in range(D, 0, -1):\n            P0 = [(max(i-a, 0), e, r) for a, e, r in P]\n            for j, v in ((j, e+1) for j, e in enumerate(memo[i]) if e < INF):\n                for A0, e, r in P0:\n                    if j < r:\n                        break\n                    E0 = min(j+e, 100)\n                    if v < memo[A0][E0]:\n                        memo[A0][E0] = v\n        res = min(memo[0])\n        if res == INF:\n            write(\"NA\\n\")\n        else:\n            write(\"%d\\n\" % res)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 20\n\ndef search(item_lst, d):\n  visited = {}\n  visited[(0, 0)] = True\n  que = []\n  heappush(que, (0, 0, 0))\n  while que:\n    score, a, e = heappop(que)\n    for da, de in item_lst[e]:\n      na = a + da\n      if na >= d:\n        print(score + 1)\n        return True\n      ne = e + de\n      if ne > 100:\n        ne = 100\n      \n      if (na, ne) not in visited:\n        visited[(na, ne)] = True\n        heappush(que, (score + 1, na, ne))\n  \n  print(\"NA\")\n  return False\n\ndef main():\n  while True:\n    d, n = map(int, input().split())\n    if d == 0:\n      break\n    item_lst = [[] for _ in range(101)]\n    for _ in range(n):\n      a, e, r = map(int, input().split())\n      for i in range(r, 101):\n        item_lst[i].append((a, e))\n    search(item_lst, d)\nmain()\n"
  }
]