[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\ntypedef struct {\n    int a;\n    int e;\n    int r;\n} Tool;\n\nint minStrikes(int D, Tool tools[], int N) {\n    int dp[1001] = {0}; // dp[exp] = min strikes to reach 'exp' experience\n    for (int i = 1; i <= 1000; i++) {\n        dp[i] = INT_MAX;\n    }\n    dp[0] = 0;\n\n    int min_strikes = INT_MAX;\n    int updated = 1;\n\n    while (updated) {\n        updated = 0;\n        for (int i = 0; i < N; i++) {\n            for (int exp = 0; exp <= 1000; exp++) {\n                if (dp[exp] != INT_MAX && exp >= tools[i].r) {\n                    int new_exp = exp + tools[i].e;\n                    if (new_exp > 1000) new_exp = 1000;\n                    if (dp[new_exp] > dp[exp] + 1) {\n                        dp[new_exp] = dp[exp] + 1;\n                        updated = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int exp = 0; exp <= 1000; exp++) {\n        if (dp[exp] != INT_MAX) {\n            for (int i = 0; i < N; i++) {\n                if (exp >= tools[i].r) {\n                    int strikes = dp[exp] + (D + tools[i].a - 1) / tools[i].a;\n                    if (strikes < min_strikes) {\n                        min_strikes = strikes;\n                    }\n                }\n            }\n        }\n    }\n\n    return min_strikes;\n}\n\nint main() {\n    int D, N;\n    scanf(\"%d %d\", &D, &N);\n    Tool tools[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &tools[i].a, &tools[i].e, &tools[i].r);\n    }\n    printf(\"%d\\n\", minStrikes(D, tools, N));\n    return 0;\n}",
    "timestamp": "2025-08-05 18:40:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeCutting {\n    public static int minimumStrikes(int treeDurability, int[][] tools) {\n        int strikes = 0;\n        int experience = 0;\n        \n        while (treeDurability > 0) {\n            boolean toolUsed = false;\n            \n            for (int[] tool : tools) {\n                int reduction = tool[0];\n                int gainedExp = tool[1];\n                int requiredExp = tool[2];\n                \n                if (experience >= requiredExp) {\n                    treeDurability -= reduction;\n                    experience += gainedExp;\n                    strikes++;\n                    toolUsed = true;\n                    break;\n                }\n            }\n            \n            if (!toolUsed) {\n                int maxExpTool = -1;\n                int maxExp = -1;\n                \n                for (int i = 0; i < tools.length; i++) {\n                    if (tools[i][1] > maxExp) {\n                        maxExp = tools[i][1];\n                        maxExpTool = i;\n                    }\n                }\n                \n                if (maxExpTool == -1) {\n                    return -1;\n                }\n                \n                experience += tools[maxExpTool][1];\n            }\n        }\n        \n        return strikes;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int treeDurability = scanner.nextInt();\n        int numTools = scanner.nextInt();\n        \n        int[][] tools = new int[numTools][3];\n        \n        for (int i = 0; i < numTools; i++) {\n            tools[i][0] = scanner.nextInt(); // Durability reduction\n            tools[i][1] = scanner.nextInt(); // Experience gained\n            tools[i][2] = scanner.nextInt(); // Required experience\n        }\n        \n        int result = minimumStrikes(treeDurability, tools);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:40:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Tool {\n    int a;\n    int e;\n    int r;\n};\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n    vector<Tool> tools(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> tools[i].a >> tools[i].e >> tools[i].r;\n    }\n\n    vector<vector<int>> dp(D + 1, vector<int>(10001, INT_MAX));\n    dp[D][0] = 0;\n    queue<pair<int, int>> q;\n    q.push({D, 0});\n\n    int min_strikes = INT_MAX;\n\n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n        int current_d = current.first;\n        int current_exp = current.second;\n        int current_strikes = dp[current_d][current_exp];\n\n        if (current_d <= 0) {\n            min_strikes = min(min_strikes, current_strikes);\n            continue;\n        }\n\n        for (const auto& tool : tools) {\n            if (current_exp >= tool.r) {\n                int new_d = current_d - tool.a;\n                int new_exp = current_exp + tool.e;\n                new_d = max(new_d, 0);\n                if (new_d > D) continue;\n                if (new_exp > 10000) new_exp = 10000;\n\n                if (current_strikes + 1 < dp[new_d][new_exp]) {\n                    dp[new_d][new_exp] = current_strikes + 1;\n                    q.push({new_d, new_exp});\n                }\n            }\n        }\n    }\n\n    cout << min_strikes << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_TOOLS 100\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n\n    int a[MAX_TOOLS], e[MAX_TOOLS], r[MAX_TOOLS];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &a[i], &e[i], &r[i]);\n    }\n\n    int min_strikes = INT_MAX;\n    \n    for (int mask = 0; mask < (1 << N); mask++) {\n        int strikes = 0;\n        int exp = 0;\n        int remaining_durability = D;\n        int valid_solution = 1;\n\n        while (remaining_durability > 0) {\n            int best_tool = -1;\n            \n            for (int i = 0; i < N; i++) {\n                if (mask & (1 << i)) {\n                    if (exp >= r[i] && (best_tool == -1 || a[best_tool] > a[i])) {\n                        best_tool = i;\n                    }\n                }\n            }\n\n            if (best_tool == -1) {\n                valid_solution = 0;\n                break;\n            }\n\n            remaining_durability -= a[best_tool];\n            exp += e[best_tool];\n            strikes++;\n        }\n\n        if (valid_solution && strikes < min_strikes) {\n            min_strikes = strikes;\n        }\n    }\n\n    printf(\"%d\\n\", min_strikes == INT_MAX ? -1 : min_strikes);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <queue>\nusing namespace std;\n\nint cutTree(int D, vector<int>& a, vector<int>& e, vector<int>& r) {\n    int N = a.size();\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;\n    \n    for (int i = 0; i < N; i++) {\n        pq.push({0, {0, i}});\n    }\n    \n    while (!pq.empty()) {\n        int strikes = pq.top().first;\n        int experience = pq.top().second.first;\n        int tool = pq.top().second.second;\n        pq.pop();\n        \n        if (experience >= r[tool]) {\n            int remainingDurability = D - strikes * a[tool];\n            \n            if (remainingDurability <= 0) {\n                return strikes;\n            }\n            \n            for (int i = 0; i < N; i++) {\n                int newStrikes = strikes + 1;\n                int newExperience = experience + e[tool];\n                pq.push({newStrikes, {newExperience, i}});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int D, N;\n    cin >> D >> N;\n    \n    vector<int> a(N), e(N), r(N);\n    for (int i = 0; i < N; i++) {\n        cin >> a[i] >> e[i] >> r[i];\n    }\n    \n    int result = cutTree(D, a, e, r);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Tool {\n    int a, e, r;\n    Tool(int a, int e, int r) {\n        this.a = a;\n        this.e = e;\n        this.r = r;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int D = scanner.nextInt();\n        int N = scanner.nextInt();\n        Tool[] tools = new Tool[N];\n        for (int i = 0; i < N; i++) {\n            int a = scanner.nextInt();\n            int e = scanner.nextInt();\n            int r = scanner.nextInt();\n            tools[i] = new Tool(a, e, r);\n        }\n\n        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        queue.add(new int[]{0, 0}); // strikes, exp\n        boolean[][] visited = new boolean[1001][1001]; // Assuming max exp and strikes constraints\n\n        int result = -1;\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int strikes = current[0];\n            int exp = current[1];\n\n            if (visited[strikes][exp]) continue;\n            visited[strikes][exp] = true;\n\n            if (D <= 0) {\n                result = strikes;\n                break;\n            }\n\n            for (Tool tool : tools) {\n                if (exp >= tool.r) {\n                    int newExp = exp + tool.e;\n                    int newD = D - tool.a;\n                    if (newD <= 0) {\n                        result = strikes + 1;\n                        queue.clear();\n                        break;\n                    }\n                    if (!visited[strikes + 1][newExp]) {\n                        queue.add(new int[]{strikes + 1, newExp});\n                    }\n                }\n            }\n            if (result != -1) break;\n        }\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 18:41:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_strikes_to_cut_tree(D, tools):\n    import heapq\n\n    strikes = 0\n    current_exp = 0\n    pq = []  # max-heap based on efficiency: (ei/ai, ei, ai, ri)\n\n    # prioritize tools initially which have no experience requirement\n    for ei, ai, ri in tools:\n        if ri == 0:\n            heapq.heappush(pq, (-ei/ai, ei, ai, ri))\n\n    while D > 0 and pq:\n        # choose the best available tool\n        _, ei, ai, _ = heapq.heappop(pq)\n        \n        strikes += 1\n        D -= ai\n        current_exp += ei\n        \n        # update tool availability based on new experience points\n        for ei2, ai2, ri2 in tools:\n            if current_exp >= ri2:\n                if (-ei2/ai2, ei2, ai2, ri2) not in pq:\n                    heapq.heappush(pq, (-ei2/ai2, ei2, ai2, ri2))\n\n    return strikes if D <= 0 else -1\n\n# Example Usage\nD = 10  # Durability\ntools = [\n    (2, 3, 0),  # (ei, ai, ri)\n    (5, 4, 5),\n    (3, 6, 0)\n]\nprint(min_strikes_to_cut_tree(D, tools))",
    "timestamp": "2025-08-13 00:32:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.PriorityQueue;\n\nclass Tool {\n    int durabilityDecrease;\n    int experienceGain;\n    int requiredExperience;\n\n    Tool(int durabilityDecrease, int experienceGain, int requiredExperience) {\n        this.durabilityDecrease = durabilityDecrease;\n        this.experienceGain = experienceGain;\n        this.requiredExperience = requiredExperience;\n    }\n}\n\npublic class TreeCutting {\n    public static int minStrikesToCutDownTree(int D, Tool[] tools) {\n        PriorityQueue<Tool> pq = new PriorityQueue<>((a, b) -> b.durabilityDecrease - a.durabilityDecrease);\n        for (Tool tool : tools) {\n            pq.offer(tool);\n        }\n\n        int strikes = 0;\n        int currentExperience = 0;\n        \n        while (D > 0) {\n            int bestDecrease = 0;\n            Tool bestTool = null;\n            for (Tool tool : pq) {\n                if (currentExperience >= tool.requiredExperience && tool.durabilityDecrease > bestDecrease) {\n                    bestDecrease = tool.durabilityDecrease;\n                    bestTool = tool;\n                }\n            }\n            \n            if (bestTool != null) {\n                D -= bestTool.durabilityDecrease;\n                currentExperience += bestTool.experienceGain;\n                strikes++;\n            } else {\n                break;\n            }\n        }\n\n        return strikes;\n    }\n\n    public static void main(String[] args) {\n        Tool[] tools = {\n            new Tool(3, 2, 0),\n            new Tool(5, 3, 4),\n            new Tool(8, 6, 10)\n        };\n        int D = 23;\n\n        System.out.println(minStrikesToCutDownTree(D, tools)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 00:33:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\ntypedef struct {\n    int a;\n    int e;\n    int r;\n} Tool;\n\nint minStrikes(int D, int N, Tool tools[]) {\n    int dp[D+1];\n    for (int i = 0; i <= D; ++i) {\n        dp[i] = INT_MAX; // Initialize dp array with infinity\n    }\n    dp[D] = 0; // No strikes needed if durability is already 0\n\n    for (int i = D; i >= 0; --i) {\n        if (dp[i] == INT_MAX) continue;\n        for (int j = 0; j < N; ++j) {\n            if (dp[i] >= tools[j].r) {\n                int newDurability = i - tools[j].a;\n                int newExperience = dp[i] + tools[j].e;\n                if (newDurability <= 0) {\n                    return dp[i] + 1;\n                }\n                dp[newDurability] = dp[newDurability] > (dp[i] + 1) ? (dp[i] + 1) : dp[newDurability];\n            }\n        }\n    }\n    return -1; // If not possible to cut down the tree\n}\n\nint main() {\n    int D, N;\n    scanf(\"%d %d\", &D, &N);\n    Tool tools[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d %d\", &tools[i].a, &tools[i].e, &tools[i].r);\n    }\n    int result = minStrikes(D, N, tools);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 00:33:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_strikes_to_cut_tree(D, tools):\n    # Sort tools by requirement and initialize variables\n    tools.sort(key=lambda x: x[2])\n    current_exp = 0\n    total_strikes = 0\n    \n    while D > 0:\n        valid_tools = [tool for tool in tools if tool[2] <= current_exp]\n        \n        if not valid_tools:\n            return -1  # Cannot cut the tree\n        \n        # Choose tool with maximum damage\n        best_tool = max(valid_tools, key=lambda x: x[0] / x[1])\n        \n        # Strike with the tool\n        D -= best_tool[0]\n        current_exp += best_tool[1]\n        total_strikes += 1\n    \n    return total_strikes\n\n# Input parsing\nN, D = map(int, input().split())\ntools = []\nfor _ in range(N):\n    a, e, r = map(int, input().split())\n    tools.append((a, e, r))\n\n# Output result\nresult = min_strikes_to_cut_tree(D, tools)\nprint(result)",
    "timestamp": "2025-08-13 00:33:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef min_strikes(D, tools):\n    max_ri = max(tool[2] for tool in tools)\n    dp = [[float('inf')] * (max_ri + 1) for _ in range(D + 1)]\n    dp[0][0] = 0  # 0 strikes needed for 0 durability and 0 exp\n    \n    heap = []\n    heapq.heappush(heap, (0, 0, 0))  # (strikes, durability, exp)\n    \n    while heap:\n        strikes, current_d, current_exp = heapq.heappop(heap)\n        if current_d >= D:\n            return strikes\n        if strikes > dp[min(current_d, D)][min(current_exp, max_ri)]:\n            continue\n        for a, e, r in tools:\n            if current_exp >= r:\n                new_d = current_d + a\n                new_exp = current_exp + e\n                new_strikes = strikes + 1\n                new_d_clipped = min(new_d, D)\n                new_exp_clipped = min(new_exp, max_ri)\n                if new_strikes < dp[new_d_clipped][new_exp_clipped]:\n                    dp[new_d_clipped][new_exp_clipped] = new_strikes\n                    heapq.heappush(heap, (new_strikes, new_d_clipped, new_exp_clipped))\n    return -1\n\n# Example usage:\n# D = 10\n# tools = [(5, 1, 0), (2, 3, 1), (3, 2, 2)]\n# print(min_strikes(D, tools))",
    "timestamp": "2025-08-13 00:33:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nstruct Tool {\n    int ai, ei, ri;\n};\n\nint main() {\n    int N, D;\n    cin >> N >> D;\n    vector<Tool> tools(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> tools[i].ai >> tools[i].ei >> tools[i].ri;\n    }\n\n    vector<int> dp(D + 1, INT_MAX);\n    dp[D] = 0;\n\n    for (int durability = D; durability >= 0; --durability) {\n        if (dp[durability] == INT_MAX) continue;\n\n        for (const auto& tool : tools) {\n            if (dp[durability] >= tool.ri) {\n                int new_durability = max(0, durability - tool.ai);\n                dp[new_durability] = min(dp[new_durability], dp[durability] + tool.ei);\n            }\n        }\n    }\n\n    int min_strikes = INT_MAX;\n    for (int i = 0; i <= D; ++i) {\n        if (dp[i] != INT_MAX) {\n            min_strikes = min(min_strikes, dp[i]);\n        }\n    }\n\n    cout << min_strikes << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:54:46"
  }
]