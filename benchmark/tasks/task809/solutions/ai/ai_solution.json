[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_H 1005\n#define MAX_W 1005\n\nint grid[MAX_H][MAX_W];\nint walls[MAX_H * MAX_W][2];\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &walls[i][0], &walls[i][1]);\n    }\n\n    grid[1][1] = 1;\n\n    for (int r = 1; r <= H; r++) {\n        for (int c = 1; c <= W; c++) {\n            int is_wall = 0;\n            for (int k = 0; k < N; k++) {\n                if (walls[k][0] == r && walls[k][1] == c) {\n                    is_wall = 1;\n                    break;\n                }\n            }\n\n            if (is_wall) continue;\n\n            if (r > 1 && !is_wall) {\n                grid[r][c] += grid[r-1][c];\n                grid[r][c] %= MOD;\n            }\n\n            if (c > 1 && !is_wall) {\n                grid[r][c] += grid[r][c-1];\n                grid[r][c] %= MOD;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", grid[H][W]);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_HW 200000\n\ntypedef struct {\n    int r, c;\n} Point;\n\nint fact[MAX_HW * 2 + 1];\nint inv_fact[MAX_HW * 2 + 1];\n\nint mod_pow(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            res = (long long)res * a % MOD;\n        }\n        a = (long long)a * a % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid precompute_factorials() {\n    fact[0] = 1;\n    for (int i = 1; i <= MAX_HW * 2; i++) {\n        fact[i] = (long long)fact[i - 1] * i % MOD;\n    }\n    inv_fact[MAX_HW * 2] = mod_pow(fact[MAX_HW * 2], MOD - 2);\n    for (int i = MAX_HW * 2 - 1; i >= 0; i--) {\n        inv_fact[i] = (long long)inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b) return 0;\n    return (long long)fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD;\n}\n\nint path_count(int r1, int c1, int r2, int c2) {\n    int dr = r2 - r1;\n    int dc = c2 - c1;\n    return comb(dr + dc, dr);\n}\n\nint compare_points(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->r != p2->r) return p1->r - p2->r;\n    return p1->c - p2->c;\n}\n\nint main() {\n    precompute_factorials();\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n    Point walls[N + 1];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &walls[i].r, &walls[i].c);\n    }\n    walls[N].r = H;\n    walls[N].c = W;\n    N++;\n    qsort(walls, N, sizeof(Point), compare_points);\n\n    int dp[N];\n    for (int i = 0; i < N; i++) {\n        dp[i] = path_count(1, 1, walls[i].r, walls[i].c);\n        for (int j = 0; j < i; j++) {\n            if (walls[j].r <= walls[i].r && walls[j].c <= walls[i].c) {\n                int subtract = (long long)dp[j] * path_count(walls[j].r, walls[j].c, walls[i].r, walls[i].c) % MOD;\n                dp[i] = (dp[i] - subtract + MOD) % MOD;\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[N - 1]);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n\nvector<long long> fact, inv_fact;\n\nvoid precompute(int max_n) {\n    fact.resize(max_n + 1);\n    inv_fact.resize(max_n + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= max_n; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n    inv_fact[max_n] = modinv(fact[max_n], MOD);\n    for (int i = max_n - 1; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;\n    }\n}\n\nlong long comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b) return 0;\n    return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD;\n}\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    vector<pair<int, int>> walls(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> walls[i].first >> walls[i].second;\n    }\n    walls.emplace_back(H, W);\n    sort(walls.begin(), walls.end());\n    \n    int max_n = H + W;\n    precompute(max_n);\n    \n    vector<long long> dp(N + 1);\n    for (int i = 0; i <= N; ++i) {\n        int r = walls[i].first, c = walls[i].second;\n        dp[i] = comb(r + c - 2, r - 1);\n        for (int j = 0; j < i; ++j) {\n            int rj = walls[j].first, cj = walls[j].second;\n            if (rj <= r && cj <= c) {\n                long long sub = dp[j] * comb(r - rj + c - cj, r - rj) % MOD;\n                dp[i] = (dp[i] - sub + MOD) % MOD;\n            }\n        }\n    }\n    cout << dp[N] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:00:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final long MOD = (long)1e9 + 7;\n    static long[] fact;\n    static long[] invFact;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int N = sc.nextInt();\n        List<int[]> walls = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int r = sc.nextInt();\n            int c = sc.nextInt();\n            walls.add(new int[]{r, c});\n        }\n        sc.close();\n\n        walls.sort((a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0];\n            return a[1] - b[1];\n        });\n\n        int max = H + W - 2;\n        fact = new long[max + 1];\n        invFact = new long[max + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= max; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n        invFact[max] = pow(fact[max], MOD - 2);\n        for (int i = max - 1; i >= 0; i--) {\n            invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n        }\n\n        long[] dp = new long[N + 1];\n        for (int i = 0; i <= N; i++) {\n            int r = i == N ? H : walls.get(i)[0];\n            int c = i == N ? W : walls.get(i)[1];\n            long res = comb(r + c - 2, r - 1);\n            for (int j = 0; j < i; j++) {\n                int rj = walls.get(j)[0];\n                int cj = walls.get(j)[1];\n                if (rj <= r && cj <= c) {\n                    long ways = dp[j] * comb(r - rj + c - cj, r - rj) % MOD;\n                    res = (res - ways + MOD) % MOD;\n                }\n            }\n            dp[i] = res;\n        }\n        System.out.println(dp[N]);\n    }\n\n    static long comb(int n, int k) {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n\n    static long pow(long a, long b) {\n        long res = 1;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % MOD;\n            }\n            a = a * a % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 23:00:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PathCount {\n    public static int countPaths(int H, int W, int[][] walls) {\n        final int MOD = 1_000_000_007;\n        \n        boolean[][] grid = new boolean[H+1][W+1];\n        for (int[] wall : walls) {\n            grid[wall[0]][wall[1]] = true;\n        }\n        \n        int[][] dp = new int[H+1][W+1];\n        dp[1][1] = 1;\n        \n        for (int r = 1; r <= H; r++) {\n            for (int c = 1; c <= W; c++) {\n                if (r == 1 && c == 1) continue;\n                if (grid[r][c]) {\n                    dp[r][c] = 0;\n                } else {\n                    dp[r][c] = (r > 1 ? dp[r-1][c] : 0) + (c > 1 ? dp[r][c-1] : 0);\n                    dp[r][c] %= MOD;\n                }\n            }\n        }\n        \n        return dp[H][W];\n    }\n}",
    "timestamp": "2025-08-05 23:01:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    \n    vector<vector<bool>> wall(H + 1, vector<bool>(W + 1, false));\n    for (int i = 0; i < N; i++) {\n        int r, c;\n        cin >> r >> c;\n        wall[r][c] = true;\n    }\n    \n    vector<vector<int>> dp(H + 1, vector<int>(W + 1, 0));\n    dp[1][1] = 1;\n    \n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            if (i == 1 && j == 1) continue;\n            if (wall[i][j]) continue;\n            \n            dp[i][j] = 0;\n            if (j > 1 && !wall[i][j-1]) \n                dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD;\n            if (i > 1 && !wall[i-1][j]) \n                dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\n        }\n    }\n    \n    cout << dp[H][W] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_paths(H, W, walls):\n    MOD = 10**9 + 7\n    # Create a grid initialized to zero\n    grid = [[0] * W for _ in range(H)]\n    \n    # Mark walls on grid\n    for r, c in walls:\n        grid[r - 1][c - 1] = -1\n\n    # Initialize the starting point\n    if grid[0][0] == -1:\n        return 0\n    grid[0][0] = 1\n\n    # Fill grid with paths counts\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == -1:\n                continue\n            if i > 0 and grid[i - 1][j] != -1:\n                grid[i][j] += grid[i - 1][j]\n            if j > 0 and grid[i][j - 1] != -1:\n                grid[i][j] += grid[i][j - 1]\n            grid[i][j] %= MOD\n\n    return grid[H - 1][W - 1]\n\n# Example usage:\nH = 3\nW = 3\nwalls = [(2, 2)]\nprint(count_paths(H, W, walls))  # Output: 2",
    "timestamp": "2025-08-13 13:13:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GridPaths {\n    private static final long MOD = 1000000007L;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int N = sc.nextInt();\n        \n        boolean[][] walls = new boolean[H + 1][W + 1];\n        for (int i = 0; i < N; i++) {\n            int r = sc.nextInt();\n            int c = sc.nextInt();\n            walls[r][c] = true;\n        }\n        \n        long[][] dp = new long[H + 1][W + 1];\n        dp[1][1] = 1;\n        \n        for (int r = 1; r <= H; r++) {\n            for (int c = 1; c <= W; c++) {\n                if (walls[r][c]) continue;\n                if (r > 1) dp[r][c] = (dp[r][c] + dp[r - 1][c]) % MOD;\n                if (c > 1) dp[r][c] = (dp[r][c] + dp[r][c - 1]) % MOD;\n            }\n        }\n        \n        System.out.println(dp[H][W]);\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 13:13:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n    int grid[H+1][W+1];\n    memset(grid, 0, sizeof(grid));\n\n    for (int i = 0; i < N; ++i) {\n        int r, c;\n        scanf(\"%d %d\", &r, &c);\n        grid[r][c] = -1;  // Mark the wall\n    }\n\n    grid[1][1] = 1;  // Start point\n\n    for (int i = 1; i <= H; ++i) {\n        for (int j = 1; j <= W; ++j) {\n            if (grid[i][j] == -1) {\n                grid[i][j] = 0; // Reset walls to 0 as they block path\n                continue;\n            }\n            if (i > 1) grid[i][j] = (grid[i][j] + grid[i-1][j]) % MOD;\n            if (j > 1) grid[i][j] = (grid[i][j] + grid[i][j-1]) % MOD;\n        }\n    }\n\n    printf(\"%d\\n\", grid[H][W]);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:13:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nstruct Point {\n    int r, c;\n\n    bool operator<(const Point &other) const {\n        if (r == other.r) return c < other.c;\n        return r < other.r;\n    }\n};\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    vector<Point> walls(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> walls[i].r >> walls[i].c;\n    }\n    \n    sort(walls.begin(), walls.end());\n\n    vector<vector<int>> dp(H + 1, vector<int>(W + 1, 0));\n    dp[1][1] = 1;\n\n    size_t wall_idx = 0;\n\n    for (int r = 1; r <= H; ++r) {\n        for (int c = 1; c <= W; ++c) {\n            if (r == 1 && c == 1) continue;\n\n            if (wall_idx < N && walls[wall_idx].r == r && walls[wall_idx].c == c) {\n                wall_idx++;\n                continue;\n            }\n\n            dp[r][c] = ((r > 1 ? dp[r - 1][c] : 0) + (c > 1 ? dp[r][c - 1] : 0)) % MOD;\n        }\n    }\n\n    cout << dp[H][W] << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:14:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_paths(H, W, walls):\n    MOD = 10**9 + 7\n    \n    # Create grid to track walls and path counts\n    grid = [[0] * (W+1) for _ in range(H+1)]\n    wall_set = set((r,c) for r,c in walls)\n    \n    # Initialize starting point\n    grid[1][1] = 1\n    \n    # Mark walls as impassable\n    for r, c in wall_set:\n        grid[r][c] = -1\n    \n    # Fill grid\n    for r in range(1, H+1):\n        for c in range(1, W+1):\n            # Skip starting point and walls\n            if (r == 1 and c == 1) or grid[r][c] == -1:\n                continue\n            \n            # Skip if cell is a wall\n            if grid[r][c] == -1:\n                continue\n            \n            # Add paths from left and top\n            if grid[r-1][c] > 0:\n                grid[r][c] += grid[r-1][c]\n            if grid[r][c-1] > 0:\n                grid[r][c] += grid[r][c-1]\n            \n            # Apply modulo\n            grid[r][c] %= MOD\n    \n    # Return paths to bottom-right or 0 if impossible\n    return max(0, grid[H][W])",
    "timestamp": "2025-08-13 13:14:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    H, W, N = map(int, sys.stdin.readline().split())\n    walls = set()\n    for _ in range(N):\n        r, c = map(int, sys.stdin.readline().split())\n        walls.add((r, c))\n    \n    max_n = H + W\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n    \n    walls = sorted(walls, key=lambda x: (x[0], x[1]))\n    walls.append((H, W))\n    m = len(walls)\n    dp = [0] * m\n    \n    for i in range(m):\n        r, c = walls[i]\n        dp[i] = comb(r + c - 2, r - 1)\n        for j in range(i):\n            rj, cj = walls[j]\n            if rj <= r and cj <= c:\n                dp[i] = (dp[i] - dp[j] * comb((r - rj) + (c - cj), r - rj)) % MOD\n    \n    print(dp[m-1] % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 13:14:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function numOfPaths(H, W, walls) {\n    const MOD = 1000000007;\n    \n    // Create a grid to mark walls\n    const grid = Array.from({ length: H }, () => Array(W).fill(false));\n    \n    // Mark the walls\n    for (let [r, c] of walls) {\n        grid[r - 1][c - 1] = true;\n    }\n\n    // DP table\n    const dp = Array.from({ length: H }, () => Array(W).fill(0));\n\n    // Initialize the DP table\n    if (!grid[0][0]) dp[0][0] = 1;\n    \n    // Fill the DP table\n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (grid[i][j]) continue;\n            if (i > 0) dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\n            if (j > 0) dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD;\n        }\n    }\n    \n    return dp[H - 1][W - 1];\n}",
    "timestamp": "2025-08-13 13:14:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countPaths(H, W, walls) {\n    const MOD = 1000000007;\n    const dp = Array.from({ length: H + 1 }, () => Array(W + 1).fill(0));\n    const wallSet = new Set(walls.map(wall => `${wall[0]},${wall[1]}`));\n\n    dp[1][1] = 1;\n\n    for (let r = 1; r <= H; r++) {\n        for (let c = 1; c <= W; c++) {\n            if (r === 1 && c === 1) continue;\n            if (wallSet.has(`${r},${c}`)) continue;\n\n            dp[r][c] = (\n                (r > 1 && !wallSet.has(`${r-1},${c}`) ? dp[r-1][c] : 0) +\n                (c > 1 && !wallSet.has(`${r},${c-1}`) ? dp[r][c-1] : 0)\n            ) % MOD;\n        }\n    }\n\n    return dp[H][W];\n}",
    "timestamp": "2025-08-13 13:14:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve(H, W, walls) {\n    const dp = new Array(H + 1).fill().map(() => new Array(W + 1).fill(0));\n    const isWall = new Array(H + 1).fill().map(() => new Array(W + 1).fill(false));\n    \n    for (const [r, c] of walls) {\n        isWall[r][c] = true;\n    }\n    \n    dp[1][1] = isWall[1][1] ? 0 : 1;\n    \n    for (let i = 1; i <= H; i++) {\n        for (let j = 1; j <= W; j++) {\n            if (i === 1 && j === 1) continue;\n            if (isWall[i][j]) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;\n            }\n        }\n    }\n    \n    return dp[H][W];\n}\n\n// Example usage:\n// const H = 3, W = 4;\n// const walls = [[2, 2]];\n// console.log(solve(H, W, walls));",
    "timestamp": "2025-08-13 13:15:05"
  }
]